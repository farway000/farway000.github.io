<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="xiyuan技术圈">
<meta property="og:url" content="http://techq.xyz/page/2/index.html">
<meta property="og:site_name" content="xiyuan技术圈">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xiyuan技术圈">





  
  
  <link rel="canonical" href="http://techq.xyz/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>xiyuan技术圈</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiyuan技术圈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">溪源的技术博客，技术的不断进取之路</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-技术">

    
    
    
      
    

    

    <a href="/categories/技术/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>技术</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-随笔">

    
    
    
      
    

    

    <a href="/categories/随笔/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>随笔</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-读书">

    
    
    
      
    

    

    <a href="/categories/读书/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>读书</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-管理">

    
    
    
      
    

    

    <a href="/categories/管理/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>管理</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-归档">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archives"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/10/17/技术/Golden Master Pattern ：一种在.NET Core中重构遗留代码的利器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/10/17/技术/Golden Master Pattern ：一种在.NET Core中重构遗留代码的利器/" class="post-title-link" itemprop="url">一种在.NET Core中重构遗留代码的利器</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-10-17 20:28:00" itemprop="dateCreated datePublished" datetime="2020-10-17T20:28:00+00:00">2020-10-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2021-04-25 11:04:00" itemprop="dateModified" datetime="2021-04-25T11:04:00+00:00">2021-04-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Golden-Master-Pattern-：一种在-NET-Core中重构遗留代码的利器"><a href="#Golden-Master-Pattern-：一种在-NET-Core中重构遗留代码的利器" class="headerlink" title="Golden Master Pattern ：一种在.NET Core中重构遗留代码的利器"></a>Golden Master Pattern ：一种在.NET Core中重构遗留代码的利器</h4><p>在软件开发领域中工作的任何人都将需要在旧代码中添加功能，这些功能可能是从先前的团队继承而来的，您需要对其进行紧急修复。</p>
<p>可以在文献中找到许多遗留代码的定义，我更喜欢的定义是：“通过<strong>遗留代码</strong>，我们指的是我们<strong>害怕改变</strong>的有利可图的代码”。</p>
<p>该定义包含两个基本概念：</p>
<ol>
<li>该代码必须有利可图。如果不是这样，我们将无意对其进行更改。 </li>
<li>它必须引起对修改它的恐惧，因为我们可以引入新的bug或依赖影子的东西。</li>
</ol>
<p>在以下情况下，更容易出错：</p>
<ul>
<li>测试未涵盖该代码。 </li>
<li>代码不干净；不遵守单一责任原则。 </li>
<li>该代码的设计不正确，或者随着时间的流逝其结构变得不合理：对一段代码进行更改可能会产生一些副作用。 </li>
<li>您没有时间全面了解正在修改的内容。</li>
</ul>
<p>测试是我们作为开发人员可用的强大武器。这些测试为我们提供了结果的安全性，并且是一种快速检测错误的方法。但是，我们如何测试未知的代码？构建单元测试套件将为我们提供有关该项目的深入知识，但它将使长时间保持高成本。如果我们无法测试细节，则可以使用<strong>Characterization Test</strong>，它是描述软件行为的测试。</p>
<p>在这种情况下起重要作用的<strong>模式</strong>是“ <strong>黄金大师模式”</strong>。基本思想很简单：如果我们无法深入了解，我们需要一些有关整个执行过程的指标。我们捕获正确执行的输出（stdout，图像，日志文件等），这就是我们的Golden Master，可用于预期输出。如果当前执行的输出匹配，我们可以确信我们的更改没有引入新的错误。 </p>
<p>为了展示Golden Master Pattern的用法，让我们从一个示例开始（完整的代码可以在<a href="https://github.com/ntonjeta/GoldenMasterExample" target="_blank" rel="noopener">此处</a>找到）。我们公司开发了用于命令行的游戏，包括井字游戏（该游戏的实现从<a href="https://www.c-sharpcorner.com/UploadFile/75a48f/tic-tac-toe-game-in-C-Sharp/" target="_blank" rel="noopener">此处获取</a>），我们的老板要求我们更改游戏以提供调整游戏板尺寸的能力。让我们看一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">namespace Tris</span><br><span class="line">&#123;</span><br><span class="line">    public class Game</span><br><span class="line">    &#123;</span><br><span class="line">        //making array and   </span><br><span class="line">        //by default I am providing 0-9 where no use of zero  </span><br><span class="line">        static char[] arr = &#123; &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos; &#125;;</span><br><span class="line">        static int player = 1; //By default player 1 is set  </span><br><span class="line">        static int choice; //This holds the choice at which position user want to mark   </span><br><span class="line">        // The flag variable checks who has won if its value is 1 then someone has won the match if -1 then Match has Draw if 0 then match is still running  </span><br><span class="line">        static int flag = 0;</span><br><span class="line"> </span><br><span class="line">        public static void run()</span><br><span class="line">        &#123;</span><br><span class="line">            do</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Clear();// whenever loop will be again start then screen will be clear  </span><br><span class="line">                Console.WriteLine(&quot;Player1:X and Player2:O&quot;);</span><br><span class="line">                Console.WriteLine(&quot;\n&quot;);</span><br><span class="line">                if (player % 2 == 0)//checking the chance of the player  </span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;Player 2 Chance&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;Player 1 Chance&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                Console.WriteLine(&quot;\n&quot;);</span><br><span class="line">                Board();// calling the board Function  </span><br><span class="line">                choice = int.Parse(Console.ReadLine());//Taking users choice   </span><br><span class="line"> </span><br><span class="line">                // checking that position where user want to run is marked (with X or O) or not  </span><br><span class="line">                if (arr[choice] != &apos;X&apos; &amp;&amp; arr[choice] != &apos;O&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (player % 2 == 0) //if chance is of player 2 then mark O else mark X  </span><br><span class="line">                    &#123;</span><br><span class="line">                        arr[choice] = &apos;O&apos;;</span><br><span class="line">                        player++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        arr[choice] = &apos;X&apos;;</span><br><span class="line">                        player++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else //If there is any position where user wants to run and that is already marked then show message and load board again  </span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;Sorry the row &#123;0&#125; is already marked with &#123;1&#125;&quot;, choice, arr[choice]);</span><br><span class="line">                    Console.WriteLine(&quot;\n&quot;);</span><br><span class="line">                    Console.WriteLine(&quot;Please wait 2 second board is loading again.....&quot;);</span><br><span class="line">                    Thread.Sleep(2000);</span><br><span class="line">                &#125;</span><br><span class="line">                flag = CheckWin();// calling of check win  </span><br><span class="line">            &#125; while (flag != 1 &amp;&amp; flag != -1);// This loof will be run until all cell of the grid is not marked with X and O or some player is not winner </span><br><span class="line"> </span><br><span class="line">            Console.Clear();// clearing the console  </span><br><span class="line"> </span><br><span class="line">            Board();// getting filled board again  </span><br><span class="line"> </span><br><span class="line">            if (flag == 1)// if flag value is 1 then someone has win or means who played marked last time which has win  </span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Player &#123;0&#125; has won&quot;, (player % 2) + 1);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            else// if flag value is -1 the match will be drawn and no one is the winner  </span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Draw&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // Board method which creats board  </span><br><span class="line">        private static void Board()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;     |     |      &quot;);</span><br><span class="line">            Console.WriteLine(&quot;  &#123;0&#125;  |  &#123;1&#125;  |  &#123;2&#125;&quot;, arr[1], arr[2], arr[3]);</span><br><span class="line">            Console.WriteLine(&quot;_____|_____|_____ &quot;);</span><br><span class="line">            Console.WriteLine(&quot;     |     |      &quot;);</span><br><span class="line">            Console.WriteLine(&quot;  &#123;0&#125;  |  &#123;1&#125;  |  &#123;2&#125;&quot;, arr[4], arr[5], arr[6]);</span><br><span class="line">            Console.WriteLine(&quot;_____|_____|_____ &quot;);</span><br><span class="line">            Console.WriteLine(&quot;     |     |      &quot;);</span><br><span class="line">            Console.WriteLine(&quot;  &#123;0&#125;  |  &#123;1&#125;  |  &#123;2&#125;&quot;, arr[7], arr[8], arr[9]);</span><br><span class="line">            Console.WriteLine(&quot;     |     |      &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        private static int CheckWin()</span><br><span class="line">        &#123;</span><br><span class="line">            #region Horzontal Winning Condtion</span><br><span class="line">            //Winning Condition For First Row   </span><br><span class="line">            if (arr[1] == arr[2] &amp;&amp; arr[2] == arr[3])</span><br><span class="line">            &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            //Winning Condition For Second Row   </span><br><span class="line">            else if (arr[4] == arr[5] &amp;&amp; arr[5] == arr[6])</span><br><span class="line">            &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            //Winning Condition For Third Row   </span><br><span class="line">            else if (arr[6] == arr[7] &amp;&amp; arr[7] == arr[8])</span><br><span class="line">            &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            #endregion</span><br><span class="line"> </span><br><span class="line">            #region vertical Winning Condtion</span><br><span class="line"> </span><br><span class="line">            //Winning Condition For First Column       </span><br><span class="line">            else if (arr[1] == arr[4] &amp;&amp; arr[4] == arr[7])</span><br><span class="line">            &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            //Winning Condition For Second Column  </span><br><span class="line">            else if (arr[2] == arr[5] &amp;&amp; arr[5] == arr[8])</span><br><span class="line">            &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            //Winning Condition For Third Column  </span><br><span class="line">            else if (arr[3] == arr[6] &amp;&amp; arr[6] == arr[9])</span><br><span class="line">            &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            #endregion</span><br><span class="line"> </span><br><span class="line">            #region Diagonal Winning Condition</span><br><span class="line">            else if (arr[1] == arr[5] &amp;&amp; arr[5] == arr[9])</span><br><span class="line">            &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            else if (arr[3] == arr[5] &amp;&amp; arr[5] == arr[7])</span><br><span class="line">            &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            #endregion</span><br><span class="line"> </span><br><span class="line">            #region Checking For Draw</span><br><span class="line"> </span><br><span class="line">            // If all the cells or values filled with X or O then any player has won the match  </span><br><span class="line">            else if (arr[1] != &apos;1&apos; &amp;&amp; arr[2] != &apos;2&apos; &amp;&amp; arr[3] != &apos;3&apos; &amp;&amp; arr[4] != &apos;4&apos; &amp;&amp; arr[5] != &apos;5&apos; &amp;&amp; arr[6] != &apos;6&apos; &amp;&amp; arr[7] != &apos;7&apos; &amp;&amp; arr[8] != &apos;8&apos; &amp;&amp; arr[9] != &apos;9&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            #endregion</span><br><span class="line"> </span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速阅读后，代码看上去很混乱，职责没有正确分开，变量名也没有意义。</p>
<p>经过准确的阅读后，我们可以找到游戏板，该游戏板存储在“ static char [] arr”中。向阵列添加新元素没有任何效果，因为该阵列直接在PrintBoard和CheckWin函数中访问。现在我们知道要调整游戏板的大小，必须更改大部分代码。 </p>
<p>创建一个新项目并运行游戏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Game.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 一旦我们印刷了棋盘，游戏就会要求用户输入。我们可以通过从文件中读取输入来实现自动化。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    private const string InputPath = &quot;input.txt&quot;;</span><br><span class="line"> </span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        var input = new StreamReader(new FileStream(InputPath, FileMode.Open));</span><br><span class="line">        Console.SetIn(input);</span><br><span class="line">        Game.run();</span><br><span class="line">        input.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有输入的集合太大，无法使用蛮力测试。我们可以做的就是对输入进行<strong>采样</strong>。为此，我们考虑井字游戏的最终得分：</p>
<ul>
<li>玩家1获胜</li>
<li>玩家2获胜</li>
<li>绘制图形</li>
</ul>
<p>选择覆盖这三种情况的最低限度的测试集，在文本文件中编写路径，并在golendenMaster文件夹中收集结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    private const string InputFolderPath = &quot;input/&quot;;</span><br><span class="line">    private const string OutputFolderPath = &quot;goldenMaster/&quot;;</span><br><span class="line"> </span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        int i = 1;</span><br><span class="line">        foreach (var filePath in Directory.GetFiles(InputFolderPath)) &#123;</span><br><span class="line">            var input = new StreamReader(new FileStream(filePath, FileMode.Open));</span><br><span class="line">            var output = new StreamWriter(new FileStream(OutputFolderPath + &quot;output&quot; + i.ToString() + &quot;.txt&quot; , FileMode.CreateNew));</span><br><span class="line">            Console.SetIn(input);</span><br><span class="line">            Console.SetOut(output);</span><br><span class="line">            Game.run();</span><br><span class="line">            input.Close();</span><br><span class="line">            output.Close();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这三个结果文件代表了我们的Golden Master，我们可以在此基础上进行一些特性测试： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[Test]</span><br><span class="line">public void WinPlayerOne()</span><br><span class="line">&#123;</span><br><span class="line">    inputPath = InputFolderPath + &quot;input1.txt&quot;;</span><br><span class="line">    outputPath = OutputFolderPath + &quot;output.txt&quot;;</span><br><span class="line">    var goldenMasterOutput = GoldenMasterOutput + &quot;output1.txt&quot;;</span><br><span class="line"> </span><br><span class="line">    var input = new StreamReader(new FileStream(inputPath, FileMode.Open));</span><br><span class="line">    var output = new StreamWriter(new FileStream(outputPath, FileMode.CreateNew));</span><br><span class="line">    Console.SetIn(input);</span><br><span class="line">    Console.SetOut(output);</span><br><span class="line"> </span><br><span class="line">    Game.run();</span><br><span class="line"> </span><br><span class="line">    input.Close();</span><br><span class="line">    output.Close();</span><br><span class="line"> </span><br><span class="line">    Assert.True(AreFileEquals(goldenMasterOutput, outputPath));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private bool AreFileEquals(string expectedPath, string actualPath)</span><br><span class="line">&#123;</span><br><span class="line">    byte[] bytes1 = Encoding.Convert(Encoding.ASCII, Encoding.ASCII, Encoding.ASCII.GetBytes(File.ReadAllText(expectedPath)));</span><br><span class="line">    byte[] bytes2 = Encoding.Convert(Encoding.ASCII, Encoding.ASCII, Encoding.ASCII.GetBytes(File.ReadAllText(actualPath)));</span><br><span class="line"> </span><br><span class="line">    return bytes1.SequenceEqual(bytes2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 只要测试是绿色的，我们就可以重构而不必担心破坏某些东西。一种可能的结果可能是： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void run()</span><br><span class="line">&#123;</span><br><span class="line">    char[] board = &#123; &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos; &#125;;</span><br><span class="line">    int actualPlayer = 1;</span><br><span class="line"> </span><br><span class="line">    while (CheckWin(board) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintPlayerChoise(actualPlayer);</span><br><span class="line">        PrintBoard(board);</span><br><span class="line">        var choice = ReadPlayerChoise();</span><br><span class="line">        if (isBoardCellAlreadyTaken(board[choice]))</span><br><span class="line">        &#123;</span><br><span class="line">            PrintCellIsAlreadyMarketMessage(board[choice], choice);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        board[choice] = GetPlayerMarker(actualPlayer);</span><br><span class="line">        actualPlayer = UpdatePlayer(actualPlayer);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    PrintResult(board, actualPlayer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码中可以看出Board的概念及其职责。让我们尝试在新的<strong>Board</strong>类中提取行为。新Board应能够： </p>
<ul>
<li>印刷板</li>
<li>标记玩家的选择 </li>
<li>检查是否有赢家</li>
</ul>
<p>使用TDD（更多详情，请阅读<a href="https://www.blexin.com/en-US/Article/Blog/TDD-the-whole-code-is-guilty-until-proven-innocent-38" target="_blank" rel="noopener">这篇文章</a>）制定一个可调整大小的Board（发现测试的完整代码<a href="https://github.com/ntonjeta/GoldenMasterExample/blob/master/test/GoldenMasterExampleTest/BoardShould.cs" target="_blank" rel="noopener">在这里</a>和阶级的一个<a href="https://github.com/ntonjeta/GoldenMasterExample/blob/master/lib/Game/Board.cs" target="_blank" rel="noopener">位置</a>）。现在尝试将它们插入游戏中，并检查Golden Master是否保持绿色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private const int Boardsize = 3;</span><br><span class="line"> </span><br><span class="line">public static void run()</span><br><span class="line">&#123;</span><br><span class="line">    Board board = new Board(Boardsize);</span><br><span class="line">    int actualPlayer = 1;</span><br><span class="line"> </span><br><span class="line">    while (board.CheckWin() == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintPlayerChoise(actualPlayer);</span><br><span class="line">        Console.WriteLine(board.Print());</span><br><span class="line">        var choice = ReadPlayerChoise();</span><br><span class="line">        if (!board.UpdateBoard(actualPlayer, choice))</span><br><span class="line">        &#123;</span><br><span class="line">            PrintCellIsAlreadyMarketMessage(board.GetCellValue(choice), choice);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        actualPlayer = UpdatePlayer(actualPlayer);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    PrintResult(board, actualPlayer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 此时，我们可以恢复标准输入/标准输出并从用户那里读取电路板的尺寸： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Insert Diagonal dimension of Board: &quot;);</span><br><span class="line">        var boardSize = int.Parse(Console.ReadLine());</span><br><span class="line">        Game.run(boardSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如您所见，多亏了Golden Master Pattern，我们能够控制遗留代码并进行重构，而无需担心。但是，所有闪闪发光的东西都不是金子：在“噪声输出”的情况下使用Golden Master可能会很困难，“噪声输出”对于执行无用，但会随时间（例如时间戳记，线程名等）而变化。在这种情况下，我们可以过滤输出并仅考虑重要部分。</p>
<p>我希望它在您下次重写旧项目时对您有用：毕竟，我们担心我们的代码失去控制！</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/10/08/技术/编写更好的C＃代码的技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/10/08/技术/编写更好的C＃代码的技巧/" class="post-title-link" itemprop="url">编写更好的C＃代码的技巧</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-10-08 18:07:00" itemprop="dateCreated datePublished" datetime="2020-10-08T18:07:00+00:00">2020-10-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2021-04-25 11:04:00" itemprop="dateModified" datetime="2021-04-25T11:04:00+00:00">2021-04-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="编写更好的C＃代码的技巧"><a href="#编写更好的C＃代码的技巧" class="headerlink" title="编写更好的C＃代码的技巧"></a>编写更好的C＃代码的技巧</h1><h5 id="编者导语"><a href="#编者导语" class="headerlink" title="编者导语"></a>编者导语</h5><p><em>本文来自<a href="https://www.pluralsight.com，原文包含以下三篇文章：" target="_blank" rel="noopener">https://www.pluralsight.com，原文包含以下三篇文章：</a></em></p>
<p><em>《编写更好的C＃代码简介》<a href="https://www.pluralsight.com/guides/introduction-to-writing-better-csharp-code" target="_blank" rel="noopener">https://www.pluralsight.com/guides/introduction-to-writing-better-csharp-code</a></em></p>
<p><em>《编写更好的C＃代码的技巧》<a href="https://www.pluralsight.com/guides/tips-for-writing-better-c-code" target="_blank" rel="noopener">https://www.pluralsight.com/guides/tips-for-writing-better-c-code</a></em></p>
<p><em>《有关编写更好的C＃代码的更多技巧》<a href="https://www.pluralsight.com/guides/more-tips-for-writing-better-csharp-code" target="_blank" rel="noopener">https://www.pluralsight.com/guides/more-tips-for-writing-better-csharp-code</a></em></p>
<p><em>虽然本文仅介绍了C#6.0语言特性，而现在最新的C#已经到了9.0，但这些内容已经仍然常读常新。</em></p>
<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>C＃已从C＃5更改为C＃6，为使项目更具可读性，基于最佳标准的实践也得到了发展，。</p>
<p>本指南系列的目的是帮助您为在团队环境中运行的C＃项目和.NET Framework应用程序编写更简洁的代码。在团队环境下，编写好的代码对开发人员可能更容易，因为编写的代码将由团队中其他开发人员使用，管理和更新，而代码质量往往取决于您个人团队的“哲学”和开发人员的编码实践。在这种情况下，最好的方法是遵循编码团队的准则，并为应用程序项目中的C＃程序添加设计和风格，以使它们对读者更好。请注意，C＃编译器并不关心您放入代码中的风格。但我们以一种使C＃应用程序对读者来说看起来更简单，更清洁，将更容易的方式更深入地进行编程，同时保持代码开发的性能和效率。</p>
<p>在阅读本指南之前，您应该了解以下几点：</p>
<ol>
<li>第6版对C＃的改进</li>
<li>.NET框架中的LINQ</li>
<li><code>Task</code>C＃中的异步编程和对象</li>
<li>使用C＃进行的不安全编程，使您无法正常的使用内存管理</li>
</ol>
<h5 id="不专注于性能"><a href="#不专注于性能" class="headerlink" title="不专注于性能"></a>不专注于性能</h5><p>应该注意的是，我不会谈论改变程序性能，提高效率或减少程序运行所花费的时间。通过编写简洁的C＃代码，您可以在几秒钟内提高程序性能，但是以下技巧并不能保证您的代码性能更好。</p>
<h2 id="为什么要编写整洁的代码？"><a href="#为什么要编写整洁的代码？" class="headerlink" title="为什么要编写整洁的代码？"></a>为什么要编写整洁的代码？</h2><p>您编写代码，编译器编译时没有警告也没有错误，代码很好。但是，如果其他人想读出该代码怎么办？如果有人后来需要为您或您所在的公司升级代码，该怎么办？看下面的代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  x = Console.Read();</span><br><span class="line"></span><br><span class="line">  Console.WriteLine(x * <span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序运行良好，系统中没有错误，应用程序也可以正常工作。但是您能告诉我该程序在现实生活中做什么吗？以下是可以做出的一些假设：</p>
<ol>
<li>它只是乘以价值</li>
<li>就像奖金一样，它正在增加价值</li>
<li>是个人银行存款总额的利率</li>
<li>等等。</li>
</ol>
<p>哪一个是真实的？没有人会知道。在这种情况下，最好编写出良好的代码，并记住遵循编程的基础。看下面的代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> salary = <span class="number">0</span>;</span><br><span class="line">  salary = Console.Read();</span><br><span class="line"></span><br><span class="line">  Console.WriteLine(salary * <span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这比以前的代码有意义吗？我们可以很容易地说这个代码将增加薪水的价值。请注意，仅通过改进代码，我们就能确保其他人可以比以前更快地理解它。</p>
<p>在本指南中，我不会向您展示如何遵循最佳原则。相反，我将以您已有的知识为基础，并教您如何充分利用C＃程序。我将重点介绍如何在应用程序中编写良好的C＃逻辑，因此您将看到通过以这种方式和结构编写程序，可以从应用程序中获得很多好处。</p>
<p>因此，让我们开始吧。</p>
<h2 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h2><p>C＃是一种面向对象的编程语言。如果对象本身没有分块，那么写一组提示有什么好处？本节将重点介绍在前进并<code>new Object()</code>在应用程序中编写代码之前应考虑的事项。您必须了解如何创建C＃类以及事物如何协作以在系统中启动一个小程序。</p>
<p>例如，看下面的代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="keyword">public</span> DateTime DateOfBirth &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">bool</span> Gender &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可能想要创建默认情况下设置值的程序，或者让它们来自模型或诸如此源代码的任何其他面向数据库的数据源，这些程序简化了在对象时输入默认值的方式正在创建。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person &#123; ID = <span class="number">1</span>, Name = <span class="string">"Afzaal Ahmad Zeeshan"</span>, DateOfBirth = <span class="keyword">new</span> DateTime(<span class="number">1995</span>, <span class="number">08</span>, <span class="number">29</span>), Gender = <span class="literal">true</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>相反，请尝试通过以下方式编写相同的代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.ID = <span class="number">1</span>;</span><br><span class="line">person.Name = <span class="string">"Afzaal Ahmad Zeeshan"</span>;</span><br><span class="line"><span class="comment">// So on.</span></span><br></pre></td></tr></table></figure>

<p>这里的代码没有明显的性能改进，但是可以真正提高代码的可读性。如果您喜欢<em>缩进</em>，请在这里查看：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person</span><br><span class="line">&#123;</span><br><span class="line">  ID = <span class="number">1</span>,</span><br><span class="line">  Name = <span class="string">"Afzaal Ahmad Zeeshan"</span>,</span><br><span class="line">  DateOfBirth = <span class="keyword">new</span> DateTime(<span class="number">1995</span>, <span class="number">08</span>, <span class="number">29</span>),</span><br><span class="line">  Gender = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这也有缩进，但是它为您的C＃代码的可读性添加了更多的说明。尽管前面的代码可以实现相同的功能，但是建议的代码可以使代码更易读和简洁。</p>
<h1 id="二、技巧"><a href="#二、技巧" class="headerlink" title="二、技巧"></a>二、技巧</h1><h2 id="空检查"><a href="#空检查" class="headerlink" title="空检查"></a>空检查</h2><p><code>NullReferenceException</code>当缺少初始化的对象再次抛出异常时，您是否曾经对感到恼火？在程序中进行空检查有很多好处，不仅可以提高可读性，而且可以确保程序不会由于内存问题而终止（例如，内存中不存在变量时）。这些可能与程序的安全性以及团队具有的良好UI和UX准则相抵触。大多数情况下，由于以下原因会引发空异常：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> name = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(name);</span><br></pre></td></tr></table></figure>

<p>在大多数情况下，除非您解决此问题，否则编译器本身不会继续运行，但是如果您设法以某种方式诱使编译器认为变量具有值，但在运行时没有变量，则会出现空引用异常。为了克服这个问题，您可以执行以下操作：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">string</span> name = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try to enter the value, from somewhere</span></span><br><span class="line"><span class="keyword">if</span>(name != <span class="literal">null</span>) &#123;</span><br><span class="line">   Console.WriteLine(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此安全检查将确保在调用此变量时该值可用。否则，它将影响您代码的路径。但是，在C＃6中，还有另一种方法可以克服此错误。考虑以下情形：建立数据库，建立数据表，找到您的人员但找不到他们的就业详细信息。你能找到他们工作的公司吗？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> company = DbHelper.PeopleTable.Find(x =&gt; x.id == id).FirstOrDefault().EmploymentHistory.CompanyName; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>如果您这样做，将会出现错误，因为我们只能在这些值的列表中进行简单几步的对象筛选。然后我们将碰到一个空值，一切都丢失了。C＃6提出了一种克服这些情况的新方法，方法是在值和字段可以为null的后面使用安全的导航运算符。<code>?.</code>。像这样：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> company = DbHelper?.PeopleTable?.Find(x =&gt; x.id == id)?.FirstOrDefault()?.EmploymentHistory?.CompanyName; <span class="comment">// Works</span></span><br></pre></td></tr></table></figure>

<p>如果前一个不为null，则此代码仅检查下一个值。如果先前的值为null，它将返回null并将null保存为的值<code>company</code>，而不是引发错误。将检查留给框架本身可以很方便，但是，尽管如此，您仍然必须在最后检查其余值是否为null。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> company = DbHelper.PeopleTable?.Find(x =&gt; x.id == id)?.FirstOrDefault()?.EmploymentHistory?.CompanyName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(company != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">// Final process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是您明白了这一点，而不是编写代码并检查所有内容是否为空，而是可以执行简单的检查并执行程序中想要的操作和逻辑。否则，将需要<code>try...catch</code>包装器或多个<code>if...else</code>块来控制程序在系统中的导航方式。</p>
<h2 id="异步编程模式"><a href="#异步编程模式" class="headerlink" title="异步编程模式"></a>异步编程模式</h2><p>如果您正在使用C＃5进行编程，那么您已经在使用async / await关键字为您的应用程序带来改进。如果不是这种情况，那么我建议您在应用程序的源代码中使用异步编程模式。这不仅可以提高对程序的响应速度，还可以提高应用程序的可读性。在源代码中具有异步模式的一些好处是：</p>
<ol>
<li>代码路径开始变得更加有意义。如果有一个进程在后台开始运行，那么程序员可以了解程序应该在哪里。</li>
<li>应用程序挂起问题将消失。大多数与应用程序阻塞相关的问题直接来自代码。当UI线程无法更新UI时，用户会认为该应用程序正在挂起并且没有响应，而事实并非如此。异步方法确实可以帮上大忙。</li>
<li>基于Windows运行时的应用程序完全基于此方法。您将（<strong>并且必须是！</strong>）在您的Windows Runtime应用程序中使用这种方法来解决诸如挂起应用程序或不良的编程习惯之类的问题。</li>
</ol>
<p>自从线程化以来，代码执行的并行化就已经存在。异步已经成为程序和应用程序的重要组成部分，因此您更应该考虑使用它。</p>
<h2 id="C＃字符串构建"><a href="#C＃字符串构建" class="headerlink" title="C＃字符串构建"></a>C＃字符串构建</h2><p>字符串是当今应用程序的重要组成部分，构建字符串可能会花费很多时间，并且还会导致应用程序性能下降。您可以通过多种方式在C＃程序中构建字符串。以下是其中几种方式：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> str = <span class="string">""</span>; <span class="comment">// Setting it to null would cause additional problems.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Way 1</span></span><br><span class="line">str = <span class="string">"Name: "</span> + name + <span class="string">", Age: "</span> + age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way 2</span></span><br><span class="line">str = <span class="keyword">string</span>.Format(<span class="string">"Name: &#123;0&#125;, Age: &#123;1&#125;"</span>, name, age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way 3</span></span><br><span class="line"><span class="keyword">var</span> builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">builder.Append(<span class="string">"Name: "</span>);</span><br><span class="line">builder.Append(name);</span><br><span class="line">builder.Append(<span class="string">", Age: "</span>);</span><br><span class="line">builder.Append(age);</span><br><span class="line">str = builder.ToString();</span><br></pre></td></tr></table></figure>

<p>请注意，C＃中的字符串是不可变的。这意味着，如果您尝试更新它们的值，则会重新创建它们，并从内存中删除以前的句柄。这就是为什么方式1看起来是最好的方式，但经过进一步思考，事实并非如此。最好的方法是方法3，它使您可以构建字符串而不必在内存中重新创建对象。同时，C＃6引入了一种全新的方式在C＃中构建字符串，该方式比您以前想象的要好得多。新的<em>字符串插值</em>运算符<code>$</code>为您提供了以最佳方式执行字符串构建的功能。字符串插值如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Just arbitrary variables</span></span><br><span class="line">   <span class="keyword">string</span> name = <span class="string">""</span>;</span><br><span class="line">   <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Our interest</span></span><br><span class="line">   <span class="keyword">string</span> str = <span class="string">$"Name: <span class="subst">&#123;name&#125;</span>, Age: <span class="subst">&#123;age&#125;</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需一行代码，编译器就会自动将其转换为<code>string.Format()</code>版本。为了证明这一点，将详细说明此C＃程序已生成的字节码，并向您展示如何自动更改语法以读取字符串格式。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IL_0000:  nop</span><br><span class="line">IL_0001:  ldstr       <span class="string">""</span></span><br><span class="line">IL_0006:  stloc<span class="number">.0</span>     <span class="comment">// name</span></span><br><span class="line">IL_0007:  ldc.i4<span class="number">.0</span></span><br><span class="line">IL_0008:  stloc<span class="number">.1</span>     <span class="comment">// age</span></span><br><span class="line">IL_0009:  ldstr       <span class="string">"Name: &#123;0&#125;, Age: &#123;1&#125;"</span></span><br><span class="line">IL_000E:  ldloc<span class="number">.0</span>     <span class="comment">// name</span></span><br><span class="line">IL_000F:  ldloc<span class="number">.1</span>     <span class="comment">// age</span></span><br><span class="line">IL_0010:  box         System.Int32</span><br><span class="line">IL_0015:  call        System.String.Format</span><br><span class="line">IL_001A:  stloc<span class="number">.2</span>     <span class="comment">// str</span></span><br><span class="line">IL_001B:  ret</span><br></pre></td></tr></table></figure>

<p>可以看出，这显示了如何将语法更改回我们已经看到的语法。有关<strong><code>IL_0009</code></strong>更多信息，请参见。当其他人正在读取程序时，这可以使您的程序外观更简洁，并且如果要构建的字符串较小，则可以提高性能。如果字符串较大，请使用<code>StringBuilder</code>。</p>
<h1 id="三、更多技巧"><a href="#三、更多技巧" class="headerlink" title="三、更多技巧"></a>三、更多技巧</h1><h2 id="遍历数据"><a href="#遍历数据" class="headerlink" title="遍历数据"></a>遍历数据</h2><p>如果不对一组数据进行循环和迭代，那么应用程序有什么用？在这种情况下，有时您将不得不查找值，查找节点，查找记录或对集合进行任何其他遍历。在这种情况下，您确实需要确保编写干净的代码，因为这是性能和可读性都非常重要且相互关联的领域。有了一些经验，我就克服了编写用于读取和遍历数据的错误代码的方式。这正是LINQ应该加入的地方，LINQ允许您编写使用最佳.NET框架为用户和客户提供最佳编码体验和最佳体验的程序。</p>
<p>以前，您可能已经做过以下一些事情：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="comment">// A function to search for people</span></span><br><span class="line"><span class="function">Person <span class="title">FindPerson</span>(<span class="params"><span class="keyword">int</span> id</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> people = DbContext.GetPeople(); <span class="comment">// Returns List&lt;Person&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">foreach</span> (<span class="keyword">var</span> person <span class="keyword">in</span> people) &#123;</span><br><span class="line">      <span class="keyword">if</span>(person.ID == id) &#123;</span><br><span class="line">         <span class="keyword">return</span> person;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// No person found.</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Then do this</span></span><br><span class="line"><span class="keyword">var</span> person = FindPerson(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>对于任何想接手您代码的人来说，这都是一段易读的代码。但是，使用C＃中的LINQ查询可以使代码更加简单和整洁。您可以通过两种方式执行此操作。一个有点像SQL，另一个是通过<code>Where</code>在集合上使用该函数并传递我们的要求。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A function to search for people</span></span><br><span class="line"><span class="function">Person <span class="title">FindPerson</span>(<span class="params"><span class="keyword">int</span> id</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> people = DbContext.GetPeople(); <span class="comment">// Returns List&lt;Person&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">from</span> person <span class="keyword">in</span> people</span><br><span class="line">          <span class="keyword">where</span> person.ID == id</span><br><span class="line">          <span class="keyword">select</span> person).ToList().FirstOrDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Then do this</span></span><br><span class="line"><span class="keyword">var</span> person = FindPerson(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>该代码看起来有点像SQL，可以增强代码的可读性和性能。该函数相似，但是，该<code>Where</code>函数的读取效果更好，并使所有迭代都针对.NET框架本身，而.NET框架将为应用程序提供最佳性能。</p>
<p>现在，让我们看看用相同的C＃代码编写此查询的另一种方式：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A function to search for people</span></span><br><span class="line"><span class="function">Person <span class="title">FindPerson</span>(<span class="params"><span class="keyword">int</span> id</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> people = DbContext.GetPeople(); <span class="comment">// Returns List&lt;Person&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> people.FirstOrDefault(x =&gt; x.ID == id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Then do this</span></span><br><span class="line"><span class="keyword">var</span> person = FindPerson(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>请注意，<code>null</code>如果没有找到匹配项，则返回第一个代码。这段代码也做同样的事情。唯一的第一个代码更糟糕的是它必须对集合本身执行迭代。</p>
<p>该本地变量<code>return person;</code>将允许程序返回控件，但是如果数据位于最后一个位置会发生什么呢？此数据搜索算法的复杂度仍为O（n）。</p>
<h2 id="避免unsafe上下文"><a href="#避免unsafe上下文" class="headerlink" title="避免unsafe上下文"></a>避免unsafe上下文</h2><p>在您必须亲自处理内存时，C＃还支持手动内存管理。C＃中的不安全上下文允许您操作内存，执行指针算术，在可能无法访问的内存位置读取和写入数据，等等。但是，.NET框架可以做很多事情来克服内存问题，延迟和磁盘上其他问题。这也使.NET框架完全无需实际执行任何内存管理，.NET框架将为您做到这一点。</p>
<p>使用不安全的上下文有很多好处，例如，当您要围绕本机C ++库编写包装器时。Emgu CV就是这样一个示例，您将在其中编写一些代码来处理如何管理本机代码，并以更简单的方式来处理内存中的错误。在这种情况下，您可以：</p>
<ol>
<li>使用指针管理和指针算术。您不能在此上下文之外的任何地址上执行任何操作，这是.NET规则所处的位置。</li>
<li>使用内存管理来操作内存中的对象。</li>
<li>使用C ++风格的编程，这正是C＃设计的目的。</li>
</ol>
<p>这几乎没有好处，如果您应该在应用程序中考虑这一点，请明智地考虑。</p>
<h4 id="关于Unsafe纯属个人观点"><a href="#关于Unsafe纯属个人观点" class="headerlink" title="关于Unsafe纯属个人观点"></a>关于<code>Unsafe</code>纯属个人观点</h4><p>我还想指出，关于“不安全”的利弊，我所说的一切都是我个人的看法。我不经常在程序中使用<code>unsafe</code>上下文，因为没有理由不考虑在应用程序中使用上下文。但是，如果您的应用程序需要本机内存管理，则可以使用此上下文。</p>
<h2 id="尽可能使用Lambda表达式"><a href="#尽可能使用Lambda表达式" class="headerlink" title="尽可能使用Lambda表达式"></a>尽可能使用Lambda表达式</h2><p>Lambda来自函数式编程领域，在C＃中已广泛使用，从内联函数一直到C＃6中的getter only属性。我将展示C＃中的两种用法，它们构成的程序，不仅看起来更清爽，而且性能指标也更高。</p>
<p>为此，我将向您显示该C＃代码的IL。我个人喜欢在许多领域使用lambda，尤其是当我不得不用C＃编写内联函数时。自从可以使用此概念编写仅用于getter的属性以来，我一直在使用它们，并且我个人认为它比以前做同一件事的方法更好。</p>
<h3 id="1-将Lambda用于内联函数"><a href="#1-将Lambda用于内联函数" class="headerlink" title="1.将Lambda用于内联函数"></a>1.将Lambda用于内联函数</h3><p>您应该知道一些C＃编程的示例，使用这种写法的代码很多。</p>
<p>例如在应用程序中进行事件处理的情况下，对于事件处理，您可以像下面这样编写当前函数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Without lamdbas</span></span><br><span class="line">myBtn.Click += Btn_Click;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Btn_Click</span> (<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// Code to handle the event</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// With the help of lambdas</span></span><br><span class="line">myBtn.Click += (sender, e) =&gt;</span><br><span class="line">               &#123;</span><br><span class="line">                  <span class="comment">// Code to handle the event.</span></span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>

<p>请注意，编译器将自动将对象映射到其类型。这在许多方面都很方便，因为它允许您用C＃编写仅与对象一起保留的内联函数，除非您也想在其他任何地方使用它们。但是，这种处理事件的方法有一个缺点：一旦附加了事件处理程序，便无法删除它。在C＃中可以，<code>-+</code>。</p>
<p>但是由于我们没有删除事件的参考，因此只能使用单独的函数。<strong>但是</strong>，如果不必删除处理程序，则应始终考虑在程序中使用这种事件处理方式。</p>
<h3 id="2-将Lambda用于仅Getter的属性"><a href="#2-将Lambda用于仅Getter的属性" class="headerlink" title="2.将Lambda用于仅Getter的属性"></a>2.将Lambda用于仅Getter的属性</h3><p>在C＃中，有一个使用属性而不是字段的概念。您可以控制如何设置值以及如何从字段中捕获值。将其视为Java编程语言的getter和setter方法的替代方法（或类似方法）。唯一的区别是您不必在某个地方分别编写它们，它们直接写在字段本身的前面。然后，C＃程序编译器将创建自己的后备字段，用于存储值。</p>
<p>基本上，您必须编写如下这样的属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>请注意，这些属性是恒定的，设置后就无法更改。它们是在构造函数中设置的，或者（从C＃6开始）在它们的前面设置。像这样：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; &#125; = <span class="string">"Afzaal Ahmad Zeeshan"</span>;</span><br></pre></td></tr></table></figure>

<p>但是，由于我们已经知道这是一个常量字段，您不能修改它，那么为什么不创建一个简单的常量属性呢？事情变得有些棘手。甚至一个属性也必须由字段来备份。在这种情况下，这将为我们解决问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public string Name =&gt; &quot;Afzaal Ahmad Zeeshan&quot;;</span><br></pre></td></tr></table></figure>

<p>这等效于编写以下内容：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="string">"Afzaal Ahmad Zeeshan"</span>; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>但是由于编译期将getter字段转换为常量字段，并且在必须调用此属性的时候才会在程序中使用该字段，因此性能要好得多。</p>
<h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>本指南系列的目的是使您了解一些使程序更易于阅读和更好执行的方法。C＃编译器本身会尽最大努力提高代码的质量和效率，而这程序员带来便利，同时也将使程序更好地工作。</p>
<p>除了上面提到的方法，还有许多其他提高可读性的方法，其中许多方法适合公司团队协作的形式编写程序，因为大多数团队往往都要求程序员遵循自己的编程方法和方式。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/07/25/技术/how-to-use-async-await-in-real-application/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/07/25/技术/how-to-use-async-await-in-real-application/" class="post-title-link" itemprop="url">一文看懂"async"和“await”关键词是如何简化了C#中多线程的开发过程</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-07-25 17:35:00" itemprop="dateCreated datePublished" datetime="2020-07-25T17:35:00+00:00">2020-07-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2021-04-25 11:04:00" itemprop="dateModified" datetime="2021-04-25T11:04:00+00:00">2021-04-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实际应用程序中的async和await"><a href="#实际应用程序中的async和await" class="headerlink" title="实际应用程序中的async和await"></a><strong>实际应用程序中的async和await</strong></h1><h3 id="一文看懂”async”和“await”关键词是如何简化了C-中多线程的开发过程"><a href="#一文看懂”async”和“await”关键词是如何简化了C-中多线程的开发过程" class="headerlink" title="一文看懂”async”和“await”关键词是如何简化了C#中多线程的开发过程"></a>一文看懂”async”和“await”关键词是如何简化了C#中多线程的开发过程</h3><p>当我们使用需要长时间运行的方法（即，用于读取大文件或从网络下载大量资源）时，在同步的应用程序中，应用程序本身将停止运行，直到活动完成。在这些情况下，<strong>异步</strong>编程非常有用：它使我们能够并行执行不同任务，并在需要时等待其完成。</p>
<p>有这种方法编程许多不同的模型类型：<strong>APM</strong>（异步编程模型），基于事件（异步模型<strong>EAP</strong>），以及<strong>TAP</strong>，基于任务的（异步模型<strong>任务</strong>）。让我们看看如何使用关键字async和await在C＃中实现第三个方法。</p>
<p>编写异步代码的主要问题之一是可维护性：实际上，这种编程方法会使代码复杂化。幸运的是，C＃5引入了一种简化的方法，在该方法中，编译器运行由开发人员先前完成的艰巨任务，并且应用程序保留类似于同步代码的逻辑结构。</p>
<p>让我们举个例子。假设我们有一个.NET Core项目，我们应该在其中管理三个实体：Area，Company和Resource。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Area</span><br><span class="line">&#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line"> </span><br><span class="line">    [Required]</span><br><span class="line">    [StringLength(255)]</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">public class Company</span><br><span class="line">&#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line"> </span><br><span class="line">    [Required]</span><br><span class="line">    [StringLength(255)]</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Resource</span><br><span class="line">&#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line"> </span><br><span class="line">    [Required]</span><br><span class="line">    [StringLength(255)]</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 现在假设我们应该使用Entity Framework Core将这些实体的值保存在数据库中。其<strong>DbContext</strong>是： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class AppDbContext : DbContext</span><br><span class="line">&#123;</span><br><span class="line">    public DbSet&lt;Area&gt; Areas &#123; get; set; &#125;</span><br><span class="line">    public DbSet&lt;Company&gt; Companies &#123; get; set; &#125;</span><br><span class="line">    public DbSet&lt;Resource&gt; Resources &#123; get; set; &#125;</span><br><span class="line">    public AppDbContext(DbContextOptions&lt;AppDbContext&gt; options) : base(options)  &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    override protected void OnModelCreating(ModelBuilder modelBuilder)</span><br><span class="line">    &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Area&gt; ().HasData(</span><br><span class="line">            new Area &#123; Id = 1, Name = &quot;Area1&quot;&#125;,</span><br><span class="line">            new Area &#123; Id = 2, Name = &quot;Area2&quot;&#125;,</span><br><span class="line">            new Area &#123; Id = 3, Name = &quot;Area3&quot;&#125;,</span><br><span class="line">            new Area &#123; Id = 4, Name = &quot;Area4&quot;&#125;,</span><br><span class="line">            new Area &#123; Id = 5, Name = &quot;Area5&quot;&#125;);</span><br><span class="line">        modelBuilder.Entity&lt;Company&gt; ().HasData(</span><br><span class="line">            new Area &#123; Id = 1, Name = &quot;Company1&quot;&#125;,</span><br><span class="line">            new Area &#123; Id = 2, Name = &quot;Company2&quot;&#125;,</span><br><span class="line">            new Area &#123; Id = 3, Name = &quot;Company3&quot;&#125;,</span><br><span class="line">            new Area &#123; Id = 4, Name = &quot;Company4&quot;&#125;,</span><br><span class="line">            new Area &#123; Id = 5, Name = &quot;Company5&quot;&#125;);</span><br><span class="line">        modelBuilder.Entity&lt;Resource&gt;().HasData(</span><br><span class="line">            new Area &#123; Id = 1, Name = &quot;Resource1&quot;&#125;,</span><br><span class="line">            new Area &#123; Id = 2, Name = &quot;Resource2&quot;&#125;,</span><br><span class="line">            new Area &#123; Id = 3, Name = &quot;Resource3&quot;&#125;,</span><br><span class="line">            new Area &#123; Id = 4, Name = &quot;Resource4&quot;&#125;,</span><br><span class="line">            new Area &#123; Id = 5, Name = &quot;Resource5&quot;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，我们插入了一些示例数据进行处理。现在假设我们要使用<em>Controller API</em>公开这些数据，既单独（针对每个实体），又使用将它们全部联接在一起的方法，并通过一次调用返回它们。</p>
<p>使用同步方法，<em>Controller API</em> 将是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[ApiController]</span><br><span class="line">[Route(&quot;[controller]&quot;)]</span><br><span class="line">public class DataController : ControllerBase</span><br><span class="line">&#123;</span><br><span class="line">    private readonly AppDbContext db = null;</span><br><span class="line">     </span><br><span class="line">    public DataController(AppDbContext db)</span><br><span class="line">    &#123;</span><br><span class="line">        this.db = db;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public IActionResult Get()</span><br><span class="line">    &#123;</span><br><span class="line">        var areas = this.GetAreas();</span><br><span class="line">        var companies = this.GetCompanies();</span><br><span class="line">        var resources = this.GetResources();</span><br><span class="line">        return Ok(new &#123; areas = areas, companies = companies, resources = resources &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    [Route(&quot;areas&quot;)]</span><br><span class="line">    public Area[] GetAreas() </span><br><span class="line">    &#123;</span><br><span class="line">        return this.db.Areas.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    [Route(&quot;companies&quot;)]</span><br><span class="line">    public Company[] GetCompanies() </span><br><span class="line">    &#123;</span><br><span class="line">        return this.db.Companies.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    [Route(&quot;resources&quot;)]</span><br><span class="line">    public Resource[] GetResources() </span><br><span class="line">    &#123;</span><br><span class="line">        return this.db.Resources.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Get（）方法在其中调用返回单个结果的三个方法，并等待每个方法的执行完成后再传递到下一个结果。这三种方法互不相关，因此您无需等待其中一种方法的执行即可调用另一种方法。然后，您可以创建三个独立的任务以并行执行。<br>第一种方法可以基于该方法<strong>运行</strong>中的<strong>任务</strong>类队列指定的作业是在跑步<em>线程池</em>，并返回一个<strong>任务</strong>对象，它代表了这项工作。这样，方法可以在线程池的不同线程上同时运行： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult Get()</span><br><span class="line">&#123;</span><br><span class="line">    var areas = Task.Run(() = &gt; this.GetAreas());</span><br><span class="line">    var companies = Task.Run(() = &gt; this.GetCompanies());</span><br><span class="line">    var resources = Task.Run(() = &gt; this.GetResources());        </span><br><span class="line">    Task.WhenAll(areas, companies, resources);</span><br><span class="line">    return Ok(new &#123; areas = areas.Result, companies = companies.Result, resources = resources.Result &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Task</strong>的<strong>Result</strong>属性包含详细说明的结果。方法<em>WhenAll</em>允许暂停当前线程执行，直到所有<em>Task</em>完成。运行代码，我们可以注意到一个有趣的事情：调用中断，并启动以下异常：</p>
<p>AggregateException：发生一个或多个错误。（在上一个操作完成之前，第二个操作在此上下文上开始。这通常是由使用相同DbContext实例的不同线程引起的。有关如何避免DbContext线程问题的更多信息，请参见<a href="https://go.microsoft.com/fwlink/?linkid=2097913" target="_blank" rel="noopener">https://go.microsoft.com。 / fwlink /？linkid = 2097913。</a>）</p>
<p>此错误消息告诉我们，方法在不同的线程上同时执行，但是由于它们使用与<strong>DbContext</strong> 相同的实例来连接数据库，<br>因此引发了异常，<strong>DbContext</strong>类无法确保<em>线程安全的</em>功能：我们可以轻松地绕过此问题，避免了.NET Core 的<em>依赖项注入</em>引擎创建单个实例，而我们为每种方法创建了单独的实例。作为示例，让我们看看方法GetAreas（）会如何变化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class DataController : ControllerBase</span><br><span class="line">&#123;</span><br><span class="line">    private readonly DbContextOptionsBuilder &lt;AppDbContext&gt; optionsBuilder = null;</span><br><span class="line">     </span><br><span class="line">    public DataController(IConfiguration configuration)</span><br><span class="line">    &#123;</span><br><span class="line">        this.optionsBuilder = new DbContextOptionsBuilder &lt;AppDbContext&gt; ()</span><br><span class="line">            .UseSqlite(configuration.GetConnectionString(&quot;DefaultConnection&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    [Route(&quot;areas&quot;)]</span><br><span class="line">    public Area[] GetAreas() </span><br><span class="line">    &#123;</span><br><span class="line">        using(var db = new AppDbContext(this.optionsBuilder.Options))</span><br><span class="line">        &#123;</span><br><span class="line">            return db.Areas.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 好吧，现在可以了。我们应该注意，EFCore提供了一些方法，例如，与方法<em>ToArrayAsync</em>一样，使用相同的<strong>DbContext</strong>进行异步调用，该方法从IQueryable <em>创建一个数组，该数组  异步枚举它。此方法返回*</em>Task *<em>，它是表示异步操作的活动。这样，我们不再需要使用</em>Task.Run（）： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult Get()</span><br><span class="line">&#123;</span><br><span class="line">    var areas = this.GetAreas();</span><br><span class="line">    var companies = this.GetCompanies();</span><br><span class="line">    var resources = this.GetResources();</span><br><span class="line">    Task.WhenAll(areas, companies, resources);</span><br><span class="line">    return Ok(new &#123; areas = areas.Result, companies = companies.Result, resources = resources.Result &#125;);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">[Route(&quot;areas&quot;)]</span><br><span class="line">public Task&lt;Area[]&gt; GetAreas() </span><br><span class="line">&#123;</span><br><span class="line">    return db.Areas.ToArrayAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论如何，Microsoft不能保证这些异步方法在每种情况下都能工作，因为DbContext尚未设计为线程安全的。您可以查询此链接以获取更多信息：<a href="https://docs.microsoft.com/en-us/ef/core/querying/async" target="_blank" rel="noopener">https</a> : <a href="https://docs.microsoft.com/en-us/ef/core/querying/async" target="_blank" rel="noopener">//docs.microsoft.com/zh-cn/ef/core/querying/async</a></p>
<p>使用Entity Framework Core时，最佳实践是在启动另一个异步操作之前，为每个异步操作都拥有一个DbContext或等待每个异步操作完成。<br>当我们必须进行异步调用并返回结果时，这种最佳做法是可以的。但是，如果我们想在返回结果之前对结果进行一些操作，会发生什么？如果我们想向列表中添加元素怎么办？我们应该等待结果，添加元素，然后返回修改后的列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;companies&quot;)]</span><br><span class="line">public Task&lt;Company[]&gt; GetCompanies() </span><br><span class="line">&#123;</span><br><span class="line">    using (var db = new AppDbContext(this.optionsBuilder.Options))</span><br><span class="line">    &#123;</span><br><span class="line">        var data = this.db.Companies.ToListAsync().Result;</span><br><span class="line">        data.Insert(0, new Company() &#123; Id = 0, Name = &quot;-&quot;&#125;);</span><br><span class="line">        return data.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 不幸的是，该代码无法编译，因为data.ToArray（）返回的是数组而不是Task。实际上，这里我们需要三个线程：主调用方（Get（）），数据库查询（this.db.Companies.ToListAsync（））和一个线程，该线程将一个值添加到列表中。我们有三种方法可以做到这一点：让我们用三种单一方法来查看它们。我们已经看到的第一个，可以使用Task.Run（）方法： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;companies&quot;)]</span><br><span class="line">public Task&lt;Company[]&gt; GetCompanies()</span><br><span class="line">&#123;</span><br><span class="line">     return Task.Run(() =&gt;</span><br><span class="line">     &#123;</span><br><span class="line">          using (var db = new AppDbContext(this.optionsBuilder.Options))</span><br><span class="line">          &#123;</span><br><span class="line">               var data = db.Companies.ToList();</span><br><span class="line">               data.Insert(0, new Company() &#123; Id = 0, Name = &quot;-&quot; &#125;);</span><br><span class="line">               return data.ToArray();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 作为替代方案，我们可以使用方法<strong>ContinueWith（）</strong>，该方法可以应用于任务，并且可以在上一个方法完成后立即指定要运行的新任务： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;resources&quot;)]</span><br><span class="line">public Task &lt;Resource[]&gt; GetResources()</span><br><span class="line">&#123;</span><br><span class="line">     using (var db = new AppDbContext(this.optionsBuilder.Options))</span><br><span class="line">     &#123;</span><br><span class="line">          return db.Resources.ToListAsync()</span><br><span class="line">              .ContinueWith(dataTask = &gt;</span><br><span class="line">              &#123;</span><br><span class="line">                   var data = dataTask.Result;</span><br><span class="line">                   dataTask.Result.Insert(0, new Resource() &#123; Id = 0, Name = &quot;-&quot; &#125;);</span><br><span class="line">                   return data.ToArray();</span><br><span class="line">              &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 我们可以让编译器执行“垃圾代码”，并使用关键字<strong>async</strong>和<strong>await</strong>，这可以为我们创建Task： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;areas&quot;)]</span><br><span class="line">public async Task &lt;Area[]&gt; GetAreas()</span><br><span class="line">&#123;</span><br><span class="line">     using (var db = new AppDbContext(this.optionsBuilder.Options))</span><br><span class="line">     &#123;</span><br><span class="line">          var data = await db.Areas.ToListAsync();</span><br><span class="line">          data.Insert(0, new Area() &#123; Id = 0, Name = &quot;-&quot; &#125;);</span><br><span class="line">          return data.ToArray();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如您在最后一种方法中看到的那样，代码更加简单，并且向我们隐藏了Task的创建，从而使我们可以异步返回。让我们想象一下一个场景，其中调用不止一个，并且这种方法如何使一切变得更加线性。</p>
<p>重构的副作用是方法GetAreas（）已成为<strong>异步操作</strong>。这个事实意味着，当不同的请求到达此API时，分配给该请求的线程池的线程将被释放以供其他请求使用，直到DbContext终止数据提取为止。</p>
<p>我希望我能引起您足够的兴趣来深入分析该论点。在许多情况下，使用async和await非常方便，并且除了使代码更加简洁和线性外，还可以提高应用程序的一般性能。</p>
<p>可以在这里找到代码：<a href="https://github.com/fvastarella/Programmazione-asincrona-con-async-await" target="_blank" rel="noopener">https</a>：<a href="https://github.com/fvastarella/Programmazione-asincrona-con-async-await" target="_blank" rel="noopener">//github.com/fvastarella/Programmazione-asincrona-con-async-await</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/07/21/技术/ASP.NET Core中的分布式缓存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/07/21/技术/ASP.NET Core中的分布式缓存/" class="post-title-link" itemprop="url">ASP.NET Core中的内存中缓存</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-07-21 21:05:00" itemprop="dateCreated datePublished" datetime="2020-07-21T21:05:00+00:00">2020-07-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2021-04-25 11:04:00" itemprop="dateModified" datetime="2021-04-25T11:04:00+00:00">2021-04-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ASP-NET-Core中的分布式缓存"><a href="#ASP-NET-Core中的分布式缓存" class="headerlink" title="ASP.NET Core中的分布式缓存"></a><strong>ASP.NET Core中的分布式缓存</strong></h1><p>在上<a href="https://www.blexin.com/en-US/Article/Blog/In-memory-caching-in-ASPNET-Core-45" target="_blank" rel="noopener">一篇文章中</a>，我解释了如何使用<strong><em>内存缓存</em></strong>在ASP.NET Core应用程序中管理<strong><em>缓存</em></strong>。如果您的应用程序托管在单个服务器上，则可以使用这种类型的缓存。</p>
<p>那.NET Core框架可以使用哪些工具在云中的分布式方案中进行缓存呢？</p>
<h2 id="IDistributedCache接口"><a href="#IDistributedCache接口" class="headerlink" title="IDistributedCache接口"></a>IDistributedCache接口</h2><p>该框架提供以下接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface IDistributedCache</span><br><span class="line">&#123;</span><br><span class="line">    byte[] Get(string key);</span><br><span class="line">    Task &lt;byte[]&gt; GetAsync(string key);</span><br><span class="line"></span><br><span class="line">    void Set(string key, byte[] value, DistributedCacheEntryOptions options);</span><br><span class="line">    Task SetAsync(string key, byte[] value, DistributedCacheEntryOptions options);</span><br><span class="line">     </span><br><span class="line">    void Refresh(string key);</span><br><span class="line">    Task RefreshAsync(string key);</span><br><span class="line">     </span><br><span class="line">    void Remove(string key);</span><br><span class="line">    Task RemoveAsync(string key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您还记得上一篇文章（<strong>IMemoryCache</strong>）中使用的接口，则可能会注意到一些相似之处，但甚至有很多区别，例如：</p>
<ol>
<li>异步方法</li>
<li>刷新方法（无需请求数据即可更新缓存键）</li>
<li>基于字节而非基于对象的方法</li>
</ol>
<p>到目前为止，Microsoft提供了3种实现：一种是<strong>内存中</strong>的，主要用于应用程序的开发阶段，第二种是在<strong>SQL Server上</strong>，最后一种是基于<strong>REDIS</strong>。<br>要使用基于REDIS的版本，必须安装NuGet软件包<strong>Microsoft.Extensions.Caching.Redis</strong>。</p>
<h2 id="分布式内存缓存"><a href="#分布式内存缓存" class="headerlink" title="分布式内存缓存"></a>分布式内存缓存</h2><p>该实现由框架提供，并将我们的数据保存在内存中。它不是完全分布式的缓存，因为数据是从应用程序实例保存在其所在的服务器上的。在某些情况下可能会有用：</p>
<ul>
<li>开发与测试</li>
<li>在生产中使用单个服务器时，内存消耗不是问题。</li>
</ul>
<p>无论如何，我们将使我们的应用程序仅在必要时才使用“真实的”分布式解决方案（用于保存的接口是相同的）。<br>要启用此IDistributedCache实现，您只需要在Startup类中注册它，如下所示：</p>
<p><a href="https://www.blexin.com/en-US/Article/Blog/Distributed-cache-in-ASPNET-Core-53#" target="_blank" rel="noopener">?</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`services.AddDistributedMemoryCache();`</span><br></pre></td></tr></table></figure>

<h2 id="分布式SQL-Server缓存"><a href="#分布式SQL-Server缓存" class="headerlink" title="分布式SQL Server缓存"></a>分布式SQL Server缓存</h2><p>此实现使分布式缓存可以将SQL Server数据库用作存储。有一些配置步骤。第一步包括创建用于保留数据的表。<br>有一个命令行命令工具，可通过简单的指令轻松实现</p>
<p><a href="https://www.blexin.com/en-US/Article/Blog/Distributed-cache-in-ASPNET-Core-53#" target="_blank" rel="noopener">?</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`dotnet sql-cache ``create` `&lt;``connection` `string &gt; &lt;``schema` `&gt; &lt;``table` `&gt;`</span><br></pre></td></tr></table></figure>

<p>允许创建具有以下结构的表：</p>
<p><a href="https://www.blexin.com/en-US/Article/Blog/Distributed-cache-in-ASPNET-Core-53#" target="_blank" rel="noopener">?</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`CREATE` `TABLE` `[dbo].[CacheTable](``  ``[Id] [nvarchar](449) ``NOT` `NULL``,``  ``[Value] [varbinary](``max``) ``NOT` `NULL``,``  ``[ExpiresAtTime] [datetimeoffset](7) ``NOT` `NULL``,``  ``[SlidingExpirationInSeconds] [``bigint``] ``NULL``,``  ``[AbsoluteExpiration] [datetimeoffset](7) ``NULL``,`` ``CONSTRAINT` `[pk_Id] ``PRIMARY` `KEY` `CLUSTERED ``(``  ``[Id] ``ASC``)``WITH` `(PAD_INDEX = ``OFF``, STATISTICS_NORECOMPUTE = ``OFF``, ``  ``IGNORE_DUP_KEY = ``OFF``, ALLOW_ROW_LOCKS = ``ON``, ``  ``ALLOW_PAGE_LOCKS = ``ON``) ``ON` `[``PRIMARY``]``) ``ON` `[``PRIMARY``] TEXTIMAGE_ON [``PRIMARY``]` `CREATE` `NONCLUSTERED ``INDEX` `[Index_ExpiresAtTime] ``ON` `[dbo].[CacheTable]``(``  ``[ExpiresAtTime] ``ASC``)``WITH` `(PAD_INDEX = ``OFF``, STATISTICS_NORECOMPUTE = ``OFF``, ``  ``SORT_IN_TEMPDB = ``OFF``, DROP_EXISTING = ``OFF``, ``  ``ONLINE = ``OFF``, ALLOW_ROW_LOCKS = ``ON``, ``  ``ALLOW_PAGE_LOCKS = ``ON``) ``ON` `[``PRIMARY``]`</span><br></pre></td></tr></table></figure>

<p>配置此实现的第二个也是最后一个步骤，即在我们的应用程序中进行注册。在Startup类的ConfigureServices方法内，我们添加以下代码块：</p>
<p><a href="https://www.blexin.com/en-US/Article/Blog/Distributed-cache-in-ASPNET-Core-53#" target="_blank" rel="noopener">?</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`services.AddDistributedSqlServerCache(o =&gt;``&#123;``  ``o.ConnectionString = Configuration[``&quot;ConnectionStrings:Default&quot;``];``  ``o.SchemaName = ``&quot;dbo&quot;``;``  ``o.TableName = ``&quot;Cache&quot;``;``&#125;);`</span><br></pre></td></tr></table></figure>

<h2 id="分布式Redis缓存"><a href="#分布式Redis缓存" class="headerlink" title="分布式Redis缓存"></a>分布式Redis缓存</h2><p>在分布式缓存场景中，Redis的使用非常广泛。Redis是一个快速存储的数据存储，它是开源的并且是键值类型。它提供的响应时间不到1毫秒，从而允许在各个领域中的每个实时应用程序每秒接收数百万个请求。<br>如果您的应用程序的基础结构基于Azure云，则可以使用服务<strong>Azure Redis缓存</strong>，并且可以从您的订阅中对其进行配置。</p>
<p>要在Redis上使用分布式缓存，必须安装软件包Microsoft.Extensions.Caching.Redis。<br>第一步是在Startup.class中配置服务<a href="https://www.blexin.com/en-US/Article/Blog/Distributed-cache-in-ASPNET-Core-53#" target="_blank" rel="noopener">?</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`public` `void` `ConfigureServices(IServiceCollection services)``&#123;`` ``// Add framework services.`` ``// ... altri servizi ...`` ` ` ``services.AddDistributedRedisCache(cfg =&gt; `` ``&#123;``  ``cfg.Configuration = Configuration.GetConnectionString(``&quot;redis&quot;``);`` ``&#125;);``&#125;`</span><br></pre></td></tr></table></figure>

<p>如果使用的是Azure Redis缓存，则可以通过访问面板的“访问键”部分找到连接字符串。</p>
<p><img src="https://www.blexin.com/storage/articles/cache/img02.png" alt="img"></p>
<h2 id="如何使用IDistributedCache"><a href="#如何使用IDistributedCache" class="headerlink" title="如何使用IDistributedCache"></a>如何使用IDistributedCache</h2><p>接口IDistributedCache的使用特别简单：如果您已经阅读了有关接口IMemoryCache的使用的文章，那么您将在命令中找到几点。如果要在控制器中使用它，则需要首先将实例注入构造函数中，如下面的代码所示：</p>
<p><a href="https://www.blexin.com/en-US/Article/Blog/Distributed-cache-in-ASPNET-Core-53#" target="_blank" rel="noopener">?</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`public` `class` `HomeController : Controller``&#123;``  ``private` `readonly` `IDistributedCache _cache;` `  ``public` `HomeController(IDistributedCache cache)``  ``&#123;``    ``_cache = cache;``  ``&#125;``  ``public` `async Task  Index()``  ``&#123;``    ``await _cache.SetStringAsync(``&quot;TestString&quot;``, ``&quot;TestValue&quot;``);` `    ``var value = _cache.GetString(``&quot;TestString&quot;``);` `    ``return` `View();``  ``&#125;``&#125;`</span><br></pre></td></tr></table></figure>

<p>如果让此代码运行，并在Index方法的最后一行插入一个断点，则会得到以下结果：</p>
<p><img src="https://www.blexin.com/storage/articles/cache/img01.png" alt="img"></p>
<p>我们可以使用<strong>DistributedCacheEntryOptions</strong>类轻松检查缓存的持续时间。在下面的代码中，我们创建一个实例，将持续时间设置为一小时。</p>
<p><a href="https://www.blexin.com/en-US/Article/Blog/Distributed-cache-in-ASPNET-Core-53#" target="_blank" rel="noopener">?</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`public` `async Task  Index()``&#123;``  ``var options = ``new` `DistributedCacheEntryOptions``  ``&#123;``    ``AbsoluteExpiration = DateTime.Now.AddHours(1)``  ``&#125;;` `  ``await _cache.SetStringAsync(``&quot;TestString&quot;``, ``&quot;TestValue&quot;``, options);` `  ``var value = _cache.GetString(``&quot;TestString&quot;``);` `  ``return` `View();``&#125;`</span><br></pre></td></tr></table></figure>

<h2 id="结论与建议"><a href="#结论与建议" class="headerlink" title="结论与建议"></a>结论与建议</h2><p>在我们的应用中使用哪种IDistributedCache实现的决定取决于某些因素。在Redis和SQL之间进行选择（我将内存实现仅保留在测试和开发中，所以我将其保留在外）应该基于对您可用的基础结构，性能要求和开发团队的经验进行选择。如果团队对Redis感到放心，这将是最佳选择。SQL实现仍然是一个很好的解决方案，但应记住，数据恢复将不会提供出色的性能，因此应谨慎选择要缓存的数据。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/07/20/技术/ASP.NET Core中的内存中缓存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/07/20/技术/ASP.NET Core中的内存中缓存/" class="post-title-link" itemprop="url">ASP.NET Core中的内存中缓存</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-07-20 21:05:00" itemprop="dateCreated datePublished" datetime="2020-07-20T21:05:00+00:00">2020-07-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2021-04-25 11:04:00" itemprop="dateModified" datetime="2021-04-25T11:04:00+00:00">2021-04-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ASP-NET-Core中的内存缓存"><a href="#ASP-NET-Core中的内存缓存" class="headerlink" title="ASP.NET Core中的内存缓存"></a><strong>ASP.NET Core中的内存缓存</strong></h1><p> <strong>让我们看看如何通过缓存优化ASP.NET Core应用程序性能</strong> </p>
<p>我相信，在我们的工作中，每个人都收到来自客户的请求或来自我们应用程序用户的反馈，以提高响应速度。</p>
<p>如果在编写代码时仅使用<strong>最佳实践</strong>还不够，那么我们肯定需要使用缓存来微调我们的应用程序。</p>
<p>缓存包括将那些不经常更改的信息存储在某个地方。频率是我们应用程序的业务要求。</p>
<p>在本文中，我们将看到ASP.NET Core可用于缓存的内容。</p>
<h2 id="IMemoryCache和IDistributedCache"><a href="#IMemoryCache和IDistributedCache" class="headerlink" title="IMemoryCache和IDistributedCache"></a>IMemoryCache和IDistributedCache</h2><p>这两个接口代表.NET Core中用于缓存的<em>内置</em>机制。您可能已经听说过的所有其他技术都是这两个接口的实现。在本文中，我们将详细介绍<em>内存缓存</em>，而在以后的文章中将研究分布式缓存。</p>
<h2 id="在ASP-NET-Core中启用内存中缓存"><a href="#在ASP-NET-Core中启用内存中缓存" class="headerlink" title="在ASP.NET Core中启用内存中缓存"></a>在ASP.NET Core中启用内存中缓存</h2><p>我们可以使用<strong>ConfigureServices</strong>方法将ASP.NET内存中缓存合并到应用程序中。您可以在<strong>Startup</strong>类中启用<em>内存中缓存</em>，如下面的代码片段所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void ConfigureServices(IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    services.AddMvc();</span><br><span class="line">    services.AddMemoryCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 该<strong>AddMemoryCache</strong>方法允许我们注册<em>IMemoryCache</em>接口，如上面提到的，将被用于高速缓存的基础。下面我们看到框架中接口的定义： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface IMemoryCache : IDisposable</span><br><span class="line">&#123;</span><br><span class="line">    bool TryGetValue(object key, out object value);</span><br><span class="line">    ICacheEntry CreateEntry(object key);</span><br><span class="line">    void Remove(object key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 接口中提供的方法并不是唯一可用于缓存的方法：我们将在后面看到，存在各种扩展来丰富可用的API并极大地促进其使用。例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static class CacheExtensions</span><br><span class="line">&#123;</span><br><span class="line">    public static TItem Get&lt;titem&gt;(this IMemoryCache cache, object key);</span><br><span class="line">     </span><br><span class="line">    public static TItem Set&lt;titem&gt;(this IMemoryCache cache, object key, TItem value, MemoryCacheEntryOptions options);</span><br><span class="line"> </span><br><span class="line">    public static bool TryGetValue&lt;titem&gt;(this IMemoryCache cache, object key, out TItem value);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 注册后，该接口可以注入到我们要使用它的类构造函数中，如下所示： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private IMemoryCache cache;</span><br><span class="line">public MyCacheController(IMemoryCache cache)</span><br><span class="line">    &#123;</span><br><span class="line">        this.cache = cache;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在下面的部分中，我们将研究如何在ASP.NET Core中使用缓存API来存储和检索对象。</p>
<h2 id="使用IMemoryCache存储和检索项目"><a href="#使用IMemoryCache存储和检索项目" class="headerlink" title="使用IMemoryCache存储和检索项目"></a>使用IMemoryCache存储和检索项目</h2><p>要使用<strong>IMemoryCache</strong>接口写入对象，请使用<strong>Set （）</strong>方法，如以下代码片段所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[HttpGet]</span><br><span class="line">public string Get()</span><br><span class="line">&#123;</span><br><span class="line">    cache.Set(“MyKey”, DateTime.Now.ToString());</span><br><span class="line">    return “This is a test method...”;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 此方法接受两个参数，第一个是键，用于标识缓存的对象，第二个参数是我们要存储的值。要从缓存中检索对象，请使用<strong>Get （）</strong>方法，如下面的代码片段所示。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[HttpGet(“&#123;key&#125;”)]</span><br><span class="line">public string Get(string key)</span><br><span class="line">&#123;</span><br><span class="line">    return cache.Get&lt;string&gt;(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们不确定缓存中是否存在特定的密钥，则可以使用TryGetValue（）方法进行帮助：它返回一个布尔值，指示所请求的密钥存在或不存在。</p>
<p>下面是如何使用<em>TryGetValue</em>修改<em>Get（）</em>方法的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[HttpGet(“&#123;key&#125;”)]</span><br><span class="line">public string Get(string key)</span><br><span class="line">&#123;</span><br><span class="line">    string obj;</span><br><span class="line">    if (!cache.TryGetValue&lt;string&gt;(key, out obj))</span><br><span class="line">     </span><br><span class="line">        obj = DateTime.Now.ToString();</span><br><span class="line">        cache.Set&lt;string&gt;(key, obj);</span><br><span class="line">     </span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可用的另一种方法是<strong>GetOrCreate（）</strong>方法，该方法验证所需密钥的存在，否则，该方法将为您创建它。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[HttpGet(“&#123;key&#125;”)]</span><br><span class="line">public string Get(string key)</span><br><span class="line">&#123;</span><br><span class="line">    return cache.GetOrCreate&lt;string&gt;(“key”,</span><br><span class="line">        cacheEntry =&gt; &#123;</span><br><span class="line">            return DateTime.Now.ToString();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何在ASP-NET-Core中的缓存数据上设置过期策略"><a href="#如何在ASP-NET-Core中的缓存数据上设置过期策略" class="headerlink" title="如何在ASP.NET Core中的缓存数据上设置过期策略"></a>如何在ASP.NET Core中的缓存数据上设置过期策略</h2><p>当我们使用IMemoryCache存储对象时，<strong>MemoryCacheEntryOptions</strong>类为我们提供了各种技术来管理缓存数据的到期时间。</p>
<p> 我们可以指定一个固定的时间，在该时间之后某个特定的密钥将过期（<strong>绝对过期</strong>），或者如果在某个特定的时间（<strong>滑动过期</strong>）之后没有访问它，则它可以过期。此外，还可以使用<strong>Expiration Token</strong>在缓存的对象之间创建依赖关系。这里有一些例子 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//absolute expiration using TimeSpan</span><br><span class="line">_cache.Set(&quot;key&quot;, item, TimeSpan.FromDays(1));</span><br><span class="line"> </span><br><span class="line">//absolute expiration using DateTime</span><br><span class="line">_cache.Set(&quot;key&quot;, item, new DateTime(2020, 1, 1));</span><br><span class="line"> </span><br><span class="line">//sliding expiration (evict if not accessed for 7 days)</span><br><span class="line">_cache.Set(&quot;key&quot;, item, new MemoryCacheEntryOptions</span><br><span class="line">&#123;</span><br><span class="line">    SlidingExpiration = TimeSpan.FromDays(7)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">//use both absolute and sliding expiration</span><br><span class="line">_cache.Set(&quot;key&quot;, item, new MemoryCacheEntryOptions</span><br><span class="line">&#123;</span><br><span class="line">    AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(30),</span><br><span class="line">    SlidingExpiration = TimeSpan.FromDays(7)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">// This method adds a trigger to refresh the data from background</span><br><span class="line">private void UpdateReset()</span><br><span class="line">&#123;</span><br><span class="line">    var mo = new MemoryCacheEntryOptions();</span><br><span class="line">    mo.RegisterPostEvictionCallback(RefreshAllPlacessCache_PostEvictionCallback);</span><br><span class="line">    mo.AddExpirationToken(new CancellationChangeToken(new CancellationTokenSource(TimeSpan.FromMinutes(35)).Token));</span><br><span class="line">    Cache.Set(CACHE_KEY_PLACES_RESET, DateTime.Now, mo);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Method triggered by the cancellation token that triggers the PostEvictionCallBack</span><br><span class="line">private async void RefreshAllPlacesCache_PostEvictionCallback(object key, object value, EvictionReason reason, object state)</span><br><span class="line">&#123;</span><br><span class="line">    // Regenerate a set of updated data</span><br><span class="line">    var places = await GetLongGeneratingData();</span><br><span class="line">    Cache.Set(CACHE_KEY_PLACES, places, TimeSpan.FromMinutes(40));</span><br><span class="line"> </span><br><span class="line">    // Re-set the cache to be reloaded in 35min</span><br><span class="line">    UpdateReset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存回调"><a href="#缓存回调" class="headerlink" title="缓存回调"></a>缓存回调</h2><p><strong>MemoryCacheEntryOptions</strong>类提供的另一个有趣功能是允许我们注册回调的功能，当从缓存中删除一项时将执行该回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MemoryCacheEntryOptions cacheOption = new MemoryCacheEntryOptions()  </span><br><span class="line">&#123;  </span><br><span class="line">    AbsoluteExpirationRelativeToNow = (DateTime.Now.AddMinutes(1) - DateTime.Now),  </span><br><span class="line">&#125;;  </span><br><span class="line">cacheOption.RegisterPostEvictionCallback(  </span><br><span class="line">    (key, value, reason, substate) =&gt;  </span><br><span class="line">    &#123;  </span><br><span class="line">        Console.Write(&quot;Cache expired!&quot;);  </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="缓存标签助手"><a href="#缓存标签助手" class="headerlink" title="缓存标签助手"></a>缓存标签助手</h2><p>到目前为止，我们已经看到.NET Core提供的API的使用，从而能够直接使用IMemoryCache接口手动在缓存中写入和读取项目。此接口还有其他实现，可能非常有用。例如，在Web环境中，如果我们使用.NET Core MVC框架，则可以使用<strong>helper cache tag</strong>存储部分页面。它非常简单易用：您可以将视图的一部分包装在缓存标签中以启用缓存：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Ora: @DateTime.Now<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 对于页面的每个后续请求（包含此标记），将从缓存中使用该段的正文。如果将其放在页面上并观察其输出，则可以轻松检查行为。当然，我们使用它的方式仅出于示例目的，但是当您尝试渲染需要大量资源的页面时，您可以欣赏它的功能。一个明显的缓存候选是视图<a href="https://www.blexin.com/en-US/Article/Blog/Kestrel-build-me-up-31" target="_blank" rel="noopener">组件</a>调用 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">expires-on</span>=<span class="string">"@TimeSpan.FromSeconds(600)"</span>&gt;</span></span><br><span class="line">@await Component.InvokeAsync("BlogPosts", new &#123; tag = "popular" &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上一个代码段中，您还可以通过属性<strong>expires-on</strong>来了解如何管理缓存中对象的<strong>过期期限</strong>。还有其他两种选择：</p>
<ul>
<li>过期时间：将使用TimeSpan进行评估以指示一段时间，此后必须重新生成内容；</li>
<li>过期滑动：还应使用指示闲置时间的TimeSpan。每次从缓存中读取内容时，都会将其删除延迟。</li>
</ul>
<p>另一个可定制方面涉及配置缓存标准的可能性。我们可能需要根据一些变量来更新缓存的对象。一些要求是由覆盖<strong>变化逐</strong>下列属性：</p>
<ul>
<li>按路由变化：通过<strong>路由参数</strong>的名称（例如id）进行了增强，以指示在指示的属性更改时必须重新生成内容；</li>
<li>因查询而异：当更改<strong>查询字符串键</strong>时，将生成并缓存内容；</li>
<li>按用户不同：当我们显示已登录用户的特定数据时（例如，包含名称和照片的个人资料框），必须将其设置为true；</li>
<li>按标题变化：如果我们使用HTTP请求标头显示语言内容，则根据HTTP请求标头来更改缓存，例如“ Accept-Language”。</li>
<li>cookie-variable-by-cookie：允许您根据cookie的内容更改缓存，我们必须指出其名称。</li>
</ul>
<p>可以使用一个或多个按属性的属性来执行高级缓存策略，但是，有句著名的名言：“功能<em>强大，责任重大</em> ”。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>使用内存缓存可以使您将数据存储在服务器的内存中，并通过删除对外部数据源的不必要请求来帮助我们提高应用程序性能。如我们所见，它非常易于使用。</p>
<p>我提醒您，当您的应用程序托管在多台服务器或云托管环境中时，不能使用这种方法。在下一篇文章中，我们将讨论分布式缓存。</p>
<p>下次见！</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/07/20/技术/常见的C＃异常及其修复方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/07/20/技术/常见的C＃异常及其修复方法/" class="post-title-link" itemprop="url">常见的C＃异常及其修复方法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-07-20 21:05:00" itemprop="dateCreated datePublished" datetime="2020-07-20T21:05:00+00:00">2020-07-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2021-04-25 11:04:00" itemprop="dateModified" datetime="2021-04-25T11:04:00+00:00">2021-04-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常见的C＃异常及其修复方法"><a href="#常见的C＃异常及其修复方法" class="headerlink" title="常见的C＃异常及其修复方法"></a>常见的C＃异常及其修复方法</h1><p>如果您今天是依靠编写的软件来谋生，那么您可能至少对异常的概念很熟悉。</p>
<p>Jeff Atwood曾经称它们为“现代编程语言的基础”。<a href="https://raygun.com/blog/java-exceptions-terminology/" target="_blank" rel="noopener">异常</a>是现代软件开发中常见且有用的结构，但有时它们也可能造成混乱。</p>
<p>那么什么<em>是</em>异常？更具体地说，C＃异常的主要类型是什么，以及如何使用它们？</p>
<p>今天的帖子将回答上述问题以及更多问题。我们将从“异常”的简要定义开始，然后继续解释该结构的组成部分。最后，我们将概述最常见的C＃异常以及如何处理它们。</p>
<p>让我们开始吧。</p>
<h2 id="有什么异常？"><a href="#有什么异常？" class="headerlink" title="有什么异常？"></a>有什么异常？</h2><p>异常是一种可用于处理错误的机制。就这么简单。在某些情况下，例如，C程序员将返回错误代码，而<a href="https://raygun.com/blog/java-exceptions-terminology/" target="_blank" rel="noopener">Java</a>或C＃程序员都很有可能引发异常。</p>
<p>异常表示执行流程的突然中断。一旦引发异常，执行就会停止。如果未处理异常，则应用程序崩溃。</p>
<p>但是，实际上您是如何做到的呢？您如何引发或捕获异常？所有这些甚至意味着什么？</p>
<p>这就是我们将在下一部分中详细介绍的内容。</p>
<h2 id="C＃异常剖析"><a href="#C＃异常剖析" class="headerlink" title="C＃异常剖析"></a>C＃异常剖析</h2><p>现在，我们将简要介绍C＃异常的情况。您将了解应该使用的主要关键字，这些关键字不仅可以捕获和处理异常，还可以抛出自己的异常。我们列表上的第一个是<code>try</code>关键字和块。</p>
<h3 id="try"><a href="#try" class="headerlink" title="try"></a>try</h3><p>异常处理解剖的第一部分是<code>try</code>块。您可以使用它来尝试执行一些可能引发异常的代码。考虑以下代码摘录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string content = string.Empty;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    content = System.IO.File.ReadAllText(@&quot;C:\file.txt&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码声明了一个变量，并为其分配了空字符串。然后，我们有了<code>try</code>块。块中的单行代码<code>try</code>使用该类中的<code>ReadAllText</code>静态方法<code>System.IO.File</code>。我们担心该路径表示的文件可能不存在，在这种情况下会引发异常。但是，当然，这还不够。我们的代码不执行任何处理异常的操作。它甚至目前还没有编译！这是来自编译器的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expected catch or finally</span><br></pre></td></tr></table></figure>

<p>该消息是不言自明的。我们需要 <code>catch</code>或<code>finally</code>代码块，因为尝试处理异常然后忘记执行处理部分没有任何意义。让我们开始吧。</p>
<h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p><code>catch</code>代码块使我们能够实际处理异常。我们将使用更多代码扩展前面的示例。</p>
<p>看看这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    string content = string.Empty;</span><br><span class="line"></span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;First message inside try block.&quot;);</span><br><span class="line">        Console.WriteLine(&quot;Second message inside try block.&quot;);</span><br><span class="line">        content = System.IO.File.ReadAllText(@&quot;C:\file.txt&quot;);</span><br><span class="line">        Console.WriteLine(&quot;Third message inside try block. This shouldn&apos;t be printed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    catch</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;First message inside the catch block.&quot;);</span><br><span class="line">        Console.WriteLine(&quot;Second message inside the catch block.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(&quot;Outside the try-catch.&quot;);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果运行上面的代码，则应看到以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">First message inside try block.</span><br><span class="line">Second message inside try block.</span><br><span class="line">First message inside the catch block.</span><br><span class="line">Second message inside the catch block.</span><br><span class="line">Outside try-catch.</span><br></pre></td></tr></table></figure>

<p>该路径处的文件不存在，因此将引发<code>System.FileNotFoundException</code>。发生这种情况时，执行流程将立即中断。因此，将在try块中打印“第三条消息”的行。这不应该被打印。” 永远不会被执行。</p>
<p>执行流程由<code>catch</code>块执行。完成后，将控制权交还给main方法，然后打印<code>Outside try-catch</code>。并等待用户输入。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>在了解了<code>try</code>和之后<code>catch</code>，我们终于（没有双关语）准备好使用这个非常有用但经常被误解的异常处理机制的一部分。那么，什么是<code>finally</code>？</p>
<p>该<code>finally</code>块是一种确保将执行给定代码段的方式，无论是否引发异常。考虑下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    content = System.IO.File.ReadAllText(path);</span><br><span class="line">    Console.WriteLine(&quot;If you&apos;re reading this, no exception was thrown.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch (System.IO.FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;If you&apos;re reading this, an exception was thrown.&quot;);</span><br><span class="line">    Console.WriteLine(&quot;Message: &quot; + e.Message);</span><br><span class="line">&#125;</span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;This will be printed, no matter what.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那仍然是相同的示例，但是现在要简单得多。注意最后的<code>finally</code>块。如果运行此代码，则应该看到以下消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">If you&apos;re reading this, an exception was thrown.</span><br><span class="line">Message: Could not find file &apos;C:\file.txt&apos;.</span><br><span class="line">This will be printed, no matter what.</span><br><span class="line">Outside the try-catch.</span><br></pre></td></tr></table></figure>

<p>现在让我们模拟文件的存在。注释掉试图从文件中读取的行，然后再次运行该应用程序。这是您现在应该看到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If you&apos;re reading this, no exception was thrown.</span><br><span class="line">This will be printed, no matter what.</span><br><span class="line">Outside the try-catch.</span><br></pre></td></tr></table></figure>

<p>如您所见，在最近的场景中，没有引发异常，因此该<code>catch</code>块中没有执行任何行。另一方面，<code>finally</code>在两种情况下都执行了该块。</p>
<h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>当涉及到异常时，您将不会总是从别人那里处理它们。您也可以自己抛出异常。为此，您将使用<code>throw</code>关键字，然后是要引发的异常的类的实例化。以下代码举例说明了这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ProductService(IProductRepository repository)</span><br><span class="line">&#123;</span><br><span class="line">    if (repository == null)</span><br><span class="line">        throw new ArgumentNullException();</span><br><span class="line"></span><br><span class="line">    this.repository = repository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见的-NET异常"><a href="#常见的-NET异常" class="headerlink" title="常见的.NET异常"></a>常见的.NET异常</h2><p>以下是常见的.NET异常列表：</p>
<h3 id="System-NullReferenceException"><a href="#System-NullReferenceException" class="headerlink" title="System.NullReferenceException"></a>System.NullReferenceException</h3><p>这是最著名的（甚至是臭名昭著的）异常之一。当您尝试调用方法/属性/索引器/等时，抛出此异常。在包含空引用的变量（即，它不指向任何对象）。下面的代码将导致空引用异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = people.Where(x =&gt; x.SSN == verifySsn).FirstOrDefault();</span><br><span class="line">string name = p.Name;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们过滤了将每个项目的SSN属性与<code>verifySsnvariable</code>变量进行比较的序列。然后，我们使用该<code>FirstOrDefault()</code>方法从序列中仅提取第一项。如果序列不产生任何项目，则它将返回该类型的默认值。由于<code>Person</code>是引用类型，因此其返回值为null。</p>
<p>在下一行，我们尝试<code>Name</code>在空引用上取消引用属性。<em>繁荣！</em>空引用异常。</p>
<p>这是通常不抛出也不捕获的异常。您不要扔它，因为它毫无意义。如果您想与代码的客户交流，给定方法不接受null作为其参数的有效值，则使用的正确异常是<code>System.ArgumentNullException</code>。</p>
<p>您如何“修复”此异常？简而言之，您必须对可为空性小心谨慎。如果您正在编写将由第三方使用的任何代码（即使这些第三方是您的同事），则请认真考虑是否接受空引用作为有效值。</p>
<p>无论您做出什么决定，都必须使该决定非常明确并记录在案。您可以通过抛出<code>System.ArgumentNullException</code>，例如，并在方法上使用XML文档标题来实现。</p>
<h3 id="System-IndexOutOfRangeException"><a href="#System-IndexOutOfRangeException" class="headerlink" title="System.IndexOutOfRangeException"></a>System.IndexOutOfRangeException</h3><p>在应用程序代码通常不会抛出或捕获该异常的意义上，该异常与上一个异常类似。</p>
<p>那为什么呢？</p>
<p>好吧，当您尝试使用无效的索引值访问数组，列表或任何可索引序列中的元素时，将引发此异常。一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void PrintUrlSufix(string url)</span><br><span class="line">&#123;</span><br><span class="line">    var parts = url.Split(&apos;.&apos;);</span><br><span class="line">    Console.WriteLine(parts[2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码显然希望使用<strong><a href="http://www.acme.com" target="_blank" rel="noopener">www.acme.com</a></strong>格式的URL 。但是，如果只是获得<strong>acme.com</strong>怎么办？为此，如果得到<strong>Hakuna Matata</strong>怎么办？是的，没错：<code>System.IndexOutOfBoundException</code>是的。</p>
<p>您如何避免遇到此异常？永远不要把事情视为理所当然。永远不要仅仅假设数据将采用正确的格式。做您的尽职调查和检查的东西。</p>
<h3 id="System-IO-IOException"><a href="#System-IO-IOException" class="headerlink" title="System.IO.IOException"></a>System.IO.IOException</h3><p>此C＃异常具有一个不言自明的名称。这正是您的想法：这是IO操作期间发生错误时引发的异常。与前两个异常不同，您可能会发现自己不时捕捉或抛出其中一个。</p>
<p>本<code>IOException</code>类实际上是一些更具体的异常，例如：</p>
<ul>
<li>DirectoryNotFoundException</li>
<li>EndOfStreamException</li>
<li>FileNotFoundException</li>
<li>FileLoadException</li>
<li>PathTooLongException</li>
</ul>
<p>有关的文档，<code>IOException</code>建议您尽可能使用更具体的异常，而不是更一般的异常。</p>
<h3 id="System-Net-WebException"><a href="#System-Net-WebException" class="headerlink" title="System.Net.WebException"></a>System.Net.WebException</h3><p>此异常与网络有关。如果使用<a href="https://docs.microsoft.com/dotnet/framework/network-programming/introducing-pluggable-protocols" target="_blank" rel="noopener">可插拔协议</a>访问网络时发生错误，则抛出该错误<a href="https://docs.microsoft.com/dotnet/framework/network-programming/introducing-pluggable-protocols" target="_blank" rel="noopener">。</a>处理此异常时，请记住验证该<code>Response</code>属性，该属性将包含远程主机返回的响应。</p>
<h3 id="System-Data-SqlClient-SqlException"><a href="#System-Data-SqlClient-SqlException" class="headerlink" title="System.Data.SqlClient.SqlException"></a>System.Data.SqlClient.SqlException</h3><p>此异常与数据库（特别是SQL Server）有关。SQL Server返回错误或警告时将引发该错误。该类具有一个称为的属性<code>Errors</code>，该属性是一个包含<code>SqlError</code>该类的一个或多个实例的集合。依次包含有关发生的错误的详细信息。</p>
<h3 id="System-StackOverflowException"><a href="#System-StackOverflowException" class="headerlink" title="System.StackOverflowException"></a>System.StackOverflowException</h3><p>当执行堆栈溢出时，抛出此异常，这通常意味着递归出错。该代码有太多的嵌套方法调用。事情就是这样：这个异常是无法捕获的-至少从.NET 2.0起就没有-这意味着当抛出该异常时，您几乎没有其他选择。默认情况下，您的过程将被终止。</p>
<p>您应该做的而不是捕获此异常的方法是编写代码，以防止它首先发生。</p>
<h3 id="System-OutOfMemoryException"><a href="#System-OutOfMemoryException" class="headerlink" title="System.OutOfMemoryException"></a>System.OutOfMemoryException</h3><p>可以说这是<a href="https://stackoverflow.com/questions/1153702/system-outofmemoryexception-was-thrown-when-there-is-still-plenty-of-memory-fr" target="_blank" rel="noopener">最令人困惑的C＃异常之一</a>。网上有很多资源<a href="https://blogs.msdn.microsoft.com/ericlippert/2009/06/08/out-of-memory-does-not-refer-to-physical-memory/" target="_blank" rel="noopener">可以很好地阐明问题</a>，但是我将在此处提供一个简短的版本。发生的情况是此异常不涉及可用的物理内存。</p>
<p>那么，什么时候抛出此异常？</p>
<p>您知道何时要停车吗，因为其他驾驶员未正确停车而不能停车吗？如果您只需在停放的汽车之间添加所有可用空间，就足以容纳您的车辆。但是目前不可能，因为它不是连续的区域。</p>
<p>当您获得此内存时，这差不多发生了什么。可能有很多可用的总内存，但是没有连续的部分可以满足所需的分配。实际上，例如，如果您尝试将 <code>StringBuilder</code>的<code>MaxCapacity</code>属性扩展到该属性之外，则会发生此异常。</p>
<h3 id="System-InvalidCastException"><a href="#System-InvalidCastException" class="headerlink" title="System.InvalidCastException"></a>System.InvalidCastException</h3><p>此异常也具有不言自明的名称。当代码由于未定义强制类型转换而无法从一种类型转换为另一种类型时，将引发该错误。以下代码将引发此类型的异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object o = &quot;10&quot;;</span><br><span class="line">int x = (int)o;</span><br></pre></td></tr></table></figure>

<p>这是您通常不会捕获的异常。相反，您将以不会发生的方式编写代码。例如，以下代码在尝试强制类型转换之前进行类型检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public override bool Equals (object obj )</span><br><span class="line">&#123;</span><br><span class="line">   if (!obj is Foo)</span><br><span class="line">       return false;</span><br><span class="line"></span><br><span class="line">   Foo other = (Foo)obj;</span><br><span class="line">   return this.bar == other.bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码可以使用简化的<a href="https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/as" target="_blank" rel="noopener"><code>as</code>操作符</a>，在这里我没有进一步具体说明，作为一个练习留给读者。无论如何，这就是问题：您实际上应该尝试做的是避免问题，而不是首先进行转换。利用泛型来防止陷入需要强制转换的情况。</p>
<h3 id="System-InvalidOperationException"><a href="#System-InvalidOperationException" class="headerlink" title="System.InvalidOperationException"></a>System.InvalidOperationException</h3><p>像之前的许多其他异常一样，这种异常通常是您不会发现的。相反，您应该做的是编写不会发生的代码。考虑以下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var numbers = new List&lt;int&gt; &#123; 1, 3, 5 &#125;;</span><br><span class="line">var firstGreaterThanFive = numbers.Where(x =&gt; x &gt; 5).First();</span><br></pre></td></tr></table></figure>

<p>当序列不产生任何结果时，将抛出First LINQ扩展方法。如果您知道该序列有时可能不会产生结果-没关系-您应该改用FirstOrDefault。在空序列上调用此方法时，将返回序列类型的默认值，而不是抛出异常。</p>
<h3 id="System-ObjectDisposedException"><a href="#System-ObjectDisposedException" class="headerlink" title="System.ObjectDisposedException"></a>System.ObjectDisposedException</h3><p>我们将在这篇文章中介绍的最后一个C＃异常也属于“不应该处理，请修复代码”类别。换句话说，这是开发人员错误。当您尝试使用已处理的<a href="https://docs.microsoft.com/dotnet/api/system.idisposable?view=netframework-4.7.2" target="_blank" rel="noopener">IDisposable</a>进行操作时，将引发此异常。</p>
<p>此当通常发生在开发者调用<code>Dispose</code>，<code>Close</code>或其它类似方法和后来试图访问该对象的一个成员时。</p>
<h2 id="如何成功的进行异常处理？"><a href="#如何成功的进行异常处理？" class="headerlink" title="如何成功的进行异常处理？"></a>如何成功的进行异常处理？</h2><p>错误处理是软件开发教学中经常被忽略的话题，出现异常有时非常不幸。如果没有可靠的<a href="https://raygun.com/blog/errors-and-exceptions/" target="_blank" rel="noopener">错误处理策略</a>，您的应用程序将永远是劣等的。</p>
<p>通过本文，我们希望通过定义异常的概念并对C＃异常的主要类型进行快速概述，以帮助解决该问题。但本文并没有涵盖异常处理的全部。恰好相反，我认为这是一个机会，可以开始引导您对该主题的学习，并且永不停止学习和练习。</p>
<p>祝您能想出一种对您的应用程序有效的策略！</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/07/19/技术/how-to-use-abp-part2-compare-with-three-layers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/07/19/技术/how-to-use-abp-part2-compare-with-three-layers/" class="post-title-link" itemprop="url">如何使用ABP进行软件开发（2）三层架构与领域驱动设计的对比</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-07-19 19:14:00" itemprop="dateCreated datePublished" datetime="2020-07-19T19:14:00+00:00">2020-07-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2021-04-25 11:04:00" itemprop="dateModified" datetime="2021-04-25T11:04:00+00:00">2021-04-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>上一篇简述了ABP框架中的一些基础理论，包括ABP前后端项目的分层结构，以及后端项目中涉及到的知识点，例如DTO,应用服务层，整洁架构，领域对象（如实体，聚合，值对象）等。</p>
<p>笔者也曾经提到，ABP依赖于领域驱动设计这门方法论，由于其门槛较高，给使用者带来了不少理解上的难度。尤其是三层架构对.NET开发者影响太深，有时很难对领域驱动设计产生直观的理解。</p>
<p>在本文中，打算从传统的简单三层架构谈起，介绍一个实际场景下的三层业务逻辑实现，然后再与领域驱动设计中的对应实现形成对比，以便让开发者形成直观具体的印象。</p>
<h1 id="回顾三层架构"><a href="#回顾三层架构" class="headerlink" title="回顾三层架构"></a>回顾三层架构</h1><p>对于.NET开发者来说，三层架构相比都不陌生，这种架构，将代码层次划分为用户界面层，业务逻辑层、数据访问层三个逻辑层次，实现了代码的关注度分离，且因其易于理解，已经成为众多.NET开发者的”条件反射”。</p>
<h2 id="三层架构简介"><a href="#三层架构简介" class="headerlink" title="三层架构简介"></a>三层架构简介</h2><p>三层架构就是为了符合“高内聚，低耦合”思想，把各个功能模块划分为表示层（UI）、业务逻辑层（BLL）和数据访问层（DAL）三层架构，各层之间采用接口相互访问，并通过对象模型的实体类（Model）作为数据传递的载体，不同的对象模型的实体类一般对应于数据库的不同表，实体类的属性与数据库表的字段名一致。</p>
<p>三层架构区分层次的目的是为了 “高内聚，低耦合”。开发人员分工更明确，将精力更专注于应用系统核心业务逻辑的分析、设计和开发，加快项目的进度，提高了开发效率，有利于项目的更新和维护工作。</p>
<h2 id="三层架构的分层逻辑"><a href="#三层架构的分层逻辑" class="headerlink" title="三层架构的分层逻辑"></a>三层架构的分层逻辑</h2><p>UI层：用户界面层，实现与UI交互有关的逻辑。用于输入用户数据，输出和呈现数据。在基于WebAPI的现代Web框架中，往往会使用MVC架构，将界面的数据行为，拆分成“模型-视图-控制器”，实现了针对对UI层上关注度的进一步分离，</p>
<p>业务逻辑层： 业务逻辑层是用户界面层和数据访问层之间的转换层，负责完成对数据的业务组装，界面数据处理，将数据层的对象输出（转换）给用户界面层。</p>
<p>数据访问层：实现数据的存储（持久化）操作，包括集成存储过程，集成SQL语句，或集成现代ORM组件的形式，实现实现数据的存储。  </p>
<p><img src="/images/compare-with_three-layers_1.png" alt="图片"></p>
<h2 id="三层架构的应用"><a href="#三层架构的应用" class="headerlink" title="三层架构的应用"></a>三层架构的应用</h2><p>遇到项目，先从实体关系建模开始，使用PowerDesign或其他数据库设计软件分析业务与业务之间的关系，是一对多，还是一对一，还是多对多，绘制实体关系图。</p>
<p><img src="/images/compare-with_three-layers_2.png" alt="图片"></p>
<p>在进行软件开发时，根据数据需求，定制想要的数据接口，从而实现以数据为核心的业务功能开发。</p>
<p>于是，在业务层次上，这种三层架构，进一步可以表示为如下分层结构：</p>
<p><img src="/images/compare-with_three-layers_3.png" alt="图片"></p>
<p>在三层架构中，实体是业务的核心，所有的业务代码，都是围绕实体展开，而左侧三个功能层，其主要目的都是为了实现对实体的“增删改查”操作。</p>
<p>以下代码简述了一个订单对象提交的全过程。（模型和代码仅供参考，不能直接运行）</p>
<p><img src="/images/compare-with_three-layers_4.png" alt="图片"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// UI控制器</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class OrderController</span><br><span class="line">&#123;</span><br><span class="line">  private OrderBll OrderBll = new OrderBll();</span><br><span class="line">  /// &lt;summary&gt;</span><br><span class="line">  /// 新增订单</span><br><span class="line">  /// &lt;/summary&gt;</span><br><span class="line">  /// &lt;param name=&quot;userId&quot;&gt;&lt;/param&gt;</span><br><span class="line">  /// &lt;param name=&quot;productId&quot;&gt;&lt;/param&gt;</span><br><span class="line">  /// &lt;param name=&quot;count&quot;&gt;&lt;/param&gt;</span><br><span class="line">  public void AddOrder(int userId, int productId, int count)</span><br><span class="line">  &#123;</span><br><span class="line">      OrderBll.AddOrder(userId, productId, count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 业务逻辑层</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class OrderBll</span><br><span class="line">&#123;</span><br><span class="line">  private UserInfoDal userInfoDal = new UserInfoDal();</span><br><span class="line">  private ProductInfoDal productInfoDal = new ProductInfoDal();</span><br><span class="line">  private OrderDal orderDal = new OrderDal();</span><br><span class="line">  /// &lt;summary&gt;</span><br><span class="line">  /// 新增订单</span><br><span class="line">  /// &lt;/summary&gt;</span><br><span class="line">  /// &lt;param name=&quot;userId&quot;&gt;&lt;/param&gt;</span><br><span class="line">  /// &lt;param name=&quot;productId&quot;&gt;&lt;/param&gt;</span><br><span class="line">  /// &lt;param name=&quot;count&quot;&gt;&lt;/param&gt;</span><br><span class="line">  public void CreateOrder(int userId, int productId, int count)</span><br><span class="line">  &#123;</span><br><span class="line">      UserInfo userInfo = userInfoDal.Get(userId);</span><br><span class="line">      ProductInfo productInfo = productInfoDal.Get(productId);</span><br><span class="line">      //新订单</span><br><span class="line">      Order order = new Order();</span><br><span class="line">      order.Address = userInfo.Address;</span><br><span class="line">      order.UserId = userId;</span><br><span class="line">      order.TotalPrice = productInfo.Price * count;</span><br><span class="line">      order.ProductId = productId;</span><br><span class="line">      orderDal.Insert(order);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 数据访问层</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class OrderDal</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 插入数据</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;order&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public void Insert(Order order)</span><br><span class="line">    &#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种基于实体驱动建模的三层架构，变成了以数据为核心的“表模块模式”。<br>参见《企业应用架构模式》第87页中关于表模块的介绍：</p>
<blockquote>
<p>表模块以一个类对应数据库中的一个表来组织领域逻辑，而且使用单一的类实体来包含将对数据进行的各种操作程序。<br>通常，表模块会与面向表的后端数据结构一起使用。以列表形式排列的数据通常是某个SQL调用的结果，它们被至于一个记录集中，用于某一个SQL表。表模块提供了一个明确的基于方法的接口对数据进行操作。<br>要进行一些实际的操作，一般需要多个表模块的行为。<br>表模块中的“表”一词，暗示你数据库中的每一个表对应一个表模块。虽然大多数情况下都是如此，但也并非绝对。对于通用的视图或其他查询，建立一个表模块也是有用的。事实上，表模块的结构并非真的取决于数据库表的结构，更多的是由应用程序能识别的虚拟表所标识，例如视图或查询。</p>
</blockquote>
<p>在《Microsoft.NET企业级架构设计》一书中，作者认为“多数.NET开发者在成长的过程中都受到了表模块模式的影响”。而相比之下，多数Java开发者则“深陷事务脚本的泥足”。</p>
<h2 id="三层架构的优缺点"><a href="#三层架构的优缺点" class="headerlink" title="三层架构的优缺点"></a>三层架构的优缺点</h2><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>软件分层架构的目的是为了分离关注点，三层架构也同样如此，简简单单的三层代码+ER图，就能设计出一个良好结构的软件系统。</p>
<p>这种模式，建立了以数据库表为核心的开发模式，使得开发者能够很便捷的对业务进行分析，进而驱动软件功能的快速开发。</p>
<p>在应对简单业务变迁过程中，由于能够快速完成代码的堆积，也使得开发者只需关注数据库表的拼凑，就能快速的完成代码开发，为开发项目带来了不少便利。   </p>
<p>除了简单业务普遍采用三层，事实上许多复杂项目也会同样采用，大概是由于三层架构的思想已经深入人心，许多资深开发者都形成的只要有表就能完成项目的开发的思维定势。</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>还是使用上述示例代码，我们假设需求发生了变化，要求减少订单的数量或增加订单，我们会怎么做？也许，我们很容易就写出了下面的代码：</p>
<blockquote>
<p>（当然，实际项目中，如果订单已经提交，很少会直接对订单数量进行修改的，往往会重新发起新订单，但为了演示方便，我们先设定有这么一个奇怪的需求吧。）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 减少订单数量</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;orderId&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;minusCount&quot;&gt;&lt;/param&gt;</span><br><span class="line">public void MinusOrder(int orderId, int minusCount)</span><br><span class="line">&#123;</span><br><span class="line">    Order order = orderDal.Get(orderId);</span><br><span class="line">    order.Count -= minusCount;</span><br><span class="line">    order.TotalPrice -= order.Price * minusCount;</span><br><span class="line">    orderDal.Update(order);</span><br><span class="line">&#125;</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 增加订单数量</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;orderId&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;minusCount&quot;&gt;&lt;/param&gt;</span><br><span class="line">public void AddOrder(int orderId, int addCount)</span><br><span class="line">&#123;</span><br><span class="line">    Order order = orderDal.Get(orderId);</span><br><span class="line">    order.Count += addCount;</span><br><span class="line">    order.TotalPrice += order.Price * addCount;</span><br><span class="line">    orderDal.Update(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码写起来非常快，因为只是新增了两小段代码逻辑，而从减少订单，到新增订单，只是加法和减法的区别，自然而然就更快了。<br>但是，速度快，一定是优点么？如果需求继续持续不断的累积呢。</p>
<p>例如，我们要修改订单收货人，收货地址，修改订单价格，是不是我们这种代码逻辑会越来越多，而且不同的业务逻辑互相搅合，使得后期的维护变得越来越困难？</p>
<p>所以，笔者认为，三层架构的缺点，就是前期开发速度太快，由于缺乏设计思想和设计模式的参与，太容易导致异味、垃圾代码、重复代码等问题产生。</p>
<p>所有这些问题，最终都被归类于“技术债”的范畴。</p>
<blockquote>
<p>详见维基百科。<br>技术债：指开发人员为了加速软件开发，在应该采用最佳方案时进行了妥协，改用了短期内能加速软件开发的方案，从而在未来给自己带来的额外开发负担。<br>这种技术上的选择，就像一笔债务一样，虽然眼前看起来可以得到好处，但必须在未来偿还。<br>软件工程师必须付出额外的时间和精力持续修复之前的妥协所造成的问题及副作用，或是进行重构，把架构改善为最佳实现方式。</p>
</blockquote>
<h1 id="回顾领域驱动设计"><a href="#回顾领域驱动设计" class="headerlink" title="回顾领域驱动设计"></a>回顾领域驱动设计</h1><h2 id="领域驱动设计简介"><a href="#领域驱动设计简介" class="headerlink" title="领域驱动设计简介"></a>领域驱动设计简介</h2><p>领域驱动设计思想来源于埃里克埃文斯在2002年前后出版的技术书籍《领域驱动设计·软件系统复杂性核心应对之道》，在这本书中，作者介绍了领域驱动设计相关的核心模式，例如：统一语言，模型驱动设计，领域实体，聚合，值对象，仓储，限界上下文等模式。 </p>
<p>随着微服务的不断兴起，领域驱动设计也越来越受到互联网人的广泛追捧，在许多不同的行业应用实践过程中，已经逐渐扮演了非常基础的作用。无论是微服务架构下的服务粒度拆分，或者甚至是中台应用，以及传统的单体应用，都可以利用领域驱动设计思想下提供的模式，为应用程序的开发插上想象的翅膀。</p>
<h2 id="领域驱动设计的分层逻辑"><a href="#领域驱动设计的分层逻辑" class="headerlink" title="领域驱动设计的分层逻辑"></a>领域驱动设计的分层逻辑</h2><p>在上一篇博客中，我们也介绍了领域驱动设计思想分层逻辑结构，共划分为如下四个层次：</p>
<p><img src="/images/compare-with_three-layers_5.png" alt="图片"></p>
<ul>
<li>用户界面层（或者表示层）：负责向用户显示信息和解释用户指令。这里的用户，既可以是使用用户界面的人，也可以是另外一个计算机系统。</li>
<li>应用层：定义软件要完成的任务，并且只会表达领域概念的对象来解决问题。这一层实际上负责的是系统与应用层进行交互的必要渠道。</li>
<li>领域层：负责表达业务概念、业务状态信息以及业务规则。尽管技术细节由基础设施层实现，但业务情况状态的反映则需要有领域层进行控制。领域层是业务软件的核心。</li>
<li>基础设施层：为上面各层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件等等。基础设施层还能够通过架构框架来支持4个层次间的交互模式。<h2 id="领域驱动设计的应用步骤"><a href="#领域驱动设计的应用步骤" class="headerlink" title="领域驱动设计的应用步骤"></a>领域驱动设计的应用步骤</h2></li>
</ul>
<h3 id="1）形成统一语言"><a href="#1）形成统一语言" class="headerlink" title="1）形成统一语言"></a>1）形成统一语言</h3><p>统一语言是围绕产品展开的一系列流程，方案，术语和名词解释及匹配的注释。在领域驱动设计为每个应用设计成体系的【统一语言】是核心要点。</p>
<p>统一语言的形成是团队成员协同参与，围绕不同的需求，达成一致性理解的过程。</p>
<p>形成统一语言有时需要领域专家的参与，但有时可能难以达到这个条件，用需求代言人也同样能够满足这个条件。</p>
<h3 id="2）使用UML建模和画图"><a href="#2）使用UML建模和画图" class="headerlink" title="2）使用UML建模和画图"></a>2）使用UML建模和画图</h3><ol>
<li>建模的必要性</li>
</ol>
<p>在我们工作过程中模型无处不在，不管是在纸上绘制的简单模型，或者使用专业软件绘制的各种模型，都是模型。领域驱动设计本身，依然依赖于模型驱动设计。</p>
<p>学会建模对于广大开发者来说，都是一项基本技能，当然也是众多最弱技能中的一种，因为广泛依赖于实体关系建模的思维模式，使得开发者已经很难形成有效的模型设计思想，代码也越来越趋于【过程化】。 </p>
<p>有时开发者甚至连实体关系建模这个步骤都会省略，直接使用Code First或甚至数据库开始建表，这样看起来速度非常快，但是太容易翻车了。</p>
<p>在团队协作项目中，没有良好的模型，仅凭高级开发者或有经验开发者的“”一面之词”进行设计，几乎很难完成一个复杂项目。</p>
<p>而uml统一建模语言也是这样的良好工具。</p>
<ol start="2">
<li>使用哪些模型</li>
</ol>
<p>笔者曾经有幸请教国内.NET技术圈拥有多年DDD实践经验的阿里技术专家，汤雪华老师，他指出：</p>
<blockquote>
<p>采用实体关系建模很容易看出对象与对象的关系，但仅此而已。数据并非对象，数据也无法看出行为，如果要依托实体关系建模来构建系统，往往需要开发者发挥自己的主观抽象思维，根据客户提供的资料或可用的原型，自行思考代码的逻辑实现。<br>但显然，具备优秀逻辑思维能力和设计思想的开发者凤毛麟角，仅凭ER图，代码写出来往往很糟糕。</p>
</blockquote>
<p>他认为，采用领域驱动设计，产品架构图，系统架构图，领域模型图，类图，关键业务场景的交互时序图，这些是必不可少的。</p>
<ul>
<li>产品架构图：列出产品功能，表现出产品模块间的相关性。</li>
</ul>
<p><img src="/images/compare-with_three-layers_6.png" alt="图片"></p>
<p>图来自<a href="http://www.woshipm.com/pmd/1065960.html" target="_blank" rel="noopener">http://www.woshipm.com/pmd/1065960.html</a></p>
<ul>
<li>系统架构图：从技术层面列出系统模块组成关系。</li>
</ul>
<p><img src="/images/compare-with_three-layers_7.png" alt="图片"></p>
<p>原图来自互联网</p>
<ul>
<li>领域模型关系图：反映出各领域模型间的相关性，限界上下文，聚合，和聚合根。</li>
</ul>
<p><img src="/images/compare-with_three-layers_8.png" alt="图片"></p>
<p>来自<a href="https://102.alibaba.com/detail?id=174" target="_blank" rel="noopener">https://102.alibaba.com/detail?id=174</a></p>
<ol start="3">
<li>如何建模？</li>
</ol>
<p>如果说代码语言是为了与其他开发者进行沟通交流，那我们建立的各种软件设计模型将极大的方便不同领域的人员进行交流。建模也可以称之为语言的一部分。利用uml建立类图，是一种可以比较易于接受的方式。我们可以采用以下手段来建立领域模型。 </p>
<p>1)建立一个与实现绑定的模型。初版的模型也许很简陋，但是它可以成为一个基础，然后在后期逐渐完善。 </p>
<p>2)建立一种基于模型的通用语言或表达形式和机制。通过通用语言让参与项目的所有人理解模型。 </p>
<p>3)开发一个蕴含丰富知识的模型。模型不是单纯的数据结构，它更是各类知识的聚合体。 </p>
<p>4)提炼模型，模型应该能在项目过程中动态改变，发现新的概念就加进来，过时的概念就适时移除，避免臃肿。 </p>
<p>5)头脑风暴和实验。模型在于实践和应用，它需要项目参与者共同的努力，而头脑风暴是发挥集体智慧的良好方式。对模型进行实验或者进行场景的模拟，有利于让模型更符合需求。 </p>
<p>当然，对于领域专家而言，不同类型的模型也许无法理解，例如类图可能过于复杂，可以使用画图的形式，通过解释性的图形，甚至纸面上的图，更能直观的表现出领域的逻辑层次。</p>
<p><img src="/images/compare-with_three-layers_9.png" alt="图片"></p>
<p>这张来自TW分享的一张图，就是一个基于.NET MVC的产品设计UML设计图。</p>
<p>建模也并非这篇博客所能讲清楚的，包括笔者自己，也只是偶尔设计过用例图，时序图和类图，可能需要在后期系统的学习一下。</p>
<h3 id="3）代码实现"><a href="#3）代码实现" class="headerlink" title="3）代码实现"></a>3）代码实现</h3><p>回到最开始的那个三层架构下的代码示例，如果采用领域驱动设计，大概如下图所示：</p>
<p><img src="/images/compare-with_three-layers_10.png" alt="图片"></p>
<p>回到开始那个示例代码，如果采用DDD的代码实现，大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 应用服务层</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public class OrderAppService</span><br><span class="line">&#123;</span><br><span class="line">    private OrderRepository _orderRepository;</span><br><span class="line">    private UserInfoRepository _userInfoRepository;</span><br><span class="line">    private ProductInfoRepository _productInfoRepository;</span><br><span class="line">    public OrderAppService(OrderRepository orderRepository, UserInfoRepository userInfoRepository, ProductInfoRepository productInfoRepository)</span><br><span class="line">    &#123;</span><br><span class="line">        _orderRepository = orderRepository;</span><br><span class="line">        _userInfoRepository = userInfoRepository;</span><br><span class="line">        _productInfoRepository = productInfoRepository; </span><br><span class="line">    &#125;</span><br><span class="line">  /// &lt;summary&gt;</span><br><span class="line">  /// 新增订单</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;userId&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;productId&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;count&quot;&gt;&lt;/param&gt;</span><br><span class="line">        public void CreateOrder(int userId, int productId, int count)</span><br><span class="line">        &#123;</span><br><span class="line">              UserInfo userInfo = _userInfoRepository.Get(userId);</span><br><span class="line">            ProductInfo productInfo = _productInfoRepository.Get(productId);</span><br><span class="line">            if (userInfo != null &amp;&amp; productInfo != null)</span><br><span class="line">            &#123;</span><br><span class="line">                //新订单</span><br><span class="line">                Order order = Order.CreateOrder(productId, userInfo.Address, userId, productInfo.Price, count);</span><br><span class="line">                _orderRepository.Insert(order);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 减少订单数量</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;orderId&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;minusCount&quot;&gt;&lt;/param&gt;</span><br><span class="line">        public void MinusOrder(int orderId, int minusCount)</span><br><span class="line">        &#123;</span><br><span class="line">            Order order = _orderRepository.Get(orderId);</span><br><span class="line">            order.Minus(minusCount);</span><br><span class="line">            _orderRepository.Update(order);</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 增加订单数量</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;orderId&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;minusCount&quot;&gt;&lt;/param&gt;</span><br><span class="line">        public void AddOrder(int orderId, int addCount)</span><br><span class="line">        &#123;</span><br><span class="line">            Order order = _orderRepository.Get(orderId);</span><br><span class="line">            order.Add(addCount);</span><br><span class="line">            _orderRepository.Update(order);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    ///订单对象 </span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public class Order</span><br><span class="line">    &#123;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 主键</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        public int Id &#123; get; protected set; &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 地址</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        public string Address &#123; get; protected set; &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 用户id</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        public int UserId &#123; get; protected set; &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 产品id</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        public int ProductId &#123; get; protected set; &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 数量</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        public int Count &#123; get; protected set; &#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 单价</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        public double Price &#123; get; protected set; &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 总价</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        public double TotalPrice &#123; get; protected set; &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 创建订单</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;productId&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;address&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;userId&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;price&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;count&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">        public static Order CreateOrder(int productId, string address, int userId, double price, int count)</span><br><span class="line">        &#123;</span><br><span class="line">            return new Order()</span><br><span class="line">            &#123;</span><br><span class="line">                Address = address,</span><br><span class="line">                UserId = userId,</span><br><span class="line">                TotalPrice = price * count,</span><br><span class="line">                ProductId = productId,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 新增</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;count&quot;&gt;&lt;/param&gt;</span><br><span class="line">        public void Add(int count)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 减少</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;count&quot;&gt;&lt;/param&gt;</span><br><span class="line">        public void Minus(int count)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码，最主要的变化是如下几点：</p>
<ol>
<li>引入领域模型，在三层架构的示例代码中，我们建立了如下模型：</li>
</ol>
<p><img src="/images/compare-with_three-layers_11.png" alt="图片"></p>
<p>这个模型是当我们Entity Framework脚本时生成的实体模型，在业内通常称其为“贫血模型”。对人类来说，红细胞负责把氧气输送到组织细胞，然后新陈代谢，产生ATP，产生动力。</p>
<p>而“贫血模型”这个术语恰如其份的表现出这类模型虽然还能有效的工作，但是需要由其他对象来驱动其完成动作的含义。</p>
<p>领域模型与贫血模型相比，更关注对象的行为，而关注行为的目的是创建带有公共接口并与在现实世界观察到的实体相似的对象，使得依照统一语言的名字和规则进行建模变得更加容易。</p>
<ol start="2">
<li>将原来的Order对象抽象化建模为一个DDD实体。DDD实体是一个包含数据（属性）和行为（方法）的POCO对象。</li>
</ol>
<p>在《Microsoft .NET企业级应用架构实战》书第9.2.2中指出了领域实体的特点：</p>
<blockquote>
<p>定义明确的身份标识。<br>通过公共和非公共方法表示行为。<br>通过只读属性暴露状态。<br>限制基元类型的使用，使用值对象代替。<br>工厂方法优于多个构造函数。<br>3. 私有set或protected set：</p>
</blockquote>
<p>在示例代码中将Order中的所有属性设置为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public double TotalPrice &#123; get; protected set; &#125;</span><br></pre></td></tr></table></figure>

<p>这样的目的是为了避免对该属性的随意更改，使得开发者在对属性进行操作过程中，多了一个环节，即需要谨慎思考这样的代码修改，从行为角度来分析是否符合业务需要。<br>在设计时实体时，开放set可能会带来严重的副作用，例如影响实体的状态。</p>
<p>在张逸老师的《<a href="https://gitbook.cn/gitchat/column/5cbed2f6f00736695f3a8699/topic/5cd3fe04e30c87051ad3d110" target="_blank" rel="noopener">领域驱动设计实战，战术篇第15课</a>》中，作者指出：</p>
<blockquote>
<p>对象之间若要默契配合，形成良好的协作关系，就需要通过行为进行协作，而不是让参与协作的对象成为数据的提供者。<br>《ThoughtWorks 软件开发沉思录》中的“对象健身操”提出了优秀软件设计的九条规则，其中最后一条提出：不使用任何 Getter/Setter/Property。<br>作者 Jeff Bay 认为：“如果可以从对象之外随便询问实例变量的值，那么行为与数据就不可能被封装到一处。在严格的封装边界背后，真正的动机是迫使程序员在完成编码之后，一定有为这段代码的行为找到一个适合的位置，确保它在对象模型中的唯一性。”</p>
</blockquote>
<p>当然，在实际开发过程中，有时并不一定把get方法也设置为protected，毕竟有时候还需要有所妥协。</p>
<ol start="4">
<li>将创建方法从业务逻辑层，移动到了领域对象Order中的静态工厂方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 创建订单</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;productId&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;address&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;userId&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;price&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;count&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public static Order CreateOrder(int productId, string address, int userId, double price, int count)</span><br><span class="line">&#123;        </span><br><span class="line">    return new Order()</span><br><span class="line">    &#123;</span><br><span class="line">        Address = address,</span><br><span class="line">        UserId = userId,</span><br><span class="line">        TotalPrice = price * count,</span><br><span class="line">        ProductId = productId,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>创建过程应该是一个非常严谨的过程，而原来在业务逻辑层中初始化对象的方法，随意性比较高，很容易就出现开发者在创建过程中将无关属性赋值的现象。<br>但如果把创建过程改成使用构造方法，又可能会造成可读性问题，而使用工厂方法，并创建一个受保护的构造方法则不会造成这个担忧。</p>
<ol start="5">
<li>将订单新增内容和减少内容从业务逻辑层移动到了领域对象上，并封装为方法。采用迪米卡法则，只暴露最小的参数，每次只对最该赋值的属性进行操作，也容易约束开发者的操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 新增</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;count&quot;&gt;&lt;/param&gt;</span><br><span class="line">public void Add(int count)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 减少</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;count&quot;&gt;&lt;/param&gt;</span><br><span class="line">public void Minus(int count)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>大概修改过程是最容易造成领域知识丢失的地方，而通过封装为方法，使得这个过程得以以受控的形式进行，有助于让其他开发者通过暴露的方法。<br>但这样做要确保所使用的命名规范符合统一语言，否则会重蹈贫血模型的覆辙。当然，在领域设计中，经常会纠结于哪些行为应该放在领域对象中，可以参考这样的规则：</p>
<ul>
<li>如果方法只处理实体的成员，它可能属于这个实体。</li>
<li>如果方法访问相同聚合的其他实体或值对象，它可能属于聚合根。</li>
<li>如何方法里的代码需要查询或更新持久层，或者需要用到实体（或聚合）边界以外的引用，它属于领域服务方法。<h1 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h1></li>
</ul>
<h2 id="二者的对比"><a href="#二者的对比" class="headerlink" title="二者的对比"></a>二者的对比</h2><p>笔者整理了一个简单的图表来表现二者的对比关系。显然，三层架构并非毫无优势，领域驱动设计也并非银弹。  </p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">三层架构</th>
<th align="left">领域驱动设计</th>
</tr>
</thead>
<tbody><tr>
<td align="left">业务识别方法</td>
<td align="left">结合瀑布模型，通过需求分析，形成数据字典，指导数据库设计。</td>
<td align="left">团队协作形成统一语言，并从统一语言中提取术语，指导类、流程，变量，行为定义等。</td>
</tr>
<tr>
<td align="left">业务参与者</td>
<td align="left">具备IT知识的开发人员，业务人员只能提供需求，往往不能参与设计过程。</td>
<td align="left">由需求提供者或客户、开发者、测试、产品经理等组成的跨职能团队全力参与。</td>
</tr>
<tr>
<td align="left">建模方法</td>
<td align="left">实体关系建模为主，有时可以用UML</td>
<td align="left">以UML方法为主，画图为辅</td>
</tr>
<tr>
<td align="left">业务代码分层</td>
<td align="left">业务代码理论上应该在业务逻辑层，但有时游离在控制器、业务逻辑层或数据访问层，甚至受依赖的其他业务逻辑中</td>
<td align="left">业务代码在领域层，有时在领域对象上，有时在领域服务中。</td>
</tr>
<tr>
<td align="left">修改代码的难易程度</td>
<td align="left">随时随地想改就改</td>
<td align="left">需要遵循一定的设计原则或步骤、流程</td>
</tr>
<tr>
<td align="left">可维护性</td>
<td align="left">项目简单时，易于维护；复杂时，难于维护。</td>
<td align="left">掌握方法时，维护难度比较平滑。</td>
</tr>
<tr>
<td align="left">数据持久化</td>
<td align="left">在数据访问层中完成，有时可以适当复用；也有开发者将数据访问层提取出仓储的模板方法进行复用。</td>
<td align="left">一般在仓储层中实现，且仓储一般是基础设施，意味着除特定场景外，基础设施不会依赖于领域而二外定制行为。</td>
</tr>
<tr>
<td align="left">多业务逻辑的整合</td>
<td align="left">一般在业务逻辑层中实现</td>
<td align="left">一般在应用服务层实现。</td>
</tr>
<tr>
<td align="left">可测试性</td>
<td align="left">比较难以加入测试代码</td>
<td align="left">易于加入测试代码；也可以根据UML使用TDD来进行开发。</td>
</tr>
</tbody></table>
<h2 id="该如何取舍？"><a href="#该如何取舍？" class="headerlink" title="该如何取舍？"></a>该如何取舍？</h2><p>下图这种流传已久，同样来自马丁弗勒老爷子《企业架构应用模式》。</p>
<p>表现了随着软件复杂度的逐渐提升，数据驱动设计和领域驱动设计模式两种不同类型的设计模式的开发效率（时间）对比曲线。</p>
<p><img src="/images/compare-with_three-layers_12.png" alt="图片"></p>
<ul>
<li>数据驱动设计建立了一个比较平滑的发展轨迹，但是随着拐点的到来，将变得越来越为难以维护，最终造出一个难以维护的“意大利面”。</li>
</ul>
<p><img src="/images/compare-with_three-layers_13.png" alt="图片"></p>
<ul>
<li>领域驱动设计，前期的起点确实比数据驱动设计要高很多，而且甚至在刚刚使用一段时间后，由于业务复杂度的提升，会迎来一个拐点。这个拐点有点像“邓宁·克鲁格效应”中遇到的“绝望之谷”，让开发者和管理层感觉有点力不从心，不少企业最终又拆掉了他们的领域驱动设计搭建的软件；</li>
<li>使用领域驱动设计，随着复杂度的逐渐推移，软件开发人员的信心越来越足，代码自然也能够不断演进，平滑发展，。</li>
</ul>
<p><img src="/images/compare-with_three-layers_14.png" alt="图片"></p>
<ul>
<li>从长期来看，领域驱动建模将给复杂系统带来更加高效的维护效能。<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li>
</ul>
<p>本文介绍了三层架构和领域驱动设计两种不同的设计思想中如何实现业务逻辑代码的过程，并对针对代码的维护性问题进行了分析。由于时间仓促，部分观点、设计图、代码可能还不够成熟，还请大家批评指正。</p>
<p>下一篇将介绍ABP框架开发中的具体实践步骤。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/06/25/技术/如何在ASP.NET Core中使用SignalR构建与Angular通信的实时通信应用程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/06/25/技术/如何在ASP.NET Core中使用SignalR构建与Angular通信的实时通信应用程序/" class="post-title-link" itemprop="url">如何在ASP.NET Core中使用SignalR构建与Angular通信的实时通信应用程序</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-06-25 20:05:00" itemprop="dateCreated datePublished" datetime="2020-06-25T20:05:00+00:00">2020-06-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2021-04-25 11:04:00" itemprop="dateModified" datetime="2021-04-25T11:04:00+00:00">2021-04-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://uploader.shimo.im/f/ByiYlxtK4DIP8lsr.png!thumbnail" alt="图片"></p>
<p>假设我们要创建一个监视Web应用程序，该应用程序为用户提供了一个能够显示一系列信息的仪表板，这些信息会随着时间的推移而更新。</p>
<p>第一种方法是在定义的时间间隔（<em>轮询</em>）定期调用API 以更新仪表板上的数据。</p>
<p>无论如何，还是有一个问题：如果没有更新的数据，我们会因请求而不必要地增加网络流量。一种替代方法是<em>长轮询</em>技术：如果服务器没有可用数据，则它可以使请求保持活动状态，直到发生某种情况或达到预设的超时时间为止，而不是发送空响应。如果存在新数据，则完整的响应将到达客户端。完全不同的方法是反转角色：当有新数据可用（推送）时，后端与客户端联系。</p>
<p>请记住，HTML 5具有标准化的WebSocket，这是一个永久的双向连接，可以在兼容的浏览器中使用Javascript接口进行配置。不幸的是，必须在客户端和服务器端都对WebSocket提供完全支持，以使其可用。然后，我们需要提供替代系统（<em>fallback</em>），无论如何，该替代系统都允许我们的应用程序运行。</p>
<p>微软于2013年发布了一个名为<strong>SignalR</strong> for <strong>ASP.NET</strong>的开源库，该库<strong>已于</strong> 2018年为ASP.NET Core进行了重写。SignalR从与通信机制有关的所有细节中进行抽象，并从可用的信息中选择最佳的一种。结果是有可能编写代码，就像我们一直处于<em>push-mode一样</em>。使用SignalR，服务器可以在其所有连接的客户端或特定客户端上调用JavaScript方法。</p>
<p>我们使用web-api模板创建一个ASP.NET Core项目，删除已生成的示例控制器。使用NuGet，我们将<em>Microsoft.AspNet.SignalR</em>添加到项目中，以创建<strong>Hub</strong>。集线器是能够调用客户端代码，发送包含所请求方法的名称和参数的消息的高级管道。作为参数发送的对象将使用适当的协议反序列化。客户端在页面代码中搜索与名称相对应的方法，如果找到该名称，则将其调用并传递反序列化的数据作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.AspNetCore.SignalR;</span><br><span class="line"> </span><br><span class="line">namespace SignalR.Hubs</span><br><span class="line">&#123;</span><br><span class="line">    public class NotificationHub : Hub &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可能知道，在ASP.NET Core中，可以配置HTTP请求的管理管道，以添加一些<strong>中间件</strong>，该<strong>中间件</strong>可拦截请求，添加已配置的功能并使其进入下一个中间件。必须预先配置SignalR中间件，在<strong>Startup</strong>  类的<em>ConfigureServices</em>方法中添加扩展方法<em>services.AddSignalR（）</em>。现在，我们可以使用Startup类的<em>Configure</em>方法中的扩展方法app.UseSignalR（）将中间件添加到管道中。在此操作期间，我们可以传递配置参数，包括集线器的路由：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.UseSignalR(route =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    route.MapHub&lt;notificationhub&gt;(&quot;/notificationHub&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>一个有趣的场景允许我们查看ASP.NET Core中的另一个有趣功能，即在<strong>后台工作</strong>进程上下文中<em>托管</em> SignalR Hub 。<br>假设我们要实现以下用例：</p>
<ul>
<li>运行业务逻辑</li>
<li>等一下</li>
<li>决定是停止还是重复该过程。</li>
</ul>
<p>在ASP.NET Core中，我们可以使用框架提供的<em>IHostedService</em>接口在.NET Core应用程序中在后台实现进程的执行。方法要实现是<em>StartAsync（）</em>和*StopAsync（） *。非常简单：StartAsync调用到主机启动，而StopAsync调用到主机关闭。</p>
<p>然后，我们将一个类<em>DashboardHostedService</em>添加到项目中，该类实现<em>IHostedService</em>。我们在Startup类的<em>ConfigureServices</em>方法中添加接口注册：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddHostedService&lt;dashboardhostedservice&gt;();</span><br></pre></td></tr></table></figure>

<p>在类构造函数<em>DashboardHostedService中，<em>我们注入</em>IHubContext</em> 访问添加到我们应用程序的集线器。<br>在方法StartAsync中，我们设置了一个计时器，它将每两秒钟运行一次方法DoWork（）中包含的代码。此方法发送带有四个随意生成的字符串的消息。</p>
<p>但是它向谁传播呢？在我们的示例中，我们正在将消息发送到所有连接的客户端。但是，SignalR提供了向单个用户或用户组发送消息的机会。在<a href="https://docs.microsoft.com/en-us/aspnet/core/signalr/groups?view=aspnetcore-2.2" target="_blank" rel="noopener">本文中</a>，您将找到涉及ASP.NET Core中的身份验证和授权功能的详细信息。有趣的是，用户可以同时在台式机和移动设备上连接。每个设备都有一个单独的SignalR连接，但是它们都将与同一用户关联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.AspNetCore.SignalR;</span><br><span class="line">using Microsoft.Extensions.Hosting;</span><br><span class="line">using SignalR.Hubs;</span><br><span class="line">using System;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Threading;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"> </span><br><span class="line">namespace SignalR</span><br><span class="line">&#123;</span><br><span class="line">    public class DashboardHostedService: IHostedService</span><br><span class="line">    &#123;</span><br><span class="line">        private Timer _timer;</span><br><span class="line">        private readonly IHubContext&lt;notificationhub&gt; _hubContext;</span><br><span class="line"> </span><br><span class="line">        public DashboardHostedService(IHubContext&lt;notificationhub&gt; hubContext)</span><br><span class="line">        &#123;</span><br><span class="line">            _hubContext = hubContext;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public Task StartAsync(CancellationToken cancellationToken)</span><br><span class="line">        &#123;</span><br><span class="line">            _timer = new Timer(DoWork, null, TimeSpan.Zero,</span><br><span class="line">            TimeSpan.FromSeconds(2));</span><br><span class="line"> </span><br><span class="line">            return Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        private void DoWork(object state)</span><br><span class="line">        &#123;</span><br><span class="line">            _hubContext.Clients.All.SendAsync(&quot;SendMessage&quot;, </span><br><span class="line">                new &#123;</span><br><span class="line">                    val1 = getRandomString(),</span><br><span class="line">                    val2 = getRandomString(),</span><br><span class="line">                    val3 = getRandomString(),</span><br><span class="line">                    val4 = getRandomString()</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public Task StopAsync(CancellationToken cancellationToken)</span><br><span class="line">        &#123;</span><br><span class="line">            _timer?.Change(Timeout.Infinite, 0);</span><br><span class="line"> </span><br><span class="line">            return Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们看看如何管理客户端部分。例如，我们使用Angular CLI的<em>ng new SignalR</em>命令创建Angular应用程序。然后我们安装SignalR的包节点（<em>npm i @ aspnet / signalr</em>）。然后添加一个服务，该服务使我们可以连接到先前创建的集线器并接收消息。<br>在这里，第一种可能的方法是，基于服务getMessage（）中Observable <message>的服务，通过使用私有声明的Subject <message>来返回（Message是与从Object返回的对象相对应的Typescript接口。后端）：</message></message></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Injectable(&#123;</span><br><span class="line"> providedIn: &apos;root&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class SignalRService &#123;</span><br><span class="line"> private message$: Subject&lt;message&gt;;</span><br><span class="line"> private connection: signalR.HubConnection;</span><br><span class="line"> </span><br><span class="line"> constructor() &#123;</span><br><span class="line">   this.message$ = new Subject&lt;message&gt;();</span><br><span class="line">   this.connection = new signalR.HubConnectionBuilder()</span><br><span class="line">   .withUrl(environment.hubUrl)</span><br><span class="line">   .build();</span><br><span class="line">   this.connect();</span><br><span class="line"> &#125;</span><br><span class="line"> private connect() &#123;</span><br><span class="line">   this.connection.start().catch(err =&gt; console.log(err));</span><br><span class="line">   this.connection.on(&apos;SendMessage&apos;, (message) =&gt; &#123;</span><br><span class="line">     this.message$.next(message);</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> public getMessage(): Observable&lt;message&gt; &#123;</span><br><span class="line">   return this.message$.asObservable();</span><br><span class="line"> &#125;</span><br><span class="line"> public disconnect() &#123;</span><br><span class="line">   this.connection.stop();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在constructor（）内部，我们创建一个SignalR.HubConnection类型对象，该对象将用于连接到服务器。我们通过使用文件environment.ts将其传递到其中心URL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.connection = new signalR.HubConnectionBuilder()</span><br><span class="line">   .withUrl(environment.hubUrl)</span><br><span class="line">   .build();</span><br></pre></td></tr></table></figure>

<p>构造函数还负责调用connect（）方法，该方法进行实际连接，并在控制台中记录可能的错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.connection.start().catch(err =&gt; console.log(err));</span><br><span class="line">this.connection.on(&apos;SendMessage&apos;, (message) =&gt; &#123;</span><br><span class="line">  this.message$.next(message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>想要显示来自后端的消息的组件（将其注入到构造函数中的服务），应该订阅getMessage（）方法并管理到达的消息。以AppComponent为例，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line"> selector: &apos;app-root&apos;,</span><br><span class="line"> templateUrl: &apos;./app.component.html&apos;,</span><br><span class="line"> styleUrls: [&apos;./app.component.css&apos;]</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent implements OnDestroy &#123;</span><br><span class="line"> private signalRSubscription: Subscription;</span><br><span class="line"> </span><br><span class="line"> public content: Message;</span><br><span class="line"> </span><br><span class="line"> constructor(private signalrService: SignalRService) &#123;</span><br><span class="line">   this.signalRSubscription = this.signalrService.getMessage().subscribe(</span><br><span class="line">     (message) =&gt; &#123;</span><br><span class="line">       this.content = message;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> ngOnDestroy(): void &#123;</span><br><span class="line">   this.signalrService.disconnect();</span><br><span class="line">   this.signalRSubscription.unsubscribe();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用主题<message>允许我们同时管理更多组件，而无论从中心返回的消息（用于订阅还是用于取消订阅）都可以，但是我们必须注意对主题的粗心使用。让我们考虑以下getMessage（）版本：</message></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public getMessage(): Observable&lt;message&gt; &#123;</span><br><span class="line">   return this.message$;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，该组件也可以使用以下简单代码发送一条消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const produceMessage = this.signalrService.getMessage() as Subject&lt;any&gt;;</span><br><span class="line"> produceMessage.next( &#123;val1: &apos;a&apos;&#125;);</span><br><span class="line">&lt;/any&gt;</span><br></pre></td></tr></table></figure>

<p>如果方法getMessage（）返回Subject <message> asObservable，则此代码将引发异常！<br>我们可以在单个组件的情况下使用的第二种方法（更简单）对管理来自后端的消息感兴趣：</message></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Injectable(&#123;</span><br><span class="line"> providedIn: &apos;root&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class SignalrService &#123;</span><br><span class="line"> connection: signalR.HubConnection;</span><br><span class="line"> </span><br><span class="line"> constructor() &#123;</span><br><span class="line">   this.connection = new signalR.HubConnectionBuilder()</span><br><span class="line">   .withUrl(environment.hubAddress)</span><br><span class="line">   .build();</span><br><span class="line">   this.connect();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public connect() &#123;</span><br><span class="line">   if (this.connection.state === signalR.HubConnectionState.Disconnected) &#123;</span><br><span class="line">     this.connection.start().catch(err =&gt; console.log(err));</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public getMessage(next) &#123;</span><br><span class="line">     this.connection.on(&apos;SendMessage&apos;, (message) =&gt; &#123;</span><br><span class="line">       next(message);</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public disconnect() &#123;</span><br><span class="line">   this.connection.stop();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以简单地将函数回调传递给方法getMessage，该函数将来自后端的消息作为参数。在这种情况下，AppComponent可以成为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public content: IMessage;</span><br><span class="line">constructor(private signalrService: SignalrService) &#123;</span><br><span class="line">   this.signalrService.getMessage(</span><br><span class="line">     (message: IMessage) =&gt; &#123;</span><br><span class="line">       this.content = message;</span><br><span class="line">     &#125;</span><br><span class="line">   );</span><br><span class="line">&#125;</span><br><span class="line">ngOnDestroy(): void &#123;</span><br><span class="line">   this.signalrService.disconnect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后几行代码分别位于<em>app.component.html</em>和<em>app.component.css中</em>，以赋予一些时尚，并且该应用程序已完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align:center&quot;&gt;</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    DASHBOARD</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;card-container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;card&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">      &lt;h4&gt;&lt;b&gt;Valore 1&lt;/b&gt;&lt;/h4&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123;content.val1&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;card&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">      &lt;h4&gt;&lt;b&gt;Valore 2&lt;/b&gt;&lt;/h4&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123;content.val2&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;card&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">      &lt;h4&gt;&lt;b&gt;Valore 3&lt;/b&gt;&lt;/h4&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123;content.val3&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;card&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">      &lt;h4&gt;&lt;b&gt;Valore 4&lt;/b&gt;&lt;/h4&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123;content.val4&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">.card-container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-wrap: wrap;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.card &#123;</span><br><span class="line">  box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);</span><br><span class="line">  transition: 0.3s;</span><br><span class="line">  width: 40%;</span><br><span class="line">  flex-grow: 1;</span><br><span class="line">  margin: 10px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.card:hover &#123;</span><br><span class="line">  box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.container &#123;</span><br><span class="line">  padding: 2px 16px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先启动后端，然后启动前端并检查最终结果：<br><img src="https://uploader.shimo.im/f/TJ3iFEnLIx8DuW8y.gif" alt="图片"></p>
<p>看起来不错！您可以在这里找到代码：<a href="https://github.com/AARNOLD87/SignalRWithAngular" target="_blank" rel="noopener">https</a> : <a href="https://github.com/AARNOLD87/SignalRWithAngular" target="_blank" rel="noopener">//github.com/AARNOLD87/SignalRWithAngular</a></p>
<p>下次见！</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/06/24/技术/how-to-use-abp-part1-basic-desc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/06/24/技术/how-to-use-abp-part1-basic-desc/" class="post-title-link" itemprop="url">如何使用ABP进行软件开发（1）基础概览</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-06-24 20:05:00" itemprop="dateCreated datePublished" datetime="2020-06-24T20:05:00+00:00">2020-06-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2021-04-25 11:04:00" itemprop="dateModified" datetime="2021-04-25T11:04:00+00:00">2021-04-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ABP框架简述"><a href="#ABP框架简述" class="headerlink" title="ABP框架简述"></a>ABP框架简述</h1><h2 id="1）简介"><a href="#1）简介" class="headerlink" title="1）简介"></a>1）简介</h2><p>在.NET众多的技术框架中，ABP框架（本系列中指aspnetboilerplate项目）以其独特的魅力吸引了一群优秀开发者广泛的使用。</p>
<p>在该框架的赋能之下，开发者可根据需求通过官方网站【<a href="https://aspnetboilerplate.com/Templates" target="_blank" rel="noopener">https://aspnetboilerplate.com/Templates</a>】选择下载例如Vue/AngluarJS/MVC等不同类型的模板项目，轻松加入ABP开发者的队伍中，尽享基于ABP开发带来的乐趣。</p>
<p><img src="/images/abp-1-1.png" alt="图片"></p>
<p>ABP开发框架也提供了丰富的文档，能够为开发者带来许多便捷。目前ABP的文档网站为：</p>
<p>官方文档：<a href="https://aspnetboilerplate.com/Pages/Documents" target="_blank" rel="noopener">https://aspnetboilerplate.com/Pages/Documents</a></p>
<p>文档库不可谓不全，加上国内众多的ABP开发者参与的活跃的技术圈子，使得学习成本只是在第一个项目中比较高，后期将会越来越平滑。</p>
<h2 id="2）现状"><a href="#2）现状" class="headerlink" title="2）现状"></a>2）现状</h2><p>当然，目前ABP的框架开发者和社区已经把更多的精力投入到了ABP.VNEXT开发框架，这个新框架以其DDD+微服务+模块化的理念获得了大量拥趸，使ABP框架的开发优先级已经开始逐渐降低。</p>
<p>但这是因为ABP框架的功能已经成熟稳定，且ABP是一种增量式的架构设计，开发者在熟练掌握这种框架后，可以根据自己的需要进行方便的扩展，使其成为小项目架构选型中一种不错的备选方案。  </p>
<p>当然，也存在一些弊端。例如由于ABP被称为.NET众多开发框架中面向领域驱动设计的最佳实践，而囿于领域驱动设计本身不低的门槛，使得学习的过程变得看起来非常陡峭；</p>
<p>除此之外，ABP也广泛使用了目前Asp.NET/Asp.NET Core框架的大量比较新的特性，对于不少无法由于各种原因无法享受.NET技术飞速发展红利的传统开发者来说，无形中也提高了技术门槛。</p>
<h2 id="3）综述"><a href="#3）综述" class="headerlink" title="3）综述"></a>3）综述</h2><p>在这个系列中，本文计划分成三篇来介绍ABP框架，第一篇介绍ABP的基础概览，介绍基础知识，第二篇介绍ABP的模式实践，第三篇，试图介绍如何从更传统的三层甚至是单层+SQL的单层架构，如何迁移到ABP框架。</p>
<p>（毕竟。。.NET遗留应用实在是太多了，拯救或不拯救？）</p>
<h1 id="代码结构结构"><a href="#代码结构结构" class="headerlink" title="代码结构结构"></a>代码结构结构</h1><h2 id="基本文件夹简述"><a href="#基本文件夹简述" class="headerlink" title="基本文件夹简述"></a>基本文件夹简述</h2><p>当我们通过ABP模板项目的官方网站下载一个项目后，我们所获得的代码包的结构如下图所示，其中：</p>
<p><img src="/images/abp-1-2.png" alt="图片">)<img src="/images/abp-1-3.png" alt="图片"></p>
<ul>
<li>vue为使用iview框架构建的管理系统基本模板，该脚手架使用了yarn作为包管理器，并集成了vuex/axios等常用框架，并提供了用户，租户，权限三个基本功能的示例代码，开发者只需发挥聪明才智就能快速的通过该框架入手前端项目。</li>
<li>（当然，该项目广泛使用了typescript+面向对象的设计，似乎前端开发者。。普遍不擅长面向对象开发？）</li>
<li>aspnet-core则是一个完整的asp.netcore项目的快速开发脚手架。该脚手架集成了docker打包于一体，并包含基本的单元测试示例，使用了identity作为权限控制单元，使用swagger作为接口文档管理工具，集成了efcore、jwt等常用组件，对于开发者来说，基本上算是开箱即用了。<h1 id="前端vue项目"><a href="#前端vue项目" class="headerlink" title="前端vue项目"></a>前端vue项目</h1></li>
</ul>
<p>打开vue文件夹之后，该项目的基本目录如下图所示。（src文件夹）</p>
<p><img src="/images/abp-1-4.png" alt="图片"></p>
<h3 id="lib文件夹"><a href="#lib文件夹" class="headerlink" title="lib文件夹"></a>lib文件夹</h3><p>定义了与abp+vue脚手架项目的基础组件和常见类库，封装了一系列基本方法。例如权限控制，数据请求，菜单操作，SignalR等基础组件的用法。</p>
<h3 id="router文件夹"><a href="#router文件夹" class="headerlink" title="router文件夹"></a>router文件夹</h3><p>定义了vue项目的路由规则，其中index.ts文件是项目的入口，router.ts文件定义了vue文件的路由规则。</p>
<h3 id="store文件夹"><a href="#store文件夹" class="headerlink" title="store文件夹"></a>store文件夹</h3><p>由于本项目使用了vuex框架，所以我们可以来看看对于store文件夹的介绍。</p>
<p>在vuex框架中：</p>
<blockquote>
<p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。<br>Vuex 和单纯的全局对象有以下两点不同：<br>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 </p>
</blockquote>
<p>即vuex框架中，将原来的请求链路，抽象化为状态的变化，通过维护状态，使得数据的管理更加便捷，也易于扩展。</p>
<h3 id="views文件夹"><a href="#views文件夹" class="headerlink" title="views文件夹"></a>views文件夹</h3><p>定义了登录、首页、用户、角色、租户的基本页面，并提供了新增、查看、编辑、删除的代码示例。</p>
<p>综上，该项目是一个结构清晰，逻辑缜密的前端框架，可以作为常见管理系统的脚手架。 </p>
<h1 id="后端项目"><a href="#后端项目" class="headerlink" title="后端项目"></a>后端项目</h1><p><img src="/images/abp-1-5.png" alt="图片"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>后端项目是一个遵循了领域驱动设计的分层，同时又符合Robert Martin在《代码整洁之道》提出的【整洁架构】。</p>
<p><img src="/images/abp-1-6.png" alt="图片"></p>
<h2 id="领域驱动设计简介"><a href="#领域驱动设计简介" class="headerlink" title="领域驱动设计简介"></a>领域驱动设计简介</h2><p>在领域驱动设计的分层设计中，共有四个功能分层，分别是：</p>
<p>表示层（Presentation Layer）：为用户提供接口，使用应用层实现用户交互。</p>
<p>应用层（Application Layer）：介于用户层和领域层之间，协调用户对象，完成对应的任务。</p>
<p>领域层（Domain Layer）：包含业务对象和规则，是应用程序的心脏。</p>
<p>基础设施层（Infrastructure Layer）：提供高层级的通用技术功能，主要使用第三方库完成。</p>
<p>在后文中，基于abp对领域驱动设计的功能分层将进行多次、详细叙述，本小节不再赘述。</p>
<h2 id="整洁架构简介"><a href="#整洁架构简介" class="headerlink" title="整洁架构简介"></a>整洁架构简介</h2><p>整洁架构是由Bob大叔提出的一种架构模型，来源于《整洁架构》这本书，顾名思义，其目的并不是为了介绍这一种优秀的架构本身，而是介绍如何设计一种整洁的架构，使得代码结构易于维护。</p>
<p><img src="/images/abp-1-7.png" alt="图片"></p>
<p>（整洁架构就是这样一个洋葱，所以也有人称它为“洋葱”架构）</p>
<ol>
<li><strong>依赖规则(Dependency Rule)</strong></li>
</ol>
<p>用一组同心圆来表示软件的不同领域。一般来说，越深入代表你的软件层次越高。外圆是战术是实现机制(mechanisms)，内圆的是核心原则(policy)。</p>
<p>Policy means the application logic.</p>
<p>Mechanism means the domain primitives.</p>
<p>使此体系架构能够工作的关键是依赖规则。这条规则规定软件模块只能向内依赖，而里面的部分对外面的模块一无所知，也就是内部不依赖外部，而外部依赖内部。同样，在外面圈中使用的数据格式不应被内圈中使用，特别是如果这些数据格式是由外面一圈的框架生成的。我们不希望任何外圆的东西会影响内圈层</p>
<ol start="2">
<li><strong>实体 (Entities)</strong></li>
</ol>
<p>实体封装的是整个企业范围内的业务核心原则(policy)，一个实体能是一个带有方法的对象，或者是一系列数据结构和函数，只要这个实体能够被不同的应用程序使用即可。</p>
<p>如果你没有编写企业软件，只是编写简单的应用程序，这些实体就是应用的业务对象，它们封装着最普通的高级别业务规则，你不能希望这些实体对象被一个页面的分页导航功能改变，也不能被安全机制改变，操作实现层面的任何改变不能影响实体层，只有业务需求改变了才可以改变实体</p>
<ol start="3">
<li><strong>用例 (Use case)</strong></li>
</ol>
<p>在这个层的软件包含只和应用相关的业务规则，它封装和实现系统的所有用例，这些用例会混合各种来自实体的各种数据流程，并且指导这些实体使用企业规则来完成用例的功能目标。</p>
<p>我们并不期望改变这层会影响实体层. 我们也不期望这层被更外部如数据库 UI或普通框架影响，而这也正是我们分离出这一层来的原因所在。</p>
<p>然而，应用层面的操作改变将会影响到这个用例层，如果需求中用例发生改变，这个层的代码就会随之发生改变。所以可以看到，这一层是和应用本身紧密相关的</p>
<ol start="4">
<li><strong>接口适配器 (Interface Adapters)</strong></li>
</ol>
<p>这一层的软件基本都是一些适配器，主要用于将用例和实体中的数据转换为外部系统如数据库或Web使用的数据，在这个层次，可以包含一些GUI的MVC架构，表现视图 控制器都属于这个层，模型Model是从控制器传递到用例或从用例传递到视图的数据结构。</p>
<p>通常在这个层数据被转换，从用例和实体使用的数据格式转换到持久层框架使用的数据，主要是为了存储到数据库中，这个圈层的代码是一点和数据库没有任何关系，如果数据库是一个SQL数据库， 这个层限制使用SQL语句以及任何和数据库打交道的事情。</p>
<ol start="5">
<li><strong>框架和驱动器</strong></li>
</ol>
<p>最外面一圈通常是由一些框架和工具组成，如数据库Database, Web框架等. 通常你不必在这个层不必写太多代码，而是写些胶水性质的代码与内层进行粘结通讯。</p>
<p>这个层是细节所在，Web技术是细节，数据库是细节，我们将这些实现细节放在外面以免它们对我们的业务规则造成影响伤害</p>
<h2 id="ABP的分层实现"><a href="#ABP的分层实现" class="headerlink" title="ABP的分层实现"></a>ABP的分层实现</h2><p>在ABP项目中，层次划分如下。</p>
<h3 id="1-应用层（Application项目）"><a href="#1-应用层（Application项目）" class="headerlink" title="1. 应用层（Application项目）"></a>1. 应用层（Application项目）</h3><p>在领域驱动设计的分层式架构中，应用层作为应用系统的北向网关，对外提供业务外观的功能。在Abp模板项目中,Application项目也是编写主要用例代码的位置，开发者们在此定义与界面有关的数据行为，实现面向接口的开发实践。</p>
<p><img src="/images/abp-1-8.png" alt="图片"></p>
<p>应用服务层包含应用服务，数据传输单元，工作单元等对象。</p>
<ul>
<li>Application Service</li>
</ul>
<p>为面向用户界面层实现业务逻辑代码。例如需要为某些界面对象组装模型，通常会定义ApplicationService，并通过DTO对象，实现与界面表现层的数据交换。</p>
<ul>
<li>Data Transfer Object (DTO)</li>
</ul>
<p>最常见的数据结构为DTO（数据传输对象），这是来源于马丁弗勒在《企业架构应用模式》中提到的名词，其主要作用为：</p>
<blockquote>
<p>是一种设计模式之间传输数据的软件应用系统。 数据传输目标往往是数据访问对象从数据库中检索数据。</p>
</blockquote>
<p>在ABP的设计中，有两种不同类型的DTO，分别是用于新增、修改、删除的Input DTO，和用于查询的Output DTO。</p>
<ul>
<li>Unit of Work：</li>
</ul>
<p>工作单元。工作单元与事务类似，封装了一系列原子级的数据库操作。  </p>
<h3 id="2-核心层（Core项目）"><a href="#2-核心层（Core项目）" class="headerlink" title="2. 核心层（Core项目）"></a>2. 核心层（Core项目）</h3><p>核心层包含领域实体、值对象、聚合根，以及领域上下文实现。</p>
<ul>
<li>Entity(实体）：</li>
</ul>
<p>实体有别于传统意义上大家所理解的与数据库字段一一匹配的实体模型，在领域驱动设计中,虽然实体同样可能持久化到数据库，但实体包含属性和行为两种不同的抽象。</p>
<p>例如，如果有一个实体为User，其中有一个属性为Phone，数据为086-132xxxxxxxx，我们有时需要判断该手机号码的国际代号，可能会添加一个新的判定 GetNationCode()，可以通过从Phone字段中取出086来实现，这就是一种通俗意义上的行为。</p>
<ul>
<li>Value Object（值对象）:</li>
</ul>
<p>值对象无需持久化到数据库，往往是从其他实体或聚合中“剥离”出来的与某些聚合具备逻辑相关性或语义相关性的对象，有时值对象甚至只有个别属性。</p>
<p>例如，上述实体，包含Phone字段，我们可以将整个Phone“剥离”为一个Telephone对象，该对象可包含PhoneNumber和NationCode字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class User</span><br><span class="line">&#123;</span><br><span class="line">     public Telephone Phone&#123;public get;private set;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Telephone</span><br><span class="line">&#123;</span><br><span class="line">    public string  PhoneNumber &#123;get;set;&#125;</span><br><span class="line">     public string NationCode  &#123;get;set;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Aggregate &amp; Aggregate Root（聚合，聚合根）：</li>
</ul>
<p>聚合是业务的最小工作单元，有时，一个实体就是一个小聚合，而为聚合对外提供访问机制的对象，就是聚合根。</p>
<p>在领域驱动设计中，识别聚合也是一件非常重要的工作，有一组系统的方法论可以为我们提供参考。</p>
<p>当然，事实上识别领域对象，包括且不限定于识别聚合、值对象、实体识别该对象的行为或（方法）本身是一件需要经验完成的工作，有时需要UML建模方法的广泛参与。</p>
<p>有时，我们会习惯于通过属性赋值完成梭代码的过程，从而造成领域行为流失在业务逻辑层的问题，那么或许可以采取这样的方法：</p>
<p>1、对象的创建，使用构造函数赋值，或工厂方法创建。</p>
<p>2、将所有对于属性的访问级别都设置为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public string Phone&#123;public get;private set;&#125;</span><br></pre></td></tr></table></figure>

<p>然后再通过一个绑定手机号码的方法，来给这个对象设置手机号码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public string BindPhone(string phone)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将所有一切涉及到对Phone的操作，都只能通过规定的方法来赋值，这样可以实现我们开发过程中，无意识的通过属性赋值，可能导致的“领域行为”丢失的现象发生。<br>这种方式可以使得对对象某些属性的操作，只能通过唯一的入口完成，符合单一职责原则的合理运用，如果要扩展方法，可以使用开闭原则来解决。</p>
<p>但是，采用这种方式，得尽量避免出现：SetPhone(string phone) 这样的方法出现，毕竟这样的方法，其实和直接的属性赋值，没有任何区别。 </p>
<ul>
<li>Repository（仓储）</li>
</ul>
<p>仓储封装了一系列对象数据库操作的方法，完成对象从数据库到对象的转换过程。在领域驱动设计中，一个仓储往往会负责一个聚合对象从数据库到创建的全过程。</p>
<ul>
<li>Domain Service（领域服务）</li>
</ul>
<p>领域服务就是“实干家”，那些不适合在领域对象中出现，又不属于对象数据库操作的方法，又与领域对象息息相关的方法，都可以放到领域服务中实现。</p>
<ul>
<li>Specification（规格定义）</li>
</ul>
<p>规范模式是一种特殊的软件设计模式，通过使用布尔逻辑将业务规则链接在一起，可以重新组合业务规则。</p>
<p>实际上，它主要用于为实体或其他业务对象定义可重用的过滤器。</p>
<h3 id="3-其他基础设施（EntityFrameworkCore，Web-Core-Web-Host项目"><a href="#3-其他基础设施（EntityFrameworkCore，Web-Core-Web-Host项目" class="headerlink" title="3. 其他基础设施（EntityFrameworkCore，Web.Core,Web.Host项目)"></a>3. 其他基础设施（EntityFrameworkCore，Web.Core,Web.Host项目)</h3><p>EntityFrameworkCore负责定义数据库上下文和对EFCore操作的一系列规则、例如种子数据的初始化等。</p>
<p><img src="/images/abp-1-9.png" alt="图片"></p>
<p>Web.Core：定义了应用程序的外观和接口。虽然从表面上看，Web.Core定义了作为Web访问入口的控制器方法和登录验证的逻辑，看起来像是用户表现层的东西，但是仔细想想，这些东西，何尝不是一种基础设施？</p>
<p>Web.Host：定义WEB应用程序的入口。 </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文简述了ABP框架的前后端项目的分层结构，通过了解这些结构，将有助于我们在后续的实战中更快入手，为应用开发插上翅膀。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/06/09/技术/how-to-manage-user-secret-in-develop-and-production/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/06/09/技术/how-to-manage-user-secret-in-develop-and-production/" class="post-title-link" itemprop="url">在Asp.NET Core中如何优雅的管理用户机密数据</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-06-09 20:05:00" itemprop="dateCreated datePublished" datetime="2020-06-09T20:05:00+00:00">2020-06-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2021-04-25 11:04:00" itemprop="dateModified" datetime="2021-04-25T11:04:00+00:00">2021-04-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在Asp-NET-Core中如何优雅的管理用户机密数据"><a href="#在Asp-NET-Core中如何优雅的管理用户机密数据" class="headerlink" title="在Asp.NET Core中如何优雅的管理用户机密数据"></a>在Asp.NET Core中如何优雅的管理用户机密数据</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p>在软件开发过程中，使用配置文件来管理某些对应用程序运行中需要使用的参数是常见的作法。在早期VB/VB.NET时代，经常使用.ini文件来进行配置管理；而在.NET FX开发中，我们则倾向于使用web.config文件，通过配置appsetting的配置节来处理；而在.NET Core开发中，我们有了新的基于json格式的appsetting.json文件。</p>
<p>无论采用哪种方式，其实配置管理从来都是一件看起来简单，但影响非常深远的基础性工作。尤其是配置的安全性，贯穿应用程序的始终，如果没能做好安全性问题，极有可能会给系统带来不可控的风向。</p>
<h4 id="源代码比配置文件安全么？"><a href="#源代码比配置文件安全么？" class="headerlink" title="源代码比配置文件安全么？"></a>源代码比配置文件安全么？</h4><p>有人以为把配置存放在源代码中，可能比存放在明文的配置文件中似乎更安全，其实是“皇帝的新装”。</p>
<p>在前不久，笔者的一位朋友就跟我说了一段故事：他说一位同事在离职后，直接将曾经写过的一段代码上传到github的公共仓库，而这段代码中包含了某些涉及到原企业的机密数据，还好被github的安全机制提前发现而及时终止了该行为，否则后果不堪设想。</p>
<p>于是，笔者顺手查了一下由于有意或无意泄露企业机密，造成企业损失的案例，发现还真不少。例如<a href="https://www.infoq.cn/article/RZzfel1m6-h8pSK8TTC9" target="_blank" rel="noopener">大疆前员工通过 Github 泄露公司源代码，被罚 20 万、获刑半年</a>  这起案件，也是一个典型的案例。</p>
<p>该员工离职后，将包含关键配置信息的源代码上传到github的公共仓库，被黑客利用，使得大量用户私人数据被黑客获取，该前员工最终被刑拘。 <img src="https://static.geekbang.org/infoq/5cc32361f3500.png?imageView2/0/w/800" alt="大疆前员工通过Github泄露公司源代码，被罚20万、获刑半年"> </p>
<p> 图片来源：<a href="http://www.digitalmunition.com/WhyIWalkedFrom3k.pdf" target="_blank" rel="noopener"> http://www.digitalmunition.com/WhyIWalkedFrom3k.pdf</a> </p>
<p>大部分IT公司都会在入职前进行背景调查，而一旦有案底，可能就已经与许多IT公司无缘；即便是成为创业者，也可能面临无法跟很多正规企业合作的问题。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>所以，安全性问题不容小觑，哪怕时间再忙，也不要急匆匆的就将数据库连接字符串或其他包含敏感信息的内容轻易的记录在源代码或配置文件中。在这个点上，一旦出现问题，往往都是非常严重的问题。</p>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>在.NET FX时代，我们可以使用对web.config文件的关键配置节进行加密的方式，来保护我们的敏感信息，在.NET Core中，自然也有这些东西，接下来我将简述在开发环境和生产环境下不同的配置加密手段，希望能够给读者带来启迪。</p>
<h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><p>在开发环境下，我们可以使用visual studio 工具提供的用户机密管理器，只需0行代码，即可轻松完成关键配置节的处理。</p>
<h5 id="机密管理器概述"><a href="#机密管理器概述" class="headerlink" title="机密管理器概述"></a>机密管理器概述</h5><p>根据<a href="https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/secure-net-microservices-web-applications/developer-app-secrets-storage" target="_blank" rel="noopener">微软官方文档</a> 的描述：</p>
<blockquote>
<p>ASP.NET Core <a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/app-secrets#secret-manager" target="_blank" rel="noopener">机密管理器</a>工具提供了开发过程中在源代码外部保存机密的另一种方法 。 若要使用机密管理器工具，请在项目文件中安装包 Microsoft.Extensions.Configuration.SecretManager 。 如果该依赖项存在并且已还原，则可以使用 <code>dotnet user-secrets</code> 命令来通过命令行设置机密的值。 这些机密将存储在用户配置文件目录中的 JSON 文件中（详细信息随操作系统而异），与源代码无关。</p>
<p>机密管理器工具设置的机密是由使用机密的项目的 <code>UserSecretsId</code> 属性组织的。 因此，必须确保在项目文件中设置 UserSecretsId 属性，如下面的代码片段所示。 默认值是 Visual Studio 分配的 GUID，但实际字符串并不重要，只要它在计算机中是唯一的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">&gt;    <span class="tag">&lt;<span class="name">UserSecretsId</span>&gt;</span>UniqueIdentifyingString<span class="tag">&lt;/<span class="name">UserSecretsId</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Secret Manager工具允许开发人员在开发ASP.NET Core应用程序期间存储和检索敏感数据。敏感数据存储在与应用程序源代码不同的位置。由于Secret Manager将秘密与源代码分开存储，因此敏感数据不会提交到源代码存储库。但机密管理器不会对存储的敏感数据进行加密，因此不应将其视为可信存储。敏感数据作为键值对存储在JSON文件中。最好<strong>不要</strong>在开发和测试环境中使用生产机密。<a href="https://nvisium.com/blog/2019/05/02/Dev-Secrets-and-the-ASP-NET-Core-Secret-Manager.html" target="_blank" rel="noopener">查看引文</a>。</p>
<h5 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h5><p>在windows平台下，机密数据的存放位置为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%APPDATA%\Microsoft\UserSecrets\\secrets.json</span><br></pre></td></tr></table></figure>

<p>而在Linux/MacOs平台下，机密数据的存放位置为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.microsoft/usersecrets/&lt;user_secrets_id&gt;/secrets.json</span><br></pre></td></tr></table></figure>

<p> 在前面的文件路径中， ``将替换<code>UserSecretsId</code>为 <em>.csproj</em>文件中指定的值。 </p>
<h5 id="在Windows环境下使用机密管理器"><a href="#在Windows环境下使用机密管理器" class="headerlink" title="在Windows环境下使用机密管理器"></a>在Windows环境下使用机密管理器</h5><p>在windows下，如果使用Visual Studio2019作为主力开发环境，只需在项目右键单击，选择菜单【管理用户机密】，即可添加用户机密数据。   </p>
<p><img src="/images/how-to-manage-user-secret-in-develop-and-production_1.png" alt></p>
<p>在管理用户机密数据中，添加的配置信息和传统的配置信息没有任何区别。</p>
<blockquote>
<p>{<br>  “ConnectionStrings”: {<br>    “Default”: “Server=xxx;Database=xxx;User ID=xxx;Password=xxx;”<br>  }<br>}</p>
</blockquote>
<p>我们同样也可以使用IConfiguration的方式、IOptions<t>的方式，进行配置的访问。</t></p>
<h5 id="在非Windows-非Visual-Studio环境下使用机密管理器"><a href="#在非Windows-非Visual-Studio环境下使用机密管理器" class="headerlink" title="在非Windows/非Visual Studio环境下使用机密管理器"></a>在非Windows/非Visual Studio环境下使用机密管理器</h5><p>完成安装dotnet-cli后，在控制台输入 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet user-secrets init</span><br></pre></td></tr></table></figure>

<p> 前面的命令将在<code>UserSecretsId</code> .csproj 文件的<code>PropertyGroup</code>中添加 <em>.csproj</em>一个元素。 <code>UserSecretsId</code>是对项目是唯一的Guid值。 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">TargetFramework</span>&gt;</span>netcoreapp3.1<span class="tag">&lt;/<span class="name">TargetFramework</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">UserSecretsId</span>&gt;</span>79a3edd0-2092-40a2-a04d-dcb46d5ca9ed<span class="tag">&lt;/<span class="name">UserSecretsId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置机密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet user-secrets set &quot;Movies:ServiceApiKey&quot; &quot;12345&quot;</span><br></pre></td></tr></table></figure>

<p>列出机密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet user-secrets list</span><br></pre></td></tr></table></figure>

<p>删除机密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet user-secrets remove &quot;Movies:ConnectionString&quot;</span><br></pre></td></tr></table></figure>

<p>清除所有机密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet user-secrets clear</span><br></pre></td></tr></table></figure>

<h4 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h4><p>机密管理器为开发者在开发环境下提供了一种保留机密数据的方法，但在开发环境下是不建议使用的，如果想在生产环境下，对机密数据进行保存该怎么办？</p>
<p>按照微软官方文档的说法，推荐使用<a href="https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/secure-net-microservices-web-applications/azure-key-vault-protects-secrets" target="_blank" rel="noopener">Azure Key Vault </a> 来保护机密数据，但。。我不是贵云的用户（当然，买不起贵云不是贵云太贵，而是我个人的问题[手动狗头]）。</p>
<p>其次，与Azure Key Valut类似的套件，例如其他云，差不多都有，所以都可以为我们所用。</p>
<p>但。。如果您如果跟我一样，不想通过第三方依赖的形式来解决这个问题，那不如就用最简单的办法，例如AES加密。</p>
<h5 id="使用AES加密配置节"><a href="#使用AES加密配置节" class="headerlink" title="使用AES加密配置节"></a>使用AES加密配置节</h5><p>该方法与平时使用AES对字符串进行加密和解密的方法并无区别，此处从略。  </p>
<h5 id="使用数据保护Api（DataProtect-Api实现）"><a href="#使用数据保护Api（DataProtect-Api实现）" class="headerlink" title="使用数据保护Api（DataProtect Api实现）"></a>使用数据保护Api（DataProtect Api实现）</h5><p>在平时开发过程中，能够动手撸AES加密是一种非常好的习惯，而微软官方提供的数据保护API则将这个过程进一步简化，只需调Api即可完成相应的数据加密操作。</p>
<p>关于数据保护api， <a href="https://home.cnblogs.com/u/savorboard/" target="_blank" rel="noopener">Savorboard</a> 大佬曾经写过3篇博客讨论这个技术问题，大家可以参考下面的文章来获取信息。</p>
<p><a href="https://www.cnblogs.com/savorboard/p/dotnetcore-data-protection.html" target="_blank" rel="noopener">ASP.NET Core 数据保护（Data Protection 集群场景）【上】</a></p>
<p><a href="https://www.cnblogs.com/savorboard/p/dotnet-core-data-protection.html" target="_blank" rel="noopener">ASP.NET Core 数据保护（Data Protection 集群场景）【中】</a></p>
<p><a href="https://www.cnblogs.com/savorboard/p/dotnetcore-data-protected-farm.html" target="_blank" rel="noopener">ASP.NET Core 数据保护（Data Protection 集群场景）【下】</a></p>
<p>(接下来我要贴代码了，如果没兴趣，请出门左拐，代码不能完整运行，<a href="https://stackoverflow.com/questions/36062670/encrypted-configuration-in-asp-net-core" target="_blank" rel="noopener">查看代码</a>）</p>
<p>首先，注入配置项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static IServiceCollection AddProtectedConfiguration(this IServiceCollection services, string directory)</span><br><span class="line">       &#123;</span><br><span class="line">           services</span><br><span class="line">               .AddDataProtection()</span><br><span class="line">               .PersistKeysToFileSystem(new DirectoryInfo(directory))</span><br><span class="line">               .UseCustomCryptographicAlgorithms(new ManagedAuthenticatedEncryptorConfiguration</span><br><span class="line">               &#123;</span><br><span class="line">                   EncryptionAlgorithmType = typeof(Aes),</span><br><span class="line">                   EncryptionAlgorithmKeySize = 256,</span><br><span class="line">                   ValidationAlgorithmType = typeof(HMACSHA256)</span><br><span class="line">               &#125;);</span><br><span class="line">           ;</span><br><span class="line"></span><br><span class="line">           return services;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>其次，实现对配置节的加/解密。（使用AES算法的数据保护机制）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ProtectedConfigurationSection : IConfigurationSection</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly IDataProtectionProvider _dataProtectionProvider;</span><br><span class="line">        private readonly IConfigurationSection _section;</span><br><span class="line">        private readonly Lazy&lt;IDataProtector&gt; _protector;</span><br><span class="line"></span><br><span class="line">        public ProtectedConfigurationSection(</span><br><span class="line">            IDataProtectionProvider dataProtectionProvider,</span><br><span class="line">            IConfigurationSection section)</span><br><span class="line">        &#123;</span><br><span class="line">            _dataProtectionProvider = dataProtectionProvider;</span><br><span class="line">            _section = section;</span><br><span class="line"></span><br><span class="line">            _protector = new Lazy&lt;IDataProtector&gt;(() =&gt; dataProtectionProvider.CreateProtector(section.Path));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public IConfigurationSection GetSection(string key)</span><br><span class="line">        &#123;</span><br><span class="line">            return new ProtectedConfigurationSection(_dataProtectionProvider, _section.GetSection(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public IEnumerable&lt;IConfigurationSection&gt; GetChildren()</span><br><span class="line">        &#123;</span><br><span class="line">            return _section.GetChildren()</span><br><span class="line">                .Select(x =&gt; new ProtectedConfigurationSection(_dataProtectionProvider, x));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public IChangeToken GetReloadToken()</span><br><span class="line">        &#123;</span><br><span class="line">            return _section.GetReloadToken();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public string this[string key]</span><br><span class="line">        &#123;</span><br><span class="line">            get =&gt; GetProtectedValue(_section[key]);</span><br><span class="line">            set =&gt; _section[key] = _protector.Value.Protect(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public string Key =&gt; _section.Key;</span><br><span class="line">        public string Path =&gt; _section.Path;</span><br><span class="line"></span><br><span class="line">        public string Value</span><br><span class="line">        &#123;</span><br><span class="line">            get =&gt; GetProtectedValue(_section.Value);</span><br><span class="line">            set =&gt; _section.Value = _protector.Value.Protect(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private string GetProtectedValue(string value)</span><br><span class="line">        &#123;</span><br><span class="line">            if (value == null)</span><br><span class="line">                return null;</span><br><span class="line"></span><br><span class="line">            return _protector.Value.Unprotect(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再次，在使用前，先将待加密的字符串转换成BASE64纯文本，然后再使用数据保护API对数据进行处理，得到处理后的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private readonly IDataProtectionProvider _dataProtectorTokenProvider;</span><br><span class="line">public TokenAuthController( IDataProtectionProvider dataProtectorTokenProvider)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">[Route(&quot;encrypt&quot;), HttpGet, HttpPost]</span><br><span class="line">public string Encrypt(string section, string value)</span><br><span class="line">&#123;</span><br><span class="line">     var protector = _dataProtectorTokenProvider.CreateProtector(section);</span><br><span class="line">     return protector.Protect(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再替换配置文件中的对应内容。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"ConnectionStrings"</span>: &#123;</span><br><span class="line">    <span class="attr">"Default"</span>: <span class="string">"此处是加密后的字符串"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以按照平时获取IOptions<connectstrings>的方式来获取了。</connectstrings></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>公众号【DotNET骚操作】号主【周杰】同学提出以下观点：</p>
<p><strong>1、在生产环境下，使用AES加密，其实依然是一种不够安全的行为，充其量也就能忽悠下产品经理，毕竟几条简单的语句，就能把机密数据dump出来。</strong></p>
<p> 也许在这种情况下，我们应该优先考虑accessKeyId/accessSecret，尽量通过设置多级子账号，通过授权Api的机制来管理机密数据，而不是直接暴露类似于数据库连接字符串这样的关键配置信息。另外，应该定期更换数据库的密码，尽量将类似的问题可能造成的风险降到最低。数据保护api也提供的类似的机制，使得开发者能够轻松的管理机密数据的时效性问题。</p>
<p><strong>2、配置文件放到CI/CD中，发布的时候在CI/CD中进行组装，然后运维只是负责管理CI/CD的账户信息，而最高机密数据，则由其他人负责配置。</strong></p>
<p>嗯，我完全同意他的第二种做法，另外考虑到由于运维同样有可能会有意无意泄露机密数据，所以如果再给运维配备一本《刑法》，并让他日常补习【侵犯商业秘密罪】相关条款，这个流程就更加闭环了。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文简述了在.NET Core中，如何在开发环境下使用用户机密管理器、在生产环境下使用AES+IDataProvider的方式来保护我们的用户敏感数据。由于时间仓促，如有考虑不周之处，还请各位大佬批评指正。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">溪源</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">81</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">categories</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.cnblogs.com/xiyuanmore" title="博客园 &rarr; https://www.cnblogs.com/xiyuanmore" rel="noopener" target="_blank"><i class="fa fa-fw fa-博客园"></i>博客园</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/farway000" title="CSDN &rarr; https://blog.csdn.net/farway000" rel="noopener" target="_blank"><i class="fa fa-fw fa-CSDN"></i>CSDN</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">溪源</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.2</div>
#<div><a href="http://www.beian.miit.gov.cn/">ICP备案号:湘ICP备19001531号-2</a></div>



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
