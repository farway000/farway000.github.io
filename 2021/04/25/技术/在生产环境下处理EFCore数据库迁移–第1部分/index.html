<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="在生产环境下处理EFCore数据库迁移–第1部分安德鲁·洛克（Andrew Lock）撰写了精彩的系列文章《在ASP.NET Core中的应用程序启动时运行异步任务》，其中他以“迁移数据库”为例，介绍了您可以在启动时执行的操作。 在他该系列的第3部分中，他介绍了为什么在启动时迁移数据库并不总是最佳选择。我决定编写一系列有关可以安全迁移数据库的不同方法的系列文章，即使用Entity Framewor">
<meta name="keywords" content="技术">
<meta property="og:type" content="article">
<meta property="og:title" content="在生产环境下处理EFCore数据库迁移–第1部分">
<meta property="og:url" content="http://techq.xyz/2021/04/25/技术/在生产环境下处理EFCore数据库迁移–第1部分/index.html">
<meta property="og:site_name" content="xiyuan技术圈">
<meta property="og:description" content="在生产环境下处理EFCore数据库迁移–第1部分安德鲁·洛克（Andrew Lock）撰写了精彩的系列文章《在ASP.NET Core中的应用程序启动时运行异步任务》，其中他以“迁移数据库”为例，介绍了您可以在启动时执行的操作。 在他该系列的第3部分中，他介绍了为什么在启动时迁移数据库并不总是最佳选择。我决定编写一系列有关可以安全迁移数据库的不同方法的系列文章，即使用Entity Framewor">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://www.thereformedprogrammer.net/wp-content/uploads/2019/01/FiveTypesOfMigrations.png">
<meta property="og:image" content="https://www.thereformedprogrammer.net/wp-content/uploads/2019/01/SQLServerObjectExplorerCompareSchema.png">
<meta property="og:updated_time" content="2021-04-25T11:04:00.924Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="在生产环境下处理EFCore数据库迁移–第1部分">
<meta name="twitter:description" content="在生产环境下处理EFCore数据库迁移–第1部分安德鲁·洛克（Andrew Lock）撰写了精彩的系列文章《在ASP.NET Core中的应用程序启动时运行异步任务》，其中他以“迁移数据库”为例，介绍了您可以在启动时执行的操作。 在他该系列的第3部分中，他介绍了为什么在启动时迁移数据库并不总是最佳选择。我决定编写一系列有关可以安全迁移数据库的不同方法的系列文章，即使用Entity Framewor">
<meta name="twitter:image" content="https://www.thereformedprogrammer.net/wp-content/uploads/2019/01/FiveTypesOfMigrations.png">





  
  
  <link rel="canonical" href="http://techq.xyz/2021/04/25/技术/在生产环境下处理EFCore数据库迁移–第1部分/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>在生产环境下处理EFCore数据库迁移–第1部分 | xiyuan技术圈</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiyuan技术圈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">溪源的技术博客，技术的不断进取之路</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-技术">

    
    
    
      
    

    

    <a href="/categories/技术/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>技术</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-随笔">

    
    
    
      
    

    

    <a href="/categories/随笔/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>随笔</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-读书">

    
    
    
      
    

    

    <a href="/categories/读书/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>读书</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-管理">

    
    
    
      
    

    

    <a href="/categories/管理/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>管理</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-归档">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archives"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2021/04/25/技术/在生产环境下处理EFCore数据库迁移–第1部分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">在生产环境下处理EFCore数据库迁移–第1部分

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2021-04-25 18:56:00 / Modified: 11:04:00" itemprop="dateCreated datePublished" datetime="2021-04-25T18:56:00+00:00">2021-04-25</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="在生产环境下处理EFCore数据库迁移–第1部分"><a href="#在生产环境下处理EFCore数据库迁移–第1部分" class="headerlink" title="在生产环境下处理EFCore数据库迁移–第1部分"></a>在生产环境下处理EFCore数据库迁移–第1部分</h1><p>安德鲁·洛克（Andrew Lock）撰写了精彩的系列文章《在ASP.NET Core中的应用程序启动时运行异步任务》，其中他以“迁移数据库”为例，介绍了您可以在启动时执行的操作。</p>
<p>在他该系列的第3部分中，他介绍了为什么在启动时迁移数据库并不总是最佳选择。我决定编写一系列有关可以安全迁移数据库的不同方法的系列文章，即使用Entity Framework Core（EF Core）更改数据库的架构。</p>
<p>这是本系列的第一部分，介绍如何<strong>创建迁移</strong>，而第二部分则介绍如何将迁移应用于数据库，特别是生产数据库。在撰写本文时，我使用了与安德鲁类似的方法，即，我尝试使用EF Core的优点和缺点，一路介绍创建迁移脚本的所有方式。</p>
<blockquote>
<p>注意：Andrew和我彼此认识，因为我们同时在为Manning Publications撰写书籍：Andrew的书是“ ASP.NET Core in Action，而我写的书是“ Entity Framework Core in Action) ”。我们分享了当作家的辛劳和喜悦，但是安德鲁在ASP.NET Core方面的工作更加艰辛–他的书长700页，而我的书“只有” 500页。</p>
</blockquote>
<h2 id="TL-DR-–创建迁移的摘要"><a href="#TL-DR-–创建迁移的摘要" class="headerlink" title="TL; DR –创建迁移的摘要"></a>TL; DR –创建迁移的摘要</h2><p>注意：单击链接可直接转到涵盖该点的部分。</p>
<ul>
<li><p>可以将两种类型的迁移应用于数据库：</p>
<ul>
<li>添加新的表，列等，称为<em>不间断的更改</em>（简单）。</li>
</ul>
</li>
<li><p>更改列/表并需要复制数据，称为<em>重大更改</em>（困难）。</p>
</li>
<li><p>有五种方法可以在EF Core中创建迁移</p>
<ul>
<li>使用EF Core创建迁移-简单，但不能处理所有可能的迁移。</li>
<li>使用EF Core创建迁移，然后手动修改迁移-中到难，但处理所有可能的迁移。</li>
<li>使用第三方迁移构建器来编写C＃迁移-很难，因为您需要自己编写迁移，但是您不需要了解SQL。</li>
<li>使用SQL数据库比较工具比较数据库并输出SQL更改脚本–很简单，但是您确实需要对SQL有一定的了解。</li>
<li>通过复制EF Core的SQL来编写自己的SQL迁移脚本 –很难理解，可以很好地控制，但您确实需要了解SQL。</li>
</ul>
</li>
<li><p>如何确保您的迁移有效–使用CompareEfSql工具。</p>
</li>
</ul>
<h2 id="设置场景–关于创建迁移，我们应该问什么问题？"><a href="#设置场景–关于创建迁移，我们应该问什么问题？" class="headerlink" title="设置场景–关于创建迁移，我们应该问什么问题？"></a>设置场景–关于创建迁移，我们应该问什么问题？</h2><p>有很多迁移数据库模式的方法，在开发中，几乎可以使用任何方法。但是，当涉及到迁移生产数据库（即实际用户正在使用的数据库）时，它就变得非常严重。弄错了，至少会给您的用户带来不便，并且更糟的是，甚至会丢失您数据库中的（宝贵）数据！</p>
<p>在获得更新数据库模式部分之前，我们需要构建迁移脚本，该脚本将包含模式以及可能的数据更改。要构建适当的迁移脚本，我们需要问自己一些有关需要应用到数据库的更改类型的重要问题。所需的迁移将是：</p>
<ol>
<li>一个非重大更改，也就是说，它只是增加了新的栏目，表格等，这可能而旧的软件仍然运行应用，即旧的软件将与迁移后的数据库一起运行。</li>
<li>一个重大更改，即有些数据必须复制或迁移过程中转化，无法应用，而旧的软件，即旧的软件会遇到与迁移后的数据库错误（中断服务）。</li>
</ol>
<p>本文中也介绍了我们正在使用EF Core，它带来的一些好处和限制。好处是，在大多数情况下，EF Core可以自动创建所需的迁移。</p>
<p>约束条件是应用迁移后的数据库必须与EF Core通过查看您的DbContext和映射的类建立的数据库软件模型匹配–我指的是带有大写M的EF Core模型，因为存在一个名为DbContext中的模型，其中包含类和数据库之间的完整映射。</p>
<blockquote>
<p>注意：我将介绍迁移，在这些迁移中，您可以控制映射到数据库的类的控制和EF Core配置-有时也称为代码优先方法。</p>
<p>我不会介绍另一种替代方法是，您直接控制数据库，并使用称为  scaffolding 的EF Core命令为您创建实体类和EF Core配置。采用这种方法迁移很简单–只需重新搭建数据库即可。</p>
</blockquote>
<h2 id="第1部分。创建迁移脚本的五种方法"><a href="#第1部分。创建迁移脚本的五种方法" class="headerlink" title="第1部分。创建迁移脚本的五种方法"></a>第1部分。创建迁移脚本的五种方法</h2><p>正如我在上一节中所述，我们创建的任何迁移脚本都必须将数据库迁移到与EF Core Model匹配的状态。例如，如果迁移在表中添加了新列，则映射到该表的实体类必须具有与该新列匹配的属性。如果数据库架构的EF Core的模型确实与数据库匹配，则您可能会在查询或写入中发生错误。如果迁移脚本与该数据库的EF Core模型匹配，则将其称为创建“可用”数据库。</p>
<p>毫无疑问，EF Core创建的迁移的有效性– EF Core创建了它，因此它将是有效的。但是，如果我们需要编辑迁移，或者我们自己进行迁移构建，那么我们需要非常小心，就EF Core而言，迁移会创建一个“可用”数据库。这是我考虑过很多的事情。</p>
<p>这是创建迁移脚本的方法的列表。</p>
<ul>
<li>创建C＃迁移脚本<ol>
<li>标准EF Core迁移脚本：使用EF Core的Add-Migration命令创建C＃迁移脚本。</li>
<li>手动修改的EF Core迁移脚本：使用EF Core的Add-Migration命令创建C＃迁移脚本，然后对其进行手动编辑以添加EF Core遗漏的位。</li>
<li>使用第三方迁移构建器，例如FluentMigrator。这样的工具使您可以用C＃编写自己的迁移脚本。</li>
</ol>
</li>
<li>创建SQL迁移脚本。<ol>
<li>使用SQL数据库比较工具。它将最后一个数据库架构与EF Core创建的新数据库架构进行比较，并生成一个SQL脚本，该脚本会将旧数据库迁移到新数据库架构。</li>
<li>编写自己的SQL迁移脚本。称职的SQL编写者可以通过捕获SQL EF Core用来创建数据库的方式来编写SQL迁移脚本。</li>
</ol>
</li>
</ul>
<p>这是一个摘要图，可让您对这五种方法进行总体回顾，并就其易用性和局限性提出个人看法。</p>
<p><a href="https://www.thereformedprogrammer.net/wp-content/uploads/2019/01/FiveTypesOfMigrations.png" target="_blank" rel="noopener"><img src="https://www.thereformedprogrammer.net/wp-content/uploads/2019/01/FiveTypesOfMigrations.png" alt="img"></a></p>
<p>现在，让我们依次看一看。</p>
<h3 id="1a。标准EF-Core-C＃迁移脚本"><a href="#1a。标准EF-Core-C＃迁移脚本" class="headerlink" title="1a。标准EF Core C＃迁移脚本"></a>1a。标准EF Core C＃迁移脚本</h3><p>这是EF Core提供的标准迁移技术。Microsoft官方文档中提供了<a href="https://docs.microsoft.com/en-us/ef/core/managing-schemas/migrations/" target="_blank" rel="noopener">充分的文档记录</a>，总而言之，您运行了一个名为Add-Migration的命令，该命令将三个C＃文件添加到您的应用程序，其中包含使用Add-Migration 迁移现有数据库以匹配当前EF Core设置/配置所需的更改。</p>
<table>
<thead>
<tr>
<th>好处</th>
<th>·自动构建迁移 ·无需学习SQL ·包括还原迁移功能</th>
</tr>
</thead>
<tbody><tr>
<td>坏处</td>
<td></td>
</tr>
<tr>
<td>局限性</td>
<td>标准迁移无法处理重大更改（但请参见1b）。 不处理SQL功能，例如SQL用户定义的函数（但请参见1b）。</td>
</tr>
<tr>
<td>提示</td>
<td>运行“添加迁移”方法时请注意错误消息。如果EF Core检测到可能丢失数据的更改，它将输出一条错误消息，但仍会创建迁移文件。您必须更改迁移脚本，否则将丢失数据–请参阅第1b节。 ·如果您的DbContext在另一个注册了DbContext的程序集中，则需要在构建中使用MigrationsAssembly方法，并且很可能需要在DbContext程序集中实现IDesignTimeDbContextFactory。</td>
</tr>
<tr>
<td>结论</td>
<td>这是处理迁移的一种非常简单的方法，并且在许多情况下效果很好。问题是，如果迁移无法满足您的需求，将会发生什么情况。幸运的是，有很多方法可以解决这个问题。</td>
</tr>
</tbody></table>
<h4 id><a href="#" class="headerlink" title></a></h4><p>参考：<a href="https://docs.microsoft.com/en-us/ef/core/managing-schemas/migrations/#create-a-migration" target="_blank" rel="noopener">Microsoft的有关创建迁移的文档</a>。</p>
<h3 id="1b。手工修改的EF-Core-C＃迁移脚本"><a href="#1b。手工修改的EF-Core-C＃迁移脚本" class="headerlink" title="1b。手工修改的EF Core C＃迁移脚本"></a>1b。手工修改的EF Core C＃迁移脚本</h3><p>关于EF Core的Add-Migration命令的好处是，它以C＃迁移文件为起点，但是您可以自己编辑这些文件以添加代码来处理重大更改或添加/更新数据库的SQL部分。Microsoft提供了通过复制数据处理重大更改的示例。</p>
<table>
<thead>
<tr>
<th>好处</th>
<th>与标准迁移相同+ ·能够自定义迁移。 ·能够包含SQL功能，例如SQL用户定义的功能。</th>
</tr>
</thead>
<tbody><tr>
<td>坏处</td>
<td>·您需要了解数据库中正在隐藏的内容。 ·可能难以决定如何编辑文件，例如，您是否保留了EF Core的所有内容，然后对其进行了更改，还是删除了EF Core部件并自己完成了？</td>
</tr>
<tr>
<td>局限性</td>
<td>没有简单的方法来检查迁移是否正确（但请参阅稍后的CompareEfSql）。</td>
</tr>
<tr>
<td>提示</td>
<td>与标准迁移相同。</td>
</tr>
<tr>
<td>结论</td>
<td>非常适合进行较小的更改，但由于经常将C＃命令与SQL混合使用，因此进行较大的更改可能很困难。这就是为什么我不使用EF Core迁移的原因之一。</td>
</tr>
</tbody></table>
<p>参考：<a href="https://docs.microsoft.com/en-us/ef/core/managing-schemas/migrations/#customize-migration-code" target="_blank" rel="noopener">Microsoft手动修改迁移的示例</a>。</p>
<h3 id="1c。使用第三方C＃迁移构建器"><a href="#1c。使用第三方C＃迁移构建器" class="headerlink" title="1c。使用第三方C＃迁移构建器"></a>1c。使用第三方C＃迁移构建器</h3><p>安德鲁·洛克（Andrew Lock）向我指出了一种使用FluentMigrator编写迁移的方法。这与EF迁移的工作原理类似，但是您必须完成详细说明更改的所有艰苦工作。好消息是FluentMigrator的命令非常明显。</p>
<table>
<thead>
<tr>
<th>好处</th>
<th>不需要学习SQL。 能明显的看到更改了什么，即“代码作为文档”。</th>
</tr>
</thead>
<tbody><tr>
<td>坏处</td>
<td>·您必须确定自己所做的更改。 不保证产生“正确的”迁移（但请参阅稍后的CompareEfSql）。</td>
</tr>
<tr>
<td><strong>局限性</strong></td>
<td>- 没有 -</td>
</tr>
<tr>
<td><strong>提示</strong></td>
<td>请注意，FluentMigrator有一个“ Migration Runners”，可以将更新应用于数据库，但也可以输出SQL脚本。</td>
</tr>
<tr>
<td>结论</td>
<td>我自己没有真正的经验。感觉这是EF Core迁移的一种更清晰的语法，但是您必须自己完成所有工作。</td>
</tr>
</tbody></table>
<p>参考：<a href="https://github.com/fluentmigrator/fluentmigrator" target="_blank" rel="noopener">GitHub的FluentMigrator</a>。</p>
<h3 id="2a。使用SQL数据库比较工具"><a href="#2a。使用SQL数据库比较工具" class="headerlink" title="2a。使用SQL数据库比较工具"></a>2a。使用SQL数据库比较工具</h3><p><a href="https://www.thereformedprogrammer.net/wp-content/uploads/2019/01/SQLServerObjectExplorerCompareSchema.png" target="_blank" rel="noopener"><img src="https://www.thereformedprogrammer.net/wp-content/uploads/2019/01/SQLServerObjectExplorerCompareSchema.png" alt="img"></a></p>
<p>有免费的和商业的工具可以比较两个数据库并创建一个SQL更改脚本，该脚本将旧数据库架构迁移到新数据库架构。</p>
<p>Visual Studio 2017（所有版本）中的“视图”选项卡下内置了一个名为“ <em>SQL Server Object Explorer</em> ”的“免费”比较工具。如果右键单击数据库，则可以访问“比较模式”工具（请参见右图），该工具可以生成SQL更改脚本。</p>
<p>在<em>SQL Server的对象资源管理器</em>工具是非常好的，但是没有这个（可惜）多文档。其他商业系统包括Redgate的SQL Compare。</p>
<table>
<thead>
<tr>
<th>好处</th>
<th>为您构建正确的SQL迁移脚本。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>坏处</strong></td>
<td>·您需要对数据库有一点了解。 ·并非所有的SQL比较工具都生成还原脚本。</td>
</tr>
<tr>
<td><strong>局限性</strong></td>
<td>不处理重大更改-需要人工输入。</td>
</tr>
<tr>
<td><strong>提示</strong></td>
<td>请注意SQL比较工具，该工具可以输出日光下的所有设置，以确保设置正确。EF Core的迁移非常简单，例如“ CREATE TABLE…”，因此应该这样做。如果您有任何特定设置，则将它们构建到数据库create中。</td>
</tr>
<tr>
<td><strong>结论</strong></td>
<td>我在难以手动编码的大型迁移中使用了SQL Server对象资源管理器。对不熟悉SQL语言的人非常有用，尤其有用。</td>
</tr>
</tbody></table>
<h3 id="2b。手工编码SQL迁移脚本"><a href="#2b。手工编码SQL迁移脚本" class="headerlink" title="2b。手工编码SQL迁移脚本"></a>2b。手工编码SQL迁移脚本</h3><p>这听起来确实很困难-编写自己的SQL迁移，但是手头上有很多帮助，无论是来自SQL比较工具（参见上文），还是查看SQL EF Core用于创建数据库的帮助。这意味着我可以查看并复制以构建结论SQL迁移脚本的SQL。</p>
<table>
<thead>
<tr>
<th><strong>好处</strong></th>
<th>完全控制数据库结构，包括EF Core不会添加的部分，例如用户定义的函数，列约束等。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>坏处</strong></td>
<td>·您必须了解基本的SQL，如CREATE TABLE等。 ·您必须确定自己所做的更改（但有帮助） ·不能进行自动还原迁移。 ·不保证产生“正确的”迁移（但请参阅稍后的CompareEfSql）。</td>
</tr>
<tr>
<td><strong>局限性</strong></td>
<td>- 没有 -</td>
</tr>
<tr>
<td><strong>提示</strong></td>
<td>·我使用一个单元测试来捕获EF Core的确保创建方法的日志输出。那让我得到了实际的SQL EF Core输出。然后，我寻找最后一个数据库的差异。这使得编写SQL迁移更加容易。   ·通过应用所有迁移（包括新迁移）创建数据库，然后运行CompareEfSql来检查数据库是否与EF Core的当前数据库模型匹配，从而对迁移进行单元测试。</td>
</tr>
<tr>
<td><strong>结论</strong></td>
<td>这是我使用的，在CompareEfSql工具的帮助下。如果EF Core的迁移功能非常好，为什么还要处理所有这些麻烦呢？这是结论原因： ·完全控制数据库结构，包括EF Core不会添加的部分，例如用户定义的函数，列约束等。 ·由于我正在编写SQL，因此使我考虑了数据库的各个方面。更改–该属性是否可以为空？我需要索引吗？等 ·通过手动修改EF Core的迁移系统来应对重大变化并非易事。我还是坚持使用SQL迁移。 这是针对想要完全控制和可视化迁移的开发人员的。</td>
</tr>
</tbody></table>
<p>您可以捕获EF Core的SQL输出以创建数据库，但是可以在调用方法 EnsureCreated  （ EnsureCreated  方法用于创建单元测试数据库）时捕获EF Core的日志记录。因为为EF Core设置日志记录有些复杂，所以我在EfCore.TestSupport库中添加了辅助方法来处理该问题。这是一个示例单元测试，它创建一个新的SQL数据库并捕获EF Core生成的SQL命令。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">RunnableInDebugOnly</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CaptureSqlEfCoreCreatesDatabaseToConsole</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//SETUP</span></span><br><span class="line">    <span class="keyword">var</span> options = <span class="keyword">this</span>.CreateUniqueClassOptionsWithLogging&lt;BookContext&gt;(</span><br><span class="line">        log =&gt; _output.WriteLine(log.Message));</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> context = <span class="keyword">new</span> BookContext(options))</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//ATTEMPT</span></span><br><span class="line">        context.Database.EnsureDeleted();</span><br><span class="line">        context.Database.EnsureCreated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们看一下这段代码的每一行</p>
<ul>
<li>第5行。这是一个EfCore.TestSupport方法，为您的DbContext创建选项。此版本使用包含类名的数据库名称。我这样做是因为xUnit测试类是并行运行的，所以我想要此单元测试类的唯一数据库。</li>
<li>第6行。我使用以… WithLogging结尾的选项生成器的版本，该版本允许我捕获日志输出。在这种情况下，我将日志的Message部分直接输出到单元测试输出窗口。</li>
<li>第11和12行。首先，我确保删除数据库，以便在我调用确保创建时，将使用由当前DbContext的配置和映射的类定义的架构来创建一个新的数据库。</li>
</ul>
<p>以下是在单元测试输出中捕获的部分输出。这为您提供了EF Core用于创建整个架构的确切SQL。您确实只需要提取与迁移有关的部分，但是至少您可以将所需的部分剪切并粘贴到SQL迁移脚本中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> [EfCore.TestSupport-Test_TestEfLogging];</span><br><span class="line">Executed DbCommand (52ms) [Parameters=[], CommandType='Text', CommandTimeout='60']</span><br><span class="line">IF SERVERPROPERTY('EngineEdition') &lt;&gt; 5</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> [EfCore.TestSupport-Test_TestEfLogging] <span class="keyword">SET</span> READ_COMMITTED_SNAPSHOT <span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">Executed DbCommand (5ms) [Parameters=[], CommandType='Text', CommandTimeout='30']</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">Authors</span>] (</span><br><span class="line">    [AuthorId] <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">    [<span class="keyword">Name</span>] <span class="keyword">nvarchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Authors] PRIMARY <span class="keyword">KEY</span> ([AuthorId])</span><br><span class="line">);</span><br><span class="line">Executed DbCommand (1ms) [Parameters=[], CommandType='Text', CommandTimeout='30']</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Books] (</span><br><span class="line">    [BookId] <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">    [Title] <span class="keyword">nvarchar</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="comment">-- rest of SQL left out</span></span><br></pre></td></tr></table></figure>

<h2 id="如何确保您的迁移有效–使用CompareEfSql工具"><a href="#如何确保您的迁移有效–使用CompareEfSql工具" class="headerlink" title="如何确保您的迁移有效–使用CompareEfSql工具"></a>如何确保您的迁移有效–使用CompareEfSql工具</h2><p>在创建迁移的描述中，我曾多次提到CompareEfSql。该工具将数据库与EF Core首次用于DbContext时创建的数据库模型进行比较。通过DbContext实例中的Model属性访问此模型，是通过查看DbContext配置以及DbSet和DbQuery属性来构建结论EF Core的。</p>
<p>这使开发人员可以根据EF Core Model测试现有数据库，并在错误消息不同的情况下为您提供错误消息。我发现这是一个非常强大的工具，它使我可以手动编码SQL迁移，并确保它们是正确的有一些小限制。这是一个示例单元测试，如果数据库架构与EF Core的模型不匹配，该测试将失败。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CompareViaContext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//SETUP</span></span><br><span class="line">    <span class="keyword">var</span> options = … options that point to the database to check;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> context = <span class="keyword">new</span> BookContext(options))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> comparer = <span class="keyword">new</span> CompareEfSql();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//ATTEMPT</span></span><br><span class="line">        <span class="comment">//This will compare EF Core model of the database </span></span><br><span class="line">        <span class="comment">//with the database that the context's connection points to</span></span><br><span class="line">        <span class="keyword">var</span> hasErrors = comparer.CompareEfWithDb(context);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//VERIFY</span></span><br><span class="line">        <span class="comment">//The CompareEfWithDb method returns true if there were errors.</span></span><br><span class="line">        <span class="comment">//The comparer.GetAllErrors property returns a string</span></span><br><span class="line">        <span class="comment">//where each error is on a separate line</span></span><br><span class="line">        hasErrors.ShouldBeFalse(comparer.GetAllErrors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我喜欢这个工具，它位于EFCore.TestSupport开源库中。它使我能够构建迁移，并确保它们能够正常工作。我也将其作为正常的单元测试来运行，它会立即告诉我是否是我或另一个同事更改了EF Core的设置。</p>
<p>您可以在名为EF Core的文章中获得对该工具的更详细的描述：完全控制数据库模式及其许多功能和配置可以在<a href="https://github.com/JonPSmith/EfCore.TestSupport/wiki/9.-EfSchemaCompare" target="_blank" rel="noopener">CompareEfSql文档页面中找到</a>。</p>
<blockquote>
<p>注意：我最初是为EF6.x构建此版本的（请参阅此旧文章），但是由于EF6.x并未完全公开其内部模型而受到限制。</p>
<p>有了EF Core，我可以做更多的事情，现在我可以检查几乎所有内容，并且因为我利用了EF Core的脚手架服务，所以它适用于EF Core支持的任何数据库。</p>
</blockquote>
<h2 id="结论–第1部分"><a href="#结论–第1部分" class="headerlink" title="结论–第1部分"></a>结论–第1部分</h2><p>本系列的这一部分将介绍如何创建有效的迁移，而第二部分则涉及将迁移应用于数据库。本文列出了使用EF Core时用于创建数据库迁移的所有适用方法-优缺点。如您所见，EF Core的Add-Migration命令确实很好，但是并不能涵盖所有情况。</p>
<p>由您决定要遇到的迁移类型，以及您希望对数据库架构进行何种级别的控制。如果您仅使用EF Core的标准迁移（1a）就可以摆脱困境，那么这将使您的生活更轻松。但是，如果您预期会发生重大变化，或者需要设置额外的SQL功能，那么您现在知道可用的选项。</p>
<p>令人担心的部分出现在part2中-将迁移应用于生产数据库。更改包含关键业务数据需求（需求！）的数据库，请仔细计划和测试。您需要考虑如果（何时！）迁移因错误而失败时该怎么办。</p>
<p>我放弃EF6中的EF迁移的最初原因是它在启动时自动迁移运行良好，直到它在部署时引发错误！确实很难找到迁移中的错误-仅此一项就使我远离使用EF迁移（那时候回想起了这篇<a href="https://www.thereformedprogrammer.net/handling-entity-framework-database-migrations-in-production-part-1-applying-the-updates/" target="_blank" rel="noopener">老文章</a>）。</p>
<p>EF Core的迁移处理要比EF6更好：已可以实现自动迁移（感激！），并且EF Core迁移对git-merge更加友好，仅提及两个更改。但是，我构建SQL迁移脚本的方式使我比正在运行Add-Migration时要更加仔细地思考自己在做什么。EF Core是一个非常出色的O / RM，但有时确实有许多隐藏功能。</p>
<p>创建SQL迁移脚本使我从数据库的角度考虑了迁移问题，而且我经常会对数据库和C＃代码的一些细微调整，以使数据库更好的运行。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/技术/" rel="tag"># 技术</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/04/25/技术/在生产中处理EFCore数据库迁移–第2部分/" rel="next" title="在生产中处理EFCore-模式实战">
                <i class="fa fa-chevron-left"></i> 在生产中处理EFCore-模式实战
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/04/25/技术/如何在.NET Core中为gRPC服务设计消息/" rel="prev" title=". 如何在.NET Core中为gRPC服务设计消息">
                . 如何在.NET Core中为gRPC服务设计消息 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">溪源</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">81</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">categories</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.cnblogs.com/xiyuanmore" title="博客园 &rarr; https://www.cnblogs.com/xiyuanmore" rel="noopener" target="_blank"><i class="fa fa-fw fa-博客园"></i>博客园</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/farway000" title="CSDN &rarr; https://blog.csdn.net/farway000" rel="noopener" target="_blank"><i class="fa fa-fw fa-CSDN"></i>CSDN</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#在生产环境下处理EFCore数据库迁移–第1部分"><span class="nav-number">1.</span> <span class="nav-text">在生产环境下处理EFCore数据库迁移–第1部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TL-DR-–创建迁移的摘要"><span class="nav-number">1.1.</span> <span class="nav-text">TL; DR –创建迁移的摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置场景–关于创建迁移，我们应该问什么问题？"><span class="nav-number">1.2.</span> <span class="nav-text">设置场景–关于创建迁移，我们应该问什么问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第1部分。创建迁移脚本的五种方法"><span class="nav-number">1.3.</span> <span class="nav-text">第1部分。创建迁移脚本的五种方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1a。标准EF-Core-C＃迁移脚本"><span class="nav-number">1.3.1.</span> <span class="nav-text">1a。标准EF Core C＃迁移脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#null"><span class="nav-number">1.3.1.1.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1b。手工修改的EF-Core-C＃迁移脚本"><span class="nav-number">1.3.2.</span> <span class="nav-text">1b。手工修改的EF Core C＃迁移脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1c。使用第三方C＃迁移构建器"><span class="nav-number">1.3.3.</span> <span class="nav-text">1c。使用第三方C＃迁移构建器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2a。使用SQL数据库比较工具"><span class="nav-number">1.3.4.</span> <span class="nav-text">2a。使用SQL数据库比较工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2b。手工编码SQL迁移脚本"><span class="nav-number">1.3.5.</span> <span class="nav-text">2b。手工编码SQL迁移脚本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何确保您的迁移有效–使用CompareEfSql工具"><span class="nav-number">1.4.</span> <span class="nav-text">如何确保您的迁移有效–使用CompareEfSql工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结论–第1部分"><span class="nav-number">1.5.</span> <span class="nav-text">结论–第1部分</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">溪源</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.2</div>
#<div><a href="http://www.beian.miit.gov.cn/">ICP备案号:湘ICP备19001531号-2</a></div>



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>



  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
