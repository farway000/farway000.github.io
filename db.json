{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/how-to-manage-user-secret-in-develop-and-production_1.png","path":"images/how-to-manage-user-secret-in-develop-and-production_1.png","modified":0,"renderable":0},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/affix.js","path":"js/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/exturl.js","path":"js/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/scroll-cookie.js","path":"js/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/js.cookie.js","path":"js/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/post-details.js","path":"js/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/scrollspy.js","path":"js/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1570609592295},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1570609592296},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1570609592296},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1570609592297},{"_id":"themes/next/.all-contributorsrc","hash":"43eb0149c78e464c695f0dd758bb8c59353182b3","modified":1570609592294},{"_id":"themes/next/.gitignore","hash":"8bf1bfc917aa8dd2d886fd36f764447a2b561e1e","modified":1570609592314},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1570609592315},{"_id":"themes/next/bower.json","hash":"8076a6e58a99d1188d335a6456a0de0fda163338","modified":1570609592321},{"_id":"themes/next/.travis.yml","hash":"fb9ac54e875f6ea16d5c83db497f6bd70ae83198","modified":1570609592316},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1570609592318},{"_id":"themes/next/_config.yml","hash":"657abcf355043e764b4ab4af279a404835284138","modified":1570623619285},{"_id":"themes/next/package.json","hash":"037ed50fbce1520918bf8c3a1c14b6e07676783e","modified":1570609592464},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1570609592321},{"_id":"themes/next/README.md","hash":"3f72e5a5051ca2bdaccdda684c46dc4fdb4413a6","modified":1570609592319},{"_id":"themes/next/gulpfile.coffee","hash":"6407d9063bd88ede299ff7c2a59cf2c82e079476","modified":1570609592343},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"1e212fe229bd659726b4a3bcf4b5b14e0310ba3a","modified":1570609592302},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"f7ddb7faed8031a9f40eae4ee7bb48c1bc50fd14","modified":1570609592299},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"f1631b9bef922e7bc2db1e33badfad70fd88d459","modified":1570609592306},{"_id":"themes/next/.github/auto_assign.yml","hash":"9fe0dbe3f6edc59bf10ea25b14eba0e92e2c8f42","modified":1570609592307},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"046262c4b2f54b5ed8ac19b0c99aad04968e01e5","modified":1570609592301},{"_id":"themes/next/.github/eslint-disable-bot.yml","hash":"e06053d417579ed967a94166deb6bda5ce41d805","modified":1570609592308},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1570609592310},{"_id":"themes/next/.github/config.yml","hash":"cbd06d0c40afa9fdf056765120e9085826b00d20","modified":1570609592307},{"_id":"themes/next/.github/lock.yml","hash":"4f1070097b614b24050f238694127e3573ce8472","modified":1570609592309},{"_id":"themes/next/.github/stale.yml","hash":"85975c43d606c39b91c0ad32197154be9d482a09","modified":1570609592311},{"_id":"themes/next/.github/release-drafter.yml","hash":"d01b1e8f462af114e3934fef2ee654634d86b406","modified":1570609592310},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1570609592312},{"_id":"themes/next/.github/topissuebot.yml","hash":"5091c3bc6f3df303d16d853ce65a302601c1e875","modified":1570609592312},{"_id":"themes/next/.github/weekly-digest.yml","hash":"6db3bcad65c3156de298f6a3ffd3ba887af4aa4f","modified":1570609592312},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"1e49c08b446678336b2eacc8bf581faca969f34b","modified":1570609592323},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1570609592323},{"_id":"themes/next/docs/DATA-FILES.md","hash":"9a1895c0a0db705c4c48f512e86917f9af1ec3fb","modified":1570609592325},{"_id":"themes/next/docs/AUTHORS.md","hash":"51a0a13da55ff3d596970b2f9ab4531c6b2211f2","modified":1570609592324},{"_id":"themes/next/docs/INSTALLATION.md","hash":"b74ef6fedf76cdb156e2265759ee0a789ddd49cc","modified":1570609592326},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1570609592328},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"721a1aa9feed1b580ab99af8e69ed22699121e88","modified":1570609592327},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"c9f2ed8e15c137b1885d9ca8b7197d9f457971e9","modified":1570609592329},{"_id":"themes/next/languages/default.yml","hash":"d66b8b48840443a4f9c72c7696a21e292f685a47","modified":1570609592345},{"_id":"themes/next/docs/MATH.md","hash":"7d0330c250082a86897d1c96fbb4ef5df59538af","modified":1570609592329},{"_id":"themes/next/languages/de.yml","hash":"79b3221344da335743b5ef5a82efa9338d64feb0","modified":1570609592344},{"_id":"themes/next/languages/en.yml","hash":"d66b8b48840443a4f9c72c7696a21e292f685a47","modified":1570609592346},{"_id":"themes/next/languages/fa.yml","hash":"3227072c7e1bfb16ec0517394b60632f4be921dd","modified":1570609592348},{"_id":"themes/next/languages/es.yml","hash":"db1a9f2af477212544c830c2dd986400e26ddd6a","modified":1570609592347},{"_id":"themes/next/languages/id.yml","hash":"f3302a4dfdc9be38a52d6e081411574b1ea01671","modified":1570609592350},{"_id":"themes/next/languages/fr.yml","hash":"2429c90dad5bb865e3a969be2b373f19b3a77b3b","modified":1570609592349},{"_id":"themes/next/languages/it.yml","hash":"31eb878b53d60ff47e3e534cdd7a839c8801ac6e","modified":1570609592351},{"_id":"themes/next/languages/ko.yml","hash":"75f2fe142f76bf623e34ed3570598226f55f2b8b","modified":1570609592353},{"_id":"themes/next/languages/ja.yml","hash":"3f25eca504ee5a519987b4402731f1bb7f5191c9","modified":1570609592352},{"_id":"themes/next/languages/nl.yml","hash":"08f16ce395dacc88847fc30dc6b985ce22fb8948","modified":1570609592354},{"_id":"themes/next/languages/pt-BR.yml","hash":"c7de8b77f44e75be4f04423088a1c891537aa601","modified":1570609592354},{"_id":"themes/next/languages/tr.yml","hash":"6d2f53d3687a7a46c67c78ab47908accd8812add","modified":1570609592357},{"_id":"themes/next/languages/ru.yml","hash":"720b92a9ec075b68737d296b1f29ad8e01151c85","modified":1570609592356},{"_id":"themes/next/languages/pt.yml","hash":"ca5072c967e5eb1178ffed91827459eda6e4e6e2","modified":1570609592355},{"_id":"themes/next/languages/uk.yml","hash":"6320439c6e9ff81e5b8f8129ca16e9a744b37032","modified":1570609592358},{"_id":"themes/next/languages/zh-CN.yml","hash":"069f15da910d6f9756be448167c07ea5aa5dc346","modified":1570609592360},{"_id":"themes/next/languages/vi.yml","hash":"e2f0dd7f020a36aa6b73ed4d00dcc4259a7e5e9d","modified":1570609592358},{"_id":"themes/next/languages/zh-HK.yml","hash":"c22113c4a6c748c18093dae56da5a9e8c5b963cd","modified":1570609592361},{"_id":"themes/next/languages/zh-TW.yml","hash":"dbf4dd87716babb2db4f5332fae9ec190a6f636a","modified":1570609592361},{"_id":"themes/next/layout/category.swig","hash":"ad0ac6a1ff341f8eab9570e7fb443962948c5f9d","modified":1570609592455},{"_id":"themes/next/layout/archive.swig","hash":"61bc56e77e653684fc834f63dcbdadf18687c748","modified":1570609592454},{"_id":"themes/next/layout/_layout.swig","hash":"ba786b1baba49021928e2e508da53f2fd1369b3f","modified":1570609592365},{"_id":"themes/next/layout/index.swig","hash":"bdcc9f57adef49706b16b107791cacecbc23c1dc","modified":1570609592456},{"_id":"themes/next/layout/schedule.swig","hash":"e79f43df0e9a6cf48bbf00882de48c5a58080247","modified":1570609592462},{"_id":"themes/next/scripts/merge-configs.js","hash":"5f96f63e86825fd7028c2522e4111103e261a758","modified":1570609592494},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1570609592495},{"_id":"themes/next/layout/post.swig","hash":"af74e97d57cf00cde6f8dbd4364f27910915454e","modified":1570609592459},{"_id":"themes/next/layout/page.swig","hash":"9a272ec78ccef56a6a39304c59cdb5c0350afea0","modified":1570609592457},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1570609592773},{"_id":"themes/next/layout/tag.swig","hash":"283519d4d5b67814412863a3e0212bac18bcc5a0","modified":1570609592462},{"_id":"source/images/how-to-manage-user-secret-in-develop-and-production_1.png","hash":"ca83ba1d5abae15e45fed471e4bcb729e6dca71b","modified":1591620973856},{"_id":"source/_posts/index.md","hash":"1bd446f14a152f761463939d846594e08ded8732","modified":1570619606425},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1570609592722},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1570609592775},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1570609592774},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"59b2b45e151972bbe08582cde22f398e58832765","modified":1570609592304},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"795b8ddb251da8e2327299d5f7dbf446fb9867c6","modified":1570609592303},{"_id":"themes/next/.github/ISSUE_TEMPLATE/custom-issue-template.md","hash":"245917ffaa296bc2d9a85444acf639077ca25944","modified":1570609592303},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"a51de08657f5946f4028b11373280ddc04639525","modified":1570609592331},{"_id":"themes/next/.github/ISSUE_TEMPLATE/non-english.md","hash":"ae22e700b7c63c60746321719a20d34022ad78d9","modified":1570609592305},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"1a4e41adcf5831057f3f7b3025ed4a5ef7c442b4","modified":1570609592334},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"7b2963daac19b0c14f98ebef375d5fbce8fc3f44","modified":1570609592332},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"018a259694f4a8c7c384e1f323531442cba5fbf3","modified":1570609592336},{"_id":"themes/next/docs/ru/README.md","hash":"aeb95129ab1da9ec41786bfa86dc32c739ee6358","modified":1570609592333},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"aaf25d304793344e2d026062768c93005723f5c6","modified":1570609592335},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"baca12cc24be082f1db28c7f283493569666321c","modified":1570609592338},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"16d98708de86efe40ebcb02c02a01af0f160b80a","modified":1570609592337},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"67f4a987e7db0ab1ce1ea4c311f2961df07b6681","modified":1570609592338},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"db2797f161e1e7a4987cbfa3d1be682266dfbba6","modified":1570609592340},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"2095d1214a4e519a1d31b67b41c89080fa3285d3","modified":1570609592342},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1570609592363},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1570609592364},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"b17fc344ff61603f83387c0f9b2b2189aae81d50","modified":1570609592340},{"_id":"themes/next/docs/zh-CN/README.md","hash":"4016948fdb971e4f905efb7a5bb3add3dd58e7a8","modified":1570609592341},{"_id":"themes/next/layout/_custom/head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1570609592363},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"891ab67815969dd8736cb22fbbb3f791b8fff4e4","modified":1570609592368},{"_id":"themes/next/layout/_partials/comments.swig","hash":"d0b9e841d55c974d02f43823a06a2627f8e46431","modified":1570609592371},{"_id":"themes/next/layout/_partials/footer.swig","hash":"d64167d8846c8e5055324bfb21a3bbd325177b99","modified":1570609592372},{"_id":"themes/next/layout/_macro/post.swig","hash":"5074f43ee5f8e03f4e29a4c16a74c992db1dab0a","modified":1570609592369},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"91017f58f83d9505ce99109fffdc51c032bf017e","modified":1570609592370},{"_id":"themes/next/layout/_partials/github-banner.swig","hash":"1ad13269b43b900356f3bdab7947d6a86f035a2c","modified":1570609592373},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"914155d5d758306cff405beefd4a07973fd8fc77","modified":1570609592382},{"_id":"themes/next/layout/_partials/post-edit.swig","hash":"dee345054d564dd56f74bb143942d3edd1cb8150","modified":1570609592384},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"cccd93d30787675010b1a74ef02eb5b813ec1d96","modified":1570609592395},{"_id":"themes/next/layout/_scripts/exturl.swig","hash":"c2e8f4b3a2bf991320ecc827dcdc227399ad5b51","modified":1570609592396},{"_id":"themes/next/layout/_scripts/next-boot.swig","hash":"50c3ae6b50f173ae70f8c3312f7c6da1097eb9b6","modified":1570609592397},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"efb3404a3303622f3be60944d9d1926972c5c248","modified":1570609592398},{"_id":"themes/next/layout/_scripts/scroll-cookie.swig","hash":"8a992b7fe42b9c1a5eb9d937b0827aed91586d94","modified":1570609592403},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"4b93dc7ac0573c402aabcb5c933bbcb893b07c51","modified":1570609592417},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"b9b57e1735035319e200c22cf46a38b52b4e0d9c","modified":1570609592403},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"87bcb495f7ddd81cc3fe2c2a886e51c08053019b","modified":1570609592416},{"_id":"themes/next/layout/_third-party/chatra.swig","hash":"9582e2eb82b1764d2fa295b3e2ef392abf03ef7c","modified":1570609592418},{"_id":"themes/next/layout/_third-party/mermaid.swig","hash":"80dfc0879866e6512cb67590a3b2d8741a66f980","modified":1570609592436},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"7db4ad4a8dd5420dad2f6890f5299945df0af970","modified":1570609592437},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"76f5933925670044ec65b454295ba7e0a8439986","modified":1570609592438},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"12bf51c55449d0e838f93a4aae9f6d25c0a27ba2","modified":1570609592429},{"_id":"themes/next/layout/_third-party/pdf.swig","hash":"4ae61c7efb16e962385bfe522a38c4d29cdcccbe","modified":1570609592441},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"8b1322a091355853db62a5aafb8886fdbd8ab56a","modified":1570609592443},{"_id":"themes/next/scripts/filters/exturl.js","hash":"b19c7c1021e57367b3b3bbf5678381017ed5667d","modified":1570609592487},{"_id":"themes/next/scripts/helpers/engine.js","hash":"cdb6152582313268d970ffeef99b4a8a7850f034","modified":1570609592489},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"a40ce6bc852bb4bff8b9f984fa064741dd151e96","modified":1570609592492},{"_id":"themes/next/scripts/tags/button.js","hash":"95a520f6529424a03c7ead6dbfd5e626d672febb","modified":1570609592496},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"4519ab8e6898f2ee90d05cde060375462b937a7d","modified":1570609592497},{"_id":"themes/next/scripts/tags/exturl.js","hash":"f9f25905adecfb8be49def4ff3b0b8bbc6955d84","modified":1570609592498},{"_id":"themes/next/scripts/tags/full-image.js","hash":"a6b2264215c555c553b2c5db85fa90678798d0d5","modified":1570609592503},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"23d839333422375e85d44e476f554faf49973a3c","modified":1570609592504},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"ab4a82a7246265717556c7a42f897430340b88cf","modified":1570609592505},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1570609592509},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1570609592507},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1570609592511},{"_id":"themes/next/scripts/tags/tabs.js","hash":"72a5adbd8f300bee1d0c289367598ca06b2bed17","modified":1570609592512},{"_id":"themes/next/scripts/tags/pdf.js","hash":"ab995f0fc60d60f637220e2651111b775b8a06de","modified":1570609592511},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1570609592513},{"_id":"themes/next/layout/_third-party/tidio.swig","hash":"b44010cd577e4d063c3406772938c4b117ec7b7b","modified":1570609592453},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"c476dc3693a9dd0be2d136a45b0d7fdef55d4d92","modified":1570609592445},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1570609592725},{"_id":"themes/next/source/css/main.styl","hash":"5e7d28bc539e84f8b03e68df82292f7fc0f2d023","modified":1570609592721},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1570609592724},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1570609592723},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1570609592727},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"882cd0b68c493af1b6d945660f9c21085e006ffc","modified":1570609592446},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1570609592726},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1570609592729},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1570609592730},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1570609592733},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1570609592731},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1570609592735},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1570609592734},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1570609592732},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1570609592736},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1570609592733},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1570609592737},{"_id":"themes/next/source/images/searchicon.png","hash":"025d64ba0160a3a2257dd2b3032b5f7c9dd9b82b","modified":1570609592739},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1570609592738},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1570609592736},{"_id":"themes/next/source/js/algolia-search.js","hash":"84906eeae57bd06744dd20160b93eacf658f97e2","modified":1570609592741},{"_id":"themes/next/source/js/affix.js","hash":"ad343aa406fd8181b5f310434817ce98fc2219e3","modified":1570609592740},{"_id":"themes/next/source/js/exturl.js","hash":"c48aa4b3c0e578a807fd3661e6cd4f3890777437","modified":1570609592742},{"_id":"themes/next/source/js/motion.js","hash":"d0a6d9dbcc57159e54bbb1f683b86632ae0b78f0","modified":1570609592743},{"_id":"themes/next/source/js/next-boot.js","hash":"696a0c2cf158001576d56b48195ec8e39e835b47","modified":1570609592744},{"_id":"themes/next/source/js/scroll-cookie.js","hash":"c4867626afab749404daf321367f9b6b8e223f69","modified":1570609592747},{"_id":"themes/next/source/js/js.cookie.js","hash":"f11e84def0352b7dd6393f1b83e55a40ab468686","modified":1570609592743},{"_id":"themes/next/source/js/post-details.js","hash":"7d309b771e86c7e22ce11cc25625481ef7d5985c","modified":1570609592745},{"_id":"source/_posts/读书/《实例化需求》读书笔记.md","hash":"5d337d55d1c380107f25f2b1040b3f5a655fabe9","modified":1570619281741},{"_id":"source/_posts/读书/《猎豹行动·硝烟中的敏捷转型之旅》有感.md","hash":"e3796e37a72cadf5c5c4ee659cf78195bfad1241","modified":1570618038369},{"_id":"themes/next/source/js/scrollspy.js","hash":"68d3690152c89e7adb08bb35ec28dbda2bd93686","modified":1570609592748},{"_id":"source/_posts/读书/从《必然》中看到的必要.md","hash":"5dfe24a4dbfe14a81e4aeb0f28de7ee65ec088f5","modified":1578580693258},{"_id":"source/_posts/读书/《程序员的三门课》读书笔记.md","hash":"5302f36a15ae7a5dc171b7548718473b6b2dbdd5","modified":1576629220529},{"_id":"themes/next/source/js/utils.js","hash":"fed16cd4fa5fac8cb4a63633d1840792a056f2be","modified":1570609592749},{"_id":"source/_posts/技术/.NET内存管理五大基础知识.md","hash":"0e2399542203483f7dbdb4f40e619083f46ff91d","modified":1590491251320},{"_id":"source/_posts/技术/@程序员，你还在群里吹水，别人的开源项目都做完了.md","hash":"2bd042ec0484fae7d933e1a35e464e548b9236a1","modified":1579394636986},{"_id":"source/_posts/技术/C＃性能提示和技巧.md","hash":"21c9a499e5d92248cb7fe3e4f7d514e23f5927b4","modified":1590667533862},{"_id":"source/_posts/技术/how-to-manage-user-secret-in-develop-and-production.md","hash":"7d3fb7e278af779b8647708ccfba7ac3784abb61","modified":1593093298407},{"_id":"source/_posts/技术/how-to-use-abp-part1-basic-desc.md","hash":"063923a521e1ab591be6332f63c1949eb9e67652","modified":1593010089972},{"_id":"source/_posts/技术/TDD学习笔记（二）单元测试.md","hash":"971f3da966277f2a79c74a583a31b03a6ffe70f9","modified":1590491289320},{"_id":"source/_posts/技术/NET Core使用gRPC打造服务间通信基础设施.md","hash":"1338ea929601b2aea2e4173df9f241ab844807c8","modified":1571315696228},{"_id":"source/_posts/技术/the-typical-ten-problems-in-c-sharp.md","hash":"2d583cbef1d06ee29f9ffc81eadb949b4a0909bb","modified":1585184150603},{"_id":"source/_posts/技术/how-to-learn-wpf.md","hash":"23156adbee2b8d6bade9fc7e6626ce0ac4fad1da","modified":1582446495612},{"_id":"source/_posts/技术/memory-manage-in-c#.md","hash":"6341421cc911d3f1b8b6b20cd6abef867c065e98","modified":1587567668246},{"_id":"source/_posts/技术/how-to-use-httpclient-in-netcore.md","hash":"06c555223f5ca94db988335eecf454db64c47565","modified":1583974078549},{"_id":"source/_posts/技术/understanding-garbage-collection-in-.net.md","hash":"3aef2b9dea9b846ef7a812ac85700da1568cd4f3","modified":1587567635366},{"_id":"source/_posts/技术/try-to-find-high-cpu-usage-in-netcore.md","hash":"aecab45e2dfc4a8b937b9f0b9ed954905d8c322a","modified":1586439506101},{"_id":"source/_posts/技术/ten-problems-view.md","hash":"2b4b2d4acb1d1c404f4a207ab2e623ce6282b6c1","modified":1585184162474},{"_id":"source/_posts/技术/从零开始学习TDD，测试驱动开发.md","hash":"4df12efa5b8c47da141652df7694db24af01b614","modified":1570617961823},{"_id":"source/_posts/技术/你或许以为你不需要领域驱动设计.md","hash":"9c667523b057e119c2bac469ddefeadbc4afc84c","modified":1572943958486},{"_id":"source/_posts/技术/什么是TDD（一）.md","hash":"3f0ebc20a1ef44ff736ffa0351e640c0a9428243","modified":1590491332550},{"_id":"source/_posts/技术/关注细节，成就卓越代码.md","hash":"71ef5222c7a3fa291d4a04ede7ada7dbd852ab43","modified":1570618490517},{"_id":"source/_posts/技术/使用自定义DelegatingHandler编写更清洁的Typed HttpClient.md","hash":"4a285b8f31f017237cd2e138f7a32d20bb9b311c","modified":1590493987543},{"_id":"source/_posts/技术/分析EFCore中的内存泄漏.md","hash":"6980a371f9d1430732deb24a23ae073b4673dbe8","modified":1587567465196},{"_id":"source/_posts/技术/如何在ASP.NET Core中使用SignalR构建与Angular通信的实时通信应用程序.md","hash":"0bf0c020d25d539605ea5cefefca4502cef3c80d","modified":1592837627676},{"_id":"source/_posts/技术/在C＃中使用RESTful API的几种好方法.md","hash":"b45f78c1a6c64e7424194e40a74a89d9f00f7c3f","modified":1590491412184},{"_id":"source/_posts/技术/持续交付全流程思考与实践.md","hash":"7b9ee87390bd0fb5ac76313f1e2c02fe98c5645c","modified":1578579844412},{"_id":"source/_posts/技术/您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术.md","hash":"4f25d417eb19db258ff11956a9de2e8df8efe562","modified":1587567416615},{"_id":"source/_posts/技术/提升WebAPI性能的几个小建议.md","hash":"5bed5d0a17bd1377562fc6d4227c3aeb2abd8d32","modified":1590491406378},{"_id":"source/_posts/技术/最佳REST API最佳做法.md","hash":"d7fb687c85c9192a39a2f7f08fe5d40d5f3e53ae","modified":1590491397808},{"_id":"source/_posts/技术/甲方爸爸，大概你要的是代码生成器吧？.md","hash":"e7169cd5f516ffcb21f323836da5665968142c66","modified":1588938424472},{"_id":"source/_posts/技术/浅议Grpc的双向流和WCF中的回调机制.md","hash":"851419cfadd7aafb2964987e86e3aac8729b0cec","modified":1575903976605},{"_id":"source/_posts/技术/简述介绍.NET Core中的依赖注入方法.md","hash":"49afece34101fab532e5a8c7904158b4c5ee560e","modified":1575903992040},{"_id":"source/_posts/技术/那些与EF有关的错误认知.md","hash":"e1b88d92b170e1193ca42a7e1edb6dc594917753","modified":1590491355512},{"_id":"source/_posts/管理/JobChance.md","hash":"55cd8cc32e6caeefca55b9b10b0c0df2f4009b4c","modified":1572253121225},{"_id":"source/_posts/管理/怎样的项目才能称为“成功项目”？.md","hash":"5505b93593e31e9f2b12169a47418a3106fce37a","modified":1570618640357},{"_id":"source/_posts/管理/项目失控全记录.md","hash":"58c082894a733d2292bc839c963ee3861d992832","modified":1570618159152},{"_id":"source/_posts/管理/我是如何完成一个短期项目的？.md","hash":"016bb6a5b4aa4f4f6964f76bc79201e3401d3da8","modified":1590492939272},{"_id":"source/_posts/随笔/2019.NET Conf，.NET技术之崛起，已势不可挡.md","hash":"70000186b59e2c74cd3629ed88f51356f448c6dd","modified":1573517396416},{"_id":"source/_posts/随笔/2019.Net Conf，我们的共同期待.md","hash":"03f20302be52fe662351b8a2cb0d5e0c2730d6ee","modified":1572826130999},{"_id":"source/_posts/随笔/PMP学习之旅回顾.md","hash":"4f0149556c38c007e80b9a8d4257db54b88e24e6","modified":1580997806714},{"_id":"source/_posts/随笔/2019年年终总结，静候时光与一步一个脚印.md","hash":"2dede3af7db15aea2c4096efb06bffc14e795021","modified":1578012847574},{"_id":"source/_posts/随笔/how-to-find-millon-in-changsha-programmer.md","hash":"8fcf5dfca246748a4bd0267bc9998f315b48ae22","modified":1586480952893},{"_id":"source/_posts/随笔/一位996、CRUD开发者的一天.md","hash":"a6f89ea92f689c9706852d0fc1cc493b8881dc0f","modified":1570618349007},{"_id":"source/_posts/随笔/共同创业五年，技术总监却突然就这么离职了.md","hash":"d30ffb9e90c0c632f28418e6a77b2a8f2776ec8f","modified":1590491500641},{"_id":"source/_posts/随笔/如何快速融入团队并成为团队核心（七）.md","hash":"62bf269f95b858c52b646f904bd85e13e824c704","modified":1581942735590},{"_id":"source/_posts/随笔/坚持一个好习惯该有多难_.md","hash":"24d5b670a0e3f98500cc27ab0441ba2c4ad0b830","modified":1570618225680},{"_id":"source/_posts/随笔/如何快速融入团队并成为团队核心（一）.md","hash":"31bb4c6f46a8a33d9780b855b409fe3329491eb7","modified":1579394796159},{"_id":"source/_posts/随笔/如何快速融入团队并成为团队核心（九）.md","hash":"0cdbdfd6476c9485c66c33ca804d57f225c62df0","modified":1583973833661},{"_id":"source/_posts/随笔/如何快速融入团队并成为团队核心（三）.md","hash":"34179e4fadefba31b6191b411c5e3f92c78f47e2","modified":1579394859083},{"_id":"source/_posts/随笔/如何快速融入团队并成为团队核心（五）.md","hash":"1ce90eb30fe8ae6445955fcacf147eea0e0de72a","modified":1579394891411},{"_id":"source/_posts/随笔/如何快速融入团队并成为团队核心（二）.md","hash":"d3801aaa2e511ef3268bc85ff2e1a7ccc0cde61a","modified":1579394554723},{"_id":"source/_posts/随笔/如何快速融入团队并成为团队核心（八）.md","hash":"06877a1f8f7f8eb53bc3d5ff3ba2edd6615f3145","modified":1583933451546},{"_id":"source/_posts/随笔/如何快速融入团队并成为团队核心（四）.md","hash":"be71edef3deacd33ea160206f8ad1208924c6cf8","modified":1579394872996},{"_id":"source/_posts/随笔/如何看待程序媛的未来职业规划.md","hash":"61f927f26139490326fad9c34f55ce6b1a075974","modified":1581841402792},{"_id":"source/_posts/随笔/容器-推荐序.md","hash":"a3c03da9d4b4cbe5e249ad75d233fe54df7ea30a","modified":1576071736974},{"_id":"source/_posts/随笔/如何快速融入团队并成为团队核心（六）.md","hash":"d19983f20d3aec92688eacde49f544ca5b01a2af","modified":1579395438349},{"_id":"source/_posts/随笔/开发者的不断进取，源自对技术的点滴追求.md","hash":"ff537d0824dc6b3d6da6ace11502c70159f0791f","modified":1572944091102},{"_id":"source/_posts/随笔/独立开发者，程序员的美好梦想？.md","hash":"f3f457d1406a67be3a5235cc6e0cd57e430fb1a2","modified":1570618019857},{"_id":"source/_posts/随笔/我在外包公司做增删改查有前途么？.md","hash":"bb26489585c82a4d939f7b554a1645a19af2f9cd","modified":1576416647053},{"_id":"source/_posts/随笔/是小厂全栈好，还是大厂专业工程师好？.md","hash":"752f08ac01fee84856a61ac769ed17ba155de05a","modified":1590491484520},{"_id":"source/_posts/随笔/网易事件背后众生相.md","hash":"4331546d816180d9ece41fc297bf55b62ef299d2","modified":1575197780399},{"_id":"source/_posts/随笔/让人迷茫的三十岁.md","hash":"e9924adb7abacc816a1a85dec4690863116dbeac","modified":1581841272818},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1570609592687},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1570609592688},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1570609592691},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1570609592719},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1570609592720},{"_id":"source/_posts/随笔/那个程序员，为什么选择改行_.md","hash":"60adbfe13acaa04182d0acc70c16eb328d292f7e","modified":1590492909568},{"_id":"source/_posts/随笔/那位五十多岁的创业者给我的启示.md","hash":"8c2b0320d795b584de10d344b82e11e69e4a2aea","modified":1587133606903},{"_id":"source/_posts/技术/how-to-use-restfulapi-in-netcore.md","hash":"9a02793a1fe23aefcc9f4702fc5a8d04e99f9d51","modified":1582467863428},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"4eb8e222dc337211efb0d3bbdb5e29af3e6ecdb8","modified":1570609592367},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"b57bf9c865bed0f22157176a8085de168a1aef77","modified":1570609592374},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"25aea3d764b952f3f6d28ab86d7212d138e892df","modified":1570609592368},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"c909f6e96373c151dea325bcddfdd8c9522421b6","modified":1570609592377},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"fd079a414ca0f42f4cddd00247a9d5a5f58c4d8e","modified":1570609592375},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"03f669356bbaa70144b743f3312178e1981ac3a8","modified":1570609592376},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"39c4ad0e36b7c1260da98ba345f7bd72a2ac0f2e","modified":1570609592378},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"b621269b177eec024be9717ce5e0b3abe57d1459","modified":1570609592375},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"2b905ddd5dea8558c3fd95aacad241da6b6800f4","modified":1570609592380},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"e015c7d9b84062b60b15b36be3ef11929dd10943","modified":1570609592379},{"_id":"themes/next/layout/_partials/post/reward.swig","hash":"f62b801c7999da67b4bdca9c5e373b9b5ed039dc","modified":1570609592387},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"f46699a9daa5fef599733cbab35cb75cf7a05444","modified":1570609592382},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"be6683db6a269d83bb0441d7cf74db63a240fa8a","modified":1570609592385},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f331ad02beea8990066d32ad6ec9f859672c3615","modified":1570609592386},{"_id":"themes/next/layout/_partials/post/wechat-subscriber.swig","hash":"fb7727e8ec63a58238a7206bf70eb273c8879993","modified":1570609592387},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"f14e9e8c27af82f1bfe794e252dec0d7e521f503","modified":1570609592389},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1570609592388},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1570609592391},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c609097b95eb6127c2784f47f2230e6e6efc0be2","modified":1570609592393},{"_id":"themes/next/layout/_partials/share/likely.swig","hash":"647e8677d1ccfb3f7918dd3ea2ff7078504a845d","modified":1570609592394},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"31245e09ce0465b994cebd94223a531585c4eab4","modified":1570609592392},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a62c93f19429f159bcf0c2e533ffc619aa399755","modified":1570609592400},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"cf87ab778618a32119ec1c4ac2079a51385b1913","modified":1570609592399},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"3c548934b97cc426544947f7a2ae35c270b5e33f","modified":1570609592400},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"828eb9c47f34090c841a2e9a0b3f31b0e4ccf40a","modified":1570609592402},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7ef07edd2a97a3774229990d2f0a6eefa31bd015","modified":1570609592401},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"66d562b3778dbc839f7c00103bd0099c5d61602a","modified":1570609592405},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"54b43d406cf37932e7b60f46814e864d31b1842c","modified":1570609592393},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"2e1de38f44af00209129d4051b7ae307cb11ad68","modified":1570609592407},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"335005a9f8b36349f0ad0a7beeba6969c55fc7f7","modified":1570609592408},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"83dd7df11b100bae38c9faab9a478f92149a0315","modified":1570609592405},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"73576c9683d9ad9b124916dc6c660607fe7cc1fa","modified":1570609592406},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"f648e5bf8c5dfc74143233976ed4ff5978deda43","modified":1570609592408},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"39928f358dd13d9fc1a4641800e57be157ecd815","modified":1570609592411},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"d68da660cd1cc8fb3ff0a81178decadb620afc11","modified":1570609592410},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"623e73bedef067ac24a398ef27c8197295da872d","modified":1570609592411},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"8ab040fccba41675bc835973515530af8a51f8bd","modified":1570609592409},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"a22d1ea29a5ffe46199ab7d108a291a05af8d5b6","modified":1570609592415},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"d18c87d7839e7407e39acd2998bcc9e0b34611b0","modified":1570609592414},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"4cff8bf5c42c62f7f0ac1f0d70f839dae39ba77a","modified":1570609592415},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"7a4e7d463165df3221a2a9063dc010968289782d","modified":1570609592413},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"4e86e1ace90a70bb8862f5e6de9dbe7bfc046bee","modified":1570609592425},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"280ff4282396beb53fb3913f58c6b5890bd1c9ef","modified":1570609592424},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"3da014b25f9ac804eda1614591706e3733c0d2c5","modified":1570609592421},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"b3818fd0b3028dadf341b6d0b180e1243683de6a","modified":1570609592427},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"bc3fc9d053b3d1fc0cd3918bf9a629a6f38f6414","modified":1570609592420},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"9a4923d2aa5182531ea7a7fb9abe824450026208","modified":1570609592426},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"1a5d94f5779a2ce13abc886dd78e0617f89c34b9","modified":1570609592428},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"ea1c136f960667a0a13b334db497b9b19c41f629","modified":1570609592431},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"43a20fa0e9ae2f4254f04813f9c619dd36b49ae5","modified":1570609592431},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"1b72c755101c9dfb85da13df9a0abccf37cd1dd2","modified":1570609592428},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"078bd2d5815eb23e8c5f74467dc0042babea00ae","modified":1570609592448},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"143ef265c96a8ea2fb93c36c5ffb9c5e940f7693","modified":1570609592447},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1570609592687},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"767ba29f258db5d2e5baf875a6f36ac1d44df6a3","modified":1570609592433},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"21a14a19149f1cb8e011c477f29dd1352675605b","modified":1570609592690},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"1aabac9e37a8f4451c86d09037b3a1f8b30eaf5e","modified":1570609592689},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1570609592687},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"e9b0752f08398709e787546a246baca12b4c557f","modified":1570609592718},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1570609592718},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"da7049f3d9a157abe0ecc62611edcf43605ba84d","modified":1570609592719},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"d45ca53af17d1d83fd27f8ed0917a72f0060e1a9","modified":1570609592449},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"3eea56cc9ce47bb4760930c4c69cebf847a7fbb2","modified":1570609592747},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ebc95eeb8966d17cdc7dd0de009deaef1fe65064","modified":1570609592720},{"_id":"themes/next/source/js/schemes/muse.js","hash":"ccc0c5cd4ec6f8159c98990ad83f11a5c0b0234c","modified":1570609592746},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1570609592753},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1570609592752},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1570609592750},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1570609592753},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1570609592754},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1570609592771},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1570609592772},{"_id":"source/_posts/技术/how-to-manage-user-secret-in-develop-and-production/image-20200608205613844.png","hash":"ca83ba1d5abae15e45fed471e4bcb729e6dca71b","modified":1591620973856},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1570609592770},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"9fd526db0527c71243f05e18086f937dc67b1c3e","modified":1570609592522},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"5c0ca7f801859cff254d2f5b7d1a70d66ff61a8d","modified":1570609592515},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"463817cbbd804ce134cb3e7e721431cb0e1616f2","modified":1570609592521},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1570609592523},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"a4c6ee546a94fd69e5b7a1e4c054ab8cacb73d2a","modified":1570609592556},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"997058180065d986e05df72992cc2cbfd7febd7e","modified":1570609592524},{"_id":"themes/next/source/css/_common/components/scrollbar.styl","hash":"afdd21533db18d846e1a2663b1199761b1bd2c1e","modified":1570609592588},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"cfa64bd8ee2ff9f943673e339d69341e76fbf031","modified":1570609592587},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"40144394fdfe05d400f39f6763f66f75479a2e34","modified":1570609592678},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"9c6194177533619a6f6685dc7e890dcbec456241","modified":1570609592680},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"fec36a14080104b5862e9f021eab117d87c5f7c5","modified":1570609592681},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"35c6fd7eab3779bd9e38b7ba8825ab0c67a1be7a","modified":1570609592680},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"107f42aa590ec4ba0765a0bc5d735f0f09edc0ff","modified":1570609592683},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1570609592682},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"1a4ac0d119f2126ef8951897338706edce112235","modified":1570609592677},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"d0e9065b0dbbc01811259f0597d1790268b4881b","modified":1570609592696},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"a609ff811f2b2764f5470236fe2fb1f3aa6ccba5","modified":1570609592695},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"8da8416213127595dfc4d2b358639194647e7bd3","modified":1570609592697},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1570609592698},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"40f266e24af4dedc9497056ab18ebcfda38dd47d","modified":1570609592698},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"6aee54cd5a20181e18596565356bd54c66e33823","modified":1570609592704},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"06d9d00257abd28414ec0b746f866bf9911cf5ec","modified":1570609592703},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"157e6915dcf5990566e463acffa71043b2651c07","modified":1570609592708},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"04706657af638f2746ae59520e6fc78577c7682c","modified":1570609592708},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"6aee54cd5a20181e18596565356bd54c66e33823","modified":1570609592710},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"25f05ed8da68d034dce7f06e0f20f6cd55841070","modified":1570609592705},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"234b44cfd03f9c9e3e179ff5fd698ac876341913","modified":1570609592709},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1570609592711},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"b9619c9827f969ca2e2f5878552362a7b858918f","modified":1570609592713},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"e73d6da74c5755442e831d8fd7d922c5b32bd892","modified":1570609592713},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0b3001909f3446843b226030524ea8498d4d8997","modified":1570609592714},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"0d6f0df798449b710e1e5dbd43d470089b2a3c95","modified":1570609592716},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"5b5e0a02a7bf63de9efcd33a4e482939cce5822d","modified":1570609592715},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"adb7379f3b9001840eb38b260434e89365771a81","modified":1570609592717},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1570609592756},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1570609592756},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1570609592757},{"_id":"themes/next/source/lib/jquery/index.js","hash":"b15f7cfa79519756dff1ad22553fd0ed09024343","modified":1570609592766},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1570609592764},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"2df409df04fdb52d7234876a9f6e502edd4e3929","modified":1570609592528},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1570609592531},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"a8f4d4b86acaa34c99111b2dde5d0779cc7e0de6","modified":1570609592529},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"c9cfb4b99e1ec8ec9cf075cb761b8f7fa5fe63fd","modified":1570609592530},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"024e8ff40ca881c6fbf45712897e22f58a3811ab","modified":1570609592540},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"b8647d6140141b0a160607f6353e4d4594cca92e","modified":1570609592537},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"3a0efe849587b34f20d4e260028dc799215b0bb3","modified":1570609592538},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"33200f60bd6a8bbfc66dd49a239bcc75c2f564c1","modified":1570609592536},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"e5a5f8747fdf2ca960e4e73c081b8952afd62224","modified":1570609592546},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1570609592547},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1570609592545},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"9c1a082e6c1f96187a099c3f4cb5424c0c9fd06e","modified":1570609592543},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fa1cea6fcc3f552d57cc7d28380a304859139bf6","modified":1570609592546},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1570609592549},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"9a8fb61bd2d184de9d206e62ba8961d1845c5669","modified":1570609592548},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"c27527cdeb9e3a9f447f7238f442a5dc33fde4e6","modified":1570609592553},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"c97c819a65f6967485184399397601e5133deda6","modified":1570609592555},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1570609592557},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"fc94dd09b4245143b452d6cf2fc4c12134d99d6d","modified":1570609592559},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a73346f999b31355075cd58637946a8950cf6f7e","modified":1570609592563},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"f3b0d259e991ac86454ae5eac6bc94dc8691d8c9","modified":1570609592558},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"13d365ee626c01f17ec664b3f54f51d8b9ee7cf4","modified":1570609592571},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"b6a241626783d2ac115d683fd59ec283af68e5bb","modified":1570609592565},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d77f85d3af2d7090d84b28ab01c6a49f92eec647","modified":1570609592566},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1570609592575},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"f14cefc99309934d4103a3aa785e1258d858813f","modified":1570609592564},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1570609592579},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"4aad8e36178faaa71a767af0084d578df4c09f73","modified":1570609592572},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ccd0b1309acff0c676fdcc848a8ae2d05f0369ab","modified":1570609592573},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"981795aad232c8bd3f52a0ed8720db696d18a234","modified":1570609592581},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"539fc0880b2e035e8316d5d4b423703195c1b7ba","modified":1570609592579},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"c8009fd9598a661b7d23158b5121b6ac266939e9","modified":1570609592580},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"615fca7dff197a2ca3df674cf963ce70b8525985","modified":1570609592582},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"a5484d8436b2b7862faf6e7309a9e7b88cdd0027","modified":1570609592590},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"ab1776c5dc537beabb0ab81a0f04e08bebad070b","modified":1570609592591},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"03a4e75e963e3e7cc393d588b1495a88d52e0e40","modified":1570609592596},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-button.styl","hash":"b36eea093bd4b32056b5de6f370ff57e50b25a49","modified":1570609592597},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"e58bb8b7127aa21e8260493a425ec00fcb25d338","modified":1570609592598},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"7e2ba73073daaea0a18c3d67ff137dd683af7011","modified":1570609592600},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"9204c79c05d620ecd5d411cdf11e27441b6281dc","modified":1570609592604},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"0eadef0381f696de7f88d7dc5f0ddc3cd5d309b3","modified":1570609592611},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"ed3a2960ebce7396d1893bb8e08c99c7d9259140","modified":1570609592613},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"fde59300ec38868676ff5ed495b9dc9b02d07ffc","modified":1570609592614},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"3cb387fa70017f3c24a1a1884461d29deda54585","modified":1570609592612},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1570609592615},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"2d58ad90f148e845bc7023751a7a13260600f8d6","modified":1570609592615},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"b43421291bf85b589e8d0ec853e238d36ab80631","modified":1570609592620},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"020fac447d7a17c03e2802f0f724ae0738088354","modified":1570609592621},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"da7a21f5a2f7dcf4c5a4788d7670159ca4132b65","modified":1570609592625},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"1df9d36e2b0e9c94e0a959acc136026405ae0d73","modified":1570609592623},{"_id":"themes/next/source/css/_common/components/tags/pdf.styl","hash":"3baeeb51cfe123e99235ee1816d0e1f6a97c7852","modified":1570609592622},{"_id":"themes/next/source/css/_common/components/third-party/copy-code.styl","hash":"d9c244b1c3a09a7fccd3c3f732e6fb112a8cd565","modified":1570609592630},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"a01484e350ad5fc9b1fdfbfafb2ddd9687ad4d20","modified":1570609592631},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"4305813408a1cd6aba764a7769b94b081d383d4f","modified":1570609592629},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"2fbe52f955da41c7a14eb09918bf86a252e4504f","modified":1570609592637},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"6880467b4f6d7b057fb8291aa10966429a0a3bff","modified":1570609592642},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"ed8a12982c0497eeb9d7642781abeb801428f83d","modified":1570609592640},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"9801977a23268e36c5deefd270423f6f1a0c3bb2","modified":1570609592671},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"35dc9f3990fadff3ea038d4e8ac75923219886ed","modified":1570609592670},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"93b6f8f38b65410d7490d60e1c487e0093999114","modified":1570609592673},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1570609592707},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1570609592706},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1570609592712},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1570609592761},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1570609592763},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1570609592769},{"_id":"public/2020/06/09/技术/how-to-manage-user-secret-in-develop-and-production/index.html","hash":"1da3053b4cb81b51849a307bbefe60dcd56bd382","modified":1593092861335},{"_id":"public/2020/06/24/技术/how-to-use-abp-part1-basic-desc/index.html","hash":"e324c6c45b2da03d326f56280d95b44810818681","modified":1593092861336},{"_id":"public/2020/06/22/技术/如何在ASP.NET Core中使用SignalR构建与Angular通信的实时通信应用程序/index.html","hash":"b6e71210f5f7c229eaab10754dbb4e10287fe634","modified":1593092861370},{"_id":"public/2020/05/28/技术/C＃性能提示和技巧/index.html","hash":"c30224255af79909e35ec976a14357ce24aa55b6","modified":1593092861371},{"_id":"public/2020/05/26/管理/我是如何完成一个短期项目的？/index.html","hash":"1643e50bdfe595c4254ef0c5db9e9514e9e6f3c3","modified":1593092861371},{"_id":"public/2020/05/18/随笔/共同创业五年，技术总监却突然就这么离职了/index.html","hash":"1a34ef7214ec973dcb0792653c266a23ffdfe402","modified":1593092861371},{"_id":"public/2020/05/12/技术/最佳REST API最佳做法/index.html","hash":"9c4432f86a1d6bf7c0b23686204b4c6eb936950b","modified":1593092861371},{"_id":"public/tags/读书/index.html","hash":"ba1c2ba8cb557e6c0009e4ddaf04de6a34d44e0d","modified":1593092861381},{"_id":"public/tags/管理/index.html","hash":"13ee813ccfd4905036cdf04cacfbe3d49a35c546","modified":1593092861381},{"_id":"public/tags/技术/page/3/index.html","hash":"658672a79f4250b6fe551e1f44ba5a64575b9df2","modified":1593092861381},{"_id":"public/archives/page/7/index.html","hash":"9751a681f9abbc239718110b5773f78994940744","modified":1593092861381},{"_id":"public/archives/2019/page/3/index.html","hash":"2bfb4482602184c6aa83b6cc542f61275e58adba","modified":1593092861381},{"_id":"public/archives/2019/10/page/2/index.html","hash":"c4ef09d1165ddcb5922ce964b8a83b932d80973e","modified":1593092861381},{"_id":"public/archives/2019/11/index.html","hash":"cd1997041328724004a3005b658e1e334f0a919d","modified":1593092861381},{"_id":"public/archives/2020/page/5/index.html","hash":"d54ff0dd68edeced2ee3596b6812ac29683abcfc","modified":1593092861381},{"_id":"public/archives/2020/02/index.html","hash":"c137c7414741ff40b826666341d86621cfd21803","modified":1593092861381},{"_id":"public/archives/2020/03/index.html","hash":"beb92c2e3dad08f4ea0e056ebe8f6071a3f7718b","modified":1593092861381},{"_id":"public/archives/2020/04/page/2/index.html","hash":"3933b0956cce04642e038f0eaa40b0853ab27076","modified":1593092861382},{"_id":"public/archives/2020/06/index.html","hash":"0a03ca4f478e14923d53987bc4c438e90e9a30d0","modified":1593092861382},{"_id":"public/categories/读书/index.html","hash":"373c72961c53b397bea6602dbc232bb0ab4c43ea","modified":1593092861382},{"_id":"public/categories/技术/page/3/index.html","hash":"4883a25b58ad447be446dcb8eab44419165e0e4b","modified":1593092861382},{"_id":"public/categories/管理/index.html","hash":"ddfc81b9467c91020781a885d1c0402144b5ea2d","modified":1593092861382},{"_id":"public/2020/05/15/技术/那些与EF有关的错误认知/index.html","hash":"262712eda83e40d9a67f2c9db5c4e44066ae285a","modified":1593092861382},{"_id":"public/2020/05/17/随笔/是小厂全栈好，还是大厂专业工程师好？/index.html","hash":"901a714b282573388ee0696a50e520947e31d724","modified":1593092861382},{"_id":"public/2020/05/08/技术/甲方爸爸，大概你要的是代码生成器吧？/index.html","hash":"56c80c625204829251ef1faf9c4665df4dca38f4","modified":1593092861382},{"_id":"public/2020/05/03/技术/提升WebAPI性能的几个小建议/index.html","hash":"67e2298b8e87c68c3baab50281f040e617c4bd76","modified":1593092861382},{"_id":"public/2020/04/30/技术/使用自定义DelegatingHandler编写更清洁的Typed HttpClient/index.html","hash":"d0fd6b3e00147ed663145e220018fc3d2ee99a31","modified":1593092861382},{"_id":"public/2020/04/30/技术/什么是TDD（一）/index.html","hash":"a48fd2b36c3459b0ce44fc937ed87fd0409000fd","modified":1593092861382},{"_id":"public/2020/04/30/技术/TDD学习笔记（二）单元测试/index.html","hash":"d720f9cc25b5aa65c07e0005d81077fcc1217e31","modified":1593092861382},{"_id":"public/2020/04/28/技术/在C＃中使用RESTful API的几种好方法/index.html","hash":"2606127c647563f23403515c96983a3daeaab39e","modified":1593092861382},{"_id":"public/2020/04/22/技术/您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术/index.html","hash":"5ecf4c890e508601cbb1bbf51e9233af84c49295","modified":1593092861383},{"_id":"public/2020/04/17/随笔/那位五十多岁的创业者给我的启示/index.html","hash":"93718cc6bcc1d017e78b3e35d96d98b1f788787f","modified":1593092861383},{"_id":"public/2020/04/22/技术/分析EFCore中的内存泄漏/index.html","hash":"4d77990f925e33dfff3c3d1e3be3bacf543a9456","modified":1593092861383},{"_id":"public/2020/04/17/随笔/那个程序员，为什么选择改行_/index.html","hash":"0d2612f0d14d64a69869df7daa8bce4e7047a5ff","modified":1593092861383},{"_id":"public/2020/04/10/随笔/how-to-find-millon-in-changsha-programmer/index.html","hash":"04c263f68ac7d3e5f29c422feae8bfe94921efe7","modified":1593092861383},{"_id":"public/2020/04/09/技术/try-to-find-high-cpu-usage-in-netcore/index.html","hash":"c8691058800e4c4cb1a70e4dee48c659573ede24","modified":1593092861383},{"_id":"public/2020/04/06/技术/memory-manage-in-c#/index.html","hash":"f93ac7fd0ff8855cbae56a29078913990e43f1db","modified":1593092861383},{"_id":"public/2020/04/05/技术/understanding-garbage-collection-in-.net/index.html","hash":"08372f2862a3b630f60f03f4638c9062cb3f1bdb","modified":1593092861383},{"_id":"public/2020/03/26/技术/the-typical-ten-problems-in-c-sharp/index.html","hash":"1313b67e81b8bfd71f9749ecf60500818de84e07","modified":1593092861383},{"_id":"public/2020/03/26/技术/ten-problems-view/index.html","hash":"ea21631aa0595072e892fcc2707f8899c8046362","modified":1593092861383},{"_id":"public/2020/03/11/随笔/如何快速融入团队并成为团队核心（八）/index.html","hash":"941607dfc4577f1e9cf84c3e0f1a20abca7bd896","modified":1593092861383},{"_id":"public/2020/03/11/随笔/如何快速融入团队并成为团队核心（九）/index.html","hash":"9b1646ca907e1064d5f1f0fdb1b7a80e938009c5","modified":1593092861383},{"_id":"public/2020/03/12/技术/how-to-use-httpclient-in-netcore/index.html","hash":"b0c036419b83a9a0eff2b8c3332850d1b20692c8","modified":1593092861383},{"_id":"public/2020/02/23/技术/how-to-use-restfulapi-in-netcore/index.html","hash":"2fb5e0e5d390ff04307226559f052f8fe09fb322","modified":1593092861384},{"_id":"public/2020/02/23/技术/how-to-learn-wpf/index.html","hash":"ab955f82048d1eea870d0912a3ddd92714d96e18","modified":1593092861384},{"_id":"public/2020/02/17/随笔/如何快速融入团队并成为团队核心（七）/index.html","hash":"b182f599ce70064c07f8a52bdc561d748d07abb4","modified":1593092861384},{"_id":"public/2020/01/19/随笔/如何快速融入团队并成为团队核心（六）/index.html","hash":"3a5c4eb6c093a2c1ef2c791e7c465a3b8111c412","modified":1593092861384},{"_id":"public/2020/02/16/随笔/让人迷茫的三十岁/index.html","hash":"3674c5cbaa6e8ffa6a53d6364fd5e3efa13e7847","modified":1593092861384},{"_id":"public/2020/02/16/随笔/如何看待程序媛的未来职业规划/index.html","hash":"a04051cdacac1625d159657681a7e98b9ec46c93","modified":1593092861384},{"_id":"public/2020/01/19/随笔/如何快速融入团队并成为团队核心（三）/index.html","hash":"5586888a1df122f3c8538df922520af5ce2f7b32","modified":1593092861384},{"_id":"public/2020/01/19/随笔/如何快速融入团队并成为团队核心（五）/index.html","hash":"e891a3a23cda9a65a4142a608100cb56d16f5b3d","modified":1593092861384},{"_id":"public/2020/01/19/随笔/如何快速融入团队并成为团队核心（四）/index.html","hash":"ffed2d71ebaa79ef7a7888a3fd3beea31404a812","modified":1593092861384},{"_id":"public/2020/01/19/随笔/如何快速融入团队并成为团队核心（二）/index.html","hash":"2aee8d17f86b3246c8545fe9bcc681cd42584b14","modified":1593092861384},{"_id":"public/2020/01/05/技术/持续交付全流程思考与实践/index.html","hash":"1787312e35ad6c277c8a1084a7d2fd92f959fa41","modified":1593092861384},{"_id":"public/2020/01/09/读书/从《必然》中看到的必要/index.html","hash":"f5fed0a423361f3aec072e1c7c9c00da9a057c81","modified":1593092861384},{"_id":"public/2020/01/03/随笔/如何快速融入团队并成为团队核心（一）/index.html","hash":"2eaa905492fc7e72f7bc05f3b29b81fdee042085","modified":1593092861385},{"_id":"public/2020/01/03/随笔/2019年年终总结，静候时光与一步一个脚印/index.html","hash":"1f2a835aedece071765dce6093450502ca277748","modified":1593092861385},{"_id":"public/2019/12/15/读书/《程序员的三门课》读书笔记/index.html","hash":"7a22e365753eba9aea9aac3a4a51f828f0562532","modified":1593092861385},{"_id":"public/2019/12/15/随笔/我在外包公司做增删改查有前途么？/index.html","hash":"894b28ec92932496aae4ed8fab21c841a59e5645","modified":1593092861385},{"_id":"public/2019/12/11/随笔/容器-推荐序/index.html","hash":"a59862edb0d0bc39f9f3953300c7d3f8301fd14c","modified":1593092861385},{"_id":"public/2019/12/09/随笔/PMP学习之旅回顾/index.html","hash":"42c38fcdae0a3794fb1e02ba7318eb6935142ba2","modified":1593092861385},{"_id":"public/2019/12/01/技术/简述介绍.NET Core中的依赖注入方法/index.html","hash":"41d7b90351d3dab81b1c59edcdbc1aa3a10552a1","modified":1593092861385},{"_id":"public/2019/12/01/技术/浅议Grpc的双向流和WCF中的回调机制/index.html","hash":"0afa5c0315a7a7f7039c64486f96fc0fcf4a70fd","modified":1593092861385},{"_id":"public/2019/12/01/随笔/网易事件背后众生相/index.html","hash":"dae5a23466c82916310d65b27cfd739014f5f507","modified":1593092861385},{"_id":"public/2019/11/12/随笔/2019.NET Conf，.NET技术之崛起，已势不可挡/index.html","hash":"a59e9be996f8e963a26029ad1eb1851b019dc6e8","modified":1593092861385},{"_id":"public/2019/11/05/技术/你或许以为你不需要领域驱动设计/index.html","hash":"2926dd7e6179a60a056d3a4f6dc1a0c8f4f1ac7e","modified":1593092861385},{"_id":"public/2019/11/05/随笔/开发者的不断进取，源自对技术的点滴追求/index.html","hash":"34cf701dd005d11be9e564f92e32ff264c03f3fc","modified":1593092861385},{"_id":"public/2019/11/04/随笔/2019.Net Conf，我们的共同期待/index.html","hash":"160b138f978433d5d10347c4a855ecda118e0f17","modified":1593092861386},{"_id":"public/2019/10/28/管理/JobChance/index.html","hash":"9f06b7cbfbf6553f377e4eb98b2cbb31af7d4c26","modified":1593092861386},{"_id":"public/2019/10/09/index/index.html","hash":"d30c843aa1a76136ba240a4ac82da61123fecccd","modified":1593092861386},{"_id":"public/2019/10/09/读书/《猎豹行动·硝烟中的敏捷转型之旅》有感/index.html","hash":"9af0e1b062590b2f2459f92781b5f4675a120662","modified":1593092861386},{"_id":"public/2019/10/09/读书/《实例化需求》读书笔记/index.html","hash":"d481a6786383679de2de67ee8a08e13c3e30659f","modified":1593092861386},{"_id":"public/2019/10/09/技术/从零开始学习TDD，测试驱动开发/index.html","hash":"2878c4aa56262b1754657ff54b1286f32f985e23","modified":1593092861386},{"_id":"public/2019/10/09/管理/怎样的项目才能称为“成功项目”？/index.html","hash":"c56d79ca5e233ebff6cbdf692f3d18df2405b610","modified":1593092861386},{"_id":"public/2019/10/09/技术/关注细节，成就卓越代码/index.html","hash":"5971ccf84d7f2ef69ab5a771a21dadf8e0dbab40","modified":1593092861386},{"_id":"public/2019/10/09/管理/项目失控全记录/index.html","hash":"61674707aa5862080178e101979af9877e668fc4","modified":1593092861386},{"_id":"public/2019/10/09/随笔/一位996、CRUD开发者的一天/index.html","hash":"ef44fa933af28fdf1886f43dbec8b71193665c57","modified":1593092861386},{"_id":"public/2019/10/09/随笔/坚持一个好习惯该有多难_/index.html","hash":"080b797e1c0216d0b43592f01d344f32a48fbf4d","modified":1593092861386},{"_id":"public/2019/10/09/随笔/独立开发者，程序员的美好梦想？/index.html","hash":"a097b8924a210d5bfcf04f809d8b772933ed245c","modified":1593092861386},{"_id":"public/tags/随笔/page/2/index.html","hash":"0997772f1e69e312b3f66da45ece9d1cd3180a0f","modified":1593092861386},{"_id":"public/tags/随笔/index.html","hash":"56f5dff2cb813717562cd0c873099c3dca1be736","modified":1593092861386},{"_id":"public/tags/技术/index.html","hash":"f54fe503347b56f7aa752bb9a769d478c6c12eda","modified":1593092861386},{"_id":"public/tags/随笔/page/3/index.html","hash":"10f04f9dd697559bce92c02a2af12b4c94695c26","modified":1593092861386},{"_id":"public/tags/技术/page/2/index.html","hash":"5db605490ec681d8f69afaec438caab641e0696e","modified":1593092861387},{"_id":"public/archives/index.html","hash":"bec1eac4627bf15b273231a6d9f3cc4d62db8533","modified":1593092861387},{"_id":"public/archives/page/2/index.html","hash":"7f4685860d6200571a0c218077ea8bf20c96f385","modified":1593092861387},{"_id":"public/archives/page/3/index.html","hash":"b10ac12a91ed0b0f60323b20093dc9bfda09b563","modified":1593092861387},{"_id":"public/archives/page/4/index.html","hash":"ac24c2860639442c04127dc486b4617dfe304b16","modified":1593092861387},{"_id":"public/archives/page/5/index.html","hash":"1a3e226fbd6f7719a1f0f651a29c81e662e2a6c3","modified":1593092861387},{"_id":"public/archives/page/6/index.html","hash":"7571d9622e7bc0fcb4fd937f81979fa6000356b1","modified":1593092861387},{"_id":"public/archives/2019/index.html","hash":"6445b3bdd7c1025b900572bc645f91f7d5f76d47","modified":1593092861387},{"_id":"public/archives/2019/page/2/index.html","hash":"379da757237b13ba504d25e35fabe695ffbc12ab","modified":1593092861387},{"_id":"public/archives/2019/10/index.html","hash":"9f55a80084fc5a3e856301fab2bf563cb2df53c2","modified":1593092861387},{"_id":"public/archives/2019/12/index.html","hash":"df2cec17a54dbe54a94232b60039a5d997bd1a5e","modified":1593092861387},{"_id":"public/archives/2020/index.html","hash":"2d672cd0b4562e3ba6491dcb5f8eab59cbe4c2b9","modified":1593092861387},{"_id":"public/archives/2020/page/2/index.html","hash":"da2d5c004809b033aa92d8dee3f29566a248bd9a","modified":1593092861387},{"_id":"public/archives/2020/page/3/index.html","hash":"be3fcf3a2cfde1685a206647e64a709b29367d60","modified":1593092861387},{"_id":"public/archives/2020/page/4/index.html","hash":"4ff66f94a3172cf1d8f7ed3a63dd5f08b9cf32cd","modified":1593092861387},{"_id":"public/archives/2020/01/index.html","hash":"303aa24616654240577c5c8e7bb88927b8715c91","modified":1593092861387},{"_id":"public/archives/2020/04/index.html","hash":"1392fa7df1b03c9805358b80ec21c78ca92dc220","modified":1593092861387},{"_id":"public/index.html","hash":"3e6845dd66040a66003c72d572357c914f0858dc","modified":1593092861388},{"_id":"public/archives/2020/05/index.html","hash":"7a5e4474493fa9c80b84feb0272ca1d1c165eae6","modified":1593092861388},{"_id":"public/page/2/index.html","hash":"0e78fb9ee6b45d1676943344ef2c113646688218","modified":1593092861388},{"_id":"public/page/3/index.html","hash":"f20ca8ff6e00c78d5f80bec6d4056a8f2a3a4b9d","modified":1593092861388},{"_id":"public/page/4/index.html","hash":"0cb4b476a70ac3be3893fe3d95574219f92179a0","modified":1593092861389},{"_id":"public/page/6/index.html","hash":"ce78f92e19bed94dd1c4a43a32120198e018c0b1","modified":1593092861389},{"_id":"public/page/5/index.html","hash":"9e500d30beb21e2edca5e3614de62422a2bfd2f6","modified":1593092861389},{"_id":"public/page/7/index.html","hash":"bde0c2a270a364607e7c3be0ed98e5909fdabf75","modified":1593092861389},{"_id":"public/categories/随笔/index.html","hash":"1903d0a15433b96cf83839679f87723f7984a3a1","modified":1593092861389},{"_id":"public/categories/随笔/page/2/index.html","hash":"1542c7a0646e5ab14ddb87ef61b08b01305d3277","modified":1593092861389},{"_id":"public/categories/随笔/page/3/index.html","hash":"e7eb95c7982c17ccefaba322749275cc0af63e89","modified":1593092861389},{"_id":"public/categories/技术/index.html","hash":"e1602ae9f32af87780cd6fa6b84542dd2f6894cc","modified":1593092861390},{"_id":"public/categories/技术/page/2/index.html","hash":"b11cdc1417c44e9544ae1742121dc6212183fdc2","modified":1593092861390},{"_id":"public/images/how-to-manage-user-secret-in-develop-and-production_1.png","hash":"ca83ba1d5abae15e45fed471e4bcb729e6dca71b","modified":1593092861390},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1593092861390},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1593092861390},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1593092861390},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1593092861390},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1593092861390},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1593092861390},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1593092861390},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1593092861390},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1593092861390},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1593092861390},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1593092861392},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1593092861392},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1593092861392},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1593092861392},{"_id":"public/images/searchicon.png","hash":"025d64ba0160a3a2257dd2b3032b5f7c9dd9b82b","modified":1593092861392},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1593092861392},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1593092861392},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1593092861392},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1593092861392},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1593092861392},{"_id":"public/2020/06/09/技术/how-to-manage-user-secret-in-develop-and-production/image-20200608205613844.png","hash":"ca83ba1d5abae15e45fed471e4bcb729e6dca71b","modified":1593092861392},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1593092861889},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1593092861891},{"_id":"public/js/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1593092861903},{"_id":"public/js/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1593092861903},{"_id":"public/js/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1593092861903},{"_id":"public/js/next-boot.js","hash":"e0615efab5f81ba0fd39c0527eac31144deac7ce","modified":1593092861903},{"_id":"public/js/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1593092861904},{"_id":"public/js/motion.js","hash":"a16bc0b701646bf6653484675f4d5dc0f892d184","modified":1593092861904},{"_id":"public/js/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1593092861904},{"_id":"public/js/utils.js","hash":"81913c5f75d0949443833cf4269ad63bd7f9be6f","modified":1593092861904},{"_id":"public/js/js.cookie.js","hash":"e0afce539f1fb81d59e3c6f0a68d736e2fb45d93","modified":1593092861904},{"_id":"public/js/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1593092861904},{"_id":"public/js/schemes/muse.js","hash":"e9bfa6b343b67625f58757efce46ccdaac8f308c","modified":1593092861904},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1593092861904},{"_id":"public/js/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1593092861904},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1593092861904},{"_id":"public/css/main.css","hash":"ad96a83ce22071c1da24129d22104796ec263e10","modified":1593092861904},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1593092861905},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1593092861905},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1593092861905},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1593092861905},{"_id":"public/lib/jquery/index.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1593092861905},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1593092861905},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1593092861914}],"Category":[{"name":"随笔","_id":"ckbuucqtu00013cvi9ugfhi1e"},{"name":"读书","_id":"ckbuucqwz00073cvidfgjrf0h"},{"name":"技术","_id":"ckbuucqxg000p3cvinriajhve"},{"name":"管理","_id":"ckbuucqyq002s3cviu1detito"}],"Data":[],"Page":[],"Post":[{"title":"Welcome My Friends，溪源的个人博客正式开业喽！","date":"2019-10-09T08:28:00.000Z","author":"邹溪源","_content":"\n\n# 一、为啥要开独立博客\n之前注册的便宜的个人博客的域名techq.xyz注册了快一年了，已经到了要续费的日期了，为了让这点小钱能产生价值，我觉得还是有必要开一个独立博客，以后把博客园里分享的那些博客再一篇篇的迁移过来。  \n\n虽然坚持写了很久博客，感觉收获还不够多，这些博客也没啥干货，所以大家们能够关注，已经是莫大的荣幸了。值此个人独立博客开业之际，向大家表示诚挚的感谢。  \n\n立个flag，要开始每周写两篇了！  欢迎大家持续关注。请记住这个域名techq.xyz，溪源的技术小圆圈。每个人的知识领域，都是无穷个圆圈，越是打开这个圆圈，你的未知领域就会越大。\n\n\n\n# 二、引子  \n不知不觉，以每月最少一篇、每周一篇到两篇的频率开始写博客已经差不多坚持了一年，也算是个人一个小小的进步吧，虽然离那些一直在进步的朋友们差距越来越大，但我觉得长期坚持下去至少会比以前的自己更优秀，这就已经是一种进步了。      \n\n![图片](https://images.smcdn.cn/GNl9d8F1UwcQ1f1b/IMG_0215.JPG!thumbnail)\n# 三、写博客的好处、坏处  \n写博客是对每个人来说都有成长的过程，既可以用来总结方法，又可以总结经验教训，也能够实现个人表达能力和文笔的提升，写博客也是在强迫自己输出，如果没有稳定的输入，如何能够稳定的输出，所以也同样是在逼自己输入。    \n\n写博客能真正有机会认识行业内的专家，但是这仅仅是入门的第一步，认识他们并不是你的人脉，没有持续的成长，其实不过是个陌路人而已。      \n\n偶尔写几篇博客被人欣赏，这不一定是在欣赏你，而是文章中的一点点亮点，他们看到了，点个赞而已。只有长期输出，才或许有机会真正能够获得别人的认可，成为专家们的圈中人。      \n\n写博客也能把社区拉起来。但是，这些并不是真正意义上的技术社区，大概率只是小圈子而已，一群人，有话聊而已，像中生代技术社区那样，才算一个真正的社区。有时看似打造了一个个圈子，建了几个群，搞了几次所谓社区活动，就容易孤芳自赏，以为获得了一点点资源，打造了一点点人脉，其实并非如此。那么多群，究竟有几个搞正事的群？  \n\n>真正有本身的人都在不停的学习。 群只是分享他们学习收获的媒介而已。\n\n张爱玲是这么说的：\n>下大雨，有人打着伞，有人没带伞。没伞的挨着有伞的，钻到伞底下去躲雨，多少有点掩蔽，可是伞的边缘滔滔流下水来，反而比外面的雨更来得凶。挤在伞沿下的人，头上游得稀湿。\n\n当然，这句话是说穷人结交富人，往往会得不偿失，实际上通过所谓即时通讯工具认识一些大佬，大体上也是一样的。跟别人共伞，他人的伞短期能让你避雨。你看似能获得许多收获，其实那大概率只是虚幻，这是别人的，不是自己的。\n\n基于即时通讯打造的群，容易让人沉迷，而事实上沉迷于所谓群聊，不过是新时代的菜市场扯淡，你以为你在闹中求静，其实是在自我安慰。      \n\n资源看似很有价值，如果不是资源运作的大佬，几乎不可能依托这样的资源创造价值。所以那些所谓资源，不过是萍水相逢的网友，有时试图靠认识大佬来提升自己，其实不过是美好的幻想。  \n  \n也不用以为认识个别大佬就自以为是，以为自己成为了世人瞩目的焦点，那也是幻想而已。别总幻想靠别人来证明自己的价值，靠别人早晚无人可靠。人生漫漫长路，只有靠自己积极进取，才能真正脱离危机。在这个时代，看起来充满了机遇、挑战、失败和未知，有人成功，有人沉沦，每个人都与众不同，其实每个人都在打造自己的品牌，每个人都是独有的品牌。  \n\n![图片](https://uploader.shimo.im/f/T4kztYsKgIM3pOF3.jpeg!thumbnail)\n\n# 四、写哪些内容  \n当你打算写某个方向的博客时，可能会遇到阻塞，这恰好说明你对这个方向还不够熟悉；就如当你遇到问题束手无策时，正说明了你还不够专业。如果熟悉或专业，做事情其实都会水到渠成，迎刃而解。\n\n每一个你认为很普通的点，其实都有着充分的意义，都可以成为一个专业方向。例如需求工程、人际沟通、技术语言、消息队列、数据存储，都同样如此，唯有认真去学习、去总结，才能真正把握真谛，真正成为专家。    \n\n敢不敢在一个最简单的事情，如撸一段简单代码上每天练习五分钟，坚持五年？毋庸置疑，事实上无需五年，哪怕一周都会有巨大收获，这样一定都能更大程度上促进你的代码领悟力。而那些专家们，他们正是这样培养出来的思维方式和方法，他们坚持了十几年，才带来了今天的收获。      \n\n每个人的每个阶段都会有许多成长，遇到未知的问题，并解决问题，这就是在成长，但是如果没有总结，也许问题就会这么错过，直到下一次再出现，但是，中年人的每一次问题解决都充满意义，下一次再犯同类错误就应该打板子了。通过博客来总结这些问题，实际上是在记录错题本，让自己的经验教训库更加完善。  \n\n![图片](https://uploader.shimo.im/f/XeT4iD8JSxACjCal.png!thumbnail)\n# 五、展望\n每天都是一个小进步，每月都有进步，每年都可以有大进步，明年再来看看，这一年成长了多少？    \n\n不必苛求一天成长，不必总想着别人怎么怎么厉害，那些标杆都是一个个同样平凡的个体，经历了多年的积累才能成就今天的优秀，天赋固然重要，但是后天的积累才更有价值。    \n\n刘未鹏从18岁开始写博客，每天写一篇，才有今天的《暗世界》；熊节大佬从20几岁开始稳定输出，靠着普通的学历，成就今天的不凡。他们今天的优秀，难道是上天的眷顾么？从来不是，都是自己后天的努力，才有今天的收获。    \n\n努力使自己有进步，只需比之前的自己更努力，更优秀，就是一种成长。    \n\n每天总结三遍，我今天收获了什么？我今天收获了什么？我今天收获了什么？    \n\n让自己的成长像猪肉一般实体化，价值才真正的随时随地可以体现出来。    \n \n![图片](https://images.smcdn.cn/a5tQGyNEcE0YgsvV/1D0C5DEC_39E0_47AA_84C5_577ACA9692CD.jpg!thumbnail)\n不要焦虑，不要鸡汤。最适合开始提高自己的时间，是昨天， 是去年，是十年前。其次是今天。\n\n\n\n\n","source":"_posts/index.md","raw":"---\ntitle:  Welcome My Friends，溪源的个人博客正式开业喽！\ndate: 2019-10-09 16:28\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n\n\n# 一、为啥要开独立博客\n之前注册的便宜的个人博客的域名techq.xyz注册了快一年了，已经到了要续费的日期了，为了让这点小钱能产生价值，我觉得还是有必要开一个独立博客，以后把博客园里分享的那些博客再一篇篇的迁移过来。  \n\n虽然坚持写了很久博客，感觉收获还不够多，这些博客也没啥干货，所以大家们能够关注，已经是莫大的荣幸了。值此个人独立博客开业之际，向大家表示诚挚的感谢。  \n\n立个flag，要开始每周写两篇了！  欢迎大家持续关注。请记住这个域名techq.xyz，溪源的技术小圆圈。每个人的知识领域，都是无穷个圆圈，越是打开这个圆圈，你的未知领域就会越大。\n\n\n\n# 二、引子  \n不知不觉，以每月最少一篇、每周一篇到两篇的频率开始写博客已经差不多坚持了一年，也算是个人一个小小的进步吧，虽然离那些一直在进步的朋友们差距越来越大，但我觉得长期坚持下去至少会比以前的自己更优秀，这就已经是一种进步了。      \n\n![图片](https://images.smcdn.cn/GNl9d8F1UwcQ1f1b/IMG_0215.JPG!thumbnail)\n# 三、写博客的好处、坏处  \n写博客是对每个人来说都有成长的过程，既可以用来总结方法，又可以总结经验教训，也能够实现个人表达能力和文笔的提升，写博客也是在强迫自己输出，如果没有稳定的输入，如何能够稳定的输出，所以也同样是在逼自己输入。    \n\n写博客能真正有机会认识行业内的专家，但是这仅仅是入门的第一步，认识他们并不是你的人脉，没有持续的成长，其实不过是个陌路人而已。      \n\n偶尔写几篇博客被人欣赏，这不一定是在欣赏你，而是文章中的一点点亮点，他们看到了，点个赞而已。只有长期输出，才或许有机会真正能够获得别人的认可，成为专家们的圈中人。      \n\n写博客也能把社区拉起来。但是，这些并不是真正意义上的技术社区，大概率只是小圈子而已，一群人，有话聊而已，像中生代技术社区那样，才算一个真正的社区。有时看似打造了一个个圈子，建了几个群，搞了几次所谓社区活动，就容易孤芳自赏，以为获得了一点点资源，打造了一点点人脉，其实并非如此。那么多群，究竟有几个搞正事的群？  \n\n>真正有本身的人都在不停的学习。 群只是分享他们学习收获的媒介而已。\n\n张爱玲是这么说的：\n>下大雨，有人打着伞，有人没带伞。没伞的挨着有伞的，钻到伞底下去躲雨，多少有点掩蔽，可是伞的边缘滔滔流下水来，反而比外面的雨更来得凶。挤在伞沿下的人，头上游得稀湿。\n\n当然，这句话是说穷人结交富人，往往会得不偿失，实际上通过所谓即时通讯工具认识一些大佬，大体上也是一样的。跟别人共伞，他人的伞短期能让你避雨。你看似能获得许多收获，其实那大概率只是虚幻，这是别人的，不是自己的。\n\n基于即时通讯打造的群，容易让人沉迷，而事实上沉迷于所谓群聊，不过是新时代的菜市场扯淡，你以为你在闹中求静，其实是在自我安慰。      \n\n资源看似很有价值，如果不是资源运作的大佬，几乎不可能依托这样的资源创造价值。所以那些所谓资源，不过是萍水相逢的网友，有时试图靠认识大佬来提升自己，其实不过是美好的幻想。  \n  \n也不用以为认识个别大佬就自以为是，以为自己成为了世人瞩目的焦点，那也是幻想而已。别总幻想靠别人来证明自己的价值，靠别人早晚无人可靠。人生漫漫长路，只有靠自己积极进取，才能真正脱离危机。在这个时代，看起来充满了机遇、挑战、失败和未知，有人成功，有人沉沦，每个人都与众不同，其实每个人都在打造自己的品牌，每个人都是独有的品牌。  \n\n![图片](https://uploader.shimo.im/f/T4kztYsKgIM3pOF3.jpeg!thumbnail)\n\n# 四、写哪些内容  \n当你打算写某个方向的博客时，可能会遇到阻塞，这恰好说明你对这个方向还不够熟悉；就如当你遇到问题束手无策时，正说明了你还不够专业。如果熟悉或专业，做事情其实都会水到渠成，迎刃而解。\n\n每一个你认为很普通的点，其实都有着充分的意义，都可以成为一个专业方向。例如需求工程、人际沟通、技术语言、消息队列、数据存储，都同样如此，唯有认真去学习、去总结，才能真正把握真谛，真正成为专家。    \n\n敢不敢在一个最简单的事情，如撸一段简单代码上每天练习五分钟，坚持五年？毋庸置疑，事实上无需五年，哪怕一周都会有巨大收获，这样一定都能更大程度上促进你的代码领悟力。而那些专家们，他们正是这样培养出来的思维方式和方法，他们坚持了十几年，才带来了今天的收获。      \n\n每个人的每个阶段都会有许多成长，遇到未知的问题，并解决问题，这就是在成长，但是如果没有总结，也许问题就会这么错过，直到下一次再出现，但是，中年人的每一次问题解决都充满意义，下一次再犯同类错误就应该打板子了。通过博客来总结这些问题，实际上是在记录错题本，让自己的经验教训库更加完善。  \n\n![图片](https://uploader.shimo.im/f/XeT4iD8JSxACjCal.png!thumbnail)\n# 五、展望\n每天都是一个小进步，每月都有进步，每年都可以有大进步，明年再来看看，这一年成长了多少？    \n\n不必苛求一天成长，不必总想着别人怎么怎么厉害，那些标杆都是一个个同样平凡的个体，经历了多年的积累才能成就今天的优秀，天赋固然重要，但是后天的积累才更有价值。    \n\n刘未鹏从18岁开始写博客，每天写一篇，才有今天的《暗世界》；熊节大佬从20几岁开始稳定输出，靠着普通的学历，成就今天的不凡。他们今天的优秀，难道是上天的眷顾么？从来不是，都是自己后天的努力，才有今天的收获。    \n\n努力使自己有进步，只需比之前的自己更努力，更优秀，就是一种成长。    \n\n每天总结三遍，我今天收获了什么？我今天收获了什么？我今天收获了什么？    \n\n让自己的成长像猪肉一般实体化，价值才真正的随时随地可以体现出来。    \n \n![图片](https://images.smcdn.cn/a5tQGyNEcE0YgsvV/1D0C5DEC_39E0_47AA_84C5_577ACA9692CD.jpg!thumbnail)\n不要焦虑，不要鸡汤。最适合开始提高自己的时间，是昨天， 是去年，是十年前。其次是今天。\n\n\n\n\n","slug":"index","published":1,"updated":"2019-10-09T11:13:26.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt2w0000n4vijybrfdfp","content":"<h1 id=\"一、为啥要开独立博客\"><a href=\"#一、为啥要开独立博客\" class=\"headerlink\" title=\"一、为啥要开独立博客\"></a>一、为啥要开独立博客</h1><p>之前注册的便宜的个人博客的域名techq.xyz注册了快一年了，已经到了要续费的日期了，为了让这点小钱能产生价值，我觉得还是有必要开一个独立博客，以后把博客园里分享的那些博客再一篇篇的迁移过来。  </p>\n<p>虽然坚持写了很久博客，感觉收获还不够多，这些博客也没啥干货，所以大家们能够关注，已经是莫大的荣幸了。值此个人独立博客开业之际，向大家表示诚挚的感谢。  </p>\n<p>立个flag，要开始每周写两篇了！  欢迎大家持续关注。请记住这个域名techq.xyz，溪源的技术小圆圈。每个人的知识领域，都是无穷个圆圈，越是打开这个圆圈，你的未知领域就会越大。</p>\n<h1 id=\"二、引子\"><a href=\"#二、引子\" class=\"headerlink\" title=\"二、引子\"></a>二、引子</h1><p>不知不觉，以每月最少一篇、每周一篇到两篇的频率开始写博客已经差不多坚持了一年，也算是个人一个小小的进步吧，虽然离那些一直在进步的朋友们差距越来越大，但我觉得长期坚持下去至少会比以前的自己更优秀，这就已经是一种进步了。      </p>\n<p><img src=\"https://images.smcdn.cn/GNl9d8F1UwcQ1f1b/IMG_0215.JPG!thumbnail\" alt=\"图片\"></p>\n<h1 id=\"三、写博客的好处、坏处\"><a href=\"#三、写博客的好处、坏处\" class=\"headerlink\" title=\"三、写博客的好处、坏处\"></a>三、写博客的好处、坏处</h1><p>写博客是对每个人来说都有成长的过程，既可以用来总结方法，又可以总结经验教训，也能够实现个人表达能力和文笔的提升，写博客也是在强迫自己输出，如果没有稳定的输入，如何能够稳定的输出，所以也同样是在逼自己输入。    </p>\n<p>写博客能真正有机会认识行业内的专家，但是这仅仅是入门的第一步，认识他们并不是你的人脉，没有持续的成长，其实不过是个陌路人而已。      </p>\n<p>偶尔写几篇博客被人欣赏，这不一定是在欣赏你，而是文章中的一点点亮点，他们看到了，点个赞而已。只有长期输出，才或许有机会真正能够获得别人的认可，成为专家们的圈中人。      </p>\n<p>写博客也能把社区拉起来。但是，这些并不是真正意义上的技术社区，大概率只是小圈子而已，一群人，有话聊而已，像中生代技术社区那样，才算一个真正的社区。有时看似打造了一个个圈子，建了几个群，搞了几次所谓社区活动，就容易孤芳自赏，以为获得了一点点资源，打造了一点点人脉，其实并非如此。那么多群，究竟有几个搞正事的群？  </p>\n<blockquote>\n<p>真正有本身的人都在不停的学习。 群只是分享他们学习收获的媒介而已。</p>\n</blockquote>\n<p>张爱玲是这么说的：</p>\n<blockquote>\n<p>下大雨，有人打着伞，有人没带伞。没伞的挨着有伞的，钻到伞底下去躲雨，多少有点掩蔽，可是伞的边缘滔滔流下水来，反而比外面的雨更来得凶。挤在伞沿下的人，头上游得稀湿。</p>\n</blockquote>\n<p>当然，这句话是说穷人结交富人，往往会得不偿失，实际上通过所谓即时通讯工具认识一些大佬，大体上也是一样的。跟别人共伞，他人的伞短期能让你避雨。你看似能获得许多收获，其实那大概率只是虚幻，这是别人的，不是自己的。</p>\n<p>基于即时通讯打造的群，容易让人沉迷，而事实上沉迷于所谓群聊，不过是新时代的菜市场扯淡，你以为你在闹中求静，其实是在自我安慰。      </p>\n<p>资源看似很有价值，如果不是资源运作的大佬，几乎不可能依托这样的资源创造价值。所以那些所谓资源，不过是萍水相逢的网友，有时试图靠认识大佬来提升自己，其实不过是美好的幻想。  </p>\n<p>也不用以为认识个别大佬就自以为是，以为自己成为了世人瞩目的焦点，那也是幻想而已。别总幻想靠别人来证明自己的价值，靠别人早晚无人可靠。人生漫漫长路，只有靠自己积极进取，才能真正脱离危机。在这个时代，看起来充满了机遇、挑战、失败和未知，有人成功，有人沉沦，每个人都与众不同，其实每个人都在打造自己的品牌，每个人都是独有的品牌。  </p>\n<p><img src=\"https://uploader.shimo.im/f/T4kztYsKgIM3pOF3.jpeg!thumbnail\" alt=\"图片\"></p>\n<h1 id=\"四、写哪些内容\"><a href=\"#四、写哪些内容\" class=\"headerlink\" title=\"四、写哪些内容\"></a>四、写哪些内容</h1><p>当你打算写某个方向的博客时，可能会遇到阻塞，这恰好说明你对这个方向还不够熟悉；就如当你遇到问题束手无策时，正说明了你还不够专业。如果熟悉或专业，做事情其实都会水到渠成，迎刃而解。</p>\n<p>每一个你认为很普通的点，其实都有着充分的意义，都可以成为一个专业方向。例如需求工程、人际沟通、技术语言、消息队列、数据存储，都同样如此，唯有认真去学习、去总结，才能真正把握真谛，真正成为专家。    </p>\n<p>敢不敢在一个最简单的事情，如撸一段简单代码上每天练习五分钟，坚持五年？毋庸置疑，事实上无需五年，哪怕一周都会有巨大收获，这样一定都能更大程度上促进你的代码领悟力。而那些专家们，他们正是这样培养出来的思维方式和方法，他们坚持了十几年，才带来了今天的收获。      </p>\n<p>每个人的每个阶段都会有许多成长，遇到未知的问题，并解决问题，这就是在成长，但是如果没有总结，也许问题就会这么错过，直到下一次再出现，但是，中年人的每一次问题解决都充满意义，下一次再犯同类错误就应该打板子了。通过博客来总结这些问题，实际上是在记录错题本，让自己的经验教训库更加完善。  </p>\n<p><img src=\"https://uploader.shimo.im/f/XeT4iD8JSxACjCal.png!thumbnail\" alt=\"图片\"></p>\n<h1 id=\"五、展望\"><a href=\"#五、展望\" class=\"headerlink\" title=\"五、展望\"></a>五、展望</h1><p>每天都是一个小进步，每月都有进步，每年都可以有大进步，明年再来看看，这一年成长了多少？    </p>\n<p>不必苛求一天成长，不必总想着别人怎么怎么厉害，那些标杆都是一个个同样平凡的个体，经历了多年的积累才能成就今天的优秀，天赋固然重要，但是后天的积累才更有价值。    </p>\n<p>刘未鹏从18岁开始写博客，每天写一篇，才有今天的《暗世界》；熊节大佬从20几岁开始稳定输出，靠着普通的学历，成就今天的不凡。他们今天的优秀，难道是上天的眷顾么？从来不是，都是自己后天的努力，才有今天的收获。    </p>\n<p>努力使自己有进步，只需比之前的自己更努力，更优秀，就是一种成长。    </p>\n<p>每天总结三遍，我今天收获了什么？我今天收获了什么？我今天收获了什么？    </p>\n<p>让自己的成长像猪肉一般实体化，价值才真正的随时随地可以体现出来。    </p>\n<p><img src=\"https://images.smcdn.cn/a5tQGyNEcE0YgsvV/1D0C5DEC_39E0_47AA_84C5_577ACA9692CD.jpg!thumbnail\" alt=\"图片\"><br>不要焦虑，不要鸡汤。最适合开始提高自己的时间，是昨天， 是去年，是十年前。其次是今天。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、为啥要开独立博客\"><a href=\"#一、为啥要开独立博客\" class=\"headerlink\" title=\"一、为啥要开独立博客\"></a>一、为啥要开独立博客</h1><p>之前注册的便宜的个人博客的域名techq.xyz注册了快一年了，已经到了要续费的日期了，为了让这点小钱能产生价值，我觉得还是有必要开一个独立博客，以后把博客园里分享的那些博客再一篇篇的迁移过来。  </p>\n<p>虽然坚持写了很久博客，感觉收获还不够多，这些博客也没啥干货，所以大家们能够关注，已经是莫大的荣幸了。值此个人独立博客开业之际，向大家表示诚挚的感谢。  </p>\n<p>立个flag，要开始每周写两篇了！  欢迎大家持续关注。请记住这个域名techq.xyz，溪源的技术小圆圈。每个人的知识领域，都是无穷个圆圈，越是打开这个圆圈，你的未知领域就会越大。</p>\n<h1 id=\"二、引子\"><a href=\"#二、引子\" class=\"headerlink\" title=\"二、引子\"></a>二、引子</h1><p>不知不觉，以每月最少一篇、每周一篇到两篇的频率开始写博客已经差不多坚持了一年，也算是个人一个小小的进步吧，虽然离那些一直在进步的朋友们差距越来越大，但我觉得长期坚持下去至少会比以前的自己更优秀，这就已经是一种进步了。      </p>\n<p><img src=\"https://images.smcdn.cn/GNl9d8F1UwcQ1f1b/IMG_0215.JPG!thumbnail\" alt=\"图片\"></p>\n<h1 id=\"三、写博客的好处、坏处\"><a href=\"#三、写博客的好处、坏处\" class=\"headerlink\" title=\"三、写博客的好处、坏处\"></a>三、写博客的好处、坏处</h1><p>写博客是对每个人来说都有成长的过程，既可以用来总结方法，又可以总结经验教训，也能够实现个人表达能力和文笔的提升，写博客也是在强迫自己输出，如果没有稳定的输入，如何能够稳定的输出，所以也同样是在逼自己输入。    </p>\n<p>写博客能真正有机会认识行业内的专家，但是这仅仅是入门的第一步，认识他们并不是你的人脉，没有持续的成长，其实不过是个陌路人而已。      </p>\n<p>偶尔写几篇博客被人欣赏，这不一定是在欣赏你，而是文章中的一点点亮点，他们看到了，点个赞而已。只有长期输出，才或许有机会真正能够获得别人的认可，成为专家们的圈中人。      </p>\n<p>写博客也能把社区拉起来。但是，这些并不是真正意义上的技术社区，大概率只是小圈子而已，一群人，有话聊而已，像中生代技术社区那样，才算一个真正的社区。有时看似打造了一个个圈子，建了几个群，搞了几次所谓社区活动，就容易孤芳自赏，以为获得了一点点资源，打造了一点点人脉，其实并非如此。那么多群，究竟有几个搞正事的群？  </p>\n<blockquote>\n<p>真正有本身的人都在不停的学习。 群只是分享他们学习收获的媒介而已。</p>\n</blockquote>\n<p>张爱玲是这么说的：</p>\n<blockquote>\n<p>下大雨，有人打着伞，有人没带伞。没伞的挨着有伞的，钻到伞底下去躲雨，多少有点掩蔽，可是伞的边缘滔滔流下水来，反而比外面的雨更来得凶。挤在伞沿下的人，头上游得稀湿。</p>\n</blockquote>\n<p>当然，这句话是说穷人结交富人，往往会得不偿失，实际上通过所谓即时通讯工具认识一些大佬，大体上也是一样的。跟别人共伞，他人的伞短期能让你避雨。你看似能获得许多收获，其实那大概率只是虚幻，这是别人的，不是自己的。</p>\n<p>基于即时通讯打造的群，容易让人沉迷，而事实上沉迷于所谓群聊，不过是新时代的菜市场扯淡，你以为你在闹中求静，其实是在自我安慰。      </p>\n<p>资源看似很有价值，如果不是资源运作的大佬，几乎不可能依托这样的资源创造价值。所以那些所谓资源，不过是萍水相逢的网友，有时试图靠认识大佬来提升自己，其实不过是美好的幻想。  </p>\n<p>也不用以为认识个别大佬就自以为是，以为自己成为了世人瞩目的焦点，那也是幻想而已。别总幻想靠别人来证明自己的价值，靠别人早晚无人可靠。人生漫漫长路，只有靠自己积极进取，才能真正脱离危机。在这个时代，看起来充满了机遇、挑战、失败和未知，有人成功，有人沉沦，每个人都与众不同，其实每个人都在打造自己的品牌，每个人都是独有的品牌。  </p>\n<p><img src=\"https://uploader.shimo.im/f/T4kztYsKgIM3pOF3.jpeg!thumbnail\" alt=\"图片\"></p>\n<h1 id=\"四、写哪些内容\"><a href=\"#四、写哪些内容\" class=\"headerlink\" title=\"四、写哪些内容\"></a>四、写哪些内容</h1><p>当你打算写某个方向的博客时，可能会遇到阻塞，这恰好说明你对这个方向还不够熟悉；就如当你遇到问题束手无策时，正说明了你还不够专业。如果熟悉或专业，做事情其实都会水到渠成，迎刃而解。</p>\n<p>每一个你认为很普通的点，其实都有着充分的意义，都可以成为一个专业方向。例如需求工程、人际沟通、技术语言、消息队列、数据存储，都同样如此，唯有认真去学习、去总结，才能真正把握真谛，真正成为专家。    </p>\n<p>敢不敢在一个最简单的事情，如撸一段简单代码上每天练习五分钟，坚持五年？毋庸置疑，事实上无需五年，哪怕一周都会有巨大收获，这样一定都能更大程度上促进你的代码领悟力。而那些专家们，他们正是这样培养出来的思维方式和方法，他们坚持了十几年，才带来了今天的收获。      </p>\n<p>每个人的每个阶段都会有许多成长，遇到未知的问题，并解决问题，这就是在成长，但是如果没有总结，也许问题就会这么错过，直到下一次再出现，但是，中年人的每一次问题解决都充满意义，下一次再犯同类错误就应该打板子了。通过博客来总结这些问题，实际上是在记录错题本，让自己的经验教训库更加完善。  </p>\n<p><img src=\"https://uploader.shimo.im/f/XeT4iD8JSxACjCal.png!thumbnail\" alt=\"图片\"></p>\n<h1 id=\"五、展望\"><a href=\"#五、展望\" class=\"headerlink\" title=\"五、展望\"></a>五、展望</h1><p>每天都是一个小进步，每月都有进步，每年都可以有大进步，明年再来看看，这一年成长了多少？    </p>\n<p>不必苛求一天成长，不必总想着别人怎么怎么厉害，那些标杆都是一个个同样平凡的个体，经历了多年的积累才能成就今天的优秀，天赋固然重要，但是后天的积累才更有价值。    </p>\n<p>刘未鹏从18岁开始写博客，每天写一篇，才有今天的《暗世界》；熊节大佬从20几岁开始稳定输出，靠着普通的学历，成就今天的不凡。他们今天的优秀，难道是上天的眷顾么？从来不是，都是自己后天的努力，才有今天的收获。    </p>\n<p>努力使自己有进步，只需比之前的自己更努力，更优秀，就是一种成长。    </p>\n<p>每天总结三遍，我今天收获了什么？我今天收获了什么？我今天收获了什么？    </p>\n<p>让自己的成长像猪肉一般实体化，价值才真正的随时随地可以体现出来。    </p>\n<p><img src=\"https://images.smcdn.cn/a5tQGyNEcE0YgsvV/1D0C5DEC_39E0_47AA_84C5_577ACA9692CD.jpg!thumbnail\" alt=\"图片\"><br>不要焦虑，不要鸡汤。最适合开始提高自己的时间，是昨天， 是去年，是十年前。其次是今天。</p>\n"},{"title":"C＃提升性能的几点提示和技巧","date":"2020-05-28T12:05:00.000Z","author":"邹溪源","_content":"# C＃性能提示和技巧\n\n在[Raygun](https://raygun.com/)，我们是一群非常懂多种语言的开发人员。Raygun的各个部分使用不同的语言和框架编写-最好的工作方式。\n\n鉴于大量的C＃和我们正在处理的数据的爆炸性增长，在不同的时间需要进行一些优化工作。大部分重大的收获往往来自于真正地重新思考问题并从全新的角度解决问题。\n\n今天我想分享一些C＃性能技巧，这些技巧对我的最新工作有所帮助。其中一些功能在你看来也许相当微不足道，因此请不要在这里充电并使用所有功能。就这样，提示1是…\n\n## 1.每个开发人员都应使用分析器\n\n有一些很棒的.NET分析器。我个人使用了[Jet Brains](https://www.jetbrains.com/)团队的dotTrace分析器。我知道我们团队中的Jason 也从[Red Gate分析器中](http://www.red-gate.com/products/dotnet-development/ants-performance-profiler/)获得了很多价值。每个开发人员都应安装**并使用**探查器。\n\n我无法数出我**认为**应用程序的最慢部分在一个区域中的次数，而实际上却完全在其他地方。探查器对此提供了帮助。此外，有时候，它可以帮助我发现错误-缓慢的部分之所以缓慢，只是因为它做错了什么（单元测试*没有*正确地拾取它）。\n\n这是您要执行的所有优化工作的第一步，也是有效的第一步。\n\n ![冲刺开始](https://raygun.com/blog/images/c-sharp-performance/image1.jpg) \n\n## 2.级别越高，速度越慢（通常）\n\n这只是我闻到的气味。您使用的抽象级别越高，通常越慢。我在这里发现的一个常见示例是在代码繁忙的部分（也许在循环中被称为数百万次）中使用LINQ。LINQ非常适合快速表达某些内容，而这些内容可能要花一堆代码，但是您通常会将性能留在桌面上。\n\n不要误会我的意思-LINQ非常适合让您开发出可运行的应用程序。但是在代码库中以性能为中心的部分中，您可能会付出太多。特别是因为将这么多操作链接在一起非常容易。\n\n我所使用的特定示例是我使用的地方`.SelectMany().Distinct().Count()`。鉴于这被称为数千万次（由我的探查器发现的关键热点），它正在累积大量的运行时间。我采用了另一种方法，并将执行时间减少了几个数量级。\n\n## 3.不要低估发行版和调试版\n\n我一直在努力工作，对获得的性能感到非常满意。然后，我意识到自己已经在Visual Studio中进行了所有测试（我经常将性能测试编写为也可以作为单元测试运行，因此我可以更轻松地运行自己关心的部分）。我们都知道发行版本已启用优化。\n\n因此，我做了一个发布版本，称为从控制台应用程序测试的方法。\n\n我对此有了很大的转变。我的代码已经疯狂地进行了优化，因此确实是时候对.NET JIT编译器进行一些微优化了。启用优化后，我的性能提高了约30％！这使我想起了我不久前在网上阅读的一个故事。\n\n![软盘的屏幕截图](https://raygun.com/blog/images/c-sharp-performance/image3.png)\n\n这是上世纪90年代的一个古老游戏编程故事，当时内存限制非常严格。在开发周期的后期，团队最终将耗尽内存，并开始考虑必须删除或降级哪些内容以适合可用的微小内存空间。资深开发人员根据他的经验就曾期望这样做，并在项目一开始就分配了1MB的内存和垃圾数据。然后，他节省了一天的时间，并删除了他在项目开始时立即分配的1MB内存，从而解决了问题！\n\n知道团队总是没有足够的空间，因为那里有可用的内存，就可以为团队提供他们所需要的东西，并按时发货。\n\n我为什么要分享这个？在性能方面类似–在调试模式下获得足够好的运行，并且您将在发行版本中获得一些“免费”性能。美好时光。\n\n## 4.看大局\n\n有一些很棒的算法。您多数不需要每天甚至每月都不用。但是，值得知道它们的存在。我经常进行研究后，就会发现一种更好的解决问题的方法。在编码之前进行研究的开发人员与在编写代码之前进行适当分析的开发人员的可能性差不多。我们喜欢代码，并且总是想直接进入IDE。\n\n此外，通常在查看性能问题时，我们过于专注于单个生产线或方法。这可能是一个错误–放眼全局，可以通过减少需要完成的工作来帮助您显着提高性能。\n\n## 5.内存位置很重要\n\n假设我们有一个数组数组。实际上是一张桌子，尺寸为3000×3000。我们要计算有多少个插槽的值大于零。\n\n问题–这两个中哪个更快？\n\n```C#\nfor (int i = 0; i < _map.Length; i++)\n{\n\tfor (int n = 0; n < _map.Length; n++)\n\t{\n  \t\tif (_map[i][n] > 0)\n  \t\t{\n    \t    result++;\n  \t\t}\n\t}\n}\nfor (int i = 0; i < _map.Length; i++)\n{\n\tfor (int n = 0; n < _map.Length; n++)\n\t{\n  \t\tif (_map[n][i] > 0)\n  \t\t{\n    \t    result++;\n  \t\t}\n\t}\n}\n```\n\n回答？第一个。 在我的测试中，此循环使性能提高了8倍！\n\n注意区别吗？这是我们遍历此数组数组的顺序（[i] [n]与[n] [i]）。即使我们从自己管理内存中抽象出来，内存局部性在.NET中的确很重要。\n\n就我而言，这种方法被称为数百万次（准确地说是数亿次），因此我可以从中获得的任何性能都获得了可观的胜利。再次感谢我经常使用的分析器，以确保我专注于正确的地方！\n\n## 6.减轻垃圾收集器的压力\n\nC＃/.NET具有垃圾回收功能。垃圾收集是确定哪些对象当前已过时并删除它们以释放内存中空间的过程。这意味着在C＃中，与C ++之类的语言不同，您不必手动维护不再有用的对象的删除，即可声明其在内存中的空间。相反，垃圾收集器（GC）处理所有这些，因此您不必这样做。\n\n> 问题是没有免费的午餐\n\n问题是没有免费的午餐。收集过程本身会导致性能下降，因此您实际上并不希望GC一直收集。那么如何避免这种情况呢？\n\n有[许多有用的技术可以避免对GC施加太大压力](https://michaelscodingspot.com/avoid-gc-pressure/)。在这里，我将只关注一个技巧：避免不必要的分配。这意味着要避免这样的事情：\n\n```C#\nList<Product> products = new List<Product>();\nproducts = productRepo.All();\n```\n\n第一行创建了一个完全无用的列表实例，因为下一行返回另一个实例并将其引用分配给变量。现在想象一下上面的两行是否在一个执行数千次的循环中？\n\n上面的代码可能看起来像一个愚蠢的示例，但是我已经在生产中看到了这样的代码，而不仅仅是一次。不要只关注示例本身，而要关注一般建议。除非确实需要，否则不要创建对象。\n\n由于GC在.NET中的工作方式（这是一个世代的GC流程），因此较旧的对象更有可能收集较新的对象。这意味着创建许多新的，短暂的对象可能会触发GC运行。\n\n## 7.不要使用空的析构函数\n\n标题说明了一切-请勿在类中添加空的析构函数。`Finalize`每个具有析构函数的类的条目都会添加到队列中。然后在调用析构函数时调用我们的老朋友GC来处理队列。空的析构函数意味着这一切都是徒劳的。\n\n请记住，就性能而言，GC执行并不便宜，正如我们已经提到的。不要不必要地导致GC工作。\n\n![盒子的屏幕截图](https://raygun.com/blog/images/c-sharp-performance/image5.jpg)\n\n## 8.避免不必要的装箱和拆箱\n\n装箱和拆箱就像垃圾回收一样，在性能方面很昂贵。因此，我们希望避免不必要地进行操作。但是他们在实践中会做什么？\n\n装箱就像创建引用类型框并将值类型的值放入其中一样。换句话说，它包括将值类型转换为“对象”或该值类型实现的接口类型。取消装箱相反，它会打开包装盒并从其中提取值类型。为什么会有问题呢？\n\n好吧，正如我们已经提到的，装箱和拆箱本身就是昂贵的过程。除此之外，当您装箱一个值时，您会在堆上创建另一个对象，这给GC带来了额外的压力（您已经猜到了！）。\n\n那么，如何避免装箱和拆箱呢？\n\n通常，您可以通过避免.NET（版本1.0）中早于泛型的API来做到这一点，因此，它们必须依赖于使用对象类型。例如，更喜欢通用集合，例如`System.Collections.Generic.List`，而不是`System.Collections.ArrayList`。\n\n## 9.当心字符串连接\n\n在C＃/。NET中，字符串是不可变的。因此，每次执行一些看起来好像在更改字符串的操作时，它们都会创建一个新的字符串。这些操作包括类似的方法`Replace`和`Substring`，同时也串联。\n\n> 提防串联大量字符串，尤其是在循环内部\n\n因此，这里的技巧很简单-注意不要串联大量字符串，尤其是在循环内部。在这种情况下，请使用`System.Text.StringBuilder`类，而不要使用“ +”运算符。这样可以确保不会为连接的每个部分创建新实例。\n\n## 10.随时关注C＃的发展\n\n最后，我们以非常笼统的建议作为结尾-请密切关注C＃语言的更改和发展方式。C＃团队不断提供可以对性能产生积极影响的新功能。\n\n我们可以提到的一个最新示例是C＃7中引入的[ref](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/ref-returns) return [和ref locals](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/ref-returns)。这些新功能允许开发人员按引用返回并将引用存储在局部变量中。C＃7.2引入了[Span](https://docs.microsoft.com/en-us/dotnet/api/system.span-1?view=netcore-3.0) 类型，从而可以对内存的连续区域进行类型安全的访问。\n\n诸如此类的新功能和类型不太可能被大多数C＃开发人员使用，但是它们无疑会对性能至关重要的应用程序产生影响，值得进一步了解。\n\n## C＃性能很重要！\n\n这只是我发现对提高.NET代码性能有用的几件事的集合-但是值得花时间检查代码以确保其性能。您的团队和客户将感谢您！\n\n","source":"_posts/技术/C＃性能提示和技巧.md","raw":"---\ntitle:  C＃提升性能的几点提示和技巧\ndate: 2020-5-28 20:05\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n# C＃性能提示和技巧\n\n在[Raygun](https://raygun.com/)，我们是一群非常懂多种语言的开发人员。Raygun的各个部分使用不同的语言和框架编写-最好的工作方式。\n\n鉴于大量的C＃和我们正在处理的数据的爆炸性增长，在不同的时间需要进行一些优化工作。大部分重大的收获往往来自于真正地重新思考问题并从全新的角度解决问题。\n\n今天我想分享一些C＃性能技巧，这些技巧对我的最新工作有所帮助。其中一些功能在你看来也许相当微不足道，因此请不要在这里充电并使用所有功能。就这样，提示1是…\n\n## 1.每个开发人员都应使用分析器\n\n有一些很棒的.NET分析器。我个人使用了[Jet Brains](https://www.jetbrains.com/)团队的dotTrace分析器。我知道我们团队中的Jason 也从[Red Gate分析器中](http://www.red-gate.com/products/dotnet-development/ants-performance-profiler/)获得了很多价值。每个开发人员都应安装**并使用**探查器。\n\n我无法数出我**认为**应用程序的最慢部分在一个区域中的次数，而实际上却完全在其他地方。探查器对此提供了帮助。此外，有时候，它可以帮助我发现错误-缓慢的部分之所以缓慢，只是因为它做错了什么（单元测试*没有*正确地拾取它）。\n\n这是您要执行的所有优化工作的第一步，也是有效的第一步。\n\n ![冲刺开始](https://raygun.com/blog/images/c-sharp-performance/image1.jpg) \n\n## 2.级别越高，速度越慢（通常）\n\n这只是我闻到的气味。您使用的抽象级别越高，通常越慢。我在这里发现的一个常见示例是在代码繁忙的部分（也许在循环中被称为数百万次）中使用LINQ。LINQ非常适合快速表达某些内容，而这些内容可能要花一堆代码，但是您通常会将性能留在桌面上。\n\n不要误会我的意思-LINQ非常适合让您开发出可运行的应用程序。但是在代码库中以性能为中心的部分中，您可能会付出太多。特别是因为将这么多操作链接在一起非常容易。\n\n我所使用的特定示例是我使用的地方`.SelectMany().Distinct().Count()`。鉴于这被称为数千万次（由我的探查器发现的关键热点），它正在累积大量的运行时间。我采用了另一种方法，并将执行时间减少了几个数量级。\n\n## 3.不要低估发行版和调试版\n\n我一直在努力工作，对获得的性能感到非常满意。然后，我意识到自己已经在Visual Studio中进行了所有测试（我经常将性能测试编写为也可以作为单元测试运行，因此我可以更轻松地运行自己关心的部分）。我们都知道发行版本已启用优化。\n\n因此，我做了一个发布版本，称为从控制台应用程序测试的方法。\n\n我对此有了很大的转变。我的代码已经疯狂地进行了优化，因此确实是时候对.NET JIT编译器进行一些微优化了。启用优化后，我的性能提高了约30％！这使我想起了我不久前在网上阅读的一个故事。\n\n![软盘的屏幕截图](https://raygun.com/blog/images/c-sharp-performance/image3.png)\n\n这是上世纪90年代的一个古老游戏编程故事，当时内存限制非常严格。在开发周期的后期，团队最终将耗尽内存，并开始考虑必须删除或降级哪些内容以适合可用的微小内存空间。资深开发人员根据他的经验就曾期望这样做，并在项目一开始就分配了1MB的内存和垃圾数据。然后，他节省了一天的时间，并删除了他在项目开始时立即分配的1MB内存，从而解决了问题！\n\n知道团队总是没有足够的空间，因为那里有可用的内存，就可以为团队提供他们所需要的东西，并按时发货。\n\n我为什么要分享这个？在性能方面类似–在调试模式下获得足够好的运行，并且您将在发行版本中获得一些“免费”性能。美好时光。\n\n## 4.看大局\n\n有一些很棒的算法。您多数不需要每天甚至每月都不用。但是，值得知道它们的存在。我经常进行研究后，就会发现一种更好的解决问题的方法。在编码之前进行研究的开发人员与在编写代码之前进行适当分析的开发人员的可能性差不多。我们喜欢代码，并且总是想直接进入IDE。\n\n此外，通常在查看性能问题时，我们过于专注于单个生产线或方法。这可能是一个错误–放眼全局，可以通过减少需要完成的工作来帮助您显着提高性能。\n\n## 5.内存位置很重要\n\n假设我们有一个数组数组。实际上是一张桌子，尺寸为3000×3000。我们要计算有多少个插槽的值大于零。\n\n问题–这两个中哪个更快？\n\n```C#\nfor (int i = 0; i < _map.Length; i++)\n{\n\tfor (int n = 0; n < _map.Length; n++)\n\t{\n  \t\tif (_map[i][n] > 0)\n  \t\t{\n    \t    result++;\n  \t\t}\n\t}\n}\nfor (int i = 0; i < _map.Length; i++)\n{\n\tfor (int n = 0; n < _map.Length; n++)\n\t{\n  \t\tif (_map[n][i] > 0)\n  \t\t{\n    \t    result++;\n  \t\t}\n\t}\n}\n```\n\n回答？第一个。 在我的测试中，此循环使性能提高了8倍！\n\n注意区别吗？这是我们遍历此数组数组的顺序（[i] [n]与[n] [i]）。即使我们从自己管理内存中抽象出来，内存局部性在.NET中的确很重要。\n\n就我而言，这种方法被称为数百万次（准确地说是数亿次），因此我可以从中获得的任何性能都获得了可观的胜利。再次感谢我经常使用的分析器，以确保我专注于正确的地方！\n\n## 6.减轻垃圾收集器的压力\n\nC＃/.NET具有垃圾回收功能。垃圾收集是确定哪些对象当前已过时并删除它们以释放内存中空间的过程。这意味着在C＃中，与C ++之类的语言不同，您不必手动维护不再有用的对象的删除，即可声明其在内存中的空间。相反，垃圾收集器（GC）处理所有这些，因此您不必这样做。\n\n> 问题是没有免费的午餐\n\n问题是没有免费的午餐。收集过程本身会导致性能下降，因此您实际上并不希望GC一直收集。那么如何避免这种情况呢？\n\n有[许多有用的技术可以避免对GC施加太大压力](https://michaelscodingspot.com/avoid-gc-pressure/)。在这里，我将只关注一个技巧：避免不必要的分配。这意味着要避免这样的事情：\n\n```C#\nList<Product> products = new List<Product>();\nproducts = productRepo.All();\n```\n\n第一行创建了一个完全无用的列表实例，因为下一行返回另一个实例并将其引用分配给变量。现在想象一下上面的两行是否在一个执行数千次的循环中？\n\n上面的代码可能看起来像一个愚蠢的示例，但是我已经在生产中看到了这样的代码，而不仅仅是一次。不要只关注示例本身，而要关注一般建议。除非确实需要，否则不要创建对象。\n\n由于GC在.NET中的工作方式（这是一个世代的GC流程），因此较旧的对象更有可能收集较新的对象。这意味着创建许多新的，短暂的对象可能会触发GC运行。\n\n## 7.不要使用空的析构函数\n\n标题说明了一切-请勿在类中添加空的析构函数。`Finalize`每个具有析构函数的类的条目都会添加到队列中。然后在调用析构函数时调用我们的老朋友GC来处理队列。空的析构函数意味着这一切都是徒劳的。\n\n请记住，就性能而言，GC执行并不便宜，正如我们已经提到的。不要不必要地导致GC工作。\n\n![盒子的屏幕截图](https://raygun.com/blog/images/c-sharp-performance/image5.jpg)\n\n## 8.避免不必要的装箱和拆箱\n\n装箱和拆箱就像垃圾回收一样，在性能方面很昂贵。因此，我们希望避免不必要地进行操作。但是他们在实践中会做什么？\n\n装箱就像创建引用类型框并将值类型的值放入其中一样。换句话说，它包括将值类型转换为“对象”或该值类型实现的接口类型。取消装箱相反，它会打开包装盒并从其中提取值类型。为什么会有问题呢？\n\n好吧，正如我们已经提到的，装箱和拆箱本身就是昂贵的过程。除此之外，当您装箱一个值时，您会在堆上创建另一个对象，这给GC带来了额外的压力（您已经猜到了！）。\n\n那么，如何避免装箱和拆箱呢？\n\n通常，您可以通过避免.NET（版本1.0）中早于泛型的API来做到这一点，因此，它们必须依赖于使用对象类型。例如，更喜欢通用集合，例如`System.Collections.Generic.List`，而不是`System.Collections.ArrayList`。\n\n## 9.当心字符串连接\n\n在C＃/。NET中，字符串是不可变的。因此，每次执行一些看起来好像在更改字符串的操作时，它们都会创建一个新的字符串。这些操作包括类似的方法`Replace`和`Substring`，同时也串联。\n\n> 提防串联大量字符串，尤其是在循环内部\n\n因此，这里的技巧很简单-注意不要串联大量字符串，尤其是在循环内部。在这种情况下，请使用`System.Text.StringBuilder`类，而不要使用“ +”运算符。这样可以确保不会为连接的每个部分创建新实例。\n\n## 10.随时关注C＃的发展\n\n最后，我们以非常笼统的建议作为结尾-请密切关注C＃语言的更改和发展方式。C＃团队不断提供可以对性能产生积极影响的新功能。\n\n我们可以提到的一个最新示例是C＃7中引入的[ref](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/ref-returns) return [和ref locals](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/ref-returns)。这些新功能允许开发人员按引用返回并将引用存储在局部变量中。C＃7.2引入了[Span](https://docs.microsoft.com/en-us/dotnet/api/system.span-1?view=netcore-3.0) 类型，从而可以对内存的连续区域进行类型安全的访问。\n\n诸如此类的新功能和类型不太可能被大多数C＃开发人员使用，但是它们无疑会对性能至关重要的应用程序产生影响，值得进一步了解。\n\n## C＃性能很重要！\n\n这只是我发现对提高.NET代码性能有用的几件事的集合-但是值得花时间检查代码以确保其性能。您的团队和客户将感谢您！\n\n","slug":"技术/C＃性能提示和技巧","published":1,"updated":"2020-06-25T14:01:00.818Z","_id":"ckbuujt650004n4viv7u7c391","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"C＃性能提示和技巧\"><a href=\"#C＃性能提示和技巧\" class=\"headerlink\" title=\"C＃性能提示和技巧\"></a>C＃性能提示和技巧</h1><p>在<a href=\"https://raygun.com/\" target=\"_blank\" rel=\"noopener\">Raygun</a>，我们是一群非常懂多种语言的开发人员。Raygun的各个部分使用不同的语言和框架编写-最好的工作方式。</p>\n<p>鉴于大量的C＃和我们正在处理的数据的爆炸性增长，在不同的时间需要进行一些优化工作。大部分重大的收获往往来自于真正地重新思考问题并从全新的角度解决问题。</p>\n<p>今天我想分享一些C＃性能技巧，这些技巧对我的最新工作有所帮助。其中一些功能在你看来也许相当微不足道，因此请不要在这里充电并使用所有功能。就这样，提示1是…</p>\n<h2 id=\"1-每个开发人员都应使用分析器\"><a href=\"#1-每个开发人员都应使用分析器\" class=\"headerlink\" title=\"1.每个开发人员都应使用分析器\"></a>1.每个开发人员都应使用分析器</h2><p>有一些很棒的.NET分析器。我个人使用了<a href=\"https://www.jetbrains.com/\" target=\"_blank\" rel=\"noopener\">Jet Brains</a>团队的dotTrace分析器。我知道我们团队中的Jason 也从<a href=\"http://www.red-gate.com/products/dotnet-development/ants-performance-profiler/\" target=\"_blank\" rel=\"noopener\">Red Gate分析器中</a>获得了很多价值。每个开发人员都应安装<strong>并使用</strong>探查器。</p>\n<p>我无法数出我<strong>认为</strong>应用程序的最慢部分在一个区域中的次数，而实际上却完全在其他地方。探查器对此提供了帮助。此外，有时候，它可以帮助我发现错误-缓慢的部分之所以缓慢，只是因为它做错了什么（单元测试<em>没有</em>正确地拾取它）。</p>\n<p>这是您要执行的所有优化工作的第一步，也是有效的第一步。</p>\n<p> <img src=\"https://raygun.com/blog/images/c-sharp-performance/image1.jpg\" alt=\"冲刺开始\"> </p>\n<h2 id=\"2-级别越高，速度越慢（通常）\"><a href=\"#2-级别越高，速度越慢（通常）\" class=\"headerlink\" title=\"2.级别越高，速度越慢（通常）\"></a>2.级别越高，速度越慢（通常）</h2><p>这只是我闻到的气味。您使用的抽象级别越高，通常越慢。我在这里发现的一个常见示例是在代码繁忙的部分（也许在循环中被称为数百万次）中使用LINQ。LINQ非常适合快速表达某些内容，而这些内容可能要花一堆代码，但是您通常会将性能留在桌面上。</p>\n<p>不要误会我的意思-LINQ非常适合让您开发出可运行的应用程序。但是在代码库中以性能为中心的部分中，您可能会付出太多。特别是因为将这么多操作链接在一起非常容易。</p>\n<p>我所使用的特定示例是我使用的地方<code>.SelectMany().Distinct().Count()</code>。鉴于这被称为数千万次（由我的探查器发现的关键热点），它正在累积大量的运行时间。我采用了另一种方法，并将执行时间减少了几个数量级。</p>\n<h2 id=\"3-不要低估发行版和调试版\"><a href=\"#3-不要低估发行版和调试版\" class=\"headerlink\" title=\"3.不要低估发行版和调试版\"></a>3.不要低估发行版和调试版</h2><p>我一直在努力工作，对获得的性能感到非常满意。然后，我意识到自己已经在Visual Studio中进行了所有测试（我经常将性能测试编写为也可以作为单元测试运行，因此我可以更轻松地运行自己关心的部分）。我们都知道发行版本已启用优化。</p>\n<p>因此，我做了一个发布版本，称为从控制台应用程序测试的方法。</p>\n<p>我对此有了很大的转变。我的代码已经疯狂地进行了优化，因此确实是时候对.NET JIT编译器进行一些微优化了。启用优化后，我的性能提高了约30％！这使我想起了我不久前在网上阅读的一个故事。</p>\n<p><img src=\"https://raygun.com/blog/images/c-sharp-performance/image3.png\" alt=\"软盘的屏幕截图\"></p>\n<p>这是上世纪90年代的一个古老游戏编程故事，当时内存限制非常严格。在开发周期的后期，团队最终将耗尽内存，并开始考虑必须删除或降级哪些内容以适合可用的微小内存空间。资深开发人员根据他的经验就曾期望这样做，并在项目一开始就分配了1MB的内存和垃圾数据。然后，他节省了一天的时间，并删除了他在项目开始时立即分配的1MB内存，从而解决了问题！</p>\n<p>知道团队总是没有足够的空间，因为那里有可用的内存，就可以为团队提供他们所需要的东西，并按时发货。</p>\n<p>我为什么要分享这个？在性能方面类似–在调试模式下获得足够好的运行，并且您将在发行版本中获得一些“免费”性能。美好时光。</p>\n<h2 id=\"4-看大局\"><a href=\"#4-看大局\" class=\"headerlink\" title=\"4.看大局\"></a>4.看大局</h2><p>有一些很棒的算法。您多数不需要每天甚至每月都不用。但是，值得知道它们的存在。我经常进行研究后，就会发现一种更好的解决问题的方法。在编码之前进行研究的开发人员与在编写代码之前进行适当分析的开发人员的可能性差不多。我们喜欢代码，并且总是想直接进入IDE。</p>\n<p>此外，通常在查看性能问题时，我们过于专注于单个生产线或方法。这可能是一个错误–放眼全局，可以通过减少需要完成的工作来帮助您显着提高性能。</p>\n<h2 id=\"5-内存位置很重要\"><a href=\"#5-内存位置很重要\" class=\"headerlink\" title=\"5.内存位置很重要\"></a>5.内存位置很重要</h2><p>假设我们有一个数组数组。实际上是一张桌子，尺寸为3000×3000。我们要计算有多少个插槽的值大于零。</p>\n<p>问题–这两个中哪个更快？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 0; i &lt; _map.Length; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor (int n = 0; n &lt; _map.Length; n++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">  \t\tif (_map[i][n] &gt; 0)</span><br><span class=\"line\">  \t\t&#123;</span><br><span class=\"line\">    \t    result++;</span><br><span class=\"line\">  \t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for (int i = 0; i &lt; _map.Length; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor (int n = 0; n &lt; _map.Length; n++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">  \t\tif (_map[n][i] &gt; 0)</span><br><span class=\"line\">  \t\t&#123;</span><br><span class=\"line\">    \t    result++;</span><br><span class=\"line\">  \t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回答？第一个。 在我的测试中，此循环使性能提高了8倍！</p>\n<p>注意区别吗？这是我们遍历此数组数组的顺序（[i] [n]与[n] [i]）。即使我们从自己管理内存中抽象出来，内存局部性在.NET中的确很重要。</p>\n<p>就我而言，这种方法被称为数百万次（准确地说是数亿次），因此我可以从中获得的任何性能都获得了可观的胜利。再次感谢我经常使用的分析器，以确保我专注于正确的地方！</p>\n<h2 id=\"6-减轻垃圾收集器的压力\"><a href=\"#6-减轻垃圾收集器的压力\" class=\"headerlink\" title=\"6.减轻垃圾收集器的压力\"></a>6.减轻垃圾收集器的压力</h2><p>C＃/.NET具有垃圾回收功能。垃圾收集是确定哪些对象当前已过时并删除它们以释放内存中空间的过程。这意味着在C＃中，与C ++之类的语言不同，您不必手动维护不再有用的对象的删除，即可声明其在内存中的空间。相反，垃圾收集器（GC）处理所有这些，因此您不必这样做。</p>\n<blockquote>\n<p>问题是没有免费的午餐</p>\n</blockquote>\n<p>问题是没有免费的午餐。收集过程本身会导致性能下降，因此您实际上并不希望GC一直收集。那么如何避免这种情况呢？</p>\n<p>有<a href=\"https://michaelscodingspot.com/avoid-gc-pressure/\" target=\"_blank\" rel=\"noopener\">许多有用的技术可以避免对GC施加太大压力</a>。在这里，我将只关注一个技巧：避免不必要的分配。这意味着要避免这样的事情：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Product&gt; products = new List&lt;Product&gt;();</span><br><span class=\"line\">products = productRepo.All();</span><br></pre></td></tr></table></figure>\n\n<p>第一行创建了一个完全无用的列表实例，因为下一行返回另一个实例并将其引用分配给变量。现在想象一下上面的两行是否在一个执行数千次的循环中？</p>\n<p>上面的代码可能看起来像一个愚蠢的示例，但是我已经在生产中看到了这样的代码，而不仅仅是一次。不要只关注示例本身，而要关注一般建议。除非确实需要，否则不要创建对象。</p>\n<p>由于GC在.NET中的工作方式（这是一个世代的GC流程），因此较旧的对象更有可能收集较新的对象。这意味着创建许多新的，短暂的对象可能会触发GC运行。</p>\n<h2 id=\"7-不要使用空的析构函数\"><a href=\"#7-不要使用空的析构函数\" class=\"headerlink\" title=\"7.不要使用空的析构函数\"></a>7.不要使用空的析构函数</h2><p>标题说明了一切-请勿在类中添加空的析构函数。<code>Finalize</code>每个具有析构函数的类的条目都会添加到队列中。然后在调用析构函数时调用我们的老朋友GC来处理队列。空的析构函数意味着这一切都是徒劳的。</p>\n<p>请记住，就性能而言，GC执行并不便宜，正如我们已经提到的。不要不必要地导致GC工作。</p>\n<p><img src=\"https://raygun.com/blog/images/c-sharp-performance/image5.jpg\" alt=\"盒子的屏幕截图\"></p>\n<h2 id=\"8-避免不必要的装箱和拆箱\"><a href=\"#8-避免不必要的装箱和拆箱\" class=\"headerlink\" title=\"8.避免不必要的装箱和拆箱\"></a>8.避免不必要的装箱和拆箱</h2><p>装箱和拆箱就像垃圾回收一样，在性能方面很昂贵。因此，我们希望避免不必要地进行操作。但是他们在实践中会做什么？</p>\n<p>装箱就像创建引用类型框并将值类型的值放入其中一样。换句话说，它包括将值类型转换为“对象”或该值类型实现的接口类型。取消装箱相反，它会打开包装盒并从其中提取值类型。为什么会有问题呢？</p>\n<p>好吧，正如我们已经提到的，装箱和拆箱本身就是昂贵的过程。除此之外，当您装箱一个值时，您会在堆上创建另一个对象，这给GC带来了额外的压力（您已经猜到了！）。</p>\n<p>那么，如何避免装箱和拆箱呢？</p>\n<p>通常，您可以通过避免.NET（版本1.0）中早于泛型的API来做到这一点，因此，它们必须依赖于使用对象类型。例如，更喜欢通用集合，例如<code>System.Collections.Generic.List</code>，而不是<code>System.Collections.ArrayList</code>。</p>\n<h2 id=\"9-当心字符串连接\"><a href=\"#9-当心字符串连接\" class=\"headerlink\" title=\"9.当心字符串连接\"></a>9.当心字符串连接</h2><p>在C＃/。NET中，字符串是不可变的。因此，每次执行一些看起来好像在更改字符串的操作时，它们都会创建一个新的字符串。这些操作包括类似的方法<code>Replace</code>和<code>Substring</code>，同时也串联。</p>\n<blockquote>\n<p>提防串联大量字符串，尤其是在循环内部</p>\n</blockquote>\n<p>因此，这里的技巧很简单-注意不要串联大量字符串，尤其是在循环内部。在这种情况下，请使用<code>System.Text.StringBuilder</code>类，而不要使用“ +”运算符。这样可以确保不会为连接的每个部分创建新实例。</p>\n<h2 id=\"10-随时关注C＃的发展\"><a href=\"#10-随时关注C＃的发展\" class=\"headerlink\" title=\"10.随时关注C＃的发展\"></a>10.随时关注C＃的发展</h2><p>最后，我们以非常笼统的建议作为结尾-请密切关注C＃语言的更改和发展方式。C＃团队不断提供可以对性能产生积极影响的新功能。</p>\n<p>我们可以提到的一个最新示例是C＃7中引入的<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/ref-returns\" target=\"_blank\" rel=\"noopener\">ref</a> return <a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/ref-returns\" target=\"_blank\" rel=\"noopener\">和ref locals</a>。这些新功能允许开发人员按引用返回并将引用存储在局部变量中。C＃7.2引入了<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.span-1?view=netcore-3.0\" target=\"_blank\" rel=\"noopener\">Span</a> 类型，从而可以对内存的连续区域进行类型安全的访问。</p>\n<p>诸如此类的新功能和类型不太可能被大多数C＃开发人员使用，但是它们无疑会对性能至关重要的应用程序产生影响，值得进一步了解。</p>\n<h2 id=\"C＃性能很重要！\"><a href=\"#C＃性能很重要！\" class=\"headerlink\" title=\"C＃性能很重要！\"></a>C＃性能很重要！</h2><p>这只是我发现对提高.NET代码性能有用的几件事的集合-但是值得花时间检查代码以确保其性能。您的团队和客户将感谢您！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C＃性能提示和技巧\"><a href=\"#C＃性能提示和技巧\" class=\"headerlink\" title=\"C＃性能提示和技巧\"></a>C＃性能提示和技巧</h1><p>在<a href=\"https://raygun.com/\" target=\"_blank\" rel=\"noopener\">Raygun</a>，我们是一群非常懂多种语言的开发人员。Raygun的各个部分使用不同的语言和框架编写-最好的工作方式。</p>\n<p>鉴于大量的C＃和我们正在处理的数据的爆炸性增长，在不同的时间需要进行一些优化工作。大部分重大的收获往往来自于真正地重新思考问题并从全新的角度解决问题。</p>\n<p>今天我想分享一些C＃性能技巧，这些技巧对我的最新工作有所帮助。其中一些功能在你看来也许相当微不足道，因此请不要在这里充电并使用所有功能。就这样，提示1是…</p>\n<h2 id=\"1-每个开发人员都应使用分析器\"><a href=\"#1-每个开发人员都应使用分析器\" class=\"headerlink\" title=\"1.每个开发人员都应使用分析器\"></a>1.每个开发人员都应使用分析器</h2><p>有一些很棒的.NET分析器。我个人使用了<a href=\"https://www.jetbrains.com/\" target=\"_blank\" rel=\"noopener\">Jet Brains</a>团队的dotTrace分析器。我知道我们团队中的Jason 也从<a href=\"http://www.red-gate.com/products/dotnet-development/ants-performance-profiler/\" target=\"_blank\" rel=\"noopener\">Red Gate分析器中</a>获得了很多价值。每个开发人员都应安装<strong>并使用</strong>探查器。</p>\n<p>我无法数出我<strong>认为</strong>应用程序的最慢部分在一个区域中的次数，而实际上却完全在其他地方。探查器对此提供了帮助。此外，有时候，它可以帮助我发现错误-缓慢的部分之所以缓慢，只是因为它做错了什么（单元测试<em>没有</em>正确地拾取它）。</p>\n<p>这是您要执行的所有优化工作的第一步，也是有效的第一步。</p>\n<p> <img src=\"https://raygun.com/blog/images/c-sharp-performance/image1.jpg\" alt=\"冲刺开始\"> </p>\n<h2 id=\"2-级别越高，速度越慢（通常）\"><a href=\"#2-级别越高，速度越慢（通常）\" class=\"headerlink\" title=\"2.级别越高，速度越慢（通常）\"></a>2.级别越高，速度越慢（通常）</h2><p>这只是我闻到的气味。您使用的抽象级别越高，通常越慢。我在这里发现的一个常见示例是在代码繁忙的部分（也许在循环中被称为数百万次）中使用LINQ。LINQ非常适合快速表达某些内容，而这些内容可能要花一堆代码，但是您通常会将性能留在桌面上。</p>\n<p>不要误会我的意思-LINQ非常适合让您开发出可运行的应用程序。但是在代码库中以性能为中心的部分中，您可能会付出太多。特别是因为将这么多操作链接在一起非常容易。</p>\n<p>我所使用的特定示例是我使用的地方<code>.SelectMany().Distinct().Count()</code>。鉴于这被称为数千万次（由我的探查器发现的关键热点），它正在累积大量的运行时间。我采用了另一种方法，并将执行时间减少了几个数量级。</p>\n<h2 id=\"3-不要低估发行版和调试版\"><a href=\"#3-不要低估发行版和调试版\" class=\"headerlink\" title=\"3.不要低估发行版和调试版\"></a>3.不要低估发行版和调试版</h2><p>我一直在努力工作，对获得的性能感到非常满意。然后，我意识到自己已经在Visual Studio中进行了所有测试（我经常将性能测试编写为也可以作为单元测试运行，因此我可以更轻松地运行自己关心的部分）。我们都知道发行版本已启用优化。</p>\n<p>因此，我做了一个发布版本，称为从控制台应用程序测试的方法。</p>\n<p>我对此有了很大的转变。我的代码已经疯狂地进行了优化，因此确实是时候对.NET JIT编译器进行一些微优化了。启用优化后，我的性能提高了约30％！这使我想起了我不久前在网上阅读的一个故事。</p>\n<p><img src=\"https://raygun.com/blog/images/c-sharp-performance/image3.png\" alt=\"软盘的屏幕截图\"></p>\n<p>这是上世纪90年代的一个古老游戏编程故事，当时内存限制非常严格。在开发周期的后期，团队最终将耗尽内存，并开始考虑必须删除或降级哪些内容以适合可用的微小内存空间。资深开发人员根据他的经验就曾期望这样做，并在项目一开始就分配了1MB的内存和垃圾数据。然后，他节省了一天的时间，并删除了他在项目开始时立即分配的1MB内存，从而解决了问题！</p>\n<p>知道团队总是没有足够的空间，因为那里有可用的内存，就可以为团队提供他们所需要的东西，并按时发货。</p>\n<p>我为什么要分享这个？在性能方面类似–在调试模式下获得足够好的运行，并且您将在发行版本中获得一些“免费”性能。美好时光。</p>\n<h2 id=\"4-看大局\"><a href=\"#4-看大局\" class=\"headerlink\" title=\"4.看大局\"></a>4.看大局</h2><p>有一些很棒的算法。您多数不需要每天甚至每月都不用。但是，值得知道它们的存在。我经常进行研究后，就会发现一种更好的解决问题的方法。在编码之前进行研究的开发人员与在编写代码之前进行适当分析的开发人员的可能性差不多。我们喜欢代码，并且总是想直接进入IDE。</p>\n<p>此外，通常在查看性能问题时，我们过于专注于单个生产线或方法。这可能是一个错误–放眼全局，可以通过减少需要完成的工作来帮助您显着提高性能。</p>\n<h2 id=\"5-内存位置很重要\"><a href=\"#5-内存位置很重要\" class=\"headerlink\" title=\"5.内存位置很重要\"></a>5.内存位置很重要</h2><p>假设我们有一个数组数组。实际上是一张桌子，尺寸为3000×3000。我们要计算有多少个插槽的值大于零。</p>\n<p>问题–这两个中哪个更快？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (int i = 0; i &lt; _map.Length; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor (int n = 0; n &lt; _map.Length; n++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">  \t\tif (_map[i][n] &gt; 0)</span><br><span class=\"line\">  \t\t&#123;</span><br><span class=\"line\">    \t    result++;</span><br><span class=\"line\">  \t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for (int i = 0; i &lt; _map.Length; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfor (int n = 0; n &lt; _map.Length; n++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">  \t\tif (_map[n][i] &gt; 0)</span><br><span class=\"line\">  \t\t&#123;</span><br><span class=\"line\">    \t    result++;</span><br><span class=\"line\">  \t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回答？第一个。 在我的测试中，此循环使性能提高了8倍！</p>\n<p>注意区别吗？这是我们遍历此数组数组的顺序（[i] [n]与[n] [i]）。即使我们从自己管理内存中抽象出来，内存局部性在.NET中的确很重要。</p>\n<p>就我而言，这种方法被称为数百万次（准确地说是数亿次），因此我可以从中获得的任何性能都获得了可观的胜利。再次感谢我经常使用的分析器，以确保我专注于正确的地方！</p>\n<h2 id=\"6-减轻垃圾收集器的压力\"><a href=\"#6-减轻垃圾收集器的压力\" class=\"headerlink\" title=\"6.减轻垃圾收集器的压力\"></a>6.减轻垃圾收集器的压力</h2><p>C＃/.NET具有垃圾回收功能。垃圾收集是确定哪些对象当前已过时并删除它们以释放内存中空间的过程。这意味着在C＃中，与C ++之类的语言不同，您不必手动维护不再有用的对象的删除，即可声明其在内存中的空间。相反，垃圾收集器（GC）处理所有这些，因此您不必这样做。</p>\n<blockquote>\n<p>问题是没有免费的午餐</p>\n</blockquote>\n<p>问题是没有免费的午餐。收集过程本身会导致性能下降，因此您实际上并不希望GC一直收集。那么如何避免这种情况呢？</p>\n<p>有<a href=\"https://michaelscodingspot.com/avoid-gc-pressure/\" target=\"_blank\" rel=\"noopener\">许多有用的技术可以避免对GC施加太大压力</a>。在这里，我将只关注一个技巧：避免不必要的分配。这意味着要避免这样的事情：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Product&gt; products = new List&lt;Product&gt;();</span><br><span class=\"line\">products = productRepo.All();</span><br></pre></td></tr></table></figure>\n\n<p>第一行创建了一个完全无用的列表实例，因为下一行返回另一个实例并将其引用分配给变量。现在想象一下上面的两行是否在一个执行数千次的循环中？</p>\n<p>上面的代码可能看起来像一个愚蠢的示例，但是我已经在生产中看到了这样的代码，而不仅仅是一次。不要只关注示例本身，而要关注一般建议。除非确实需要，否则不要创建对象。</p>\n<p>由于GC在.NET中的工作方式（这是一个世代的GC流程），因此较旧的对象更有可能收集较新的对象。这意味着创建许多新的，短暂的对象可能会触发GC运行。</p>\n<h2 id=\"7-不要使用空的析构函数\"><a href=\"#7-不要使用空的析构函数\" class=\"headerlink\" title=\"7.不要使用空的析构函数\"></a>7.不要使用空的析构函数</h2><p>标题说明了一切-请勿在类中添加空的析构函数。<code>Finalize</code>每个具有析构函数的类的条目都会添加到队列中。然后在调用析构函数时调用我们的老朋友GC来处理队列。空的析构函数意味着这一切都是徒劳的。</p>\n<p>请记住，就性能而言，GC执行并不便宜，正如我们已经提到的。不要不必要地导致GC工作。</p>\n<p><img src=\"https://raygun.com/blog/images/c-sharp-performance/image5.jpg\" alt=\"盒子的屏幕截图\"></p>\n<h2 id=\"8-避免不必要的装箱和拆箱\"><a href=\"#8-避免不必要的装箱和拆箱\" class=\"headerlink\" title=\"8.避免不必要的装箱和拆箱\"></a>8.避免不必要的装箱和拆箱</h2><p>装箱和拆箱就像垃圾回收一样，在性能方面很昂贵。因此，我们希望避免不必要地进行操作。但是他们在实践中会做什么？</p>\n<p>装箱就像创建引用类型框并将值类型的值放入其中一样。换句话说，它包括将值类型转换为“对象”或该值类型实现的接口类型。取消装箱相反，它会打开包装盒并从其中提取值类型。为什么会有问题呢？</p>\n<p>好吧，正如我们已经提到的，装箱和拆箱本身就是昂贵的过程。除此之外，当您装箱一个值时，您会在堆上创建另一个对象，这给GC带来了额外的压力（您已经猜到了！）。</p>\n<p>那么，如何避免装箱和拆箱呢？</p>\n<p>通常，您可以通过避免.NET（版本1.0）中早于泛型的API来做到这一点，因此，它们必须依赖于使用对象类型。例如，更喜欢通用集合，例如<code>System.Collections.Generic.List</code>，而不是<code>System.Collections.ArrayList</code>。</p>\n<h2 id=\"9-当心字符串连接\"><a href=\"#9-当心字符串连接\" class=\"headerlink\" title=\"9.当心字符串连接\"></a>9.当心字符串连接</h2><p>在C＃/。NET中，字符串是不可变的。因此，每次执行一些看起来好像在更改字符串的操作时，它们都会创建一个新的字符串。这些操作包括类似的方法<code>Replace</code>和<code>Substring</code>，同时也串联。</p>\n<blockquote>\n<p>提防串联大量字符串，尤其是在循环内部</p>\n</blockquote>\n<p>因此，这里的技巧很简单-注意不要串联大量字符串，尤其是在循环内部。在这种情况下，请使用<code>System.Text.StringBuilder</code>类，而不要使用“ +”运算符。这样可以确保不会为连接的每个部分创建新实例。</p>\n<h2 id=\"10-随时关注C＃的发展\"><a href=\"#10-随时关注C＃的发展\" class=\"headerlink\" title=\"10.随时关注C＃的发展\"></a>10.随时关注C＃的发展</h2><p>最后，我们以非常笼统的建议作为结尾-请密切关注C＃语言的更改和发展方式。C＃团队不断提供可以对性能产生积极影响的新功能。</p>\n<p>我们可以提到的一个最新示例是C＃7中引入的<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/ref-returns\" target=\"_blank\" rel=\"noopener\">ref</a> return <a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/ref-returns\" target=\"_blank\" rel=\"noopener\">和ref locals</a>。这些新功能允许开发人员按引用返回并将引用存储在局部变量中。C＃7.2引入了<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.span-1?view=netcore-3.0\" target=\"_blank\" rel=\"noopener\">Span</a> 类型，从而可以对内存的连续区域进行类型安全的访问。</p>\n<p>诸如此类的新功能和类型不太可能被大多数C＃开发人员使用，但是它们无疑会对性能至关重要的应用程序产生影响，值得进一步了解。</p>\n<h2 id=\"C＃性能很重要！\"><a href=\"#C＃性能很重要！\" class=\"headerlink\" title=\"C＃性能很重要！\"></a>C＃性能很重要！</h2><p>这只是我发现对提高.NET代码性能有用的几件事的集合-但是值得花时间检查代码以确保其性能。您的团队和客户将感谢您！</p>\n"},{"title":".TDD学习笔记（二）单元测试","date":"2020-04-30T11:07:00.000Z","author":"邹溪源","_content":"# 单元测试\n## 定义\n单元测试最早来源于Kent Beck，他在开发SmallTalk中引入了这个概念，随着软件工程学的不断发展，使得单元测试已经成为软件编程中一项非常有用的实践。\n\n在维基百科中，“单元测试”是这样定义的：\n\n>一个单元测试是一段代码（通常是一个方法），这段代码调用另一段代码，然后检验某些假设的正确性。如果这些假设是错误的，单元测试就失败了。一个单元可以是一个方法或一个函数。\n\n  而《单元测试的艺术》作者Roy Osherove则认为，一个单元不仅仅是一个方法，也有可能是包括实现某个功能的多个类和函数。\n\n## 什么是好的单元测试\nRoy Osherove同时也认为，一个单元测试应该具备以下特征：\n\n1. 它应该是自动化的，可重复执行。\n2. 它应该很容易实现；\n3. 它应该第二天还有意义；\n4. 任何人都应该能一键运行它；\n5. 它应该运行很快；\n6. 它的结果应该是稳定的（如果运行之间没有进行修改的话，多次运行一个测试应该总是能够返回同样的结果）\n7. 它应该能完全控制被测试的单元；\n8. 它应该是完全隔离的（独立于其他测试的运行）；\n9. 如果它失败了，我们应该很容易发现什么是期待的结果，进而定位问题所在。\n# 几种概念\n在[这篇博客](https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da)中，作者对Fake、Mock、Stub进行了对比。\n\n## Fakes（伪造）\n![图片](https://uploader.shimo.im/f/9bhjo93eYX4y1Mbt.png!thumbnail)\n\nFake创建的对象，看似跟原对象一致，但是简化了原来对象的某些行为，使得我们在进行代码过程中，无需通过启动数据库或其他外部组件，即可对服务进行集成测试。\n\n## Mock（模拟）\n![图片](https://uploader.shimo.im/f/OLf5e8HV6yUrw7uC.png!thumbnail)\n\nmock是在调用方法中，注入“模拟”的完整的被调用者对象，并在Test方法中，通过注入的这个模拟对象来执行对应的操作。\n\n## Stub（打桩）\n![图片](https://uploader.shimo.im/f/X7xnMFmBKoQQXb7C.png!thumbnail)\n\n存根是预先定义一个方法的返回值，以便我们在调用该方法时，返回存根对象，这样使我们的代码不会以不改变原方法、或对原方法产生副作用的情况下，实现某方法。\n\n## 横切关注点\n>部分关注点「横切」程序代码中的数个模块，即在多个模块中都有出现，它们即被称作「横切关注点（Cross-cutting concerns, Horizontal concerns）」。\n\n横切关注点也是面向对象编程中的概念，我们通俗意义上理解的AOP框架，可以理解为解决横切关注点问题的一种框架。\n\n日志、异常处理、服务调用、方法调用链路都是大家会遇到的一类关注点问题，而而在《单元测试的艺术》这本书中，作者也指出“时间”（DateTime）也同样是一种问题。例如，如果我们在代码中普遍使用了系统默认的DateTime.Now，那么假设我们要测试代码在元旦和非元旦日期中的不同行为时，是不是手动把系统时间修改为指定的时间？这显然是的代码不利于维护，也不利于代码的可测试性。\n\n通过定义了一个SystemTime 对象来解决这个问题，确实是一种非常不错的方法。\n\n```\n [TestFixture]\n    public class TimeLoggerTests\n    {\n        [Test]\n        public void SettingingSystemTime_Always_ChangesTime()\n        {\n            SystemTime.Set(new DateTime(2000, 1, 1));\n            string output = TimeLogger.CreateMessage(\"a\");\n            StringAssert.Contains(\"01.01.2000\", output);\n        }\n    }\n public class SystemTime\n    {\n        private static DateTime _dateTime;\n        public static void Set(DateTime custom)\n        {\n            _dateTime = custom;\n        }\n        public static void Reset()\n        {\n            _dateTime = DateTime.MinValue;\n        }\n        public static DateTime Now\n        {\n            get\n            {\n                if (_dateTime != DateTime.MinValue)\n                {\n                    return _dateTime;\n                }\n                return DateTime.Now;\n            }\n        }\n        \n    }\n```\n# 测试框架\n测试框架是用来辅助开发者进行单元测试的代码库。在.NET开发环境下，我们常见的的测试框架可以分成以下两种类型：\n\n## 单元测试框架\n单元测试框架框架是帮助开发者进行单元测试的代码库和模块，它也可以作为自动编译过程的一个步骤运行测试。单元测试的框架[如此之多](https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks)，而在.NET中，常见的主要包括这几种：\n\n1、MSTest:这是Visual Studio中最常见的测试框架，在除Visual Studio2019以前的版本中，创建的单元测试项目自带的就是这种测试框架。\n\n2、XUnit:XUnit是一个大家族，在Java、.NET、等多种技术语言下都有XUnit的身影。\n\n3、NUnit:在许多介绍单元测试的书籍中，都会采用NUnit作为示例，在本文中，也主要介绍这种框架。\n\n## 隔离（模拟）框架   \n隔离（模拟）是一种可编程的API，使用这种API可以使得创建为对象比手工编写简便、快速和容易。常见的隔离（模拟）框架包括以下几种：\n\n1、Moq：在.NET中常见的Mock框架。\n\n2、NSubstitute：在《单元测试的艺术》一书中，作者Roy Osherove着重介绍过这种测试隔离框架，也经常和Moq框架一起进行[比较](https://itenium.be/blog/dotnet/nsubstitute-vs-moq/)。\n\n3、Microsoft Fakes:也是一种模拟框架，经常被用于和上述模拟框架[对比](https://saucelabs.com/blog/mock-frameworks-vs-microsoft-fakes)。\n\n4、FakeItEasy、EasyMoq、JustMock框架：其他模拟框架。 \n\n# 编写良好测试代码中常见的问题\n## 如何给测试方法命名\n方法的命名一直是困扰开发者的难题，尤其是单元测试方法。我们该如何给单元测试方法命名呢？目前我了解到两种不同的命名方法：\n\n假设，现有一个新增方法为：\n\n```\npublic int Add(int x,int y)\n```\n一种是Should开头的单元测试命名方法，可以命名为\n```\nShould_Returns_Sum_When_Add_Numbers();\n```\n另外一种是在《单元测试的艺术》这本书中作者用到的命名方法，作者将单元测试命名为三个部分，分别为：被测试方法名，测试场景，预期行为，将三个部分用下划线“_”分开，例如MethodUnderTest_Scenario_Behavior()。按照这个命名方法，上述方法可以被命名为：\n```\nAdd_Nums_Returns_ResultsOfInteger();\n```\n## 静态类或单例如何进行单元测试\n### 静态类\n在.NET Framework中经常互相静态类和静态对象，这无形中给我们的单元测试过程带来了不少困扰。我们可以采取以下方式对这些静态类进行测试。\n\n1、静态类应该只限于静态的方法，例如像StringExtension这样的扩展方法，这种方式是可以直接进行测试的。\n\n2、对于历史代码中为包含不少静态成员的“静态”对象，应该将其改成有IoC框架注入的单例对象，这样就能使用mock的方式进行单元测试。\n\n3、对于无法修改的静态对象，我们可以考虑将其隔离。\n\n### 单例\n而对于单例代码，则可以采用将单例逻辑和单例持有者分开的方式，让代码更易于测试。\n\n```\npublic class MySingleton\n{\n       private static MySingleton _instance;\n       public static MySingleton Instance\n       {\n           get\n           {\n               if (_instance == null)\n               {\n                   _instance = new MySingleton();\n               }\n               return _instance;\n           }\n       }\n       public void Foo()\n       {\n\n\n       }\n}\n```\n修改后：\n\n```\n public class MySingletonLogic\n    { \n        public void Foo()\n        {\n\n\n        }\n    }\n    public class MySingletonHolder\n    {\n        private static MySingletonLogic _instance;\n        public static MySingletonLogic Instance\n        {\n            get\n            {\n                if (_instance == null)\n                {\n                    _instance = new MySingletonLogic();\n                }\n                return _instance;\n            }\n        } \n    }\n```\n通过这种方式的改造，使得我们能够非常方便的对Foo方法进行测试了。\n### 何时开始进行单元测试？\n最好的时机就是当下，当你需要键入一行逻辑代码时，先写一个测试方法，按照TDD的流程进行开发，将有利于你的代码开发过程处于“自信满满”的状态，而且还能减少代码调试的时间，进而提高代码开发的效率。\n\n","source":"_posts/技术/TDD学习笔记（二）单元测试.md","raw":"---\ntitle:  .TDD学习笔记（二）单元测试\ndate: 2020-4-30 19:07\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n# 单元测试\n## 定义\n单元测试最早来源于Kent Beck，他在开发SmallTalk中引入了这个概念，随着软件工程学的不断发展，使得单元测试已经成为软件编程中一项非常有用的实践。\n\n在维基百科中，“单元测试”是这样定义的：\n\n>一个单元测试是一段代码（通常是一个方法），这段代码调用另一段代码，然后检验某些假设的正确性。如果这些假设是错误的，单元测试就失败了。一个单元可以是一个方法或一个函数。\n\n  而《单元测试的艺术》作者Roy Osherove则认为，一个单元不仅仅是一个方法，也有可能是包括实现某个功能的多个类和函数。\n\n## 什么是好的单元测试\nRoy Osherove同时也认为，一个单元测试应该具备以下特征：\n\n1. 它应该是自动化的，可重复执行。\n2. 它应该很容易实现；\n3. 它应该第二天还有意义；\n4. 任何人都应该能一键运行它；\n5. 它应该运行很快；\n6. 它的结果应该是稳定的（如果运行之间没有进行修改的话，多次运行一个测试应该总是能够返回同样的结果）\n7. 它应该能完全控制被测试的单元；\n8. 它应该是完全隔离的（独立于其他测试的运行）；\n9. 如果它失败了，我们应该很容易发现什么是期待的结果，进而定位问题所在。\n# 几种概念\n在[这篇博客](https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da)中，作者对Fake、Mock、Stub进行了对比。\n\n## Fakes（伪造）\n![图片](https://uploader.shimo.im/f/9bhjo93eYX4y1Mbt.png!thumbnail)\n\nFake创建的对象，看似跟原对象一致，但是简化了原来对象的某些行为，使得我们在进行代码过程中，无需通过启动数据库或其他外部组件，即可对服务进行集成测试。\n\n## Mock（模拟）\n![图片](https://uploader.shimo.im/f/OLf5e8HV6yUrw7uC.png!thumbnail)\n\nmock是在调用方法中，注入“模拟”的完整的被调用者对象，并在Test方法中，通过注入的这个模拟对象来执行对应的操作。\n\n## Stub（打桩）\n![图片](https://uploader.shimo.im/f/X7xnMFmBKoQQXb7C.png!thumbnail)\n\n存根是预先定义一个方法的返回值，以便我们在调用该方法时，返回存根对象，这样使我们的代码不会以不改变原方法、或对原方法产生副作用的情况下，实现某方法。\n\n## 横切关注点\n>部分关注点「横切」程序代码中的数个模块，即在多个模块中都有出现，它们即被称作「横切关注点（Cross-cutting concerns, Horizontal concerns）」。\n\n横切关注点也是面向对象编程中的概念，我们通俗意义上理解的AOP框架，可以理解为解决横切关注点问题的一种框架。\n\n日志、异常处理、服务调用、方法调用链路都是大家会遇到的一类关注点问题，而而在《单元测试的艺术》这本书中，作者也指出“时间”（DateTime）也同样是一种问题。例如，如果我们在代码中普遍使用了系统默认的DateTime.Now，那么假设我们要测试代码在元旦和非元旦日期中的不同行为时，是不是手动把系统时间修改为指定的时间？这显然是的代码不利于维护，也不利于代码的可测试性。\n\n通过定义了一个SystemTime 对象来解决这个问题，确实是一种非常不错的方法。\n\n```\n [TestFixture]\n    public class TimeLoggerTests\n    {\n        [Test]\n        public void SettingingSystemTime_Always_ChangesTime()\n        {\n            SystemTime.Set(new DateTime(2000, 1, 1));\n            string output = TimeLogger.CreateMessage(\"a\");\n            StringAssert.Contains(\"01.01.2000\", output);\n        }\n    }\n public class SystemTime\n    {\n        private static DateTime _dateTime;\n        public static void Set(DateTime custom)\n        {\n            _dateTime = custom;\n        }\n        public static void Reset()\n        {\n            _dateTime = DateTime.MinValue;\n        }\n        public static DateTime Now\n        {\n            get\n            {\n                if (_dateTime != DateTime.MinValue)\n                {\n                    return _dateTime;\n                }\n                return DateTime.Now;\n            }\n        }\n        \n    }\n```\n# 测试框架\n测试框架是用来辅助开发者进行单元测试的代码库。在.NET开发环境下，我们常见的的测试框架可以分成以下两种类型：\n\n## 单元测试框架\n单元测试框架框架是帮助开发者进行单元测试的代码库和模块，它也可以作为自动编译过程的一个步骤运行测试。单元测试的框架[如此之多](https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks)，而在.NET中，常见的主要包括这几种：\n\n1、MSTest:这是Visual Studio中最常见的测试框架，在除Visual Studio2019以前的版本中，创建的单元测试项目自带的就是这种测试框架。\n\n2、XUnit:XUnit是一个大家族，在Java、.NET、等多种技术语言下都有XUnit的身影。\n\n3、NUnit:在许多介绍单元测试的书籍中，都会采用NUnit作为示例，在本文中，也主要介绍这种框架。\n\n## 隔离（模拟）框架   \n隔离（模拟）是一种可编程的API，使用这种API可以使得创建为对象比手工编写简便、快速和容易。常见的隔离（模拟）框架包括以下几种：\n\n1、Moq：在.NET中常见的Mock框架。\n\n2、NSubstitute：在《单元测试的艺术》一书中，作者Roy Osherove着重介绍过这种测试隔离框架，也经常和Moq框架一起进行[比较](https://itenium.be/blog/dotnet/nsubstitute-vs-moq/)。\n\n3、Microsoft Fakes:也是一种模拟框架，经常被用于和上述模拟框架[对比](https://saucelabs.com/blog/mock-frameworks-vs-microsoft-fakes)。\n\n4、FakeItEasy、EasyMoq、JustMock框架：其他模拟框架。 \n\n# 编写良好测试代码中常见的问题\n## 如何给测试方法命名\n方法的命名一直是困扰开发者的难题，尤其是单元测试方法。我们该如何给单元测试方法命名呢？目前我了解到两种不同的命名方法：\n\n假设，现有一个新增方法为：\n\n```\npublic int Add(int x,int y)\n```\n一种是Should开头的单元测试命名方法，可以命名为\n```\nShould_Returns_Sum_When_Add_Numbers();\n```\n另外一种是在《单元测试的艺术》这本书中作者用到的命名方法，作者将单元测试命名为三个部分，分别为：被测试方法名，测试场景，预期行为，将三个部分用下划线“_”分开，例如MethodUnderTest_Scenario_Behavior()。按照这个命名方法，上述方法可以被命名为：\n```\nAdd_Nums_Returns_ResultsOfInteger();\n```\n## 静态类或单例如何进行单元测试\n### 静态类\n在.NET Framework中经常互相静态类和静态对象，这无形中给我们的单元测试过程带来了不少困扰。我们可以采取以下方式对这些静态类进行测试。\n\n1、静态类应该只限于静态的方法，例如像StringExtension这样的扩展方法，这种方式是可以直接进行测试的。\n\n2、对于历史代码中为包含不少静态成员的“静态”对象，应该将其改成有IoC框架注入的单例对象，这样就能使用mock的方式进行单元测试。\n\n3、对于无法修改的静态对象，我们可以考虑将其隔离。\n\n### 单例\n而对于单例代码，则可以采用将单例逻辑和单例持有者分开的方式，让代码更易于测试。\n\n```\npublic class MySingleton\n{\n       private static MySingleton _instance;\n       public static MySingleton Instance\n       {\n           get\n           {\n               if (_instance == null)\n               {\n                   _instance = new MySingleton();\n               }\n               return _instance;\n           }\n       }\n       public void Foo()\n       {\n\n\n       }\n}\n```\n修改后：\n\n```\n public class MySingletonLogic\n    { \n        public void Foo()\n        {\n\n\n        }\n    }\n    public class MySingletonHolder\n    {\n        private static MySingletonLogic _instance;\n        public static MySingletonLogic Instance\n        {\n            get\n            {\n                if (_instance == null)\n                {\n                    _instance = new MySingletonLogic();\n                }\n                return _instance;\n            }\n        } \n    }\n```\n通过这种方式的改造，使得我们能够非常方便的对Foo方法进行测试了。\n### 何时开始进行单元测试？\n最好的时机就是当下，当你需要键入一行逻辑代码时，先写一个测试方法，按照TDD的流程进行开发，将有利于你的代码开发过程处于“自信满满”的状态，而且还能减少代码调试的时间，进而提高代码开发的效率。\n\n","slug":"技术/TDD学习笔记（二）单元测试","published":1,"updated":"2020-05-26T11:08:09.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt6j0005n4vitz62ng3r","content":"<h1 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>单元测试最早来源于Kent Beck，他在开发SmallTalk中引入了这个概念，随着软件工程学的不断发展，使得单元测试已经成为软件编程中一项非常有用的实践。</p>\n<p>在维基百科中，“单元测试”是这样定义的：</p>\n<blockquote>\n<p>一个单元测试是一段代码（通常是一个方法），这段代码调用另一段代码，然后检验某些假设的正确性。如果这些假设是错误的，单元测试就失败了。一个单元可以是一个方法或一个函数。</p>\n</blockquote>\n<p>  而《单元测试的艺术》作者Roy Osherove则认为，一个单元不仅仅是一个方法，也有可能是包括实现某个功能的多个类和函数。</p>\n<h2 id=\"什么是好的单元测试\"><a href=\"#什么是好的单元测试\" class=\"headerlink\" title=\"什么是好的单元测试\"></a>什么是好的单元测试</h2><p>Roy Osherove同时也认为，一个单元测试应该具备以下特征：</p>\n<ol>\n<li>它应该是自动化的，可重复执行。</li>\n<li>它应该很容易实现；</li>\n<li>它应该第二天还有意义；</li>\n<li>任何人都应该能一键运行它；</li>\n<li>它应该运行很快；</li>\n<li>它的结果应该是稳定的（如果运行之间没有进行修改的话，多次运行一个测试应该总是能够返回同样的结果）</li>\n<li>它应该能完全控制被测试的单元；</li>\n<li>它应该是完全隔离的（独立于其他测试的运行）；</li>\n<li>如果它失败了，我们应该很容易发现什么是期待的结果，进而定位问题所在。<h1 id=\"几种概念\"><a href=\"#几种概念\" class=\"headerlink\" title=\"几种概念\"></a>几种概念</h1>在<a href=\"https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da\" target=\"_blank\" rel=\"noopener\">这篇博客</a>中，作者对Fake、Mock、Stub进行了对比。</li>\n</ol>\n<h2 id=\"Fakes（伪造）\"><a href=\"#Fakes（伪造）\" class=\"headerlink\" title=\"Fakes（伪造）\"></a>Fakes（伪造）</h2><p><img src=\"https://uploader.shimo.im/f/9bhjo93eYX4y1Mbt.png!thumbnail\" alt=\"图片\"></p>\n<p>Fake创建的对象，看似跟原对象一致，但是简化了原来对象的某些行为，使得我们在进行代码过程中，无需通过启动数据库或其他外部组件，即可对服务进行集成测试。</p>\n<h2 id=\"Mock（模拟）\"><a href=\"#Mock（模拟）\" class=\"headerlink\" title=\"Mock（模拟）\"></a>Mock（模拟）</h2><p><img src=\"https://uploader.shimo.im/f/OLf5e8HV6yUrw7uC.png!thumbnail\" alt=\"图片\"></p>\n<p>mock是在调用方法中，注入“模拟”的完整的被调用者对象，并在Test方法中，通过注入的这个模拟对象来执行对应的操作。</p>\n<h2 id=\"Stub（打桩）\"><a href=\"#Stub（打桩）\" class=\"headerlink\" title=\"Stub（打桩）\"></a>Stub（打桩）</h2><p><img src=\"https://uploader.shimo.im/f/X7xnMFmBKoQQXb7C.png!thumbnail\" alt=\"图片\"></p>\n<p>存根是预先定义一个方法的返回值，以便我们在调用该方法时，返回存根对象，这样使我们的代码不会以不改变原方法、或对原方法产生副作用的情况下，实现某方法。</p>\n<h2 id=\"横切关注点\"><a href=\"#横切关注点\" class=\"headerlink\" title=\"横切关注点\"></a>横切关注点</h2><blockquote>\n<p>部分关注点「横切」程序代码中的数个模块，即在多个模块中都有出现，它们即被称作「横切关注点（Cross-cutting concerns, Horizontal concerns）」。</p>\n</blockquote>\n<p>横切关注点也是面向对象编程中的概念，我们通俗意义上理解的AOP框架，可以理解为解决横切关注点问题的一种框架。</p>\n<p>日志、异常处理、服务调用、方法调用链路都是大家会遇到的一类关注点问题，而而在《单元测试的艺术》这本书中，作者也指出“时间”（DateTime）也同样是一种问题。例如，如果我们在代码中普遍使用了系统默认的DateTime.Now，那么假设我们要测试代码在元旦和非元旦日期中的不同行为时，是不是手动把系统时间修改为指定的时间？这显然是的代码不利于维护，也不利于代码的可测试性。</p>\n<p>通过定义了一个SystemTime 对象来解决这个问题，确实是一种非常不错的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> [TestFixture]</span><br><span class=\"line\">    public class TimeLoggerTests</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [Test]</span><br><span class=\"line\">        public void SettingingSystemTime_Always_ChangesTime()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            SystemTime.Set(new DateTime(2000, 1, 1));</span><br><span class=\"line\">            string output = TimeLogger.CreateMessage(&quot;a&quot;);</span><br><span class=\"line\">            StringAssert.Contains(&quot;01.01.2000&quot;, output);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> public class SystemTime</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private static DateTime _dateTime;</span><br><span class=\"line\">        public static void Set(DateTime custom)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _dateTime = custom;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static void Reset()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _dateTime = DateTime.MinValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static DateTime Now</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            get</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                if (_dateTime != DateTime.MinValue)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    return _dateTime;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return DateTime.Now;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"测试框架\"><a href=\"#测试框架\" class=\"headerlink\" title=\"测试框架\"></a>测试框架</h1><p>测试框架是用来辅助开发者进行单元测试的代码库。在.NET开发环境下，我们常见的的测试框架可以分成以下两种类型：</p>\n<h2 id=\"单元测试框架\"><a href=\"#单元测试框架\" class=\"headerlink\" title=\"单元测试框架\"></a>单元测试框架</h2><p>单元测试框架框架是帮助开发者进行单元测试的代码库和模块，它也可以作为自动编译过程的一个步骤运行测试。单元测试的框架<a href=\"https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks\" target=\"_blank\" rel=\"noopener\">如此之多</a>，而在.NET中，常见的主要包括这几种：</p>\n<p>1、MSTest:这是Visual Studio中最常见的测试框架，在除Visual Studio2019以前的版本中，创建的单元测试项目自带的就是这种测试框架。</p>\n<p>2、XUnit:XUnit是一个大家族，在Java、.NET、等多种技术语言下都有XUnit的身影。</p>\n<p>3、NUnit:在许多介绍单元测试的书籍中，都会采用NUnit作为示例，在本文中，也主要介绍这种框架。</p>\n<h2 id=\"隔离（模拟）框架\"><a href=\"#隔离（模拟）框架\" class=\"headerlink\" title=\"隔离（模拟）框架\"></a>隔离（模拟）框架</h2><p>隔离（模拟）是一种可编程的API，使用这种API可以使得创建为对象比手工编写简便、快速和容易。常见的隔离（模拟）框架包括以下几种：</p>\n<p>1、Moq：在.NET中常见的Mock框架。</p>\n<p>2、NSubstitute：在《单元测试的艺术》一书中，作者Roy Osherove着重介绍过这种测试隔离框架，也经常和Moq框架一起进行<a href=\"https://itenium.be/blog/dotnet/nsubstitute-vs-moq/\" target=\"_blank\" rel=\"noopener\">比较</a>。</p>\n<p>3、Microsoft Fakes:也是一种模拟框架，经常被用于和上述模拟框架<a href=\"https://saucelabs.com/blog/mock-frameworks-vs-microsoft-fakes\" target=\"_blank\" rel=\"noopener\">对比</a>。</p>\n<p>4、FakeItEasy、EasyMoq、JustMock框架：其他模拟框架。 </p>\n<h1 id=\"编写良好测试代码中常见的问题\"><a href=\"#编写良好测试代码中常见的问题\" class=\"headerlink\" title=\"编写良好测试代码中常见的问题\"></a>编写良好测试代码中常见的问题</h1><h2 id=\"如何给测试方法命名\"><a href=\"#如何给测试方法命名\" class=\"headerlink\" title=\"如何给测试方法命名\"></a>如何给测试方法命名</h2><p>方法的命名一直是困扰开发者的难题，尤其是单元测试方法。我们该如何给单元测试方法命名呢？目前我了解到两种不同的命名方法：</p>\n<p>假设，现有一个新增方法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int Add(int x,int y)</span><br></pre></td></tr></table></figure>\n\n<p>一种是Should开头的单元测试命名方法，可以命名为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Should_Returns_Sum_When_Add_Numbers();</span><br></pre></td></tr></table></figure>\n\n<p>另外一种是在《单元测试的艺术》这本书中作者用到的命名方法，作者将单元测试命名为三个部分，分别为：被测试方法名，测试场景，预期行为，将三个部分用下划线“_”分开，例如MethodUnderTest_Scenario_Behavior()。按照这个命名方法，上述方法可以被命名为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Add_Nums_Returns_ResultsOfInteger();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态类或单例如何进行单元测试\"><a href=\"#静态类或单例如何进行单元测试\" class=\"headerlink\" title=\"静态类或单例如何进行单元测试\"></a>静态类或单例如何进行单元测试</h2><h3 id=\"静态类\"><a href=\"#静态类\" class=\"headerlink\" title=\"静态类\"></a>静态类</h3><p>在.NET Framework中经常互相静态类和静态对象，这无形中给我们的单元测试过程带来了不少困扰。我们可以采取以下方式对这些静态类进行测试。</p>\n<p>1、静态类应该只限于静态的方法，例如像StringExtension这样的扩展方法，这种方式是可以直接进行测试的。</p>\n<p>2、对于历史代码中为包含不少静态成员的“静态”对象，应该将其改成有IoC框架注入的单例对象，这样就能使用mock的方式进行单元测试。</p>\n<p>3、对于无法修改的静态对象，我们可以考虑将其隔离。</p>\n<h3 id=\"单例\"><a href=\"#单例\" class=\"headerlink\" title=\"单例\"></a>单例</h3><p>而对于单例代码，则可以采用将单例逻辑和单例持有者分开的方式，让代码更易于测试。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MySingleton</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">       private static MySingleton _instance;</span><br><span class=\"line\">       public static MySingleton Instance</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           get</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               if (_instance == null)</span><br><span class=\"line\">               &#123;</span><br><span class=\"line\">                   _instance = new MySingleton();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               return _instance;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       public void Foo()</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public class MySingletonLogic</span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        public void Foo()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public class MySingletonHolder</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private static MySingletonLogic _instance;</span><br><span class=\"line\">        public static MySingletonLogic Instance</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            get</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                if (_instance == null)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    _instance = new MySingletonLogic();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return _instance;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这种方式的改造，使得我们能够非常方便的对Foo方法进行测试了。</p>\n<h3 id=\"何时开始进行单元测试？\"><a href=\"#何时开始进行单元测试？\" class=\"headerlink\" title=\"何时开始进行单元测试？\"></a>何时开始进行单元测试？</h3><p>最好的时机就是当下，当你需要键入一行逻辑代码时，先写一个测试方法，按照TDD的流程进行开发，将有利于你的代码开发过程处于“自信满满”的状态，而且还能减少代码调试的时间，进而提高代码开发的效率。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>单元测试最早来源于Kent Beck，他在开发SmallTalk中引入了这个概念，随着软件工程学的不断发展，使得单元测试已经成为软件编程中一项非常有用的实践。</p>\n<p>在维基百科中，“单元测试”是这样定义的：</p>\n<blockquote>\n<p>一个单元测试是一段代码（通常是一个方法），这段代码调用另一段代码，然后检验某些假设的正确性。如果这些假设是错误的，单元测试就失败了。一个单元可以是一个方法或一个函数。</p>\n</blockquote>\n<p>  而《单元测试的艺术》作者Roy Osherove则认为，一个单元不仅仅是一个方法，也有可能是包括实现某个功能的多个类和函数。</p>\n<h2 id=\"什么是好的单元测试\"><a href=\"#什么是好的单元测试\" class=\"headerlink\" title=\"什么是好的单元测试\"></a>什么是好的单元测试</h2><p>Roy Osherove同时也认为，一个单元测试应该具备以下特征：</p>\n<ol>\n<li>它应该是自动化的，可重复执行。</li>\n<li>它应该很容易实现；</li>\n<li>它应该第二天还有意义；</li>\n<li>任何人都应该能一键运行它；</li>\n<li>它应该运行很快；</li>\n<li>它的结果应该是稳定的（如果运行之间没有进行修改的话，多次运行一个测试应该总是能够返回同样的结果）</li>\n<li>它应该能完全控制被测试的单元；</li>\n<li>它应该是完全隔离的（独立于其他测试的运行）；</li>\n<li>如果它失败了，我们应该很容易发现什么是期待的结果，进而定位问题所在。<h1 id=\"几种概念\"><a href=\"#几种概念\" class=\"headerlink\" title=\"几种概念\"></a>几种概念</h1>在<a href=\"https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da\" target=\"_blank\" rel=\"noopener\">这篇博客</a>中，作者对Fake、Mock、Stub进行了对比。</li>\n</ol>\n<h2 id=\"Fakes（伪造）\"><a href=\"#Fakes（伪造）\" class=\"headerlink\" title=\"Fakes（伪造）\"></a>Fakes（伪造）</h2><p><img src=\"https://uploader.shimo.im/f/9bhjo93eYX4y1Mbt.png!thumbnail\" alt=\"图片\"></p>\n<p>Fake创建的对象，看似跟原对象一致，但是简化了原来对象的某些行为，使得我们在进行代码过程中，无需通过启动数据库或其他外部组件，即可对服务进行集成测试。</p>\n<h2 id=\"Mock（模拟）\"><a href=\"#Mock（模拟）\" class=\"headerlink\" title=\"Mock（模拟）\"></a>Mock（模拟）</h2><p><img src=\"https://uploader.shimo.im/f/OLf5e8HV6yUrw7uC.png!thumbnail\" alt=\"图片\"></p>\n<p>mock是在调用方法中，注入“模拟”的完整的被调用者对象，并在Test方法中，通过注入的这个模拟对象来执行对应的操作。</p>\n<h2 id=\"Stub（打桩）\"><a href=\"#Stub（打桩）\" class=\"headerlink\" title=\"Stub（打桩）\"></a>Stub（打桩）</h2><p><img src=\"https://uploader.shimo.im/f/X7xnMFmBKoQQXb7C.png!thumbnail\" alt=\"图片\"></p>\n<p>存根是预先定义一个方法的返回值，以便我们在调用该方法时，返回存根对象，这样使我们的代码不会以不改变原方法、或对原方法产生副作用的情况下，实现某方法。</p>\n<h2 id=\"横切关注点\"><a href=\"#横切关注点\" class=\"headerlink\" title=\"横切关注点\"></a>横切关注点</h2><blockquote>\n<p>部分关注点「横切」程序代码中的数个模块，即在多个模块中都有出现，它们即被称作「横切关注点（Cross-cutting concerns, Horizontal concerns）」。</p>\n</blockquote>\n<p>横切关注点也是面向对象编程中的概念，我们通俗意义上理解的AOP框架，可以理解为解决横切关注点问题的一种框架。</p>\n<p>日志、异常处理、服务调用、方法调用链路都是大家会遇到的一类关注点问题，而而在《单元测试的艺术》这本书中，作者也指出“时间”（DateTime）也同样是一种问题。例如，如果我们在代码中普遍使用了系统默认的DateTime.Now，那么假设我们要测试代码在元旦和非元旦日期中的不同行为时，是不是手动把系统时间修改为指定的时间？这显然是的代码不利于维护，也不利于代码的可测试性。</p>\n<p>通过定义了一个SystemTime 对象来解决这个问题，确实是一种非常不错的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> [TestFixture]</span><br><span class=\"line\">    public class TimeLoggerTests</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [Test]</span><br><span class=\"line\">        public void SettingingSystemTime_Always_ChangesTime()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            SystemTime.Set(new DateTime(2000, 1, 1));</span><br><span class=\"line\">            string output = TimeLogger.CreateMessage(&quot;a&quot;);</span><br><span class=\"line\">            StringAssert.Contains(&quot;01.01.2000&quot;, output);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> public class SystemTime</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private static DateTime _dateTime;</span><br><span class=\"line\">        public static void Set(DateTime custom)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _dateTime = custom;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static void Reset()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _dateTime = DateTime.MinValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static DateTime Now</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            get</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                if (_dateTime != DateTime.MinValue)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    return _dateTime;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return DateTime.Now;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"测试框架\"><a href=\"#测试框架\" class=\"headerlink\" title=\"测试框架\"></a>测试框架</h1><p>测试框架是用来辅助开发者进行单元测试的代码库。在.NET开发环境下，我们常见的的测试框架可以分成以下两种类型：</p>\n<h2 id=\"单元测试框架\"><a href=\"#单元测试框架\" class=\"headerlink\" title=\"单元测试框架\"></a>单元测试框架</h2><p>单元测试框架框架是帮助开发者进行单元测试的代码库和模块，它也可以作为自动编译过程的一个步骤运行测试。单元测试的框架<a href=\"https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks\" target=\"_blank\" rel=\"noopener\">如此之多</a>，而在.NET中，常见的主要包括这几种：</p>\n<p>1、MSTest:这是Visual Studio中最常见的测试框架，在除Visual Studio2019以前的版本中，创建的单元测试项目自带的就是这种测试框架。</p>\n<p>2、XUnit:XUnit是一个大家族，在Java、.NET、等多种技术语言下都有XUnit的身影。</p>\n<p>3、NUnit:在许多介绍单元测试的书籍中，都会采用NUnit作为示例，在本文中，也主要介绍这种框架。</p>\n<h2 id=\"隔离（模拟）框架\"><a href=\"#隔离（模拟）框架\" class=\"headerlink\" title=\"隔离（模拟）框架\"></a>隔离（模拟）框架</h2><p>隔离（模拟）是一种可编程的API，使用这种API可以使得创建为对象比手工编写简便、快速和容易。常见的隔离（模拟）框架包括以下几种：</p>\n<p>1、Moq：在.NET中常见的Mock框架。</p>\n<p>2、NSubstitute：在《单元测试的艺术》一书中，作者Roy Osherove着重介绍过这种测试隔离框架，也经常和Moq框架一起进行<a href=\"https://itenium.be/blog/dotnet/nsubstitute-vs-moq/\" target=\"_blank\" rel=\"noopener\">比较</a>。</p>\n<p>3、Microsoft Fakes:也是一种模拟框架，经常被用于和上述模拟框架<a href=\"https://saucelabs.com/blog/mock-frameworks-vs-microsoft-fakes\" target=\"_blank\" rel=\"noopener\">对比</a>。</p>\n<p>4、FakeItEasy、EasyMoq、JustMock框架：其他模拟框架。 </p>\n<h1 id=\"编写良好测试代码中常见的问题\"><a href=\"#编写良好测试代码中常见的问题\" class=\"headerlink\" title=\"编写良好测试代码中常见的问题\"></a>编写良好测试代码中常见的问题</h1><h2 id=\"如何给测试方法命名\"><a href=\"#如何给测试方法命名\" class=\"headerlink\" title=\"如何给测试方法命名\"></a>如何给测试方法命名</h2><p>方法的命名一直是困扰开发者的难题，尤其是单元测试方法。我们该如何给单元测试方法命名呢？目前我了解到两种不同的命名方法：</p>\n<p>假设，现有一个新增方法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int Add(int x,int y)</span><br></pre></td></tr></table></figure>\n\n<p>一种是Should开头的单元测试命名方法，可以命名为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Should_Returns_Sum_When_Add_Numbers();</span><br></pre></td></tr></table></figure>\n\n<p>另外一种是在《单元测试的艺术》这本书中作者用到的命名方法，作者将单元测试命名为三个部分，分别为：被测试方法名，测试场景，预期行为，将三个部分用下划线“_”分开，例如MethodUnderTest_Scenario_Behavior()。按照这个命名方法，上述方法可以被命名为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Add_Nums_Returns_ResultsOfInteger();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态类或单例如何进行单元测试\"><a href=\"#静态类或单例如何进行单元测试\" class=\"headerlink\" title=\"静态类或单例如何进行单元测试\"></a>静态类或单例如何进行单元测试</h2><h3 id=\"静态类\"><a href=\"#静态类\" class=\"headerlink\" title=\"静态类\"></a>静态类</h3><p>在.NET Framework中经常互相静态类和静态对象，这无形中给我们的单元测试过程带来了不少困扰。我们可以采取以下方式对这些静态类进行测试。</p>\n<p>1、静态类应该只限于静态的方法，例如像StringExtension这样的扩展方法，这种方式是可以直接进行测试的。</p>\n<p>2、对于历史代码中为包含不少静态成员的“静态”对象，应该将其改成有IoC框架注入的单例对象，这样就能使用mock的方式进行单元测试。</p>\n<p>3、对于无法修改的静态对象，我们可以考虑将其隔离。</p>\n<h3 id=\"单例\"><a href=\"#单例\" class=\"headerlink\" title=\"单例\"></a>单例</h3><p>而对于单例代码，则可以采用将单例逻辑和单例持有者分开的方式，让代码更易于测试。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MySingleton</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">       private static MySingleton _instance;</span><br><span class=\"line\">       public static MySingleton Instance</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           get</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               if (_instance == null)</span><br><span class=\"line\">               &#123;</span><br><span class=\"line\">                   _instance = new MySingleton();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               return _instance;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       public void Foo()</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public class MySingletonLogic</span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        public void Foo()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public class MySingletonHolder</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private static MySingletonLogic _instance;</span><br><span class=\"line\">        public static MySingletonLogic Instance</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            get</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                if (_instance == null)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    _instance = new MySingletonLogic();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return _instance;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这种方式的改造，使得我们能够非常方便的对Foo方法进行测试了。</p>\n<h3 id=\"何时开始进行单元测试？\"><a href=\"#何时开始进行单元测试？\" class=\"headerlink\" title=\"何时开始进行单元测试？\"></a>何时开始进行单元测试？</h3><p>最好的时机就是当下，当你需要键入一行逻辑代码时，先写一个测试方法，按照TDD的流程进行开发，将有利于你的代码开发过程处于“自信满满”的状态，而且还能减少代码调试的时间，进而提高代码开发的效率。</p>\n"},{"title":"如何使用ABP进行软件开发（1）基础概览","date":"2020-06-24T12:05:00.000Z","author":"邹溪源","_content":"# ABP框架简述\n\n## 1）简介\n\n在.NET众多的技术框架中，ABP框架（本系列中指aspnetboilerplate项目）以其独特的魅力吸引了一群优秀开发者广泛的使用。\n\n在该框架的赋能之下，开发者可根据需求通过官方网站【[https://aspnetboilerplate.com/Templates](https://aspnetboilerplate.com/Templates)】选择下载例如Vue/AngluarJS/MVC等不同类型的模板项目，轻松加入ABP开发者的队伍中，尽享基于ABP开发带来的乐趣。\n\n![图片](https://uploader.shimo.im/f/0I5mbgL5X2KWe3Ec.png!thumbnail)\n\nABP开发框架也提供了丰富的文档，能够为开发者带来许多便捷。目前ABP的文档网站为：\n\n官方文档：[https://aspnetboilerplate.com/Pages/Documents](https://aspnetboilerplate.com/Pages/Documents)\n\n文档库不可谓不全，加上国内众多的ABP开发者参与的活跃的技术圈子，使得学习成本只是在第一个项目中比较高，后期将会越来越平滑。\n\n## 2）现状\n\n当然，目前ABP的框架开发者和社区已经把更多的精力投入到了ABP.VNEXT开发框架，这个新框架以其DDD+微服务+模块化的理念获得了大量拥趸，使ABP框架的开发优先级已经开始逐渐降低。\n\n但这是因为ABP框架的功能已经成熟稳定，且ABP是一种增量式的架构设计，开发者在熟练掌握这种框架后，可以根据自己的需要进行方便的扩展，使其成为小项目架构选型中一种不错的备选方案。  \n\n当然，也存在一些弊端。例如由于ABP被称为.NET众多开发框架中面向领域驱动设计的最佳实践，而囿于领域驱动设计本身不低的门槛，使得学习的过程变得看起来非常陡峭；\n\n除此之外，ABP也广泛使用了目前Asp.NET/Asp.NET Core框架的大量比较新的特性，对于不少无法由于各种原因无法享受.NET技术飞速发展红利的传统开发者来说，无形中也提高了技术门槛。\n\n## 3）综述\n\n在这个系列中，本文计划分成三篇来介绍ABP框架，第一篇介绍ABP的基础概览，介绍基础知识，第二篇介绍ABP的模式实践，第三篇，试图介绍如何从更传统的三层甚至是单层+SQL的单层架构，如何迁移到ABP框架。\n\n（毕竟。。.NET遗留应用实在是太多了，拯救或不拯救？）\n\n# 代码结构结构\n\n## 基本文件夹简述\n\n当我们通过ABP模板项目的官方网站下载一个项目后，我们所获得的代码包的结构如下图所示，其中：\n\n![图片](https://uploader.shimo.im/f/Ju6P1J8FRkBtAhwt.png!thumbnail)![图片](https://uploader.shimo.im/f/52c6ytXJo2RPq4U4.png!thumbnail)\n\n* vue为使用iview框架构建的管理系统基本模板，该脚手架使用了yarn作为包管理器，并集成了vuex/axios等常用框架，并提供了用户，租户，权限三个基本功能的示例代码，开发者只需发挥聪明才智就能快速的通过该框架入手前端项目。\n* （当然，该项目广泛使用了typescript+面向对象的设计，似乎前端开发者。。普遍不擅长面向对象开发？）\n* aspnet-core则是一个完整的asp.netcore项目的快速开发脚手架。该脚手架集成了docker打包于一体，并包含基本的单元测试示例，使用了identity作为权限控制单元，使用swagger作为接口文档管理工具，集成了efcore、jwt等常用组件，对于开发者来说，基本上算是开箱即用了。\n# 前端vue项目\n\n打开vue文件夹之后，该项目的基本目录如下图所示。（src文件夹）\n\n![图片](https://uploader.shimo.im/f/hjXiUSLWHrkFiSoI.png!thumbnail)\n\n### lib文件夹\n\n定义了与abp+vue脚手架项目的基础组件和常见类库，封装了一系列基本方法。例如权限控制，数据请求，菜单操作，SignalR等基础组件的用法。\n\n### router文件夹\n\n定义了vue项目的路由规则，其中index.ts文件是项目的入口，router.ts文件定义了vue文件的路由规则。\n\n### store文件夹\n\n由于本项目使用了vuex框架，所以我们可以来看看对于store文件夹的介绍。\n\n在vuex框架中：\n\n>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。\n>Vuex 和单纯的全局对象有以下两点不同：\n>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 \n\n即vuex框架中，将原来的请求链路，抽象化为状态的变化，通过维护状态，使得数据的管理更加便捷，也易于扩展。\n\n### views文件夹\n\n定义了登录、首页、用户、角色、租户的基本页面，并提供了新增、查看、编辑、删除的代码示例。\n\n综上，该项目是一个结构清晰，逻辑缜密的前端框架，可以作为常见管理系统的脚手架。 \n\n# 后端项目\n\n![图片](https://uploader.shimo.im/f/sMZQOoDFjlQgIJrW.png!thumbnail)\n\n## 简介\n\n后端项目是一个遵循了领域驱动设计的分层，同时又符合Robert Martin在《代码整洁之道》提出的【整洁架构】。\n\n![图片](https://uploader.shimo.im/f/zYQDS5X0g86PUuIh.png!thumbnail)\n\n## 领域驱动设计简介 \n\n在领域驱动设计的分层设计中，共有四个功能分层，分别是：\n\n表示层（Presentation Layer）：为用户提供接口，使用应用层实现用户交互。\n\n应用层（Application Layer）：介于用户层和领域层之间，协调用户对象，完成对应的任务。\n\n领域层（Domain Layer）：包含业务对象和规则，是应用程序的心脏。\n\n基础设施层（Infrastructure Layer）：提供高层级的通用技术功能，主要使用第三方库完成。\n\n在后文中，基于abp对领域驱动设计的功能分层将进行多次、详细叙述，本小节不再赘述。\n\n## 整洁架构简介\n\n整洁架构是由Bob大叔提出的一种架构模型，来源于《整洁架构》这本书，顾名思义，其目的并不是为了介绍这一种优秀的架构本身，而是介绍如何设计一种整洁的架构，使得代码结构易于维护。\n\n![图片](https://uploader.shimo.im/f/C41YQfT1LaZ2qeLF.png!thumbnail)\n\n（整洁架构就是这样一个洋葱，所以也有人称它为“洋葱”架构）\n\n1. **依赖规则(Dependency Rule)**\n\n用一组同心圆来表示软件的不同领域。一般来说，越深入代表你的软件层次越高。外圆是战术是实现机制(mechanisms)，内圆的是核心原则(policy)。\n\nPolicy means the application logic.\n\nMechanism means the domain primitives.\n\n使此体系架构能够工作的关键是依赖规则。这条规则规定软件模块只能向内依赖，而里面的部分对外面的模块一无所知，也就是内部不依赖外部，而外部依赖内部。同样，在外面圈中使用的数据格式不应被内圈中使用，特别是如果这些数据格式是由外面一圈的框架生成的。我们不希望任何外圆的东西会影响内圈层\n\n2. **实体 (Entities)**\n\n实体封装的是整个企业范围内的业务核心原则(policy)，一个实体能是一个带有方法的对象，或者是一系列数据结构和函数，只要这个实体能够被不同的应用程序使用即可。\n\n如果你没有编写企业软件，只是编写简单的应用程序，这些实体就是应用的业务对象，它们封装着最普通的高级别业务规则，你不能希望这些实体对象被一个页面的分页导航功能改变，也不能被安全机制改变，操作实现层面的任何改变不能影响实体层，只有业务需求改变了才可以改变实体\n\n3. **用例 (Use case)**\n\n在这个层的软件包含只和应用相关的业务规则，它封装和实现系统的所有用例，这些用例会混合各种来自实体的各种数据流程，并且指导这些实体使用企业规则来完成用例的功能目标。\n\n我们并不期望改变这层会影响实体层. 我们也不期望这层被更外部如数据库 UI或普通框架影响，而这也正是我们分离出这一层来的原因所在。\n\n然而，应用层面的操作改变将会影响到这个用例层，如果需求中用例发生改变，这个层的代码就会随之发生改变。所以可以看到，这一层是和应用本身紧密相关的\n\n4. **接口适配器 (Interface Adapters)**\n\n这一层的软件基本都是一些适配器，主要用于将用例和实体中的数据转换为外部系统如数据库或Web使用的数据，在这个层次，可以包含一些GUI的MVC架构，表现视图 控制器都属于这个层，模型Model是从控制器传递到用例或从用例传递到视图的数据结构。\n\n通常在这个层数据被转换，从用例和实体使用的数据格式转换到持久层框架使用的数据，主要是为了存储到数据库中，这个圈层的代码是一点和数据库没有任何关系，如果数据库是一个SQL数据库， 这个层限制使用SQL语句以及任何和数据库打交道的事情。\n\n5. **框架和驱动器**\n\n最外面一圈通常是由一些框架和工具组成，如数据库Database, Web框架等. 通常你不必在这个层不必写太多代码，而是写些胶水性质的代码与内层进行粘结通讯。\n\n这个层是细节所在，Web技术是细节，数据库是细节，我们将这些实现细节放在外面以免它们对我们的业务规则造成影响伤害\n\n## ABP的分层实现\n\n在ABP项目中，层次划分如下。\n\n1. 应用层（Application项目）\n\n在领域驱动设计的分层式架构中，应用层作为应用系统的北向网关，对外提供业务外观的功能。在Abp模板项目中,Application项目也是编写主要用例代码的位置，开发者们在此定义与界面有关的数据行为，实现面向接口的开发实践。\n\n![图片](https://uploader.shimo.im/f/0nBaITGior4zlqO1.png!thumbnail)\n\n应用服务层包含应用服务，数据传输单元，工作单元等对象。\n\n* Application Service\n\n为面向用户界面层实现业务逻辑代码。例如需要为某些界面对象组装模型，通常会定义ApplicationService，并通过DTO对象，实现与界面表现层的数据交换。\n\n* Data Transfer Object (DTO)\n\n最常见的数据结构为DTO（数据传输对象），这是来源于马丁弗勒在《企业架构应用模式》中提到的名词，其主要作用为：\n\n>是一种设计模式之间传输数据的软件应用系统。 数据传输目标往往是数据访问对象从数据库中检索数据。\n\n在ABP的设计中，有两种不同类型的DTO，分别是用于新增、修改、删除的Input DTO，和用于查询的Output DTO。\n\n* Unit of Work：\n\n工作单元。工作单元与事务类似，封装了一系列原子级的数据库操作。  \n\n2. 核心层（Core项目）\n\n核心层包含领域实体、值对象、聚合根，以及领域上下文实现。\n\n* Entity(实体）：\n\n实体有别于传统意义上大家所理解的与数据库字段一一匹配的实体模型，在领域驱动设计中,虽然实体同样可能持久化到数据库，但实体包含属性和行为两种不同的抽象。\n\n例如，如果有一个实体为User，其中有一个属性为Phone，数据为086-132xxxxxxxx，我们有时需要判断该手机号码的国际代号，可能会添加一个新的判定 GetNationCode()，可以通过从Phone字段中取出086来实现，这就是一种通俗意义上的行为。\n\n* Value Object（值对象）:\n\n值对象无需持久化到数据库，往往是从其他实体或聚合中“剥离”出来的与某些聚合具备逻辑相关性或语义相关性的对象，有时值对象甚至只有个别属性。\n\n例如，上述实体，包含Phone字段，我们可以将整个Phone“剥离”为一个Telephone对象，该对象可包含PhoneNumber和NationCode字段。\n\n```c#\npublic class User\n{\n     public Telephone Phone{public get;private set;}\n}\npublic class Telephone\n{\n    public string  PhoneNumber {get;set;}\n     public string NationCode  {get;set;}\n}\n```\n* Aggregate & Aggregate Root（聚合，聚合根）：\n\n聚合是业务的最小工作单元，有时，一个实体就是一个小聚合，而为聚合对外提供访问机制的对象，就是聚合根。\n\n在领域驱动设计中，识别聚合也是一件非常重要的工作，有一组系统的方法论可以为我们提供参考。\n\n当然，事实上识别领域对象，包括且不限定于识别聚合、值对象、实体识别该对象的行为或（方法）本身是一件需要经验完成的工作，有时需要UML建模方法的广泛参与。\n\n有时，我们会习惯于通过属性赋值完成梭代码的过程，从而造成领域行为流失在业务逻辑层的问题，那么或许可以采取这样的方法：\n\n1、对象的创建，使用构造函数赋值，或工厂方法创建。\n\n2、将所有对于属性的访问级别都设置为\n\n```c#\npublic string Phone{public get;private set;}\n```\n然后再通过一个绑定手机号码的方法，来给这个对象设置手机号码。\n```c#\npublic string BindPhone(string phone)\n{\n}\n```\n将所有一切涉及到对Phone的操作，都只能通过规定的方法来赋值，这样可以实现我们开发过程中，无意识的通过属性赋值，可能导致的“领域行为”丢失的现象发生。\n这种方式可以使得对对象某些属性的操作，只能通过唯一的入口完成，符合单一职责原则的合理运用，如果要扩展方法，可以使用开闭原则来解决。\n\n但是，采用这种方式，得尽量避免出现：SetPhone(string phone) 这样的方法出现，毕竟这样的方法，其实和直接的属性赋值，没有任何区别。 \n\n* Repository（仓储）\n\n仓储封装了一系列对象数据库操作的方法，完成对象从数据库到对象的转换过程。在领域驱动设计中，一个仓储往往会负责一个聚合对象从数据库到创建的全过程。\n\n* Domain Service（领域服务）\n\n领域服务就是“实干家”，那些不适合在领域对象中出现，又不属于对象数据库操作的方法，又与领域对象息息相关的方法，都可以放到领域服务中实现。\n\n* Specification（规格定义）\n\n规范模式是一种特殊的软件设计模式，通过使用布尔逻辑将业务规则链接在一起，可以重新组合业务规则。\n\n实际上，它主要用于为实体或其他业务对象定义可重用的过滤器。\n\n3. 其他基础设施（EntityFrameworkCore，Web.Core,Web.Host项目)\n\nEntityFrameworkCore负责定义数据库上下文和对EFCore操作的一系列规则、例如种子数据的初始化等。\n\n![图片](https://uploader.shimo.im/f/D51RK39ZSnDFxvcz.png!thumbnail)\n\nWeb.Core：定义了应用程序的外观和接口。虽然从表面上看，Web.Core定义了作为Web访问入口的控制器方法和登录验证的逻辑，看起来像是用户表现层的东西，但是仔细想想，这些东西，何尝不是一种基础设施？\n\nWeb.Host：定义WEB应用程序的入口。 \n\n# 总结\n\n本文简述了ABP框架的前后端项目的分层结构，通过了解这些结构，将有助于我们在后续的实战中更快入手，为应用开发插上翅膀。\n\n","source":"_posts/技术/how-to-use-abp-part1-basic-desc.md","raw":"---\ntitle:  如何使用ABP进行软件开发（1）基础概览\ndate: 2020-6-24 20:05\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n# ABP框架简述\n\n## 1）简介\n\n在.NET众多的技术框架中，ABP框架（本系列中指aspnetboilerplate项目）以其独特的魅力吸引了一群优秀开发者广泛的使用。\n\n在该框架的赋能之下，开发者可根据需求通过官方网站【[https://aspnetboilerplate.com/Templates](https://aspnetboilerplate.com/Templates)】选择下载例如Vue/AngluarJS/MVC等不同类型的模板项目，轻松加入ABP开发者的队伍中，尽享基于ABP开发带来的乐趣。\n\n![图片](https://uploader.shimo.im/f/0I5mbgL5X2KWe3Ec.png!thumbnail)\n\nABP开发框架也提供了丰富的文档，能够为开发者带来许多便捷。目前ABP的文档网站为：\n\n官方文档：[https://aspnetboilerplate.com/Pages/Documents](https://aspnetboilerplate.com/Pages/Documents)\n\n文档库不可谓不全，加上国内众多的ABP开发者参与的活跃的技术圈子，使得学习成本只是在第一个项目中比较高，后期将会越来越平滑。\n\n## 2）现状\n\n当然，目前ABP的框架开发者和社区已经把更多的精力投入到了ABP.VNEXT开发框架，这个新框架以其DDD+微服务+模块化的理念获得了大量拥趸，使ABP框架的开发优先级已经开始逐渐降低。\n\n但这是因为ABP框架的功能已经成熟稳定，且ABP是一种增量式的架构设计，开发者在熟练掌握这种框架后，可以根据自己的需要进行方便的扩展，使其成为小项目架构选型中一种不错的备选方案。  \n\n当然，也存在一些弊端。例如由于ABP被称为.NET众多开发框架中面向领域驱动设计的最佳实践，而囿于领域驱动设计本身不低的门槛，使得学习的过程变得看起来非常陡峭；\n\n除此之外，ABP也广泛使用了目前Asp.NET/Asp.NET Core框架的大量比较新的特性，对于不少无法由于各种原因无法享受.NET技术飞速发展红利的传统开发者来说，无形中也提高了技术门槛。\n\n## 3）综述\n\n在这个系列中，本文计划分成三篇来介绍ABP框架，第一篇介绍ABP的基础概览，介绍基础知识，第二篇介绍ABP的模式实践，第三篇，试图介绍如何从更传统的三层甚至是单层+SQL的单层架构，如何迁移到ABP框架。\n\n（毕竟。。.NET遗留应用实在是太多了，拯救或不拯救？）\n\n# 代码结构结构\n\n## 基本文件夹简述\n\n当我们通过ABP模板项目的官方网站下载一个项目后，我们所获得的代码包的结构如下图所示，其中：\n\n![图片](https://uploader.shimo.im/f/Ju6P1J8FRkBtAhwt.png!thumbnail)![图片](https://uploader.shimo.im/f/52c6ytXJo2RPq4U4.png!thumbnail)\n\n* vue为使用iview框架构建的管理系统基本模板，该脚手架使用了yarn作为包管理器，并集成了vuex/axios等常用框架，并提供了用户，租户，权限三个基本功能的示例代码，开发者只需发挥聪明才智就能快速的通过该框架入手前端项目。\n* （当然，该项目广泛使用了typescript+面向对象的设计，似乎前端开发者。。普遍不擅长面向对象开发？）\n* aspnet-core则是一个完整的asp.netcore项目的快速开发脚手架。该脚手架集成了docker打包于一体，并包含基本的单元测试示例，使用了identity作为权限控制单元，使用swagger作为接口文档管理工具，集成了efcore、jwt等常用组件，对于开发者来说，基本上算是开箱即用了。\n# 前端vue项目\n\n打开vue文件夹之后，该项目的基本目录如下图所示。（src文件夹）\n\n![图片](https://uploader.shimo.im/f/hjXiUSLWHrkFiSoI.png!thumbnail)\n\n### lib文件夹\n\n定义了与abp+vue脚手架项目的基础组件和常见类库，封装了一系列基本方法。例如权限控制，数据请求，菜单操作，SignalR等基础组件的用法。\n\n### router文件夹\n\n定义了vue项目的路由规则，其中index.ts文件是项目的入口，router.ts文件定义了vue文件的路由规则。\n\n### store文件夹\n\n由于本项目使用了vuex框架，所以我们可以来看看对于store文件夹的介绍。\n\n在vuex框架中：\n\n>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。\n>Vuex 和单纯的全局对象有以下两点不同：\n>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 \n\n即vuex框架中，将原来的请求链路，抽象化为状态的变化，通过维护状态，使得数据的管理更加便捷，也易于扩展。\n\n### views文件夹\n\n定义了登录、首页、用户、角色、租户的基本页面，并提供了新增、查看、编辑、删除的代码示例。\n\n综上，该项目是一个结构清晰，逻辑缜密的前端框架，可以作为常见管理系统的脚手架。 \n\n# 后端项目\n\n![图片](https://uploader.shimo.im/f/sMZQOoDFjlQgIJrW.png!thumbnail)\n\n## 简介\n\n后端项目是一个遵循了领域驱动设计的分层，同时又符合Robert Martin在《代码整洁之道》提出的【整洁架构】。\n\n![图片](https://uploader.shimo.im/f/zYQDS5X0g86PUuIh.png!thumbnail)\n\n## 领域驱动设计简介 \n\n在领域驱动设计的分层设计中，共有四个功能分层，分别是：\n\n表示层（Presentation Layer）：为用户提供接口，使用应用层实现用户交互。\n\n应用层（Application Layer）：介于用户层和领域层之间，协调用户对象，完成对应的任务。\n\n领域层（Domain Layer）：包含业务对象和规则，是应用程序的心脏。\n\n基础设施层（Infrastructure Layer）：提供高层级的通用技术功能，主要使用第三方库完成。\n\n在后文中，基于abp对领域驱动设计的功能分层将进行多次、详细叙述，本小节不再赘述。\n\n## 整洁架构简介\n\n整洁架构是由Bob大叔提出的一种架构模型，来源于《整洁架构》这本书，顾名思义，其目的并不是为了介绍这一种优秀的架构本身，而是介绍如何设计一种整洁的架构，使得代码结构易于维护。\n\n![图片](https://uploader.shimo.im/f/C41YQfT1LaZ2qeLF.png!thumbnail)\n\n（整洁架构就是这样一个洋葱，所以也有人称它为“洋葱”架构）\n\n1. **依赖规则(Dependency Rule)**\n\n用一组同心圆来表示软件的不同领域。一般来说，越深入代表你的软件层次越高。外圆是战术是实现机制(mechanisms)，内圆的是核心原则(policy)。\n\nPolicy means the application logic.\n\nMechanism means the domain primitives.\n\n使此体系架构能够工作的关键是依赖规则。这条规则规定软件模块只能向内依赖，而里面的部分对外面的模块一无所知，也就是内部不依赖外部，而外部依赖内部。同样，在外面圈中使用的数据格式不应被内圈中使用，特别是如果这些数据格式是由外面一圈的框架生成的。我们不希望任何外圆的东西会影响内圈层\n\n2. **实体 (Entities)**\n\n实体封装的是整个企业范围内的业务核心原则(policy)，一个实体能是一个带有方法的对象，或者是一系列数据结构和函数，只要这个实体能够被不同的应用程序使用即可。\n\n如果你没有编写企业软件，只是编写简单的应用程序，这些实体就是应用的业务对象，它们封装着最普通的高级别业务规则，你不能希望这些实体对象被一个页面的分页导航功能改变，也不能被安全机制改变，操作实现层面的任何改变不能影响实体层，只有业务需求改变了才可以改变实体\n\n3. **用例 (Use case)**\n\n在这个层的软件包含只和应用相关的业务规则，它封装和实现系统的所有用例，这些用例会混合各种来自实体的各种数据流程，并且指导这些实体使用企业规则来完成用例的功能目标。\n\n我们并不期望改变这层会影响实体层. 我们也不期望这层被更外部如数据库 UI或普通框架影响，而这也正是我们分离出这一层来的原因所在。\n\n然而，应用层面的操作改变将会影响到这个用例层，如果需求中用例发生改变，这个层的代码就会随之发生改变。所以可以看到，这一层是和应用本身紧密相关的\n\n4. **接口适配器 (Interface Adapters)**\n\n这一层的软件基本都是一些适配器，主要用于将用例和实体中的数据转换为外部系统如数据库或Web使用的数据，在这个层次，可以包含一些GUI的MVC架构，表现视图 控制器都属于这个层，模型Model是从控制器传递到用例或从用例传递到视图的数据结构。\n\n通常在这个层数据被转换，从用例和实体使用的数据格式转换到持久层框架使用的数据，主要是为了存储到数据库中，这个圈层的代码是一点和数据库没有任何关系，如果数据库是一个SQL数据库， 这个层限制使用SQL语句以及任何和数据库打交道的事情。\n\n5. **框架和驱动器**\n\n最外面一圈通常是由一些框架和工具组成，如数据库Database, Web框架等. 通常你不必在这个层不必写太多代码，而是写些胶水性质的代码与内层进行粘结通讯。\n\n这个层是细节所在，Web技术是细节，数据库是细节，我们将这些实现细节放在外面以免它们对我们的业务规则造成影响伤害\n\n## ABP的分层实现\n\n在ABP项目中，层次划分如下。\n\n1. 应用层（Application项目）\n\n在领域驱动设计的分层式架构中，应用层作为应用系统的北向网关，对外提供业务外观的功能。在Abp模板项目中,Application项目也是编写主要用例代码的位置，开发者们在此定义与界面有关的数据行为，实现面向接口的开发实践。\n\n![图片](https://uploader.shimo.im/f/0nBaITGior4zlqO1.png!thumbnail)\n\n应用服务层包含应用服务，数据传输单元，工作单元等对象。\n\n* Application Service\n\n为面向用户界面层实现业务逻辑代码。例如需要为某些界面对象组装模型，通常会定义ApplicationService，并通过DTO对象，实现与界面表现层的数据交换。\n\n* Data Transfer Object (DTO)\n\n最常见的数据结构为DTO（数据传输对象），这是来源于马丁弗勒在《企业架构应用模式》中提到的名词，其主要作用为：\n\n>是一种设计模式之间传输数据的软件应用系统。 数据传输目标往往是数据访问对象从数据库中检索数据。\n\n在ABP的设计中，有两种不同类型的DTO，分别是用于新增、修改、删除的Input DTO，和用于查询的Output DTO。\n\n* Unit of Work：\n\n工作单元。工作单元与事务类似，封装了一系列原子级的数据库操作。  \n\n2. 核心层（Core项目）\n\n核心层包含领域实体、值对象、聚合根，以及领域上下文实现。\n\n* Entity(实体）：\n\n实体有别于传统意义上大家所理解的与数据库字段一一匹配的实体模型，在领域驱动设计中,虽然实体同样可能持久化到数据库，但实体包含属性和行为两种不同的抽象。\n\n例如，如果有一个实体为User，其中有一个属性为Phone，数据为086-132xxxxxxxx，我们有时需要判断该手机号码的国际代号，可能会添加一个新的判定 GetNationCode()，可以通过从Phone字段中取出086来实现，这就是一种通俗意义上的行为。\n\n* Value Object（值对象）:\n\n值对象无需持久化到数据库，往往是从其他实体或聚合中“剥离”出来的与某些聚合具备逻辑相关性或语义相关性的对象，有时值对象甚至只有个别属性。\n\n例如，上述实体，包含Phone字段，我们可以将整个Phone“剥离”为一个Telephone对象，该对象可包含PhoneNumber和NationCode字段。\n\n```c#\npublic class User\n{\n     public Telephone Phone{public get;private set;}\n}\npublic class Telephone\n{\n    public string  PhoneNumber {get;set;}\n     public string NationCode  {get;set;}\n}\n```\n* Aggregate & Aggregate Root（聚合，聚合根）：\n\n聚合是业务的最小工作单元，有时，一个实体就是一个小聚合，而为聚合对外提供访问机制的对象，就是聚合根。\n\n在领域驱动设计中，识别聚合也是一件非常重要的工作，有一组系统的方法论可以为我们提供参考。\n\n当然，事实上识别领域对象，包括且不限定于识别聚合、值对象、实体识别该对象的行为或（方法）本身是一件需要经验完成的工作，有时需要UML建模方法的广泛参与。\n\n有时，我们会习惯于通过属性赋值完成梭代码的过程，从而造成领域行为流失在业务逻辑层的问题，那么或许可以采取这样的方法：\n\n1、对象的创建，使用构造函数赋值，或工厂方法创建。\n\n2、将所有对于属性的访问级别都设置为\n\n```c#\npublic string Phone{public get;private set;}\n```\n然后再通过一个绑定手机号码的方法，来给这个对象设置手机号码。\n```c#\npublic string BindPhone(string phone)\n{\n}\n```\n将所有一切涉及到对Phone的操作，都只能通过规定的方法来赋值，这样可以实现我们开发过程中，无意识的通过属性赋值，可能导致的“领域行为”丢失的现象发生。\n这种方式可以使得对对象某些属性的操作，只能通过唯一的入口完成，符合单一职责原则的合理运用，如果要扩展方法，可以使用开闭原则来解决。\n\n但是，采用这种方式，得尽量避免出现：SetPhone(string phone) 这样的方法出现，毕竟这样的方法，其实和直接的属性赋值，没有任何区别。 \n\n* Repository（仓储）\n\n仓储封装了一系列对象数据库操作的方法，完成对象从数据库到对象的转换过程。在领域驱动设计中，一个仓储往往会负责一个聚合对象从数据库到创建的全过程。\n\n* Domain Service（领域服务）\n\n领域服务就是“实干家”，那些不适合在领域对象中出现，又不属于对象数据库操作的方法，又与领域对象息息相关的方法，都可以放到领域服务中实现。\n\n* Specification（规格定义）\n\n规范模式是一种特殊的软件设计模式，通过使用布尔逻辑将业务规则链接在一起，可以重新组合业务规则。\n\n实际上，它主要用于为实体或其他业务对象定义可重用的过滤器。\n\n3. 其他基础设施（EntityFrameworkCore，Web.Core,Web.Host项目)\n\nEntityFrameworkCore负责定义数据库上下文和对EFCore操作的一系列规则、例如种子数据的初始化等。\n\n![图片](https://uploader.shimo.im/f/D51RK39ZSnDFxvcz.png!thumbnail)\n\nWeb.Core：定义了应用程序的外观和接口。虽然从表面上看，Web.Core定义了作为Web访问入口的控制器方法和登录验证的逻辑，看起来像是用户表现层的东西，但是仔细想想，这些东西，何尝不是一种基础设施？\n\nWeb.Host：定义WEB应用程序的入口。 \n\n# 总结\n\n本文简述了ABP框架的前后端项目的分层结构，通过了解这些结构，将有助于我们在后续的实战中更快入手，为应用开发插上翅膀。\n\n","slug":"技术/how-to-use-abp-part1-basic-desc","published":1,"updated":"2020-06-25T14:00:25.873Z","_id":"ckbuujt6m0007n4vimwa8lxgf","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"ABP框架简述\"><a href=\"#ABP框架简述\" class=\"headerlink\" title=\"ABP框架简述\"></a>ABP框架简述</h1><h2 id=\"1）简介\"><a href=\"#1）简介\" class=\"headerlink\" title=\"1）简介\"></a>1）简介</h2><p>在.NET众多的技术框架中，ABP框架（本系列中指aspnetboilerplate项目）以其独特的魅力吸引了一群优秀开发者广泛的使用。</p>\n<p>在该框架的赋能之下，开发者可根据需求通过官方网站【<a href=\"https://aspnetboilerplate.com/Templates\" target=\"_blank\" rel=\"noopener\">https://aspnetboilerplate.com/Templates</a>】选择下载例如Vue/AngluarJS/MVC等不同类型的模板项目，轻松加入ABP开发者的队伍中，尽享基于ABP开发带来的乐趣。</p>\n<p><img src=\"https://uploader.shimo.im/f/0I5mbgL5X2KWe3Ec.png!thumbnail\" alt=\"图片\"></p>\n<p>ABP开发框架也提供了丰富的文档，能够为开发者带来许多便捷。目前ABP的文档网站为：</p>\n<p>官方文档：<a href=\"https://aspnetboilerplate.com/Pages/Documents\" target=\"_blank\" rel=\"noopener\">https://aspnetboilerplate.com/Pages/Documents</a></p>\n<p>文档库不可谓不全，加上国内众多的ABP开发者参与的活跃的技术圈子，使得学习成本只是在第一个项目中比较高，后期将会越来越平滑。</p>\n<h2 id=\"2）现状\"><a href=\"#2）现状\" class=\"headerlink\" title=\"2）现状\"></a>2）现状</h2><p>当然，目前ABP的框架开发者和社区已经把更多的精力投入到了ABP.VNEXT开发框架，这个新框架以其DDD+微服务+模块化的理念获得了大量拥趸，使ABP框架的开发优先级已经开始逐渐降低。</p>\n<p>但这是因为ABP框架的功能已经成熟稳定，且ABP是一种增量式的架构设计，开发者在熟练掌握这种框架后，可以根据自己的需要进行方便的扩展，使其成为小项目架构选型中一种不错的备选方案。  </p>\n<p>当然，也存在一些弊端。例如由于ABP被称为.NET众多开发框架中面向领域驱动设计的最佳实践，而囿于领域驱动设计本身不低的门槛，使得学习的过程变得看起来非常陡峭；</p>\n<p>除此之外，ABP也广泛使用了目前Asp.NET/Asp.NET Core框架的大量比较新的特性，对于不少无法由于各种原因无法享受.NET技术飞速发展红利的传统开发者来说，无形中也提高了技术门槛。</p>\n<h2 id=\"3）综述\"><a href=\"#3）综述\" class=\"headerlink\" title=\"3）综述\"></a>3）综述</h2><p>在这个系列中，本文计划分成三篇来介绍ABP框架，第一篇介绍ABP的基础概览，介绍基础知识，第二篇介绍ABP的模式实践，第三篇，试图介绍如何从更传统的三层甚至是单层+SQL的单层架构，如何迁移到ABP框架。</p>\n<p>（毕竟。。.NET遗留应用实在是太多了，拯救或不拯救？）</p>\n<h1 id=\"代码结构结构\"><a href=\"#代码结构结构\" class=\"headerlink\" title=\"代码结构结构\"></a>代码结构结构</h1><h2 id=\"基本文件夹简述\"><a href=\"#基本文件夹简述\" class=\"headerlink\" title=\"基本文件夹简述\"></a>基本文件夹简述</h2><p>当我们通过ABP模板项目的官方网站下载一个项目后，我们所获得的代码包的结构如下图所示，其中：</p>\n<p><img src=\"https://uploader.shimo.im/f/Ju6P1J8FRkBtAhwt.png!thumbnail\" alt=\"图片\">)<img src=\"https://uploader.shimo.im/f/52c6ytXJo2RPq4U4.png!thumbnail\" alt=\"图片\"></p>\n<ul>\n<li>vue为使用iview框架构建的管理系统基本模板，该脚手架使用了yarn作为包管理器，并集成了vuex/axios等常用框架，并提供了用户，租户，权限三个基本功能的示例代码，开发者只需发挥聪明才智就能快速的通过该框架入手前端项目。</li>\n<li>（当然，该项目广泛使用了typescript+面向对象的设计，似乎前端开发者。。普遍不擅长面向对象开发？）</li>\n<li>aspnet-core则是一个完整的asp.netcore项目的快速开发脚手架。该脚手架集成了docker打包于一体，并包含基本的单元测试示例，使用了identity作为权限控制单元，使用swagger作为接口文档管理工具，集成了efcore、jwt等常用组件，对于开发者来说，基本上算是开箱即用了。<h1 id=\"前端vue项目\"><a href=\"#前端vue项目\" class=\"headerlink\" title=\"前端vue项目\"></a>前端vue项目</h1></li>\n</ul>\n<p>打开vue文件夹之后，该项目的基本目录如下图所示。（src文件夹）</p>\n<p><img src=\"https://uploader.shimo.im/f/hjXiUSLWHrkFiSoI.png!thumbnail\" alt=\"图片\"></p>\n<h3 id=\"lib文件夹\"><a href=\"#lib文件夹\" class=\"headerlink\" title=\"lib文件夹\"></a>lib文件夹</h3><p>定义了与abp+vue脚手架项目的基础组件和常见类库，封装了一系列基本方法。例如权限控制，数据请求，菜单操作，SignalR等基础组件的用法。</p>\n<h3 id=\"router文件夹\"><a href=\"#router文件夹\" class=\"headerlink\" title=\"router文件夹\"></a>router文件夹</h3><p>定义了vue项目的路由规则，其中index.ts文件是项目的入口，router.ts文件定义了vue文件的路由规则。</p>\n<h3 id=\"store文件夹\"><a href=\"#store文件夹\" class=\"headerlink\" title=\"store文件夹\"></a>store文件夹</h3><p>由于本项目使用了vuex框架，所以我们可以来看看对于store文件夹的介绍。</p>\n<p>在vuex框架中：</p>\n<blockquote>\n<p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。<br>Vuex 和单纯的全局对象有以下两点不同：<br>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 </p>\n</blockquote>\n<p>即vuex框架中，将原来的请求链路，抽象化为状态的变化，通过维护状态，使得数据的管理更加便捷，也易于扩展。</p>\n<h3 id=\"views文件夹\"><a href=\"#views文件夹\" class=\"headerlink\" title=\"views文件夹\"></a>views文件夹</h3><p>定义了登录、首页、用户、角色、租户的基本页面，并提供了新增、查看、编辑、删除的代码示例。</p>\n<p>综上，该项目是一个结构清晰，逻辑缜密的前端框架，可以作为常见管理系统的脚手架。 </p>\n<h1 id=\"后端项目\"><a href=\"#后端项目\" class=\"headerlink\" title=\"后端项目\"></a>后端项目</h1><p><img src=\"https://uploader.shimo.im/f/sMZQOoDFjlQgIJrW.png!thumbnail\" alt=\"图片\"></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>后端项目是一个遵循了领域驱动设计的分层，同时又符合Robert Martin在《代码整洁之道》提出的【整洁架构】。</p>\n<p><img src=\"https://uploader.shimo.im/f/zYQDS5X0g86PUuIh.png!thumbnail\" alt=\"图片\"></p>\n<h2 id=\"领域驱动设计简介\"><a href=\"#领域驱动设计简介\" class=\"headerlink\" title=\"领域驱动设计简介\"></a>领域驱动设计简介</h2><p>在领域驱动设计的分层设计中，共有四个功能分层，分别是：</p>\n<p>表示层（Presentation Layer）：为用户提供接口，使用应用层实现用户交互。</p>\n<p>应用层（Application Layer）：介于用户层和领域层之间，协调用户对象，完成对应的任务。</p>\n<p>领域层（Domain Layer）：包含业务对象和规则，是应用程序的心脏。</p>\n<p>基础设施层（Infrastructure Layer）：提供高层级的通用技术功能，主要使用第三方库完成。</p>\n<p>在后文中，基于abp对领域驱动设计的功能分层将进行多次、详细叙述，本小节不再赘述。</p>\n<h2 id=\"整洁架构简介\"><a href=\"#整洁架构简介\" class=\"headerlink\" title=\"整洁架构简介\"></a>整洁架构简介</h2><p>整洁架构是由Bob大叔提出的一种架构模型，来源于《整洁架构》这本书，顾名思义，其目的并不是为了介绍这一种优秀的架构本身，而是介绍如何设计一种整洁的架构，使得代码结构易于维护。</p>\n<p><img src=\"https://uploader.shimo.im/f/C41YQfT1LaZ2qeLF.png!thumbnail\" alt=\"图片\"></p>\n<p>（整洁架构就是这样一个洋葱，所以也有人称它为“洋葱”架构）</p>\n<ol>\n<li><strong>依赖规则(Dependency Rule)</strong></li>\n</ol>\n<p>用一组同心圆来表示软件的不同领域。一般来说，越深入代表你的软件层次越高。外圆是战术是实现机制(mechanisms)，内圆的是核心原则(policy)。</p>\n<p>Policy means the application logic.</p>\n<p>Mechanism means the domain primitives.</p>\n<p>使此体系架构能够工作的关键是依赖规则。这条规则规定软件模块只能向内依赖，而里面的部分对外面的模块一无所知，也就是内部不依赖外部，而外部依赖内部。同样，在外面圈中使用的数据格式不应被内圈中使用，特别是如果这些数据格式是由外面一圈的框架生成的。我们不希望任何外圆的东西会影响内圈层</p>\n<ol start=\"2\">\n<li><strong>实体 (Entities)</strong></li>\n</ol>\n<p>实体封装的是整个企业范围内的业务核心原则(policy)，一个实体能是一个带有方法的对象，或者是一系列数据结构和函数，只要这个实体能够被不同的应用程序使用即可。</p>\n<p>如果你没有编写企业软件，只是编写简单的应用程序，这些实体就是应用的业务对象，它们封装着最普通的高级别业务规则，你不能希望这些实体对象被一个页面的分页导航功能改变，也不能被安全机制改变，操作实现层面的任何改变不能影响实体层，只有业务需求改变了才可以改变实体</p>\n<ol start=\"3\">\n<li><strong>用例 (Use case)</strong></li>\n</ol>\n<p>在这个层的软件包含只和应用相关的业务规则，它封装和实现系统的所有用例，这些用例会混合各种来自实体的各种数据流程，并且指导这些实体使用企业规则来完成用例的功能目标。</p>\n<p>我们并不期望改变这层会影响实体层. 我们也不期望这层被更外部如数据库 UI或普通框架影响，而这也正是我们分离出这一层来的原因所在。</p>\n<p>然而，应用层面的操作改变将会影响到这个用例层，如果需求中用例发生改变，这个层的代码就会随之发生改变。所以可以看到，这一层是和应用本身紧密相关的</p>\n<ol start=\"4\">\n<li><strong>接口适配器 (Interface Adapters)</strong></li>\n</ol>\n<p>这一层的软件基本都是一些适配器，主要用于将用例和实体中的数据转换为外部系统如数据库或Web使用的数据，在这个层次，可以包含一些GUI的MVC架构，表现视图 控制器都属于这个层，模型Model是从控制器传递到用例或从用例传递到视图的数据结构。</p>\n<p>通常在这个层数据被转换，从用例和实体使用的数据格式转换到持久层框架使用的数据，主要是为了存储到数据库中，这个圈层的代码是一点和数据库没有任何关系，如果数据库是一个SQL数据库， 这个层限制使用SQL语句以及任何和数据库打交道的事情。</p>\n<ol start=\"5\">\n<li><strong>框架和驱动器</strong></li>\n</ol>\n<p>最外面一圈通常是由一些框架和工具组成，如数据库Database, Web框架等. 通常你不必在这个层不必写太多代码，而是写些胶水性质的代码与内层进行粘结通讯。</p>\n<p>这个层是细节所在，Web技术是细节，数据库是细节，我们将这些实现细节放在外面以免它们对我们的业务规则造成影响伤害</p>\n<h2 id=\"ABP的分层实现\"><a href=\"#ABP的分层实现\" class=\"headerlink\" title=\"ABP的分层实现\"></a>ABP的分层实现</h2><p>在ABP项目中，层次划分如下。</p>\n<ol>\n<li>应用层（Application项目）</li>\n</ol>\n<p>在领域驱动设计的分层式架构中，应用层作为应用系统的北向网关，对外提供业务外观的功能。在Abp模板项目中,Application项目也是编写主要用例代码的位置，开发者们在此定义与界面有关的数据行为，实现面向接口的开发实践。</p>\n<p><img src=\"https://uploader.shimo.im/f/0nBaITGior4zlqO1.png!thumbnail\" alt=\"图片\"></p>\n<p>应用服务层包含应用服务，数据传输单元，工作单元等对象。</p>\n<ul>\n<li>Application Service</li>\n</ul>\n<p>为面向用户界面层实现业务逻辑代码。例如需要为某些界面对象组装模型，通常会定义ApplicationService，并通过DTO对象，实现与界面表现层的数据交换。</p>\n<ul>\n<li>Data Transfer Object (DTO)</li>\n</ul>\n<p>最常见的数据结构为DTO（数据传输对象），这是来源于马丁弗勒在《企业架构应用模式》中提到的名词，其主要作用为：</p>\n<blockquote>\n<p>是一种设计模式之间传输数据的软件应用系统。 数据传输目标往往是数据访问对象从数据库中检索数据。</p>\n</blockquote>\n<p>在ABP的设计中，有两种不同类型的DTO，分别是用于新增、修改、删除的Input DTO，和用于查询的Output DTO。</p>\n<ul>\n<li>Unit of Work：</li>\n</ul>\n<p>工作单元。工作单元与事务类似，封装了一系列原子级的数据库操作。  </p>\n<ol start=\"2\">\n<li>核心层（Core项目）</li>\n</ol>\n<p>核心层包含领域实体、值对象、聚合根，以及领域上下文实现。</p>\n<ul>\n<li>Entity(实体）：</li>\n</ul>\n<p>实体有别于传统意义上大家所理解的与数据库字段一一匹配的实体模型，在领域驱动设计中,虽然实体同样可能持久化到数据库，但实体包含属性和行为两种不同的抽象。</p>\n<p>例如，如果有一个实体为User，其中有一个属性为Phone，数据为086-132xxxxxxxx，我们有时需要判断该手机号码的国际代号，可能会添加一个新的判定 GetNationCode()，可以通过从Phone字段中取出086来实现，这就是一种通俗意义上的行为。</p>\n<ul>\n<li>Value Object（值对象）:</li>\n</ul>\n<p>值对象无需持久化到数据库，往往是从其他实体或聚合中“剥离”出来的与某些聚合具备逻辑相关性或语义相关性的对象，有时值对象甚至只有个别属性。</p>\n<p>例如，上述实体，包含Phone字段，我们可以将整个Phone“剥离”为一个Telephone对象，该对象可包含PhoneNumber和NationCode字段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class User</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     public Telephone Phone&#123;public get;private set;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Telephone</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public string  PhoneNumber &#123;get;set;&#125;</span><br><span class=\"line\">     public string NationCode  &#123;get;set;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Aggregate &amp; Aggregate Root（聚合，聚合根）：</li>\n</ul>\n<p>聚合是业务的最小工作单元，有时，一个实体就是一个小聚合，而为聚合对外提供访问机制的对象，就是聚合根。</p>\n<p>在领域驱动设计中，识别聚合也是一件非常重要的工作，有一组系统的方法论可以为我们提供参考。</p>\n<p>当然，事实上识别领域对象，包括且不限定于识别聚合、值对象、实体识别该对象的行为或（方法）本身是一件需要经验完成的工作，有时需要UML建模方法的广泛参与。</p>\n<p>有时，我们会习惯于通过属性赋值完成梭代码的过程，从而造成领域行为流失在业务逻辑层的问题，那么或许可以采取这样的方法：</p>\n<p>1、对象的创建，使用构造函数赋值，或工厂方法创建。</p>\n<p>2、将所有对于属性的访问级别都设置为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string Phone&#123;public get;private set;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后再通过一个绑定手机号码的方法，来给这个对象设置手机号码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string BindPhone(string phone)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将所有一切涉及到对Phone的操作，都只能通过规定的方法来赋值，这样可以实现我们开发过程中，无意识的通过属性赋值，可能导致的“领域行为”丢失的现象发生。<br>这种方式可以使得对对象某些属性的操作，只能通过唯一的入口完成，符合单一职责原则的合理运用，如果要扩展方法，可以使用开闭原则来解决。</p>\n<p>但是，采用这种方式，得尽量避免出现：SetPhone(string phone) 这样的方法出现，毕竟这样的方法，其实和直接的属性赋值，没有任何区别。 </p>\n<ul>\n<li>Repository（仓储）</li>\n</ul>\n<p>仓储封装了一系列对象数据库操作的方法，完成对象从数据库到对象的转换过程。在领域驱动设计中，一个仓储往往会负责一个聚合对象从数据库到创建的全过程。</p>\n<ul>\n<li>Domain Service（领域服务）</li>\n</ul>\n<p>领域服务就是“实干家”，那些不适合在领域对象中出现，又不属于对象数据库操作的方法，又与领域对象息息相关的方法，都可以放到领域服务中实现。</p>\n<ul>\n<li>Specification（规格定义）</li>\n</ul>\n<p>规范模式是一种特殊的软件设计模式，通过使用布尔逻辑将业务规则链接在一起，可以重新组合业务规则。</p>\n<p>实际上，它主要用于为实体或其他业务对象定义可重用的过滤器。</p>\n<ol start=\"3\">\n<li>其他基础设施（EntityFrameworkCore，Web.Core,Web.Host项目)</li>\n</ol>\n<p>EntityFrameworkCore负责定义数据库上下文和对EFCore操作的一系列规则、例如种子数据的初始化等。</p>\n<p><img src=\"https://uploader.shimo.im/f/D51RK39ZSnDFxvcz.png!thumbnail\" alt=\"图片\"></p>\n<p>Web.Core：定义了应用程序的外观和接口。虽然从表面上看，Web.Core定义了作为Web访问入口的控制器方法和登录验证的逻辑，看起来像是用户表现层的东西，但是仔细想想，这些东西，何尝不是一种基础设施？</p>\n<p>Web.Host：定义WEB应用程序的入口。 </p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文简述了ABP框架的前后端项目的分层结构，通过了解这些结构，将有助于我们在后续的实战中更快入手，为应用开发插上翅膀。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ABP框架简述\"><a href=\"#ABP框架简述\" class=\"headerlink\" title=\"ABP框架简述\"></a>ABP框架简述</h1><h2 id=\"1）简介\"><a href=\"#1）简介\" class=\"headerlink\" title=\"1）简介\"></a>1）简介</h2><p>在.NET众多的技术框架中，ABP框架（本系列中指aspnetboilerplate项目）以其独特的魅力吸引了一群优秀开发者广泛的使用。</p>\n<p>在该框架的赋能之下，开发者可根据需求通过官方网站【<a href=\"https://aspnetboilerplate.com/Templates\" target=\"_blank\" rel=\"noopener\">https://aspnetboilerplate.com/Templates</a>】选择下载例如Vue/AngluarJS/MVC等不同类型的模板项目，轻松加入ABP开发者的队伍中，尽享基于ABP开发带来的乐趣。</p>\n<p><img src=\"https://uploader.shimo.im/f/0I5mbgL5X2KWe3Ec.png!thumbnail\" alt=\"图片\"></p>\n<p>ABP开发框架也提供了丰富的文档，能够为开发者带来许多便捷。目前ABP的文档网站为：</p>\n<p>官方文档：<a href=\"https://aspnetboilerplate.com/Pages/Documents\" target=\"_blank\" rel=\"noopener\">https://aspnetboilerplate.com/Pages/Documents</a></p>\n<p>文档库不可谓不全，加上国内众多的ABP开发者参与的活跃的技术圈子，使得学习成本只是在第一个项目中比较高，后期将会越来越平滑。</p>\n<h2 id=\"2）现状\"><a href=\"#2）现状\" class=\"headerlink\" title=\"2）现状\"></a>2）现状</h2><p>当然，目前ABP的框架开发者和社区已经把更多的精力投入到了ABP.VNEXT开发框架，这个新框架以其DDD+微服务+模块化的理念获得了大量拥趸，使ABP框架的开发优先级已经开始逐渐降低。</p>\n<p>但这是因为ABP框架的功能已经成熟稳定，且ABP是一种增量式的架构设计，开发者在熟练掌握这种框架后，可以根据自己的需要进行方便的扩展，使其成为小项目架构选型中一种不错的备选方案。  </p>\n<p>当然，也存在一些弊端。例如由于ABP被称为.NET众多开发框架中面向领域驱动设计的最佳实践，而囿于领域驱动设计本身不低的门槛，使得学习的过程变得看起来非常陡峭；</p>\n<p>除此之外，ABP也广泛使用了目前Asp.NET/Asp.NET Core框架的大量比较新的特性，对于不少无法由于各种原因无法享受.NET技术飞速发展红利的传统开发者来说，无形中也提高了技术门槛。</p>\n<h2 id=\"3）综述\"><a href=\"#3）综述\" class=\"headerlink\" title=\"3）综述\"></a>3）综述</h2><p>在这个系列中，本文计划分成三篇来介绍ABP框架，第一篇介绍ABP的基础概览，介绍基础知识，第二篇介绍ABP的模式实践，第三篇，试图介绍如何从更传统的三层甚至是单层+SQL的单层架构，如何迁移到ABP框架。</p>\n<p>（毕竟。。.NET遗留应用实在是太多了，拯救或不拯救？）</p>\n<h1 id=\"代码结构结构\"><a href=\"#代码结构结构\" class=\"headerlink\" title=\"代码结构结构\"></a>代码结构结构</h1><h2 id=\"基本文件夹简述\"><a href=\"#基本文件夹简述\" class=\"headerlink\" title=\"基本文件夹简述\"></a>基本文件夹简述</h2><p>当我们通过ABP模板项目的官方网站下载一个项目后，我们所获得的代码包的结构如下图所示，其中：</p>\n<p><img src=\"https://uploader.shimo.im/f/Ju6P1J8FRkBtAhwt.png!thumbnail\" alt=\"图片\">)<img src=\"https://uploader.shimo.im/f/52c6ytXJo2RPq4U4.png!thumbnail\" alt=\"图片\"></p>\n<ul>\n<li>vue为使用iview框架构建的管理系统基本模板，该脚手架使用了yarn作为包管理器，并集成了vuex/axios等常用框架，并提供了用户，租户，权限三个基本功能的示例代码，开发者只需发挥聪明才智就能快速的通过该框架入手前端项目。</li>\n<li>（当然，该项目广泛使用了typescript+面向对象的设计，似乎前端开发者。。普遍不擅长面向对象开发？）</li>\n<li>aspnet-core则是一个完整的asp.netcore项目的快速开发脚手架。该脚手架集成了docker打包于一体，并包含基本的单元测试示例，使用了identity作为权限控制单元，使用swagger作为接口文档管理工具，集成了efcore、jwt等常用组件，对于开发者来说，基本上算是开箱即用了。<h1 id=\"前端vue项目\"><a href=\"#前端vue项目\" class=\"headerlink\" title=\"前端vue项目\"></a>前端vue项目</h1></li>\n</ul>\n<p>打开vue文件夹之后，该项目的基本目录如下图所示。（src文件夹）</p>\n<p><img src=\"https://uploader.shimo.im/f/hjXiUSLWHrkFiSoI.png!thumbnail\" alt=\"图片\"></p>\n<h3 id=\"lib文件夹\"><a href=\"#lib文件夹\" class=\"headerlink\" title=\"lib文件夹\"></a>lib文件夹</h3><p>定义了与abp+vue脚手架项目的基础组件和常见类库，封装了一系列基本方法。例如权限控制，数据请求，菜单操作，SignalR等基础组件的用法。</p>\n<h3 id=\"router文件夹\"><a href=\"#router文件夹\" class=\"headerlink\" title=\"router文件夹\"></a>router文件夹</h3><p>定义了vue项目的路由规则，其中index.ts文件是项目的入口，router.ts文件定义了vue文件的路由规则。</p>\n<h3 id=\"store文件夹\"><a href=\"#store文件夹\" class=\"headerlink\" title=\"store文件夹\"></a>store文件夹</h3><p>由于本项目使用了vuex框架，所以我们可以来看看对于store文件夹的介绍。</p>\n<p>在vuex框架中：</p>\n<blockquote>\n<p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。<br>Vuex 和单纯的全局对象有以下两点不同：<br>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 </p>\n</blockquote>\n<p>即vuex框架中，将原来的请求链路，抽象化为状态的变化，通过维护状态，使得数据的管理更加便捷，也易于扩展。</p>\n<h3 id=\"views文件夹\"><a href=\"#views文件夹\" class=\"headerlink\" title=\"views文件夹\"></a>views文件夹</h3><p>定义了登录、首页、用户、角色、租户的基本页面，并提供了新增、查看、编辑、删除的代码示例。</p>\n<p>综上，该项目是一个结构清晰，逻辑缜密的前端框架，可以作为常见管理系统的脚手架。 </p>\n<h1 id=\"后端项目\"><a href=\"#后端项目\" class=\"headerlink\" title=\"后端项目\"></a>后端项目</h1><p><img src=\"https://uploader.shimo.im/f/sMZQOoDFjlQgIJrW.png!thumbnail\" alt=\"图片\"></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>后端项目是一个遵循了领域驱动设计的分层，同时又符合Robert Martin在《代码整洁之道》提出的【整洁架构】。</p>\n<p><img src=\"https://uploader.shimo.im/f/zYQDS5X0g86PUuIh.png!thumbnail\" alt=\"图片\"></p>\n<h2 id=\"领域驱动设计简介\"><a href=\"#领域驱动设计简介\" class=\"headerlink\" title=\"领域驱动设计简介\"></a>领域驱动设计简介</h2><p>在领域驱动设计的分层设计中，共有四个功能分层，分别是：</p>\n<p>表示层（Presentation Layer）：为用户提供接口，使用应用层实现用户交互。</p>\n<p>应用层（Application Layer）：介于用户层和领域层之间，协调用户对象，完成对应的任务。</p>\n<p>领域层（Domain Layer）：包含业务对象和规则，是应用程序的心脏。</p>\n<p>基础设施层（Infrastructure Layer）：提供高层级的通用技术功能，主要使用第三方库完成。</p>\n<p>在后文中，基于abp对领域驱动设计的功能分层将进行多次、详细叙述，本小节不再赘述。</p>\n<h2 id=\"整洁架构简介\"><a href=\"#整洁架构简介\" class=\"headerlink\" title=\"整洁架构简介\"></a>整洁架构简介</h2><p>整洁架构是由Bob大叔提出的一种架构模型，来源于《整洁架构》这本书，顾名思义，其目的并不是为了介绍这一种优秀的架构本身，而是介绍如何设计一种整洁的架构，使得代码结构易于维护。</p>\n<p><img src=\"https://uploader.shimo.im/f/C41YQfT1LaZ2qeLF.png!thumbnail\" alt=\"图片\"></p>\n<p>（整洁架构就是这样一个洋葱，所以也有人称它为“洋葱”架构）</p>\n<ol>\n<li><strong>依赖规则(Dependency Rule)</strong></li>\n</ol>\n<p>用一组同心圆来表示软件的不同领域。一般来说，越深入代表你的软件层次越高。外圆是战术是实现机制(mechanisms)，内圆的是核心原则(policy)。</p>\n<p>Policy means the application logic.</p>\n<p>Mechanism means the domain primitives.</p>\n<p>使此体系架构能够工作的关键是依赖规则。这条规则规定软件模块只能向内依赖，而里面的部分对外面的模块一无所知，也就是内部不依赖外部，而外部依赖内部。同样，在外面圈中使用的数据格式不应被内圈中使用，特别是如果这些数据格式是由外面一圈的框架生成的。我们不希望任何外圆的东西会影响内圈层</p>\n<ol start=\"2\">\n<li><strong>实体 (Entities)</strong></li>\n</ol>\n<p>实体封装的是整个企业范围内的业务核心原则(policy)，一个实体能是一个带有方法的对象，或者是一系列数据结构和函数，只要这个实体能够被不同的应用程序使用即可。</p>\n<p>如果你没有编写企业软件，只是编写简单的应用程序，这些实体就是应用的业务对象，它们封装着最普通的高级别业务规则，你不能希望这些实体对象被一个页面的分页导航功能改变，也不能被安全机制改变，操作实现层面的任何改变不能影响实体层，只有业务需求改变了才可以改变实体</p>\n<ol start=\"3\">\n<li><strong>用例 (Use case)</strong></li>\n</ol>\n<p>在这个层的软件包含只和应用相关的业务规则，它封装和实现系统的所有用例，这些用例会混合各种来自实体的各种数据流程，并且指导这些实体使用企业规则来完成用例的功能目标。</p>\n<p>我们并不期望改变这层会影响实体层. 我们也不期望这层被更外部如数据库 UI或普通框架影响，而这也正是我们分离出这一层来的原因所在。</p>\n<p>然而，应用层面的操作改变将会影响到这个用例层，如果需求中用例发生改变，这个层的代码就会随之发生改变。所以可以看到，这一层是和应用本身紧密相关的</p>\n<ol start=\"4\">\n<li><strong>接口适配器 (Interface Adapters)</strong></li>\n</ol>\n<p>这一层的软件基本都是一些适配器，主要用于将用例和实体中的数据转换为外部系统如数据库或Web使用的数据，在这个层次，可以包含一些GUI的MVC架构，表现视图 控制器都属于这个层，模型Model是从控制器传递到用例或从用例传递到视图的数据结构。</p>\n<p>通常在这个层数据被转换，从用例和实体使用的数据格式转换到持久层框架使用的数据，主要是为了存储到数据库中，这个圈层的代码是一点和数据库没有任何关系，如果数据库是一个SQL数据库， 这个层限制使用SQL语句以及任何和数据库打交道的事情。</p>\n<ol start=\"5\">\n<li><strong>框架和驱动器</strong></li>\n</ol>\n<p>最外面一圈通常是由一些框架和工具组成，如数据库Database, Web框架等. 通常你不必在这个层不必写太多代码，而是写些胶水性质的代码与内层进行粘结通讯。</p>\n<p>这个层是细节所在，Web技术是细节，数据库是细节，我们将这些实现细节放在外面以免它们对我们的业务规则造成影响伤害</p>\n<h2 id=\"ABP的分层实现\"><a href=\"#ABP的分层实现\" class=\"headerlink\" title=\"ABP的分层实现\"></a>ABP的分层实现</h2><p>在ABP项目中，层次划分如下。</p>\n<ol>\n<li>应用层（Application项目）</li>\n</ol>\n<p>在领域驱动设计的分层式架构中，应用层作为应用系统的北向网关，对外提供业务外观的功能。在Abp模板项目中,Application项目也是编写主要用例代码的位置，开发者们在此定义与界面有关的数据行为，实现面向接口的开发实践。</p>\n<p><img src=\"https://uploader.shimo.im/f/0nBaITGior4zlqO1.png!thumbnail\" alt=\"图片\"></p>\n<p>应用服务层包含应用服务，数据传输单元，工作单元等对象。</p>\n<ul>\n<li>Application Service</li>\n</ul>\n<p>为面向用户界面层实现业务逻辑代码。例如需要为某些界面对象组装模型，通常会定义ApplicationService，并通过DTO对象，实现与界面表现层的数据交换。</p>\n<ul>\n<li>Data Transfer Object (DTO)</li>\n</ul>\n<p>最常见的数据结构为DTO（数据传输对象），这是来源于马丁弗勒在《企业架构应用模式》中提到的名词，其主要作用为：</p>\n<blockquote>\n<p>是一种设计模式之间传输数据的软件应用系统。 数据传输目标往往是数据访问对象从数据库中检索数据。</p>\n</blockquote>\n<p>在ABP的设计中，有两种不同类型的DTO，分别是用于新增、修改、删除的Input DTO，和用于查询的Output DTO。</p>\n<ul>\n<li>Unit of Work：</li>\n</ul>\n<p>工作单元。工作单元与事务类似，封装了一系列原子级的数据库操作。  </p>\n<ol start=\"2\">\n<li>核心层（Core项目）</li>\n</ol>\n<p>核心层包含领域实体、值对象、聚合根，以及领域上下文实现。</p>\n<ul>\n<li>Entity(实体）：</li>\n</ul>\n<p>实体有别于传统意义上大家所理解的与数据库字段一一匹配的实体模型，在领域驱动设计中,虽然实体同样可能持久化到数据库，但实体包含属性和行为两种不同的抽象。</p>\n<p>例如，如果有一个实体为User，其中有一个属性为Phone，数据为086-132xxxxxxxx，我们有时需要判断该手机号码的国际代号，可能会添加一个新的判定 GetNationCode()，可以通过从Phone字段中取出086来实现，这就是一种通俗意义上的行为。</p>\n<ul>\n<li>Value Object（值对象）:</li>\n</ul>\n<p>值对象无需持久化到数据库，往往是从其他实体或聚合中“剥离”出来的与某些聚合具备逻辑相关性或语义相关性的对象，有时值对象甚至只有个别属性。</p>\n<p>例如，上述实体，包含Phone字段，我们可以将整个Phone“剥离”为一个Telephone对象，该对象可包含PhoneNumber和NationCode字段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class User</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     public Telephone Phone&#123;public get;private set;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Telephone</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public string  PhoneNumber &#123;get;set;&#125;</span><br><span class=\"line\">     public string NationCode  &#123;get;set;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Aggregate &amp; Aggregate Root（聚合，聚合根）：</li>\n</ul>\n<p>聚合是业务的最小工作单元，有时，一个实体就是一个小聚合，而为聚合对外提供访问机制的对象，就是聚合根。</p>\n<p>在领域驱动设计中，识别聚合也是一件非常重要的工作，有一组系统的方法论可以为我们提供参考。</p>\n<p>当然，事实上识别领域对象，包括且不限定于识别聚合、值对象、实体识别该对象的行为或（方法）本身是一件需要经验完成的工作，有时需要UML建模方法的广泛参与。</p>\n<p>有时，我们会习惯于通过属性赋值完成梭代码的过程，从而造成领域行为流失在业务逻辑层的问题，那么或许可以采取这样的方法：</p>\n<p>1、对象的创建，使用构造函数赋值，或工厂方法创建。</p>\n<p>2、将所有对于属性的访问级别都设置为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string Phone&#123;public get;private set;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后再通过一个绑定手机号码的方法，来给这个对象设置手机号码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string BindPhone(string phone)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将所有一切涉及到对Phone的操作，都只能通过规定的方法来赋值，这样可以实现我们开发过程中，无意识的通过属性赋值，可能导致的“领域行为”丢失的现象发生。<br>这种方式可以使得对对象某些属性的操作，只能通过唯一的入口完成，符合单一职责原则的合理运用，如果要扩展方法，可以使用开闭原则来解决。</p>\n<p>但是，采用这种方式，得尽量避免出现：SetPhone(string phone) 这样的方法出现，毕竟这样的方法，其实和直接的属性赋值，没有任何区别。 </p>\n<ul>\n<li>Repository（仓储）</li>\n</ul>\n<p>仓储封装了一系列对象数据库操作的方法，完成对象从数据库到对象的转换过程。在领域驱动设计中，一个仓储往往会负责一个聚合对象从数据库到创建的全过程。</p>\n<ul>\n<li>Domain Service（领域服务）</li>\n</ul>\n<p>领域服务就是“实干家”，那些不适合在领域对象中出现，又不属于对象数据库操作的方法，又与领域对象息息相关的方法，都可以放到领域服务中实现。</p>\n<ul>\n<li>Specification（规格定义）</li>\n</ul>\n<p>规范模式是一种特殊的软件设计模式，通过使用布尔逻辑将业务规则链接在一起，可以重新组合业务规则。</p>\n<p>实际上，它主要用于为实体或其他业务对象定义可重用的过滤器。</p>\n<ol start=\"3\">\n<li>其他基础设施（EntityFrameworkCore，Web.Core,Web.Host项目)</li>\n</ol>\n<p>EntityFrameworkCore负责定义数据库上下文和对EFCore操作的一系列规则、例如种子数据的初始化等。</p>\n<p><img src=\"https://uploader.shimo.im/f/D51RK39ZSnDFxvcz.png!thumbnail\" alt=\"图片\"></p>\n<p>Web.Core：定义了应用程序的外观和接口。虽然从表面上看，Web.Core定义了作为Web访问入口的控制器方法和登录验证的逻辑，看起来像是用户表现层的东西，但是仔细想想，这些东西，何尝不是一种基础设施？</p>\n<p>Web.Host：定义WEB应用程序的入口。 </p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文简述了ABP框架的前后端项目的分层结构，通过了解这些结构，将有助于我们在后续的实战中更快入手，为应用开发插上翅膀。</p>\n"},{"title":"WPF学习路线概述","date":"2020-02-23T08:28:00.000Z","author":"邹溪源","_content":"# 引言\n在桌面开发领域，虽然在某些领域，基于electron的跨平台方案能够为我们带来某些便利，但是由于WPF技术能够更好的运用Direct3D带来的性能提升、以及海量Windows操作系统和硬件资源的支持，所以他依然有着得天独厚的优势。    \n\n当然，选用一门技术，依然看公司的基因土壤和综合因素或者老板的心血来潮，例如QT也同样是一门非常不错的跨平台图形界面解决方案。    \n\n目前我们公司在桌面开发领域广泛应用了WPF技术，主要是使用其作为大屏数据可视化相关的UI呈现，包括一些数据展示效果、动画效果等。由于之前我对WPF仅有三周经验，因此在开发和设计相关功能时，一些简单功能还能勉强完成，稍微复杂一点的就有点费时过长了，因此这篇文章主要梳理自己的学习笔记，以便总结学习成果。    \n\n# 如何学习WPF技术？\n在Quote上有人提出了这样一个相同的问题，[查看问题](https://www.quora.com/How-can-I-learn-WPF-easily)，开发者Srikanth Pagadala如是回答：    \n\n>1、以了解基础控件作为学习的起步过程：这些控件包括TextBox,Button,TextBlock及其他的，理解这些控件对外提供的属性，以及如何使用。\n>2、了解和使用布局空间：例如Grid、StackPanel、DockerPanel和其他控件，在这一点上，你需要花费大量的时间。同时你需要学会创建复杂的UI设计。\n>3、了解循环类型的空间，例如ItemControl控件。\n>4、了解关于模板的概念。包括如何定义包含CheckBox的Combox，同时这个控件还包含了一张图片的按钮，以及如何在ItemsControl中使用不同的模板。\n>5、理解数据绑定的运行机制。尝试创建一个MVVM或类似类型的应用程序。\n>6、创建一个典型的控件，探索DependencyProperties（依赖属性）和AttachedProperties（附加属性）。\n>7、创建一个样式资源，理解如何给控件设计样式。\n\n除此之外，还有其他开发者给出了补充回答：    \n\n>1、学习控件的数据绑定过程，在DataGrid上实现数据绑定。\n>2、学习和实现INotifyPropertyChanged类。[查看如何实现](https://msdn.microsoft.com/en-us/library/vstudio/ms743695(v=vs.100).aspx)\n>3、学习Observable Collection。该类型的集合广泛使用于数据集合绑定方面，同时也提供了数据改变通知的机制。\n>4、使网格上的列可编辑。用文本控件（用户项目模板）替换列。为每个捕获文本更改事件的列创建一个属性。在文本控件上使用绑定类型。尝试捕获您在后端在网格上所做的更改。\n>5、成功将数据控件中的文本控件与后端属性绑定后，请在同一页面上创建网格的副本。尝试同步这两个网格。例如，您在第一个网格中所做的每个更改都必须在第二个网格中自动更新。\n\n网站“[https://www.wpf-tutorial.com/](https://www.wpf-tutorial.com/)”是一个专门用于学习WPF的网站，通过这个网站，可以快速的入门WPF。    \n\n由于WPF技术已经比较熟悉，所以书籍也比较多，网友推荐来自刘铁猛老师的《深入浅出WPF》这本书，而我通过Kindle则看到了一本比较有意思的书《葵花宝典-WPF自学手册》，这本书写得比较生动，通过故事的形式讲了WPF的许多技术原理，无形中让我对WPF的概念有了许多新的认识。当然，这本书已经有点年头了。    \n\n# WPF的常用控件\n| 控件类型   | 控件名称   | 控件说明   | 链接地址   | \n|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|\n| 组件   | Window   | 窗口   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.window?view=netframework-4.8)   | \n|    | Page   | 页面   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.page?view=netframework-4.8)   | \n|    | NavigationWindow   | 导航窗口   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.navigation.navigationwindow?view=netframework-4.8)   | \n|    | Frame   |    | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Frame)   | \n| 常规控件   | Button   | 按钮控件，提供Content作为内容   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Button)   | \n|    | TextBox   | 文本框控件，用以输入文本   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TextBox)   | \n|    | TextBlock   | 文本块，用以显示文本   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TextBlock)   | \n|    | Label   | 标签，用以显示文本   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Label)   | \n|    | ProgressBar   | 进度条   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ProgressBar)   | \n|    | ToggleButton   | 一种可以设置开关三态的按钮   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.primitives.togglebutton?view=netframework-4.8)   | \n|    | Image   | 图像控件，通过Source设置资源路径   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Image)   | \n|    | CheckBox   | 勾选框，可以设置是否勾选的三种状态   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/CheckBox)   | \n|    | RichTextBox   | 富文本框，可以多种格式显示和输入文本   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/RichTextBox)   | \n|    | TreeView   | 树视图，以树状图的形式显示绑定内容，可以显示是否勾选三态。   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TreeView)   | \n|    | WebBrowser   | 浏览器，基于IE内核的浏览器控件   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.webbrowser?view=netframework-4.8)   | \n|    | Calendar   | 日历控件   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.calendar?view=netframework-4.8)   | \n|    | ComboBox   | 下拉列表   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ComboBox)   | \n|    | ContentControl   | 内容控件   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.contentcontrol?view=netframework-4.8)   | \n|    | Expander   | 扩展器，可以显示和折叠面板内的元素   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Expander)   | \n|    | GroupBox   | 分组框   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/GroupBox)   | \n|    | StatusBar   | 状态栏，用于在页面下方显示状态信息。   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/StatusBar)   | \n|    | DateTimePicker   | 时间控件，可以设置时间状态。   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.forms.datetimepicker?view=netframework-4.8)   | \n|    | DocumentViewer   | 文档查看器   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/DocumentViewer)   | \n|    | RadioButton   | 单选按钮   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/RadioButton)   | \n|    | ScollViewer   | 滚动视图   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/scrollviewer-overview)   | \n|    | ScollBar   | 滚动条   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.primitives.scrollbar?view=netframework-4.8)   | \n|    | Separator   | 分隔器   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Separator)   | \n|    | ToolBar   | 工具条   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ToolBar)   | \n|    | Slider   |    | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Slider)   | \n|    | Menu   | 菜单   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Menu)   | \n|    | MediaElement   | 多媒体控件   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.mediaelement?view=netframework-4.8)   | \n|    | PasswordBox   | 密码输入框   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/PasswordBox)   | \n|    | TabControl   | 选项卡   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TabControl)   | \n|    | ToolBarTray   | 工具条   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.toolbartray?view=netframework-4.8)   | \n|    | WindowsFormsHost   | 用以承载WinForm   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.forms.integration.windowsformshost?view=netframework-4.8)   | \n|    | Border   | 边框   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Border)   | \n| 数据控件   | ListView   | 列表视图   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ListView)   | \n|    | DataGrid   | 数据表   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/datagrid)   | \n|    | ListBox   | 列表框   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ListBox)   | \n| 布局   | WrapPanel   | 可变面板   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/WrapPanel)   | \n|    | StackPanel   | 固定面板   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/StackPanel)   | \n|    | DockerPanel   | 停靠面板   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.dockpanel?view=netframework-4.8)   | \n|    | Grid   | 表格布局   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Grid)   | \n|    | UniformGrid   | 统一分布表格布局   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.primitives.uniformgrid?view=netframework-4.8)   | \n| [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Label)   | Canvas   | 画布   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Canvas)   | \n| 图形   | Point   | 点   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Border)   | \n|    | Line   | 线   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.line?view=netframework-4.8)   | \n|    | Path   | 路径   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.path?view=netframework-4.8)   | \n|    | Polygon   | 多边形   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.polygon?view=netframework-4.8)   | \n|    | Polyline   | 多段线   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.polyline?view=netframework-4.8)   | \n|    | Rectangle   | 矩形   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.rectangle?view=netframework-4.8)   | \n|    | Shape   | 画笔   | [查看示例](http://各类图元的基类)   | \n|    | Rectangle   | 矩形   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.rectangle?view=netframework-4.8)   | \n|    | Ellipse   | 椭圆   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.ellipse?view=netframework-4.8)   | \n\n# WPF的XAML语法\n## 概述    \n在WPF技术中引入的XAML语法算是该技术的一大特色，也是被学习者视同为学习路径陡峭的“罪魁祸首”。原因是在前端技术飞速发展的今天，HTML的语法体系由于更早的被开发者接受，所以也自然而然更容易成为开发者的首选。    \n\n而XAML是一种脱胎于XML，并吸收了HTML的精华的语法体系，是一种界面描述语言，XML语法本身相对而言较为臃肿的体系，看似成为了他的历史负担，但是其实倒也没那么复杂，通过几个简单的示例，其实就足够掌握这门新的语法体系了。例如，使用<button></button>这样的语法，完全可以平滑过渡到<Button></Button>这样的语法体系。(部分标签其实只是大小写不同）。当然，在XAML中熟练编写样式，确实需要花一点点时间。    \n\n在WPF中，通过XAML定义面向用户交互层的界面，然后编译成baml运行，后端则使用C#或VB.NET这样的CLR语法来实现逻辑交互。    \n\n## XAML的语法定义    \n### XAML的根元素定义    \n根元素定义是定义XAML的命名空间。    \n\n```\n<Page\n  xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n  xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\">\n```\n### XAML的属性语法    \n通过xaml定义按钮，并设置文本为 helloworld 。这种写法在官方文档中称为“属性语法”，即直接在XAML中对属性进行设置。\n\n```\n<Button Background=\"Blue\" Foreground=\"Red\" Content=\"hello world\"/>\n```\n### XAML的属性元素语法    \n通过xaml定义按钮，并设置其背景为蓝色画笔，字体颜色为红色画笔，内容 为helloworld。这种写法在官方文档中称为“属性元素语法”。    \n\n```\n<Button>\n  <Button.Background>\n    <SolidColorBrush Color=\"Blue\"/>\n  </Button.Background>\n  <Button.Foreground>\n    <SolidColorBrush Color=\"Red\"/>\n  </Button.Foreground>\n  <Button.Content>\n    hello world\n  </Button.Content>\n</Button>\n```\n### XAML的集合语法    \n定义按钮的颜色为红色和蓝色渐变色，内容为helloworld。这种称为“集合语法”。    \n\n```\n<LinearGradientBrush>\n  <LinearGradientBrush.GradientStops>\n    <!-- no explicit new GradientStopCollection, parser knows how to find or create -->\n    <GradientStop Offset=\"0.0\" Color=\"Red\" />\n    <GradientStop Offset=\"1.0\" Color=\"Blue\" />\n  </LinearGradientBrush.GradientStops>\n</LinearGradientBrush>\n```\n## XAML的样式定义    \n### 通过属性语法来定义按钮的外观    \n样式定义使用 <Style></Style>标签，然后在中间对样式的内容进行定义。    \n\n例如，以下表示通过XAML语法对 ToggleButton 按钮定义了一个命名为 ToggleLikeButtonStyle 的样式。    \n\n```\n <Style TargetType=\"ToggleButton\" x:Key=\"ToggleLikeButtonStyle\">\n            <Setter Property=\"Margin\"   Value=\"4\" />\n\n            <Setter Property=\"FontWeight\" Value=\"Black\"/>\n\n            <Setter Property=\"Foreground\"  Value=\"Black\" />\n\n            <Setter Property=\"BorderThickness\" Value=\"0\"/>\n\n            <Setter Property=\"IsThreeState\" Value=\"False\"></Setter>\n\n</Style>\n```\n### WPF中的模板Template\nWPF中的控件可以通过模板 Template 的形式来定义其内容，使得开发者能够通过 XAML 灵活的对控件的外观进行扩展。例如，如下定义了一个 Template，这个控件模板将会对控件（Button）定义填充制定颜色。    \n\n```\n <Setter Property=\"Template\">  \n                <Setter.Value>  \n                    <ControlTemplate>  \n                        <Border BorderThickness=\"0\" CornerRadius=\"3\">  \n                            <Border.Background>  \n                                <LinearGradientBrush EndPoint=\"0,1\" StartPoint=\"0,0\">  \n                                    <GradientStop Color=\"#4696F2\" Offset=\"0.5\"/>  \n                                </LinearGradientBrush>  \n                            </Border.Background>  \n                            <ContentPresenter Content=\"{TemplateBinding ContentControl.Content}\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" />  \n                        </Border>  \n                    </ControlTemplate>  \n                </Setter.Value>  \n            </Setter>  \n```\n### XAML中的触发器Triggers\n传统的WinForm开发者习惯于通过事件的机制对按钮的外观进行定义，而在WPF中，则可以通过属性的形式对外观进行设置，这使得开发者更能够写出高质量的代码。  \n\n例如，如下代码通过定义触发器，设置控件（控件为 ToggleButton），当控件的勾选状态属性为“IsChecked” 时，其边框填充色为#4696F2颜色。  \n\n```\n<ControlTemplate.Triggers>  \n                            <Trigger Property=\"IsChecked\" Value=\"True\">  \n  <Setter Property=\"Border.Background\" TargetName=\"PART_Background\"\n<Setter.Value>\n                                        <LinearGradientBrush EndPoint=\"0,1\" StartPoint=\"0,0\">\n                                            <GradientStop Color=\"#4696F2\" Offset=\"0.5\"/>\n                                        </LinearGradientBrush>\n                                    </Setter.Value>\n                                </Setter>\n                                <Setter Property=\"Width\" TargetName=\"PART_Background\" Value=\"60\"></Setter>\n                                <Setter Property=\"Content\"  TargetName=\"contextPresenter\" Value=\"已点赞\"></Setter>\n                                <Setter Property=\"Visibility\"  TargetName=\"contextPresenter\" Value=\"Visible\"></Setter>\n                                <Setter Property=\"Visibility\" TargetName=\"contextImage\" Value=\"Hidden\"/>\n                            </Trigger>\n</ControlTemplate.Triggers>                         \n                                    \n```\n### 部分完整代码\n在上述事例中，共定义了两个按钮的样式，分别是:\n\n* **FlatButtonStyle，这是个圆角按钮。**![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/circleButton.png)\n```\n<Style TargetType=\"Button\" x:Key=\"FlatButtonStyle\">\n            <Setter Property=\"Margin\"   Value=\"4\" />\n            <Setter Property=\"FontWeight\" Value=\"Black\"/>\n            <Setter Property=\"Foreground\"  Value=\"Black\" />\n            <Setter Property=\"BorderThickness\" Value=\"0\"/>\n            <Setter Property=\"Template\">\n                <Setter.Value>\n                    <ControlTemplate>\n                        <Border BorderThickness=\"0\" CornerRadius=\"3\">\n                            <Border.Background>\n                                <LinearGradientBrush EndPoint=\"0,1\" StartPoint=\"0,0\">\n                                    <GradientStop Color=\"#4696F2\" Offset=\"0.5\"/>\n                                </LinearGradientBrush>\n                            </Border.Background>\n                            <ContentPresenter Content=\"{TemplateBinding ContentControl.Content}\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" />\n                        </Border>\n                    </ControlTemplate>\n                </Setter.Value>\n            </Setter>\n        </Style>\n```\n* **ToggleLikeButtonStyle，这是一个点赞按钮。**![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/likeButton.png)。\n```\n<Style TargetType=\"ToggleButton\" x:Key=\"ToggleLikeButtonStyle\">\n            <Setter Property=\"Margin\"   Value=\"4\" />\n            <Setter Property=\"FontWeight\" Value=\"Black\"/>\n            <Setter Property=\"Foreground\"  Value=\"Black\" />\n            <Setter Property=\"BorderThickness\" Value=\"0\"/>\n            <Setter Property=\"IsThreeState\" Value=\"False\"></Setter>\n            <Setter Property=\"Template\">\n                <Setter.Value>\n                    <ControlTemplate TargetType=\"{x:Type ToggleButton}\">\n                        <Border BorderThickness=\"0\" CornerRadius=\"3\" Name=\"PART_Background\">\n                            <Border.Background>\n                                <LinearGradientBrush EndPoint=\"0,1\" StartPoint=\"0,0\">\n                                    <GradientStop Color=\"#525252\" Offset=\"0.5\"/>\n                                </LinearGradientBrush>\n                            </Border.Background>\n                            <Grid>\n                                <ContentPresenter x:Name=\"contextPresenter\" Content=\"{TemplateBinding ContentControl.Content}\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" />\n                                <Image x:Name=\"contextImage\" Width=\"24\" Height=\"24\" Source=\"assests/thumbs-up-outline.png\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\"/>\n                            </Grid>\n                        </Border>\n                        <ControlTemplate.Triggers>\n                            <Trigger Property=\"IsChecked\" Value=\"True\">\n                                <Setter Property=\"Border.Background\" TargetName=\"PART_Background\">\n                                    <Setter.Value>\n                                        <LinearGradientBrush EndPoint=\"0,1\" StartPoint=\"0,0\">\n                                            <GradientStop Color=\"#4696F2\" Offset=\"0.5\"/>\n                                        </LinearGradientBrush>\n                                    </Setter.Value>\n                                </Setter>\n                                <Setter Property=\"Width\" TargetName=\"PART_Background\" Value=\"60\"></Setter>\n                                <Setter Property=\"Content\"  TargetName=\"contextPresenter\" Value=\"已点赞\"></Setter>\n                                <Setter Property=\"Visibility\"  TargetName=\"contextPresenter\" Value=\"Visible\"></Setter>\n                                <Setter Property=\"Visibility\" TargetName=\"contextImage\" Value=\"Hidden\"/>\n                            </Trigger>\n                            <Trigger Property=\"IsChecked\" Value=\"False\">\n                                <Setter Property=\"Border.Background\" TargetName=\"PART_Background\">\n                                    <Setter.Value>\n                                        <LinearGradientBrush EndPoint=\"0,1\" StartPoint=\"0,0\">\n                                            <GradientStop Color=\"#525252\" Offset=\"0.5\"/>\n                                        </LinearGradientBrush>\n                                    </Setter.Value>\n                                </Setter>\n                                <Setter Property=\"Width\" TargetName=\"PART_Background\" Value=\"40\"></Setter>\n                                <Setter Property=\"Visibility\"  TargetName=\"contextPresenter\" Value=\"Hidden\"></Setter>\n                                <Setter Property=\"Visibility\" TargetName=\"contextImage\" Value=\"Visible\"/>\n                            </Trigger>\n                        </ControlTemplate.Triggers>\n                    </ControlTemplate>\n                </Setter.Value>\n            </Setter>\n</Style>\n```\n## XAML的[标记扩展](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/markup-extensions-and-wpf-xaml)\n通过了解WPF的常用控件，我们可以知道自己需要使用的控件有哪些属性，并能使用 XAML 语法对相应的属性进行设置，这种设置方法有别于通过C#代码的形式进行定义的方法，在 XAML中的属性称为 “标记”。标记使用 “{}” 花括号，编译器通过该花括号将语法和XAML语法进行区分。  \n\n例如：  \n\n```\n HeaderTemplate=\"{DynamicResource StretchedHeaderTemplate}\"  \n```\n### 标记值的转换与TypeConverters  \n在进行标记值转换时，有时候需要使用TypeConverters实现类型转换。例如，在上述示例代码中，可以看到使用了字符串“#525252”来定义颜色，在内部就是实现了从字符串到 Color 类的转换过程。限于篇幅有限，此处就暂时略过。  \n\n### XAML中内置特殊标记扩展  \n* x:Type：特定类型  \n```\n<object property=\"{x:Type prefix:typeNameValue}\" .../>    \n```\n* x:Static：使用静态值。  \n```\n<object property=\"{x:Static prefix:typeName.staticMemberName}\" .../>    \n```\n* x:Null：使用空对象定义为属性值。  \n```\n<object property=\"{x:Null}\" .../>    \n```\n* x:Array：使用数组对象。  \n```\n<x:Array Type=\"typeName\">    \n  arrayContents    \n</x:Array>    \n```\n### 常见的标记扩展\n1. StaticResource：通过替换已定义资源的值来为属性提供内容，该资源标记在XAML加载时自动执行。静态资源无法通过在XAML语法体系中对其引用关系进行前向引用，意味着无法通过多层级关系定义可复用的样式资源，如果需要这样做，则需要使用DynamicResource。  \n```\n<object property=\"{StaticResource key}\" .../>    \n```\n2. DynamicResource：在运行时为资源提供内容。  \n```\n<object property=\"{DynamicResource key}\" .../>    \n```\n3. Binding：在运行时为使用数据上下文为数据提供内容。  \n```\n<object property=\"{Binding}\" .../>    \n-or-  \n<object property=\"{Binding  bindProp1=value1[, bindPropN=valueN]*}\" ...  \n/>    \n-or-    \n<object property=\"{Binding path}\" .../>  \n-or     \n<object property=\"{Binding path[, bindPropN=valueN]*}\" .../>    \n```\n4. RelativeSource：提供了可在运行时对象树中导航几个可能的关系的 [Binding](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.data.binding) 的源信息。  \n```\n<Binding RelativeSource=\"{RelativeSource modeEnumValue}\" .../>  \n```\n5. TemplateBinding：使控件模板能够使用模板化属性的值，这些属性来自于将使用该模板的类的对象模型定义属性。  \n```\n<object property=\"{TemplateBinding sourceProperty}\" .../>    \n```\n6. ColorConvertedBitmap：提供一种方法，用于指定没有嵌入的配置文件的位图源。 颜色上下文/配置文件由 URI 指定，与映像源 URI 相同。  \n```\n<object property=\"{ColorConvertedBitmap imageSource sourceIIC destinationIIC}\" .../>    \n```\n7. ComponentResourceKey和TemplateResourceKey：  \n```\n<object x:Key=\"{ComponentResourceKey {x:Type targetTypeName}, targetID}\" .../>    \n```\n## XAML资源复用\n在开发过程中，我们可以直接在按钮上进行按钮模板的定义，例如下面的代码。  \n\n```\n<Button Width=\"40\" Height=\"40\" Style=\"{DynamicResource CubeImageButtonStyle}\" Click=\"Button_Click\" Content=\"点赞\">\n    <Button.Background>\n                                <ImageBrush ImageSource=\"/assests/favicon.png\" Stretch=\"Fill\"/> \n                            </Button.Background>\n                        </Button>   \n                          <Setter Property=\"Template\"\n                <Setter.Value>\n                    <ControlTemplate>\n                        <Border BorderThickness=\"0\" CornerRadius=\"3\">\n                            <Border.Background>\n                                <LinearGradientBrush EndPoint=\"0,1\" StartPoint=\"0,0\">\n                                    <GradientStop Color=\"#4696F2\" Offset=\"0.5\"/>\n                                </LinearGradientBrush>\n                            </Border.Background>\n                            <ContentPresenter Content=\"{TemplateBinding ContentControl.Content}\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" />\n                        </Border>\n                    </ControlTemplate>\n                </Setter.Value>\n            </Setter>\n        </Style>\n </Window.Resources>\n <Grid>\n<Button Grid.Column=\"0\" Grid.Row=\"1\" Style=\"{StaticResource FlatButtonStyle}\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Top\" Width=\"48\" Height=\"16\" FontSize=\"10\" Background=\"#4696F2\" Content=\"获取\"></Button>\n </Grid>\n                        \n```\n这样的代码在界面比较简单时，还无所谓，但是随着控件的样式越来越复杂，可能会成为一团乱麻，这对于追求优雅代码的我们来说，可能是难以忍受的，所以往往会使用资源引用来完成。    \n### StaticResource    \n例如，我们可以在当前页面代码中定义对应的样式，这种样式可以使用 StaticResource 的形式引入。但是这样的引用形式，没有对象图的访问权限，意味着无法访问资源依赖的其他资源。    \n\n```\n <Window.Resources>  \n<Style TargetType=\"Button\" x:Key=\"FlatButtonStyle\">     \n            <Setter Property=\"Margin\"   Value=\"4\" />    \n            <Setter Property=\"FontWeight\" Value=\"Black\"/>    \n            <Setter Property=\"Foreground\"  Value=\"Black\" />        \n            <Setter Property=\"BorderThickness\" Value=\"0\"/>    \n</Window.Resources>          \n```\n### DynamicResource\n将上述代码中的{StaticResource FlatButtonStyle} 改成{StaticResource  FlatButtonStyle}则会在运行时加载样式，并可以访问相应的对象图。\n\n当然，这样的更改意义不大，如果该FlatButtonStyle引用了其他样式或元素，会发生作用。\n\n```\n<Grid\n<Button Grid.Column=\"0\" Grid.Row=\"1\" Style=\"{StaticResource FlatButtonStyle}\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Top\" Width=\"48\" Height=\"16\" FontSize=\"10\" Background=\"#4696F2\" Content=\"获取\"></Button>\n </Grid>\n```\n## 注意事项\n1、由于XAML语法脱胎于XML语法，而XML语法中本身对某些输入字符，如“<>”存在限制，所以在XAML中也会出现这类问题，并会被Visual Studio检测出错误而无法编译，需要使用UTF-8编码进行转换。  \n\n# 用户控件和自定义控件  \n## 用户控件  \n而用户控件，使用于控件组合的场景。  \n\n## 自定义控件  \n在笔者进行开发时，总是思考究竟是使用用户控件，还是自定义控件，后来在阅读《葵花宝典-WPF自学手册》这本书中，终于得以大彻大悟。  \n\n作者指出：“不要被控件的外观所欺骗，要考虑其内在本质”。即思考控件的基本特征，首先想到该控件的行为与原有控件的行为是否相似，如果能够找到，则修改原有控件，而不是定义一个控件。尤其是在XAML语法中，能够通过Content 模型和模板、附加属性的运用，使得自定义控件的用途得到了进一步缩减，只有当实在万不得已时，在定义自定义控件。\n\n作者给出了使用自定义控件的分析思路：    \n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/flow.png)\n\n例如，在示例代码**ToggleLikeButtonStyle **中，我实现了一个点赞和取消点赞的状态，则使用了ToggleButton来完成，就没必要使用 Button 扩展出一个是否点赞的状态了。  \n\n而如果我们需要实现的功能有这么复杂，那大概使用传统的控件就无法实现，就得使用自定义控件了。（[点击查看示例代码](https://github.com/caomfan/WpfDemo.git)）\n\n![图片](https://uploader.shimo.im/f/f44dU5UMbaYZpJtm.png!thumbnail)\n\n作者定义了自定义控件 ButtonEx，并实现了依赖属性 ButtonType，见【依赖属性】，并定义了不同类型的样式特征。  \n\n```\n <Trigger Property=\"ButtonType\" Value=\"Icon\">\n                <Setter Property=\"Cursor\" Value=\"Hand\"/>\n                <Setter Property=\"Template\">\n                    <Setter.Value>\n                        <ControlTemplate TargetType=\"{x:Type controls:ButtonEx}\">\n                            <Border Width=\"{TemplateBinding Width}\" Height=\"{TemplateBinding Height}\">\n                                <Image x:Name=\"Img\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\" Source=\"{TemplateBinding Icon}\" Stretch=\"None\"/>\n                            </Border>\n                            <ControlTemplate.Triggers>\n                                <Trigger Property=\"IsMouseOver\" Value=\"True\">\n                                    <Setter Property=\"Opacity\" Value=\"0.8\"/>\n                                </Trigger>\n                                <Trigger Property=\"IsPressed\" Value=\"True\">\n                                    <Setter Property=\"Opacity\" Value=\"0.9\"/>\n                                </Trigger>\n                            </ControlTemplate.Triggers>\n                        </ControlTemplate>\n                    </Setter.Value>\n                </Setter>\n            </Trigger>\n```\n使用时，只需这样设置，即可实现不同类型的按钮外观。\n```\n <controls:ButtonEx Icon=\"/Images/search.png\"  Margin=\"10\" ButtonType=\"Icon\"/>\n```\n# 属性和事件  \n## [依赖属性](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/dependency-properties-overview)  \n依赖属性是为既有WPF控件对象定义自定义属性，以便支持其扩展，例如在上述自定义控件的示例中，就定义了依赖属性 ButtonType，实现了不同类型的按钮外观。  \n\n```\npublic ButtonType ButtonType  \n        {\n            get { return (ButtonType)GetValue(ButtonTypeProperty); }\n            set { SetValue(ButtonTypeProperty, value); }\n        }\n\n\n        public static readonly DependencyProperty ButtonTypeProperty =\n```\n##             DependencyProperty.Register(\"ButtonType\", typeof(ButtonType), typeof(ButtonEx), new PropertyMetadata(ButtonType.Normal));\n\n\n[附加属性](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/attached-properties-overview)  \n按照官方的说法就是“附加属性旨在用作可在任何对象上设置的一类全局属性”，例如，DockPanel面板中的子对象，继承了来自于容器对象的附加属性，使得其能够在父对象中实现停靠的功能。  \n\n```\n<DockPanel>\n  <CheckBox DockPanel.Dock=\"Top\">Hello</CheckBox>\n</DockPanel>\n```\n## [路由事件](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/routed-events-overview)  \n### 基本定义  \n假设我们定义了几个这样的控件。  \n\n```\n<Border Height=\"50\" Width=\"300\" BorderBrush=\"Gray\" BorderThickness=\"1\">\n  <StackPanel Background=\"LightGray\" Orientation=\"Horizontal\" Button.Click=\"CommonClickHandler\">\n    <Button Name=\"YesButton\" Width=\"Auto\" >Yes</Button>\n    <Button Name=\"NoButton\" Width=\"Auto\" >No</Button>\n    <Button Name=\"CancelButton\" Width=\"Auto\" >Cancel</Button>\n  </StackPanel>\n</Border>\n```\n实现了这样的界面![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/ui.png)\n\n路由事件就是针对这组元素树中多个元素调用处理程序的事件。当我们点击了按钮Button时，将会触发 Button=>StackPanel=>Border的事件路由，而不是像WinForm应用一样，只能触发最上层的Button的按钮点击事件。  \n\n### 路由策略\n* 冒泡事件（官方称为浮升，这个翻译有点。。）：调用事件源上的事件处理程序。 路由事件随后会路由到后续的父级元素，直到到达元素树的根。 大多数路由事件都使用浮升路由策略。 浮升路由事件通常用于报告来自不同控件或其他 UI 元素的输入或状态变化。  \n* 直接： 只有源元素本身才有机会调用处理程序以进行响应。通过使用 [EventSetter](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.eventsetter) 和 [EventTrigger](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.eventtrigger)使用来设置处理程序。例如，可以使用RoutedEventArgs的[Handled](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.routedeventargs.handled)，设置为 true 将事件标记为已处理，将 \"停止\" 路由用于隧道路由或冒泡路由。  \n```\nvoid MakeButton2()\n{\n  Button b2 = new Button();\n  b2.Click += new RoutedEventHandler(Onb2Click2);\n}\nvoid Onb2Click2(object sender, RoutedEventArgs e)\n{\n  //logic to handle the Click event     \n}\n```\n* 隧道：最初将调用元素树的根处的事件处理程序。 随后，路由事件将朝着路由事件的源节点元素（即引发路由事件的元素）方向，沿路由线路传播到后续的子元素。  \n* WPF中约定，隧道路由事件的名称以单词“Preview”开头。 输入事件通常成对出现，一个是浮升事件，另一个是隧道事件。例如，如下图所示，假设按钮2为触发事件的源。  \n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/event.png)\n\n1、处理Border根元素的隧道事件PreviewMouseDown  \n\n2、处理StackPanel面板的隧道事件PreviewMouseDown.  \n\n3、处理Button按钮的隧道事件的PreMouseDown。  \n\n4、处理Button按钮的MouseDown事件。  \n\n5、处理StackPanel的MouseDown事件。  \n\n6、处理Border的MouseDown事件。    \n\n# 总结\nWPF是一个非常庞大的技术体系，以上学习路径仅供开发者进行简单的入门，由于篇幅有限，对于标记扩展还需要进一步理解透彻，以及格式转换、图形绘制、数据绑定、MVVM等内容未能一一描述。  \n\n如果果想要对WPF进一步了解，最好通过系统的学习相关知识，除了前面提到的网站和几本书，最好的入门网站依然是[微软官方文档](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/)。  \n\n#  \n \n\n\n","source":"_posts/技术/how-to-learn-wpf.md","raw":"---\ntitle:  WPF学习路线概述\ndate: 2020-02-23 16:28\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n# 引言\n在桌面开发领域，虽然在某些领域，基于electron的跨平台方案能够为我们带来某些便利，但是由于WPF技术能够更好的运用Direct3D带来的性能提升、以及海量Windows操作系统和硬件资源的支持，所以他依然有着得天独厚的优势。    \n\n当然，选用一门技术，依然看公司的基因土壤和综合因素或者老板的心血来潮，例如QT也同样是一门非常不错的跨平台图形界面解决方案。    \n\n目前我们公司在桌面开发领域广泛应用了WPF技术，主要是使用其作为大屏数据可视化相关的UI呈现，包括一些数据展示效果、动画效果等。由于之前我对WPF仅有三周经验，因此在开发和设计相关功能时，一些简单功能还能勉强完成，稍微复杂一点的就有点费时过长了，因此这篇文章主要梳理自己的学习笔记，以便总结学习成果。    \n\n# 如何学习WPF技术？\n在Quote上有人提出了这样一个相同的问题，[查看问题](https://www.quora.com/How-can-I-learn-WPF-easily)，开发者Srikanth Pagadala如是回答：    \n\n>1、以了解基础控件作为学习的起步过程：这些控件包括TextBox,Button,TextBlock及其他的，理解这些控件对外提供的属性，以及如何使用。\n>2、了解和使用布局空间：例如Grid、StackPanel、DockerPanel和其他控件，在这一点上，你需要花费大量的时间。同时你需要学会创建复杂的UI设计。\n>3、了解循环类型的空间，例如ItemControl控件。\n>4、了解关于模板的概念。包括如何定义包含CheckBox的Combox，同时这个控件还包含了一张图片的按钮，以及如何在ItemsControl中使用不同的模板。\n>5、理解数据绑定的运行机制。尝试创建一个MVVM或类似类型的应用程序。\n>6、创建一个典型的控件，探索DependencyProperties（依赖属性）和AttachedProperties（附加属性）。\n>7、创建一个样式资源，理解如何给控件设计样式。\n\n除此之外，还有其他开发者给出了补充回答：    \n\n>1、学习控件的数据绑定过程，在DataGrid上实现数据绑定。\n>2、学习和实现INotifyPropertyChanged类。[查看如何实现](https://msdn.microsoft.com/en-us/library/vstudio/ms743695(v=vs.100).aspx)\n>3、学习Observable Collection。该类型的集合广泛使用于数据集合绑定方面，同时也提供了数据改变通知的机制。\n>4、使网格上的列可编辑。用文本控件（用户项目模板）替换列。为每个捕获文本更改事件的列创建一个属性。在文本控件上使用绑定类型。尝试捕获您在后端在网格上所做的更改。\n>5、成功将数据控件中的文本控件与后端属性绑定后，请在同一页面上创建网格的副本。尝试同步这两个网格。例如，您在第一个网格中所做的每个更改都必须在第二个网格中自动更新。\n\n网站“[https://www.wpf-tutorial.com/](https://www.wpf-tutorial.com/)”是一个专门用于学习WPF的网站，通过这个网站，可以快速的入门WPF。    \n\n由于WPF技术已经比较熟悉，所以书籍也比较多，网友推荐来自刘铁猛老师的《深入浅出WPF》这本书，而我通过Kindle则看到了一本比较有意思的书《葵花宝典-WPF自学手册》，这本书写得比较生动，通过故事的形式讲了WPF的许多技术原理，无形中让我对WPF的概念有了许多新的认识。当然，这本书已经有点年头了。    \n\n# WPF的常用控件\n| 控件类型   | 控件名称   | 控件说明   | 链接地址   | \n|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|\n| 组件   | Window   | 窗口   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.window?view=netframework-4.8)   | \n|    | Page   | 页面   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.page?view=netframework-4.8)   | \n|    | NavigationWindow   | 导航窗口   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.navigation.navigationwindow?view=netframework-4.8)   | \n|    | Frame   |    | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Frame)   | \n| 常规控件   | Button   | 按钮控件，提供Content作为内容   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Button)   | \n|    | TextBox   | 文本框控件，用以输入文本   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TextBox)   | \n|    | TextBlock   | 文本块，用以显示文本   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TextBlock)   | \n|    | Label   | 标签，用以显示文本   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Label)   | \n|    | ProgressBar   | 进度条   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ProgressBar)   | \n|    | ToggleButton   | 一种可以设置开关三态的按钮   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.primitives.togglebutton?view=netframework-4.8)   | \n|    | Image   | 图像控件，通过Source设置资源路径   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Image)   | \n|    | CheckBox   | 勾选框，可以设置是否勾选的三种状态   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/CheckBox)   | \n|    | RichTextBox   | 富文本框，可以多种格式显示和输入文本   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/RichTextBox)   | \n|    | TreeView   | 树视图，以树状图的形式显示绑定内容，可以显示是否勾选三态。   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TreeView)   | \n|    | WebBrowser   | 浏览器，基于IE内核的浏览器控件   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.webbrowser?view=netframework-4.8)   | \n|    | Calendar   | 日历控件   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.calendar?view=netframework-4.8)   | \n|    | ComboBox   | 下拉列表   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ComboBox)   | \n|    | ContentControl   | 内容控件   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.contentcontrol?view=netframework-4.8)   | \n|    | Expander   | 扩展器，可以显示和折叠面板内的元素   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Expander)   | \n|    | GroupBox   | 分组框   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/GroupBox)   | \n|    | StatusBar   | 状态栏，用于在页面下方显示状态信息。   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/StatusBar)   | \n|    | DateTimePicker   | 时间控件，可以设置时间状态。   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.forms.datetimepicker?view=netframework-4.8)   | \n|    | DocumentViewer   | 文档查看器   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/DocumentViewer)   | \n|    | RadioButton   | 单选按钮   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/RadioButton)   | \n|    | ScollViewer   | 滚动视图   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/scrollviewer-overview)   | \n|    | ScollBar   | 滚动条   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.primitives.scrollbar?view=netframework-4.8)   | \n|    | Separator   | 分隔器   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Separator)   | \n|    | ToolBar   | 工具条   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ToolBar)   | \n|    | Slider   |    | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Slider)   | \n|    | Menu   | 菜单   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Menu)   | \n|    | MediaElement   | 多媒体控件   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.mediaelement?view=netframework-4.8)   | \n|    | PasswordBox   | 密码输入框   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/PasswordBox)   | \n|    | TabControl   | 选项卡   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TabControl)   | \n|    | ToolBarTray   | 工具条   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.toolbartray?view=netframework-4.8)   | \n|    | WindowsFormsHost   | 用以承载WinForm   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.forms.integration.windowsformshost?view=netframework-4.8)   | \n|    | Border   | 边框   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Border)   | \n| 数据控件   | ListView   | 列表视图   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ListView)   | \n|    | DataGrid   | 数据表   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/datagrid)   | \n|    | ListBox   | 列表框   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ListBox)   | \n| 布局   | WrapPanel   | 可变面板   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/WrapPanel)   | \n|    | StackPanel   | 固定面板   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/StackPanel)   | \n|    | DockerPanel   | 停靠面板   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.dockpanel?view=netframework-4.8)   | \n|    | Grid   | 表格布局   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Grid)   | \n|    | UniformGrid   | 统一分布表格布局   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.primitives.uniformgrid?view=netframework-4.8)   | \n| [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Label)   | Canvas   | 画布   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Canvas)   | \n| 图形   | Point   | 点   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Border)   | \n|    | Line   | 线   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.line?view=netframework-4.8)   | \n|    | Path   | 路径   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.path?view=netframework-4.8)   | \n|    | Polygon   | 多边形   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.polygon?view=netframework-4.8)   | \n|    | Polyline   | 多段线   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.polyline?view=netframework-4.8)   | \n|    | Rectangle   | 矩形   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.rectangle?view=netframework-4.8)   | \n|    | Shape   | 画笔   | [查看示例](http://各类图元的基类)   | \n|    | Rectangle   | 矩形   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.rectangle?view=netframework-4.8)   | \n|    | Ellipse   | 椭圆   | [查看示例](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.ellipse?view=netframework-4.8)   | \n\n# WPF的XAML语法\n## 概述    \n在WPF技术中引入的XAML语法算是该技术的一大特色，也是被学习者视同为学习路径陡峭的“罪魁祸首”。原因是在前端技术飞速发展的今天，HTML的语法体系由于更早的被开发者接受，所以也自然而然更容易成为开发者的首选。    \n\n而XAML是一种脱胎于XML，并吸收了HTML的精华的语法体系，是一种界面描述语言，XML语法本身相对而言较为臃肿的体系，看似成为了他的历史负担，但是其实倒也没那么复杂，通过几个简单的示例，其实就足够掌握这门新的语法体系了。例如，使用<button></button>这样的语法，完全可以平滑过渡到<Button></Button>这样的语法体系。(部分标签其实只是大小写不同）。当然，在XAML中熟练编写样式，确实需要花一点点时间。    \n\n在WPF中，通过XAML定义面向用户交互层的界面，然后编译成baml运行，后端则使用C#或VB.NET这样的CLR语法来实现逻辑交互。    \n\n## XAML的语法定义    \n### XAML的根元素定义    \n根元素定义是定义XAML的命名空间。    \n\n```\n<Page\n  xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n  xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\">\n```\n### XAML的属性语法    \n通过xaml定义按钮，并设置文本为 helloworld 。这种写法在官方文档中称为“属性语法”，即直接在XAML中对属性进行设置。\n\n```\n<Button Background=\"Blue\" Foreground=\"Red\" Content=\"hello world\"/>\n```\n### XAML的属性元素语法    \n通过xaml定义按钮，并设置其背景为蓝色画笔，字体颜色为红色画笔，内容 为helloworld。这种写法在官方文档中称为“属性元素语法”。    \n\n```\n<Button>\n  <Button.Background>\n    <SolidColorBrush Color=\"Blue\"/>\n  </Button.Background>\n  <Button.Foreground>\n    <SolidColorBrush Color=\"Red\"/>\n  </Button.Foreground>\n  <Button.Content>\n    hello world\n  </Button.Content>\n</Button>\n```\n### XAML的集合语法    \n定义按钮的颜色为红色和蓝色渐变色，内容为helloworld。这种称为“集合语法”。    \n\n```\n<LinearGradientBrush>\n  <LinearGradientBrush.GradientStops>\n    <!-- no explicit new GradientStopCollection, parser knows how to find or create -->\n    <GradientStop Offset=\"0.0\" Color=\"Red\" />\n    <GradientStop Offset=\"1.0\" Color=\"Blue\" />\n  </LinearGradientBrush.GradientStops>\n</LinearGradientBrush>\n```\n## XAML的样式定义    \n### 通过属性语法来定义按钮的外观    \n样式定义使用 <Style></Style>标签，然后在中间对样式的内容进行定义。    \n\n例如，以下表示通过XAML语法对 ToggleButton 按钮定义了一个命名为 ToggleLikeButtonStyle 的样式。    \n\n```\n <Style TargetType=\"ToggleButton\" x:Key=\"ToggleLikeButtonStyle\">\n            <Setter Property=\"Margin\"   Value=\"4\" />\n\n            <Setter Property=\"FontWeight\" Value=\"Black\"/>\n\n            <Setter Property=\"Foreground\"  Value=\"Black\" />\n\n            <Setter Property=\"BorderThickness\" Value=\"0\"/>\n\n            <Setter Property=\"IsThreeState\" Value=\"False\"></Setter>\n\n</Style>\n```\n### WPF中的模板Template\nWPF中的控件可以通过模板 Template 的形式来定义其内容，使得开发者能够通过 XAML 灵活的对控件的外观进行扩展。例如，如下定义了一个 Template，这个控件模板将会对控件（Button）定义填充制定颜色。    \n\n```\n <Setter Property=\"Template\">  \n                <Setter.Value>  \n                    <ControlTemplate>  \n                        <Border BorderThickness=\"0\" CornerRadius=\"3\">  \n                            <Border.Background>  \n                                <LinearGradientBrush EndPoint=\"0,1\" StartPoint=\"0,0\">  \n                                    <GradientStop Color=\"#4696F2\" Offset=\"0.5\"/>  \n                                </LinearGradientBrush>  \n                            </Border.Background>  \n                            <ContentPresenter Content=\"{TemplateBinding ContentControl.Content}\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" />  \n                        </Border>  \n                    </ControlTemplate>  \n                </Setter.Value>  \n            </Setter>  \n```\n### XAML中的触发器Triggers\n传统的WinForm开发者习惯于通过事件的机制对按钮的外观进行定义，而在WPF中，则可以通过属性的形式对外观进行设置，这使得开发者更能够写出高质量的代码。  \n\n例如，如下代码通过定义触发器，设置控件（控件为 ToggleButton），当控件的勾选状态属性为“IsChecked” 时，其边框填充色为#4696F2颜色。  \n\n```\n<ControlTemplate.Triggers>  \n                            <Trigger Property=\"IsChecked\" Value=\"True\">  \n  <Setter Property=\"Border.Background\" TargetName=\"PART_Background\"\n<Setter.Value>\n                                        <LinearGradientBrush EndPoint=\"0,1\" StartPoint=\"0,0\">\n                                            <GradientStop Color=\"#4696F2\" Offset=\"0.5\"/>\n                                        </LinearGradientBrush>\n                                    </Setter.Value>\n                                </Setter>\n                                <Setter Property=\"Width\" TargetName=\"PART_Background\" Value=\"60\"></Setter>\n                                <Setter Property=\"Content\"  TargetName=\"contextPresenter\" Value=\"已点赞\"></Setter>\n                                <Setter Property=\"Visibility\"  TargetName=\"contextPresenter\" Value=\"Visible\"></Setter>\n                                <Setter Property=\"Visibility\" TargetName=\"contextImage\" Value=\"Hidden\"/>\n                            </Trigger>\n</ControlTemplate.Triggers>                         \n                                    \n```\n### 部分完整代码\n在上述事例中，共定义了两个按钮的样式，分别是:\n\n* **FlatButtonStyle，这是个圆角按钮。**![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/circleButton.png)\n```\n<Style TargetType=\"Button\" x:Key=\"FlatButtonStyle\">\n            <Setter Property=\"Margin\"   Value=\"4\" />\n            <Setter Property=\"FontWeight\" Value=\"Black\"/>\n            <Setter Property=\"Foreground\"  Value=\"Black\" />\n            <Setter Property=\"BorderThickness\" Value=\"0\"/>\n            <Setter Property=\"Template\">\n                <Setter.Value>\n                    <ControlTemplate>\n                        <Border BorderThickness=\"0\" CornerRadius=\"3\">\n                            <Border.Background>\n                                <LinearGradientBrush EndPoint=\"0,1\" StartPoint=\"0,0\">\n                                    <GradientStop Color=\"#4696F2\" Offset=\"0.5\"/>\n                                </LinearGradientBrush>\n                            </Border.Background>\n                            <ContentPresenter Content=\"{TemplateBinding ContentControl.Content}\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" />\n                        </Border>\n                    </ControlTemplate>\n                </Setter.Value>\n            </Setter>\n        </Style>\n```\n* **ToggleLikeButtonStyle，这是一个点赞按钮。**![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/likeButton.png)。\n```\n<Style TargetType=\"ToggleButton\" x:Key=\"ToggleLikeButtonStyle\">\n            <Setter Property=\"Margin\"   Value=\"4\" />\n            <Setter Property=\"FontWeight\" Value=\"Black\"/>\n            <Setter Property=\"Foreground\"  Value=\"Black\" />\n            <Setter Property=\"BorderThickness\" Value=\"0\"/>\n            <Setter Property=\"IsThreeState\" Value=\"False\"></Setter>\n            <Setter Property=\"Template\">\n                <Setter.Value>\n                    <ControlTemplate TargetType=\"{x:Type ToggleButton}\">\n                        <Border BorderThickness=\"0\" CornerRadius=\"3\" Name=\"PART_Background\">\n                            <Border.Background>\n                                <LinearGradientBrush EndPoint=\"0,1\" StartPoint=\"0,0\">\n                                    <GradientStop Color=\"#525252\" Offset=\"0.5\"/>\n                                </LinearGradientBrush>\n                            </Border.Background>\n                            <Grid>\n                                <ContentPresenter x:Name=\"contextPresenter\" Content=\"{TemplateBinding ContentControl.Content}\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" />\n                                <Image x:Name=\"contextImage\" Width=\"24\" Height=\"24\" Source=\"assests/thumbs-up-outline.png\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\"/>\n                            </Grid>\n                        </Border>\n                        <ControlTemplate.Triggers>\n                            <Trigger Property=\"IsChecked\" Value=\"True\">\n                                <Setter Property=\"Border.Background\" TargetName=\"PART_Background\">\n                                    <Setter.Value>\n                                        <LinearGradientBrush EndPoint=\"0,1\" StartPoint=\"0,0\">\n                                            <GradientStop Color=\"#4696F2\" Offset=\"0.5\"/>\n                                        </LinearGradientBrush>\n                                    </Setter.Value>\n                                </Setter>\n                                <Setter Property=\"Width\" TargetName=\"PART_Background\" Value=\"60\"></Setter>\n                                <Setter Property=\"Content\"  TargetName=\"contextPresenter\" Value=\"已点赞\"></Setter>\n                                <Setter Property=\"Visibility\"  TargetName=\"contextPresenter\" Value=\"Visible\"></Setter>\n                                <Setter Property=\"Visibility\" TargetName=\"contextImage\" Value=\"Hidden\"/>\n                            </Trigger>\n                            <Trigger Property=\"IsChecked\" Value=\"False\">\n                                <Setter Property=\"Border.Background\" TargetName=\"PART_Background\">\n                                    <Setter.Value>\n                                        <LinearGradientBrush EndPoint=\"0,1\" StartPoint=\"0,0\">\n                                            <GradientStop Color=\"#525252\" Offset=\"0.5\"/>\n                                        </LinearGradientBrush>\n                                    </Setter.Value>\n                                </Setter>\n                                <Setter Property=\"Width\" TargetName=\"PART_Background\" Value=\"40\"></Setter>\n                                <Setter Property=\"Visibility\"  TargetName=\"contextPresenter\" Value=\"Hidden\"></Setter>\n                                <Setter Property=\"Visibility\" TargetName=\"contextImage\" Value=\"Visible\"/>\n                            </Trigger>\n                        </ControlTemplate.Triggers>\n                    </ControlTemplate>\n                </Setter.Value>\n            </Setter>\n</Style>\n```\n## XAML的[标记扩展](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/markup-extensions-and-wpf-xaml)\n通过了解WPF的常用控件，我们可以知道自己需要使用的控件有哪些属性，并能使用 XAML 语法对相应的属性进行设置，这种设置方法有别于通过C#代码的形式进行定义的方法，在 XAML中的属性称为 “标记”。标记使用 “{}” 花括号，编译器通过该花括号将语法和XAML语法进行区分。  \n\n例如：  \n\n```\n HeaderTemplate=\"{DynamicResource StretchedHeaderTemplate}\"  \n```\n### 标记值的转换与TypeConverters  \n在进行标记值转换时，有时候需要使用TypeConverters实现类型转换。例如，在上述示例代码中，可以看到使用了字符串“#525252”来定义颜色，在内部就是实现了从字符串到 Color 类的转换过程。限于篇幅有限，此处就暂时略过。  \n\n### XAML中内置特殊标记扩展  \n* x:Type：特定类型  \n```\n<object property=\"{x:Type prefix:typeNameValue}\" .../>    \n```\n* x:Static：使用静态值。  \n```\n<object property=\"{x:Static prefix:typeName.staticMemberName}\" .../>    \n```\n* x:Null：使用空对象定义为属性值。  \n```\n<object property=\"{x:Null}\" .../>    \n```\n* x:Array：使用数组对象。  \n```\n<x:Array Type=\"typeName\">    \n  arrayContents    \n</x:Array>    \n```\n### 常见的标记扩展\n1. StaticResource：通过替换已定义资源的值来为属性提供内容，该资源标记在XAML加载时自动执行。静态资源无法通过在XAML语法体系中对其引用关系进行前向引用，意味着无法通过多层级关系定义可复用的样式资源，如果需要这样做，则需要使用DynamicResource。  \n```\n<object property=\"{StaticResource key}\" .../>    \n```\n2. DynamicResource：在运行时为资源提供内容。  \n```\n<object property=\"{DynamicResource key}\" .../>    \n```\n3. Binding：在运行时为使用数据上下文为数据提供内容。  \n```\n<object property=\"{Binding}\" .../>    \n-or-  \n<object property=\"{Binding  bindProp1=value1[, bindPropN=valueN]*}\" ...  \n/>    \n-or-    \n<object property=\"{Binding path}\" .../>  \n-or     \n<object property=\"{Binding path[, bindPropN=valueN]*}\" .../>    \n```\n4. RelativeSource：提供了可在运行时对象树中导航几个可能的关系的 [Binding](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.data.binding) 的源信息。  \n```\n<Binding RelativeSource=\"{RelativeSource modeEnumValue}\" .../>  \n```\n5. TemplateBinding：使控件模板能够使用模板化属性的值，这些属性来自于将使用该模板的类的对象模型定义属性。  \n```\n<object property=\"{TemplateBinding sourceProperty}\" .../>    \n```\n6. ColorConvertedBitmap：提供一种方法，用于指定没有嵌入的配置文件的位图源。 颜色上下文/配置文件由 URI 指定，与映像源 URI 相同。  \n```\n<object property=\"{ColorConvertedBitmap imageSource sourceIIC destinationIIC}\" .../>    \n```\n7. ComponentResourceKey和TemplateResourceKey：  \n```\n<object x:Key=\"{ComponentResourceKey {x:Type targetTypeName}, targetID}\" .../>    \n```\n## XAML资源复用\n在开发过程中，我们可以直接在按钮上进行按钮模板的定义，例如下面的代码。  \n\n```\n<Button Width=\"40\" Height=\"40\" Style=\"{DynamicResource CubeImageButtonStyle}\" Click=\"Button_Click\" Content=\"点赞\">\n    <Button.Background>\n                                <ImageBrush ImageSource=\"/assests/favicon.png\" Stretch=\"Fill\"/> \n                            </Button.Background>\n                        </Button>   \n                          <Setter Property=\"Template\"\n                <Setter.Value>\n                    <ControlTemplate>\n                        <Border BorderThickness=\"0\" CornerRadius=\"3\">\n                            <Border.Background>\n                                <LinearGradientBrush EndPoint=\"0,1\" StartPoint=\"0,0\">\n                                    <GradientStop Color=\"#4696F2\" Offset=\"0.5\"/>\n                                </LinearGradientBrush>\n                            </Border.Background>\n                            <ContentPresenter Content=\"{TemplateBinding ContentControl.Content}\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" />\n                        </Border>\n                    </ControlTemplate>\n                </Setter.Value>\n            </Setter>\n        </Style>\n </Window.Resources>\n <Grid>\n<Button Grid.Column=\"0\" Grid.Row=\"1\" Style=\"{StaticResource FlatButtonStyle}\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Top\" Width=\"48\" Height=\"16\" FontSize=\"10\" Background=\"#4696F2\" Content=\"获取\"></Button>\n </Grid>\n                        \n```\n这样的代码在界面比较简单时，还无所谓，但是随着控件的样式越来越复杂，可能会成为一团乱麻，这对于追求优雅代码的我们来说，可能是难以忍受的，所以往往会使用资源引用来完成。    \n### StaticResource    \n例如，我们可以在当前页面代码中定义对应的样式，这种样式可以使用 StaticResource 的形式引入。但是这样的引用形式，没有对象图的访问权限，意味着无法访问资源依赖的其他资源。    \n\n```\n <Window.Resources>  \n<Style TargetType=\"Button\" x:Key=\"FlatButtonStyle\">     \n            <Setter Property=\"Margin\"   Value=\"4\" />    \n            <Setter Property=\"FontWeight\" Value=\"Black\"/>    \n            <Setter Property=\"Foreground\"  Value=\"Black\" />        \n            <Setter Property=\"BorderThickness\" Value=\"0\"/>    \n</Window.Resources>          \n```\n### DynamicResource\n将上述代码中的{StaticResource FlatButtonStyle} 改成{StaticResource  FlatButtonStyle}则会在运行时加载样式，并可以访问相应的对象图。\n\n当然，这样的更改意义不大，如果该FlatButtonStyle引用了其他样式或元素，会发生作用。\n\n```\n<Grid\n<Button Grid.Column=\"0\" Grid.Row=\"1\" Style=\"{StaticResource FlatButtonStyle}\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Top\" Width=\"48\" Height=\"16\" FontSize=\"10\" Background=\"#4696F2\" Content=\"获取\"></Button>\n </Grid>\n```\n## 注意事项\n1、由于XAML语法脱胎于XML语法，而XML语法中本身对某些输入字符，如“<>”存在限制，所以在XAML中也会出现这类问题，并会被Visual Studio检测出错误而无法编译，需要使用UTF-8编码进行转换。  \n\n# 用户控件和自定义控件  \n## 用户控件  \n而用户控件，使用于控件组合的场景。  \n\n## 自定义控件  \n在笔者进行开发时，总是思考究竟是使用用户控件，还是自定义控件，后来在阅读《葵花宝典-WPF自学手册》这本书中，终于得以大彻大悟。  \n\n作者指出：“不要被控件的外观所欺骗，要考虑其内在本质”。即思考控件的基本特征，首先想到该控件的行为与原有控件的行为是否相似，如果能够找到，则修改原有控件，而不是定义一个控件。尤其是在XAML语法中，能够通过Content 模型和模板、附加属性的运用，使得自定义控件的用途得到了进一步缩减，只有当实在万不得已时，在定义自定义控件。\n\n作者给出了使用自定义控件的分析思路：    \n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/flow.png)\n\n例如，在示例代码**ToggleLikeButtonStyle **中，我实现了一个点赞和取消点赞的状态，则使用了ToggleButton来完成，就没必要使用 Button 扩展出一个是否点赞的状态了。  \n\n而如果我们需要实现的功能有这么复杂，那大概使用传统的控件就无法实现，就得使用自定义控件了。（[点击查看示例代码](https://github.com/caomfan/WpfDemo.git)）\n\n![图片](https://uploader.shimo.im/f/f44dU5UMbaYZpJtm.png!thumbnail)\n\n作者定义了自定义控件 ButtonEx，并实现了依赖属性 ButtonType，见【依赖属性】，并定义了不同类型的样式特征。  \n\n```\n <Trigger Property=\"ButtonType\" Value=\"Icon\">\n                <Setter Property=\"Cursor\" Value=\"Hand\"/>\n                <Setter Property=\"Template\">\n                    <Setter.Value>\n                        <ControlTemplate TargetType=\"{x:Type controls:ButtonEx}\">\n                            <Border Width=\"{TemplateBinding Width}\" Height=\"{TemplateBinding Height}\">\n                                <Image x:Name=\"Img\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\" Source=\"{TemplateBinding Icon}\" Stretch=\"None\"/>\n                            </Border>\n                            <ControlTemplate.Triggers>\n                                <Trigger Property=\"IsMouseOver\" Value=\"True\">\n                                    <Setter Property=\"Opacity\" Value=\"0.8\"/>\n                                </Trigger>\n                                <Trigger Property=\"IsPressed\" Value=\"True\">\n                                    <Setter Property=\"Opacity\" Value=\"0.9\"/>\n                                </Trigger>\n                            </ControlTemplate.Triggers>\n                        </ControlTemplate>\n                    </Setter.Value>\n                </Setter>\n            </Trigger>\n```\n使用时，只需这样设置，即可实现不同类型的按钮外观。\n```\n <controls:ButtonEx Icon=\"/Images/search.png\"  Margin=\"10\" ButtonType=\"Icon\"/>\n```\n# 属性和事件  \n## [依赖属性](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/dependency-properties-overview)  \n依赖属性是为既有WPF控件对象定义自定义属性，以便支持其扩展，例如在上述自定义控件的示例中，就定义了依赖属性 ButtonType，实现了不同类型的按钮外观。  \n\n```\npublic ButtonType ButtonType  \n        {\n            get { return (ButtonType)GetValue(ButtonTypeProperty); }\n            set { SetValue(ButtonTypeProperty, value); }\n        }\n\n\n        public static readonly DependencyProperty ButtonTypeProperty =\n```\n##             DependencyProperty.Register(\"ButtonType\", typeof(ButtonType), typeof(ButtonEx), new PropertyMetadata(ButtonType.Normal));\n\n\n[附加属性](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/attached-properties-overview)  \n按照官方的说法就是“附加属性旨在用作可在任何对象上设置的一类全局属性”，例如，DockPanel面板中的子对象，继承了来自于容器对象的附加属性，使得其能够在父对象中实现停靠的功能。  \n\n```\n<DockPanel>\n  <CheckBox DockPanel.Dock=\"Top\">Hello</CheckBox>\n</DockPanel>\n```\n## [路由事件](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/routed-events-overview)  \n### 基本定义  \n假设我们定义了几个这样的控件。  \n\n```\n<Border Height=\"50\" Width=\"300\" BorderBrush=\"Gray\" BorderThickness=\"1\">\n  <StackPanel Background=\"LightGray\" Orientation=\"Horizontal\" Button.Click=\"CommonClickHandler\">\n    <Button Name=\"YesButton\" Width=\"Auto\" >Yes</Button>\n    <Button Name=\"NoButton\" Width=\"Auto\" >No</Button>\n    <Button Name=\"CancelButton\" Width=\"Auto\" >Cancel</Button>\n  </StackPanel>\n</Border>\n```\n实现了这样的界面![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/ui.png)\n\n路由事件就是针对这组元素树中多个元素调用处理程序的事件。当我们点击了按钮Button时，将会触发 Button=>StackPanel=>Border的事件路由，而不是像WinForm应用一样，只能触发最上层的Button的按钮点击事件。  \n\n### 路由策略\n* 冒泡事件（官方称为浮升，这个翻译有点。。）：调用事件源上的事件处理程序。 路由事件随后会路由到后续的父级元素，直到到达元素树的根。 大多数路由事件都使用浮升路由策略。 浮升路由事件通常用于报告来自不同控件或其他 UI 元素的输入或状态变化。  \n* 直接： 只有源元素本身才有机会调用处理程序以进行响应。通过使用 [EventSetter](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.eventsetter) 和 [EventTrigger](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.eventtrigger)使用来设置处理程序。例如，可以使用RoutedEventArgs的[Handled](https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.routedeventargs.handled)，设置为 true 将事件标记为已处理，将 \"停止\" 路由用于隧道路由或冒泡路由。  \n```\nvoid MakeButton2()\n{\n  Button b2 = new Button();\n  b2.Click += new RoutedEventHandler(Onb2Click2);\n}\nvoid Onb2Click2(object sender, RoutedEventArgs e)\n{\n  //logic to handle the Click event     \n}\n```\n* 隧道：最初将调用元素树的根处的事件处理程序。 随后，路由事件将朝着路由事件的源节点元素（即引发路由事件的元素）方向，沿路由线路传播到后续的子元素。  \n* WPF中约定，隧道路由事件的名称以单词“Preview”开头。 输入事件通常成对出现，一个是浮升事件，另一个是隧道事件。例如，如下图所示，假设按钮2为触发事件的源。  \n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/event.png)\n\n1、处理Border根元素的隧道事件PreviewMouseDown  \n\n2、处理StackPanel面板的隧道事件PreviewMouseDown.  \n\n3、处理Button按钮的隧道事件的PreMouseDown。  \n\n4、处理Button按钮的MouseDown事件。  \n\n5、处理StackPanel的MouseDown事件。  \n\n6、处理Border的MouseDown事件。    \n\n# 总结\nWPF是一个非常庞大的技术体系，以上学习路径仅供开发者进行简单的入门，由于篇幅有限，对于标记扩展还需要进一步理解透彻，以及格式转换、图形绘制、数据绑定、MVVM等内容未能一一描述。  \n\n如果果想要对WPF进一步了解，最好通过系统的学习相关知识，除了前面提到的网站和几本书，最好的入门网站依然是[微软官方文档](https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/)。  \n\n#  \n \n\n\n","slug":"技术/how-to-learn-wpf","published":1,"updated":"2020-02-23T08:28:15.612Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt6p0008n4vitndsgk6p","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>在桌面开发领域，虽然在某些领域，基于electron的跨平台方案能够为我们带来某些便利，但是由于WPF技术能够更好的运用Direct3D带来的性能提升、以及海量Windows操作系统和硬件资源的支持，所以他依然有着得天独厚的优势。    </p>\n<p>当然，选用一门技术，依然看公司的基因土壤和综合因素或者老板的心血来潮，例如QT也同样是一门非常不错的跨平台图形界面解决方案。    </p>\n<p>目前我们公司在桌面开发领域广泛应用了WPF技术，主要是使用其作为大屏数据可视化相关的UI呈现，包括一些数据展示效果、动画效果等。由于之前我对WPF仅有三周经验，因此在开发和设计相关功能时，一些简单功能还能勉强完成，稍微复杂一点的就有点费时过长了，因此这篇文章主要梳理自己的学习笔记，以便总结学习成果。    </p>\n<h1 id=\"如何学习WPF技术？\"><a href=\"#如何学习WPF技术？\" class=\"headerlink\" title=\"如何学习WPF技术？\"></a>如何学习WPF技术？</h1><p>在Quote上有人提出了这样一个相同的问题，<a href=\"https://www.quora.com/How-can-I-learn-WPF-easily\" target=\"_blank\" rel=\"noopener\">查看问题</a>，开发者Srikanth Pagadala如是回答：    </p>\n<blockquote>\n<p>1、以了解基础控件作为学习的起步过程：这些控件包括TextBox,Button,TextBlock及其他的，理解这些控件对外提供的属性，以及如何使用。<br>2、了解和使用布局空间：例如Grid、StackPanel、DockerPanel和其他控件，在这一点上，你需要花费大量的时间。同时你需要学会创建复杂的UI设计。<br>3、了解循环类型的空间，例如ItemControl控件。<br>4、了解关于模板的概念。包括如何定义包含CheckBox的Combox，同时这个控件还包含了一张图片的按钮，以及如何在ItemsControl中使用不同的模板。<br>5、理解数据绑定的运行机制。尝试创建一个MVVM或类似类型的应用程序。<br>6、创建一个典型的控件，探索DependencyProperties（依赖属性）和AttachedProperties（附加属性）。<br>7、创建一个样式资源，理解如何给控件设计样式。</p>\n</blockquote>\n<p>除此之外，还有其他开发者给出了补充回答：    </p>\n<blockquote>\n<p>1、学习控件的数据绑定过程，在DataGrid上实现数据绑定。<br>2、学习和实现INotifyPropertyChanged类。<a href=\"https://msdn.microsoft.com/en-us/library/vstudio/ms743695(v=vs.100).aspx\" target=\"_blank\" rel=\"noopener\">查看如何实现</a><br>3、学习Observable Collection。该类型的集合广泛使用于数据集合绑定方面，同时也提供了数据改变通知的机制。<br>4、使网格上的列可编辑。用文本控件（用户项目模板）替换列。为每个捕获文本更改事件的列创建一个属性。在文本控件上使用绑定类型。尝试捕获您在后端在网格上所做的更改。<br>5、成功将数据控件中的文本控件与后端属性绑定后，请在同一页面上创建网格的副本。尝试同步这两个网格。例如，您在第一个网格中所做的每个更改都必须在第二个网格中自动更新。</p>\n</blockquote>\n<p>网站“<a href=\"https://www.wpf-tutorial.com/\" target=\"_blank\" rel=\"noopener\">https://www.wpf-tutorial.com/</a>”是一个专门用于学习WPF的网站，通过这个网站，可以快速的入门WPF。    </p>\n<p>由于WPF技术已经比较熟悉，所以书籍也比较多，网友推荐来自刘铁猛老师的《深入浅出WPF》这本书，而我通过Kindle则看到了一本比较有意思的书《葵花宝典-WPF自学手册》，这本书写得比较生动，通过故事的形式讲了WPF的许多技术原理，无形中让我对WPF的概念有了许多新的认识。当然，这本书已经有点年头了。    </p>\n<h1 id=\"WPF的常用控件\"><a href=\"#WPF的常用控件\" class=\"headerlink\" title=\"WPF的常用控件\"></a>WPF的常用控件</h1><p>| 控件类型   | 控件名称   | 控件说明   | 链接地址   |<br>|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|<br>| 组件   | Window   | 窗口   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.window?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Page   | 页面   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.page?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | NavigationWindow   | 导航窗口   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.navigation.navigationwindow?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Frame   |    | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Frame\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>| 常规控件   | Button   | 按钮控件，提供Content作为内容   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Button\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | TextBox   | 文本框控件，用以输入文本   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TextBox\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | TextBlock   | 文本块，用以显示文本   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TextBlock\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Label   | 标签，用以显示文本   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Label\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ProgressBar   | 进度条   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ProgressBar\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ToggleButton   | 一种可以设置开关三态的按钮   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.primitives.togglebutton?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Image   | 图像控件，通过Source设置资源路径   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Image\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | CheckBox   | 勾选框，可以设置是否勾选的三种状态   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/CheckBox\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | RichTextBox   | 富文本框，可以多种格式显示和输入文本   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/RichTextBox\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | TreeView   | 树视图，以树状图的形式显示绑定内容，可以显示是否勾选三态。   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TreeView\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | WebBrowser   | 浏览器，基于IE内核的浏览器控件   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.webbrowser?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Calendar   | 日历控件   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.calendar?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ComboBox   | 下拉列表   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ComboBox\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ContentControl   | 内容控件   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.contentcontrol?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Expander   | 扩展器，可以显示和折叠面板内的元素   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Expander\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | GroupBox   | 分组框   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/GroupBox\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | StatusBar   | 状态栏，用于在页面下方显示状态信息。   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/StatusBar\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | DateTimePicker   | 时间控件，可以设置时间状态。   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.forms.datetimepicker?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | DocumentViewer   | 文档查看器   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/DocumentViewer\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | RadioButton   | 单选按钮   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/RadioButton\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ScollViewer   | 滚动视图   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/scrollviewer-overview\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ScollBar   | 滚动条   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.primitives.scrollbar?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Separator   | 分隔器   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Separator\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ToolBar   | 工具条   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ToolBar\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Slider   |    | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Slider\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Menu   | 菜单   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Menu\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | MediaElement   | 多媒体控件   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.mediaelement?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | PasswordBox   | 密码输入框   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/PasswordBox\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | TabControl   | 选项卡   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TabControl\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ToolBarTray   | 工具条   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.toolbartray?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | WindowsFormsHost   | 用以承载WinForm   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.forms.integration.windowsformshost?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Border   | 边框   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Border\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>| 数据控件   | ListView   | 列表视图   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ListView\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | DataGrid   | 数据表   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/datagrid\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ListBox   | 列表框   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ListBox\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>| 布局   | WrapPanel   | 可变面板   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/WrapPanel\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | StackPanel   | 固定面板   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/StackPanel\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | DockerPanel   | 停靠面板   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.dockpanel?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Grid   | 表格布局   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Grid\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | UniformGrid   | 统一分布表格布局   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.primitives.uniformgrid?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>| <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Label\" target=\"_blank\" rel=\"noopener\">查看示例</a>   | Canvas   | 画布   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Canvas\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>| 图形   | Point   | 点   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Border\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Line   | 线   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.line?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Path   | 路径   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.path?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Polygon   | 多边形   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.polygon?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Polyline   | 多段线   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.polyline?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Rectangle   | 矩形   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.rectangle?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Shape   | 画笔   | <a href=\"http://各类图元的基类\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Rectangle   | 矩形   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.rectangle?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Ellipse   | 椭圆   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.ellipse?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   | </p>\n<h1 id=\"WPF的XAML语法\"><a href=\"#WPF的XAML语法\" class=\"headerlink\" title=\"WPF的XAML语法\"></a>WPF的XAML语法</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>在WPF技术中引入的XAML语法算是该技术的一大特色，也是被学习者视同为学习路径陡峭的“罪魁祸首”。原因是在前端技术飞速发展的今天，HTML的语法体系由于更早的被开发者接受，所以也自然而然更容易成为开发者的首选。    </p>\n<p>而XAML是一种脱胎于XML，并吸收了HTML的精华的语法体系，是一种界面描述语言，XML语法本身相对而言较为臃肿的体系，看似成为了他的历史负担，但是其实倒也没那么复杂，通过几个简单的示例，其实就足够掌握这门新的语法体系了。例如，使用<button></button>这样的语法，完全可以平滑过渡到<button></button>这样的语法体系。(部分标签其实只是大小写不同）。当然，在XAML中熟练编写样式，确实需要花一点点时间。    </p>\n<p>在WPF中，通过XAML定义面向用户交互层的界面，然后编译成baml运行，后端则使用C#或VB.NET这样的CLR语法来实现逻辑交互。    </p>\n<h2 id=\"XAML的语法定义\"><a href=\"#XAML的语法定义\" class=\"headerlink\" title=\"XAML的语法定义\"></a>XAML的语法定义</h2><h3 id=\"XAML的根元素定义\"><a href=\"#XAML的根元素定义\" class=\"headerlink\" title=\"XAML的根元素定义\"></a>XAML的根元素定义</h3><p>根元素定义是定义XAML的命名空间。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Page</span><br><span class=\"line\">  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class=\"line\">  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"XAML的属性语法\"><a href=\"#XAML的属性语法\" class=\"headerlink\" title=\"XAML的属性语法\"></a>XAML的属性语法</h3><p>通过xaml定义按钮，并设置文本为 helloworld 。这种写法在官方文档中称为“属性语法”，即直接在XAML中对属性进行设置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button Background=&quot;Blue&quot; Foreground=&quot;Red&quot; Content=&quot;hello world&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"XAML的属性元素语法\"><a href=\"#XAML的属性元素语法\" class=\"headerlink\" title=\"XAML的属性元素语法\"></a>XAML的属性元素语法</h3><p>通过xaml定义按钮，并设置其背景为蓝色画笔，字体颜色为红色画笔，内容 为helloworld。这种写法在官方文档中称为“属性元素语法”。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button&gt;</span><br><span class=\"line\">  &lt;Button.Background&gt;</span><br><span class=\"line\">    &lt;SolidColorBrush Color=&quot;Blue&quot;/&gt;</span><br><span class=\"line\">  &lt;/Button.Background&gt;</span><br><span class=\"line\">  &lt;Button.Foreground&gt;</span><br><span class=\"line\">    &lt;SolidColorBrush Color=&quot;Red&quot;/&gt;</span><br><span class=\"line\">  &lt;/Button.Foreground&gt;</span><br><span class=\"line\">  &lt;Button.Content&gt;</span><br><span class=\"line\">    hello world</span><br><span class=\"line\">  &lt;/Button.Content&gt;</span><br><span class=\"line\">&lt;/Button&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"XAML的集合语法\"><a href=\"#XAML的集合语法\" class=\"headerlink\" title=\"XAML的集合语法\"></a>XAML的集合语法</h3><p>定义按钮的颜色为红色和蓝色渐变色，内容为helloworld。这种称为“集合语法”。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;LinearGradientBrush&gt;</span><br><span class=\"line\">  &lt;LinearGradientBrush.GradientStops&gt;</span><br><span class=\"line\">    &lt;!-- no explicit new GradientStopCollection, parser knows how to find or create --&gt;</span><br><span class=\"line\">    &lt;GradientStop Offset=&quot;0.0&quot; Color=&quot;Red&quot; /&gt;</span><br><span class=\"line\">    &lt;GradientStop Offset=&quot;1.0&quot; Color=&quot;Blue&quot; /&gt;</span><br><span class=\"line\">  &lt;/LinearGradientBrush.GradientStops&gt;</span><br><span class=\"line\">&lt;/LinearGradientBrush&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"XAML的样式定义\"><a href=\"#XAML的样式定义\" class=\"headerlink\" title=\"XAML的样式定义\"></a>XAML的样式定义</h2><h3 id=\"通过属性语法来定义按钮的外观\"><a href=\"#通过属性语法来定义按钮的外观\" class=\"headerlink\" title=\"通过属性语法来定义按钮的外观\"></a>通过属性语法来定义按钮的外观</h3><p>样式定义使用 <style></style>标签，然后在中间对样式的内容进行定义。    </p>\n<p>例如，以下表示通过XAML语法对 ToggleButton 按钮定义了一个命名为 ToggleLikeButtonStyle 的样式。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;Style TargetType=&quot;ToggleButton&quot; x:Key=&quot;ToggleLikeButtonStyle&quot;&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;Margin&quot;   Value=&quot;4&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;Setter Property=&quot;FontWeight&quot; Value=&quot;Black&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;Setter Property=&quot;Foreground&quot;  Value=&quot;Black&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;0&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;Setter Property=&quot;IsThreeState&quot; Value=&quot;False&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/Style&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WPF中的模板Template\"><a href=\"#WPF中的模板Template\" class=\"headerlink\" title=\"WPF中的模板Template\"></a>WPF中的模板Template</h3><p>WPF中的控件可以通过模板 Template 的形式来定义其内容，使得开发者能够通过 XAML 灵活的对控件的外观进行扩展。例如，如下定义了一个 Template，这个控件模板将会对控件（Button）定义填充制定颜色。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;Setter Property=&quot;Template&quot;&gt;  </span><br><span class=\"line\">                &lt;Setter.Value&gt;  </span><br><span class=\"line\">                    &lt;ControlTemplate&gt;  </span><br><span class=\"line\">                        &lt;Border BorderThickness=&quot;0&quot; CornerRadius=&quot;3&quot;&gt;  </span><br><span class=\"line\">                            &lt;Border.Background&gt;  </span><br><span class=\"line\">                                &lt;LinearGradientBrush EndPoint=&quot;0,1&quot; StartPoint=&quot;0,0&quot;&gt;  </span><br><span class=\"line\">                                    &lt;GradientStop Color=&quot;#4696F2&quot; Offset=&quot;0.5&quot;/&gt;  </span><br><span class=\"line\">                                &lt;/LinearGradientBrush&gt;  </span><br><span class=\"line\">                            &lt;/Border.Background&gt;  </span><br><span class=\"line\">                            &lt;ContentPresenter Content=&quot;&#123;TemplateBinding ContentControl.Content&#125;&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt;  </span><br><span class=\"line\">                        &lt;/Border&gt;  </span><br><span class=\"line\">                    &lt;/ControlTemplate&gt;  </span><br><span class=\"line\">                &lt;/Setter.Value&gt;  </span><br><span class=\"line\">            &lt;/Setter&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"XAML中的触发器Triggers\"><a href=\"#XAML中的触发器Triggers\" class=\"headerlink\" title=\"XAML中的触发器Triggers\"></a>XAML中的触发器Triggers</h3><p>传统的WinForm开发者习惯于通过事件的机制对按钮的外观进行定义，而在WPF中，则可以通过属性的形式对外观进行设置，这使得开发者更能够写出高质量的代码。  </p>\n<p>例如，如下代码通过定义触发器，设置控件（控件为 ToggleButton），当控件的勾选状态属性为“IsChecked” 时，其边框填充色为#4696F2颜色。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ControlTemplate.Triggers&gt;  </span><br><span class=\"line\">                            &lt;Trigger Property=&quot;IsChecked&quot; Value=&quot;True&quot;&gt;  </span><br><span class=\"line\">  &lt;Setter Property=&quot;Border.Background&quot; TargetName=&quot;PART_Background&quot;</span><br><span class=\"line\">&lt;Setter.Value&gt;</span><br><span class=\"line\">                                        &lt;LinearGradientBrush EndPoint=&quot;0,1&quot; StartPoint=&quot;0,0&quot;&gt;</span><br><span class=\"line\">                                            &lt;GradientStop Color=&quot;#4696F2&quot; Offset=&quot;0.5&quot;/&gt;</span><br><span class=\"line\">                                        &lt;/LinearGradientBrush&gt;</span><br><span class=\"line\">                                    &lt;/Setter.Value&gt;</span><br><span class=\"line\">                                &lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Width&quot; TargetName=&quot;PART_Background&quot; Value=&quot;60&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Content&quot;  TargetName=&quot;contextPresenter&quot; Value=&quot;已点赞&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Visibility&quot;  TargetName=&quot;contextPresenter&quot; Value=&quot;Visible&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Visibility&quot; TargetName=&quot;contextImage&quot; Value=&quot;Hidden&quot;/&gt;</span><br><span class=\"line\">                            &lt;/Trigger&gt;</span><br><span class=\"line\">&lt;/ControlTemplate.Triggers&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"部分完整代码\"><a href=\"#部分完整代码\" class=\"headerlink\" title=\"部分完整代码\"></a>部分完整代码</h3><p>在上述事例中，共定义了两个按钮的样式，分别是:</p>\n<ul>\n<li><p><strong>FlatButtonStyle，这是个圆角按钮。</strong><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/circleButton.png\" alt=\"图片\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Style TargetType=&quot;Button&quot; x:Key=&quot;FlatButtonStyle&quot;&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;Margin&quot;   Value=&quot;4&quot; /&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;FontWeight&quot; Value=&quot;Black&quot;/&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;Foreground&quot;  Value=&quot;Black&quot; /&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;0&quot;/&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;Template&quot;&gt;</span><br><span class=\"line\">                &lt;Setter.Value&gt;</span><br><span class=\"line\">                    &lt;ControlTemplate&gt;</span><br><span class=\"line\">                        &lt;Border BorderThickness=&quot;0&quot; CornerRadius=&quot;3&quot;&gt;</span><br><span class=\"line\">                            &lt;Border.Background&gt;</span><br><span class=\"line\">                                &lt;LinearGradientBrush EndPoint=&quot;0,1&quot; StartPoint=&quot;0,0&quot;&gt;</span><br><span class=\"line\">                                    &lt;GradientStop Color=&quot;#4696F2&quot; Offset=&quot;0.5&quot;/&gt;</span><br><span class=\"line\">                                &lt;/LinearGradientBrush&gt;</span><br><span class=\"line\">                            &lt;/Border.Background&gt;</span><br><span class=\"line\">                            &lt;ContentPresenter Content=&quot;&#123;TemplateBinding ContentControl.Content&#125;&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt;</span><br><span class=\"line\">                        &lt;/Border&gt;</span><br><span class=\"line\">                    &lt;/ControlTemplate&gt;</span><br><span class=\"line\">                &lt;/Setter.Value&gt;</span><br><span class=\"line\">            &lt;/Setter&gt;</span><br><span class=\"line\">        &lt;/Style&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>ToggleLikeButtonStyle，这是一个点赞按钮。</strong><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/likeButton.png\" alt=\"图片\">。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Style TargetType=&quot;ToggleButton&quot; x:Key=&quot;ToggleLikeButtonStyle&quot;&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;Margin&quot;   Value=&quot;4&quot; /&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;FontWeight&quot; Value=&quot;Black&quot;/&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;Foreground&quot;  Value=&quot;Black&quot; /&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;0&quot;/&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;IsThreeState&quot; Value=&quot;False&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;Template&quot;&gt;</span><br><span class=\"line\">                &lt;Setter.Value&gt;</span><br><span class=\"line\">                    &lt;ControlTemplate TargetType=&quot;&#123;x:Type ToggleButton&#125;&quot;&gt;</span><br><span class=\"line\">                        &lt;Border BorderThickness=&quot;0&quot; CornerRadius=&quot;3&quot; Name=&quot;PART_Background&quot;&gt;</span><br><span class=\"line\">                            &lt;Border.Background&gt;</span><br><span class=\"line\">                                &lt;LinearGradientBrush EndPoint=&quot;0,1&quot; StartPoint=&quot;0,0&quot;&gt;</span><br><span class=\"line\">                                    &lt;GradientStop Color=&quot;#525252&quot; Offset=&quot;0.5&quot;/&gt;</span><br><span class=\"line\">                                &lt;/LinearGradientBrush&gt;</span><br><span class=\"line\">                            &lt;/Border.Background&gt;</span><br><span class=\"line\">                            &lt;Grid&gt;</span><br><span class=\"line\">                                &lt;ContentPresenter x:Name=&quot;contextPresenter&quot; Content=&quot;&#123;TemplateBinding ContentControl.Content&#125;&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt;</span><br><span class=\"line\">                                &lt;Image x:Name=&quot;contextImage&quot; Width=&quot;24&quot; Height=&quot;24&quot; Source=&quot;assests/thumbs-up-outline.png&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt;</span><br><span class=\"line\">                            &lt;/Grid&gt;</span><br><span class=\"line\">                        &lt;/Border&gt;</span><br><span class=\"line\">                        &lt;ControlTemplate.Triggers&gt;</span><br><span class=\"line\">                            &lt;Trigger Property=&quot;IsChecked&quot; Value=&quot;True&quot;&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Border.Background&quot; TargetName=&quot;PART_Background&quot;&gt;</span><br><span class=\"line\">                                    &lt;Setter.Value&gt;</span><br><span class=\"line\">                                        &lt;LinearGradientBrush EndPoint=&quot;0,1&quot; StartPoint=&quot;0,0&quot;&gt;</span><br><span class=\"line\">                                            &lt;GradientStop Color=&quot;#4696F2&quot; Offset=&quot;0.5&quot;/&gt;</span><br><span class=\"line\">                                        &lt;/LinearGradientBrush&gt;</span><br><span class=\"line\">                                    &lt;/Setter.Value&gt;</span><br><span class=\"line\">                                &lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Width&quot; TargetName=&quot;PART_Background&quot; Value=&quot;60&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Content&quot;  TargetName=&quot;contextPresenter&quot; Value=&quot;已点赞&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Visibility&quot;  TargetName=&quot;contextPresenter&quot; Value=&quot;Visible&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Visibility&quot; TargetName=&quot;contextImage&quot; Value=&quot;Hidden&quot;/&gt;</span><br><span class=\"line\">                            &lt;/Trigger&gt;</span><br><span class=\"line\">                            &lt;Trigger Property=&quot;IsChecked&quot; Value=&quot;False&quot;&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Border.Background&quot; TargetName=&quot;PART_Background&quot;&gt;</span><br><span class=\"line\">                                    &lt;Setter.Value&gt;</span><br><span class=\"line\">                                        &lt;LinearGradientBrush EndPoint=&quot;0,1&quot; StartPoint=&quot;0,0&quot;&gt;</span><br><span class=\"line\">                                            &lt;GradientStop Color=&quot;#525252&quot; Offset=&quot;0.5&quot;/&gt;</span><br><span class=\"line\">                                        &lt;/LinearGradientBrush&gt;</span><br><span class=\"line\">                                    &lt;/Setter.Value&gt;</span><br><span class=\"line\">                                &lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Width&quot; TargetName=&quot;PART_Background&quot; Value=&quot;40&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Visibility&quot;  TargetName=&quot;contextPresenter&quot; Value=&quot;Hidden&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Visibility&quot; TargetName=&quot;contextImage&quot; Value=&quot;Visible&quot;/&gt;</span><br><span class=\"line\">                            &lt;/Trigger&gt;</span><br><span class=\"line\">                        &lt;/ControlTemplate.Triggers&gt;</span><br><span class=\"line\">                    &lt;/ControlTemplate&gt;</span><br><span class=\"line\">                &lt;/Setter.Value&gt;</span><br><span class=\"line\">            &lt;/Setter&gt;</span><br><span class=\"line\">&lt;/Style&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"XAML的标记扩展\"><a href=\"#XAML的标记扩展\" class=\"headerlink\" title=\"XAML的标记扩展\"></a>XAML的<a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/markup-extensions-and-wpf-xaml\" target=\"_blank\" rel=\"noopener\">标记扩展</a></h2><p>通过了解WPF的常用控件，我们可以知道自己需要使用的控件有哪些属性，并能使用 XAML 语法对相应的属性进行设置，这种设置方法有别于通过C#代码的形式进行定义的方法，在 XAML中的属性称为 “标记”。标记使用 “{}” 花括号，编译器通过该花括号将语法和XAML语法进行区分。  </p>\n<p>例如：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> HeaderTemplate=&quot;&#123;DynamicResource StretchedHeaderTemplate&#125;&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"标记值的转换与TypeConverters\"><a href=\"#标记值的转换与TypeConverters\" class=\"headerlink\" title=\"标记值的转换与TypeConverters\"></a>标记值的转换与TypeConverters</h3><p>在进行标记值转换时，有时候需要使用TypeConverters实现类型转换。例如，在上述示例代码中，可以看到使用了字符串“#525252”来定义颜色，在内部就是实现了从字符串到 Color 类的转换过程。限于篇幅有限，此处就暂时略过。  </p>\n<h3 id=\"XAML中内置特殊标记扩展\"><a href=\"#XAML中内置特殊标记扩展\" class=\"headerlink\" title=\"XAML中内置特殊标记扩展\"></a>XAML中内置特殊标记扩展</h3><ul>\n<li><p>x:Type：特定类型  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;x:Type prefix:typeNameValue&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>x:Static：使用静态值。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;x:Static prefix:typeName.staticMemberName&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>x:Null：使用空对象定义为属性值。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;x:Null&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>x:Array：使用数组对象。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;x:Array Type=&quot;typeName&quot;&gt;    </span><br><span class=\"line\">  arrayContents    </span><br><span class=\"line\">&lt;/x:Array&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"常见的标记扩展\"><a href=\"#常见的标记扩展\" class=\"headerlink\" title=\"常见的标记扩展\"></a>常见的标记扩展</h3><ol>\n<li><p>StaticResource：通过替换已定义资源的值来为属性提供内容，该资源标记在XAML加载时自动执行。静态资源无法通过在XAML语法体系中对其引用关系进行前向引用，意味着无法通过多层级关系定义可复用的样式资源，如果需要这样做，则需要使用DynamicResource。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;StaticResource key&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>DynamicResource：在运行时为资源提供内容。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;DynamicResource key&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Binding：在运行时为使用数据上下文为数据提供内容。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;Binding&#125;&quot; .../&gt;    </span><br><span class=\"line\">-or-  </span><br><span class=\"line\">&lt;object property=&quot;&#123;Binding  bindProp1=value1[, bindPropN=valueN]*&#125;&quot; ...  </span><br><span class=\"line\">/&gt;    </span><br><span class=\"line\">-or-    </span><br><span class=\"line\">&lt;object property=&quot;&#123;Binding path&#125;&quot; .../&gt;  </span><br><span class=\"line\">-or     </span><br><span class=\"line\">&lt;object property=&quot;&#123;Binding path[, bindPropN=valueN]*&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>RelativeSource：提供了可在运行时对象树中导航几个可能的关系的 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.data.binding\" target=\"_blank\" rel=\"noopener\">Binding</a> 的源信息。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Binding RelativeSource=&quot;&#123;RelativeSource modeEnumValue&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>TemplateBinding：使控件模板能够使用模板化属性的值，这些属性来自于将使用该模板的类的对象模型定义属性。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;TemplateBinding sourceProperty&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ColorConvertedBitmap：提供一种方法，用于指定没有嵌入的配置文件的位图源。 颜色上下文/配置文件由 URI 指定，与映像源 URI 相同。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;ColorConvertedBitmap imageSource sourceIIC destinationIIC&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ComponentResourceKey和TemplateResourceKey：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object x:Key=&quot;&#123;ComponentResourceKey &#123;x:Type targetTypeName&#125;, targetID&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"XAML资源复用\"><a href=\"#XAML资源复用\" class=\"headerlink\" title=\"XAML资源复用\"></a>XAML资源复用</h2><p>在开发过程中，我们可以直接在按钮上进行按钮模板的定义，例如下面的代码。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button Width=&quot;40&quot; Height=&quot;40&quot; Style=&quot;&#123;DynamicResource CubeImageButtonStyle&#125;&quot; Click=&quot;Button_Click&quot; Content=&quot;点赞&quot;&gt;</span><br><span class=\"line\">    &lt;Button.Background&gt;</span><br><span class=\"line\">                                &lt;ImageBrush ImageSource=&quot;/assests/favicon.png&quot; Stretch=&quot;Fill&quot;/&gt; </span><br><span class=\"line\">                            &lt;/Button.Background&gt;</span><br><span class=\"line\">                        &lt;/Button&gt;   </span><br><span class=\"line\">                          &lt;Setter Property=&quot;Template&quot;</span><br><span class=\"line\">                &lt;Setter.Value&gt;</span><br><span class=\"line\">                    &lt;ControlTemplate&gt;</span><br><span class=\"line\">                        &lt;Border BorderThickness=&quot;0&quot; CornerRadius=&quot;3&quot;&gt;</span><br><span class=\"line\">                            &lt;Border.Background&gt;</span><br><span class=\"line\">                                &lt;LinearGradientBrush EndPoint=&quot;0,1&quot; StartPoint=&quot;0,0&quot;&gt;</span><br><span class=\"line\">                                    &lt;GradientStop Color=&quot;#4696F2&quot; Offset=&quot;0.5&quot;/&gt;</span><br><span class=\"line\">                                &lt;/LinearGradientBrush&gt;</span><br><span class=\"line\">                            &lt;/Border.Background&gt;</span><br><span class=\"line\">                            &lt;ContentPresenter Content=&quot;&#123;TemplateBinding ContentControl.Content&#125;&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt;</span><br><span class=\"line\">                        &lt;/Border&gt;</span><br><span class=\"line\">                    &lt;/ControlTemplate&gt;</span><br><span class=\"line\">                &lt;/Setter.Value&gt;</span><br><span class=\"line\">            &lt;/Setter&gt;</span><br><span class=\"line\">        &lt;/Style&gt;</span><br><span class=\"line\"> &lt;/Window.Resources&gt;</span><br><span class=\"line\"> &lt;Grid&gt;</span><br><span class=\"line\">&lt;Button Grid.Column=&quot;0&quot; Grid.Row=&quot;1&quot; Style=&quot;&#123;StaticResource FlatButtonStyle&#125;&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;48&quot; Height=&quot;16&quot; FontSize=&quot;10&quot; Background=&quot;#4696F2&quot; Content=&quot;获取&quot;&gt;&lt;/Button&gt;</span><br><span class=\"line\"> &lt;/Grid&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这样的代码在界面比较简单时，还无所谓，但是随着控件的样式越来越复杂，可能会成为一团乱麻，这对于追求优雅代码的我们来说，可能是难以忍受的，所以往往会使用资源引用来完成。    </p>\n<h3 id=\"StaticResource\"><a href=\"#StaticResource\" class=\"headerlink\" title=\"StaticResource\"></a>StaticResource</h3><p>例如，我们可以在当前页面代码中定义对应的样式，这种样式可以使用 StaticResource 的形式引入。但是这样的引用形式，没有对象图的访问权限，意味着无法访问资源依赖的其他资源。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;Window.Resources&gt;  </span><br><span class=\"line\">&lt;Style TargetType=&quot;Button&quot; x:Key=&quot;FlatButtonStyle&quot;&gt;     </span><br><span class=\"line\">            &lt;Setter Property=&quot;Margin&quot;   Value=&quot;4&quot; /&gt;    </span><br><span class=\"line\">            &lt;Setter Property=&quot;FontWeight&quot; Value=&quot;Black&quot;/&gt;    </span><br><span class=\"line\">            &lt;Setter Property=&quot;Foreground&quot;  Value=&quot;Black&quot; /&gt;        </span><br><span class=\"line\">            &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;0&quot;/&gt;    </span><br><span class=\"line\">&lt;/Window.Resources&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DynamicResource\"><a href=\"#DynamicResource\" class=\"headerlink\" title=\"DynamicResource\"></a>DynamicResource</h3><p>将上述代码中的{StaticResource FlatButtonStyle} 改成{StaticResource  FlatButtonStyle}则会在运行时加载样式，并可以访问相应的对象图。</p>\n<p>当然，这样的更改意义不大，如果该FlatButtonStyle引用了其他样式或元素，会发生作用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Grid</span><br><span class=\"line\">&lt;Button Grid.Column=&quot;0&quot; Grid.Row=&quot;1&quot; Style=&quot;&#123;StaticResource FlatButtonStyle&#125;&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;48&quot; Height=&quot;16&quot; FontSize=&quot;10&quot; Background=&quot;#4696F2&quot; Content=&quot;获取&quot;&gt;&lt;/Button&gt;</span><br><span class=\"line\"> &lt;/Grid&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>1、由于XAML语法脱胎于XML语法，而XML语法中本身对某些输入字符，如“&lt;&gt;”存在限制，所以在XAML中也会出现这类问题，并会被Visual Studio检测出错误而无法编译，需要使用UTF-8编码进行转换。  </p>\n<h1 id=\"用户控件和自定义控件\"><a href=\"#用户控件和自定义控件\" class=\"headerlink\" title=\"用户控件和自定义控件\"></a>用户控件和自定义控件</h1><h2 id=\"用户控件\"><a href=\"#用户控件\" class=\"headerlink\" title=\"用户控件\"></a>用户控件</h2><p>而用户控件，使用于控件组合的场景。  </p>\n<h2 id=\"自定义控件\"><a href=\"#自定义控件\" class=\"headerlink\" title=\"自定义控件\"></a>自定义控件</h2><p>在笔者进行开发时，总是思考究竟是使用用户控件，还是自定义控件，后来在阅读《葵花宝典-WPF自学手册》这本书中，终于得以大彻大悟。  </p>\n<p>作者指出：“不要被控件的外观所欺骗，要考虑其内在本质”。即思考控件的基本特征，首先想到该控件的行为与原有控件的行为是否相似，如果能够找到，则修改原有控件，而不是定义一个控件。尤其是在XAML语法中，能够通过Content 模型和模板、附加属性的运用，使得自定义控件的用途得到了进一步缩减，只有当实在万不得已时，在定义自定义控件。</p>\n<p>作者给出了使用自定义控件的分析思路：    </p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/flow.png\" alt=\"图片\"></p>\n<p>例如，在示例代码*<em>ToggleLikeButtonStyle *</em>中，我实现了一个点赞和取消点赞的状态，则使用了ToggleButton来完成，就没必要使用 Button 扩展出一个是否点赞的状态了。  </p>\n<p>而如果我们需要实现的功能有这么复杂，那大概使用传统的控件就无法实现，就得使用自定义控件了。（<a href=\"https://github.com/caomfan/WpfDemo.git\" target=\"_blank\" rel=\"noopener\">点击查看示例代码</a>）</p>\n<p><img src=\"https://uploader.shimo.im/f/f44dU5UMbaYZpJtm.png!thumbnail\" alt=\"图片\"></p>\n<p>作者定义了自定义控件 ButtonEx，并实现了依赖属性 ButtonType，见【依赖属性】，并定义了不同类型的样式特征。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;Trigger Property=&quot;ButtonType&quot; Value=&quot;Icon&quot;&gt;</span><br><span class=\"line\">                &lt;Setter Property=&quot;Cursor&quot; Value=&quot;Hand&quot;/&gt;</span><br><span class=\"line\">                &lt;Setter Property=&quot;Template&quot;&gt;</span><br><span class=\"line\">                    &lt;Setter.Value&gt;</span><br><span class=\"line\">                        &lt;ControlTemplate TargetType=&quot;&#123;x:Type controls:ButtonEx&#125;&quot;&gt;</span><br><span class=\"line\">                            &lt;Border Width=&quot;&#123;TemplateBinding Width&#125;&quot; Height=&quot;&#123;TemplateBinding Height&#125;&quot;&gt;</span><br><span class=\"line\">                                &lt;Image x:Name=&quot;Img&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Source=&quot;&#123;TemplateBinding Icon&#125;&quot; Stretch=&quot;None&quot;/&gt;</span><br><span class=\"line\">                            &lt;/Border&gt;</span><br><span class=\"line\">                            &lt;ControlTemplate.Triggers&gt;</span><br><span class=\"line\">                                &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&gt;</span><br><span class=\"line\">                                    &lt;Setter Property=&quot;Opacity&quot; Value=&quot;0.8&quot;/&gt;</span><br><span class=\"line\">                                &lt;/Trigger&gt;</span><br><span class=\"line\">                                &lt;Trigger Property=&quot;IsPressed&quot; Value=&quot;True&quot;&gt;</span><br><span class=\"line\">                                    &lt;Setter Property=&quot;Opacity&quot; Value=&quot;0.9&quot;/&gt;</span><br><span class=\"line\">                                &lt;/Trigger&gt;</span><br><span class=\"line\">                            &lt;/ControlTemplate.Triggers&gt;</span><br><span class=\"line\">                        &lt;/ControlTemplate&gt;</span><br><span class=\"line\">                    &lt;/Setter.Value&gt;</span><br><span class=\"line\">                &lt;/Setter&gt;</span><br><span class=\"line\">            &lt;/Trigger&gt;</span><br></pre></td></tr></table></figure>\n\n<p>使用时，只需这样设置，即可实现不同类型的按钮外观。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;controls:ButtonEx Icon=&quot;/Images/search.png&quot;  Margin=&quot;10&quot; ButtonType=&quot;Icon&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"属性和事件\"><a href=\"#属性和事件\" class=\"headerlink\" title=\"属性和事件\"></a>属性和事件</h1><h2 id=\"依赖属性\"><a href=\"#依赖属性\" class=\"headerlink\" title=\"依赖属性\"></a><a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/dependency-properties-overview\" target=\"_blank\" rel=\"noopener\">依赖属性</a></h2><p>依赖属性是为既有WPF控件对象定义自定义属性，以便支持其扩展，例如在上述自定义控件的示例中，就定义了依赖属性 ButtonType，实现了不同类型的按钮外观。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ButtonType ButtonType  </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            get &#123; return (ButtonType)GetValue(ButtonTypeProperty); &#125;</span><br><span class=\"line\">            set &#123; SetValue(ButtonTypeProperty, value); &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        public static readonly DependencyProperty ButtonTypeProperty =</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"DependencyProperty-Register-“ButtonType”-typeof-ButtonType-typeof-ButtonEx-new-PropertyMetadata-ButtonType-Normal\"><a href=\"#DependencyProperty-Register-“ButtonType”-typeof-ButtonType-typeof-ButtonEx-new-PropertyMetadata-ButtonType-Normal\" class=\"headerlink\" title=\"DependencyProperty.Register(“ButtonType”, typeof(ButtonType), typeof(ButtonEx), new PropertyMetadata(ButtonType.Normal));\"></a>DependencyProperty.Register(“ButtonType”, typeof(ButtonType), typeof(ButtonEx), new PropertyMetadata(ButtonType.Normal));</h2><p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/attached-properties-overview\" target=\"_blank\" rel=\"noopener\">附加属性</a><br>按照官方的说法就是“附加属性旨在用作可在任何对象上设置的一类全局属性”，例如，DockPanel面板中的子对象，继承了来自于容器对象的附加属性，使得其能够在父对象中实现停靠的功能。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;DockPanel&gt;</span><br><span class=\"line\">  &lt;CheckBox DockPanel.Dock=&quot;Top&quot;&gt;Hello&lt;/CheckBox&gt;</span><br><span class=\"line\">&lt;/DockPanel&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"路由事件\"><a href=\"#路由事件\" class=\"headerlink\" title=\"路由事件\"></a><a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/routed-events-overview\" target=\"_blank\" rel=\"noopener\">路由事件</a></h2><h3 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a>基本定义</h3><p>假设我们定义了几个这样的控件。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Border Height=&quot;50&quot; Width=&quot;300&quot; BorderBrush=&quot;Gray&quot; BorderThickness=&quot;1&quot;&gt;</span><br><span class=\"line\">  &lt;StackPanel Background=&quot;LightGray&quot; Orientation=&quot;Horizontal&quot; Button.Click=&quot;CommonClickHandler&quot;&gt;</span><br><span class=\"line\">    &lt;Button Name=&quot;YesButton&quot; Width=&quot;Auto&quot; &gt;Yes&lt;/Button&gt;</span><br><span class=\"line\">    &lt;Button Name=&quot;NoButton&quot; Width=&quot;Auto&quot; &gt;No&lt;/Button&gt;</span><br><span class=\"line\">    &lt;Button Name=&quot;CancelButton&quot; Width=&quot;Auto&quot; &gt;Cancel&lt;/Button&gt;</span><br><span class=\"line\">  &lt;/StackPanel&gt;</span><br><span class=\"line\">&lt;/Border&gt;</span><br></pre></td></tr></table></figure>\n\n<p>实现了这样的界面<img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/ui.png\" alt=\"图片\"></p>\n<p>路由事件就是针对这组元素树中多个元素调用处理程序的事件。当我们点击了按钮Button时，将会触发 Button=&gt;StackPanel=&gt;Border的事件路由，而不是像WinForm应用一样，只能触发最上层的Button的按钮点击事件。  </p>\n<h3 id=\"路由策略\"><a href=\"#路由策略\" class=\"headerlink\" title=\"路由策略\"></a>路由策略</h3><ul>\n<li><p>冒泡事件（官方称为浮升，这个翻译有点。。）：调用事件源上的事件处理程序。 路由事件随后会路由到后续的父级元素，直到到达元素树的根。 大多数路由事件都使用浮升路由策略。 浮升路由事件通常用于报告来自不同控件或其他 UI 元素的输入或状态变化。  </p>\n</li>\n<li><p>直接： 只有源元素本身才有机会调用处理程序以进行响应。通过使用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.eventsetter\" target=\"_blank\" rel=\"noopener\">EventSetter</a> 和 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.eventtrigger\" target=\"_blank\" rel=\"noopener\">EventTrigger</a>使用来设置处理程序。例如，可以使用RoutedEventArgs的<a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.routedeventargs.handled\" target=\"_blank\" rel=\"noopener\">Handled</a>，设置为 true 将事件标记为已处理，将 “停止” 路由用于隧道路由或冒泡路由。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void MakeButton2()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  Button b2 = new Button();</span><br><span class=\"line\">  b2.Click += new RoutedEventHandler(Onb2Click2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void Onb2Click2(object sender, RoutedEventArgs e)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  //logic to handle the Click event     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>隧道：最初将调用元素树的根处的事件处理程序。 随后，路由事件将朝着路由事件的源节点元素（即引发路由事件的元素）方向，沿路由线路传播到后续的子元素。  </p>\n</li>\n<li><p>WPF中约定，隧道路由事件的名称以单词“Preview”开头。 输入事件通常成对出现，一个是浮升事件，另一个是隧道事件。例如，如下图所示，假设按钮2为触发事件的源。  </p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/event.png\" alt=\"图片\"></p>\n<p>1、处理Border根元素的隧道事件PreviewMouseDown  </p>\n<p>2、处理StackPanel面板的隧道事件PreviewMouseDown.  </p>\n<p>3、处理Button按钮的隧道事件的PreMouseDown。  </p>\n<p>4、处理Button按钮的MouseDown事件。  </p>\n<p>5、处理StackPanel的MouseDown事件。  </p>\n<p>6、处理Border的MouseDown事件。    </p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>WPF是一个非常庞大的技术体系，以上学习路径仅供开发者进行简单的入门，由于篇幅有限，对于标记扩展还需要进一步理解透彻，以及格式转换、图形绘制、数据绑定、MVVM等内容未能一一描述。  </p>\n<p>如果果想要对WPF进一步了解，最好通过系统的学习相关知识，除了前面提到的网站和几本书，最好的入门网站依然是<a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/\" target=\"_blank\" rel=\"noopener\">微软官方文档</a>。  </p>\n<h1 id><a href=\"#\" class=\"headerlink\" title></a></h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>在桌面开发领域，虽然在某些领域，基于electron的跨平台方案能够为我们带来某些便利，但是由于WPF技术能够更好的运用Direct3D带来的性能提升、以及海量Windows操作系统和硬件资源的支持，所以他依然有着得天独厚的优势。    </p>\n<p>当然，选用一门技术，依然看公司的基因土壤和综合因素或者老板的心血来潮，例如QT也同样是一门非常不错的跨平台图形界面解决方案。    </p>\n<p>目前我们公司在桌面开发领域广泛应用了WPF技术，主要是使用其作为大屏数据可视化相关的UI呈现，包括一些数据展示效果、动画效果等。由于之前我对WPF仅有三周经验，因此在开发和设计相关功能时，一些简单功能还能勉强完成，稍微复杂一点的就有点费时过长了，因此这篇文章主要梳理自己的学习笔记，以便总结学习成果。    </p>\n<h1 id=\"如何学习WPF技术？\"><a href=\"#如何学习WPF技术？\" class=\"headerlink\" title=\"如何学习WPF技术？\"></a>如何学习WPF技术？</h1><p>在Quote上有人提出了这样一个相同的问题，<a href=\"https://www.quora.com/How-can-I-learn-WPF-easily\" target=\"_blank\" rel=\"noopener\">查看问题</a>，开发者Srikanth Pagadala如是回答：    </p>\n<blockquote>\n<p>1、以了解基础控件作为学习的起步过程：这些控件包括TextBox,Button,TextBlock及其他的，理解这些控件对外提供的属性，以及如何使用。<br>2、了解和使用布局空间：例如Grid、StackPanel、DockerPanel和其他控件，在这一点上，你需要花费大量的时间。同时你需要学会创建复杂的UI设计。<br>3、了解循环类型的空间，例如ItemControl控件。<br>4、了解关于模板的概念。包括如何定义包含CheckBox的Combox，同时这个控件还包含了一张图片的按钮，以及如何在ItemsControl中使用不同的模板。<br>5、理解数据绑定的运行机制。尝试创建一个MVVM或类似类型的应用程序。<br>6、创建一个典型的控件，探索DependencyProperties（依赖属性）和AttachedProperties（附加属性）。<br>7、创建一个样式资源，理解如何给控件设计样式。</p>\n</blockquote>\n<p>除此之外，还有其他开发者给出了补充回答：    </p>\n<blockquote>\n<p>1、学习控件的数据绑定过程，在DataGrid上实现数据绑定。<br>2、学习和实现INotifyPropertyChanged类。<a href=\"https://msdn.microsoft.com/en-us/library/vstudio/ms743695(v=vs.100).aspx\" target=\"_blank\" rel=\"noopener\">查看如何实现</a><br>3、学习Observable Collection。该类型的集合广泛使用于数据集合绑定方面，同时也提供了数据改变通知的机制。<br>4、使网格上的列可编辑。用文本控件（用户项目模板）替换列。为每个捕获文本更改事件的列创建一个属性。在文本控件上使用绑定类型。尝试捕获您在后端在网格上所做的更改。<br>5、成功将数据控件中的文本控件与后端属性绑定后，请在同一页面上创建网格的副本。尝试同步这两个网格。例如，您在第一个网格中所做的每个更改都必须在第二个网格中自动更新。</p>\n</blockquote>\n<p>网站“<a href=\"https://www.wpf-tutorial.com/\" target=\"_blank\" rel=\"noopener\">https://www.wpf-tutorial.com/</a>”是一个专门用于学习WPF的网站，通过这个网站，可以快速的入门WPF。    </p>\n<p>由于WPF技术已经比较熟悉，所以书籍也比较多，网友推荐来自刘铁猛老师的《深入浅出WPF》这本书，而我通过Kindle则看到了一本比较有意思的书《葵花宝典-WPF自学手册》，这本书写得比较生动，通过故事的形式讲了WPF的许多技术原理，无形中让我对WPF的概念有了许多新的认识。当然，这本书已经有点年头了。    </p>\n<h1 id=\"WPF的常用控件\"><a href=\"#WPF的常用控件\" class=\"headerlink\" title=\"WPF的常用控件\"></a>WPF的常用控件</h1><p>| 控件类型   | 控件名称   | 控件说明   | 链接地址   |<br>|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|<br>| 组件   | Window   | 窗口   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.window?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Page   | 页面   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.page?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | NavigationWindow   | 导航窗口   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.navigation.navigationwindow?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Frame   |    | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Frame\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>| 常规控件   | Button   | 按钮控件，提供Content作为内容   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Button\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | TextBox   | 文本框控件，用以输入文本   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TextBox\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | TextBlock   | 文本块，用以显示文本   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TextBlock\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Label   | 标签，用以显示文本   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Label\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ProgressBar   | 进度条   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ProgressBar\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ToggleButton   | 一种可以设置开关三态的按钮   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.primitives.togglebutton?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Image   | 图像控件，通过Source设置资源路径   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Image\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | CheckBox   | 勾选框，可以设置是否勾选的三种状态   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/CheckBox\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | RichTextBox   | 富文本框，可以多种格式显示和输入文本   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/RichTextBox\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | TreeView   | 树视图，以树状图的形式显示绑定内容，可以显示是否勾选三态。   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TreeView\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | WebBrowser   | 浏览器，基于IE内核的浏览器控件   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.webbrowser?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Calendar   | 日历控件   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.calendar?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ComboBox   | 下拉列表   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ComboBox\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ContentControl   | 内容控件   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.contentcontrol?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Expander   | 扩展器，可以显示和折叠面板内的元素   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Expander\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | GroupBox   | 分组框   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/GroupBox\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | StatusBar   | 状态栏，用于在页面下方显示状态信息。   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/StatusBar\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | DateTimePicker   | 时间控件，可以设置时间状态。   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.forms.datetimepicker?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | DocumentViewer   | 文档查看器   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/DocumentViewer\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | RadioButton   | 单选按钮   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/RadioButton\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ScollViewer   | 滚动视图   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/scrollviewer-overview\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ScollBar   | 滚动条   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.primitives.scrollbar?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Separator   | 分隔器   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Separator\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ToolBar   | 工具条   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ToolBar\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Slider   |    | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Slider\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Menu   | 菜单   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Menu\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | MediaElement   | 多媒体控件   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.mediaelement?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | PasswordBox   | 密码输入框   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/PasswordBox\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | TabControl   | 选项卡   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/TabControl\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ToolBarTray   | 工具条   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.toolbartray?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | WindowsFormsHost   | 用以承载WinForm   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.forms.integration.windowsformshost?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Border   | 边框   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Border\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>| 数据控件   | ListView   | 列表视图   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ListView\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | DataGrid   | 数据表   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/datagrid\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | ListBox   | 列表框   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/ListBox\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>| 布局   | WrapPanel   | 可变面板   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/WrapPanel\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | StackPanel   | 固定面板   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/StackPanel\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | DockerPanel   | 停靠面板   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.dockpanel?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Grid   | 表格布局   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Grid\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | UniformGrid   | 统一分布表格布局   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.primitives.uniformgrid?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>| <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Label\" target=\"_blank\" rel=\"noopener\">查看示例</a>   | Canvas   | 画布   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Canvas\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>| 图形   | Point   | 点   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/controls/Border\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Line   | 线   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.line?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Path   | 路径   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.path?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Polygon   | 多边形   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.polygon?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Polyline   | 多段线   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.polyline?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Rectangle   | 矩形   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.rectangle?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Shape   | 画笔   | <a href=\"http://各类图元的基类\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Rectangle   | 矩形   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.rectangle?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   |<br>|    | Ellipse   | 椭圆   | <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.shapes.ellipse?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">查看示例</a>   | </p>\n<h1 id=\"WPF的XAML语法\"><a href=\"#WPF的XAML语法\" class=\"headerlink\" title=\"WPF的XAML语法\"></a>WPF的XAML语法</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>在WPF技术中引入的XAML语法算是该技术的一大特色，也是被学习者视同为学习路径陡峭的“罪魁祸首”。原因是在前端技术飞速发展的今天，HTML的语法体系由于更早的被开发者接受，所以也自然而然更容易成为开发者的首选。    </p>\n<p>而XAML是一种脱胎于XML，并吸收了HTML的精华的语法体系，是一种界面描述语言，XML语法本身相对而言较为臃肿的体系，看似成为了他的历史负担，但是其实倒也没那么复杂，通过几个简单的示例，其实就足够掌握这门新的语法体系了。例如，使用<button></button>这样的语法，完全可以平滑过渡到<button></button>这样的语法体系。(部分标签其实只是大小写不同）。当然，在XAML中熟练编写样式，确实需要花一点点时间。    </p>\n<p>在WPF中，通过XAML定义面向用户交互层的界面，然后编译成baml运行，后端则使用C#或VB.NET这样的CLR语法来实现逻辑交互。    </p>\n<h2 id=\"XAML的语法定义\"><a href=\"#XAML的语法定义\" class=\"headerlink\" title=\"XAML的语法定义\"></a>XAML的语法定义</h2><h3 id=\"XAML的根元素定义\"><a href=\"#XAML的根元素定义\" class=\"headerlink\" title=\"XAML的根元素定义\"></a>XAML的根元素定义</h3><p>根元素定义是定义XAML的命名空间。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Page</span><br><span class=\"line\">  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class=\"line\">  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"XAML的属性语法\"><a href=\"#XAML的属性语法\" class=\"headerlink\" title=\"XAML的属性语法\"></a>XAML的属性语法</h3><p>通过xaml定义按钮，并设置文本为 helloworld 。这种写法在官方文档中称为“属性语法”，即直接在XAML中对属性进行设置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button Background=&quot;Blue&quot; Foreground=&quot;Red&quot; Content=&quot;hello world&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"XAML的属性元素语法\"><a href=\"#XAML的属性元素语法\" class=\"headerlink\" title=\"XAML的属性元素语法\"></a>XAML的属性元素语法</h3><p>通过xaml定义按钮，并设置其背景为蓝色画笔，字体颜色为红色画笔，内容 为helloworld。这种写法在官方文档中称为“属性元素语法”。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button&gt;</span><br><span class=\"line\">  &lt;Button.Background&gt;</span><br><span class=\"line\">    &lt;SolidColorBrush Color=&quot;Blue&quot;/&gt;</span><br><span class=\"line\">  &lt;/Button.Background&gt;</span><br><span class=\"line\">  &lt;Button.Foreground&gt;</span><br><span class=\"line\">    &lt;SolidColorBrush Color=&quot;Red&quot;/&gt;</span><br><span class=\"line\">  &lt;/Button.Foreground&gt;</span><br><span class=\"line\">  &lt;Button.Content&gt;</span><br><span class=\"line\">    hello world</span><br><span class=\"line\">  &lt;/Button.Content&gt;</span><br><span class=\"line\">&lt;/Button&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"XAML的集合语法\"><a href=\"#XAML的集合语法\" class=\"headerlink\" title=\"XAML的集合语法\"></a>XAML的集合语法</h3><p>定义按钮的颜色为红色和蓝色渐变色，内容为helloworld。这种称为“集合语法”。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;LinearGradientBrush&gt;</span><br><span class=\"line\">  &lt;LinearGradientBrush.GradientStops&gt;</span><br><span class=\"line\">    &lt;!-- no explicit new GradientStopCollection, parser knows how to find or create --&gt;</span><br><span class=\"line\">    &lt;GradientStop Offset=&quot;0.0&quot; Color=&quot;Red&quot; /&gt;</span><br><span class=\"line\">    &lt;GradientStop Offset=&quot;1.0&quot; Color=&quot;Blue&quot; /&gt;</span><br><span class=\"line\">  &lt;/LinearGradientBrush.GradientStops&gt;</span><br><span class=\"line\">&lt;/LinearGradientBrush&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"XAML的样式定义\"><a href=\"#XAML的样式定义\" class=\"headerlink\" title=\"XAML的样式定义\"></a>XAML的样式定义</h2><h3 id=\"通过属性语法来定义按钮的外观\"><a href=\"#通过属性语法来定义按钮的外观\" class=\"headerlink\" title=\"通过属性语法来定义按钮的外观\"></a>通过属性语法来定义按钮的外观</h3><p>样式定义使用 <style></style>标签，然后在中间对样式的内容进行定义。    </p>\n<p>例如，以下表示通过XAML语法对 ToggleButton 按钮定义了一个命名为 ToggleLikeButtonStyle 的样式。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;Style TargetType=&quot;ToggleButton&quot; x:Key=&quot;ToggleLikeButtonStyle&quot;&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;Margin&quot;   Value=&quot;4&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;Setter Property=&quot;FontWeight&quot; Value=&quot;Black&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;Setter Property=&quot;Foreground&quot;  Value=&quot;Black&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;0&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">            &lt;Setter Property=&quot;IsThreeState&quot; Value=&quot;False&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/Style&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WPF中的模板Template\"><a href=\"#WPF中的模板Template\" class=\"headerlink\" title=\"WPF中的模板Template\"></a>WPF中的模板Template</h3><p>WPF中的控件可以通过模板 Template 的形式来定义其内容，使得开发者能够通过 XAML 灵活的对控件的外观进行扩展。例如，如下定义了一个 Template，这个控件模板将会对控件（Button）定义填充制定颜色。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;Setter Property=&quot;Template&quot;&gt;  </span><br><span class=\"line\">                &lt;Setter.Value&gt;  </span><br><span class=\"line\">                    &lt;ControlTemplate&gt;  </span><br><span class=\"line\">                        &lt;Border BorderThickness=&quot;0&quot; CornerRadius=&quot;3&quot;&gt;  </span><br><span class=\"line\">                            &lt;Border.Background&gt;  </span><br><span class=\"line\">                                &lt;LinearGradientBrush EndPoint=&quot;0,1&quot; StartPoint=&quot;0,0&quot;&gt;  </span><br><span class=\"line\">                                    &lt;GradientStop Color=&quot;#4696F2&quot; Offset=&quot;0.5&quot;/&gt;  </span><br><span class=\"line\">                                &lt;/LinearGradientBrush&gt;  </span><br><span class=\"line\">                            &lt;/Border.Background&gt;  </span><br><span class=\"line\">                            &lt;ContentPresenter Content=&quot;&#123;TemplateBinding ContentControl.Content&#125;&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt;  </span><br><span class=\"line\">                        &lt;/Border&gt;  </span><br><span class=\"line\">                    &lt;/ControlTemplate&gt;  </span><br><span class=\"line\">                &lt;/Setter.Value&gt;  </span><br><span class=\"line\">            &lt;/Setter&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"XAML中的触发器Triggers\"><a href=\"#XAML中的触发器Triggers\" class=\"headerlink\" title=\"XAML中的触发器Triggers\"></a>XAML中的触发器Triggers</h3><p>传统的WinForm开发者习惯于通过事件的机制对按钮的外观进行定义，而在WPF中，则可以通过属性的形式对外观进行设置，这使得开发者更能够写出高质量的代码。  </p>\n<p>例如，如下代码通过定义触发器，设置控件（控件为 ToggleButton），当控件的勾选状态属性为“IsChecked” 时，其边框填充色为#4696F2颜色。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ControlTemplate.Triggers&gt;  </span><br><span class=\"line\">                            &lt;Trigger Property=&quot;IsChecked&quot; Value=&quot;True&quot;&gt;  </span><br><span class=\"line\">  &lt;Setter Property=&quot;Border.Background&quot; TargetName=&quot;PART_Background&quot;</span><br><span class=\"line\">&lt;Setter.Value&gt;</span><br><span class=\"line\">                                        &lt;LinearGradientBrush EndPoint=&quot;0,1&quot; StartPoint=&quot;0,0&quot;&gt;</span><br><span class=\"line\">                                            &lt;GradientStop Color=&quot;#4696F2&quot; Offset=&quot;0.5&quot;/&gt;</span><br><span class=\"line\">                                        &lt;/LinearGradientBrush&gt;</span><br><span class=\"line\">                                    &lt;/Setter.Value&gt;</span><br><span class=\"line\">                                &lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Width&quot; TargetName=&quot;PART_Background&quot; Value=&quot;60&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Content&quot;  TargetName=&quot;contextPresenter&quot; Value=&quot;已点赞&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Visibility&quot;  TargetName=&quot;contextPresenter&quot; Value=&quot;Visible&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Visibility&quot; TargetName=&quot;contextImage&quot; Value=&quot;Hidden&quot;/&gt;</span><br><span class=\"line\">                            &lt;/Trigger&gt;</span><br><span class=\"line\">&lt;/ControlTemplate.Triggers&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"部分完整代码\"><a href=\"#部分完整代码\" class=\"headerlink\" title=\"部分完整代码\"></a>部分完整代码</h3><p>在上述事例中，共定义了两个按钮的样式，分别是:</p>\n<ul>\n<li><p><strong>FlatButtonStyle，这是个圆角按钮。</strong><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/circleButton.png\" alt=\"图片\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Style TargetType=&quot;Button&quot; x:Key=&quot;FlatButtonStyle&quot;&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;Margin&quot;   Value=&quot;4&quot; /&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;FontWeight&quot; Value=&quot;Black&quot;/&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;Foreground&quot;  Value=&quot;Black&quot; /&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;0&quot;/&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;Template&quot;&gt;</span><br><span class=\"line\">                &lt;Setter.Value&gt;</span><br><span class=\"line\">                    &lt;ControlTemplate&gt;</span><br><span class=\"line\">                        &lt;Border BorderThickness=&quot;0&quot; CornerRadius=&quot;3&quot;&gt;</span><br><span class=\"line\">                            &lt;Border.Background&gt;</span><br><span class=\"line\">                                &lt;LinearGradientBrush EndPoint=&quot;0,1&quot; StartPoint=&quot;0,0&quot;&gt;</span><br><span class=\"line\">                                    &lt;GradientStop Color=&quot;#4696F2&quot; Offset=&quot;0.5&quot;/&gt;</span><br><span class=\"line\">                                &lt;/LinearGradientBrush&gt;</span><br><span class=\"line\">                            &lt;/Border.Background&gt;</span><br><span class=\"line\">                            &lt;ContentPresenter Content=&quot;&#123;TemplateBinding ContentControl.Content&#125;&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt;</span><br><span class=\"line\">                        &lt;/Border&gt;</span><br><span class=\"line\">                    &lt;/ControlTemplate&gt;</span><br><span class=\"line\">                &lt;/Setter.Value&gt;</span><br><span class=\"line\">            &lt;/Setter&gt;</span><br><span class=\"line\">        &lt;/Style&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>ToggleLikeButtonStyle，这是一个点赞按钮。</strong><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/likeButton.png\" alt=\"图片\">。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Style TargetType=&quot;ToggleButton&quot; x:Key=&quot;ToggleLikeButtonStyle&quot;&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;Margin&quot;   Value=&quot;4&quot; /&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;FontWeight&quot; Value=&quot;Black&quot;/&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;Foreground&quot;  Value=&quot;Black&quot; /&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;0&quot;/&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;IsThreeState&quot; Value=&quot;False&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">            &lt;Setter Property=&quot;Template&quot;&gt;</span><br><span class=\"line\">                &lt;Setter.Value&gt;</span><br><span class=\"line\">                    &lt;ControlTemplate TargetType=&quot;&#123;x:Type ToggleButton&#125;&quot;&gt;</span><br><span class=\"line\">                        &lt;Border BorderThickness=&quot;0&quot; CornerRadius=&quot;3&quot; Name=&quot;PART_Background&quot;&gt;</span><br><span class=\"line\">                            &lt;Border.Background&gt;</span><br><span class=\"line\">                                &lt;LinearGradientBrush EndPoint=&quot;0,1&quot; StartPoint=&quot;0,0&quot;&gt;</span><br><span class=\"line\">                                    &lt;GradientStop Color=&quot;#525252&quot; Offset=&quot;0.5&quot;/&gt;</span><br><span class=\"line\">                                &lt;/LinearGradientBrush&gt;</span><br><span class=\"line\">                            &lt;/Border.Background&gt;</span><br><span class=\"line\">                            &lt;Grid&gt;</span><br><span class=\"line\">                                &lt;ContentPresenter x:Name=&quot;contextPresenter&quot; Content=&quot;&#123;TemplateBinding ContentControl.Content&#125;&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt;</span><br><span class=\"line\">                                &lt;Image x:Name=&quot;contextImage&quot; Width=&quot;24&quot; Height=&quot;24&quot; Source=&quot;assests/thumbs-up-outline.png&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt;</span><br><span class=\"line\">                            &lt;/Grid&gt;</span><br><span class=\"line\">                        &lt;/Border&gt;</span><br><span class=\"line\">                        &lt;ControlTemplate.Triggers&gt;</span><br><span class=\"line\">                            &lt;Trigger Property=&quot;IsChecked&quot; Value=&quot;True&quot;&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Border.Background&quot; TargetName=&quot;PART_Background&quot;&gt;</span><br><span class=\"line\">                                    &lt;Setter.Value&gt;</span><br><span class=\"line\">                                        &lt;LinearGradientBrush EndPoint=&quot;0,1&quot; StartPoint=&quot;0,0&quot;&gt;</span><br><span class=\"line\">                                            &lt;GradientStop Color=&quot;#4696F2&quot; Offset=&quot;0.5&quot;/&gt;</span><br><span class=\"line\">                                        &lt;/LinearGradientBrush&gt;</span><br><span class=\"line\">                                    &lt;/Setter.Value&gt;</span><br><span class=\"line\">                                &lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Width&quot; TargetName=&quot;PART_Background&quot; Value=&quot;60&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Content&quot;  TargetName=&quot;contextPresenter&quot; Value=&quot;已点赞&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Visibility&quot;  TargetName=&quot;contextPresenter&quot; Value=&quot;Visible&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Visibility&quot; TargetName=&quot;contextImage&quot; Value=&quot;Hidden&quot;/&gt;</span><br><span class=\"line\">                            &lt;/Trigger&gt;</span><br><span class=\"line\">                            &lt;Trigger Property=&quot;IsChecked&quot; Value=&quot;False&quot;&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Border.Background&quot; TargetName=&quot;PART_Background&quot;&gt;</span><br><span class=\"line\">                                    &lt;Setter.Value&gt;</span><br><span class=\"line\">                                        &lt;LinearGradientBrush EndPoint=&quot;0,1&quot; StartPoint=&quot;0,0&quot;&gt;</span><br><span class=\"line\">                                            &lt;GradientStop Color=&quot;#525252&quot; Offset=&quot;0.5&quot;/&gt;</span><br><span class=\"line\">                                        &lt;/LinearGradientBrush&gt;</span><br><span class=\"line\">                                    &lt;/Setter.Value&gt;</span><br><span class=\"line\">                                &lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Width&quot; TargetName=&quot;PART_Background&quot; Value=&quot;40&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Visibility&quot;  TargetName=&quot;contextPresenter&quot; Value=&quot;Hidden&quot;&gt;&lt;/Setter&gt;</span><br><span class=\"line\">                                &lt;Setter Property=&quot;Visibility&quot; TargetName=&quot;contextImage&quot; Value=&quot;Visible&quot;/&gt;</span><br><span class=\"line\">                            &lt;/Trigger&gt;</span><br><span class=\"line\">                        &lt;/ControlTemplate.Triggers&gt;</span><br><span class=\"line\">                    &lt;/ControlTemplate&gt;</span><br><span class=\"line\">                &lt;/Setter.Value&gt;</span><br><span class=\"line\">            &lt;/Setter&gt;</span><br><span class=\"line\">&lt;/Style&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"XAML的标记扩展\"><a href=\"#XAML的标记扩展\" class=\"headerlink\" title=\"XAML的标记扩展\"></a>XAML的<a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/markup-extensions-and-wpf-xaml\" target=\"_blank\" rel=\"noopener\">标记扩展</a></h2><p>通过了解WPF的常用控件，我们可以知道自己需要使用的控件有哪些属性，并能使用 XAML 语法对相应的属性进行设置，这种设置方法有别于通过C#代码的形式进行定义的方法，在 XAML中的属性称为 “标记”。标记使用 “{}” 花括号，编译器通过该花括号将语法和XAML语法进行区分。  </p>\n<p>例如：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> HeaderTemplate=&quot;&#123;DynamicResource StretchedHeaderTemplate&#125;&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"标记值的转换与TypeConverters\"><a href=\"#标记值的转换与TypeConverters\" class=\"headerlink\" title=\"标记值的转换与TypeConverters\"></a>标记值的转换与TypeConverters</h3><p>在进行标记值转换时，有时候需要使用TypeConverters实现类型转换。例如，在上述示例代码中，可以看到使用了字符串“#525252”来定义颜色，在内部就是实现了从字符串到 Color 类的转换过程。限于篇幅有限，此处就暂时略过。  </p>\n<h3 id=\"XAML中内置特殊标记扩展\"><a href=\"#XAML中内置特殊标记扩展\" class=\"headerlink\" title=\"XAML中内置特殊标记扩展\"></a>XAML中内置特殊标记扩展</h3><ul>\n<li><p>x:Type：特定类型  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;x:Type prefix:typeNameValue&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>x:Static：使用静态值。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;x:Static prefix:typeName.staticMemberName&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>x:Null：使用空对象定义为属性值。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;x:Null&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>x:Array：使用数组对象。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;x:Array Type=&quot;typeName&quot;&gt;    </span><br><span class=\"line\">  arrayContents    </span><br><span class=\"line\">&lt;/x:Array&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"常见的标记扩展\"><a href=\"#常见的标记扩展\" class=\"headerlink\" title=\"常见的标记扩展\"></a>常见的标记扩展</h3><ol>\n<li><p>StaticResource：通过替换已定义资源的值来为属性提供内容，该资源标记在XAML加载时自动执行。静态资源无法通过在XAML语法体系中对其引用关系进行前向引用，意味着无法通过多层级关系定义可复用的样式资源，如果需要这样做，则需要使用DynamicResource。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;StaticResource key&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>DynamicResource：在运行时为资源提供内容。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;DynamicResource key&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Binding：在运行时为使用数据上下文为数据提供内容。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;Binding&#125;&quot; .../&gt;    </span><br><span class=\"line\">-or-  </span><br><span class=\"line\">&lt;object property=&quot;&#123;Binding  bindProp1=value1[, bindPropN=valueN]*&#125;&quot; ...  </span><br><span class=\"line\">/&gt;    </span><br><span class=\"line\">-or-    </span><br><span class=\"line\">&lt;object property=&quot;&#123;Binding path&#125;&quot; .../&gt;  </span><br><span class=\"line\">-or     </span><br><span class=\"line\">&lt;object property=&quot;&#123;Binding path[, bindPropN=valueN]*&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>RelativeSource：提供了可在运行时对象树中导航几个可能的关系的 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.data.binding\" target=\"_blank\" rel=\"noopener\">Binding</a> 的源信息。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Binding RelativeSource=&quot;&#123;RelativeSource modeEnumValue&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>TemplateBinding：使控件模板能够使用模板化属性的值，这些属性来自于将使用该模板的类的对象模型定义属性。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;TemplateBinding sourceProperty&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ColorConvertedBitmap：提供一种方法，用于指定没有嵌入的配置文件的位图源。 颜色上下文/配置文件由 URI 指定，与映像源 URI 相同。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object property=&quot;&#123;ColorConvertedBitmap imageSource sourceIIC destinationIIC&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ComponentResourceKey和TemplateResourceKey：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;object x:Key=&quot;&#123;ComponentResourceKey &#123;x:Type targetTypeName&#125;, targetID&#125;&quot; .../&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"XAML资源复用\"><a href=\"#XAML资源复用\" class=\"headerlink\" title=\"XAML资源复用\"></a>XAML资源复用</h2><p>在开发过程中，我们可以直接在按钮上进行按钮模板的定义，例如下面的代码。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button Width=&quot;40&quot; Height=&quot;40&quot; Style=&quot;&#123;DynamicResource CubeImageButtonStyle&#125;&quot; Click=&quot;Button_Click&quot; Content=&quot;点赞&quot;&gt;</span><br><span class=\"line\">    &lt;Button.Background&gt;</span><br><span class=\"line\">                                &lt;ImageBrush ImageSource=&quot;/assests/favicon.png&quot; Stretch=&quot;Fill&quot;/&gt; </span><br><span class=\"line\">                            &lt;/Button.Background&gt;</span><br><span class=\"line\">                        &lt;/Button&gt;   </span><br><span class=\"line\">                          &lt;Setter Property=&quot;Template&quot;</span><br><span class=\"line\">                &lt;Setter.Value&gt;</span><br><span class=\"line\">                    &lt;ControlTemplate&gt;</span><br><span class=\"line\">                        &lt;Border BorderThickness=&quot;0&quot; CornerRadius=&quot;3&quot;&gt;</span><br><span class=\"line\">                            &lt;Border.Background&gt;</span><br><span class=\"line\">                                &lt;LinearGradientBrush EndPoint=&quot;0,1&quot; StartPoint=&quot;0,0&quot;&gt;</span><br><span class=\"line\">                                    &lt;GradientStop Color=&quot;#4696F2&quot; Offset=&quot;0.5&quot;/&gt;</span><br><span class=\"line\">                                &lt;/LinearGradientBrush&gt;</span><br><span class=\"line\">                            &lt;/Border.Background&gt;</span><br><span class=\"line\">                            &lt;ContentPresenter Content=&quot;&#123;TemplateBinding ContentControl.Content&#125;&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; /&gt;</span><br><span class=\"line\">                        &lt;/Border&gt;</span><br><span class=\"line\">                    &lt;/ControlTemplate&gt;</span><br><span class=\"line\">                &lt;/Setter.Value&gt;</span><br><span class=\"line\">            &lt;/Setter&gt;</span><br><span class=\"line\">        &lt;/Style&gt;</span><br><span class=\"line\"> &lt;/Window.Resources&gt;</span><br><span class=\"line\"> &lt;Grid&gt;</span><br><span class=\"line\">&lt;Button Grid.Column=&quot;0&quot; Grid.Row=&quot;1&quot; Style=&quot;&#123;StaticResource FlatButtonStyle&#125;&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;48&quot; Height=&quot;16&quot; FontSize=&quot;10&quot; Background=&quot;#4696F2&quot; Content=&quot;获取&quot;&gt;&lt;/Button&gt;</span><br><span class=\"line\"> &lt;/Grid&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这样的代码在界面比较简单时，还无所谓，但是随着控件的样式越来越复杂，可能会成为一团乱麻，这对于追求优雅代码的我们来说，可能是难以忍受的，所以往往会使用资源引用来完成。    </p>\n<h3 id=\"StaticResource\"><a href=\"#StaticResource\" class=\"headerlink\" title=\"StaticResource\"></a>StaticResource</h3><p>例如，我们可以在当前页面代码中定义对应的样式，这种样式可以使用 StaticResource 的形式引入。但是这样的引用形式，没有对象图的访问权限，意味着无法访问资源依赖的其他资源。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;Window.Resources&gt;  </span><br><span class=\"line\">&lt;Style TargetType=&quot;Button&quot; x:Key=&quot;FlatButtonStyle&quot;&gt;     </span><br><span class=\"line\">            &lt;Setter Property=&quot;Margin&quot;   Value=&quot;4&quot; /&gt;    </span><br><span class=\"line\">            &lt;Setter Property=&quot;FontWeight&quot; Value=&quot;Black&quot;/&gt;    </span><br><span class=\"line\">            &lt;Setter Property=&quot;Foreground&quot;  Value=&quot;Black&quot; /&gt;        </span><br><span class=\"line\">            &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;0&quot;/&gt;    </span><br><span class=\"line\">&lt;/Window.Resources&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DynamicResource\"><a href=\"#DynamicResource\" class=\"headerlink\" title=\"DynamicResource\"></a>DynamicResource</h3><p>将上述代码中的{StaticResource FlatButtonStyle} 改成{StaticResource  FlatButtonStyle}则会在运行时加载样式，并可以访问相应的对象图。</p>\n<p>当然，这样的更改意义不大，如果该FlatButtonStyle引用了其他样式或元素，会发生作用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Grid</span><br><span class=\"line\">&lt;Button Grid.Column=&quot;0&quot; Grid.Row=&quot;1&quot; Style=&quot;&#123;StaticResource FlatButtonStyle&#125;&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;48&quot; Height=&quot;16&quot; FontSize=&quot;10&quot; Background=&quot;#4696F2&quot; Content=&quot;获取&quot;&gt;&lt;/Button&gt;</span><br><span class=\"line\"> &lt;/Grid&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>1、由于XAML语法脱胎于XML语法，而XML语法中本身对某些输入字符，如“&lt;&gt;”存在限制，所以在XAML中也会出现这类问题，并会被Visual Studio检测出错误而无法编译，需要使用UTF-8编码进行转换。  </p>\n<h1 id=\"用户控件和自定义控件\"><a href=\"#用户控件和自定义控件\" class=\"headerlink\" title=\"用户控件和自定义控件\"></a>用户控件和自定义控件</h1><h2 id=\"用户控件\"><a href=\"#用户控件\" class=\"headerlink\" title=\"用户控件\"></a>用户控件</h2><p>而用户控件，使用于控件组合的场景。  </p>\n<h2 id=\"自定义控件\"><a href=\"#自定义控件\" class=\"headerlink\" title=\"自定义控件\"></a>自定义控件</h2><p>在笔者进行开发时，总是思考究竟是使用用户控件，还是自定义控件，后来在阅读《葵花宝典-WPF自学手册》这本书中，终于得以大彻大悟。  </p>\n<p>作者指出：“不要被控件的外观所欺骗，要考虑其内在本质”。即思考控件的基本特征，首先想到该控件的行为与原有控件的行为是否相似，如果能够找到，则修改原有控件，而不是定义一个控件。尤其是在XAML语法中，能够通过Content 模型和模板、附加属性的运用，使得自定义控件的用途得到了进一步缩减，只有当实在万不得已时，在定义自定义控件。</p>\n<p>作者给出了使用自定义控件的分析思路：    </p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/flow.png\" alt=\"图片\"></p>\n<p>例如，在示例代码*<em>ToggleLikeButtonStyle *</em>中，我实现了一个点赞和取消点赞的状态，则使用了ToggleButton来完成，就没必要使用 Button 扩展出一个是否点赞的状态了。  </p>\n<p>而如果我们需要实现的功能有这么复杂，那大概使用传统的控件就无法实现，就得使用自定义控件了。（<a href=\"https://github.com/caomfan/WpfDemo.git\" target=\"_blank\" rel=\"noopener\">点击查看示例代码</a>）</p>\n<p><img src=\"https://uploader.shimo.im/f/f44dU5UMbaYZpJtm.png!thumbnail\" alt=\"图片\"></p>\n<p>作者定义了自定义控件 ButtonEx，并实现了依赖属性 ButtonType，见【依赖属性】，并定义了不同类型的样式特征。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;Trigger Property=&quot;ButtonType&quot; Value=&quot;Icon&quot;&gt;</span><br><span class=\"line\">                &lt;Setter Property=&quot;Cursor&quot; Value=&quot;Hand&quot;/&gt;</span><br><span class=\"line\">                &lt;Setter Property=&quot;Template&quot;&gt;</span><br><span class=\"line\">                    &lt;Setter.Value&gt;</span><br><span class=\"line\">                        &lt;ControlTemplate TargetType=&quot;&#123;x:Type controls:ButtonEx&#125;&quot;&gt;</span><br><span class=\"line\">                            &lt;Border Width=&quot;&#123;TemplateBinding Width&#125;&quot; Height=&quot;&#123;TemplateBinding Height&#125;&quot;&gt;</span><br><span class=\"line\">                                &lt;Image x:Name=&quot;Img&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Source=&quot;&#123;TemplateBinding Icon&#125;&quot; Stretch=&quot;None&quot;/&gt;</span><br><span class=\"line\">                            &lt;/Border&gt;</span><br><span class=\"line\">                            &lt;ControlTemplate.Triggers&gt;</span><br><span class=\"line\">                                &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&gt;</span><br><span class=\"line\">                                    &lt;Setter Property=&quot;Opacity&quot; Value=&quot;0.8&quot;/&gt;</span><br><span class=\"line\">                                &lt;/Trigger&gt;</span><br><span class=\"line\">                                &lt;Trigger Property=&quot;IsPressed&quot; Value=&quot;True&quot;&gt;</span><br><span class=\"line\">                                    &lt;Setter Property=&quot;Opacity&quot; Value=&quot;0.9&quot;/&gt;</span><br><span class=\"line\">                                &lt;/Trigger&gt;</span><br><span class=\"line\">                            &lt;/ControlTemplate.Triggers&gt;</span><br><span class=\"line\">                        &lt;/ControlTemplate&gt;</span><br><span class=\"line\">                    &lt;/Setter.Value&gt;</span><br><span class=\"line\">                &lt;/Setter&gt;</span><br><span class=\"line\">            &lt;/Trigger&gt;</span><br></pre></td></tr></table></figure>\n\n<p>使用时，只需这样设置，即可实现不同类型的按钮外观。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;controls:ButtonEx Icon=&quot;/Images/search.png&quot;  Margin=&quot;10&quot; ButtonType=&quot;Icon&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"属性和事件\"><a href=\"#属性和事件\" class=\"headerlink\" title=\"属性和事件\"></a>属性和事件</h1><h2 id=\"依赖属性\"><a href=\"#依赖属性\" class=\"headerlink\" title=\"依赖属性\"></a><a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/dependency-properties-overview\" target=\"_blank\" rel=\"noopener\">依赖属性</a></h2><p>依赖属性是为既有WPF控件对象定义自定义属性，以便支持其扩展，例如在上述自定义控件的示例中，就定义了依赖属性 ButtonType，实现了不同类型的按钮外观。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ButtonType ButtonType  </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            get &#123; return (ButtonType)GetValue(ButtonTypeProperty); &#125;</span><br><span class=\"line\">            set &#123; SetValue(ButtonTypeProperty, value); &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        public static readonly DependencyProperty ButtonTypeProperty =</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"DependencyProperty-Register-“ButtonType”-typeof-ButtonType-typeof-ButtonEx-new-PropertyMetadata-ButtonType-Normal\"><a href=\"#DependencyProperty-Register-“ButtonType”-typeof-ButtonType-typeof-ButtonEx-new-PropertyMetadata-ButtonType-Normal\" class=\"headerlink\" title=\"DependencyProperty.Register(“ButtonType”, typeof(ButtonType), typeof(ButtonEx), new PropertyMetadata(ButtonType.Normal));\"></a>DependencyProperty.Register(“ButtonType”, typeof(ButtonType), typeof(ButtonEx), new PropertyMetadata(ButtonType.Normal));</h2><p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/attached-properties-overview\" target=\"_blank\" rel=\"noopener\">附加属性</a><br>按照官方的说法就是“附加属性旨在用作可在任何对象上设置的一类全局属性”，例如，DockPanel面板中的子对象，继承了来自于容器对象的附加属性，使得其能够在父对象中实现停靠的功能。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;DockPanel&gt;</span><br><span class=\"line\">  &lt;CheckBox DockPanel.Dock=&quot;Top&quot;&gt;Hello&lt;/CheckBox&gt;</span><br><span class=\"line\">&lt;/DockPanel&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"路由事件\"><a href=\"#路由事件\" class=\"headerlink\" title=\"路由事件\"></a><a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/routed-events-overview\" target=\"_blank\" rel=\"noopener\">路由事件</a></h2><h3 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a>基本定义</h3><p>假设我们定义了几个这样的控件。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Border Height=&quot;50&quot; Width=&quot;300&quot; BorderBrush=&quot;Gray&quot; BorderThickness=&quot;1&quot;&gt;</span><br><span class=\"line\">  &lt;StackPanel Background=&quot;LightGray&quot; Orientation=&quot;Horizontal&quot; Button.Click=&quot;CommonClickHandler&quot;&gt;</span><br><span class=\"line\">    &lt;Button Name=&quot;YesButton&quot; Width=&quot;Auto&quot; &gt;Yes&lt;/Button&gt;</span><br><span class=\"line\">    &lt;Button Name=&quot;NoButton&quot; Width=&quot;Auto&quot; &gt;No&lt;/Button&gt;</span><br><span class=\"line\">    &lt;Button Name=&quot;CancelButton&quot; Width=&quot;Auto&quot; &gt;Cancel&lt;/Button&gt;</span><br><span class=\"line\">  &lt;/StackPanel&gt;</span><br><span class=\"line\">&lt;/Border&gt;</span><br></pre></td></tr></table></figure>\n\n<p>实现了这样的界面<img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/ui.png\" alt=\"图片\"></p>\n<p>路由事件就是针对这组元素树中多个元素调用处理程序的事件。当我们点击了按钮Button时，将会触发 Button=&gt;StackPanel=&gt;Border的事件路由，而不是像WinForm应用一样，只能触发最上层的Button的按钮点击事件。  </p>\n<h3 id=\"路由策略\"><a href=\"#路由策略\" class=\"headerlink\" title=\"路由策略\"></a>路由策略</h3><ul>\n<li><p>冒泡事件（官方称为浮升，这个翻译有点。。）：调用事件源上的事件处理程序。 路由事件随后会路由到后续的父级元素，直到到达元素树的根。 大多数路由事件都使用浮升路由策略。 浮升路由事件通常用于报告来自不同控件或其他 UI 元素的输入或状态变化。  </p>\n</li>\n<li><p>直接： 只有源元素本身才有机会调用处理程序以进行响应。通过使用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.eventsetter\" target=\"_blank\" rel=\"noopener\">EventSetter</a> 和 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.eventtrigger\" target=\"_blank\" rel=\"noopener\">EventTrigger</a>使用来设置处理程序。例如，可以使用RoutedEventArgs的<a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.routedeventargs.handled\" target=\"_blank\" rel=\"noopener\">Handled</a>，设置为 true 将事件标记为已处理，将 “停止” 路由用于隧道路由或冒泡路由。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void MakeButton2()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  Button b2 = new Button();</span><br><span class=\"line\">  b2.Click += new RoutedEventHandler(Onb2Click2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void Onb2Click2(object sender, RoutedEventArgs e)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  //logic to handle the Click event     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>隧道：最初将调用元素树的根处的事件处理程序。 随后，路由事件将朝着路由事件的源节点元素（即引发路由事件的元素）方向，沿路由线路传播到后续的子元素。  </p>\n</li>\n<li><p>WPF中约定，隧道路由事件的名称以单词“Preview”开头。 输入事件通常成对出现，一个是浮升事件，另一个是隧道事件。例如，如下图所示，假设按钮2为触发事件的源。  </p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-learn-wpf/event.png\" alt=\"图片\"></p>\n<p>1、处理Border根元素的隧道事件PreviewMouseDown  </p>\n<p>2、处理StackPanel面板的隧道事件PreviewMouseDown.  </p>\n<p>3、处理Button按钮的隧道事件的PreMouseDown。  </p>\n<p>4、处理Button按钮的MouseDown事件。  </p>\n<p>5、处理StackPanel的MouseDown事件。  </p>\n<p>6、处理Border的MouseDown事件。    </p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>WPF是一个非常庞大的技术体系，以上学习路径仅供开发者进行简单的入门，由于篇幅有限，对于标记扩展还需要进一步理解透彻，以及格式转换、图形绘制、数据绑定、MVVM等内容未能一一描述。  </p>\n<p>如果果想要对WPF进一步了解，最好通过系统的学习相关知识，除了前面提到的网站和几本书，最好的入门网站依然是<a href=\"https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/\" target=\"_blank\" rel=\"noopener\">微软官方文档</a>。  </p>\n<h1 id><a href=\"#\" class=\"headerlink\" title></a></h1>"},{"title":".NET Core的HttpClient连接池管理","date":"2020-03-12T00:28:00.000Z","author":"邹溪源","_content":"[本文来源](https://www.stevejgordon.co.uk/httpclient-connection-pooling-in-dotnet-core)*于史蒂夫·戈登（Steve Gordon）是Microsoft MVP，Pluralsight的作者，布莱顿（英国西南部城市）的高级开发人员和社区负责人。他的个人博客为：*[www.stevejgordon.co.uk](http://www.stevejgordon.co.uk)。\n\n***导读：***\n\n*.NET Core（从2.1开始）中的HttpClient执行连接池和这些连接的生命周期管理。这支持使用单个HttpClient实例，通过单例减少了套接字耗尽的机会，同时确保连接定期重新连接以反映DNS更改。*\n\n## 回顾HttpClient的历史\nHttpClient最初是作为NuGet包开始的，该包可以选择包含在.NET Framework 4.0项目中。在.NET Framework 4.5中，它作为BCL（基本类库）的一部分在框中提供。它建立在预先存在的HttpWebRequest实现之上。在.NET Framework中，ServicePoint API可用于控制和管理HTTP连接，包括通过为端点配置ConnectionLeaseTimeout来设置连接寿命。\n\n![图片](https://uploader.shimo.im/f/oKgF6qKs4QYLHxcE.png!thumbnail)\n\n.NET Core 1.0最初于2016年6月发布。与.NET Framework中可用的版本相比，此第一个版本的API接口要小得多，主要用于构建ASP.NET Core Web应用程序。由于.NET Core 1.0是HttpClient，因此提供了API。但是，不包括用于HttpWebRequest和ServicePoint的API。.NET Core 1.0中的HttpClient直接建立在使用非托管代码的OS平台API之上，Windows API使用WinHTTP，Linux和Mac使用LibCurl。\n\n![图片](https://uploader.shimo.im/f/eQR5yORTYbAFS4Th.png!thumbnail)\n\n到2016年8月，很快就注意到，重新使用HttpClient实例以防止套接字耗尽的建议有一个相当麻烦的副作用。Oren Novotny（译者注：.NET基金会执行董事，.NET团队的项目经理）揭开了一个长期存在的GitHub问题，题为“ [Singleton HttpClient doesn’t respect DNS changes](https://github.com/dotnet/corefx/issues/11224) ”(单例HttpClient不遵守DNS 更改）。在此问题中，人们认识到重新使用单个HttpClient实例将导致连接无限期保持打开状态，因此，DNS更改可能会导致请求失败或与过时的终结点通信。\n\n在.NET Core 2.0中，添加了HttpWebRequest以支持.NET Standard 2.0。它位于HttpClient实现的顶层，这与.NET Framework 4.5+中的工作原理相反。还添加了ServicePoint，尽管它的许多API接口要么要么会抛出未实现的异常，要么根本就没有实现。\n\n![图片](https://uploader.shimo.im/f/phP4JDje5EI92hn3.png!thumbnail)\n\n## 自.NET CORE 2.1以来的变化\n这种有问题的行为导致团队不同团队进行了两项工作。ASP.NET团队开始研究**Microsoft.Extensions.Http**包，该包的主要功能是**IHttpClientFactory**。这个针对HttpClient实例自用的工厂还包括基础HttpMessageHandler链的生命周期管理。如果您想了解有关此功能的更多信息，可以查看我的[系列博客文章](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore)，我将在此介绍。 \n\nIHttpClientFactory功能是作为ASP.NET Core 2.1的一部分发布的，对于许多人来说，这是一个很好的折衷方案，它解决了连接重用以及生命周期管理的问题。\n\n在同一时间范围内，.NET团队正在研究自己的解决方案。该团队也在.NET Core 2.1中发布，在HttpClient的处理程序链的核心引入了一个新的**SocketsHttpHandler**。该处理程序直接建立在Socket API之上，并在托管代码中实现HTTP。这项工作的一部分包括连接池系统以及为这些连接设置最大生存期的能力。此功能将是本文其余部分的重点。\n\n![图片](https://uploader.shimo.im/f/1Uacoirz6ok1CYur.png!thumbnail)\n\n但是在开始之前，我想指出，虽然默认情况下从.NET Core 2.1启用了SocketsHttpHandler，但实现仅限于HTTP / 1.1通信。那些需要HTTP / 2的用户必须禁用该功能并使用较旧的处理程序链，该处理程序链像以前一样依赖非托管代码，并且不包括连接池。\n\n幸运的是，.NET Core 3.0中已消除了此限制，并且现在提供了HTTP/2支持。这应该使用基于适合所有对象的SocketsHttpHandler链的HttpClient。\n\n## 什么是连接池？\nSocketsHttpHandler为每个唯一端点建立连接池，您的应用程序通过HttpClient向该唯一端点发出出站HTTP请求。在对端点的第一个请求上，当不存在现有连接时，将建立一个新的HTTP连接并将其用于该请求。该请求完成后，连接将保持打开状态并返回到池中。\n\n对同一端点的后续请求将尝试从池中找到可用的连接。如果没有可用的连接，并且尚未达到该端点的连接限制，则将建立新的连接。达到连接限制后，请求将保留在队列中，直到连接可以自由发送它们为止。\n\n我一直在研究此实现的内部代码，并可能在以后的博客文章中对池的行为进行更深入的分析。\n\n## 如何控制连接池\n有三个主要设置可用于控制连接池的行为。\n\n**PooledConnectionLifetime**，定义连接在池中保持活动状态的时间。此生存期到期后，将不再为将来的请求而合并或发出连接。\n\n**PooledConnectionIdleTimeout**，定义闲置连接在未使用时在池中保留的时间。一旦此生存期到期，空闲连接将被清除并从池中删除。\n\n**MaxConnectionsPerServer**，定义每个端点将建立的最大出站连接数。每个端点的连接分别池化。例如，如果最大连接数为2，则您的应用程序将请求发送到两个[www.github.com](http://www.github.com/)和[www.google.com](http://www.google.com/)，总共可能最多有4个打开的连接。\n\n默认情况下，从.NET Core 2.1开始，更高级别的HttpClientHandler将SocketsHttpHandler用作内部处理程序。没有任何自定义配置，将应用连接池的默认设置。\n\n该**PooledConnectionLifetime**默认是无限的，因此，虽然经常使用的请求，连接可能会无限期地保持打开状态。该**PooledConnectionIdleTimeout**默认为2分钟，如果在连接池中长时间未使用将被清理。**MaxConnectionsPerServer**默认为int.MaxValue，因此连接基本上不受限制。\n\n如果希望控制这些值中的任何一个，则可以手动创建SocketsHttpHandler实例，并根据需要进行配置。\n\n```\nvar socketsHandler = new SocketsHttpHandler\n\t{\n\t    PooledConnectionLifetime = TimeSpan.FromMinutes(10),\n\t    PooledConnectionIdleTimeout = TimeSpan.FromMinutes(5),\n\t    MaxConnectionsPerServer = 10\n\t};\n\t\n\n\tvar client = new HttpClient(socketsHandler);\n```\n在前面的示例中，对SocketsHttpHandler进行了配置，以使连接将最多在10分钟后停止重新发出并关闭。如果闲置5分钟，则连接将在池的清理过程中被更早地删除。我们还将最大连接数（每个端点）限制为十个。如果我们需要并行发出更多出站请求，则某些请求可能会排队等待，直到10个池中的连接可用为止。\n要应用处理程序，它将被传递到HttpClient的构造函数中。\n\n### 测试连接寿命\n以这个示例程序为例：\n\n```\nusing System;\n\tusing System.Net.Http;\n\tusing System.Threading.Tasks;\n\t\n\n\tnamespace HttpConnectionPoolingSamples\n\t{\n\t    class Program\n\t    {\n\t        static async Task Main(string[] args)\n\t        {\n\t            var ips = await Dns.GetHostAddressesAsync(\"www.google.com\");\n\t\n\n\t            foreach (var ipAddress in ips)\n\t            {\n\t                Console.WriteLine(ipAddress.MapToIPv4().ToString());\n\t            }\n\t            \n\t            var socketsHandler = new SocketsHttpHandler\n\t            {\n\t                PooledConnectionLifetime = TimeSpan.FromMinutes(10),\n\t                PooledConnectionIdleTimeout = TimeSpan.FromMinutes(5),\n\t                MaxConnectionsPerServer = 10\n\t            };\n\t\n\n\t            var client = new HttpClient(socketsHandler);\n\t            \n\t            for (var i = 0; i < 5; i++)\n\t            {\n\t                _ = await client.GetAsync(\"https://www.google.com\");\n\t                await Task.Delay(TimeSpan.FromSeconds(2));\n\t            }\n\t\n\n\t            Console.WriteLine(\"Press a key to exit...\");\n\t            Console.ReadKey();\n\t        }\n\t    }\n\t}\n```\n使用我们刚刚讨论的设置，此代码依次向同一端点发出5个请求。在每个请求之间，它会暂停两秒钟。该代码还输出从DNS检索到的Google服务器的IPv4地址。我们可以使用此IP地址来查看通过PowerShell中发出的netstat命令对其打开的连接：\n```\nnetstat -ano | findstr 216.58.211\n```\n在我的例子中，此命令的输出为：\n```\nTCP   192.168.1.139:53040   216.58.211.164:443   ESTABLISHED   20372\n```\n我们可以看到，在这种情况下，到远程端点的连接只有1个。在每个请求之后，该连接将返回到池中，因此在发出下一个请求时可以重新使用。\n如果我们更改连接的生存期，以使它们在1秒后过期，那么我们可以测试这对行为的影响：\n\n```\nusing System;\n\tusing System.Net;\n\tusing System.Net.Http;\n\tusing System.Threading.Tasks;\n\t\n\n\tnamespace HttpConnectionPoolingSamples\n\t{\n\t    class Program\n\t    {\n\t        static async Task Main(string[] args)\n\t        {\n\t            var ips = await Dns.GetHostAddressesAsync(\"www.google.com\");\n\t\n\n\t            foreach (var ipAddress in ips)\n\t            {\n\t                Console.WriteLine(ipAddress.MapToIPv4().ToString());\n\t            }\n\t\n\n\t            var socketsHandler = new SocketsHttpHandler\n\t            {\n\t                PooledConnectionLifetime = TimeSpan.FromSeconds(1),\n\t                PooledConnectionIdleTimeout = TimeSpan.FromSeconds(1),\n\t                MaxConnectionsPerServer = 10\n\t            };\n\t\n\n\t            var client = new HttpClient(socketsHandler);\n\t            \n\t            for (var i = 0; i < 5; i++)\n\t            {\n\t                _ = await client.GetAsync(\"https://www.google.com\");\n\t                await Task.Delay(TimeSpan.FromSeconds(2));\n\t            }\n\t\n\n\t            Console.WriteLine(\"Press a key to exit...\");\n\t            Console.ReadKey();\n\t        }\n\t    }\n\t}\n```\n\n```\nTCP   192.168.1.139:53115   216.58.211.164:443   TIME_WAIT     0\nTCP   192.168.1.139:53116   216.58.211.164:443   TIME_WAIT     0\nTCP   192.168.1.139:53118   216.58.211.164:443   TIME_WAIT     0\nTCP   192.168.1.139:53120   216.58.211.164:443   TIME_WAIT     0\nTCP   192.168.1.139:53121   216.58.211.164:443   ESTABLISHED   25948\n```\n在这种情况下，我们可以看到使用了五个连接。其中的前四个在1秒后从池中删除，因此无法在下一个请求中重复使用。结果，每个请求都打开了一个新连接。现在，原始连接处于TIME_WAIT状态，并且操作系统无法将其重新用于新的出站连接。最终连接显示为ESTABLISHED，因为我在它过期之前就抓住了它。\n### 测试最大连接数\n对于下一个测试用例，我们将使用以下程序：\n\n```\nusing System;\n\tusing System.Diagnostics;\n\tusing System.Linq;\n\tusing System.Net;\n\tusing System.Net.Http;\n\tusing System.Threading.Tasks;\n\t\n\n\tnamespace HttpConnectionPoolingSamples\n\t{\n\t    class Program\n\t    {\n\t        static async Task Main(string[] args)\n\t        {\n\t            var ips = await Dns.GetHostAddressesAsync(\"www.google.com\");\n\t\n\n\t            foreach (var ipAddress in ips)\n\t            {\n\t                Console.WriteLine(ipAddress.MapToIPv4().ToString());\n\t            }\n\t\n\n\t            var socketsHandler = new SocketsHttpHandler\n\t            {\n\t                PooledConnectionLifetime = TimeSpan.FromSeconds(60),\n\t                PooledConnectionIdleTimeout = TimeSpan.FromMinutes(20),\n\t                MaxConnectionsPerServer = 2\n\t            };\n\t\n\n\t            var client = new HttpClient(socketsHandler);\n\t\n\n\t            var sw = Stopwatch.StartNew();\n\t\n\n\t            var tasks = Enumerable.Range(0, 200).Select(i => client.GetAsync(\"https://www.google.com\"));\n\t\n\n\t            await Task.WhenAll(tasks);\n\t\n\n\t            sw.Stop();\n\t\n\n\t            Console.WriteLine($\"{sw.ElapsedMilliseconds}ms taken for 200 requests\");\n\t\n\n\t            Console.WriteLine(\"Press a key to exit...\");\n\t            Console.ReadKey();\n\t        }\n\t    }\n\t}\n```\n该代码将MaxConnectionsPerServer限制为2。然后启动200个任务，每个任务都向同一端点发出HTTP请求。这些任务将同时运行。所有请求竞争所花费的时间将写入控制台。\n在我的机器上运行此命令后，输出为：\n\n```\n 8013ms taken for 200 requests\n```\n如果使用netstat查看连接，则根据定义的限制，我们可以看到两个已建立的连接。\n已建立\n\n```\nTCP   192.168.1.139:52780   216.58.204.36:443   ESTABLISHED   16076\nTCP   192.168.1.139:52780   216.58.204.36:443   ESTABLISHED   16076\n```\n如果我们调整此代码以允许MaxConnectionsPerServer = 10，则可以重新运行该应用程序。这次所花费的时间减少了大约4倍。\n```\n2123ms taken for 200 requests\n```\n当我们查看连接时，我们可以看到确实建立了十个连接。\n```\nTCP   192.168.1.139:52798   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52799   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52800   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52801   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52802   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52803   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52804   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52805   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52806   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52807   216.58.204.36:443   ESTABLISHED   30856\n```\n结果，提高了吞吐量。我们允许更多的出站连接，因此可以更快地处理请求队列，并通过额外的连接并行发出更多请求。\n## 我还需要IHttpClientFactory吗？\n这是一个非常合乎逻辑的问题，可能是该帖子的结果。IHttpClientFactory的功能之一是HttpMessageHandler链的生命周期管理，因此也是基础连接的生命周期管理。有了HttpClient和SocketsHttpHandler可以达到相同效果的知识，我们是否需要使用IHttpClientFactory？\n\n我的观点是，IHttpClientFactory除了帮助管理连接生存期外还有其他好处，并且在发出出站HTTP请求时仍然可以增加价值。它提供了一种很好的模式，可以使用[命名或类型化的客户端方法](https://www.stevejgordon.co.uk/httpclientfactory-named-typed-clients-aspnetcore)为HttpClient实例定义逻辑配置。后来有类型的客户是我个人的最爱。\n\n这些逻辑客户端的流畅配置方法还使[定制的DelegatingHandlers](https://www.stevejgordon.co.uk/httpclientfactory-aspnetcore-outgoing-request-middleware-pipeline-delegatinghandlers)与客户端的使用非常简单明了。这包括ASP.NET团队对该方法的扩展，以便[与Polly集成，](https://www.stevejgordon.co.uk/httpclientfactory-using-polly-for-transient-fault-handling)以便轻松地对出站请求应用弹性和瞬时故障处理。\n\n即使没有生命周期管理，我也希望在将来的一段时间内将工厂用于我的应用程序。根据我在网上看到的讨论，很有可能在将来的版本中，寿命管理功能将从IHttpClientFactory中弃用和/或删除，因为它解决的问题不再适用。\n\n## 摘要\n在本文中，我们看到自从.NET Core 2.1发布以来，使用默认的SocketsHttpHandler实现时，将维护连接池。使用池的设置，我们可以控制连接的生存期并限制每个端点可能创建的出站连接的数量。\n\n我们还讨论了IHttpClientFactory不仅具有连接生存期管理的优点和功能，因此仍然是一个有价值的工具。\n\n","source":"_posts/技术/how-to-use-httpclient-in-netcore.md","raw":"---\ntitle:  .NET Core的HttpClient连接池管理\ndate: 2020-3-12 8:28\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n[本文来源](https://www.stevejgordon.co.uk/httpclient-connection-pooling-in-dotnet-core)*于史蒂夫·戈登（Steve Gordon）是Microsoft MVP，Pluralsight的作者，布莱顿（英国西南部城市）的高级开发人员和社区负责人。他的个人博客为：*[www.stevejgordon.co.uk](http://www.stevejgordon.co.uk)。\n\n***导读：***\n\n*.NET Core（从2.1开始）中的HttpClient执行连接池和这些连接的生命周期管理。这支持使用单个HttpClient实例，通过单例减少了套接字耗尽的机会，同时确保连接定期重新连接以反映DNS更改。*\n\n## 回顾HttpClient的历史\nHttpClient最初是作为NuGet包开始的，该包可以选择包含在.NET Framework 4.0项目中。在.NET Framework 4.5中，它作为BCL（基本类库）的一部分在框中提供。它建立在预先存在的HttpWebRequest实现之上。在.NET Framework中，ServicePoint API可用于控制和管理HTTP连接，包括通过为端点配置ConnectionLeaseTimeout来设置连接寿命。\n\n![图片](https://uploader.shimo.im/f/oKgF6qKs4QYLHxcE.png!thumbnail)\n\n.NET Core 1.0最初于2016年6月发布。与.NET Framework中可用的版本相比，此第一个版本的API接口要小得多，主要用于构建ASP.NET Core Web应用程序。由于.NET Core 1.0是HttpClient，因此提供了API。但是，不包括用于HttpWebRequest和ServicePoint的API。.NET Core 1.0中的HttpClient直接建立在使用非托管代码的OS平台API之上，Windows API使用WinHTTP，Linux和Mac使用LibCurl。\n\n![图片](https://uploader.shimo.im/f/eQR5yORTYbAFS4Th.png!thumbnail)\n\n到2016年8月，很快就注意到，重新使用HttpClient实例以防止套接字耗尽的建议有一个相当麻烦的副作用。Oren Novotny（译者注：.NET基金会执行董事，.NET团队的项目经理）揭开了一个长期存在的GitHub问题，题为“ [Singleton HttpClient doesn’t respect DNS changes](https://github.com/dotnet/corefx/issues/11224) ”(单例HttpClient不遵守DNS 更改）。在此问题中，人们认识到重新使用单个HttpClient实例将导致连接无限期保持打开状态，因此，DNS更改可能会导致请求失败或与过时的终结点通信。\n\n在.NET Core 2.0中，添加了HttpWebRequest以支持.NET Standard 2.0。它位于HttpClient实现的顶层，这与.NET Framework 4.5+中的工作原理相反。还添加了ServicePoint，尽管它的许多API接口要么要么会抛出未实现的异常，要么根本就没有实现。\n\n![图片](https://uploader.shimo.im/f/phP4JDje5EI92hn3.png!thumbnail)\n\n## 自.NET CORE 2.1以来的变化\n这种有问题的行为导致团队不同团队进行了两项工作。ASP.NET团队开始研究**Microsoft.Extensions.Http**包，该包的主要功能是**IHttpClientFactory**。这个针对HttpClient实例自用的工厂还包括基础HttpMessageHandler链的生命周期管理。如果您想了解有关此功能的更多信息，可以查看我的[系列博客文章](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore)，我将在此介绍。 \n\nIHttpClientFactory功能是作为ASP.NET Core 2.1的一部分发布的，对于许多人来说，这是一个很好的折衷方案，它解决了连接重用以及生命周期管理的问题。\n\n在同一时间范围内，.NET团队正在研究自己的解决方案。该团队也在.NET Core 2.1中发布，在HttpClient的处理程序链的核心引入了一个新的**SocketsHttpHandler**。该处理程序直接建立在Socket API之上，并在托管代码中实现HTTP。这项工作的一部分包括连接池系统以及为这些连接设置最大生存期的能力。此功能将是本文其余部分的重点。\n\n![图片](https://uploader.shimo.im/f/1Uacoirz6ok1CYur.png!thumbnail)\n\n但是在开始之前，我想指出，虽然默认情况下从.NET Core 2.1启用了SocketsHttpHandler，但实现仅限于HTTP / 1.1通信。那些需要HTTP / 2的用户必须禁用该功能并使用较旧的处理程序链，该处理程序链像以前一样依赖非托管代码，并且不包括连接池。\n\n幸运的是，.NET Core 3.0中已消除了此限制，并且现在提供了HTTP/2支持。这应该使用基于适合所有对象的SocketsHttpHandler链的HttpClient。\n\n## 什么是连接池？\nSocketsHttpHandler为每个唯一端点建立连接池，您的应用程序通过HttpClient向该唯一端点发出出站HTTP请求。在对端点的第一个请求上，当不存在现有连接时，将建立一个新的HTTP连接并将其用于该请求。该请求完成后，连接将保持打开状态并返回到池中。\n\n对同一端点的后续请求将尝试从池中找到可用的连接。如果没有可用的连接，并且尚未达到该端点的连接限制，则将建立新的连接。达到连接限制后，请求将保留在队列中，直到连接可以自由发送它们为止。\n\n我一直在研究此实现的内部代码，并可能在以后的博客文章中对池的行为进行更深入的分析。\n\n## 如何控制连接池\n有三个主要设置可用于控制连接池的行为。\n\n**PooledConnectionLifetime**，定义连接在池中保持活动状态的时间。此生存期到期后，将不再为将来的请求而合并或发出连接。\n\n**PooledConnectionIdleTimeout**，定义闲置连接在未使用时在池中保留的时间。一旦此生存期到期，空闲连接将被清除并从池中删除。\n\n**MaxConnectionsPerServer**，定义每个端点将建立的最大出站连接数。每个端点的连接分别池化。例如，如果最大连接数为2，则您的应用程序将请求发送到两个[www.github.com](http://www.github.com/)和[www.google.com](http://www.google.com/)，总共可能最多有4个打开的连接。\n\n默认情况下，从.NET Core 2.1开始，更高级别的HttpClientHandler将SocketsHttpHandler用作内部处理程序。没有任何自定义配置，将应用连接池的默认设置。\n\n该**PooledConnectionLifetime**默认是无限的，因此，虽然经常使用的请求，连接可能会无限期地保持打开状态。该**PooledConnectionIdleTimeout**默认为2分钟，如果在连接池中长时间未使用将被清理。**MaxConnectionsPerServer**默认为int.MaxValue，因此连接基本上不受限制。\n\n如果希望控制这些值中的任何一个，则可以手动创建SocketsHttpHandler实例，并根据需要进行配置。\n\n```\nvar socketsHandler = new SocketsHttpHandler\n\t{\n\t    PooledConnectionLifetime = TimeSpan.FromMinutes(10),\n\t    PooledConnectionIdleTimeout = TimeSpan.FromMinutes(5),\n\t    MaxConnectionsPerServer = 10\n\t};\n\t\n\n\tvar client = new HttpClient(socketsHandler);\n```\n在前面的示例中，对SocketsHttpHandler进行了配置，以使连接将最多在10分钟后停止重新发出并关闭。如果闲置5分钟，则连接将在池的清理过程中被更早地删除。我们还将最大连接数（每个端点）限制为十个。如果我们需要并行发出更多出站请求，则某些请求可能会排队等待，直到10个池中的连接可用为止。\n要应用处理程序，它将被传递到HttpClient的构造函数中。\n\n### 测试连接寿命\n以这个示例程序为例：\n\n```\nusing System;\n\tusing System.Net.Http;\n\tusing System.Threading.Tasks;\n\t\n\n\tnamespace HttpConnectionPoolingSamples\n\t{\n\t    class Program\n\t    {\n\t        static async Task Main(string[] args)\n\t        {\n\t            var ips = await Dns.GetHostAddressesAsync(\"www.google.com\");\n\t\n\n\t            foreach (var ipAddress in ips)\n\t            {\n\t                Console.WriteLine(ipAddress.MapToIPv4().ToString());\n\t            }\n\t            \n\t            var socketsHandler = new SocketsHttpHandler\n\t            {\n\t                PooledConnectionLifetime = TimeSpan.FromMinutes(10),\n\t                PooledConnectionIdleTimeout = TimeSpan.FromMinutes(5),\n\t                MaxConnectionsPerServer = 10\n\t            };\n\t\n\n\t            var client = new HttpClient(socketsHandler);\n\t            \n\t            for (var i = 0; i < 5; i++)\n\t            {\n\t                _ = await client.GetAsync(\"https://www.google.com\");\n\t                await Task.Delay(TimeSpan.FromSeconds(2));\n\t            }\n\t\n\n\t            Console.WriteLine(\"Press a key to exit...\");\n\t            Console.ReadKey();\n\t        }\n\t    }\n\t}\n```\n使用我们刚刚讨论的设置，此代码依次向同一端点发出5个请求。在每个请求之间，它会暂停两秒钟。该代码还输出从DNS检索到的Google服务器的IPv4地址。我们可以使用此IP地址来查看通过PowerShell中发出的netstat命令对其打开的连接：\n```\nnetstat -ano | findstr 216.58.211\n```\n在我的例子中，此命令的输出为：\n```\nTCP   192.168.1.139:53040   216.58.211.164:443   ESTABLISHED   20372\n```\n我们可以看到，在这种情况下，到远程端点的连接只有1个。在每个请求之后，该连接将返回到池中，因此在发出下一个请求时可以重新使用。\n如果我们更改连接的生存期，以使它们在1秒后过期，那么我们可以测试这对行为的影响：\n\n```\nusing System;\n\tusing System.Net;\n\tusing System.Net.Http;\n\tusing System.Threading.Tasks;\n\t\n\n\tnamespace HttpConnectionPoolingSamples\n\t{\n\t    class Program\n\t    {\n\t        static async Task Main(string[] args)\n\t        {\n\t            var ips = await Dns.GetHostAddressesAsync(\"www.google.com\");\n\t\n\n\t            foreach (var ipAddress in ips)\n\t            {\n\t                Console.WriteLine(ipAddress.MapToIPv4().ToString());\n\t            }\n\t\n\n\t            var socketsHandler = new SocketsHttpHandler\n\t            {\n\t                PooledConnectionLifetime = TimeSpan.FromSeconds(1),\n\t                PooledConnectionIdleTimeout = TimeSpan.FromSeconds(1),\n\t                MaxConnectionsPerServer = 10\n\t            };\n\t\n\n\t            var client = new HttpClient(socketsHandler);\n\t            \n\t            for (var i = 0; i < 5; i++)\n\t            {\n\t                _ = await client.GetAsync(\"https://www.google.com\");\n\t                await Task.Delay(TimeSpan.FromSeconds(2));\n\t            }\n\t\n\n\t            Console.WriteLine(\"Press a key to exit...\");\n\t            Console.ReadKey();\n\t        }\n\t    }\n\t}\n```\n\n```\nTCP   192.168.1.139:53115   216.58.211.164:443   TIME_WAIT     0\nTCP   192.168.1.139:53116   216.58.211.164:443   TIME_WAIT     0\nTCP   192.168.1.139:53118   216.58.211.164:443   TIME_WAIT     0\nTCP   192.168.1.139:53120   216.58.211.164:443   TIME_WAIT     0\nTCP   192.168.1.139:53121   216.58.211.164:443   ESTABLISHED   25948\n```\n在这种情况下，我们可以看到使用了五个连接。其中的前四个在1秒后从池中删除，因此无法在下一个请求中重复使用。结果，每个请求都打开了一个新连接。现在，原始连接处于TIME_WAIT状态，并且操作系统无法将其重新用于新的出站连接。最终连接显示为ESTABLISHED，因为我在它过期之前就抓住了它。\n### 测试最大连接数\n对于下一个测试用例，我们将使用以下程序：\n\n```\nusing System;\n\tusing System.Diagnostics;\n\tusing System.Linq;\n\tusing System.Net;\n\tusing System.Net.Http;\n\tusing System.Threading.Tasks;\n\t\n\n\tnamespace HttpConnectionPoolingSamples\n\t{\n\t    class Program\n\t    {\n\t        static async Task Main(string[] args)\n\t        {\n\t            var ips = await Dns.GetHostAddressesAsync(\"www.google.com\");\n\t\n\n\t            foreach (var ipAddress in ips)\n\t            {\n\t                Console.WriteLine(ipAddress.MapToIPv4().ToString());\n\t            }\n\t\n\n\t            var socketsHandler = new SocketsHttpHandler\n\t            {\n\t                PooledConnectionLifetime = TimeSpan.FromSeconds(60),\n\t                PooledConnectionIdleTimeout = TimeSpan.FromMinutes(20),\n\t                MaxConnectionsPerServer = 2\n\t            };\n\t\n\n\t            var client = new HttpClient(socketsHandler);\n\t\n\n\t            var sw = Stopwatch.StartNew();\n\t\n\n\t            var tasks = Enumerable.Range(0, 200).Select(i => client.GetAsync(\"https://www.google.com\"));\n\t\n\n\t            await Task.WhenAll(tasks);\n\t\n\n\t            sw.Stop();\n\t\n\n\t            Console.WriteLine($\"{sw.ElapsedMilliseconds}ms taken for 200 requests\");\n\t\n\n\t            Console.WriteLine(\"Press a key to exit...\");\n\t            Console.ReadKey();\n\t        }\n\t    }\n\t}\n```\n该代码将MaxConnectionsPerServer限制为2。然后启动200个任务，每个任务都向同一端点发出HTTP请求。这些任务将同时运行。所有请求竞争所花费的时间将写入控制台。\n在我的机器上运行此命令后，输出为：\n\n```\n 8013ms taken for 200 requests\n```\n如果使用netstat查看连接，则根据定义的限制，我们可以看到两个已建立的连接。\n已建立\n\n```\nTCP   192.168.1.139:52780   216.58.204.36:443   ESTABLISHED   16076\nTCP   192.168.1.139:52780   216.58.204.36:443   ESTABLISHED   16076\n```\n如果我们调整此代码以允许MaxConnectionsPerServer = 10，则可以重新运行该应用程序。这次所花费的时间减少了大约4倍。\n```\n2123ms taken for 200 requests\n```\n当我们查看连接时，我们可以看到确实建立了十个连接。\n```\nTCP   192.168.1.139:52798   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52799   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52800   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52801   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52802   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52803   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52804   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52805   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52806   216.58.204.36:443   ESTABLISHED   30856\nTCP   192.168.1.139:52807   216.58.204.36:443   ESTABLISHED   30856\n```\n结果，提高了吞吐量。我们允许更多的出站连接，因此可以更快地处理请求队列，并通过额外的连接并行发出更多请求。\n## 我还需要IHttpClientFactory吗？\n这是一个非常合乎逻辑的问题，可能是该帖子的结果。IHttpClientFactory的功能之一是HttpMessageHandler链的生命周期管理，因此也是基础连接的生命周期管理。有了HttpClient和SocketsHttpHandler可以达到相同效果的知识，我们是否需要使用IHttpClientFactory？\n\n我的观点是，IHttpClientFactory除了帮助管理连接生存期外还有其他好处，并且在发出出站HTTP请求时仍然可以增加价值。它提供了一种很好的模式，可以使用[命名或类型化的客户端方法](https://www.stevejgordon.co.uk/httpclientfactory-named-typed-clients-aspnetcore)为HttpClient实例定义逻辑配置。后来有类型的客户是我个人的最爱。\n\n这些逻辑客户端的流畅配置方法还使[定制的DelegatingHandlers](https://www.stevejgordon.co.uk/httpclientfactory-aspnetcore-outgoing-request-middleware-pipeline-delegatinghandlers)与客户端的使用非常简单明了。这包括ASP.NET团队对该方法的扩展，以便[与Polly集成，](https://www.stevejgordon.co.uk/httpclientfactory-using-polly-for-transient-fault-handling)以便轻松地对出站请求应用弹性和瞬时故障处理。\n\n即使没有生命周期管理，我也希望在将来的一段时间内将工厂用于我的应用程序。根据我在网上看到的讨论，很有可能在将来的版本中，寿命管理功能将从IHttpClientFactory中弃用和/或删除，因为它解决的问题不再适用。\n\n## 摘要\n在本文中，我们看到自从.NET Core 2.1发布以来，使用默认的SocketsHttpHandler实现时，将维护连接池。使用池的设置，我们可以控制连接的生存期并限制每个端点可能创建的出站连接的数量。\n\n我们还讨论了IHttpClientFactory不仅具有连接生存期管理的优点和功能，因此仍然是一个有价值的工具。\n\n","slug":"技术/how-to-use-httpclient-in-netcore","published":1,"updated":"2020-03-12T00:47:58.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt6r000an4vienjgq92d","content":"<p><a href=\"https://www.stevejgordon.co.uk/httpclient-connection-pooling-in-dotnet-core\" target=\"_blank\" rel=\"noopener\">本文来源</a><em>于史蒂夫·戈登（Steve Gordon）是Microsoft MVP，Pluralsight的作者，布莱顿（英国西南部城市）的高级开发人员和社区负责人。他的个人博客为：</em><a href=\"http://www.stevejgordon.co.uk\" target=\"_blank\" rel=\"noopener\">www.stevejgordon.co.uk</a>。</p>\n<p><strong><em>导读：</em></strong></p>\n<p><em>.NET Core（从2.1开始）中的HttpClient执行连接池和这些连接的生命周期管理。这支持使用单个HttpClient实例，通过单例减少了套接字耗尽的机会，同时确保连接定期重新连接以反映DNS更改。</em></p>\n<h2 id=\"回顾HttpClient的历史\"><a href=\"#回顾HttpClient的历史\" class=\"headerlink\" title=\"回顾HttpClient的历史\"></a>回顾HttpClient的历史</h2><p>HttpClient最初是作为NuGet包开始的，该包可以选择包含在.NET Framework 4.0项目中。在.NET Framework 4.5中，它作为BCL（基本类库）的一部分在框中提供。它建立在预先存在的HttpWebRequest实现之上。在.NET Framework中，ServicePoint API可用于控制和管理HTTP连接，包括通过为端点配置ConnectionLeaseTimeout来设置连接寿命。</p>\n<p><img src=\"https://uploader.shimo.im/f/oKgF6qKs4QYLHxcE.png!thumbnail\" alt=\"图片\"></p>\n<p>.NET Core 1.0最初于2016年6月发布。与.NET Framework中可用的版本相比，此第一个版本的API接口要小得多，主要用于构建ASP.NET Core Web应用程序。由于.NET Core 1.0是HttpClient，因此提供了API。但是，不包括用于HttpWebRequest和ServicePoint的API。.NET Core 1.0中的HttpClient直接建立在使用非托管代码的OS平台API之上，Windows API使用WinHTTP，Linux和Mac使用LibCurl。</p>\n<p><img src=\"https://uploader.shimo.im/f/eQR5yORTYbAFS4Th.png!thumbnail\" alt=\"图片\"></p>\n<p>到2016年8月，很快就注意到，重新使用HttpClient实例以防止套接字耗尽的建议有一个相当麻烦的副作用。Oren Novotny（译者注：.NET基金会执行董事，.NET团队的项目经理）揭开了一个长期存在的GitHub问题，题为“ <a href=\"https://github.com/dotnet/corefx/issues/11224\" target=\"_blank\" rel=\"noopener\">Singleton HttpClient doesn’t respect DNS changes</a> ”(单例HttpClient不遵守DNS 更改）。在此问题中，人们认识到重新使用单个HttpClient实例将导致连接无限期保持打开状态，因此，DNS更改可能会导致请求失败或与过时的终结点通信。</p>\n<p>在.NET Core 2.0中，添加了HttpWebRequest以支持.NET Standard 2.0。它位于HttpClient实现的顶层，这与.NET Framework 4.5+中的工作原理相反。还添加了ServicePoint，尽管它的许多API接口要么要么会抛出未实现的异常，要么根本就没有实现。</p>\n<p><img src=\"https://uploader.shimo.im/f/phP4JDje5EI92hn3.png!thumbnail\" alt=\"图片\"></p>\n<h2 id=\"自-NET-CORE-2-1以来的变化\"><a href=\"#自-NET-CORE-2-1以来的变化\" class=\"headerlink\" title=\"自.NET CORE 2.1以来的变化\"></a>自.NET CORE 2.1以来的变化</h2><p>这种有问题的行为导致团队不同团队进行了两项工作。ASP.NET团队开始研究<strong>Microsoft.Extensions.Http</strong>包，该包的主要功能是<strong>IHttpClientFactory</strong>。这个针对HttpClient实例自用的工厂还包括基础HttpMessageHandler链的生命周期管理。如果您想了解有关此功能的更多信息，可以查看我的<a href=\"https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore\" target=\"_blank\" rel=\"noopener\">系列博客文章</a>，我将在此介绍。 </p>\n<p>IHttpClientFactory功能是作为ASP.NET Core 2.1的一部分发布的，对于许多人来说，这是一个很好的折衷方案，它解决了连接重用以及生命周期管理的问题。</p>\n<p>在同一时间范围内，.NET团队正在研究自己的解决方案。该团队也在.NET Core 2.1中发布，在HttpClient的处理程序链的核心引入了一个新的<strong>SocketsHttpHandler</strong>。该处理程序直接建立在Socket API之上，并在托管代码中实现HTTP。这项工作的一部分包括连接池系统以及为这些连接设置最大生存期的能力。此功能将是本文其余部分的重点。</p>\n<p><img src=\"https://uploader.shimo.im/f/1Uacoirz6ok1CYur.png!thumbnail\" alt=\"图片\"></p>\n<p>但是在开始之前，我想指出，虽然默认情况下从.NET Core 2.1启用了SocketsHttpHandler，但实现仅限于HTTP / 1.1通信。那些需要HTTP / 2的用户必须禁用该功能并使用较旧的处理程序链，该处理程序链像以前一样依赖非托管代码，并且不包括连接池。</p>\n<p>幸运的是，.NET Core 3.0中已消除了此限制，并且现在提供了HTTP/2支持。这应该使用基于适合所有对象的SocketsHttpHandler链的HttpClient。</p>\n<h2 id=\"什么是连接池？\"><a href=\"#什么是连接池？\" class=\"headerlink\" title=\"什么是连接池？\"></a>什么是连接池？</h2><p>SocketsHttpHandler为每个唯一端点建立连接池，您的应用程序通过HttpClient向该唯一端点发出出站HTTP请求。在对端点的第一个请求上，当不存在现有连接时，将建立一个新的HTTP连接并将其用于该请求。该请求完成后，连接将保持打开状态并返回到池中。</p>\n<p>对同一端点的后续请求将尝试从池中找到可用的连接。如果没有可用的连接，并且尚未达到该端点的连接限制，则将建立新的连接。达到连接限制后，请求将保留在队列中，直到连接可以自由发送它们为止。</p>\n<p>我一直在研究此实现的内部代码，并可能在以后的博客文章中对池的行为进行更深入的分析。</p>\n<h2 id=\"如何控制连接池\"><a href=\"#如何控制连接池\" class=\"headerlink\" title=\"如何控制连接池\"></a>如何控制连接池</h2><p>有三个主要设置可用于控制连接池的行为。</p>\n<p><strong>PooledConnectionLifetime</strong>，定义连接在池中保持活动状态的时间。此生存期到期后，将不再为将来的请求而合并或发出连接。</p>\n<p><strong>PooledConnectionIdleTimeout</strong>，定义闲置连接在未使用时在池中保留的时间。一旦此生存期到期，空闲连接将被清除并从池中删除。</p>\n<p><strong>MaxConnectionsPerServer</strong>，定义每个端点将建立的最大出站连接数。每个端点的连接分别池化。例如，如果最大连接数为2，则您的应用程序将请求发送到两个<a href=\"http://www.github.com/\" target=\"_blank\" rel=\"noopener\">www.github.com</a>和<a href=\"http://www.google.com/\" target=\"_blank\" rel=\"noopener\">www.google.com</a>，总共可能最多有4个打开的连接。</p>\n<p>默认情况下，从.NET Core 2.1开始，更高级别的HttpClientHandler将SocketsHttpHandler用作内部处理程序。没有任何自定义配置，将应用连接池的默认设置。</p>\n<p>该<strong>PooledConnectionLifetime</strong>默认是无限的，因此，虽然经常使用的请求，连接可能会无限期地保持打开状态。该<strong>PooledConnectionIdleTimeout</strong>默认为2分钟，如果在连接池中长时间未使用将被清理。<strong>MaxConnectionsPerServer</strong>默认为int.MaxValue，因此连接基本上不受限制。</p>\n<p>如果希望控制这些值中的任何一个，则可以手动创建SocketsHttpHandler实例，并根据需要进行配置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var socketsHandler = new SocketsHttpHandler</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    PooledConnectionLifetime = TimeSpan.FromMinutes(10),</span><br><span class=\"line\">\t    PooledConnectionIdleTimeout = TimeSpan.FromMinutes(5),</span><br><span class=\"line\">\t    MaxConnectionsPerServer = 10</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar client = new HttpClient(socketsHandler);</span><br></pre></td></tr></table></figure>\n\n<p>在前面的示例中，对SocketsHttpHandler进行了配置，以使连接将最多在10分钟后停止重新发出并关闭。如果闲置5分钟，则连接将在池的清理过程中被更早地删除。我们还将最大连接数（每个端点）限制为十个。如果我们需要并行发出更多出站请求，则某些请求可能会排队等待，直到10个池中的连接可用为止。<br>要应用处理程序，它将被传递到HttpClient的构造函数中。</p>\n<h3 id=\"测试连接寿命\"><a href=\"#测试连接寿命\" class=\"headerlink\" title=\"测试连接寿命\"></a>测试连接寿命</h3><p>以这个示例程序为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">\tusing System.Net.Http;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace HttpConnectionPoolingSamples</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    class Program</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        static async Task Main(string[] args)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            var ips = await Dns.GetHostAddressesAsync(&quot;www.google.com&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            foreach (var ipAddress in ips)</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                Console.WriteLine(ipAddress.MapToIPv4().ToString());</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t            var socketsHandler = new SocketsHttpHandler</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                PooledConnectionLifetime = TimeSpan.FromMinutes(10),</span><br><span class=\"line\">\t                PooledConnectionIdleTimeout = TimeSpan.FromMinutes(5),</span><br><span class=\"line\">\t                MaxConnectionsPerServer = 10</span><br><span class=\"line\">\t            &#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            var client = new HttpClient(socketsHandler);</span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t            for (var i = 0; i &lt; 5; i++)</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                _ = await client.GetAsync(&quot;https://www.google.com&quot;);</span><br><span class=\"line\">\t                await Task.Delay(TimeSpan.FromSeconds(2));</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            Console.WriteLine(&quot;Press a key to exit...&quot;);</span><br><span class=\"line\">\t            Console.ReadKey();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用我们刚刚讨论的设置，此代码依次向同一端点发出5个请求。在每个请求之间，它会暂停两秒钟。该代码还输出从DNS检索到的Google服务器的IPv4地址。我们可以使用此IP地址来查看通过PowerShell中发出的netstat命令对其打开的连接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ano | findstr 216.58.211</span><br></pre></td></tr></table></figure>\n\n<p>在我的例子中，此命令的输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCP   192.168.1.139:53040   216.58.211.164:443   ESTABLISHED   20372</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，在这种情况下，到远程端点的连接只有1个。在每个请求之后，该连接将返回到池中，因此在发出下一个请求时可以重新使用。<br>如果我们更改连接的生存期，以使它们在1秒后过期，那么我们可以测试这对行为的影响：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">\tusing System.Net;</span><br><span class=\"line\">\tusing System.Net.Http;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace HttpConnectionPoolingSamples</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    class Program</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        static async Task Main(string[] args)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            var ips = await Dns.GetHostAddressesAsync(&quot;www.google.com&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            foreach (var ipAddress in ips)</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                Console.WriteLine(ipAddress.MapToIPv4().ToString());</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            var socketsHandler = new SocketsHttpHandler</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                PooledConnectionLifetime = TimeSpan.FromSeconds(1),</span><br><span class=\"line\">\t                PooledConnectionIdleTimeout = TimeSpan.FromSeconds(1),</span><br><span class=\"line\">\t                MaxConnectionsPerServer = 10</span><br><span class=\"line\">\t            &#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            var client = new HttpClient(socketsHandler);</span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t            for (var i = 0; i &lt; 5; i++)</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                _ = await client.GetAsync(&quot;https://www.google.com&quot;);</span><br><span class=\"line\">\t                await Task.Delay(TimeSpan.FromSeconds(2));</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            Console.WriteLine(&quot;Press a key to exit...&quot;);</span><br><span class=\"line\">\t            Console.ReadKey();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCP   192.168.1.139:53115   216.58.211.164:443   TIME_WAIT     0</span><br><span class=\"line\">TCP   192.168.1.139:53116   216.58.211.164:443   TIME_WAIT     0</span><br><span class=\"line\">TCP   192.168.1.139:53118   216.58.211.164:443   TIME_WAIT     0</span><br><span class=\"line\">TCP   192.168.1.139:53120   216.58.211.164:443   TIME_WAIT     0</span><br><span class=\"line\">TCP   192.168.1.139:53121   216.58.211.164:443   ESTABLISHED   25948</span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，我们可以看到使用了五个连接。其中的前四个在1秒后从池中删除，因此无法在下一个请求中重复使用。结果，每个请求都打开了一个新连接。现在，原始连接处于TIME_WAIT状态，并且操作系统无法将其重新用于新的出站连接。最终连接显示为ESTABLISHED，因为我在它过期之前就抓住了它。</p>\n<h3 id=\"测试最大连接数\"><a href=\"#测试最大连接数\" class=\"headerlink\" title=\"测试最大连接数\"></a>测试最大连接数</h3><p>对于下一个测试用例，我们将使用以下程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">\tusing System.Diagnostics;</span><br><span class=\"line\">\tusing System.Linq;</span><br><span class=\"line\">\tusing System.Net;</span><br><span class=\"line\">\tusing System.Net.Http;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace HttpConnectionPoolingSamples</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    class Program</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        static async Task Main(string[] args)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            var ips = await Dns.GetHostAddressesAsync(&quot;www.google.com&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            foreach (var ipAddress in ips)</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                Console.WriteLine(ipAddress.MapToIPv4().ToString());</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            var socketsHandler = new SocketsHttpHandler</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                PooledConnectionLifetime = TimeSpan.FromSeconds(60),</span><br><span class=\"line\">\t                PooledConnectionIdleTimeout = TimeSpan.FromMinutes(20),</span><br><span class=\"line\">\t                MaxConnectionsPerServer = 2</span><br><span class=\"line\">\t            &#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            var client = new HttpClient(socketsHandler);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            var sw = Stopwatch.StartNew();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            var tasks = Enumerable.Range(0, 200).Select(i =&gt; client.GetAsync(&quot;https://www.google.com&quot;));</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            await Task.WhenAll(tasks);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            sw.Stop();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            Console.WriteLine($&quot;&#123;sw.ElapsedMilliseconds&#125;ms taken for 200 requests&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            Console.WriteLine(&quot;Press a key to exit...&quot;);</span><br><span class=\"line\">\t            Console.ReadKey();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该代码将MaxConnectionsPerServer限制为2。然后启动200个任务，每个任务都向同一端点发出HTTP请求。这些任务将同时运行。所有请求竞争所花费的时间将写入控制台。<br>在我的机器上运行此命令后，输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8013ms taken for 200 requests</span><br></pre></td></tr></table></figure>\n\n<p>如果使用netstat查看连接，则根据定义的限制，我们可以看到两个已建立的连接。<br>已建立</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCP   192.168.1.139:52780   216.58.204.36:443   ESTABLISHED   16076</span><br><span class=\"line\">TCP   192.168.1.139:52780   216.58.204.36:443   ESTABLISHED   16076</span><br></pre></td></tr></table></figure>\n\n<p>如果我们调整此代码以允许MaxConnectionsPerServer = 10，则可以重新运行该应用程序。这次所花费的时间减少了大约4倍。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2123ms taken for 200 requests</span><br></pre></td></tr></table></figure>\n\n<p>当我们查看连接时，我们可以看到确实建立了十个连接。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCP   192.168.1.139:52798   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52799   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52800   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52801   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52802   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52803   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52804   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52805   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52806   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52807   216.58.204.36:443   ESTABLISHED   30856</span><br></pre></td></tr></table></figure>\n\n<p>结果，提高了吞吐量。我们允许更多的出站连接，因此可以更快地处理请求队列，并通过额外的连接并行发出更多请求。</p>\n<h2 id=\"我还需要IHttpClientFactory吗？\"><a href=\"#我还需要IHttpClientFactory吗？\" class=\"headerlink\" title=\"我还需要IHttpClientFactory吗？\"></a>我还需要IHttpClientFactory吗？</h2><p>这是一个非常合乎逻辑的问题，可能是该帖子的结果。IHttpClientFactory的功能之一是HttpMessageHandler链的生命周期管理，因此也是基础连接的生命周期管理。有了HttpClient和SocketsHttpHandler可以达到相同效果的知识，我们是否需要使用IHttpClientFactory？</p>\n<p>我的观点是，IHttpClientFactory除了帮助管理连接生存期外还有其他好处，并且在发出出站HTTP请求时仍然可以增加价值。它提供了一种很好的模式，可以使用<a href=\"https://www.stevejgordon.co.uk/httpclientfactory-named-typed-clients-aspnetcore\" target=\"_blank\" rel=\"noopener\">命名或类型化的客户端方法</a>为HttpClient实例定义逻辑配置。后来有类型的客户是我个人的最爱。</p>\n<p>这些逻辑客户端的流畅配置方法还使<a href=\"https://www.stevejgordon.co.uk/httpclientfactory-aspnetcore-outgoing-request-middleware-pipeline-delegatinghandlers\" target=\"_blank\" rel=\"noopener\">定制的DelegatingHandlers</a>与客户端的使用非常简单明了。这包括ASP.NET团队对该方法的扩展，以便<a href=\"https://www.stevejgordon.co.uk/httpclientfactory-using-polly-for-transient-fault-handling\" target=\"_blank\" rel=\"noopener\">与Polly集成，</a>以便轻松地对出站请求应用弹性和瞬时故障处理。</p>\n<p>即使没有生命周期管理，我也希望在将来的一段时间内将工厂用于我的应用程序。根据我在网上看到的讨论，很有可能在将来的版本中，寿命管理功能将从IHttpClientFactory中弃用和/或删除，因为它解决的问题不再适用。</p>\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>在本文中，我们看到自从.NET Core 2.1发布以来，使用默认的SocketsHttpHandler实现时，将维护连接池。使用池的设置，我们可以控制连接的生存期并限制每个端点可能创建的出站连接的数量。</p>\n<p>我们还讨论了IHttpClientFactory不仅具有连接生存期管理的优点和功能，因此仍然是一个有价值的工具。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.stevejgordon.co.uk/httpclient-connection-pooling-in-dotnet-core\" target=\"_blank\" rel=\"noopener\">本文来源</a><em>于史蒂夫·戈登（Steve Gordon）是Microsoft MVP，Pluralsight的作者，布莱顿（英国西南部城市）的高级开发人员和社区负责人。他的个人博客为：</em><a href=\"http://www.stevejgordon.co.uk\" target=\"_blank\" rel=\"noopener\">www.stevejgordon.co.uk</a>。</p>\n<p><strong><em>导读：</em></strong></p>\n<p><em>.NET Core（从2.1开始）中的HttpClient执行连接池和这些连接的生命周期管理。这支持使用单个HttpClient实例，通过单例减少了套接字耗尽的机会，同时确保连接定期重新连接以反映DNS更改。</em></p>\n<h2 id=\"回顾HttpClient的历史\"><a href=\"#回顾HttpClient的历史\" class=\"headerlink\" title=\"回顾HttpClient的历史\"></a>回顾HttpClient的历史</h2><p>HttpClient最初是作为NuGet包开始的，该包可以选择包含在.NET Framework 4.0项目中。在.NET Framework 4.5中，它作为BCL（基本类库）的一部分在框中提供。它建立在预先存在的HttpWebRequest实现之上。在.NET Framework中，ServicePoint API可用于控制和管理HTTP连接，包括通过为端点配置ConnectionLeaseTimeout来设置连接寿命。</p>\n<p><img src=\"https://uploader.shimo.im/f/oKgF6qKs4QYLHxcE.png!thumbnail\" alt=\"图片\"></p>\n<p>.NET Core 1.0最初于2016年6月发布。与.NET Framework中可用的版本相比，此第一个版本的API接口要小得多，主要用于构建ASP.NET Core Web应用程序。由于.NET Core 1.0是HttpClient，因此提供了API。但是，不包括用于HttpWebRequest和ServicePoint的API。.NET Core 1.0中的HttpClient直接建立在使用非托管代码的OS平台API之上，Windows API使用WinHTTP，Linux和Mac使用LibCurl。</p>\n<p><img src=\"https://uploader.shimo.im/f/eQR5yORTYbAFS4Th.png!thumbnail\" alt=\"图片\"></p>\n<p>到2016年8月，很快就注意到，重新使用HttpClient实例以防止套接字耗尽的建议有一个相当麻烦的副作用。Oren Novotny（译者注：.NET基金会执行董事，.NET团队的项目经理）揭开了一个长期存在的GitHub问题，题为“ <a href=\"https://github.com/dotnet/corefx/issues/11224\" target=\"_blank\" rel=\"noopener\">Singleton HttpClient doesn’t respect DNS changes</a> ”(单例HttpClient不遵守DNS 更改）。在此问题中，人们认识到重新使用单个HttpClient实例将导致连接无限期保持打开状态，因此，DNS更改可能会导致请求失败或与过时的终结点通信。</p>\n<p>在.NET Core 2.0中，添加了HttpWebRequest以支持.NET Standard 2.0。它位于HttpClient实现的顶层，这与.NET Framework 4.5+中的工作原理相反。还添加了ServicePoint，尽管它的许多API接口要么要么会抛出未实现的异常，要么根本就没有实现。</p>\n<p><img src=\"https://uploader.shimo.im/f/phP4JDje5EI92hn3.png!thumbnail\" alt=\"图片\"></p>\n<h2 id=\"自-NET-CORE-2-1以来的变化\"><a href=\"#自-NET-CORE-2-1以来的变化\" class=\"headerlink\" title=\"自.NET CORE 2.1以来的变化\"></a>自.NET CORE 2.1以来的变化</h2><p>这种有问题的行为导致团队不同团队进行了两项工作。ASP.NET团队开始研究<strong>Microsoft.Extensions.Http</strong>包，该包的主要功能是<strong>IHttpClientFactory</strong>。这个针对HttpClient实例自用的工厂还包括基础HttpMessageHandler链的生命周期管理。如果您想了解有关此功能的更多信息，可以查看我的<a href=\"https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore\" target=\"_blank\" rel=\"noopener\">系列博客文章</a>，我将在此介绍。 </p>\n<p>IHttpClientFactory功能是作为ASP.NET Core 2.1的一部分发布的，对于许多人来说，这是一个很好的折衷方案，它解决了连接重用以及生命周期管理的问题。</p>\n<p>在同一时间范围内，.NET团队正在研究自己的解决方案。该团队也在.NET Core 2.1中发布，在HttpClient的处理程序链的核心引入了一个新的<strong>SocketsHttpHandler</strong>。该处理程序直接建立在Socket API之上，并在托管代码中实现HTTP。这项工作的一部分包括连接池系统以及为这些连接设置最大生存期的能力。此功能将是本文其余部分的重点。</p>\n<p><img src=\"https://uploader.shimo.im/f/1Uacoirz6ok1CYur.png!thumbnail\" alt=\"图片\"></p>\n<p>但是在开始之前，我想指出，虽然默认情况下从.NET Core 2.1启用了SocketsHttpHandler，但实现仅限于HTTP / 1.1通信。那些需要HTTP / 2的用户必须禁用该功能并使用较旧的处理程序链，该处理程序链像以前一样依赖非托管代码，并且不包括连接池。</p>\n<p>幸运的是，.NET Core 3.0中已消除了此限制，并且现在提供了HTTP/2支持。这应该使用基于适合所有对象的SocketsHttpHandler链的HttpClient。</p>\n<h2 id=\"什么是连接池？\"><a href=\"#什么是连接池？\" class=\"headerlink\" title=\"什么是连接池？\"></a>什么是连接池？</h2><p>SocketsHttpHandler为每个唯一端点建立连接池，您的应用程序通过HttpClient向该唯一端点发出出站HTTP请求。在对端点的第一个请求上，当不存在现有连接时，将建立一个新的HTTP连接并将其用于该请求。该请求完成后，连接将保持打开状态并返回到池中。</p>\n<p>对同一端点的后续请求将尝试从池中找到可用的连接。如果没有可用的连接，并且尚未达到该端点的连接限制，则将建立新的连接。达到连接限制后，请求将保留在队列中，直到连接可以自由发送它们为止。</p>\n<p>我一直在研究此实现的内部代码，并可能在以后的博客文章中对池的行为进行更深入的分析。</p>\n<h2 id=\"如何控制连接池\"><a href=\"#如何控制连接池\" class=\"headerlink\" title=\"如何控制连接池\"></a>如何控制连接池</h2><p>有三个主要设置可用于控制连接池的行为。</p>\n<p><strong>PooledConnectionLifetime</strong>，定义连接在池中保持活动状态的时间。此生存期到期后，将不再为将来的请求而合并或发出连接。</p>\n<p><strong>PooledConnectionIdleTimeout</strong>，定义闲置连接在未使用时在池中保留的时间。一旦此生存期到期，空闲连接将被清除并从池中删除。</p>\n<p><strong>MaxConnectionsPerServer</strong>，定义每个端点将建立的最大出站连接数。每个端点的连接分别池化。例如，如果最大连接数为2，则您的应用程序将请求发送到两个<a href=\"http://www.github.com/\" target=\"_blank\" rel=\"noopener\">www.github.com</a>和<a href=\"http://www.google.com/\" target=\"_blank\" rel=\"noopener\">www.google.com</a>，总共可能最多有4个打开的连接。</p>\n<p>默认情况下，从.NET Core 2.1开始，更高级别的HttpClientHandler将SocketsHttpHandler用作内部处理程序。没有任何自定义配置，将应用连接池的默认设置。</p>\n<p>该<strong>PooledConnectionLifetime</strong>默认是无限的，因此，虽然经常使用的请求，连接可能会无限期地保持打开状态。该<strong>PooledConnectionIdleTimeout</strong>默认为2分钟，如果在连接池中长时间未使用将被清理。<strong>MaxConnectionsPerServer</strong>默认为int.MaxValue，因此连接基本上不受限制。</p>\n<p>如果希望控制这些值中的任何一个，则可以手动创建SocketsHttpHandler实例，并根据需要进行配置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var socketsHandler = new SocketsHttpHandler</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    PooledConnectionLifetime = TimeSpan.FromMinutes(10),</span><br><span class=\"line\">\t    PooledConnectionIdleTimeout = TimeSpan.FromMinutes(5),</span><br><span class=\"line\">\t    MaxConnectionsPerServer = 10</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar client = new HttpClient(socketsHandler);</span><br></pre></td></tr></table></figure>\n\n<p>在前面的示例中，对SocketsHttpHandler进行了配置，以使连接将最多在10分钟后停止重新发出并关闭。如果闲置5分钟，则连接将在池的清理过程中被更早地删除。我们还将最大连接数（每个端点）限制为十个。如果我们需要并行发出更多出站请求，则某些请求可能会排队等待，直到10个池中的连接可用为止。<br>要应用处理程序，它将被传递到HttpClient的构造函数中。</p>\n<h3 id=\"测试连接寿命\"><a href=\"#测试连接寿命\" class=\"headerlink\" title=\"测试连接寿命\"></a>测试连接寿命</h3><p>以这个示例程序为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">\tusing System.Net.Http;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace HttpConnectionPoolingSamples</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    class Program</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        static async Task Main(string[] args)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            var ips = await Dns.GetHostAddressesAsync(&quot;www.google.com&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            foreach (var ipAddress in ips)</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                Console.WriteLine(ipAddress.MapToIPv4().ToString());</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t            var socketsHandler = new SocketsHttpHandler</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                PooledConnectionLifetime = TimeSpan.FromMinutes(10),</span><br><span class=\"line\">\t                PooledConnectionIdleTimeout = TimeSpan.FromMinutes(5),</span><br><span class=\"line\">\t                MaxConnectionsPerServer = 10</span><br><span class=\"line\">\t            &#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            var client = new HttpClient(socketsHandler);</span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t            for (var i = 0; i &lt; 5; i++)</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                _ = await client.GetAsync(&quot;https://www.google.com&quot;);</span><br><span class=\"line\">\t                await Task.Delay(TimeSpan.FromSeconds(2));</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            Console.WriteLine(&quot;Press a key to exit...&quot;);</span><br><span class=\"line\">\t            Console.ReadKey();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用我们刚刚讨论的设置，此代码依次向同一端点发出5个请求。在每个请求之间，它会暂停两秒钟。该代码还输出从DNS检索到的Google服务器的IPv4地址。我们可以使用此IP地址来查看通过PowerShell中发出的netstat命令对其打开的连接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ano | findstr 216.58.211</span><br></pre></td></tr></table></figure>\n\n<p>在我的例子中，此命令的输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCP   192.168.1.139:53040   216.58.211.164:443   ESTABLISHED   20372</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，在这种情况下，到远程端点的连接只有1个。在每个请求之后，该连接将返回到池中，因此在发出下一个请求时可以重新使用。<br>如果我们更改连接的生存期，以使它们在1秒后过期，那么我们可以测试这对行为的影响：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">\tusing System.Net;</span><br><span class=\"line\">\tusing System.Net.Http;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace HttpConnectionPoolingSamples</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    class Program</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        static async Task Main(string[] args)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            var ips = await Dns.GetHostAddressesAsync(&quot;www.google.com&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            foreach (var ipAddress in ips)</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                Console.WriteLine(ipAddress.MapToIPv4().ToString());</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            var socketsHandler = new SocketsHttpHandler</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                PooledConnectionLifetime = TimeSpan.FromSeconds(1),</span><br><span class=\"line\">\t                PooledConnectionIdleTimeout = TimeSpan.FromSeconds(1),</span><br><span class=\"line\">\t                MaxConnectionsPerServer = 10</span><br><span class=\"line\">\t            &#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            var client = new HttpClient(socketsHandler);</span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t            for (var i = 0; i &lt; 5; i++)</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                _ = await client.GetAsync(&quot;https://www.google.com&quot;);</span><br><span class=\"line\">\t                await Task.Delay(TimeSpan.FromSeconds(2));</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            Console.WriteLine(&quot;Press a key to exit...&quot;);</span><br><span class=\"line\">\t            Console.ReadKey();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCP   192.168.1.139:53115   216.58.211.164:443   TIME_WAIT     0</span><br><span class=\"line\">TCP   192.168.1.139:53116   216.58.211.164:443   TIME_WAIT     0</span><br><span class=\"line\">TCP   192.168.1.139:53118   216.58.211.164:443   TIME_WAIT     0</span><br><span class=\"line\">TCP   192.168.1.139:53120   216.58.211.164:443   TIME_WAIT     0</span><br><span class=\"line\">TCP   192.168.1.139:53121   216.58.211.164:443   ESTABLISHED   25948</span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，我们可以看到使用了五个连接。其中的前四个在1秒后从池中删除，因此无法在下一个请求中重复使用。结果，每个请求都打开了一个新连接。现在，原始连接处于TIME_WAIT状态，并且操作系统无法将其重新用于新的出站连接。最终连接显示为ESTABLISHED，因为我在它过期之前就抓住了它。</p>\n<h3 id=\"测试最大连接数\"><a href=\"#测试最大连接数\" class=\"headerlink\" title=\"测试最大连接数\"></a>测试最大连接数</h3><p>对于下一个测试用例，我们将使用以下程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">\tusing System.Diagnostics;</span><br><span class=\"line\">\tusing System.Linq;</span><br><span class=\"line\">\tusing System.Net;</span><br><span class=\"line\">\tusing System.Net.Http;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace HttpConnectionPoolingSamples</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    class Program</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        static async Task Main(string[] args)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            var ips = await Dns.GetHostAddressesAsync(&quot;www.google.com&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            foreach (var ipAddress in ips)</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                Console.WriteLine(ipAddress.MapToIPv4().ToString());</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            var socketsHandler = new SocketsHttpHandler</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                PooledConnectionLifetime = TimeSpan.FromSeconds(60),</span><br><span class=\"line\">\t                PooledConnectionIdleTimeout = TimeSpan.FromMinutes(20),</span><br><span class=\"line\">\t                MaxConnectionsPerServer = 2</span><br><span class=\"line\">\t            &#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            var client = new HttpClient(socketsHandler);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            var sw = Stopwatch.StartNew();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            var tasks = Enumerable.Range(0, 200).Select(i =&gt; client.GetAsync(&quot;https://www.google.com&quot;));</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            await Task.WhenAll(tasks);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            sw.Stop();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            Console.WriteLine($&quot;&#123;sw.ElapsedMilliseconds&#125;ms taken for 200 requests&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            Console.WriteLine(&quot;Press a key to exit...&quot;);</span><br><span class=\"line\">\t            Console.ReadKey();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该代码将MaxConnectionsPerServer限制为2。然后启动200个任务，每个任务都向同一端点发出HTTP请求。这些任务将同时运行。所有请求竞争所花费的时间将写入控制台。<br>在我的机器上运行此命令后，输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8013ms taken for 200 requests</span><br></pre></td></tr></table></figure>\n\n<p>如果使用netstat查看连接，则根据定义的限制，我们可以看到两个已建立的连接。<br>已建立</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCP   192.168.1.139:52780   216.58.204.36:443   ESTABLISHED   16076</span><br><span class=\"line\">TCP   192.168.1.139:52780   216.58.204.36:443   ESTABLISHED   16076</span><br></pre></td></tr></table></figure>\n\n<p>如果我们调整此代码以允许MaxConnectionsPerServer = 10，则可以重新运行该应用程序。这次所花费的时间减少了大约4倍。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2123ms taken for 200 requests</span><br></pre></td></tr></table></figure>\n\n<p>当我们查看连接时，我们可以看到确实建立了十个连接。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCP   192.168.1.139:52798   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52799   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52800   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52801   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52802   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52803   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52804   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52805   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52806   216.58.204.36:443   ESTABLISHED   30856</span><br><span class=\"line\">TCP   192.168.1.139:52807   216.58.204.36:443   ESTABLISHED   30856</span><br></pre></td></tr></table></figure>\n\n<p>结果，提高了吞吐量。我们允许更多的出站连接，因此可以更快地处理请求队列，并通过额外的连接并行发出更多请求。</p>\n<h2 id=\"我还需要IHttpClientFactory吗？\"><a href=\"#我还需要IHttpClientFactory吗？\" class=\"headerlink\" title=\"我还需要IHttpClientFactory吗？\"></a>我还需要IHttpClientFactory吗？</h2><p>这是一个非常合乎逻辑的问题，可能是该帖子的结果。IHttpClientFactory的功能之一是HttpMessageHandler链的生命周期管理，因此也是基础连接的生命周期管理。有了HttpClient和SocketsHttpHandler可以达到相同效果的知识，我们是否需要使用IHttpClientFactory？</p>\n<p>我的观点是，IHttpClientFactory除了帮助管理连接生存期外还有其他好处，并且在发出出站HTTP请求时仍然可以增加价值。它提供了一种很好的模式，可以使用<a href=\"https://www.stevejgordon.co.uk/httpclientfactory-named-typed-clients-aspnetcore\" target=\"_blank\" rel=\"noopener\">命名或类型化的客户端方法</a>为HttpClient实例定义逻辑配置。后来有类型的客户是我个人的最爱。</p>\n<p>这些逻辑客户端的流畅配置方法还使<a href=\"https://www.stevejgordon.co.uk/httpclientfactory-aspnetcore-outgoing-request-middleware-pipeline-delegatinghandlers\" target=\"_blank\" rel=\"noopener\">定制的DelegatingHandlers</a>与客户端的使用非常简单明了。这包括ASP.NET团队对该方法的扩展，以便<a href=\"https://www.stevejgordon.co.uk/httpclientfactory-using-polly-for-transient-fault-handling\" target=\"_blank\" rel=\"noopener\">与Polly集成，</a>以便轻松地对出站请求应用弹性和瞬时故障处理。</p>\n<p>即使没有生命周期管理，我也希望在将来的一段时间内将工厂用于我的应用程序。根据我在网上看到的讨论，很有可能在将来的版本中，寿命管理功能将从IHttpClientFactory中弃用和/或删除，因为它解决的问题不再适用。</p>\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>在本文中，我们看到自从.NET Core 2.1发布以来，使用默认的SocketsHttpHandler实现时，将维护连接池。使用池的设置，我们可以控制连接的生存期并限制每个端点可能创建的出站连接的数量。</p>\n<p>我们还讨论了IHttpClientFactory不仅具有连接生存期管理的优点和功能，因此仍然是一个有价值的工具。</p>\n"},{"title":"15个基本的C＃面试问题","date":"2020-03-26T00:54:00.000Z","author":"译者：笑语","_content":"\n\n1、给定一个int数组，编写方法以统计所有偶数的值。\n\n有很多方法可以做到这一点，但是最直接的两种方法是：\n\n```\nstatic long TotalAllEvenNumbers(int[] intArray) {\n  return intArray.Where(i => i % 2 == 0).Sum(i => (long)i);\n}\n```\n还有就是\n```\nstatic long TotalAllEvenNumbers(int[] intArray) {\n  return (from i in intArray where i % 2 == 0 select (long)i).Sum();\n}\n```\n当然，你还需要注意以下关键：\n1. 你是否利用 C＃语言特性 一行就解决问题。（即，不是使用包含循环，条件语句和累加器的更长篇幅的解决方案）\n2. 你是否考虑过溢出的可能性。例如，诸如 \n\n     return intArray.Where(i => i % 2 == 0).Sum()（与函数的返回类型无关）\n\n这可能一个很\"明显\"的单行，但这样溢出的可能性很高。虽然上面的答案中使用的转换为long的方法并没有消除这种可能性，但是它使得发生溢出异常的可能性非常小。但请注意，如果你写答案的时候询问数组的预期大小及其成员的大小，则显然你在做这道题目的时候在考虑此溢出问题，这很棒。\n\n# 2、下面的代码的输出是什么？解释你的答案。\n```\nclass Program {\n  static String location;\n  static DateTime time;\n \n  static void Main() {\n    Console.WriteLine(location == null ? \"location is null\" : location);\n    Console.WriteLine(time == null ? \"time is null\" : time.ToString());\n  }\n}\n```\n输出将是：\n\n```\nlocation is null\n1/1/0001 12:00:00 AM\n```\n下面的简短程序的输出是什么？解释你的答案。简短程序的输出是什么？解释你的答案。\n尽管两个变量都未初始化，但是String是引用类型 、DateTime 是值类型。作为值类型，单位化DateTime变量设置为默认值  公元1年晚上12点，*而不是* null \n\n# 3、下面语句中 time 和null 的比较是有效还是无效的?\n```\nstatic DateTime time;\n/* ... */\nif (time == null)\n{\n\t/* do something */\n}\n```\n有人可能会认为，由于变量永远不可能为null (它被自动初始化为1月1日的值)，所以编译器在比较某个变量时就会报错。具体来说，操作符将其操作数强制转换为不同的允许类型，以便在两边都得到一个通用类型，然后可以对其进行比较。这就是为什么像这样的东西会给你期望的结果(而不是失败或意外的行为，因为操作数是不同的类型):\n\n```\ndouble x = 5.0;\nint y = 5;\nConsole.WriteLine(x == y);  // outputs true\n```\n然而，这有时会导致意外的行为，例如DateTime变量和null的比较。在这种情况下，DateTime变量和null文字都可以转换为可空的。因此，比较这两个值是合法的，即使结果总是假的。\n# 4、给定circle以下类的实例：\n```\npublic sealed class Circle {\n  private double radius;\n  \n  public double Calculate(Func<double, double> op) {\n    return op(radius);\n  }\n}\n```\n 简编写代码以计算圆的周长，而无需修改Circle类本身。\n首选的答案如下:\n\n```\ncircle.Calculate(r => 2 * Math.PI * r);\n```\n由于我们不能访问对象的私有半径字段，所以我们通过内联传递计算函数，让对象本身计算周长。\n\n许多c#程序员回避(或不理解)函数值参数。虽然在这种情况下，这个例子有点做作，但其目的是看看申请人是否了解如何制定一个调用来计算哪个与方法的定义相匹配。\n\n另外，一个有效的(虽然不那么优雅的)解决方案是从对象中检索半径值本身，然后执行计算结果:\n\n```\nvar radius = circle.Calculate(r => r);\nvar circumference = 2 * Math.PI * radius;\n```\n无论哪种方式。我们在这里主要寻找的是面试者是否熟悉并理解如何调用Calculate方法。\n\n\n# 5、下面程序的输出是什么?解释你的答案。\n```\nclass Program {\n  private static string result;\n \n  static void Main() {\n    SaySomething();\n    Console.WriteLine(result);\n  }\n \n  static async Task<string> SaySomething() {\n    await Task.Delay(5);\n    result = \"Hello world!\";\n    return “Something”;\n  }\n```\n下面\n此外，如果我们替换wait task，答案会改变吗? 比如 thread . sleep (5) ? 为什么?的简短\n\n程序的输出是什么？解释你的答案。序的输出是什么？解释你的答案。\n\n回答：\n\n问题第一部分（即带有的代码版本await Task.Delay(5);）的答案是该程序将仅输出一个空行（而不是 “ Hello world！”）。这是因为调用result时仍将未初始化Console.WriteLine。\n\n大多数程序和面向对象的程序员都希望函数return在返回调用函数之前从头到尾执行，或者从语句执行。C＃async函数不是这种情况。它们只执行到第一个await语句，然后返回到调用方。由await（在此例中为Task.Delay）调用的函数是异步执行的，并且该await语句之后的行直到Task.Delay完成（在5毫秒内）之前都不会发出信号。但是，在这段时间内，控制权已经返回给调用者，该调用者Console.WriteLine对尚未初始化的字符串执行该语句。\n\n调用await Task.Delay(5) 可让当前线程继续其正在执行的操作，如果已完成（等待任何等待），则将其返回到线程池。这是异步/等待机制的主要好处。它允许CLR使用线程池中的更少线程来服务更多请求。\n\n异步编程已经变得越来越普遍，因为执行许多活动的网络服务请求或数据库请求的设备越来越普遍。C＃具有一些出色的编程结构，可以极大地简化异步方法的编程任务，并且意识到它们的程序员将产生更好的程序。\n\n关于问题的第二部分，如果将await Task.Delay(5);其替换为Thread.Sleep(5)，则程序将输出Hello world!。一种没有至少一个语句的async方法，其操作就像同步方法一样。也就是说，它将从头到尾执行，或者直到遇到一条语句为止。调用只是阻塞了当前正在运行的线程，因此调用仅将方法的执行时间增加了5毫秒。awaitreturnThread.Sleep()Thread.Sleep(5)SaySomething()\n\n\n# 6、下面的程序输出是什么？解释你的答案。\n```\ndelegate void Printer();\n\nstatic void Main()\n{\n        List<Printer> printers = new List<Printer>();\n        int i=0;\n        for(; i < 10; i++)\n        {\n            printers.Add(delegate { Console.WriteLine(i); });\n        }\n\n        foreach (var printer in printers)\n        {\n            printer();\n        }\n}\n```\n这个程序将把数字10输出十次。\n\n原因如下: 委托被添加到 for循环中l了，而 “引用” (或者“指针”)被存储到i中，而不是值本身。因此，在我们退出循环之后，变量i被设置为10，所以到调用每个委托时，传递给它们的值都是10。\n\n# 7、是否可以将混合数据类型（例如int，string，float，char）全部存储在一个数组中？\n是! 之所以可以这样做，是因为数组的类型object不仅可以存储任何数据类型，还可以存储类的对象，如下所示：\n\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication8\n{\n    class Program\n    {\n        class Customer\n        {\n            public int ID { get; set; }\n            public string Name { get; set; }\n            public override string ToString()\n            {\n                return this.Name;\n            }\n        }\n        static void Main(string[] args)\n        {\n            object[] array = new object[3];\n            array[0] = 101;\n            array[1] = \"C#\";\n            Customer c = new Customer();\n            c.ID = 55;\n            c.Name = \"Manish\";\n            array[2] = c;\n            foreach (object obj in array)\n            {\n                Console.WriteLine(obj);\n            }\n            Console.ReadLine();\n        }\n    }\n}\n```\n# 8、比较C＃中的结构和类。他们有什么共同点？它们有何不同？\nC＃中的类和结构确实有一些共同点，即：\n\n他们都是\n\n是复合数据类型\n\n可以包含方法和事件\n\n可以支持接口\n\n但是有许多差异。比较一下：\n\n**类：**\n\n支持继承\n\n是引用（指针）类型\n\n引用可以为空\n\n每个新实例都有内存开销\n\n**结构：**\n\n不支持继承\n\n是值类型\n\n按值传递（如整数）\n\n不能有空引用（除非使用了Nullable）\n\n每个新实例没有内存开销（除非“装箱”）\n\n# 9、这里有一个包含一个或多个$符号的字串，例如:\n```\n\"foo bar foo $ bar $ foo bar $ \"\n```\n问题：如何$从给定的字符串中删除第二和第三次出现的？\n答案：\n\n使用如下正则表达式：\n\n```\nstring s = \"like for example $  you don't have $  network $  access\";       \nRegex rgx = new Regex(\"\\\\$\\\\s+\");\ns = Regex.Replace(s, @\"(\\$\\s+.*?)\\$\\s+\", \"$1$$\");\nConsole.WriteLine(\"string is: {0}\",s);\n```\n说明：\n* (\\$\\s+.*?)-第1组，捕获一个文字$，一个或多个空格字符，然后捕获除换行符以外的任意数量的字符，并尽可能少地捕获到下一个最接近的匹配项\n* \\$\\s+—单个$符号和一个或多个空格字符\n* $1引用组1的值，它只是将其插入被替换的字符串中，$$代表替换模式中的$符号。\n# 10、下面的程序输出是什么？\n```\npublic class TestStatic\n    {\n        public static int TestValue;\n\n        public TestStatic()\n        {\n            if (TestValue == 0)\n            {\n                TestValue = 5;\n            }\n        }\n        static TestStatic()\n        {\n            if (TestValue == 0)\n            {\n                TestValue = 10;\n            }\n        }\n\n        public void Print()\n        {\n            if (TestValue == 5)\n            {\n                TestValue = 6;                \n            }\n            Console.WriteLine(\"TestValue : \" + TestValue);\n\n        } \n    }\n\n public void Main(string[] args)\n        {\n            TestStatic t = new TestStatic();\n            t.Print();\n        }\n```\nTestValue : 10\n\n在创建该类的任何实例之前，将调用该类的静态构造函数。此处调用的静态构造函数TestValue首先将变量初始化。\n\n# 11、有没有一种方法可以修改ClassA、以便您可以在调用Main方法时使用参数调用构造函数，而无需创建任何其他新实例ClassA？\n```\nclass ClassA\n{\n  public ClassA() { }\n\n  public ClassA(int pValue) {  }\n}\n```\n启动类\n```\nclass Program\n{\n  static void Main(string[] args)\n  {\n    ClassA refA = new ClassA();\n  }\n}\n```\n回答：\n\n所述this关键字被用于调用其他构造，初始化该类对象。下面是实现：\n\n```\nclass ClassA\n{\n  public ClassA() : this(10)\n  { }\n\n  public ClassA(int pValue)\n  {  }\n}\n```\n# 12、以下代码输出什么？\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace main1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            try\n            {\n                Console.WriteLine(\"Hello\");\n            }\n            catch (ArgumentNullException)\n            {\n                Console.WriteLine(\"A\");\n            }\n            catch (Exception)\n            {\n                Console.WriteLine(\"B\");\n            }\n            finally\n            {\n                Console.WriteLine(\"C\");\n            }\n            Console.ReadKey();\n        }\n    }\n}\n```\n答案：\n\n```\nHello\nC\n```\n# 13、描述依赖注入。\n依赖注入是一种使紧密链接的类分离的方式，从而减少了类之间的直接依赖。有多种方法可以实现依赖项注入：\n\n1. 构造函数依赖\n2. 属性依赖\n3. 方法依赖\n# 14、编写一个C＃程序，该程序接受以千米为单位的距离，将其转换为米，然后显示结果。\n```\nusing system; \n\nclass abc   \n\n{   \n    public static Void Main()   \n    \n    {\n      \n            int ndistance, nresult;  \n            \n        Console.WriteLine(\"Enter the distance in kilometers\");  \n        \n        ndistance = convert.ToInt32(Console.ReadLine());  \n        \n        nresult = ndistance * 1000;\n          \n        Console.WriteLine(\"Distance in meters: \" + nresult);  \n        \n        Console.ReadLine();  \n        \n    }  \n    \n}  \n```\n\n# 15、描述装箱和拆箱。并写一个例子。\n装箱是将值类型隐式转换为该类型object或该值类型实现的任何接口类型。将值类型装箱会创建一个包含该值的对象实例，并将其存储在堆中。\n\n例：\n\n```\nint x = 101;\nobject o = x;  // boxing value of x into object o\n\no = 999;\nx = (int)o;    // unboxing value of o into integer x\n```\n# 最后：\n面试不仅要基础扎实，更重要的是能解决棘手的技术问题，所以以上这些内容仅供参考。并非每个值得招聘的优秀候选人都能够回答所有问题，也不能确定能够全部回答，就能保证他是一个优秀候选人。归根结底，招聘仍然是一门艺术，一门科学以及许多工作。\n\n如果你有招聘的要求，也欢迎和我们公众号联系，我们有12万的粉丝，相信能在其中找到适合您公司的 .net 候选人。\n\n恭喜你！全部看完，看来您高手只有一步之遥，赶紧转发朋友圈吧！让其他.net 新手也来瞻仰瞻仰。 \n\n","source":"_posts/技术/ten-problems-view.md","raw":"---\ntitle:  15个基本的C＃面试问题\ndate: 2020-03-26 08:54\ntags: 技术\nauthor: 译者：笑语\ncategories:\n  - 技术\n---\n\n\n1、给定一个int数组，编写方法以统计所有偶数的值。\n\n有很多方法可以做到这一点，但是最直接的两种方法是：\n\n```\nstatic long TotalAllEvenNumbers(int[] intArray) {\n  return intArray.Where(i => i % 2 == 0).Sum(i => (long)i);\n}\n```\n还有就是\n```\nstatic long TotalAllEvenNumbers(int[] intArray) {\n  return (from i in intArray where i % 2 == 0 select (long)i).Sum();\n}\n```\n当然，你还需要注意以下关键：\n1. 你是否利用 C＃语言特性 一行就解决问题。（即，不是使用包含循环，条件语句和累加器的更长篇幅的解决方案）\n2. 你是否考虑过溢出的可能性。例如，诸如 \n\n     return intArray.Where(i => i % 2 == 0).Sum()（与函数的返回类型无关）\n\n这可能一个很\"明显\"的单行，但这样溢出的可能性很高。虽然上面的答案中使用的转换为long的方法并没有消除这种可能性，但是它使得发生溢出异常的可能性非常小。但请注意，如果你写答案的时候询问数组的预期大小及其成员的大小，则显然你在做这道题目的时候在考虑此溢出问题，这很棒。\n\n# 2、下面的代码的输出是什么？解释你的答案。\n```\nclass Program {\n  static String location;\n  static DateTime time;\n \n  static void Main() {\n    Console.WriteLine(location == null ? \"location is null\" : location);\n    Console.WriteLine(time == null ? \"time is null\" : time.ToString());\n  }\n}\n```\n输出将是：\n\n```\nlocation is null\n1/1/0001 12:00:00 AM\n```\n下面的简短程序的输出是什么？解释你的答案。简短程序的输出是什么？解释你的答案。\n尽管两个变量都未初始化，但是String是引用类型 、DateTime 是值类型。作为值类型，单位化DateTime变量设置为默认值  公元1年晚上12点，*而不是* null \n\n# 3、下面语句中 time 和null 的比较是有效还是无效的?\n```\nstatic DateTime time;\n/* ... */\nif (time == null)\n{\n\t/* do something */\n}\n```\n有人可能会认为，由于变量永远不可能为null (它被自动初始化为1月1日的值)，所以编译器在比较某个变量时就会报错。具体来说，操作符将其操作数强制转换为不同的允许类型，以便在两边都得到一个通用类型，然后可以对其进行比较。这就是为什么像这样的东西会给你期望的结果(而不是失败或意外的行为，因为操作数是不同的类型):\n\n```\ndouble x = 5.0;\nint y = 5;\nConsole.WriteLine(x == y);  // outputs true\n```\n然而，这有时会导致意外的行为，例如DateTime变量和null的比较。在这种情况下，DateTime变量和null文字都可以转换为可空的。因此，比较这两个值是合法的，即使结果总是假的。\n# 4、给定circle以下类的实例：\n```\npublic sealed class Circle {\n  private double radius;\n  \n  public double Calculate(Func<double, double> op) {\n    return op(radius);\n  }\n}\n```\n 简编写代码以计算圆的周长，而无需修改Circle类本身。\n首选的答案如下:\n\n```\ncircle.Calculate(r => 2 * Math.PI * r);\n```\n由于我们不能访问对象的私有半径字段，所以我们通过内联传递计算函数，让对象本身计算周长。\n\n许多c#程序员回避(或不理解)函数值参数。虽然在这种情况下，这个例子有点做作，但其目的是看看申请人是否了解如何制定一个调用来计算哪个与方法的定义相匹配。\n\n另外，一个有效的(虽然不那么优雅的)解决方案是从对象中检索半径值本身，然后执行计算结果:\n\n```\nvar radius = circle.Calculate(r => r);\nvar circumference = 2 * Math.PI * radius;\n```\n无论哪种方式。我们在这里主要寻找的是面试者是否熟悉并理解如何调用Calculate方法。\n\n\n# 5、下面程序的输出是什么?解释你的答案。\n```\nclass Program {\n  private static string result;\n \n  static void Main() {\n    SaySomething();\n    Console.WriteLine(result);\n  }\n \n  static async Task<string> SaySomething() {\n    await Task.Delay(5);\n    result = \"Hello world!\";\n    return “Something”;\n  }\n```\n下面\n此外，如果我们替换wait task，答案会改变吗? 比如 thread . sleep (5) ? 为什么?的简短\n\n程序的输出是什么？解释你的答案。序的输出是什么？解释你的答案。\n\n回答：\n\n问题第一部分（即带有的代码版本await Task.Delay(5);）的答案是该程序将仅输出一个空行（而不是 “ Hello world！”）。这是因为调用result时仍将未初始化Console.WriteLine。\n\n大多数程序和面向对象的程序员都希望函数return在返回调用函数之前从头到尾执行，或者从语句执行。C＃async函数不是这种情况。它们只执行到第一个await语句，然后返回到调用方。由await（在此例中为Task.Delay）调用的函数是异步执行的，并且该await语句之后的行直到Task.Delay完成（在5毫秒内）之前都不会发出信号。但是，在这段时间内，控制权已经返回给调用者，该调用者Console.WriteLine对尚未初始化的字符串执行该语句。\n\n调用await Task.Delay(5) 可让当前线程继续其正在执行的操作，如果已完成（等待任何等待），则将其返回到线程池。这是异步/等待机制的主要好处。它允许CLR使用线程池中的更少线程来服务更多请求。\n\n异步编程已经变得越来越普遍，因为执行许多活动的网络服务请求或数据库请求的设备越来越普遍。C＃具有一些出色的编程结构，可以极大地简化异步方法的编程任务，并且意识到它们的程序员将产生更好的程序。\n\n关于问题的第二部分，如果将await Task.Delay(5);其替换为Thread.Sleep(5)，则程序将输出Hello world!。一种没有至少一个语句的async方法，其操作就像同步方法一样。也就是说，它将从头到尾执行，或者直到遇到一条语句为止。调用只是阻塞了当前正在运行的线程，因此调用仅将方法的执行时间增加了5毫秒。awaitreturnThread.Sleep()Thread.Sleep(5)SaySomething()\n\n\n# 6、下面的程序输出是什么？解释你的答案。\n```\ndelegate void Printer();\n\nstatic void Main()\n{\n        List<Printer> printers = new List<Printer>();\n        int i=0;\n        for(; i < 10; i++)\n        {\n            printers.Add(delegate { Console.WriteLine(i); });\n        }\n\n        foreach (var printer in printers)\n        {\n            printer();\n        }\n}\n```\n这个程序将把数字10输出十次。\n\n原因如下: 委托被添加到 for循环中l了，而 “引用” (或者“指针”)被存储到i中，而不是值本身。因此，在我们退出循环之后，变量i被设置为10，所以到调用每个委托时，传递给它们的值都是10。\n\n# 7、是否可以将混合数据类型（例如int，string，float，char）全部存储在一个数组中？\n是! 之所以可以这样做，是因为数组的类型object不仅可以存储任何数据类型，还可以存储类的对象，如下所示：\n\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication8\n{\n    class Program\n    {\n        class Customer\n        {\n            public int ID { get; set; }\n            public string Name { get; set; }\n            public override string ToString()\n            {\n                return this.Name;\n            }\n        }\n        static void Main(string[] args)\n        {\n            object[] array = new object[3];\n            array[0] = 101;\n            array[1] = \"C#\";\n            Customer c = new Customer();\n            c.ID = 55;\n            c.Name = \"Manish\";\n            array[2] = c;\n            foreach (object obj in array)\n            {\n                Console.WriteLine(obj);\n            }\n            Console.ReadLine();\n        }\n    }\n}\n```\n# 8、比较C＃中的结构和类。他们有什么共同点？它们有何不同？\nC＃中的类和结构确实有一些共同点，即：\n\n他们都是\n\n是复合数据类型\n\n可以包含方法和事件\n\n可以支持接口\n\n但是有许多差异。比较一下：\n\n**类：**\n\n支持继承\n\n是引用（指针）类型\n\n引用可以为空\n\n每个新实例都有内存开销\n\n**结构：**\n\n不支持继承\n\n是值类型\n\n按值传递（如整数）\n\n不能有空引用（除非使用了Nullable）\n\n每个新实例没有内存开销（除非“装箱”）\n\n# 9、这里有一个包含一个或多个$符号的字串，例如:\n```\n\"foo bar foo $ bar $ foo bar $ \"\n```\n问题：如何$从给定的字符串中删除第二和第三次出现的？\n答案：\n\n使用如下正则表达式：\n\n```\nstring s = \"like for example $  you don't have $  network $  access\";       \nRegex rgx = new Regex(\"\\\\$\\\\s+\");\ns = Regex.Replace(s, @\"(\\$\\s+.*?)\\$\\s+\", \"$1$$\");\nConsole.WriteLine(\"string is: {0}\",s);\n```\n说明：\n* (\\$\\s+.*?)-第1组，捕获一个文字$，一个或多个空格字符，然后捕获除换行符以外的任意数量的字符，并尽可能少地捕获到下一个最接近的匹配项\n* \\$\\s+—单个$符号和一个或多个空格字符\n* $1引用组1的值，它只是将其插入被替换的字符串中，$$代表替换模式中的$符号。\n# 10、下面的程序输出是什么？\n```\npublic class TestStatic\n    {\n        public static int TestValue;\n\n        public TestStatic()\n        {\n            if (TestValue == 0)\n            {\n                TestValue = 5;\n            }\n        }\n        static TestStatic()\n        {\n            if (TestValue == 0)\n            {\n                TestValue = 10;\n            }\n        }\n\n        public void Print()\n        {\n            if (TestValue == 5)\n            {\n                TestValue = 6;                \n            }\n            Console.WriteLine(\"TestValue : \" + TestValue);\n\n        } \n    }\n\n public void Main(string[] args)\n        {\n            TestStatic t = new TestStatic();\n            t.Print();\n        }\n```\nTestValue : 10\n\n在创建该类的任何实例之前，将调用该类的静态构造函数。此处调用的静态构造函数TestValue首先将变量初始化。\n\n# 11、有没有一种方法可以修改ClassA、以便您可以在调用Main方法时使用参数调用构造函数，而无需创建任何其他新实例ClassA？\n```\nclass ClassA\n{\n  public ClassA() { }\n\n  public ClassA(int pValue) {  }\n}\n```\n启动类\n```\nclass Program\n{\n  static void Main(string[] args)\n  {\n    ClassA refA = new ClassA();\n  }\n}\n```\n回答：\n\n所述this关键字被用于调用其他构造，初始化该类对象。下面是实现：\n\n```\nclass ClassA\n{\n  public ClassA() : this(10)\n  { }\n\n  public ClassA(int pValue)\n  {  }\n}\n```\n# 12、以下代码输出什么？\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace main1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            try\n            {\n                Console.WriteLine(\"Hello\");\n            }\n            catch (ArgumentNullException)\n            {\n                Console.WriteLine(\"A\");\n            }\n            catch (Exception)\n            {\n                Console.WriteLine(\"B\");\n            }\n            finally\n            {\n                Console.WriteLine(\"C\");\n            }\n            Console.ReadKey();\n        }\n    }\n}\n```\n答案：\n\n```\nHello\nC\n```\n# 13、描述依赖注入。\n依赖注入是一种使紧密链接的类分离的方式，从而减少了类之间的直接依赖。有多种方法可以实现依赖项注入：\n\n1. 构造函数依赖\n2. 属性依赖\n3. 方法依赖\n# 14、编写一个C＃程序，该程序接受以千米为单位的距离，将其转换为米，然后显示结果。\n```\nusing system; \n\nclass abc   \n\n{   \n    public static Void Main()   \n    \n    {\n      \n            int ndistance, nresult;  \n            \n        Console.WriteLine(\"Enter the distance in kilometers\");  \n        \n        ndistance = convert.ToInt32(Console.ReadLine());  \n        \n        nresult = ndistance * 1000;\n          \n        Console.WriteLine(\"Distance in meters: \" + nresult);  \n        \n        Console.ReadLine();  \n        \n    }  \n    \n}  \n```\n\n# 15、描述装箱和拆箱。并写一个例子。\n装箱是将值类型隐式转换为该类型object或该值类型实现的任何接口类型。将值类型装箱会创建一个包含该值的对象实例，并将其存储在堆中。\n\n例：\n\n```\nint x = 101;\nobject o = x;  // boxing value of x into object o\n\no = 999;\nx = (int)o;    // unboxing value of o into integer x\n```\n# 最后：\n面试不仅要基础扎实，更重要的是能解决棘手的技术问题，所以以上这些内容仅供参考。并非每个值得招聘的优秀候选人都能够回答所有问题，也不能确定能够全部回答，就能保证他是一个优秀候选人。归根结底，招聘仍然是一门艺术，一门科学以及许多工作。\n\n如果你有招聘的要求，也欢迎和我们公众号联系，我们有12万的粉丝，相信能在其中找到适合您公司的 .net 候选人。\n\n恭喜你！全部看完，看来您高手只有一步之遥，赶紧转发朋友圈吧！让其他.net 新手也来瞻仰瞻仰。 \n\n","slug":"技术/ten-problems-view","published":1,"updated":"2020-03-26T00:56:02.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt6v000en4vinz05je93","content":"<p>1、给定一个int数组，编写方法以统计所有偶数的值。</p>\n<p>有很多方法可以做到这一点，但是最直接的两种方法是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static long TotalAllEvenNumbers(int[] intArray) &#123;</span><br><span class=\"line\">  return intArray.Where(i =&gt; i % 2 == 0).Sum(i =&gt; (long)i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static long TotalAllEvenNumbers(int[] intArray) &#123;</span><br><span class=\"line\">  return (from i in intArray where i % 2 == 0 select (long)i).Sum();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，你还需要注意以下关键：</p>\n<ol>\n<li><p>你是否利用 C＃语言特性 一行就解决问题。（即，不是使用包含循环，条件语句和累加器的更长篇幅的解决方案）</p>\n</li>\n<li><p>你是否考虑过溢出的可能性。例如，诸如 </p>\n<p>  return intArray.Where(i =&gt; i % 2 == 0).Sum()（与函数的返回类型无关）</p>\n</li>\n</ol>\n<p>这可能一个很”明显”的单行，但这样溢出的可能性很高。虽然上面的答案中使用的转换为long的方法并没有消除这种可能性，但是它使得发生溢出异常的可能性非常小。但请注意，如果你写答案的时候询问数组的预期大小及其成员的大小，则显然你在做这道题目的时候在考虑此溢出问题，这很棒。</p>\n<h1 id=\"2、下面的代码的输出是什么？解释你的答案。\"><a href=\"#2、下面的代码的输出是什么？解释你的答案。\" class=\"headerlink\" title=\"2、下面的代码的输出是什么？解释你的答案。\"></a>2、下面的代码的输出是什么？解释你的答案。</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Program &#123;</span><br><span class=\"line\">  static String location;</span><br><span class=\"line\">  static DateTime time;</span><br><span class=\"line\"> </span><br><span class=\"line\">  static void Main() &#123;</span><br><span class=\"line\">    Console.WriteLine(location == null ? &quot;location is null&quot; : location);</span><br><span class=\"line\">    Console.WriteLine(time == null ? &quot;time is null&quot; : time.ToString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出将是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location is null</span><br><span class=\"line\">1/1/0001 12:00:00 AM</span><br></pre></td></tr></table></figure>\n\n<p>下面的简短程序的输出是什么？解释你的答案。简短程序的输出是什么？解释你的答案。<br>尽管两个变量都未初始化，但是String是引用类型 、DateTime 是值类型。作为值类型，单位化DateTime变量设置为默认值  公元1年晚上12点，<em>而不是</em> null </p>\n<h1 id=\"3、下面语句中-time-和null-的比较是有效还是无效的\"><a href=\"#3、下面语句中-time-和null-的比较是有效还是无效的\" class=\"headerlink\" title=\"3、下面语句中 time 和null 的比较是有效还是无效的?\"></a>3、下面语句中 time 和null 的比较是有效还是无效的?</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static DateTime time;</span><br><span class=\"line\">/* ... */</span><br><span class=\"line\">if (time == null)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t/* do something */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有人可能会认为，由于变量永远不可能为null (它被自动初始化为1月1日的值)，所以编译器在比较某个变量时就会报错。具体来说，操作符将其操作数强制转换为不同的允许类型，以便在两边都得到一个通用类型，然后可以对其进行比较。这就是为什么像这样的东西会给你期望的结果(而不是失败或意外的行为，因为操作数是不同的类型):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double x = 5.0;</span><br><span class=\"line\">int y = 5;</span><br><span class=\"line\">Console.WriteLine(x == y);  // outputs true</span><br></pre></td></tr></table></figure>\n\n<p>然而，这有时会导致意外的行为，例如DateTime变量和null的比较。在这种情况下，DateTime变量和null文字都可以转换为可空的。因此，比较这两个值是合法的，即使结果总是假的。</p>\n<h1 id=\"4、给定circle以下类的实例：\"><a href=\"#4、给定circle以下类的实例：\" class=\"headerlink\" title=\"4、给定circle以下类的实例：\"></a>4、给定circle以下类的实例：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public sealed class Circle &#123;</span><br><span class=\"line\">  private double radius;</span><br><span class=\"line\">  </span><br><span class=\"line\">  public double Calculate(Func&lt;double, double&gt; op) &#123;</span><br><span class=\"line\">    return op(radius);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 简编写代码以计算圆的周长，而无需修改Circle类本身。<br>首选的答案如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">circle.Calculate(r =&gt; 2 * Math.PI * r);</span><br></pre></td></tr></table></figure>\n\n<p>由于我们不能访问对象的私有半径字段，所以我们通过内联传递计算函数，让对象本身计算周长。</p>\n<p>许多c#程序员回避(或不理解)函数值参数。虽然在这种情况下，这个例子有点做作，但其目的是看看申请人是否了解如何制定一个调用来计算哪个与方法的定义相匹配。</p>\n<p>另外，一个有效的(虽然不那么优雅的)解决方案是从对象中检索半径值本身，然后执行计算结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var radius = circle.Calculate(r =&gt; r);</span><br><span class=\"line\">var circumference = 2 * Math.PI * radius;</span><br></pre></td></tr></table></figure>\n\n<p>无论哪种方式。我们在这里主要寻找的是面试者是否熟悉并理解如何调用Calculate方法。</p>\n<h1 id=\"5、下面程序的输出是什么-解释你的答案。\"><a href=\"#5、下面程序的输出是什么-解释你的答案。\" class=\"headerlink\" title=\"5、下面程序的输出是什么?解释你的答案。\"></a>5、下面程序的输出是什么?解释你的答案。</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Program &#123;</span><br><span class=\"line\">  private static string result;</span><br><span class=\"line\"> </span><br><span class=\"line\">  static void Main() &#123;</span><br><span class=\"line\">    SaySomething();</span><br><span class=\"line\">    Console.WriteLine(result);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  static async Task&lt;string&gt; SaySomething() &#123;</span><br><span class=\"line\">    await Task.Delay(5);</span><br><span class=\"line\">    result = &quot;Hello world!&quot;;</span><br><span class=\"line\">    return “Something”;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面<br>此外，如果我们替换wait task，答案会改变吗? 比如 thread . sleep (5) ? 为什么?的简短</p>\n<p>程序的输出是什么？解释你的答案。序的输出是什么？解释你的答案。</p>\n<p>回答：</p>\n<p>问题第一部分（即带有的代码版本await Task.Delay(5);）的答案是该程序将仅输出一个空行（而不是 “ Hello world！”）。这是因为调用result时仍将未初始化Console.WriteLine。</p>\n<p>大多数程序和面向对象的程序员都希望函数return在返回调用函数之前从头到尾执行，或者从语句执行。C＃async函数不是这种情况。它们只执行到第一个await语句，然后返回到调用方。由await（在此例中为Task.Delay）调用的函数是异步执行的，并且该await语句之后的行直到Task.Delay完成（在5毫秒内）之前都不会发出信号。但是，在这段时间内，控制权已经返回给调用者，该调用者Console.WriteLine对尚未初始化的字符串执行该语句。</p>\n<p>调用await Task.Delay(5) 可让当前线程继续其正在执行的操作，如果已完成（等待任何等待），则将其返回到线程池。这是异步/等待机制的主要好处。它允许CLR使用线程池中的更少线程来服务更多请求。</p>\n<p>异步编程已经变得越来越普遍，因为执行许多活动的网络服务请求或数据库请求的设备越来越普遍。C＃具有一些出色的编程结构，可以极大地简化异步方法的编程任务，并且意识到它们的程序员将产生更好的程序。</p>\n<p>关于问题的第二部分，如果将await Task.Delay(5);其替换为Thread.Sleep(5)，则程序将输出Hello world!。一种没有至少一个语句的async方法，其操作就像同步方法一样。也就是说，它将从头到尾执行，或者直到遇到一条语句为止。调用只是阻塞了当前正在运行的线程，因此调用仅将方法的执行时间增加了5毫秒。awaitreturnThread.Sleep()Thread.Sleep(5)SaySomething()</p>\n<h1 id=\"6、下面的程序输出是什么？解释你的答案。\"><a href=\"#6、下面的程序输出是什么？解释你的答案。\" class=\"headerlink\" title=\"6、下面的程序输出是什么？解释你的答案。\"></a>6、下面的程序输出是什么？解释你的答案。</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delegate void Printer();</span><br><span class=\"line\"></span><br><span class=\"line\">static void Main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        List&lt;Printer&gt; printers = new List&lt;Printer&gt;();</span><br><span class=\"line\">        int i=0;</span><br><span class=\"line\">        for(; i &lt; 10; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            printers.Add(delegate &#123; Console.WriteLine(i); &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        foreach (var printer in printers)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            printer();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个程序将把数字10输出十次。</p>\n<p>原因如下: 委托被添加到 for循环中l了，而 “引用” (或者“指针”)被存储到i中，而不是值本身。因此，在我们退出循环之后，变量i被设置为10，所以到调用每个委托时，传递给它们的值都是10。</p>\n<h1 id=\"7、是否可以将混合数据类型（例如int，string，float，char）全部存储在一个数组中？\"><a href=\"#7、是否可以将混合数据类型（例如int，string，float，char）全部存储在一个数组中？\" class=\"headerlink\" title=\"7、是否可以将混合数据类型（例如int，string，float，char）全部存储在一个数组中？\"></a>7、是否可以将混合数据类型（例如int，string，float，char）全部存储在一个数组中？</h1><p>是! 之所以可以这样做，是因为数组的类型object不仅可以存储任何数据类型，还可以存储类的对象，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using System.Linq;</span><br><span class=\"line\">using System.Text;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace ConsoleApplication8</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    class Program</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        class Customer</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            public int ID &#123; get; set; &#125;</span><br><span class=\"line\">            public string Name &#123; get; set; &#125;</span><br><span class=\"line\">            public override string ToString()</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return this.Name;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        static void Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            object[] array = new object[3];</span><br><span class=\"line\">            array[0] = 101;</span><br><span class=\"line\">            array[1] = &quot;C#&quot;;</span><br><span class=\"line\">            Customer c = new Customer();</span><br><span class=\"line\">            c.ID = 55;</span><br><span class=\"line\">            c.Name = &quot;Manish&quot;;</span><br><span class=\"line\">            array[2] = c;</span><br><span class=\"line\">            foreach (object obj in array)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(obj);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Console.ReadLine();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"8、比较C＃中的结构和类。他们有什么共同点？它们有何不同？\"><a href=\"#8、比较C＃中的结构和类。他们有什么共同点？它们有何不同？\" class=\"headerlink\" title=\"8、比较C＃中的结构和类。他们有什么共同点？它们有何不同？\"></a>8、比较C＃中的结构和类。他们有什么共同点？它们有何不同？</h1><p>C＃中的类和结构确实有一些共同点，即：</p>\n<p>他们都是</p>\n<p>是复合数据类型</p>\n<p>可以包含方法和事件</p>\n<p>可以支持接口</p>\n<p>但是有许多差异。比较一下：</p>\n<p><strong>类：</strong></p>\n<p>支持继承</p>\n<p>是引用（指针）类型</p>\n<p>引用可以为空</p>\n<p>每个新实例都有内存开销</p>\n<p><strong>结构：</strong></p>\n<p>不支持继承</p>\n<p>是值类型</p>\n<p>按值传递（如整数）</p>\n<p>不能有空引用（除非使用了Nullable）</p>\n<p>每个新实例没有内存开销（除非“装箱”）</p>\n<h1 id=\"9、这里有一个包含一个或多个-符号的字串，例如\"><a href=\"#9、这里有一个包含一个或多个-符号的字串，例如\" class=\"headerlink\" title=\"9、这里有一个包含一个或多个$符号的字串，例如:\"></a>9、这里有一个包含一个或多个$符号的字串，例如:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;foo bar foo $ bar $ foo bar $ &quot;</span><br></pre></td></tr></table></figure>\n\n<p>问题：如何$从给定的字符串中删除第二和第三次出现的？<br>答案：</p>\n<p>使用如下正则表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s = &quot;like for example $  you don&apos;t have $  network $  access&quot;;       </span><br><span class=\"line\">Regex rgx = new Regex(&quot;\\\\$\\\\s+&quot;);</span><br><span class=\"line\">s = Regex.Replace(s, @&quot;(\\$\\s+.*?)\\$\\s+&quot;, &quot;$1$$&quot;);</span><br><span class=\"line\">Console.WriteLine(&quot;string is: &#123;0&#125;&quot;,s);</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<ul>\n<li>($\\s+.*?)-第1组，捕获一个文字$，一个或多个空格字符，然后捕获除换行符以外的任意数量的字符，并尽可能少地捕获到下一个最接近的匹配项</li>\n<li>$\\s+—单个$符号和一个或多个空格字符</li>\n<li>$1引用组1的值，它只是将其插入被替换的字符串中，$$代表替换模式中的$符号。<h1 id=\"10、下面的程序输出是什么？\"><a href=\"#10、下面的程序输出是什么？\" class=\"headerlink\" title=\"10、下面的程序输出是什么？\"></a>10、下面的程序输出是什么？</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestStatic</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        public static int TestValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        public TestStatic()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (TestValue == 0)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                TestValue = 5;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        static TestStatic()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (TestValue == 0)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                TestValue = 10;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public void Print()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (TestValue == 5)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                TestValue = 6;                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Console.WriteLine(&quot;TestValue : &quot; + TestValue);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> public void Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TestStatic t = new TestStatic();</span><br><span class=\"line\">            t.Print();</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>TestValue : 10</p>\n<p>在创建该类的任何实例之前，将调用该类的静态构造函数。此处调用的静态构造函数TestValue首先将变量初始化。</p>\n<h1 id=\"11、有没有一种方法可以修改ClassA、以便您可以在调用Main方法时使用参数调用构造函数，而无需创建任何其他新实例ClassA？\"><a href=\"#11、有没有一种方法可以修改ClassA、以便您可以在调用Main方法时使用参数调用构造函数，而无需创建任何其他新实例ClassA？\" class=\"headerlink\" title=\"11、有没有一种方法可以修改ClassA、以便您可以在调用Main方法时使用参数调用构造函数，而无需创建任何其他新实例ClassA？\"></a>11、有没有一种方法可以修改ClassA、以便您可以在调用Main方法时使用参数调用构造函数，而无需创建任何其他新实例ClassA？</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ClassA</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  public ClassA() &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public ClassA(int pValue) &#123;  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启动类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Program</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  static void Main(string[] args)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    ClassA refA = new ClassA();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回答：</p>\n<p>所述this关键字被用于调用其他构造，初始化该类对象。下面是实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ClassA</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  public ClassA() : this(10)</span><br><span class=\"line\">  &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public ClassA(int pValue)</span><br><span class=\"line\">  &#123;  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"12、以下代码输出什么？\"><a href=\"#12、以下代码输出什么？\" class=\"headerlink\" title=\"12、以下代码输出什么？\"></a>12、以下代码输出什么？</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using System.Linq;</span><br><span class=\"line\">using System.Text;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace main1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    class Program</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        static void Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            try</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(&quot;Hello&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            catch (ArgumentNullException)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(&quot;A&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            catch (Exception)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(&quot;B&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            finally</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(&quot;C&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Console.ReadKey();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>答案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello</span><br><span class=\"line\">C</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"13、描述依赖注入。\"><a href=\"#13、描述依赖注入。\" class=\"headerlink\" title=\"13、描述依赖注入。\"></a>13、描述依赖注入。</h1><p>依赖注入是一种使紧密链接的类分离的方式，从而减少了类之间的直接依赖。有多种方法可以实现依赖项注入：</p>\n<ol>\n<li>构造函数依赖</li>\n<li>属性依赖</li>\n<li>方法依赖<h1 id=\"14、编写一个C＃程序，该程序接受以千米为单位的距离，将其转换为米，然后显示结果。\"><a href=\"#14、编写一个C＃程序，该程序接受以千米为单位的距离，将其转换为米，然后显示结果。\" class=\"headerlink\" title=\"14、编写一个C＃程序，该程序接受以千米为单位的距离，将其转换为米，然后显示结果。\"></a>14、编写一个C＃程序，该程序接受以千米为单位的距离，将其转换为米，然后显示结果。</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using system; </span><br><span class=\"line\"></span><br><span class=\"line\">class abc   </span><br><span class=\"line\"></span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    public static Void Main()   </span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">            int ndistance, nresult;  </span><br><span class=\"line\">            </span><br><span class=\"line\">        Console.WriteLine(&quot;Enter the distance in kilometers&quot;);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        ndistance = convert.ToInt32(Console.ReadLine());  </span><br><span class=\"line\">        </span><br><span class=\"line\">        nresult = ndistance * 1000;</span><br><span class=\"line\">          </span><br><span class=\"line\">        Console.WriteLine(&quot;Distance in meters: &quot; + nresult);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Console.ReadLine();  </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h1 id=\"15、描述装箱和拆箱。并写一个例子。\"><a href=\"#15、描述装箱和拆箱。并写一个例子。\" class=\"headerlink\" title=\"15、描述装箱和拆箱。并写一个例子。\"></a>15、描述装箱和拆箱。并写一个例子。</h1><p>装箱是将值类型隐式转换为该类型object或该值类型实现的任何接口类型。将值类型装箱会创建一个包含该值的对象实例，并将其存储在堆中。</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int x = 101;</span><br><span class=\"line\">object o = x;  // boxing value of x into object o</span><br><span class=\"line\"></span><br><span class=\"line\">o = 999;</span><br><span class=\"line\">x = (int)o;    // unboxing value of o into integer x</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"最后：\"><a href=\"#最后：\" class=\"headerlink\" title=\"最后：\"></a>最后：</h1><p>面试不仅要基础扎实，更重要的是能解决棘手的技术问题，所以以上这些内容仅供参考。并非每个值得招聘的优秀候选人都能够回答所有问题，也不能确定能够全部回答，就能保证他是一个优秀候选人。归根结底，招聘仍然是一门艺术，一门科学以及许多工作。</p>\n<p>如果你有招聘的要求，也欢迎和我们公众号联系，我们有12万的粉丝，相信能在其中找到适合您公司的 .net 候选人。</p>\n<p>恭喜你！全部看完，看来您高手只有一步之遥，赶紧转发朋友圈吧！让其他.net 新手也来瞻仰瞻仰。 </p>\n","site":{"data":{}},"excerpt":"","more":"<p>1、给定一个int数组，编写方法以统计所有偶数的值。</p>\n<p>有很多方法可以做到这一点，但是最直接的两种方法是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static long TotalAllEvenNumbers(int[] intArray) &#123;</span><br><span class=\"line\">  return intArray.Where(i =&gt; i % 2 == 0).Sum(i =&gt; (long)i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static long TotalAllEvenNumbers(int[] intArray) &#123;</span><br><span class=\"line\">  return (from i in intArray where i % 2 == 0 select (long)i).Sum();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，你还需要注意以下关键：</p>\n<ol>\n<li><p>你是否利用 C＃语言特性 一行就解决问题。（即，不是使用包含循环，条件语句和累加器的更长篇幅的解决方案）</p>\n</li>\n<li><p>你是否考虑过溢出的可能性。例如，诸如 </p>\n<p>  return intArray.Where(i =&gt; i % 2 == 0).Sum()（与函数的返回类型无关）</p>\n</li>\n</ol>\n<p>这可能一个很”明显”的单行，但这样溢出的可能性很高。虽然上面的答案中使用的转换为long的方法并没有消除这种可能性，但是它使得发生溢出异常的可能性非常小。但请注意，如果你写答案的时候询问数组的预期大小及其成员的大小，则显然你在做这道题目的时候在考虑此溢出问题，这很棒。</p>\n<h1 id=\"2、下面的代码的输出是什么？解释你的答案。\"><a href=\"#2、下面的代码的输出是什么？解释你的答案。\" class=\"headerlink\" title=\"2、下面的代码的输出是什么？解释你的答案。\"></a>2、下面的代码的输出是什么？解释你的答案。</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Program &#123;</span><br><span class=\"line\">  static String location;</span><br><span class=\"line\">  static DateTime time;</span><br><span class=\"line\"> </span><br><span class=\"line\">  static void Main() &#123;</span><br><span class=\"line\">    Console.WriteLine(location == null ? &quot;location is null&quot; : location);</span><br><span class=\"line\">    Console.WriteLine(time == null ? &quot;time is null&quot; : time.ToString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出将是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location is null</span><br><span class=\"line\">1/1/0001 12:00:00 AM</span><br></pre></td></tr></table></figure>\n\n<p>下面的简短程序的输出是什么？解释你的答案。简短程序的输出是什么？解释你的答案。<br>尽管两个变量都未初始化，但是String是引用类型 、DateTime 是值类型。作为值类型，单位化DateTime变量设置为默认值  公元1年晚上12点，<em>而不是</em> null </p>\n<h1 id=\"3、下面语句中-time-和null-的比较是有效还是无效的\"><a href=\"#3、下面语句中-time-和null-的比较是有效还是无效的\" class=\"headerlink\" title=\"3、下面语句中 time 和null 的比较是有效还是无效的?\"></a>3、下面语句中 time 和null 的比较是有效还是无效的?</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static DateTime time;</span><br><span class=\"line\">/* ... */</span><br><span class=\"line\">if (time == null)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t/* do something */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有人可能会认为，由于变量永远不可能为null (它被自动初始化为1月1日的值)，所以编译器在比较某个变量时就会报错。具体来说，操作符将其操作数强制转换为不同的允许类型，以便在两边都得到一个通用类型，然后可以对其进行比较。这就是为什么像这样的东西会给你期望的结果(而不是失败或意外的行为，因为操作数是不同的类型):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double x = 5.0;</span><br><span class=\"line\">int y = 5;</span><br><span class=\"line\">Console.WriteLine(x == y);  // outputs true</span><br></pre></td></tr></table></figure>\n\n<p>然而，这有时会导致意外的行为，例如DateTime变量和null的比较。在这种情况下，DateTime变量和null文字都可以转换为可空的。因此，比较这两个值是合法的，即使结果总是假的。</p>\n<h1 id=\"4、给定circle以下类的实例：\"><a href=\"#4、给定circle以下类的实例：\" class=\"headerlink\" title=\"4、给定circle以下类的实例：\"></a>4、给定circle以下类的实例：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public sealed class Circle &#123;</span><br><span class=\"line\">  private double radius;</span><br><span class=\"line\">  </span><br><span class=\"line\">  public double Calculate(Func&lt;double, double&gt; op) &#123;</span><br><span class=\"line\">    return op(radius);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 简编写代码以计算圆的周长，而无需修改Circle类本身。<br>首选的答案如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">circle.Calculate(r =&gt; 2 * Math.PI * r);</span><br></pre></td></tr></table></figure>\n\n<p>由于我们不能访问对象的私有半径字段，所以我们通过内联传递计算函数，让对象本身计算周长。</p>\n<p>许多c#程序员回避(或不理解)函数值参数。虽然在这种情况下，这个例子有点做作，但其目的是看看申请人是否了解如何制定一个调用来计算哪个与方法的定义相匹配。</p>\n<p>另外，一个有效的(虽然不那么优雅的)解决方案是从对象中检索半径值本身，然后执行计算结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var radius = circle.Calculate(r =&gt; r);</span><br><span class=\"line\">var circumference = 2 * Math.PI * radius;</span><br></pre></td></tr></table></figure>\n\n<p>无论哪种方式。我们在这里主要寻找的是面试者是否熟悉并理解如何调用Calculate方法。</p>\n<h1 id=\"5、下面程序的输出是什么-解释你的答案。\"><a href=\"#5、下面程序的输出是什么-解释你的答案。\" class=\"headerlink\" title=\"5、下面程序的输出是什么?解释你的答案。\"></a>5、下面程序的输出是什么?解释你的答案。</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Program &#123;</span><br><span class=\"line\">  private static string result;</span><br><span class=\"line\"> </span><br><span class=\"line\">  static void Main() &#123;</span><br><span class=\"line\">    SaySomething();</span><br><span class=\"line\">    Console.WriteLine(result);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  static async Task&lt;string&gt; SaySomething() &#123;</span><br><span class=\"line\">    await Task.Delay(5);</span><br><span class=\"line\">    result = &quot;Hello world!&quot;;</span><br><span class=\"line\">    return “Something”;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面<br>此外，如果我们替换wait task，答案会改变吗? 比如 thread . sleep (5) ? 为什么?的简短</p>\n<p>程序的输出是什么？解释你的答案。序的输出是什么？解释你的答案。</p>\n<p>回答：</p>\n<p>问题第一部分（即带有的代码版本await Task.Delay(5);）的答案是该程序将仅输出一个空行（而不是 “ Hello world！”）。这是因为调用result时仍将未初始化Console.WriteLine。</p>\n<p>大多数程序和面向对象的程序员都希望函数return在返回调用函数之前从头到尾执行，或者从语句执行。C＃async函数不是这种情况。它们只执行到第一个await语句，然后返回到调用方。由await（在此例中为Task.Delay）调用的函数是异步执行的，并且该await语句之后的行直到Task.Delay完成（在5毫秒内）之前都不会发出信号。但是，在这段时间内，控制权已经返回给调用者，该调用者Console.WriteLine对尚未初始化的字符串执行该语句。</p>\n<p>调用await Task.Delay(5) 可让当前线程继续其正在执行的操作，如果已完成（等待任何等待），则将其返回到线程池。这是异步/等待机制的主要好处。它允许CLR使用线程池中的更少线程来服务更多请求。</p>\n<p>异步编程已经变得越来越普遍，因为执行许多活动的网络服务请求或数据库请求的设备越来越普遍。C＃具有一些出色的编程结构，可以极大地简化异步方法的编程任务，并且意识到它们的程序员将产生更好的程序。</p>\n<p>关于问题的第二部分，如果将await Task.Delay(5);其替换为Thread.Sleep(5)，则程序将输出Hello world!。一种没有至少一个语句的async方法，其操作就像同步方法一样。也就是说，它将从头到尾执行，或者直到遇到一条语句为止。调用只是阻塞了当前正在运行的线程，因此调用仅将方法的执行时间增加了5毫秒。awaitreturnThread.Sleep()Thread.Sleep(5)SaySomething()</p>\n<h1 id=\"6、下面的程序输出是什么？解释你的答案。\"><a href=\"#6、下面的程序输出是什么？解释你的答案。\" class=\"headerlink\" title=\"6、下面的程序输出是什么？解释你的答案。\"></a>6、下面的程序输出是什么？解释你的答案。</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delegate void Printer();</span><br><span class=\"line\"></span><br><span class=\"line\">static void Main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        List&lt;Printer&gt; printers = new List&lt;Printer&gt;();</span><br><span class=\"line\">        int i=0;</span><br><span class=\"line\">        for(; i &lt; 10; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            printers.Add(delegate &#123; Console.WriteLine(i); &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        foreach (var printer in printers)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            printer();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个程序将把数字10输出十次。</p>\n<p>原因如下: 委托被添加到 for循环中l了，而 “引用” (或者“指针”)被存储到i中，而不是值本身。因此，在我们退出循环之后，变量i被设置为10，所以到调用每个委托时，传递给它们的值都是10。</p>\n<h1 id=\"7、是否可以将混合数据类型（例如int，string，float，char）全部存储在一个数组中？\"><a href=\"#7、是否可以将混合数据类型（例如int，string，float，char）全部存储在一个数组中？\" class=\"headerlink\" title=\"7、是否可以将混合数据类型（例如int，string，float，char）全部存储在一个数组中？\"></a>7、是否可以将混合数据类型（例如int，string，float，char）全部存储在一个数组中？</h1><p>是! 之所以可以这样做，是因为数组的类型object不仅可以存储任何数据类型，还可以存储类的对象，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using System.Linq;</span><br><span class=\"line\">using System.Text;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace ConsoleApplication8</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    class Program</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        class Customer</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            public int ID &#123; get; set; &#125;</span><br><span class=\"line\">            public string Name &#123; get; set; &#125;</span><br><span class=\"line\">            public override string ToString()</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return this.Name;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        static void Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            object[] array = new object[3];</span><br><span class=\"line\">            array[0] = 101;</span><br><span class=\"line\">            array[1] = &quot;C#&quot;;</span><br><span class=\"line\">            Customer c = new Customer();</span><br><span class=\"line\">            c.ID = 55;</span><br><span class=\"line\">            c.Name = &quot;Manish&quot;;</span><br><span class=\"line\">            array[2] = c;</span><br><span class=\"line\">            foreach (object obj in array)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(obj);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Console.ReadLine();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"8、比较C＃中的结构和类。他们有什么共同点？它们有何不同？\"><a href=\"#8、比较C＃中的结构和类。他们有什么共同点？它们有何不同？\" class=\"headerlink\" title=\"8、比较C＃中的结构和类。他们有什么共同点？它们有何不同？\"></a>8、比较C＃中的结构和类。他们有什么共同点？它们有何不同？</h1><p>C＃中的类和结构确实有一些共同点，即：</p>\n<p>他们都是</p>\n<p>是复合数据类型</p>\n<p>可以包含方法和事件</p>\n<p>可以支持接口</p>\n<p>但是有许多差异。比较一下：</p>\n<p><strong>类：</strong></p>\n<p>支持继承</p>\n<p>是引用（指针）类型</p>\n<p>引用可以为空</p>\n<p>每个新实例都有内存开销</p>\n<p><strong>结构：</strong></p>\n<p>不支持继承</p>\n<p>是值类型</p>\n<p>按值传递（如整数）</p>\n<p>不能有空引用（除非使用了Nullable）</p>\n<p>每个新实例没有内存开销（除非“装箱”）</p>\n<h1 id=\"9、这里有一个包含一个或多个-符号的字串，例如\"><a href=\"#9、这里有一个包含一个或多个-符号的字串，例如\" class=\"headerlink\" title=\"9、这里有一个包含一个或多个$符号的字串，例如:\"></a>9、这里有一个包含一个或多个$符号的字串，例如:</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;foo bar foo $ bar $ foo bar $ &quot;</span><br></pre></td></tr></table></figure>\n\n<p>问题：如何$从给定的字符串中删除第二和第三次出现的？<br>答案：</p>\n<p>使用如下正则表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s = &quot;like for example $  you don&apos;t have $  network $  access&quot;;       </span><br><span class=\"line\">Regex rgx = new Regex(&quot;\\\\$\\\\s+&quot;);</span><br><span class=\"line\">s = Regex.Replace(s, @&quot;(\\$\\s+.*?)\\$\\s+&quot;, &quot;$1$$&quot;);</span><br><span class=\"line\">Console.WriteLine(&quot;string is: &#123;0&#125;&quot;,s);</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<ul>\n<li>($\\s+.*?)-第1组，捕获一个文字$，一个或多个空格字符，然后捕获除换行符以外的任意数量的字符，并尽可能少地捕获到下一个最接近的匹配项</li>\n<li>$\\s+—单个$符号和一个或多个空格字符</li>\n<li>$1引用组1的值，它只是将其插入被替换的字符串中，$$代表替换模式中的$符号。<h1 id=\"10、下面的程序输出是什么？\"><a href=\"#10、下面的程序输出是什么？\" class=\"headerlink\" title=\"10、下面的程序输出是什么？\"></a>10、下面的程序输出是什么？</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestStatic</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        public static int TestValue;</span><br><span class=\"line\"></span><br><span class=\"line\">        public TestStatic()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (TestValue == 0)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                TestValue = 5;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        static TestStatic()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (TestValue == 0)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                TestValue = 10;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public void Print()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (TestValue == 5)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                TestValue = 6;                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Console.WriteLine(&quot;TestValue : &quot; + TestValue);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> public void Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TestStatic t = new TestStatic();</span><br><span class=\"line\">            t.Print();</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>TestValue : 10</p>\n<p>在创建该类的任何实例之前，将调用该类的静态构造函数。此处调用的静态构造函数TestValue首先将变量初始化。</p>\n<h1 id=\"11、有没有一种方法可以修改ClassA、以便您可以在调用Main方法时使用参数调用构造函数，而无需创建任何其他新实例ClassA？\"><a href=\"#11、有没有一种方法可以修改ClassA、以便您可以在调用Main方法时使用参数调用构造函数，而无需创建任何其他新实例ClassA？\" class=\"headerlink\" title=\"11、有没有一种方法可以修改ClassA、以便您可以在调用Main方法时使用参数调用构造函数，而无需创建任何其他新实例ClassA？\"></a>11、有没有一种方法可以修改ClassA、以便您可以在调用Main方法时使用参数调用构造函数，而无需创建任何其他新实例ClassA？</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ClassA</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  public ClassA() &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public ClassA(int pValue) &#123;  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启动类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Program</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  static void Main(string[] args)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    ClassA refA = new ClassA();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回答：</p>\n<p>所述this关键字被用于调用其他构造，初始化该类对象。下面是实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ClassA</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  public ClassA() : this(10)</span><br><span class=\"line\">  &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public ClassA(int pValue)</span><br><span class=\"line\">  &#123;  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"12、以下代码输出什么？\"><a href=\"#12、以下代码输出什么？\" class=\"headerlink\" title=\"12、以下代码输出什么？\"></a>12、以下代码输出什么？</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using System.Linq;</span><br><span class=\"line\">using System.Text;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace main1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    class Program</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        static void Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            try</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(&quot;Hello&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            catch (ArgumentNullException)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(&quot;A&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            catch (Exception)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(&quot;B&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            finally</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(&quot;C&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Console.ReadKey();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>答案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello</span><br><span class=\"line\">C</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"13、描述依赖注入。\"><a href=\"#13、描述依赖注入。\" class=\"headerlink\" title=\"13、描述依赖注入。\"></a>13、描述依赖注入。</h1><p>依赖注入是一种使紧密链接的类分离的方式，从而减少了类之间的直接依赖。有多种方法可以实现依赖项注入：</p>\n<ol>\n<li>构造函数依赖</li>\n<li>属性依赖</li>\n<li>方法依赖<h1 id=\"14、编写一个C＃程序，该程序接受以千米为单位的距离，将其转换为米，然后显示结果。\"><a href=\"#14、编写一个C＃程序，该程序接受以千米为单位的距离，将其转换为米，然后显示结果。\" class=\"headerlink\" title=\"14、编写一个C＃程序，该程序接受以千米为单位的距离，将其转换为米，然后显示结果。\"></a>14、编写一个C＃程序，该程序接受以千米为单位的距离，将其转换为米，然后显示结果。</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using system; </span><br><span class=\"line\"></span><br><span class=\"line\">class abc   </span><br><span class=\"line\"></span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    public static Void Main()   </span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">            int ndistance, nresult;  </span><br><span class=\"line\">            </span><br><span class=\"line\">        Console.WriteLine(&quot;Enter the distance in kilometers&quot;);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        ndistance = convert.ToInt32(Console.ReadLine());  </span><br><span class=\"line\">        </span><br><span class=\"line\">        nresult = ndistance * 1000;</span><br><span class=\"line\">          </span><br><span class=\"line\">        Console.WriteLine(&quot;Distance in meters: &quot; + nresult);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Console.ReadLine();  </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h1 id=\"15、描述装箱和拆箱。并写一个例子。\"><a href=\"#15、描述装箱和拆箱。并写一个例子。\" class=\"headerlink\" title=\"15、描述装箱和拆箱。并写一个例子。\"></a>15、描述装箱和拆箱。并写一个例子。</h1><p>装箱是将值类型隐式转换为该类型object或该值类型实现的任何接口类型。将值类型装箱会创建一个包含该值的对象实例，并将其存储在堆中。</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int x = 101;</span><br><span class=\"line\">object o = x;  // boxing value of x into object o</span><br><span class=\"line\"></span><br><span class=\"line\">o = 999;</span><br><span class=\"line\">x = (int)o;    // unboxing value of o into integer x</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"最后：\"><a href=\"#最后：\" class=\"headerlink\" title=\"最后：\"></a>最后：</h1><p>面试不仅要基础扎实，更重要的是能解决棘手的技术问题，所以以上这些内容仅供参考。并非每个值得招聘的优秀候选人都能够回答所有问题，也不能确定能够全部回答，就能保证他是一个优秀候选人。归根结底，招聘仍然是一门艺术，一门科学以及许多工作。</p>\n<p>如果你有招聘的要求，也欢迎和我们公众号联系，我们有12万的粉丝，相信能在其中找到适合您公司的 .net 候选人。</p>\n<p>恭喜你！全部看完，看来您高手只有一步之遥，赶紧转发朋友圈吧！让其他.net 新手也来瞻仰瞻仰。 </p>\n"},{"title":".NET中的内存管理","date":"2020-04-06T08:28:00.000Z","author":"邹溪源","_content":"#  .NET中的内存管理\n\n\n **资源分配\n**\nMicrosoft .NET公共语言运行时要求从托管堆分配所有资源。当应用程序不再需要对象时，它们将自动释放。\n\n初始化进程后，运行时将保留地址空间的连续区域，该区域最初没有为其分配存储空间。该地址空间区域是托管堆。堆还维护一个指针。该指针指示下一个对象将在堆中分配的位置。最初，将指针设置为保留地址空间区域的基地址。\n\n应用程序使用new运算符创建一个对象。该运算符首先确保新对象所需的字节适合保留区域（必要时进行存储）。如果对象合适，则指针指向堆中的对象，调用该对象的构造函数，并且new运算符返回该对象的地址。\n\n![Memory3.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory3.gif)\n\n\n上图显示了一个由三个对象组成的托管堆：A，B和C。要分配的下一个对象将放置在NextObjPtr指向的位置（紧随对象C之后）。\n\n当应用程序调用new运算符创建对象时，该区域中可能没有足够的地址空间分配给该对象。堆通过将新对象的大小添加到NextObjPtr来检测到这一点。如果NextObjPtr超出地址空间区域的末尾，则堆已满，必须执行收集。\n\n实际上，当第0代完全填满时发生收集。简而言之，生成是由垃圾收集器实现以提高性能的一种机制。这个想法是，新创建的对象是年轻一代的一部分，而在应用程序生命周期的早期创建的对象是老一代的对象。将对象分成几代可以使垃圾收集器收集特定的世代，而不是收集托管堆中的所有对象。\n\n**垃圾收集算法**\n\n垃圾收集器检查以查看堆中是否有不再由应用程序使用的对象。如果存在此类对象，则可以回收这些对象使用的内存。（如果没有更多的内存可用于堆，则new运算符将引发OutOfMemoryException。）\n\n每个应用程序都有一组根。根标识存储位置，这些存储位置引用托管堆上的对象或设置为null的对象。例如，应用程序中的所有全局和静态对象指针都被视为应用程序根目录的一部分。另外，线程堆栈上的任何局部变量/参数对象指针都被视为应用程序根目录的一部分。最后，任何包含指向托管堆中对象的指针的CPU寄存器也被视为应用程序根目录的一部分。活动根的列表由即时（JIT）编译器和公共语言运行时维护，并且可以由垃圾收集器的算法访问。\n\n当垃圾收集器开始运行时，它假定堆中的所有对象都是垃圾。换句话说，它假定应用程序的任何根都没有引用堆中的任何对象。现在，垃圾收集器开始遍历根目录，并为从根目录可访问的所有对象建立图形。例如，垃圾收集器可以定位一个指向堆中对象的全局变量。\n\n下图显示了具有几个已分配对象的堆，其中应用程序的根直接引用对象A，C，D和F。所有这些对象都成为图形的一部分。在添加对象D时，收集器会注意到该对象引用了对象H，并且对象H也已添加到图中。收集器将继续递归遍历所有可到达的对象。\n\n图的这一部分完成后，垃圾收集器将检查下一个根并再次遍历对象。当垃圾收集器从一个对象移动到另一个对象时，如果它试图将一个对象添加到先前添加的图形中，则垃圾收集器可以停止沿该路径移动。这有两个目的。首先，它不会多次遍历一组对象，因此可以显着提高性能。其次，如果您有任何循环链接的对象列表，它可以防止无限循环。\n\n一旦检查完所有的根，垃圾收集器的图形就会包含从应用程序的根以某种方式可以访问的所有对象的集合。应用程序无法访问该图中未包含的任何对象，因此将其视为垃圾。\n\n垃圾收集器现在线性地遍历堆，寻找垃圾对象的连续块（现在被认为是可用空间）。然后，垃圾收集器将非垃圾对象向下移动到内存中（使用标准的memcpy函数），从而消除了堆中的所有间隙。当然，在内存中移动对象会使指向该对象的所有指针无效。因此，垃圾收集器必须修改应用程序的根，以便指针指向对象的新位置。另外，如果任何对象包含指向另一个对象的指针，则垃圾回收器还负责更正这些指针。\n\n下图显示了收集后的托管堆。\n\n![Memory5.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory5.gif)\n\n在识别完所有垃圾之后，所有非垃圾都已压缩，所有非垃圾指针都已固定，NextObjPtr定位在最后一个非垃圾对象之后。此时，再次尝试新操作，并成功创建应用程序请求的资源。\n\nGC会对性能产生重大影响，这是使用托管堆的主要缺点。但是，请记住，GC仅在堆已满时才发生，并且在此之前，托管堆要比C运行时堆快得多。运行时的垃圾收集器还使用Generations提供了一些优化，可以大大提高垃圾收集的性能。\n\n您不再需要实现管理应用程序使用的任何资源的生存期的任何代码。现在，不可能泄漏资源，因为可以在某个时候收集从应用程序的根目录无法访问的任何资源。此外，也无法访问已释放的资源，因为如果可访问资源将不会被释放。如果无法访问，则您的应用程序无法访问它。\n\n以下代码演示了如何分配和管理资源：\n\n `class Application\n{\npublic static int Main(String[] args)\n{\n// ArrayList object created in heap, myArray is now in root\nArrayList myArray = new ArrayList();\n// Create 10000 objects in the heap\nfor (int x = 0; x < 10000; x++)\n{\nmyArray.Add(new Object()); // Object object created in heap\n}\n// Right now, myArray is a root (on the thread's stack). So,\n// myArray is reachable and the 10000 objects it points to are also reachable.\nConsole.WriteLine(myArray.Count);\n// After the last reference to myArray in the code, myArray is not a root.\n// Note that the method doesn't have to return, the JIT compiler knows\n// to make myArray not a root after the last reference to it in the code.\n// Since myArray is not a root, all 10001 objects are not reachable\n// and are considered garbage. However, the objects are not\n// collected until a GC is performed.\n}\n}`\n\n如果GC非常出色，那么您可能想知道为什么它不在ANSI C ++中。原因是垃圾收集器必须能够标识应用程序的根，还必须能够找到所有对象指针。C ++的问题在于它允许将指针从一种类型转换为另一种类型，并且无法知道指针所指的是什么。在公共语言运行库中，托管堆始终知道对象的实际类型，并且元数据信息用于确定对象的哪些成员引用其他对象。\n\n**世代**\n\n纯粹为了提高性能而存在的垃圾收集器的一个功能称为“世代”。分代垃圾收集器（也称为临时垃圾收集器）进行以下假设：\n\n- 对象越新，其生存期就会越短。\n- 对象越旧，其寿命将越长。\n- 较新的对象往往彼此之间具有很强的关系，并且经常在同一时间访问。\n- 压缩一部分堆比压缩整个堆要快。\n\n初始化后，托管堆不包含任何对象。如下图所示，添加到堆中的对象被称为第0代。简而言之，第0代中的对象是从未被垃圾收集器检查过的年轻对象。\n\n![Memory6.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory6.gif)\n\n现在，如果将更多对象添加到堆中，则将填充堆，并且必须进行垃圾回收。垃圾收集器分析堆时，将构建垃圾（此处以绿色显示）和非垃圾对象的图形。可以将收集到的所有对象压缩到堆的最左侧。这些对象在收藏中幸存下来，并且更旧，现在被认为是第一代。\n\n![Memory7.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory7.gif)\n\n随着更多对象添加到堆中，这些新的年轻对象将放置在第0代中。如果再次填充第0代，则会执行GC。这次，将第1代中幸存的所有对象压缩并视为第2代（请参见下图）。现在压缩了第0代中的所有幸存者，并认为它们是第1代。第0代当前不包含任何对象，但是所有新对象将进入第0代。\n\n![Memory8.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory8.gif)\n\n当前，第二代是运行时的垃圾收集器支持的最高一代。当将来发生收集时，当前第2代中尚存的所有对象仅保留在第2代中。\n\n**世代GC性能优化**\n\n分代垃圾收集提高了性能。当堆填满并发生收集时，垃圾收集器可以选择仅检查第0代中的对象，而忽略任何更大的后代中的对象。毕竟，对象越新，则预期寿命越短。因此，收集和压缩第0代对象很可能会从堆中回收大量空间，并且比收集器检查所有代的对象要快。\n\n分代收集器可以通过不遍历托管堆中的每个对象来提供更多优化。如果根或对象引用的是旧对象，则垃圾收集器可以忽略任何较旧对象的内部引用，从而减少了构建可访问对象图所需的时间。当然，旧对象可能是指新对象。为了检查这些对象，收集器可以利用系统的写监视支持（由Kernel32.dll中的Win32 GetWriteWatch函数提供）。此支持使收集器知道自上次收集以来已将哪些旧对象（如果有）写入了。可以检查这些特定的旧对象的引用，以查看它们是否引用了任何新对象。\n\n如果收集第0代未提供必要的存储量，则收集器可以尝试收集第1代和第0代的对象。如果所有其他操作均失败，则收集器可以收集第2代，第1代和第9代的所有对象。 0。\n\n前面提到的一种假设是，较新的对象之间往往具有很强的关系，并且经常在同一时间访问。由于新对象是在内存中连续分配的，因此您可以从引用的位置获得性能。更具体地说，很可能所有对象都可以驻留在CPU的缓存中。您的应用程序将以惊人的速度访问这些对象，因为CPU将能够执行其大多数操作，而不会导致强制RAM访问的高速缓存未命中。\n\n微软的性能测试表明，托管堆分配比Win32 HeapAlloc函数执行的标准分配更快。这些测试还表明，在200 MHz Pentium上执行第0代完整GC所需的时间少于1毫秒。Microsoft的目标是使GC花费的时间不比普通页面错误多。\n\n**Win32堆的缺点：**\n\n- 大多数堆（例如C运行时堆）在找到可用空间的任何地方分配对象。因此，如果我连续创建多个对象，则这些对象很有可能将被兆字节的地址空间分隔开。但是，在托管堆中，连续分配几个对象可确保对象在内存中是连续的。\n- 从Win32堆分配内存时，必须检查该堆以找到可以满足请求的内存块。这在托管堆中不是必需的，因为此处对象在内存中是连续的。\n- 在Win32堆中，必须维护堆维护的数据结构。另一方面，托管堆仅需要增加堆指针。\n\n**终接器**\n\n垃圾收集器提供了您可能想利用的其他功能：终结处理。最终确定允许资源在被收集后对其进行适当的清理。通过使用终结处理，当垃圾回收器决定释放资源的内存时，代表文件或网络连接的资源便能够正确清理自身。\n\n当垃圾收集器检测到对象是垃圾时，垃圾收集器将调用对象的Finalize方法（如果存在），然后回收该对象的内存。例如，假设您具有以下类型（在C＃中）：\n\n `public class BaseObj`\n`{`\n`public BaseObj()`\n`{`\n`}`\n`protected override void Finalize()`\n`{`\n`// Perform resource cleanup code here`\n`// Example: Close file/Close network connection`\n`Console.WriteLine(\"In Finalize.\");`\n`}`\n`}`\n\n现在，您可以通过调用以下内容来创建该对象的实例：\n\n `BaseObj bo = new BaseObj();` \n\n将来的某个时候，垃圾收集器将确定该对象为垃圾。发生这种情况时，垃圾收集器将看到该类型具有Finalize方法，并将调用该方法，从而使“ In Finalize”出现在控制台窗口中并回收该对象使用的内存块。\n\n许多习惯于使用C ++进行编程的开发人员都会在析构函数和Finalize方法之间建立直接的关联。但是，对象终结处理和析构函数具有非常不同的语义，在考虑终结处理时，最好忘记您对析构函数的了解。受管对象永远不会有析构函数。\n\n设计类型时，最好避免使用Finalize方法。有几个原因：\n\n- 可终结对象被提升为较早的一代，这增加了内存压力，并在垃圾收集器确定对象为垃圾时阻止了对象的内存被收集。此外，该对象直接或间接引用的所有对象也将得到提升。\n\n  \n\n- 可终结对象需要更长的分配时间。\n\n  \n\n- 强制垃圾收集器执行Finalize方法会严重影响性能。请记住，每个对象都已完成。因此，如果我有10,000个对象的数组，则每个对象都必须调用其Finalize方法。\n\n  \n\n- 终结对象可以引用其他（不可终结）对象，从而不必要地延长其寿命。实际上，您可能需要考虑将类型分为两种不同的类型：一种轻型类型，其具有不引用任何其他对象的Finalize方法，一个单独的类型，其类型不具有引用其他对象的Finalize方法。\n\n  \n\n- 您无法控制Finalize方法何时执行。该对象可能会保留资源，直到下一次垃圾收集器运行为止。\n\n  \n\n- 当应用程序终止时，某些对象仍然可以访问，并且不会调用其Finalize方法。如果后台线程正在使用对象，或者在应用程序关闭或AppDomain卸载期间创建了对象，则会发生这种情况。此外，默认情况下，应用程序退出时，不可达对象不会调用Finalize方法，因此应用程序可能会迅速终止。当然，将回收所有操作系统资源，但是托管堆中的任何对象都无法正常清理。您可以通过调用System.GC类型的RequestFinalizeOnShutdown方法来更改此默认行为。但是，应谨慎使用此方法，因为调用它意味着您的类型正在控制整个应用程序的策略。\n\n  \n\n- 运行时无法保证Finalize方法的调用顺序。例如，假设有一个对象包含一个指向内部对象的指针。垃圾收集器检测到两个对象都是垃圾。此外，假设首先调用内部对象的Finalize方法。现在，允许外部对象的Finalize方法访问内部对象并对其调用方法，但是内部对象已完成，并且结果可能无法预测。因此，强烈建议Finalize方法不要访问任何内部成员对象。\n\n如果确定类型必须实现Finalize方法，则请确保代码尽快执行。避免所有会阻止Finalize方法的操作，包括任何线程同步操作。另外，如果您让任何异常转义了Finalize方法，则系统仅假定Finalize方法已返回，并继续调用其他对象的Finalize方法。\n\n当编译器为构造函数生成代码时，编译器会自动插入对基本类型的构造函数的调用。同样，当C ++编译器为析构函数生成代码时，编译器会自动插入对基本类型的析构函数的调用。终结方法不同于析构函数。编译器对Finalize方法没有特殊知识，因此编译器不会自动生成代码以调用基本类型的Finalize方法。如果您想要这种行为，并且经常这样做，那么必须从类型的Finalize方法中显式调用基本类型的Finalize方法：\n\n`public class BaseObj\n{\npublic BaseObj()\n{\n}\nprotected override void Finalize()\n{\nConsole.WriteLine(\"In Finalize.\");\nbase.Finalize(); // Call base type's Finalize\n}\n}`\n\n请注意，通常将基类型的Finalize方法称为派生类型的Finalize方法中的最后一条语句。这样可以使基础对象保持尽可能长的生命。由于调用基本类型的Finalize方法很常见，因此C＃的语法简化了您的工作。在C＃中，以下代码：\n\n\n\n ` class MyObject\n{\nMyObject()\n{\n}\n} `\n\n\n\n**终结内部**\n\n当应用程序创建新对象时，新运算符将从堆中分配内存。如果对象的类型包含Finalize方法，则将指向该对象的指针放在终结队列中。终结队列是由垃圾收集器控制的内部数据结构。队列中的每个条目都指向一个对象，在可以回收该对象的内存之前，应调用该对象的Finalize方法。\n\n下图显示了包含多个对象的堆。从应用程序的根目录可以访问其中的某些对象，而某些则不能。创建对象C，E，F，I和J时，系统检测到这些对象具有Finalize方法，并将指向这些对象的指针添加到了终结队列中。\n\n![Memory9.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory9.gif)\n\n发生GC时，对象B，E，G，H，I和J被确定为垃圾。垃圾收集器扫描完成队列，以查找指向这些对象的指针。当找到一个指针时，该指针将从终结队列中删除，并附加到易碎队列（发音为“ F-reachable”）。易碎队列是由垃圾收集器控制的另一个内部数据结构。易碎队列中的每个指针都标识一个对象，该对象已准备好调用其Finalize方法。\n\n收集之后，托管堆如下图所示。在这里，您看到对象B，G和H占用的内存已被回收，因为这些对象没有需要调用的Finalize方法。但是，无法回收对象E，I和J占用的内存，因为尚未调用它们的Finalize方法。\n\n![Memory10.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory10.gif)\n\n有一个专用的运行时线程专用于调用Finalize方法。当可访问队列为空时（通常是这种情况），该线程进入睡眠状态。但是，当出现条目时，该线程将唤醒，从队列中删除每个条目，并调用每个对象的Finalize方法。因此，您不应在Finalize方法中执行任何有关执行代码的线程的假设的代码。例如，避免在Finalize方法中访问线程本地存储。\n\n终结队列与易碎队列的交互非常有趣。首先，让我告诉您易碎队列的名称。f很明显，代表定稿；易碎队列中的每个条目都应调用其Finalize方法。名称的“可到达”部分表示对象可到达。换句话说，易碎队列被视为根，就像全局变量和静态变量是根一样。因此，如果对象在易碎队列中，则该对象可访问且不是垃圾。\n\n简而言之，当对象不可访问时，垃圾收集器将其视为对象垃圾。然后，当垃圾收集器将对象的条目从终结队列移到可访问队列时，该对象不再被视为垃圾，并且不回收其内存。至此，垃圾收集器已经完成了对垃圾的识别。某些标识为垃圾的对象已被重新分类为非垃圾。垃圾收集器压缩可回收内存，特殊的运行时线程清空易碎队列，执行每个对象的Finalize方法。\n\n![Memory11.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory11.gif)\n\n下次调用垃圾回收器时，它会看到最终对象是真正的垃圾，因为应用程序的根不指向该对象，并且易碎队列不再指向该对象。现在，只需回收该对象的内存即可。这里要了解的重要一点是，需要两个GC来回收需要终结处理的对象使用的内存。实际上，可能需要两个以上的集合，因为这些对象可以提升为较老的一代。上图显示了第二个GC之后托管堆的外观。\n\n**处置方法**\n\n使用此方法可以关闭或释放由实现此接口的类的实例持有的非托管资源，例如文件，流和句柄。按照惯例，此方法用于与释放对象拥有的资源或准备对象重用相关的所有任务。\n\n在实现此方法时，对象必须设法通过在包含层次结构中传播调用来确保释放所有保留的资源。例如，如果对象A分配了对象B，而对象B分配了对象C，则A的Dispose实现必须调用B上的Dispose，后者又必须调用C上的Dispose。对象还必须调用其基类的Dispose方法。如果基类实现IDisposable。\n\n`如果多次调用对象的`Dispose方法，则该对象必须忽略第一个调用之后的所有调用。如果多次调用其Dispose方法，则该对象不得引发异常。如果由于已释放资源并且以前未调用过Dispose而发生错误，则Dispose可能引发异常。\n\n`因为必须显式调用`Dispose方法，所以实现IDisposable的对象还必须实现终结器，以在不调用Dispose时处理释放资源。默认情况下，垃圾回收器将在回收对象的内存之前自动调用其终结器。但是，一旦调用了Dispose方法，垃圾收集器通常就不需要调用已处理对象的终结器。为了防止自动完成，Dispose实现可以调用GC.SuppressFinalize方法。\n\n**通过System.GC直接控制**\n\nSystem.GC类型使您的应用程序可以直接控制垃圾收集器。您可以通过读取GC.MaxGeneration属性来查询托管堆支持的最大生成量。当前，GC.MaxGeneration属性始终返回2。\n\n也可以通过调用此处显示的两个方法之一来强制垃圾收集器执行收集：\n\n` void GC.Collect(Int32 Generation)\nvoid GC.Collect() `\n\n第一种方法允许您指定要收集的世代。您可以将0范围内的任何整数传递给GC.MaxGeneration（含）。传递0导致生成0被收集；传递1导致收集第1代和第0代；传递2会导致生成2、1、0和0。不带参数的Collect方法的版本强制所有世代的完整集合，等效于调用：\n\n`GC.Collect（GC.MaxGeneration）;`\n\nGC类型还提供了WaitForPendingFinalizers方法。此方法只是挂起调用线程，直到处理易碎队列的线程清空了队列，然后调用每个对象的Finalize方法。在大多数应用程序中，您不太可能需要调用此方法。\n\n最后，垃圾收集器提供了两种方法，可让您确定对象当前处于哪个世代：\n\n`Int32 GetGeneration（Object obj）`\n`Int32 GetGeneration（WeakReference wr）`\n\nGetGeneration的第一个版本将对象引用作为参数，而第二个版本将WeakReference引用作为参数。当然，返回的值将介于0到GC.MaxGeneration之间（含）。","source":"_posts/技术/memory-manage-in-c#.md","raw":"---\ntitle: .NET中的内存管理\ndate: 2020-4-6 16:28\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n#  .NET中的内存管理\n\n\n **资源分配\n**\nMicrosoft .NET公共语言运行时要求从托管堆分配所有资源。当应用程序不再需要对象时，它们将自动释放。\n\n初始化进程后，运行时将保留地址空间的连续区域，该区域最初没有为其分配存储空间。该地址空间区域是托管堆。堆还维护一个指针。该指针指示下一个对象将在堆中分配的位置。最初，将指针设置为保留地址空间区域的基地址。\n\n应用程序使用new运算符创建一个对象。该运算符首先确保新对象所需的字节适合保留区域（必要时进行存储）。如果对象合适，则指针指向堆中的对象，调用该对象的构造函数，并且new运算符返回该对象的地址。\n\n![Memory3.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory3.gif)\n\n\n上图显示了一个由三个对象组成的托管堆：A，B和C。要分配的下一个对象将放置在NextObjPtr指向的位置（紧随对象C之后）。\n\n当应用程序调用new运算符创建对象时，该区域中可能没有足够的地址空间分配给该对象。堆通过将新对象的大小添加到NextObjPtr来检测到这一点。如果NextObjPtr超出地址空间区域的末尾，则堆已满，必须执行收集。\n\n实际上，当第0代完全填满时发生收集。简而言之，生成是由垃圾收集器实现以提高性能的一种机制。这个想法是，新创建的对象是年轻一代的一部分，而在应用程序生命周期的早期创建的对象是老一代的对象。将对象分成几代可以使垃圾收集器收集特定的世代，而不是收集托管堆中的所有对象。\n\n**垃圾收集算法**\n\n垃圾收集器检查以查看堆中是否有不再由应用程序使用的对象。如果存在此类对象，则可以回收这些对象使用的内存。（如果没有更多的内存可用于堆，则new运算符将引发OutOfMemoryException。）\n\n每个应用程序都有一组根。根标识存储位置，这些存储位置引用托管堆上的对象或设置为null的对象。例如，应用程序中的所有全局和静态对象指针都被视为应用程序根目录的一部分。另外，线程堆栈上的任何局部变量/参数对象指针都被视为应用程序根目录的一部分。最后，任何包含指向托管堆中对象的指针的CPU寄存器也被视为应用程序根目录的一部分。活动根的列表由即时（JIT）编译器和公共语言运行时维护，并且可以由垃圾收集器的算法访问。\n\n当垃圾收集器开始运行时，它假定堆中的所有对象都是垃圾。换句话说，它假定应用程序的任何根都没有引用堆中的任何对象。现在，垃圾收集器开始遍历根目录，并为从根目录可访问的所有对象建立图形。例如，垃圾收集器可以定位一个指向堆中对象的全局变量。\n\n下图显示了具有几个已分配对象的堆，其中应用程序的根直接引用对象A，C，D和F。所有这些对象都成为图形的一部分。在添加对象D时，收集器会注意到该对象引用了对象H，并且对象H也已添加到图中。收集器将继续递归遍历所有可到达的对象。\n\n图的这一部分完成后，垃圾收集器将检查下一个根并再次遍历对象。当垃圾收集器从一个对象移动到另一个对象时，如果它试图将一个对象添加到先前添加的图形中，则垃圾收集器可以停止沿该路径移动。这有两个目的。首先，它不会多次遍历一组对象，因此可以显着提高性能。其次，如果您有任何循环链接的对象列表，它可以防止无限循环。\n\n一旦检查完所有的根，垃圾收集器的图形就会包含从应用程序的根以某种方式可以访问的所有对象的集合。应用程序无法访问该图中未包含的任何对象，因此将其视为垃圾。\n\n垃圾收集器现在线性地遍历堆，寻找垃圾对象的连续块（现在被认为是可用空间）。然后，垃圾收集器将非垃圾对象向下移动到内存中（使用标准的memcpy函数），从而消除了堆中的所有间隙。当然，在内存中移动对象会使指向该对象的所有指针无效。因此，垃圾收集器必须修改应用程序的根，以便指针指向对象的新位置。另外，如果任何对象包含指向另一个对象的指针，则垃圾回收器还负责更正这些指针。\n\n下图显示了收集后的托管堆。\n\n![Memory5.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory5.gif)\n\n在识别完所有垃圾之后，所有非垃圾都已压缩，所有非垃圾指针都已固定，NextObjPtr定位在最后一个非垃圾对象之后。此时，再次尝试新操作，并成功创建应用程序请求的资源。\n\nGC会对性能产生重大影响，这是使用托管堆的主要缺点。但是，请记住，GC仅在堆已满时才发生，并且在此之前，托管堆要比C运行时堆快得多。运行时的垃圾收集器还使用Generations提供了一些优化，可以大大提高垃圾收集的性能。\n\n您不再需要实现管理应用程序使用的任何资源的生存期的任何代码。现在，不可能泄漏资源，因为可以在某个时候收集从应用程序的根目录无法访问的任何资源。此外，也无法访问已释放的资源，因为如果可访问资源将不会被释放。如果无法访问，则您的应用程序无法访问它。\n\n以下代码演示了如何分配和管理资源：\n\n `class Application\n{\npublic static int Main(String[] args)\n{\n// ArrayList object created in heap, myArray is now in root\nArrayList myArray = new ArrayList();\n// Create 10000 objects in the heap\nfor (int x = 0; x < 10000; x++)\n{\nmyArray.Add(new Object()); // Object object created in heap\n}\n// Right now, myArray is a root (on the thread's stack). So,\n// myArray is reachable and the 10000 objects it points to are also reachable.\nConsole.WriteLine(myArray.Count);\n// After the last reference to myArray in the code, myArray is not a root.\n// Note that the method doesn't have to return, the JIT compiler knows\n// to make myArray not a root after the last reference to it in the code.\n// Since myArray is not a root, all 10001 objects are not reachable\n// and are considered garbage. However, the objects are not\n// collected until a GC is performed.\n}\n}`\n\n如果GC非常出色，那么您可能想知道为什么它不在ANSI C ++中。原因是垃圾收集器必须能够标识应用程序的根，还必须能够找到所有对象指针。C ++的问题在于它允许将指针从一种类型转换为另一种类型，并且无法知道指针所指的是什么。在公共语言运行库中，托管堆始终知道对象的实际类型，并且元数据信息用于确定对象的哪些成员引用其他对象。\n\n**世代**\n\n纯粹为了提高性能而存在的垃圾收集器的一个功能称为“世代”。分代垃圾收集器（也称为临时垃圾收集器）进行以下假设：\n\n- 对象越新，其生存期就会越短。\n- 对象越旧，其寿命将越长。\n- 较新的对象往往彼此之间具有很强的关系，并且经常在同一时间访问。\n- 压缩一部分堆比压缩整个堆要快。\n\n初始化后，托管堆不包含任何对象。如下图所示，添加到堆中的对象被称为第0代。简而言之，第0代中的对象是从未被垃圾收集器检查过的年轻对象。\n\n![Memory6.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory6.gif)\n\n现在，如果将更多对象添加到堆中，则将填充堆，并且必须进行垃圾回收。垃圾收集器分析堆时，将构建垃圾（此处以绿色显示）和非垃圾对象的图形。可以将收集到的所有对象压缩到堆的最左侧。这些对象在收藏中幸存下来，并且更旧，现在被认为是第一代。\n\n![Memory7.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory7.gif)\n\n随着更多对象添加到堆中，这些新的年轻对象将放置在第0代中。如果再次填充第0代，则会执行GC。这次，将第1代中幸存的所有对象压缩并视为第2代（请参见下图）。现在压缩了第0代中的所有幸存者，并认为它们是第1代。第0代当前不包含任何对象，但是所有新对象将进入第0代。\n\n![Memory8.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory8.gif)\n\n当前，第二代是运行时的垃圾收集器支持的最高一代。当将来发生收集时，当前第2代中尚存的所有对象仅保留在第2代中。\n\n**世代GC性能优化**\n\n分代垃圾收集提高了性能。当堆填满并发生收集时，垃圾收集器可以选择仅检查第0代中的对象，而忽略任何更大的后代中的对象。毕竟，对象越新，则预期寿命越短。因此，收集和压缩第0代对象很可能会从堆中回收大量空间，并且比收集器检查所有代的对象要快。\n\n分代收集器可以通过不遍历托管堆中的每个对象来提供更多优化。如果根或对象引用的是旧对象，则垃圾收集器可以忽略任何较旧对象的内部引用，从而减少了构建可访问对象图所需的时间。当然，旧对象可能是指新对象。为了检查这些对象，收集器可以利用系统的写监视支持（由Kernel32.dll中的Win32 GetWriteWatch函数提供）。此支持使收集器知道自上次收集以来已将哪些旧对象（如果有）写入了。可以检查这些特定的旧对象的引用，以查看它们是否引用了任何新对象。\n\n如果收集第0代未提供必要的存储量，则收集器可以尝试收集第1代和第0代的对象。如果所有其他操作均失败，则收集器可以收集第2代，第1代和第9代的所有对象。 0。\n\n前面提到的一种假设是，较新的对象之间往往具有很强的关系，并且经常在同一时间访问。由于新对象是在内存中连续分配的，因此您可以从引用的位置获得性能。更具体地说，很可能所有对象都可以驻留在CPU的缓存中。您的应用程序将以惊人的速度访问这些对象，因为CPU将能够执行其大多数操作，而不会导致强制RAM访问的高速缓存未命中。\n\n微软的性能测试表明，托管堆分配比Win32 HeapAlloc函数执行的标准分配更快。这些测试还表明，在200 MHz Pentium上执行第0代完整GC所需的时间少于1毫秒。Microsoft的目标是使GC花费的时间不比普通页面错误多。\n\n**Win32堆的缺点：**\n\n- 大多数堆（例如C运行时堆）在找到可用空间的任何地方分配对象。因此，如果我连续创建多个对象，则这些对象很有可能将被兆字节的地址空间分隔开。但是，在托管堆中，连续分配几个对象可确保对象在内存中是连续的。\n- 从Win32堆分配内存时，必须检查该堆以找到可以满足请求的内存块。这在托管堆中不是必需的，因为此处对象在内存中是连续的。\n- 在Win32堆中，必须维护堆维护的数据结构。另一方面，托管堆仅需要增加堆指针。\n\n**终接器**\n\n垃圾收集器提供了您可能想利用的其他功能：终结处理。最终确定允许资源在被收集后对其进行适当的清理。通过使用终结处理，当垃圾回收器决定释放资源的内存时，代表文件或网络连接的资源便能够正确清理自身。\n\n当垃圾收集器检测到对象是垃圾时，垃圾收集器将调用对象的Finalize方法（如果存在），然后回收该对象的内存。例如，假设您具有以下类型（在C＃中）：\n\n `public class BaseObj`\n`{`\n`public BaseObj()`\n`{`\n`}`\n`protected override void Finalize()`\n`{`\n`// Perform resource cleanup code here`\n`// Example: Close file/Close network connection`\n`Console.WriteLine(\"In Finalize.\");`\n`}`\n`}`\n\n现在，您可以通过调用以下内容来创建该对象的实例：\n\n `BaseObj bo = new BaseObj();` \n\n将来的某个时候，垃圾收集器将确定该对象为垃圾。发生这种情况时，垃圾收集器将看到该类型具有Finalize方法，并将调用该方法，从而使“ In Finalize”出现在控制台窗口中并回收该对象使用的内存块。\n\n许多习惯于使用C ++进行编程的开发人员都会在析构函数和Finalize方法之间建立直接的关联。但是，对象终结处理和析构函数具有非常不同的语义，在考虑终结处理时，最好忘记您对析构函数的了解。受管对象永远不会有析构函数。\n\n设计类型时，最好避免使用Finalize方法。有几个原因：\n\n- 可终结对象被提升为较早的一代，这增加了内存压力，并在垃圾收集器确定对象为垃圾时阻止了对象的内存被收集。此外，该对象直接或间接引用的所有对象也将得到提升。\n\n  \n\n- 可终结对象需要更长的分配时间。\n\n  \n\n- 强制垃圾收集器执行Finalize方法会严重影响性能。请记住，每个对象都已完成。因此，如果我有10,000个对象的数组，则每个对象都必须调用其Finalize方法。\n\n  \n\n- 终结对象可以引用其他（不可终结）对象，从而不必要地延长其寿命。实际上，您可能需要考虑将类型分为两种不同的类型：一种轻型类型，其具有不引用任何其他对象的Finalize方法，一个单独的类型，其类型不具有引用其他对象的Finalize方法。\n\n  \n\n- 您无法控制Finalize方法何时执行。该对象可能会保留资源，直到下一次垃圾收集器运行为止。\n\n  \n\n- 当应用程序终止时，某些对象仍然可以访问，并且不会调用其Finalize方法。如果后台线程正在使用对象，或者在应用程序关闭或AppDomain卸载期间创建了对象，则会发生这种情况。此外，默认情况下，应用程序退出时，不可达对象不会调用Finalize方法，因此应用程序可能会迅速终止。当然，将回收所有操作系统资源，但是托管堆中的任何对象都无法正常清理。您可以通过调用System.GC类型的RequestFinalizeOnShutdown方法来更改此默认行为。但是，应谨慎使用此方法，因为调用它意味着您的类型正在控制整个应用程序的策略。\n\n  \n\n- 运行时无法保证Finalize方法的调用顺序。例如，假设有一个对象包含一个指向内部对象的指针。垃圾收集器检测到两个对象都是垃圾。此外，假设首先调用内部对象的Finalize方法。现在，允许外部对象的Finalize方法访问内部对象并对其调用方法，但是内部对象已完成，并且结果可能无法预测。因此，强烈建议Finalize方法不要访问任何内部成员对象。\n\n如果确定类型必须实现Finalize方法，则请确保代码尽快执行。避免所有会阻止Finalize方法的操作，包括任何线程同步操作。另外，如果您让任何异常转义了Finalize方法，则系统仅假定Finalize方法已返回，并继续调用其他对象的Finalize方法。\n\n当编译器为构造函数生成代码时，编译器会自动插入对基本类型的构造函数的调用。同样，当C ++编译器为析构函数生成代码时，编译器会自动插入对基本类型的析构函数的调用。终结方法不同于析构函数。编译器对Finalize方法没有特殊知识，因此编译器不会自动生成代码以调用基本类型的Finalize方法。如果您想要这种行为，并且经常这样做，那么必须从类型的Finalize方法中显式调用基本类型的Finalize方法：\n\n`public class BaseObj\n{\npublic BaseObj()\n{\n}\nprotected override void Finalize()\n{\nConsole.WriteLine(\"In Finalize.\");\nbase.Finalize(); // Call base type's Finalize\n}\n}`\n\n请注意，通常将基类型的Finalize方法称为派生类型的Finalize方法中的最后一条语句。这样可以使基础对象保持尽可能长的生命。由于调用基本类型的Finalize方法很常见，因此C＃的语法简化了您的工作。在C＃中，以下代码：\n\n\n\n ` class MyObject\n{\nMyObject()\n{\n}\n} `\n\n\n\n**终结内部**\n\n当应用程序创建新对象时，新运算符将从堆中分配内存。如果对象的类型包含Finalize方法，则将指向该对象的指针放在终结队列中。终结队列是由垃圾收集器控制的内部数据结构。队列中的每个条目都指向一个对象，在可以回收该对象的内存之前，应调用该对象的Finalize方法。\n\n下图显示了包含多个对象的堆。从应用程序的根目录可以访问其中的某些对象，而某些则不能。创建对象C，E，F，I和J时，系统检测到这些对象具有Finalize方法，并将指向这些对象的指针添加到了终结队列中。\n\n![Memory9.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory9.gif)\n\n发生GC时，对象B，E，G，H，I和J被确定为垃圾。垃圾收集器扫描完成队列，以查找指向这些对象的指针。当找到一个指针时，该指针将从终结队列中删除，并附加到易碎队列（发音为“ F-reachable”）。易碎队列是由垃圾收集器控制的另一个内部数据结构。易碎队列中的每个指针都标识一个对象，该对象已准备好调用其Finalize方法。\n\n收集之后，托管堆如下图所示。在这里，您看到对象B，G和H占用的内存已被回收，因为这些对象没有需要调用的Finalize方法。但是，无法回收对象E，I和J占用的内存，因为尚未调用它们的Finalize方法。\n\n![Memory10.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory10.gif)\n\n有一个专用的运行时线程专用于调用Finalize方法。当可访问队列为空时（通常是这种情况），该线程进入睡眠状态。但是，当出现条目时，该线程将唤醒，从队列中删除每个条目，并调用每个对象的Finalize方法。因此，您不应在Finalize方法中执行任何有关执行代码的线程的假设的代码。例如，避免在Finalize方法中访问线程本地存储。\n\n终结队列与易碎队列的交互非常有趣。首先，让我告诉您易碎队列的名称。f很明显，代表定稿；易碎队列中的每个条目都应调用其Finalize方法。名称的“可到达”部分表示对象可到达。换句话说，易碎队列被视为根，就像全局变量和静态变量是根一样。因此，如果对象在易碎队列中，则该对象可访问且不是垃圾。\n\n简而言之，当对象不可访问时，垃圾收集器将其视为对象垃圾。然后，当垃圾收集器将对象的条目从终结队列移到可访问队列时，该对象不再被视为垃圾，并且不回收其内存。至此，垃圾收集器已经完成了对垃圾的识别。某些标识为垃圾的对象已被重新分类为非垃圾。垃圾收集器压缩可回收内存，特殊的运行时线程清空易碎队列，执行每个对象的Finalize方法。\n\n![Memory11.gif](https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory11.gif)\n\n下次调用垃圾回收器时，它会看到最终对象是真正的垃圾，因为应用程序的根不指向该对象，并且易碎队列不再指向该对象。现在，只需回收该对象的内存即可。这里要了解的重要一点是，需要两个GC来回收需要终结处理的对象使用的内存。实际上，可能需要两个以上的集合，因为这些对象可以提升为较老的一代。上图显示了第二个GC之后托管堆的外观。\n\n**处置方法**\n\n使用此方法可以关闭或释放由实现此接口的类的实例持有的非托管资源，例如文件，流和句柄。按照惯例，此方法用于与释放对象拥有的资源或准备对象重用相关的所有任务。\n\n在实现此方法时，对象必须设法通过在包含层次结构中传播调用来确保释放所有保留的资源。例如，如果对象A分配了对象B，而对象B分配了对象C，则A的Dispose实现必须调用B上的Dispose，后者又必须调用C上的Dispose。对象还必须调用其基类的Dispose方法。如果基类实现IDisposable。\n\n`如果多次调用对象的`Dispose方法，则该对象必须忽略第一个调用之后的所有调用。如果多次调用其Dispose方法，则该对象不得引发异常。如果由于已释放资源并且以前未调用过Dispose而发生错误，则Dispose可能引发异常。\n\n`因为必须显式调用`Dispose方法，所以实现IDisposable的对象还必须实现终结器，以在不调用Dispose时处理释放资源。默认情况下，垃圾回收器将在回收对象的内存之前自动调用其终结器。但是，一旦调用了Dispose方法，垃圾收集器通常就不需要调用已处理对象的终结器。为了防止自动完成，Dispose实现可以调用GC.SuppressFinalize方法。\n\n**通过System.GC直接控制**\n\nSystem.GC类型使您的应用程序可以直接控制垃圾收集器。您可以通过读取GC.MaxGeneration属性来查询托管堆支持的最大生成量。当前，GC.MaxGeneration属性始终返回2。\n\n也可以通过调用此处显示的两个方法之一来强制垃圾收集器执行收集：\n\n` void GC.Collect(Int32 Generation)\nvoid GC.Collect() `\n\n第一种方法允许您指定要收集的世代。您可以将0范围内的任何整数传递给GC.MaxGeneration（含）。传递0导致生成0被收集；传递1导致收集第1代和第0代；传递2会导致生成2、1、0和0。不带参数的Collect方法的版本强制所有世代的完整集合，等效于调用：\n\n`GC.Collect（GC.MaxGeneration）;`\n\nGC类型还提供了WaitForPendingFinalizers方法。此方法只是挂起调用线程，直到处理易碎队列的线程清空了队列，然后调用每个对象的Finalize方法。在大多数应用程序中，您不太可能需要调用此方法。\n\n最后，垃圾收集器提供了两种方法，可让您确定对象当前处于哪个世代：\n\n`Int32 GetGeneration（Object obj）`\n`Int32 GetGeneration（WeakReference wr）`\n\nGetGeneration的第一个版本将对象引用作为参数，而第二个版本将WeakReference引用作为参数。当然，返回的值将介于0到GC.MaxGeneration之间（含）。","slug":"技术/memory-manage-in-c#","published":1,"updated":"2020-04-22T15:01:08.246Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt6x000gn4vibro7d6xn","content":"<h1 id=\"NET中的内存管理\"><a href=\"#NET中的内存管理\" class=\"headerlink\" title=\".NET中的内存管理\"></a>.NET中的内存管理</h1><p> *<em>资源分配<br>*</em><br>Microsoft .NET公共语言运行时要求从托管堆分配所有资源。当应用程序不再需要对象时，它们将自动释放。</p>\n<p>初始化进程后，运行时将保留地址空间的连续区域，该区域最初没有为其分配存储空间。该地址空间区域是托管堆。堆还维护一个指针。该指针指示下一个对象将在堆中分配的位置。最初，将指针设置为保留地址空间区域的基地址。</p>\n<p>应用程序使用new运算符创建一个对象。该运算符首先确保新对象所需的字节适合保留区域（必要时进行存储）。如果对象合适，则指针指向堆中的对象，调用该对象的构造函数，并且new运算符返回该对象的地址。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory3.gif\" alt=\"Memory3.gif\"></p>\n<p>上图显示了一个由三个对象组成的托管堆：A，B和C。要分配的下一个对象将放置在NextObjPtr指向的位置（紧随对象C之后）。</p>\n<p>当应用程序调用new运算符创建对象时，该区域中可能没有足够的地址空间分配给该对象。堆通过将新对象的大小添加到NextObjPtr来检测到这一点。如果NextObjPtr超出地址空间区域的末尾，则堆已满，必须执行收集。</p>\n<p>实际上，当第0代完全填满时发生收集。简而言之，生成是由垃圾收集器实现以提高性能的一种机制。这个想法是，新创建的对象是年轻一代的一部分，而在应用程序生命周期的早期创建的对象是老一代的对象。将对象分成几代可以使垃圾收集器收集特定的世代，而不是收集托管堆中的所有对象。</p>\n<p><strong>垃圾收集算法</strong></p>\n<p>垃圾收集器检查以查看堆中是否有不再由应用程序使用的对象。如果存在此类对象，则可以回收这些对象使用的内存。（如果没有更多的内存可用于堆，则new运算符将引发OutOfMemoryException。）</p>\n<p>每个应用程序都有一组根。根标识存储位置，这些存储位置引用托管堆上的对象或设置为null的对象。例如，应用程序中的所有全局和静态对象指针都被视为应用程序根目录的一部分。另外，线程堆栈上的任何局部变量/参数对象指针都被视为应用程序根目录的一部分。最后，任何包含指向托管堆中对象的指针的CPU寄存器也被视为应用程序根目录的一部分。活动根的列表由即时（JIT）编译器和公共语言运行时维护，并且可以由垃圾收集器的算法访问。</p>\n<p>当垃圾收集器开始运行时，它假定堆中的所有对象都是垃圾。换句话说，它假定应用程序的任何根都没有引用堆中的任何对象。现在，垃圾收集器开始遍历根目录，并为从根目录可访问的所有对象建立图形。例如，垃圾收集器可以定位一个指向堆中对象的全局变量。</p>\n<p>下图显示了具有几个已分配对象的堆，其中应用程序的根直接引用对象A，C，D和F。所有这些对象都成为图形的一部分。在添加对象D时，收集器会注意到该对象引用了对象H，并且对象H也已添加到图中。收集器将继续递归遍历所有可到达的对象。</p>\n<p>图的这一部分完成后，垃圾收集器将检查下一个根并再次遍历对象。当垃圾收集器从一个对象移动到另一个对象时，如果它试图将一个对象添加到先前添加的图形中，则垃圾收集器可以停止沿该路径移动。这有两个目的。首先，它不会多次遍历一组对象，因此可以显着提高性能。其次，如果您有任何循环链接的对象列表，它可以防止无限循环。</p>\n<p>一旦检查完所有的根，垃圾收集器的图形就会包含从应用程序的根以某种方式可以访问的所有对象的集合。应用程序无法访问该图中未包含的任何对象，因此将其视为垃圾。</p>\n<p>垃圾收集器现在线性地遍历堆，寻找垃圾对象的连续块（现在被认为是可用空间）。然后，垃圾收集器将非垃圾对象向下移动到内存中（使用标准的memcpy函数），从而消除了堆中的所有间隙。当然，在内存中移动对象会使指向该对象的所有指针无效。因此，垃圾收集器必须修改应用程序的根，以便指针指向对象的新位置。另外，如果任何对象包含指向另一个对象的指针，则垃圾回收器还负责更正这些指针。</p>\n<p>下图显示了收集后的托管堆。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory5.gif\" alt=\"Memory5.gif\"></p>\n<p>在识别完所有垃圾之后，所有非垃圾都已压缩，所有非垃圾指针都已固定，NextObjPtr定位在最后一个非垃圾对象之后。此时，再次尝试新操作，并成功创建应用程序请求的资源。</p>\n<p>GC会对性能产生重大影响，这是使用托管堆的主要缺点。但是，请记住，GC仅在堆已满时才发生，并且在此之前，托管堆要比C运行时堆快得多。运行时的垃圾收集器还使用Generations提供了一些优化，可以大大提高垃圾收集的性能。</p>\n<p>您不再需要实现管理应用程序使用的任何资源的生存期的任何代码。现在，不可能泄漏资源，因为可以在某个时候收集从应用程序的根目录无法访问的任何资源。此外，也无法访问已释放的资源，因为如果可访问资源将不会被释放。如果无法访问，则您的应用程序无法访问它。</p>\n<p>以下代码演示了如何分配和管理资源：</p>\n<p> <code>class Application\n{\npublic static int Main(String[] args)\n{\n// ArrayList object created in heap, myArray is now in root\nArrayList myArray = new ArrayList();\n// Create 10000 objects in the heap\nfor (int x = 0; x &lt; 10000; x++)\n{\nmyArray.Add(new Object()); // Object object created in heap\n}\n// Right now, myArray is a root (on the thread&#39;s stack). So,\n// myArray is reachable and the 10000 objects it points to are also reachable.\nConsole.WriteLine(myArray.Count);\n// After the last reference to myArray in the code, myArray is not a root.\n// Note that the method doesn&#39;t have to return, the JIT compiler knows\n// to make myArray not a root after the last reference to it in the code.\n// Since myArray is not a root, all 10001 objects are not reachable\n// and are considered garbage. However, the objects are not\n// collected until a GC is performed.\n}\n}</code></p>\n<p>如果GC非常出色，那么您可能想知道为什么它不在ANSI C ++中。原因是垃圾收集器必须能够标识应用程序的根，还必须能够找到所有对象指针。C ++的问题在于它允许将指针从一种类型转换为另一种类型，并且无法知道指针所指的是什么。在公共语言运行库中，托管堆始终知道对象的实际类型，并且元数据信息用于确定对象的哪些成员引用其他对象。</p>\n<p><strong>世代</strong></p>\n<p>纯粹为了提高性能而存在的垃圾收集器的一个功能称为“世代”。分代垃圾收集器（也称为临时垃圾收集器）进行以下假设：</p>\n<ul>\n<li>对象越新，其生存期就会越短。</li>\n<li>对象越旧，其寿命将越长。</li>\n<li>较新的对象往往彼此之间具有很强的关系，并且经常在同一时间访问。</li>\n<li>压缩一部分堆比压缩整个堆要快。</li>\n</ul>\n<p>初始化后，托管堆不包含任何对象。如下图所示，添加到堆中的对象被称为第0代。简而言之，第0代中的对象是从未被垃圾收集器检查过的年轻对象。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory6.gif\" alt=\"Memory6.gif\"></p>\n<p>现在，如果将更多对象添加到堆中，则将填充堆，并且必须进行垃圾回收。垃圾收集器分析堆时，将构建垃圾（此处以绿色显示）和非垃圾对象的图形。可以将收集到的所有对象压缩到堆的最左侧。这些对象在收藏中幸存下来，并且更旧，现在被认为是第一代。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory7.gif\" alt=\"Memory7.gif\"></p>\n<p>随着更多对象添加到堆中，这些新的年轻对象将放置在第0代中。如果再次填充第0代，则会执行GC。这次，将第1代中幸存的所有对象压缩并视为第2代（请参见下图）。现在压缩了第0代中的所有幸存者，并认为它们是第1代。第0代当前不包含任何对象，但是所有新对象将进入第0代。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory8.gif\" alt=\"Memory8.gif\"></p>\n<p>当前，第二代是运行时的垃圾收集器支持的最高一代。当将来发生收集时，当前第2代中尚存的所有对象仅保留在第2代中。</p>\n<p><strong>世代GC性能优化</strong></p>\n<p>分代垃圾收集提高了性能。当堆填满并发生收集时，垃圾收集器可以选择仅检查第0代中的对象，而忽略任何更大的后代中的对象。毕竟，对象越新，则预期寿命越短。因此，收集和压缩第0代对象很可能会从堆中回收大量空间，并且比收集器检查所有代的对象要快。</p>\n<p>分代收集器可以通过不遍历托管堆中的每个对象来提供更多优化。如果根或对象引用的是旧对象，则垃圾收集器可以忽略任何较旧对象的内部引用，从而减少了构建可访问对象图所需的时间。当然，旧对象可能是指新对象。为了检查这些对象，收集器可以利用系统的写监视支持（由Kernel32.dll中的Win32 GetWriteWatch函数提供）。此支持使收集器知道自上次收集以来已将哪些旧对象（如果有）写入了。可以检查这些特定的旧对象的引用，以查看它们是否引用了任何新对象。</p>\n<p>如果收集第0代未提供必要的存储量，则收集器可以尝试收集第1代和第0代的对象。如果所有其他操作均失败，则收集器可以收集第2代，第1代和第9代的所有对象。 0。</p>\n<p>前面提到的一种假设是，较新的对象之间往往具有很强的关系，并且经常在同一时间访问。由于新对象是在内存中连续分配的，因此您可以从引用的位置获得性能。更具体地说，很可能所有对象都可以驻留在CPU的缓存中。您的应用程序将以惊人的速度访问这些对象，因为CPU将能够执行其大多数操作，而不会导致强制RAM访问的高速缓存未命中。</p>\n<p>微软的性能测试表明，托管堆分配比Win32 HeapAlloc函数执行的标准分配更快。这些测试还表明，在200 MHz Pentium上执行第0代完整GC所需的时间少于1毫秒。Microsoft的目标是使GC花费的时间不比普通页面错误多。</p>\n<p><strong>Win32堆的缺点：</strong></p>\n<ul>\n<li>大多数堆（例如C运行时堆）在找到可用空间的任何地方分配对象。因此，如果我连续创建多个对象，则这些对象很有可能将被兆字节的地址空间分隔开。但是，在托管堆中，连续分配几个对象可确保对象在内存中是连续的。</li>\n<li>从Win32堆分配内存时，必须检查该堆以找到可以满足请求的内存块。这在托管堆中不是必需的，因为此处对象在内存中是连续的。</li>\n<li>在Win32堆中，必须维护堆维护的数据结构。另一方面，托管堆仅需要增加堆指针。</li>\n</ul>\n<p><strong>终接器</strong></p>\n<p>垃圾收集器提供了您可能想利用的其他功能：终结处理。最终确定允许资源在被收集后对其进行适当的清理。通过使用终结处理，当垃圾回收器决定释放资源的内存时，代表文件或网络连接的资源便能够正确清理自身。</p>\n<p>当垃圾收集器检测到对象是垃圾时，垃圾收集器将调用对象的Finalize方法（如果存在），然后回收该对象的内存。例如，假设您具有以下类型（在C＃中）：</p>\n<p> <code>public class BaseObj</code><br><code>{</code><br><code>public BaseObj()</code><br><code>{</code><br><code>}</code><br><code>protected override void Finalize()</code><br><code>{</code><br><code>// Perform resource cleanup code here</code><br><code>// Example: Close file/Close network connection</code><br><code>Console.WriteLine(&quot;In Finalize.&quot;);</code><br><code>}</code><br><code>}</code></p>\n<p>现在，您可以通过调用以下内容来创建该对象的实例：</p>\n<p> <code>BaseObj bo = new BaseObj();</code> </p>\n<p>将来的某个时候，垃圾收集器将确定该对象为垃圾。发生这种情况时，垃圾收集器将看到该类型具有Finalize方法，并将调用该方法，从而使“ In Finalize”出现在控制台窗口中并回收该对象使用的内存块。</p>\n<p>许多习惯于使用C ++进行编程的开发人员都会在析构函数和Finalize方法之间建立直接的关联。但是，对象终结处理和析构函数具有非常不同的语义，在考虑终结处理时，最好忘记您对析构函数的了解。受管对象永远不会有析构函数。</p>\n<p>设计类型时，最好避免使用Finalize方法。有几个原因：</p>\n<ul>\n<li>可终结对象被提升为较早的一代，这增加了内存压力，并在垃圾收集器确定对象为垃圾时阻止了对象的内存被收集。此外，该对象直接或间接引用的所有对象也将得到提升。</li>\n</ul>\n<ul>\n<li>可终结对象需要更长的分配时间。</li>\n</ul>\n<ul>\n<li>强制垃圾收集器执行Finalize方法会严重影响性能。请记住，每个对象都已完成。因此，如果我有10,000个对象的数组，则每个对象都必须调用其Finalize方法。</li>\n</ul>\n<ul>\n<li>终结对象可以引用其他（不可终结）对象，从而不必要地延长其寿命。实际上，您可能需要考虑将类型分为两种不同的类型：一种轻型类型，其具有不引用任何其他对象的Finalize方法，一个单独的类型，其类型不具有引用其他对象的Finalize方法。</li>\n</ul>\n<ul>\n<li>您无法控制Finalize方法何时执行。该对象可能会保留资源，直到下一次垃圾收集器运行为止。</li>\n</ul>\n<ul>\n<li>当应用程序终止时，某些对象仍然可以访问，并且不会调用其Finalize方法。如果后台线程正在使用对象，或者在应用程序关闭或AppDomain卸载期间创建了对象，则会发生这种情况。此外，默认情况下，应用程序退出时，不可达对象不会调用Finalize方法，因此应用程序可能会迅速终止。当然，将回收所有操作系统资源，但是托管堆中的任何对象都无法正常清理。您可以通过调用System.GC类型的RequestFinalizeOnShutdown方法来更改此默认行为。但是，应谨慎使用此方法，因为调用它意味着您的类型正在控制整个应用程序的策略。</li>\n</ul>\n<ul>\n<li>运行时无法保证Finalize方法的调用顺序。例如，假设有一个对象包含一个指向内部对象的指针。垃圾收集器检测到两个对象都是垃圾。此外，假设首先调用内部对象的Finalize方法。现在，允许外部对象的Finalize方法访问内部对象并对其调用方法，但是内部对象已完成，并且结果可能无法预测。因此，强烈建议Finalize方法不要访问任何内部成员对象。</li>\n</ul>\n<p>如果确定类型必须实现Finalize方法，则请确保代码尽快执行。避免所有会阻止Finalize方法的操作，包括任何线程同步操作。另外，如果您让任何异常转义了Finalize方法，则系统仅假定Finalize方法已返回，并继续调用其他对象的Finalize方法。</p>\n<p>当编译器为构造函数生成代码时，编译器会自动插入对基本类型的构造函数的调用。同样，当C ++编译器为析构函数生成代码时，编译器会自动插入对基本类型的析构函数的调用。终结方法不同于析构函数。编译器对Finalize方法没有特殊知识，因此编译器不会自动生成代码以调用基本类型的Finalize方法。如果您想要这种行为，并且经常这样做，那么必须从类型的Finalize方法中显式调用基本类型的Finalize方法：</p>\n<p><code>public class BaseObj\n{\npublic BaseObj()\n{\n}\nprotected override void Finalize()\n{\nConsole.WriteLine(&quot;In Finalize.&quot;);\nbase.Finalize(); // Call base type&#39;s Finalize\n}\n}</code></p>\n<p>请注意，通常将基类型的Finalize方法称为派生类型的Finalize方法中的最后一条语句。这样可以使基础对象保持尽可能长的生命。由于调用基本类型的Finalize方法很常见，因此C＃的语法简化了您的工作。在C＃中，以下代码：</p>\n<p> <code>class MyObject\n{\nMyObject()\n{\n}\n}</code></p>\n<p><strong>终结内部</strong></p>\n<p>当应用程序创建新对象时，新运算符将从堆中分配内存。如果对象的类型包含Finalize方法，则将指向该对象的指针放在终结队列中。终结队列是由垃圾收集器控制的内部数据结构。队列中的每个条目都指向一个对象，在可以回收该对象的内存之前，应调用该对象的Finalize方法。</p>\n<p>下图显示了包含多个对象的堆。从应用程序的根目录可以访问其中的某些对象，而某些则不能。创建对象C，E，F，I和J时，系统检测到这些对象具有Finalize方法，并将指向这些对象的指针添加到了终结队列中。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory9.gif\" alt=\"Memory9.gif\"></p>\n<p>发生GC时，对象B，E，G，H，I和J被确定为垃圾。垃圾收集器扫描完成队列，以查找指向这些对象的指针。当找到一个指针时，该指针将从终结队列中删除，并附加到易碎队列（发音为“ F-reachable”）。易碎队列是由垃圾收集器控制的另一个内部数据结构。易碎队列中的每个指针都标识一个对象，该对象已准备好调用其Finalize方法。</p>\n<p>收集之后，托管堆如下图所示。在这里，您看到对象B，G和H占用的内存已被回收，因为这些对象没有需要调用的Finalize方法。但是，无法回收对象E，I和J占用的内存，因为尚未调用它们的Finalize方法。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory10.gif\" alt=\"Memory10.gif\"></p>\n<p>有一个专用的运行时线程专用于调用Finalize方法。当可访问队列为空时（通常是这种情况），该线程进入睡眠状态。但是，当出现条目时，该线程将唤醒，从队列中删除每个条目，并调用每个对象的Finalize方法。因此，您不应在Finalize方法中执行任何有关执行代码的线程的假设的代码。例如，避免在Finalize方法中访问线程本地存储。</p>\n<p>终结队列与易碎队列的交互非常有趣。首先，让我告诉您易碎队列的名称。f很明显，代表定稿；易碎队列中的每个条目都应调用其Finalize方法。名称的“可到达”部分表示对象可到达。换句话说，易碎队列被视为根，就像全局变量和静态变量是根一样。因此，如果对象在易碎队列中，则该对象可访问且不是垃圾。</p>\n<p>简而言之，当对象不可访问时，垃圾收集器将其视为对象垃圾。然后，当垃圾收集器将对象的条目从终结队列移到可访问队列时，该对象不再被视为垃圾，并且不回收其内存。至此，垃圾收集器已经完成了对垃圾的识别。某些标识为垃圾的对象已被重新分类为非垃圾。垃圾收集器压缩可回收内存，特殊的运行时线程清空易碎队列，执行每个对象的Finalize方法。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory11.gif\" alt=\"Memory11.gif\"></p>\n<p>下次调用垃圾回收器时，它会看到最终对象是真正的垃圾，因为应用程序的根不指向该对象，并且易碎队列不再指向该对象。现在，只需回收该对象的内存即可。这里要了解的重要一点是，需要两个GC来回收需要终结处理的对象使用的内存。实际上，可能需要两个以上的集合，因为这些对象可以提升为较老的一代。上图显示了第二个GC之后托管堆的外观。</p>\n<p><strong>处置方法</strong></p>\n<p>使用此方法可以关闭或释放由实现此接口的类的实例持有的非托管资源，例如文件，流和句柄。按照惯例，此方法用于与释放对象拥有的资源或准备对象重用相关的所有任务。</p>\n<p>在实现此方法时，对象必须设法通过在包含层次结构中传播调用来确保释放所有保留的资源。例如，如果对象A分配了对象B，而对象B分配了对象C，则A的Dispose实现必须调用B上的Dispose，后者又必须调用C上的Dispose。对象还必须调用其基类的Dispose方法。如果基类实现IDisposable。</p>\n<p><code>如果多次调用对象的</code>Dispose方法，则该对象必须忽略第一个调用之后的所有调用。如果多次调用其Dispose方法，则该对象不得引发异常。如果由于已释放资源并且以前未调用过Dispose而发生错误，则Dispose可能引发异常。</p>\n<p><code>因为必须显式调用</code>Dispose方法，所以实现IDisposable的对象还必须实现终结器，以在不调用Dispose时处理释放资源。默认情况下，垃圾回收器将在回收对象的内存之前自动调用其终结器。但是，一旦调用了Dispose方法，垃圾收集器通常就不需要调用已处理对象的终结器。为了防止自动完成，Dispose实现可以调用GC.SuppressFinalize方法。</p>\n<p><strong>通过System.GC直接控制</strong></p>\n<p>System.GC类型使您的应用程序可以直接控制垃圾收集器。您可以通过读取GC.MaxGeneration属性来查询托管堆支持的最大生成量。当前，GC.MaxGeneration属性始终返回2。</p>\n<p>也可以通过调用此处显示的两个方法之一来强制垃圾收集器执行收集：</p>\n<p><code>void GC.Collect(Int32 Generation)\nvoid GC.Collect()</code></p>\n<p>第一种方法允许您指定要收集的世代。您可以将0范围内的任何整数传递给GC.MaxGeneration（含）。传递0导致生成0被收集；传递1导致收集第1代和第0代；传递2会导致生成2、1、0和0。不带参数的Collect方法的版本强制所有世代的完整集合，等效于调用：</p>\n<p><code>GC.Collect（GC.MaxGeneration）;</code></p>\n<p>GC类型还提供了WaitForPendingFinalizers方法。此方法只是挂起调用线程，直到处理易碎队列的线程清空了队列，然后调用每个对象的Finalize方法。在大多数应用程序中，您不太可能需要调用此方法。</p>\n<p>最后，垃圾收集器提供了两种方法，可让您确定对象当前处于哪个世代：</p>\n<p><code>Int32 GetGeneration（Object obj）</code><br><code>Int32 GetGeneration（WeakReference wr）</code></p>\n<p>GetGeneration的第一个版本将对象引用作为参数，而第二个版本将WeakReference引用作为参数。当然，返回的值将介于0到GC.MaxGeneration之间（含）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"NET中的内存管理\"><a href=\"#NET中的内存管理\" class=\"headerlink\" title=\".NET中的内存管理\"></a>.NET中的内存管理</h1><p> *<em>资源分配<br>*</em><br>Microsoft .NET公共语言运行时要求从托管堆分配所有资源。当应用程序不再需要对象时，它们将自动释放。</p>\n<p>初始化进程后，运行时将保留地址空间的连续区域，该区域最初没有为其分配存储空间。该地址空间区域是托管堆。堆还维护一个指针。该指针指示下一个对象将在堆中分配的位置。最初，将指针设置为保留地址空间区域的基地址。</p>\n<p>应用程序使用new运算符创建一个对象。该运算符首先确保新对象所需的字节适合保留区域（必要时进行存储）。如果对象合适，则指针指向堆中的对象，调用该对象的构造函数，并且new运算符返回该对象的地址。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory3.gif\" alt=\"Memory3.gif\"></p>\n<p>上图显示了一个由三个对象组成的托管堆：A，B和C。要分配的下一个对象将放置在NextObjPtr指向的位置（紧随对象C之后）。</p>\n<p>当应用程序调用new运算符创建对象时，该区域中可能没有足够的地址空间分配给该对象。堆通过将新对象的大小添加到NextObjPtr来检测到这一点。如果NextObjPtr超出地址空间区域的末尾，则堆已满，必须执行收集。</p>\n<p>实际上，当第0代完全填满时发生收集。简而言之，生成是由垃圾收集器实现以提高性能的一种机制。这个想法是，新创建的对象是年轻一代的一部分，而在应用程序生命周期的早期创建的对象是老一代的对象。将对象分成几代可以使垃圾收集器收集特定的世代，而不是收集托管堆中的所有对象。</p>\n<p><strong>垃圾收集算法</strong></p>\n<p>垃圾收集器检查以查看堆中是否有不再由应用程序使用的对象。如果存在此类对象，则可以回收这些对象使用的内存。（如果没有更多的内存可用于堆，则new运算符将引发OutOfMemoryException。）</p>\n<p>每个应用程序都有一组根。根标识存储位置，这些存储位置引用托管堆上的对象或设置为null的对象。例如，应用程序中的所有全局和静态对象指针都被视为应用程序根目录的一部分。另外，线程堆栈上的任何局部变量/参数对象指针都被视为应用程序根目录的一部分。最后，任何包含指向托管堆中对象的指针的CPU寄存器也被视为应用程序根目录的一部分。活动根的列表由即时（JIT）编译器和公共语言运行时维护，并且可以由垃圾收集器的算法访问。</p>\n<p>当垃圾收集器开始运行时，它假定堆中的所有对象都是垃圾。换句话说，它假定应用程序的任何根都没有引用堆中的任何对象。现在，垃圾收集器开始遍历根目录，并为从根目录可访问的所有对象建立图形。例如，垃圾收集器可以定位一个指向堆中对象的全局变量。</p>\n<p>下图显示了具有几个已分配对象的堆，其中应用程序的根直接引用对象A，C，D和F。所有这些对象都成为图形的一部分。在添加对象D时，收集器会注意到该对象引用了对象H，并且对象H也已添加到图中。收集器将继续递归遍历所有可到达的对象。</p>\n<p>图的这一部分完成后，垃圾收集器将检查下一个根并再次遍历对象。当垃圾收集器从一个对象移动到另一个对象时，如果它试图将一个对象添加到先前添加的图形中，则垃圾收集器可以停止沿该路径移动。这有两个目的。首先，它不会多次遍历一组对象，因此可以显着提高性能。其次，如果您有任何循环链接的对象列表，它可以防止无限循环。</p>\n<p>一旦检查完所有的根，垃圾收集器的图形就会包含从应用程序的根以某种方式可以访问的所有对象的集合。应用程序无法访问该图中未包含的任何对象，因此将其视为垃圾。</p>\n<p>垃圾收集器现在线性地遍历堆，寻找垃圾对象的连续块（现在被认为是可用空间）。然后，垃圾收集器将非垃圾对象向下移动到内存中（使用标准的memcpy函数），从而消除了堆中的所有间隙。当然，在内存中移动对象会使指向该对象的所有指针无效。因此，垃圾收集器必须修改应用程序的根，以便指针指向对象的新位置。另外，如果任何对象包含指向另一个对象的指针，则垃圾回收器还负责更正这些指针。</p>\n<p>下图显示了收集后的托管堆。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory5.gif\" alt=\"Memory5.gif\"></p>\n<p>在识别完所有垃圾之后，所有非垃圾都已压缩，所有非垃圾指针都已固定，NextObjPtr定位在最后一个非垃圾对象之后。此时，再次尝试新操作，并成功创建应用程序请求的资源。</p>\n<p>GC会对性能产生重大影响，这是使用托管堆的主要缺点。但是，请记住，GC仅在堆已满时才发生，并且在此之前，托管堆要比C运行时堆快得多。运行时的垃圾收集器还使用Generations提供了一些优化，可以大大提高垃圾收集的性能。</p>\n<p>您不再需要实现管理应用程序使用的任何资源的生存期的任何代码。现在，不可能泄漏资源，因为可以在某个时候收集从应用程序的根目录无法访问的任何资源。此外，也无法访问已释放的资源，因为如果可访问资源将不会被释放。如果无法访问，则您的应用程序无法访问它。</p>\n<p>以下代码演示了如何分配和管理资源：</p>\n<p> <code>class Application\n{\npublic static int Main(String[] args)\n{\n// ArrayList object created in heap, myArray is now in root\nArrayList myArray = new ArrayList();\n// Create 10000 objects in the heap\nfor (int x = 0; x &lt; 10000; x++)\n{\nmyArray.Add(new Object()); // Object object created in heap\n}\n// Right now, myArray is a root (on the thread&#39;s stack). So,\n// myArray is reachable and the 10000 objects it points to are also reachable.\nConsole.WriteLine(myArray.Count);\n// After the last reference to myArray in the code, myArray is not a root.\n// Note that the method doesn&#39;t have to return, the JIT compiler knows\n// to make myArray not a root after the last reference to it in the code.\n// Since myArray is not a root, all 10001 objects are not reachable\n// and are considered garbage. However, the objects are not\n// collected until a GC is performed.\n}\n}</code></p>\n<p>如果GC非常出色，那么您可能想知道为什么它不在ANSI C ++中。原因是垃圾收集器必须能够标识应用程序的根，还必须能够找到所有对象指针。C ++的问题在于它允许将指针从一种类型转换为另一种类型，并且无法知道指针所指的是什么。在公共语言运行库中，托管堆始终知道对象的实际类型，并且元数据信息用于确定对象的哪些成员引用其他对象。</p>\n<p><strong>世代</strong></p>\n<p>纯粹为了提高性能而存在的垃圾收集器的一个功能称为“世代”。分代垃圾收集器（也称为临时垃圾收集器）进行以下假设：</p>\n<ul>\n<li>对象越新，其生存期就会越短。</li>\n<li>对象越旧，其寿命将越长。</li>\n<li>较新的对象往往彼此之间具有很强的关系，并且经常在同一时间访问。</li>\n<li>压缩一部分堆比压缩整个堆要快。</li>\n</ul>\n<p>初始化后，托管堆不包含任何对象。如下图所示，添加到堆中的对象被称为第0代。简而言之，第0代中的对象是从未被垃圾收集器检查过的年轻对象。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory6.gif\" alt=\"Memory6.gif\"></p>\n<p>现在，如果将更多对象添加到堆中，则将填充堆，并且必须进行垃圾回收。垃圾收集器分析堆时，将构建垃圾（此处以绿色显示）和非垃圾对象的图形。可以将收集到的所有对象压缩到堆的最左侧。这些对象在收藏中幸存下来，并且更旧，现在被认为是第一代。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory7.gif\" alt=\"Memory7.gif\"></p>\n<p>随着更多对象添加到堆中，这些新的年轻对象将放置在第0代中。如果再次填充第0代，则会执行GC。这次，将第1代中幸存的所有对象压缩并视为第2代（请参见下图）。现在压缩了第0代中的所有幸存者，并认为它们是第1代。第0代当前不包含任何对象，但是所有新对象将进入第0代。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory8.gif\" alt=\"Memory8.gif\"></p>\n<p>当前，第二代是运行时的垃圾收集器支持的最高一代。当将来发生收集时，当前第2代中尚存的所有对象仅保留在第2代中。</p>\n<p><strong>世代GC性能优化</strong></p>\n<p>分代垃圾收集提高了性能。当堆填满并发生收集时，垃圾收集器可以选择仅检查第0代中的对象，而忽略任何更大的后代中的对象。毕竟，对象越新，则预期寿命越短。因此，收集和压缩第0代对象很可能会从堆中回收大量空间，并且比收集器检查所有代的对象要快。</p>\n<p>分代收集器可以通过不遍历托管堆中的每个对象来提供更多优化。如果根或对象引用的是旧对象，则垃圾收集器可以忽略任何较旧对象的内部引用，从而减少了构建可访问对象图所需的时间。当然，旧对象可能是指新对象。为了检查这些对象，收集器可以利用系统的写监视支持（由Kernel32.dll中的Win32 GetWriteWatch函数提供）。此支持使收集器知道自上次收集以来已将哪些旧对象（如果有）写入了。可以检查这些特定的旧对象的引用，以查看它们是否引用了任何新对象。</p>\n<p>如果收集第0代未提供必要的存储量，则收集器可以尝试收集第1代和第0代的对象。如果所有其他操作均失败，则收集器可以收集第2代，第1代和第9代的所有对象。 0。</p>\n<p>前面提到的一种假设是，较新的对象之间往往具有很强的关系，并且经常在同一时间访问。由于新对象是在内存中连续分配的，因此您可以从引用的位置获得性能。更具体地说，很可能所有对象都可以驻留在CPU的缓存中。您的应用程序将以惊人的速度访问这些对象，因为CPU将能够执行其大多数操作，而不会导致强制RAM访问的高速缓存未命中。</p>\n<p>微软的性能测试表明，托管堆分配比Win32 HeapAlloc函数执行的标准分配更快。这些测试还表明，在200 MHz Pentium上执行第0代完整GC所需的时间少于1毫秒。Microsoft的目标是使GC花费的时间不比普通页面错误多。</p>\n<p><strong>Win32堆的缺点：</strong></p>\n<ul>\n<li>大多数堆（例如C运行时堆）在找到可用空间的任何地方分配对象。因此，如果我连续创建多个对象，则这些对象很有可能将被兆字节的地址空间分隔开。但是，在托管堆中，连续分配几个对象可确保对象在内存中是连续的。</li>\n<li>从Win32堆分配内存时，必须检查该堆以找到可以满足请求的内存块。这在托管堆中不是必需的，因为此处对象在内存中是连续的。</li>\n<li>在Win32堆中，必须维护堆维护的数据结构。另一方面，托管堆仅需要增加堆指针。</li>\n</ul>\n<p><strong>终接器</strong></p>\n<p>垃圾收集器提供了您可能想利用的其他功能：终结处理。最终确定允许资源在被收集后对其进行适当的清理。通过使用终结处理，当垃圾回收器决定释放资源的内存时，代表文件或网络连接的资源便能够正确清理自身。</p>\n<p>当垃圾收集器检测到对象是垃圾时，垃圾收集器将调用对象的Finalize方法（如果存在），然后回收该对象的内存。例如，假设您具有以下类型（在C＃中）：</p>\n<p> <code>public class BaseObj</code><br><code>{</code><br><code>public BaseObj()</code><br><code>{</code><br><code>}</code><br><code>protected override void Finalize()</code><br><code>{</code><br><code>// Perform resource cleanup code here</code><br><code>// Example: Close file/Close network connection</code><br><code>Console.WriteLine(&quot;In Finalize.&quot;);</code><br><code>}</code><br><code>}</code></p>\n<p>现在，您可以通过调用以下内容来创建该对象的实例：</p>\n<p> <code>BaseObj bo = new BaseObj();</code> </p>\n<p>将来的某个时候，垃圾收集器将确定该对象为垃圾。发生这种情况时，垃圾收集器将看到该类型具有Finalize方法，并将调用该方法，从而使“ In Finalize”出现在控制台窗口中并回收该对象使用的内存块。</p>\n<p>许多习惯于使用C ++进行编程的开发人员都会在析构函数和Finalize方法之间建立直接的关联。但是，对象终结处理和析构函数具有非常不同的语义，在考虑终结处理时，最好忘记您对析构函数的了解。受管对象永远不会有析构函数。</p>\n<p>设计类型时，最好避免使用Finalize方法。有几个原因：</p>\n<ul>\n<li>可终结对象被提升为较早的一代，这增加了内存压力，并在垃圾收集器确定对象为垃圾时阻止了对象的内存被收集。此外，该对象直接或间接引用的所有对象也将得到提升。</li>\n</ul>\n<ul>\n<li>可终结对象需要更长的分配时间。</li>\n</ul>\n<ul>\n<li>强制垃圾收集器执行Finalize方法会严重影响性能。请记住，每个对象都已完成。因此，如果我有10,000个对象的数组，则每个对象都必须调用其Finalize方法。</li>\n</ul>\n<ul>\n<li>终结对象可以引用其他（不可终结）对象，从而不必要地延长其寿命。实际上，您可能需要考虑将类型分为两种不同的类型：一种轻型类型，其具有不引用任何其他对象的Finalize方法，一个单独的类型，其类型不具有引用其他对象的Finalize方法。</li>\n</ul>\n<ul>\n<li>您无法控制Finalize方法何时执行。该对象可能会保留资源，直到下一次垃圾收集器运行为止。</li>\n</ul>\n<ul>\n<li>当应用程序终止时，某些对象仍然可以访问，并且不会调用其Finalize方法。如果后台线程正在使用对象，或者在应用程序关闭或AppDomain卸载期间创建了对象，则会发生这种情况。此外，默认情况下，应用程序退出时，不可达对象不会调用Finalize方法，因此应用程序可能会迅速终止。当然，将回收所有操作系统资源，但是托管堆中的任何对象都无法正常清理。您可以通过调用System.GC类型的RequestFinalizeOnShutdown方法来更改此默认行为。但是，应谨慎使用此方法，因为调用它意味着您的类型正在控制整个应用程序的策略。</li>\n</ul>\n<ul>\n<li>运行时无法保证Finalize方法的调用顺序。例如，假设有一个对象包含一个指向内部对象的指针。垃圾收集器检测到两个对象都是垃圾。此外，假设首先调用内部对象的Finalize方法。现在，允许外部对象的Finalize方法访问内部对象并对其调用方法，但是内部对象已完成，并且结果可能无法预测。因此，强烈建议Finalize方法不要访问任何内部成员对象。</li>\n</ul>\n<p>如果确定类型必须实现Finalize方法，则请确保代码尽快执行。避免所有会阻止Finalize方法的操作，包括任何线程同步操作。另外，如果您让任何异常转义了Finalize方法，则系统仅假定Finalize方法已返回，并继续调用其他对象的Finalize方法。</p>\n<p>当编译器为构造函数生成代码时，编译器会自动插入对基本类型的构造函数的调用。同样，当C ++编译器为析构函数生成代码时，编译器会自动插入对基本类型的析构函数的调用。终结方法不同于析构函数。编译器对Finalize方法没有特殊知识，因此编译器不会自动生成代码以调用基本类型的Finalize方法。如果您想要这种行为，并且经常这样做，那么必须从类型的Finalize方法中显式调用基本类型的Finalize方法：</p>\n<p><code>public class BaseObj\n{\npublic BaseObj()\n{\n}\nprotected override void Finalize()\n{\nConsole.WriteLine(&quot;In Finalize.&quot;);\nbase.Finalize(); // Call base type&#39;s Finalize\n}\n}</code></p>\n<p>请注意，通常将基类型的Finalize方法称为派生类型的Finalize方法中的最后一条语句。这样可以使基础对象保持尽可能长的生命。由于调用基本类型的Finalize方法很常见，因此C＃的语法简化了您的工作。在C＃中，以下代码：</p>\n<p> <code>class MyObject\n{\nMyObject()\n{\n}\n}</code></p>\n<p><strong>终结内部</strong></p>\n<p>当应用程序创建新对象时，新运算符将从堆中分配内存。如果对象的类型包含Finalize方法，则将指向该对象的指针放在终结队列中。终结队列是由垃圾收集器控制的内部数据结构。队列中的每个条目都指向一个对象，在可以回收该对象的内存之前，应调用该对象的Finalize方法。</p>\n<p>下图显示了包含多个对象的堆。从应用程序的根目录可以访问其中的某些对象，而某些则不能。创建对象C，E，F，I和J时，系统检测到这些对象具有Finalize方法，并将指向这些对象的指针添加到了终结队列中。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory9.gif\" alt=\"Memory9.gif\"></p>\n<p>发生GC时，对象B，E，G，H，I和J被确定为垃圾。垃圾收集器扫描完成队列，以查找指向这些对象的指针。当找到一个指针时，该指针将从终结队列中删除，并附加到易碎队列（发音为“ F-reachable”）。易碎队列是由垃圾收集器控制的另一个内部数据结构。易碎队列中的每个指针都标识一个对象，该对象已准备好调用其Finalize方法。</p>\n<p>收集之后，托管堆如下图所示。在这里，您看到对象B，G和H占用的内存已被回收，因为这些对象没有需要调用的Finalize方法。但是，无法回收对象E，I和J占用的内存，因为尚未调用它们的Finalize方法。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory10.gif\" alt=\"Memory10.gif\"></p>\n<p>有一个专用的运行时线程专用于调用Finalize方法。当可访问队列为空时（通常是这种情况），该线程进入睡眠状态。但是，当出现条目时，该线程将唤醒，从队列中删除每个条目，并调用每个对象的Finalize方法。因此，您不应在Finalize方法中执行任何有关执行代码的线程的假设的代码。例如，避免在Finalize方法中访问线程本地存储。</p>\n<p>终结队列与易碎队列的交互非常有趣。首先，让我告诉您易碎队列的名称。f很明显，代表定稿；易碎队列中的每个条目都应调用其Finalize方法。名称的“可到达”部分表示对象可到达。换句话说，易碎队列被视为根，就像全局变量和静态变量是根一样。因此，如果对象在易碎队列中，则该对象可访问且不是垃圾。</p>\n<p>简而言之，当对象不可访问时，垃圾收集器将其视为对象垃圾。然后，当垃圾收集器将对象的条目从终结队列移到可访问队列时，该对象不再被视为垃圾，并且不回收其内存。至此，垃圾收集器已经完成了对垃圾的识别。某些标识为垃圾的对象已被重新分类为非垃圾。垃圾收集器压缩可回收内存，特殊的运行时线程清空易碎队列，执行每个对象的Finalize方法。</p>\n<p><img src=\"https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory11.gif\" alt=\"Memory11.gif\"></p>\n<p>下次调用垃圾回收器时，它会看到最终对象是真正的垃圾，因为应用程序的根不指向该对象，并且易碎队列不再指向该对象。现在，只需回收该对象的内存即可。这里要了解的重要一点是，需要两个GC来回收需要终结处理的对象使用的内存。实际上，可能需要两个以上的集合，因为这些对象可以提升为较老的一代。上图显示了第二个GC之后托管堆的外观。</p>\n<p><strong>处置方法</strong></p>\n<p>使用此方法可以关闭或释放由实现此接口的类的实例持有的非托管资源，例如文件，流和句柄。按照惯例，此方法用于与释放对象拥有的资源或准备对象重用相关的所有任务。</p>\n<p>在实现此方法时，对象必须设法通过在包含层次结构中传播调用来确保释放所有保留的资源。例如，如果对象A分配了对象B，而对象B分配了对象C，则A的Dispose实现必须调用B上的Dispose，后者又必须调用C上的Dispose。对象还必须调用其基类的Dispose方法。如果基类实现IDisposable。</p>\n<p><code>如果多次调用对象的</code>Dispose方法，则该对象必须忽略第一个调用之后的所有调用。如果多次调用其Dispose方法，则该对象不得引发异常。如果由于已释放资源并且以前未调用过Dispose而发生错误，则Dispose可能引发异常。</p>\n<p><code>因为必须显式调用</code>Dispose方法，所以实现IDisposable的对象还必须实现终结器，以在不调用Dispose时处理释放资源。默认情况下，垃圾回收器将在回收对象的内存之前自动调用其终结器。但是，一旦调用了Dispose方法，垃圾收集器通常就不需要调用已处理对象的终结器。为了防止自动完成，Dispose实现可以调用GC.SuppressFinalize方法。</p>\n<p><strong>通过System.GC直接控制</strong></p>\n<p>System.GC类型使您的应用程序可以直接控制垃圾收集器。您可以通过读取GC.MaxGeneration属性来查询托管堆支持的最大生成量。当前，GC.MaxGeneration属性始终返回2。</p>\n<p>也可以通过调用此处显示的两个方法之一来强制垃圾收集器执行收集：</p>\n<p><code>void GC.Collect(Int32 Generation)\nvoid GC.Collect()</code></p>\n<p>第一种方法允许您指定要收集的世代。您可以将0范围内的任何整数传递给GC.MaxGeneration（含）。传递0导致生成0被收集；传递1导致收集第1代和第0代；传递2会导致生成2、1、0和0。不带参数的Collect方法的版本强制所有世代的完整集合，等效于调用：</p>\n<p><code>GC.Collect（GC.MaxGeneration）;</code></p>\n<p>GC类型还提供了WaitForPendingFinalizers方法。此方法只是挂起调用线程，直到处理易碎队列的线程清空了队列，然后调用每个对象的Finalize方法。在大多数应用程序中，您不太可能需要调用此方法。</p>\n<p>最后，垃圾收集器提供了两种方法，可让您确定对象当前处于哪个世代：</p>\n<p><code>Int32 GetGeneration（Object obj）</code><br><code>Int32 GetGeneration（WeakReference wr）</code></p>\n<p>GetGeneration的第一个版本将对象引用作为参数，而第二个版本将WeakReference引用作为参数。当然，返回的值将介于0到GC.MaxGeneration之间（含）。</p>\n"},{"title":"C＃编程中最常见的10个错误","date":"2020-03-26T00:55:00.000Z","author":"译者：邹溪源","_content":"原文来自：[https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make](https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make)\n\n帕特里克·赖德（PATRICK RYDER）在Microsoft工作期间帮助创建了VB 1.0和更高版本的.NET平台。自2000年以来，他专注于全栈项目。\n\nC＃是针对Microsoft 公共语言运行库（CLR）的几种语言之一。面向CLR的语言受益于多种功能，例如跨语言集成和异常处理，增强的安全性，简化的组件交互模型以及调试和性能分析服务。在当今的CLR语言中，C＃被广泛用于针对Windows台式机，移动或服务器环境的复杂，专业的开发项目中。(译者注，目前已支持各类跨平台的操作系统环境）\n\nC＃是一种面向对象的强类型语言。在编译和运行时，C＃中严格的类型检查会导致尽早报告大多数典型的C＃编程错误，并准确定位其位置。这可以在C Sharp编程中节省大量时间，相比之下，在更自由地执行类型安全的语言中，跟踪令人困惑的错误的原因可能会在违规操作发生很久之后才发生。但是，许多C＃编码人员无意间（或不小心）放弃了这种检测的好处，这导致了本C＃教程中讨论的一些问题。\n\n## 关于本C Sharp编程教程\n**本教程描述了C＃程序员犯下的10种最常见的C＃编程错误或应避免的问题，并为他们提供了帮助。**\n\n尽管本文中讨论的大多数错误都是C＃特定的，但有些错误也与其他以CLR为目标或使用框架类库（FCL）的语言有关。\n\n## 常见的C＃编程错误＃1：使用值类型与引用相等，或反过来\nC ++和许多其他语言的程序员习惯于控制他们分配给变量的值是简单的值还是对现有对象的引用。但是，在C Sharp编程中，该决定由编写对象的程序员决定，而不是由实例化该对象并将其分配给变量的程序员做出。对于那些试图学习C＃编程的人来说，这是一个常见的“陷阱”。\n\n如果您不知道所使用的对象是值类型还是引用类型，则可能会遇到一些意外。例如：\n\n```\n      Point point1 = new Point(20, 30);\n      Point point2 = point1;\n      point2.X = 50;\n      Console.WriteLine(point1.X);       // 20 (does this surprise you?)\n      Console.WriteLine(point2.X);       // 50\n      \n      Pen pen1 = new Pen(Color.Black);\n      Pen pen2 = pen1;\n      pen2.Color = Color.Blue;\n      Console.WriteLine(pen1.Color);     // Blue (or does this surprise you?)\n      Console.WriteLine(pen2.Color);     // Blue\n```\n正如你所看到的，都Point和Pen对象创建方式不尽相同，但值point1保持不变，当一个新的X坐标值被分配到point2，而价值pen1 *是*当一个新的颜色被分配到修改pen2。因此，我们可以*推断出*，point1并且point2每个Point对象都包含自己的对象副本，而pen1和pen2都包含对同一Pen对象的引用。*但是，如果不进行此实验，我们怎么知道呢？*\n答案是查看对象类型的定义（您可以在Visual Studio中通过将光标置于对象类型的名称上并按F12轻松地完成此操作）：\n\n```\n      public struct Point { ... }     // defines a “value” type\n      public class Pen { ... }        // defines a “reference” type\n```\n如上所示，在C＃编程中，struct关键字用于定义值类型，而class关键字用于定义引用类型。*对于那些具有C ++背景的人，由于C ++和C＃关键字之间的许多相似之处而陷入一种错误的安全感，这种行为可能会让人感到意外，您可能会从C＃教程中寻求帮助。*\n如果您要依赖值和引用类型之间不同的某些行为（例如，将对象作为方法参数传递并让该方法更改对象状态的能力），请确保您正在处理正确的对象类型，以避免C＃编程问题。\n\n## 常见的C＃编程错误＃2：误解了未初始化变量的默认值\n在C＃中，值类型不能为null。根据定义，值类型具有值，甚至值类型的未初始化变量也必须具有值。这称为该类型的默认值。当检查变量是否未初始化时，这会导致以下结果，通常是意外的结果：\n\n```\n      class Program {\n          static Point point1;\n          static Pen pen1;\n          static void Main(string[] args) {\n              Console.WriteLine(pen1 == null);      // True\n              Console.WriteLine(point1 == null);    // False (huh?)\n          }\n      }\n```\n为什么point1不为空？答案是Point是值类型，它的默认值为Point（0,0），而不是null。未能意识到这一点是在C＃中非常容易（也是常见）的错误。\n许多（但不是全部）值类型都有一个IsEmpty属性，您可以检查该属性是否等于其默认值：\n\n```\nConsole.WriteLine(point1.IsEmpty);        // True\n```\n当您检查变量是否已初始化时，请确保您知道该类型的未初始化变量在默认情况下将具有什么值，并且不要依赖于它为null。\n## 常见的C＃编程错误＃3：使用不正确或未指定的字符串比较方法\n比较C＃中的字符串有很多不同的方法。\n\n尽管许多程序员使用==运算符进行字符串比较，但这实际上是最不希望采用的方法之一，主要是因为它没有在代码中明确指定需要哪种类型的比较。\n\n相反，在C＃编程中测试字符串相等性的首选方法是使用以下Equals方法：\n\n      public bool Equals(string value);\n\n      public bool Equals(string value, StringComparison comparisonType);\n\n第一个方法签名（即不带comparisonType参数）实际上与使用==运算符相同，但是具有显式应用于字符串的好处。它执行字符串的序数比较，基本上是逐字节比较。在很多情况下，这正是您想要的比较类型，尤其是在比较以编程方式设置值的字符串（例如文件名，环境变量，属性等）时。在这些情况下，只要序数比较确实是正确的类型这种情况下的比较，使用Equals方法不带 comparisonType参数的唯一缺点是，阅读代码的人可能不知道您要进行哪种类型的比较。\n\n但是，使用Equals每次比较字符串包含comparisonType的方法签名，不仅可以使代码更清晰，还可以使您明确考虑需要进行哪种类型的比较。这是一件值得做的事情，因为即使英语在序数比较和对文化敏感的比较之间不能提供很多差异，其他语言也可以提供很多好处，而忽略其他语言的可能性正在为您提供巨大的潜力错误的道路。例如：\n\n```\n      string s = \"strasse\";\n      \n      // outputs False:\n      Console.WriteLine(s == \"straße\");\n      Console.WriteLine(s.Equals(\"straße\"));\n      Console.WriteLine(s.Equals(\"straße\", StringComparison.Ordinal));\n      Console.WriteLine(s.Equals(\"Straße\", StringComparison.CurrentCulture));        \n      Console.WriteLine(s.Equals(\"straße\", StringComparison.OrdinalIgnoreCase));\n      \n      // outputs True:\n      Console.WriteLine(s.Equals(\"straße\", StringComparison.CurrentCulture));\n      Console.WriteLine(s.Equals(\"Straße\", StringComparison.CurrentCultureIgnoreCase));\n```\n最安全的做法是始终为该Equals方法提供comparisonType参数。以下是一些基本准则：\n* 在比较用户输入的字符串或要显示给用户的字符串时，请使用区分区域性的比较（CurrentCulture或CurrentCultureIgnoreCase）。\n* 比较程序字符串时，请使用序数比较（Ordinal或OrdinalIgnoreCase）。\n* InvariantCulture和InvariantCultureIgnoreCase一般不被除了在非常有限的情况下使用，因为顺序比较是更有效的。如果需要进行文化意识比较，则通常应针对当前文化或其他特定文化进行比较。\n\n除了Equals方法之外，字符串还提供了 Compare方法，该方法为您提供有关字符串相对顺序的信息，而不仅仅是进行相等性测试。此方法是优选的<，<=，>和>=运算符，对于上述的为讨论避免C＃的问题同样的原因。\n\n## 常见的C＃编程错误＃4：使用迭代（而不是声明性）语句来操作集合\n在C＃3.0中，向[语言](http://msdn.microsoft.com/en-us/library/bb308959.aspx)添加[语言集成查询](http://msdn.microsoft.com/en-us/library/bb308959.aspx)（LINQ）永远改变了查询和操作集合的方式。从那时起，如果您使用迭代语句来操作集合，那么您本来应该使用LINQ。\n\n一些C＃程序员甚至不知道LINQ的存在，但是幸运的是，这个数目正在变得越来越小。但是，许多人仍然认为，由于LINQ关键字和SQL语句之间的相似性，它的唯一用途是在查询数据库的代码中。\n\n尽管数据库查询是LINQ语句的一种非常普遍的用法，但它们实际上是在任何可枚举的集合（即，实现IEnumerable接口的任何对象）上工作的。因此，例如，如果您有一个Accounts数组，而不是为每个each编写一个C＃List：\n\n```\n      decimal total = 0;\n      foreach (Account account in myAccounts) {\n        if (account.Status == \"active\") {\n          total += account.Balance;\n        }\n      }\n你可以这样写：\n      decimal total = (from account in myAccounts\n                       where account.Status == \"active\"\n                       select account.Balance).Sum();\n```\n尽管这是一个非常简单的示例，说明如何避免这种常见的C＃编程问题，但在某些情况下，单个LINQ语句可以轻松替换代码中的迭代循环（或嵌套循环）中的数十个语句。更少的通用代码意味着更少的引入错误的机会。但是请记住，在性能方面可能会有所取舍。在对性能有严格要求的情况下，尤其是在迭代代码能够对LINQ无法进行的集合进行假设的情况下，请确保在这两种方法之间进行性能比较。\n## 常见的C＃编程错误＃5：无法考虑LINQ语句中的基础对象\nLINQ非常适合抽象处理集合的任务，无论它们是内存中对象，数据库表还是XML文档。在理想环境中，您不需要知道底层对象是什么。但是这里的错误是假设我们生活在一个完美的世界中。实际上，如果相同的LINQ语句恰好采用不同的格式，则当它们对完全相同的数据执行时，它们可以返回不同的结果。\n\n例如，考虑以下语句：\n\n```\n      decimal total = (from account in myAccounts\n                       where account.Status == \"active\"\n                       select account.Balance).Sum();\n```\n如果对象的其中一个account.Status等于“活动”（请注意大写字母A）会怎样？好吧，如果myAccounts是一个DbSet对象（使用默认的不区分大小写的默认配置设置），则where表达式仍会匹配该元素。但是，如果myAccounts位于内存阵列中，则它将不匹配，因此将产生总计不同的结果。\n等一下 在前面讨论字符串比较时，我们看到==运算符对字符串进行了序数比较。那么，为什么在这种情况下==操作员执行不区分大小写的比较？\n\n*答案是，当LINQ语句中的基础对象是对SQL表数据的引用时（如本示例中的Entity Framework DbSet对象一样），该语句将转换为T-SQL语句。然后，操作员将遵循T-SQL编程规则，而不是C＃编程规则，因此，上述情况下的比较最终不区分大小写。*\n\n通常，即使LINQ是查询对象集合的有用且一致的方式，实际上，您仍然需要知道您的语句是否将转换为C＃以外的其他内容，以确保代码的行为能够在运行时达到预期。\n\n## 常见的C＃编程错误＃6：扩展方法使您感到困惑或冒充\n如前所述，LINQ语句可在实现IEnumerable的任何对象上工作。例如，以下简单功能将在任何帐户集合上累加余额：\n\n```\n      public decimal SumAccounts(IEnumerable<Account> myAccounts) {\n          return myAccounts.Sum(a => a.Balance);\n      }\n```\n在上面的代码中，myAccounts参数的类型声明为 IEnumerable<Account>。由于myAccounts引用Sum方法（C＃使用熟悉的“点符号”来引用类或接口上的方法），因此我们希望看到Sum()在IEnumerable<T>接口定义上调用的方法。但是，定义 IEnumerable<T>未引用任何Sum方法，而只是这样：\n```\n      public interface IEnumerable<out T> : IEnumerable {\n          IEnumerator<T> GetEnumerator();\n      }\n```\n那么该Sum()方法在哪里定义？C＃是强类型的，因此，如果对该Sum方法的引用无效，则C＃编译器肯定会将其标记为错误。因此，我们知道它必须存在，但是在哪里？此外，LINQ为查询或汇总这些集合提供的所有其他方法的定义在哪里？\n答案是这Sum()不是IEnumerable接口上定义的方法 。相反，它是在System.Linq.Enumerable类上定义的静态方法（称为“扩展方法”）：\n\n```\n      namespace System.Linq {\n        public static class Enumerable {\n          ...\n          // the reference here to “this IEnumerable<TSource> source” is\n          // the magic sauce that provides access to the extension method Sum\n          public static decimal Sum<TSource>(this IEnumerable<TSource> source,\n                                             Func<TSource, decimal> selector);\n          ...\n        }\n      }\n```\n那么，什么使扩展方法与任何其他静态方法不同，又使我们能够在其他类中访问它呢？\n扩展方法的显着特征是this其第一个参数上的 修饰符。这是“魔术”，可以将其标识为编译器的扩展方法。它修改的参数的类型（在本例中为IEnumerable<TSource>）表示将要实现此方法的类或接口。\n\n（另一方面，IEnumerable接口名称和Enumerable定义扩展方法的类的名称 之间的相似性并没有什么神奇的。这种相似性只是一个任意的样式选择。）\n\n有了这种理解，我们还可以看到sumAccounts上面介绍的功能可以改为如下实现：\n\n      public decimal SumAccounts(IEnumerable<Account> myAccounts) {\n\n          return Enumerable.Sum(myAccounts, a => a.Balance);\n\n      }\n\n我们本可以以这种方式实现它的事实反而引起了一个问题，为什么根本没有扩展方法？ [扩展方法](http://msdn.microsoft.com/en-us/library/bb383977.aspx)本质上是C＃编程语言的一种便利，它使您可以将方法“添加”到现有类型，而无需创建新的派生类型，重新编译或修改原始类型。\n\n通过using [namespace];在文件顶部包含一条语句，可将扩展方法纳入范围。您需要知道哪个C＃名称空间包含要查找的扩展方法，但是一旦知道要查找的内容，就很容易确定。\n\n当C＃编译器在对象的实例上遇到方法调用，但未找到在引用的对象类上定义的方法时，它将查看范围内的所有扩展方法，以尝试查找与所需方法匹配的扩展方法。签名和类。如果找到一个，它将实例引用作为该扩展方法的第一个参数传递，然后其余参数（如果有）将作为后续参数传递给扩展方法。（如果C＃编译器在范围内找不到任何相应的扩展方法，它将抛出错误。）\n\n扩展方法是C＃编译器中“语法糖”的一个示例，它使我们能够编写（通常）更清晰，更可维护的代码。更清楚的是，如果您知道它们的用法。否则，可能会有些混乱，尤其是在开始时。\n\n尽管使用扩展方法当然具有优势，但它们可能会引起问题，并且对于那些不了解它们或不正确理解它们的开发人员，C＃编程帮助会大声疾呼。当在线查看代码示例或任何其他预先编写的代码时，尤其如此。当此类代码产生编译器错误时（因为它调用的类显然没有定义方法），人们倾向于认为该代码适用于该库的不同版本，或完全适用于不同的库。可能会花费大量时间搜索不存在的新版本或幻影“缺少库”。\n\n当对象上存在具有相同名称的方法时，即使熟悉扩展方法的开发人员仍然偶尔会被捕获，但是其方法签名与扩展方法的方法签名之间存在细微的差异。寻找错别字或错误可能会浪费很多时间。\n\n在C＃库中使用扩展方法变得越来越普遍。除LINQ之外，[Unity Application Block](http://msdn.microsoft.com/en-us/library/ff648512.aspx)和[Web API框架](http://msdn.microsoft.com/en-us/library/hh833994%28v=vs.108%29.aspx)是Microsoft经常使用的两个现代库的示例，它们也使用扩展方法，并且还有许多其他方法。框架越现代，就越有可能包含扩展方法。\n\n当然，您也可以编写自己的扩展方法。请意识到，尽管扩展方法看起来像常规实例方法一样被调用，但这实际上只是一种幻想。特别是，您的扩展方法不能引用它们正在扩展的类的私有成员或受保护成员，因此不能完全替代更传统的类继承。\n\n## 常见的C＃编程错误＃7：为当前任务使用错误的集合类型\nC＃提供了大量的各种对象集合，具有以下仅为部分清单：\n\nArray，ArrayList，BitArray，BitVector32，Dictionary<K,V>，HashTable，HybridDictionary，List<T>，NameValueCollection，OrderedDictionary，Queue, Queue<T>，SortedList，Stack, Stack<T>，StringCollection，StringDictionary。\n\n尽管在某些情况下，太多的选择和不足的选择一样糟糕，但对于集合对象却并非如此。可用的选项数量肯定可以使您受益。预先花一些时间进行研究，然后为您的目的选择最佳的收集类型。这可能会导致更好的性能和更少的错误空间。\n\n如果有一种收集类型专门针对您拥有的元素类型（例如字符串或位），则倾向于首先使用该元素。当针对特定类型的元素时，实现通常会更高效。\n\n为了利用C＃的类型安全性，通常应首选使用通用接口而不是非通用接口。泛型接口的元素是您在声明对象时指定的类型，而非泛型接口的元素则是object类型。使用非泛型接口时，C＃编译器无法对您的代码进行类型检查。同样，在处理原始值类型的集合时，使用非泛型集合将导致这些类型的重复 [装箱/拆箱](http://msdn.microsoft.com/en-us/library/yz2be5wk.aspx)，与适当类型的泛型集合相比，可能会对性能产生重大的负面影响。\n\n另一个常见的C＃问题是编写您自己的集合对象。但这并不是说它永远不合适，但是通过提供.NET提供的广泛选择，您可以通过使用或扩展已经存在的扩展而不是重新发明轮子来节省大量时间。特别是，用于C＃和CLI的C5通用集合库“开箱即用”提供了各种各样的附加集合，例如持久树数据结构，基于堆的优先级队列，哈希索引数组列表，链接列表等等。\n\n## 常见的C＃编程错误＃8：忽略释放资源\nCLR环境使用垃圾回收器，因此您无需显式释放为任何对象创建的内存。实际上，您不能。没有C ++ delete运算符或free()这样的函数。但这并不意味着您在使用完所有对象后就可以忘记所有对象。许多类型的对象封装了其他类型的系统资源（例如，磁盘文件，数据库连接，网络套接字等）。保持这些资源开放状态会迅速耗尽系统资源的总数，从而降低性能并最终导致程序错误。\n\n尽管可以在任何C＃类上定义析构函数方法，但析构函数（在C＃中也称为终结器）存在的问题是，您不确定是否会调用它们。它们在将来的不确定时间内被垃圾收集器调用（在单独的线程上，这可能会导致其他问题）。尝试通过强制使用垃圾回收来克服这些限制 GC.Collect()不是[C＃最佳实践](https://orcharddojo.net/orchard-resources/Library/DevelopmentGuidelines/BestPractices/CSharp)，因为这将在线程收集所有符合收集条件的对象时在未知时间内阻塞线程。\n\n这并不是说终结器没有很好的用途，但是以确定性方式释放资源并不是其中之一。相反，当您在文件，网络或数据库连接上进行操作时，您希望在完成使用后立即显式释放基础资源。\n\n在几乎[所有环境中，](https://www.toptal.com/c-sharp/how-to-make-an-android-and-ios-app-in-c-on-a-mac)资源泄漏都是一个问题。但是，C＃提供了一种健壮且易于使用的机制，如果使用该机制，则使泄漏的情况更加罕见。.NET框架定义了IDisposable仅由Dispose()方法组成的接口 。任何实现的对象都IDisposable希望在对象的使用者完成对它的操作后才调用该方法。这导致显式，确定性的资源释放。\n\n如果要在单个代码块的上下文中创建和处理对象，则忘记调用基本上是不可原谅的 Dispose()，因为C＃提供了一条using语句， Dispose()无论代码块如何退出（无论它是例外，return陈述式，或是干脆关闭区块）。是的，这与using前面提到的语句相同，该语句用于在文件顶部包含C＃名称空间。它有第二个完全不相关的目的，许多C＃开发人员都不知道。即，确保Dispose()在退出代码块时对对象进行调用：\n\n```\n      using (FileStream myFile = File.OpenRead(\"foo.txt\")) {\n        myFile.Read(buffer, 0, 100);\n      }\n```\n通过using 在上面的示例中创建一个块，您可以确定 myFile.Dispose()在处理完文件后立即调用该块，无论是否Read()引发异常。\n## 常见的C＃编程错误＃9：回避异常\nC＃将其类型安全性强制实施到运行时。这使您能够比在C ++等语言中更快地查明C＃中的许多类型的错误，在C＃中错误的类型转换可能导致将任意值分配给对象的字段。但是，程序员再次可以浪费这一强大功能，从而导致C＃问题。之所以陷入这种陷阱，是因为C＃提供了两种不同的处理方式，一种可以引发异常，而另一种则不能。有些人会回避异常路由，认为不必编写try / catch块可以节省一些代码。\n\n例如，以下两种方法可以在C＃中执行显式类型转换：\n\n```\n      // METHOD 1:\n      // Throws an exception if account can't be cast to SavingsAccount\n      SavingsAccount savingsAccount = (SavingsAccount)account;\n      \n      // METHOD 2:\n      // Does NOT throw an exception if account can't be cast to\n      // SavingsAccount; will just set savingsAccount to null instead\n      SavingsAccount savingsAccount = account as SavingsAccount;\n```\n使用方法2可能发生的最明显的错误是无法检查返回值。这可能会导致最终的NullReferenceException，该异常可能会在更晚的时间浮出水面，从而更加难以找到问题的根源。相反，方法1会立即抛出一个 InvalidCastException问题，使问题的根源更加明显。\n而且，即使您记得在方法2中检查过返回值，如果发现它为空，您将怎么办？您编写的方法是否适合报告错误？如果强制转换失败，您还可以尝试其他方法吗？如果不是，那么抛出异常是正确的事，因此您最好让它尽可能地靠近问题的根源。\n\n这是其他两个常见方法对的两个示例，其中一个抛出异常而另一个不抛出异常：\n\n```\n      int.Parse();     // throws exception if argument can’t be parsed\n      int.TryParse();  // returns a bool to denote whether parse succeeded\n      \n      IEnumerable.First();           // throws exception if sequence is empty\n      IEnumerable.FirstOrDefault();  // returns null/default value if sequence is empty\n```\n一些C＃开发人员是如此“异常不利”，以至于他们自动认为不抛出异常的方法是更好的。尽管在某些特定情况下这可能是正确的，但作为概括，它根本不正确。\n作为一个特定的示例，如果您有替代的合法（例如，默认）操作要发生，那么将产生异常，那么非异常方法可能是一个合法的选择。在这种情况下，写这样的东西确实更好：\n\n```\n      if (int.TryParse(myString, out myInt)) {\n        // use myInt\n      } else {\n        // use default value\n      }\n```\n代替：\n```\n      try {\n        myInt = int.Parse(myString);\n        // use myInt\n      } catch (FormatException) {\n        // use default value\n      }\n```\n但是，认为TryParse必然是“更好”的方法是不正确的。有时候是这种情况，有时候不是。这就是为什么有两种方法可以做到这一点。在您所处的环境中使用正确的方法，请记住，作为开发人员，异常肯定可以成为您的朋友。\n## 常见的C＃编程错误＃10：允许编译器警告累积\n尽管此问题绝对不是C＃特有的，但由于放弃了C＃编译器提供的严格类型检查的优点，因此在C＃编程中尤为突出。\n\n产生警告是有原因的。尽管所有C＃编译器错误都表明您的代码有缺陷，但许多警告也是如此。两者的区别在于，在出现警告的情况下，编译器在发出代码所表示的指令时没有问题。即使这样，它也会发现您的代码有些混乱，并且您的代码有可能无法准确反映您的意图。\n\n就本C＃编程教程而言，一个常见的简单示例是，当您修改算法以消除对正在使用的变量的使用时，却忘记了删除变量声明。该程序将完美运行，但编译器将标记无用的变量声明。程序运行完美的事实导致程序员忽略了修复警告原因的方法。此外，编码人员还利用了Visual Studio功能，该功能使他们可以轻松地将警告隐藏在“错误列表”窗口中，从而使他们只能专注于错误。很快就出现了数十种警告，所有这些警告都被幸福地忽略了（或更糟的是隐藏了）。\n\n但是，如果您迟早忽略这种类型的警告，则类似这样的内容很可能会在您的代码中找到：\n\n```\n      class Account {\n      \n          int myId;\n          int Id;   // compiler warned you about this, but you didn’t listen!\n  \n          // Constructor\n          Account(int id) {\n              this.myId = Id;     // OOPS!\n          }\n  \n      }\n```\n而且，以Intellisense允许我们编写代码的速度，此错误并不像看起来那样不可能。\n现在，您的程序中出现了严重错误（尽管出于已经说明的原因，编译器仅将其标记为警告），并且根据程序的复杂程度，您可能会浪费大量时间来跟踪该程序。如果您首先注意了此警告，则只需五秒钟即可解决此问题。\n\n**记住，如果您正在侦听，C Sharp编译器会为您提供有关代码健壮性的许多有用信息。不要忽略警告。**通常，它们只需要花费几秒钟的时间进行修复，而在发生新问题时修复它们可以节省您的时间。训练自己，使Visual Studio“错误列表”窗口显示“ 0错误，0警告”，以便所有警告使您感到不舒服，无法立即解决它们。\n\n当然，每个规则都有例外。因此，有时您的代码对编译器来说似乎有些混乱，即使这正是您的预期。在极少数情况下，请#pragma warning disable [warning id]仅在周围使用触发警告的代码，并仅使用其触发的警告ID。这将取消该警告，并且仅禁止该警告，因此您仍然可以保持警惕以防出现新的警告。\n\n## 结论\nC＃是一种功能强大且灵活的语言，具有许多可以极大地提高生产率的机制和范例。但是，就像使用任何软件工具或语言一样，对其功能的有限了解或欣赏有时可能更多的是障碍而不是收益，可能会导致生产环境代码的问题频发。为此，我们需要更多的了解C#语言中那些常见的错误，并不断的持续优化，确保每一行代码都处于可控的状态。\n\n在你的日常开发过程中，你是否也曾经遇到过这些常见错误？赶紧跟你身边的伙伴一起分享吧~\n\n\n\n","source":"_posts/技术/the-typical-ten-problems-in-c-sharp.md","raw":"---\ntitle:  C＃编程中最常见的10个错误\ndate: 2020-03-26 08:55\ntags: 技术\nauthor:  译者：邹溪源\ncategories:\n  - 技术\n---\n原文来自：[https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make](https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make)\n\n帕特里克·赖德（PATRICK RYDER）在Microsoft工作期间帮助创建了VB 1.0和更高版本的.NET平台。自2000年以来，他专注于全栈项目。\n\nC＃是针对Microsoft 公共语言运行库（CLR）的几种语言之一。面向CLR的语言受益于多种功能，例如跨语言集成和异常处理，增强的安全性，简化的组件交互模型以及调试和性能分析服务。在当今的CLR语言中，C＃被广泛用于针对Windows台式机，移动或服务器环境的复杂，专业的开发项目中。(译者注，目前已支持各类跨平台的操作系统环境）\n\nC＃是一种面向对象的强类型语言。在编译和运行时，C＃中严格的类型检查会导致尽早报告大多数典型的C＃编程错误，并准确定位其位置。这可以在C Sharp编程中节省大量时间，相比之下，在更自由地执行类型安全的语言中，跟踪令人困惑的错误的原因可能会在违规操作发生很久之后才发生。但是，许多C＃编码人员无意间（或不小心）放弃了这种检测的好处，这导致了本C＃教程中讨论的一些问题。\n\n## 关于本C Sharp编程教程\n**本教程描述了C＃程序员犯下的10种最常见的C＃编程错误或应避免的问题，并为他们提供了帮助。**\n\n尽管本文中讨论的大多数错误都是C＃特定的，但有些错误也与其他以CLR为目标或使用框架类库（FCL）的语言有关。\n\n## 常见的C＃编程错误＃1：使用值类型与引用相等，或反过来\nC ++和许多其他语言的程序员习惯于控制他们分配给变量的值是简单的值还是对现有对象的引用。但是，在C Sharp编程中，该决定由编写对象的程序员决定，而不是由实例化该对象并将其分配给变量的程序员做出。对于那些试图学习C＃编程的人来说，这是一个常见的“陷阱”。\n\n如果您不知道所使用的对象是值类型还是引用类型，则可能会遇到一些意外。例如：\n\n```\n      Point point1 = new Point(20, 30);\n      Point point2 = point1;\n      point2.X = 50;\n      Console.WriteLine(point1.X);       // 20 (does this surprise you?)\n      Console.WriteLine(point2.X);       // 50\n      \n      Pen pen1 = new Pen(Color.Black);\n      Pen pen2 = pen1;\n      pen2.Color = Color.Blue;\n      Console.WriteLine(pen1.Color);     // Blue (or does this surprise you?)\n      Console.WriteLine(pen2.Color);     // Blue\n```\n正如你所看到的，都Point和Pen对象创建方式不尽相同，但值point1保持不变，当一个新的X坐标值被分配到point2，而价值pen1 *是*当一个新的颜色被分配到修改pen2。因此，我们可以*推断出*，point1并且point2每个Point对象都包含自己的对象副本，而pen1和pen2都包含对同一Pen对象的引用。*但是，如果不进行此实验，我们怎么知道呢？*\n答案是查看对象类型的定义（您可以在Visual Studio中通过将光标置于对象类型的名称上并按F12轻松地完成此操作）：\n\n```\n      public struct Point { ... }     // defines a “value” type\n      public class Pen { ... }        // defines a “reference” type\n```\n如上所示，在C＃编程中，struct关键字用于定义值类型，而class关键字用于定义引用类型。*对于那些具有C ++背景的人，由于C ++和C＃关键字之间的许多相似之处而陷入一种错误的安全感，这种行为可能会让人感到意外，您可能会从C＃教程中寻求帮助。*\n如果您要依赖值和引用类型之间不同的某些行为（例如，将对象作为方法参数传递并让该方法更改对象状态的能力），请确保您正在处理正确的对象类型，以避免C＃编程问题。\n\n## 常见的C＃编程错误＃2：误解了未初始化变量的默认值\n在C＃中，值类型不能为null。根据定义，值类型具有值，甚至值类型的未初始化变量也必须具有值。这称为该类型的默认值。当检查变量是否未初始化时，这会导致以下结果，通常是意外的结果：\n\n```\n      class Program {\n          static Point point1;\n          static Pen pen1;\n          static void Main(string[] args) {\n              Console.WriteLine(pen1 == null);      // True\n              Console.WriteLine(point1 == null);    // False (huh?)\n          }\n      }\n```\n为什么point1不为空？答案是Point是值类型，它的默认值为Point（0,0），而不是null。未能意识到这一点是在C＃中非常容易（也是常见）的错误。\n许多（但不是全部）值类型都有一个IsEmpty属性，您可以检查该属性是否等于其默认值：\n\n```\nConsole.WriteLine(point1.IsEmpty);        // True\n```\n当您检查变量是否已初始化时，请确保您知道该类型的未初始化变量在默认情况下将具有什么值，并且不要依赖于它为null。\n## 常见的C＃编程错误＃3：使用不正确或未指定的字符串比较方法\n比较C＃中的字符串有很多不同的方法。\n\n尽管许多程序员使用==运算符进行字符串比较，但这实际上是最不希望采用的方法之一，主要是因为它没有在代码中明确指定需要哪种类型的比较。\n\n相反，在C＃编程中测试字符串相等性的首选方法是使用以下Equals方法：\n\n      public bool Equals(string value);\n\n      public bool Equals(string value, StringComparison comparisonType);\n\n第一个方法签名（即不带comparisonType参数）实际上与使用==运算符相同，但是具有显式应用于字符串的好处。它执行字符串的序数比较，基本上是逐字节比较。在很多情况下，这正是您想要的比较类型，尤其是在比较以编程方式设置值的字符串（例如文件名，环境变量，属性等）时。在这些情况下，只要序数比较确实是正确的类型这种情况下的比较，使用Equals方法不带 comparisonType参数的唯一缺点是，阅读代码的人可能不知道您要进行哪种类型的比较。\n\n但是，使用Equals每次比较字符串包含comparisonType的方法签名，不仅可以使代码更清晰，还可以使您明确考虑需要进行哪种类型的比较。这是一件值得做的事情，因为即使英语在序数比较和对文化敏感的比较之间不能提供很多差异，其他语言也可以提供很多好处，而忽略其他语言的可能性正在为您提供巨大的潜力错误的道路。例如：\n\n```\n      string s = \"strasse\";\n      \n      // outputs False:\n      Console.WriteLine(s == \"straße\");\n      Console.WriteLine(s.Equals(\"straße\"));\n      Console.WriteLine(s.Equals(\"straße\", StringComparison.Ordinal));\n      Console.WriteLine(s.Equals(\"Straße\", StringComparison.CurrentCulture));        \n      Console.WriteLine(s.Equals(\"straße\", StringComparison.OrdinalIgnoreCase));\n      \n      // outputs True:\n      Console.WriteLine(s.Equals(\"straße\", StringComparison.CurrentCulture));\n      Console.WriteLine(s.Equals(\"Straße\", StringComparison.CurrentCultureIgnoreCase));\n```\n最安全的做法是始终为该Equals方法提供comparisonType参数。以下是一些基本准则：\n* 在比较用户输入的字符串或要显示给用户的字符串时，请使用区分区域性的比较（CurrentCulture或CurrentCultureIgnoreCase）。\n* 比较程序字符串时，请使用序数比较（Ordinal或OrdinalIgnoreCase）。\n* InvariantCulture和InvariantCultureIgnoreCase一般不被除了在非常有限的情况下使用，因为顺序比较是更有效的。如果需要进行文化意识比较，则通常应针对当前文化或其他特定文化进行比较。\n\n除了Equals方法之外，字符串还提供了 Compare方法，该方法为您提供有关字符串相对顺序的信息，而不仅仅是进行相等性测试。此方法是优选的<，<=，>和>=运算符，对于上述的为讨论避免C＃的问题同样的原因。\n\n## 常见的C＃编程错误＃4：使用迭代（而不是声明性）语句来操作集合\n在C＃3.0中，向[语言](http://msdn.microsoft.com/en-us/library/bb308959.aspx)添加[语言集成查询](http://msdn.microsoft.com/en-us/library/bb308959.aspx)（LINQ）永远改变了查询和操作集合的方式。从那时起，如果您使用迭代语句来操作集合，那么您本来应该使用LINQ。\n\n一些C＃程序员甚至不知道LINQ的存在，但是幸运的是，这个数目正在变得越来越小。但是，许多人仍然认为，由于LINQ关键字和SQL语句之间的相似性，它的唯一用途是在查询数据库的代码中。\n\n尽管数据库查询是LINQ语句的一种非常普遍的用法，但它们实际上是在任何可枚举的集合（即，实现IEnumerable接口的任何对象）上工作的。因此，例如，如果您有一个Accounts数组，而不是为每个each编写一个C＃List：\n\n```\n      decimal total = 0;\n      foreach (Account account in myAccounts) {\n        if (account.Status == \"active\") {\n          total += account.Balance;\n        }\n      }\n你可以这样写：\n      decimal total = (from account in myAccounts\n                       where account.Status == \"active\"\n                       select account.Balance).Sum();\n```\n尽管这是一个非常简单的示例，说明如何避免这种常见的C＃编程问题，但在某些情况下，单个LINQ语句可以轻松替换代码中的迭代循环（或嵌套循环）中的数十个语句。更少的通用代码意味着更少的引入错误的机会。但是请记住，在性能方面可能会有所取舍。在对性能有严格要求的情况下，尤其是在迭代代码能够对LINQ无法进行的集合进行假设的情况下，请确保在这两种方法之间进行性能比较。\n## 常见的C＃编程错误＃5：无法考虑LINQ语句中的基础对象\nLINQ非常适合抽象处理集合的任务，无论它们是内存中对象，数据库表还是XML文档。在理想环境中，您不需要知道底层对象是什么。但是这里的错误是假设我们生活在一个完美的世界中。实际上，如果相同的LINQ语句恰好采用不同的格式，则当它们对完全相同的数据执行时，它们可以返回不同的结果。\n\n例如，考虑以下语句：\n\n```\n      decimal total = (from account in myAccounts\n                       where account.Status == \"active\"\n                       select account.Balance).Sum();\n```\n如果对象的其中一个account.Status等于“活动”（请注意大写字母A）会怎样？好吧，如果myAccounts是一个DbSet对象（使用默认的不区分大小写的默认配置设置），则where表达式仍会匹配该元素。但是，如果myAccounts位于内存阵列中，则它将不匹配，因此将产生总计不同的结果。\n等一下 在前面讨论字符串比较时，我们看到==运算符对字符串进行了序数比较。那么，为什么在这种情况下==操作员执行不区分大小写的比较？\n\n*答案是，当LINQ语句中的基础对象是对SQL表数据的引用时（如本示例中的Entity Framework DbSet对象一样），该语句将转换为T-SQL语句。然后，操作员将遵循T-SQL编程规则，而不是C＃编程规则，因此，上述情况下的比较最终不区分大小写。*\n\n通常，即使LINQ是查询对象集合的有用且一致的方式，实际上，您仍然需要知道您的语句是否将转换为C＃以外的其他内容，以确保代码的行为能够在运行时达到预期。\n\n## 常见的C＃编程错误＃6：扩展方法使您感到困惑或冒充\n如前所述，LINQ语句可在实现IEnumerable的任何对象上工作。例如，以下简单功能将在任何帐户集合上累加余额：\n\n```\n      public decimal SumAccounts(IEnumerable<Account> myAccounts) {\n          return myAccounts.Sum(a => a.Balance);\n      }\n```\n在上面的代码中，myAccounts参数的类型声明为 IEnumerable<Account>。由于myAccounts引用Sum方法（C＃使用熟悉的“点符号”来引用类或接口上的方法），因此我们希望看到Sum()在IEnumerable<T>接口定义上调用的方法。但是，定义 IEnumerable<T>未引用任何Sum方法，而只是这样：\n```\n      public interface IEnumerable<out T> : IEnumerable {\n          IEnumerator<T> GetEnumerator();\n      }\n```\n那么该Sum()方法在哪里定义？C＃是强类型的，因此，如果对该Sum方法的引用无效，则C＃编译器肯定会将其标记为错误。因此，我们知道它必须存在，但是在哪里？此外，LINQ为查询或汇总这些集合提供的所有其他方法的定义在哪里？\n答案是这Sum()不是IEnumerable接口上定义的方法 。相反，它是在System.Linq.Enumerable类上定义的静态方法（称为“扩展方法”）：\n\n```\n      namespace System.Linq {\n        public static class Enumerable {\n          ...\n          // the reference here to “this IEnumerable<TSource> source” is\n          // the magic sauce that provides access to the extension method Sum\n          public static decimal Sum<TSource>(this IEnumerable<TSource> source,\n                                             Func<TSource, decimal> selector);\n          ...\n        }\n      }\n```\n那么，什么使扩展方法与任何其他静态方法不同，又使我们能够在其他类中访问它呢？\n扩展方法的显着特征是this其第一个参数上的 修饰符。这是“魔术”，可以将其标识为编译器的扩展方法。它修改的参数的类型（在本例中为IEnumerable<TSource>）表示将要实现此方法的类或接口。\n\n（另一方面，IEnumerable接口名称和Enumerable定义扩展方法的类的名称 之间的相似性并没有什么神奇的。这种相似性只是一个任意的样式选择。）\n\n有了这种理解，我们还可以看到sumAccounts上面介绍的功能可以改为如下实现：\n\n      public decimal SumAccounts(IEnumerable<Account> myAccounts) {\n\n          return Enumerable.Sum(myAccounts, a => a.Balance);\n\n      }\n\n我们本可以以这种方式实现它的事实反而引起了一个问题，为什么根本没有扩展方法？ [扩展方法](http://msdn.microsoft.com/en-us/library/bb383977.aspx)本质上是C＃编程语言的一种便利，它使您可以将方法“添加”到现有类型，而无需创建新的派生类型，重新编译或修改原始类型。\n\n通过using [namespace];在文件顶部包含一条语句，可将扩展方法纳入范围。您需要知道哪个C＃名称空间包含要查找的扩展方法，但是一旦知道要查找的内容，就很容易确定。\n\n当C＃编译器在对象的实例上遇到方法调用，但未找到在引用的对象类上定义的方法时，它将查看范围内的所有扩展方法，以尝试查找与所需方法匹配的扩展方法。签名和类。如果找到一个，它将实例引用作为该扩展方法的第一个参数传递，然后其余参数（如果有）将作为后续参数传递给扩展方法。（如果C＃编译器在范围内找不到任何相应的扩展方法，它将抛出错误。）\n\n扩展方法是C＃编译器中“语法糖”的一个示例，它使我们能够编写（通常）更清晰，更可维护的代码。更清楚的是，如果您知道它们的用法。否则，可能会有些混乱，尤其是在开始时。\n\n尽管使用扩展方法当然具有优势，但它们可能会引起问题，并且对于那些不了解它们或不正确理解它们的开发人员，C＃编程帮助会大声疾呼。当在线查看代码示例或任何其他预先编写的代码时，尤其如此。当此类代码产生编译器错误时（因为它调用的类显然没有定义方法），人们倾向于认为该代码适用于该库的不同版本，或完全适用于不同的库。可能会花费大量时间搜索不存在的新版本或幻影“缺少库”。\n\n当对象上存在具有相同名称的方法时，即使熟悉扩展方法的开发人员仍然偶尔会被捕获，但是其方法签名与扩展方法的方法签名之间存在细微的差异。寻找错别字或错误可能会浪费很多时间。\n\n在C＃库中使用扩展方法变得越来越普遍。除LINQ之外，[Unity Application Block](http://msdn.microsoft.com/en-us/library/ff648512.aspx)和[Web API框架](http://msdn.microsoft.com/en-us/library/hh833994%28v=vs.108%29.aspx)是Microsoft经常使用的两个现代库的示例，它们也使用扩展方法，并且还有许多其他方法。框架越现代，就越有可能包含扩展方法。\n\n当然，您也可以编写自己的扩展方法。请意识到，尽管扩展方法看起来像常规实例方法一样被调用，但这实际上只是一种幻想。特别是，您的扩展方法不能引用它们正在扩展的类的私有成员或受保护成员，因此不能完全替代更传统的类继承。\n\n## 常见的C＃编程错误＃7：为当前任务使用错误的集合类型\nC＃提供了大量的各种对象集合，具有以下仅为部分清单：\n\nArray，ArrayList，BitArray，BitVector32，Dictionary<K,V>，HashTable，HybridDictionary，List<T>，NameValueCollection，OrderedDictionary，Queue, Queue<T>，SortedList，Stack, Stack<T>，StringCollection，StringDictionary。\n\n尽管在某些情况下，太多的选择和不足的选择一样糟糕，但对于集合对象却并非如此。可用的选项数量肯定可以使您受益。预先花一些时间进行研究，然后为您的目的选择最佳的收集类型。这可能会导致更好的性能和更少的错误空间。\n\n如果有一种收集类型专门针对您拥有的元素类型（例如字符串或位），则倾向于首先使用该元素。当针对特定类型的元素时，实现通常会更高效。\n\n为了利用C＃的类型安全性，通常应首选使用通用接口而不是非通用接口。泛型接口的元素是您在声明对象时指定的类型，而非泛型接口的元素则是object类型。使用非泛型接口时，C＃编译器无法对您的代码进行类型检查。同样，在处理原始值类型的集合时，使用非泛型集合将导致这些类型的重复 [装箱/拆箱](http://msdn.microsoft.com/en-us/library/yz2be5wk.aspx)，与适当类型的泛型集合相比，可能会对性能产生重大的负面影响。\n\n另一个常见的C＃问题是编写您自己的集合对象。但这并不是说它永远不合适，但是通过提供.NET提供的广泛选择，您可以通过使用或扩展已经存在的扩展而不是重新发明轮子来节省大量时间。特别是，用于C＃和CLI的C5通用集合库“开箱即用”提供了各种各样的附加集合，例如持久树数据结构，基于堆的优先级队列，哈希索引数组列表，链接列表等等。\n\n## 常见的C＃编程错误＃8：忽略释放资源\nCLR环境使用垃圾回收器，因此您无需显式释放为任何对象创建的内存。实际上，您不能。没有C ++ delete运算符或free()这样的函数。但这并不意味着您在使用完所有对象后就可以忘记所有对象。许多类型的对象封装了其他类型的系统资源（例如，磁盘文件，数据库连接，网络套接字等）。保持这些资源开放状态会迅速耗尽系统资源的总数，从而降低性能并最终导致程序错误。\n\n尽管可以在任何C＃类上定义析构函数方法，但析构函数（在C＃中也称为终结器）存在的问题是，您不确定是否会调用它们。它们在将来的不确定时间内被垃圾收集器调用（在单独的线程上，这可能会导致其他问题）。尝试通过强制使用垃圾回收来克服这些限制 GC.Collect()不是[C＃最佳实践](https://orcharddojo.net/orchard-resources/Library/DevelopmentGuidelines/BestPractices/CSharp)，因为这将在线程收集所有符合收集条件的对象时在未知时间内阻塞线程。\n\n这并不是说终结器没有很好的用途，但是以确定性方式释放资源并不是其中之一。相反，当您在文件，网络或数据库连接上进行操作时，您希望在完成使用后立即显式释放基础资源。\n\n在几乎[所有环境中，](https://www.toptal.com/c-sharp/how-to-make-an-android-and-ios-app-in-c-on-a-mac)资源泄漏都是一个问题。但是，C＃提供了一种健壮且易于使用的机制，如果使用该机制，则使泄漏的情况更加罕见。.NET框架定义了IDisposable仅由Dispose()方法组成的接口 。任何实现的对象都IDisposable希望在对象的使用者完成对它的操作后才调用该方法。这导致显式，确定性的资源释放。\n\n如果要在单个代码块的上下文中创建和处理对象，则忘记调用基本上是不可原谅的 Dispose()，因为C＃提供了一条using语句， Dispose()无论代码块如何退出（无论它是例外，return陈述式，或是干脆关闭区块）。是的，这与using前面提到的语句相同，该语句用于在文件顶部包含C＃名称空间。它有第二个完全不相关的目的，许多C＃开发人员都不知道。即，确保Dispose()在退出代码块时对对象进行调用：\n\n```\n      using (FileStream myFile = File.OpenRead(\"foo.txt\")) {\n        myFile.Read(buffer, 0, 100);\n      }\n```\n通过using 在上面的示例中创建一个块，您可以确定 myFile.Dispose()在处理完文件后立即调用该块，无论是否Read()引发异常。\n## 常见的C＃编程错误＃9：回避异常\nC＃将其类型安全性强制实施到运行时。这使您能够比在C ++等语言中更快地查明C＃中的许多类型的错误，在C＃中错误的类型转换可能导致将任意值分配给对象的字段。但是，程序员再次可以浪费这一强大功能，从而导致C＃问题。之所以陷入这种陷阱，是因为C＃提供了两种不同的处理方式，一种可以引发异常，而另一种则不能。有些人会回避异常路由，认为不必编写try / catch块可以节省一些代码。\n\n例如，以下两种方法可以在C＃中执行显式类型转换：\n\n```\n      // METHOD 1:\n      // Throws an exception if account can't be cast to SavingsAccount\n      SavingsAccount savingsAccount = (SavingsAccount)account;\n      \n      // METHOD 2:\n      // Does NOT throw an exception if account can't be cast to\n      // SavingsAccount; will just set savingsAccount to null instead\n      SavingsAccount savingsAccount = account as SavingsAccount;\n```\n使用方法2可能发生的最明显的错误是无法检查返回值。这可能会导致最终的NullReferenceException，该异常可能会在更晚的时间浮出水面，从而更加难以找到问题的根源。相反，方法1会立即抛出一个 InvalidCastException问题，使问题的根源更加明显。\n而且，即使您记得在方法2中检查过返回值，如果发现它为空，您将怎么办？您编写的方法是否适合报告错误？如果强制转换失败，您还可以尝试其他方法吗？如果不是，那么抛出异常是正确的事，因此您最好让它尽可能地靠近问题的根源。\n\n这是其他两个常见方法对的两个示例，其中一个抛出异常而另一个不抛出异常：\n\n```\n      int.Parse();     // throws exception if argument can’t be parsed\n      int.TryParse();  // returns a bool to denote whether parse succeeded\n      \n      IEnumerable.First();           // throws exception if sequence is empty\n      IEnumerable.FirstOrDefault();  // returns null/default value if sequence is empty\n```\n一些C＃开发人员是如此“异常不利”，以至于他们自动认为不抛出异常的方法是更好的。尽管在某些特定情况下这可能是正确的，但作为概括，它根本不正确。\n作为一个特定的示例，如果您有替代的合法（例如，默认）操作要发生，那么将产生异常，那么非异常方法可能是一个合法的选择。在这种情况下，写这样的东西确实更好：\n\n```\n      if (int.TryParse(myString, out myInt)) {\n        // use myInt\n      } else {\n        // use default value\n      }\n```\n代替：\n```\n      try {\n        myInt = int.Parse(myString);\n        // use myInt\n      } catch (FormatException) {\n        // use default value\n      }\n```\n但是，认为TryParse必然是“更好”的方法是不正确的。有时候是这种情况，有时候不是。这就是为什么有两种方法可以做到这一点。在您所处的环境中使用正确的方法，请记住，作为开发人员，异常肯定可以成为您的朋友。\n## 常见的C＃编程错误＃10：允许编译器警告累积\n尽管此问题绝对不是C＃特有的，但由于放弃了C＃编译器提供的严格类型检查的优点，因此在C＃编程中尤为突出。\n\n产生警告是有原因的。尽管所有C＃编译器错误都表明您的代码有缺陷，但许多警告也是如此。两者的区别在于，在出现警告的情况下，编译器在发出代码所表示的指令时没有问题。即使这样，它也会发现您的代码有些混乱，并且您的代码有可能无法准确反映您的意图。\n\n就本C＃编程教程而言，一个常见的简单示例是，当您修改算法以消除对正在使用的变量的使用时，却忘记了删除变量声明。该程序将完美运行，但编译器将标记无用的变量声明。程序运行完美的事实导致程序员忽略了修复警告原因的方法。此外，编码人员还利用了Visual Studio功能，该功能使他们可以轻松地将警告隐藏在“错误列表”窗口中，从而使他们只能专注于错误。很快就出现了数十种警告，所有这些警告都被幸福地忽略了（或更糟的是隐藏了）。\n\n但是，如果您迟早忽略这种类型的警告，则类似这样的内容很可能会在您的代码中找到：\n\n```\n      class Account {\n      \n          int myId;\n          int Id;   // compiler warned you about this, but you didn’t listen!\n  \n          // Constructor\n          Account(int id) {\n              this.myId = Id;     // OOPS!\n          }\n  \n      }\n```\n而且，以Intellisense允许我们编写代码的速度，此错误并不像看起来那样不可能。\n现在，您的程序中出现了严重错误（尽管出于已经说明的原因，编译器仅将其标记为警告），并且根据程序的复杂程度，您可能会浪费大量时间来跟踪该程序。如果您首先注意了此警告，则只需五秒钟即可解决此问题。\n\n**记住，如果您正在侦听，C Sharp编译器会为您提供有关代码健壮性的许多有用信息。不要忽略警告。**通常，它们只需要花费几秒钟的时间进行修复，而在发生新问题时修复它们可以节省您的时间。训练自己，使Visual Studio“错误列表”窗口显示“ 0错误，0警告”，以便所有警告使您感到不舒服，无法立即解决它们。\n\n当然，每个规则都有例外。因此，有时您的代码对编译器来说似乎有些混乱，即使这正是您的预期。在极少数情况下，请#pragma warning disable [warning id]仅在周围使用触发警告的代码，并仅使用其触发的警告ID。这将取消该警告，并且仅禁止该警告，因此您仍然可以保持警惕以防出现新的警告。\n\n## 结论\nC＃是一种功能强大且灵活的语言，具有许多可以极大地提高生产率的机制和范例。但是，就像使用任何软件工具或语言一样，对其功能的有限了解或欣赏有时可能更多的是障碍而不是收益，可能会导致生产环境代码的问题频发。为此，我们需要更多的了解C#语言中那些常见的错误，并不断的持续优化，确保每一行代码都处于可控的状态。\n\n在你的日常开发过程中，你是否也曾经遇到过这些常见错误？赶紧跟你身边的伙伴一起分享吧~\n\n\n\n","slug":"技术/the-typical-ten-problems-in-c-sharp","published":1,"updated":"2020-03-26T00:55:50.603Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt70000jn4viwmch7wlh","content":"<p>原文来自：<a href=\"https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make\" target=\"_blank\" rel=\"noopener\">https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make</a></p>\n<p>帕特里克·赖德（PATRICK RYDER）在Microsoft工作期间帮助创建了VB 1.0和更高版本的.NET平台。自2000年以来，他专注于全栈项目。</p>\n<p>C＃是针对Microsoft 公共语言运行库（CLR）的几种语言之一。面向CLR的语言受益于多种功能，例如跨语言集成和异常处理，增强的安全性，简化的组件交互模型以及调试和性能分析服务。在当今的CLR语言中，C＃被广泛用于针对Windows台式机，移动或服务器环境的复杂，专业的开发项目中。(译者注，目前已支持各类跨平台的操作系统环境）</p>\n<p>C＃是一种面向对象的强类型语言。在编译和运行时，C＃中严格的类型检查会导致尽早报告大多数典型的C＃编程错误，并准确定位其位置。这可以在C Sharp编程中节省大量时间，相比之下，在更自由地执行类型安全的语言中，跟踪令人困惑的错误的原因可能会在违规操作发生很久之后才发生。但是，许多C＃编码人员无意间（或不小心）放弃了这种检测的好处，这导致了本C＃教程中讨论的一些问题。</p>\n<h2 id=\"关于本C-Sharp编程教程\"><a href=\"#关于本C-Sharp编程教程\" class=\"headerlink\" title=\"关于本C Sharp编程教程\"></a>关于本C Sharp编程教程</h2><p><strong>本教程描述了C＃程序员犯下的10种最常见的C＃编程错误或应避免的问题，并为他们提供了帮助。</strong></p>\n<p>尽管本文中讨论的大多数错误都是C＃特定的，但有些错误也与其他以CLR为目标或使用框架类库（FCL）的语言有关。</p>\n<h2 id=\"常见的C＃编程错误＃1：使用值类型与引用相等，或反过来\"><a href=\"#常见的C＃编程错误＃1：使用值类型与引用相等，或反过来\" class=\"headerlink\" title=\"常见的C＃编程错误＃1：使用值类型与引用相等，或反过来\"></a>常见的C＃编程错误＃1：使用值类型与引用相等，或反过来</h2><p>C ++和许多其他语言的程序员习惯于控制他们分配给变量的值是简单的值还是对现有对象的引用。但是，在C Sharp编程中，该决定由编写对象的程序员决定，而不是由实例化该对象并将其分配给变量的程序员做出。对于那些试图学习C＃编程的人来说，这是一个常见的“陷阱”。</p>\n<p>如果您不知道所使用的对象是值类型还是引用类型，则可能会遇到一些意外。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point point1 = new Point(20, 30);</span><br><span class=\"line\">Point point2 = point1;</span><br><span class=\"line\">point2.X = 50;</span><br><span class=\"line\">Console.WriteLine(point1.X);       // 20 (does this surprise you?)</span><br><span class=\"line\">Console.WriteLine(point2.X);       // 50</span><br><span class=\"line\"></span><br><span class=\"line\">Pen pen1 = new Pen(Color.Black);</span><br><span class=\"line\">Pen pen2 = pen1;</span><br><span class=\"line\">pen2.Color = Color.Blue;</span><br><span class=\"line\">Console.WriteLine(pen1.Color);     // Blue (or does this surprise you?)</span><br><span class=\"line\">Console.WriteLine(pen2.Color);     // Blue</span><br></pre></td></tr></table></figure>\n\n<p>正如你所看到的，都Point和Pen对象创建方式不尽相同，但值point1保持不变，当一个新的X坐标值被分配到point2，而价值pen1 <em>是</em>当一个新的颜色被分配到修改pen2。因此，我们可以<em>推断出<em>，point1并且point2每个Point对象都包含自己的对象副本，而pen1和pen2都包含对同一Pen对象的引用。</em>但是，如果不进行此实验，我们怎么知道呢？</em><br>答案是查看对象类型的定义（您可以在Visual Studio中通过将光标置于对象类型的名称上并按F12轻松地完成此操作）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public struct Point &#123; ... &#125;     // defines a “value” type</span><br><span class=\"line\">public class Pen &#123; ... &#125;        // defines a “reference” type</span><br></pre></td></tr></table></figure>\n\n<p>如上所示，在C＃编程中，struct关键字用于定义值类型，而class关键字用于定义引用类型。<em>对于那些具有C ++背景的人，由于C ++和C＃关键字之间的许多相似之处而陷入一种错误的安全感，这种行为可能会让人感到意外，您可能会从C＃教程中寻求帮助。</em><br>如果您要依赖值和引用类型之间不同的某些行为（例如，将对象作为方法参数传递并让该方法更改对象状态的能力），请确保您正在处理正确的对象类型，以避免C＃编程问题。</p>\n<h2 id=\"常见的C＃编程错误＃2：误解了未初始化变量的默认值\"><a href=\"#常见的C＃编程错误＃2：误解了未初始化变量的默认值\" class=\"headerlink\" title=\"常见的C＃编程错误＃2：误解了未初始化变量的默认值\"></a>常见的C＃编程错误＃2：误解了未初始化变量的默认值</h2><p>在C＃中，值类型不能为null。根据定义，值类型具有值，甚至值类型的未初始化变量也必须具有值。这称为该类型的默认值。当检查变量是否未初始化时，这会导致以下结果，通常是意外的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Program &#123;</span><br><span class=\"line\">    static Point point1;</span><br><span class=\"line\">    static Pen pen1;</span><br><span class=\"line\">    static void Main(string[] args) &#123;</span><br><span class=\"line\">        Console.WriteLine(pen1 == null);      // True</span><br><span class=\"line\">        Console.WriteLine(point1 == null);    // False (huh?)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么point1不为空？答案是Point是值类型，它的默认值为Point（0,0），而不是null。未能意识到这一点是在C＃中非常容易（也是常见）的错误。<br>许多（但不是全部）值类型都有一个IsEmpty属性，您可以检查该属性是否等于其默认值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Console.WriteLine(point1.IsEmpty);        // True</span><br></pre></td></tr></table></figure>\n\n<p>当您检查变量是否已初始化时，请确保您知道该类型的未初始化变量在默认情况下将具有什么值，并且不要依赖于它为null。</p>\n<h2 id=\"常见的C＃编程错误＃3：使用不正确或未指定的字符串比较方法\"><a href=\"#常见的C＃编程错误＃3：使用不正确或未指定的字符串比较方法\" class=\"headerlink\" title=\"常见的C＃编程错误＃3：使用不正确或未指定的字符串比较方法\"></a>常见的C＃编程错误＃3：使用不正确或未指定的字符串比较方法</h2><p>比较C＃中的字符串有很多不同的方法。</p>\n<p>尽管许多程序员使用==运算符进行字符串比较，但这实际上是最不希望采用的方法之一，主要是因为它没有在代码中明确指定需要哪种类型的比较。</p>\n<p>相反，在C＃编程中测试字符串相等性的首选方法是使用以下Equals方法：</p>\n<pre><code>public bool Equals(string value);\n\npublic bool Equals(string value, StringComparison comparisonType);</code></pre><p>第一个方法签名（即不带comparisonType参数）实际上与使用==运算符相同，但是具有显式应用于字符串的好处。它执行字符串的序数比较，基本上是逐字节比较。在很多情况下，这正是您想要的比较类型，尤其是在比较以编程方式设置值的字符串（例如文件名，环境变量，属性等）时。在这些情况下，只要序数比较确实是正确的类型这种情况下的比较，使用Equals方法不带 comparisonType参数的唯一缺点是，阅读代码的人可能不知道您要进行哪种类型的比较。</p>\n<p>但是，使用Equals每次比较字符串包含comparisonType的方法签名，不仅可以使代码更清晰，还可以使您明确考虑需要进行哪种类型的比较。这是一件值得做的事情，因为即使英语在序数比较和对文化敏感的比较之间不能提供很多差异，其他语言也可以提供很多好处，而忽略其他语言的可能性正在为您提供巨大的潜力错误的道路。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s = &quot;strasse&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// outputs False:</span><br><span class=\"line\">Console.WriteLine(s == &quot;straße&quot;);</span><br><span class=\"line\">Console.WriteLine(s.Equals(&quot;straße&quot;));</span><br><span class=\"line\">Console.WriteLine(s.Equals(&quot;straße&quot;, StringComparison.Ordinal));</span><br><span class=\"line\">Console.WriteLine(s.Equals(&quot;Straße&quot;, StringComparison.CurrentCulture));        </span><br><span class=\"line\">Console.WriteLine(s.Equals(&quot;straße&quot;, StringComparison.OrdinalIgnoreCase));</span><br><span class=\"line\"></span><br><span class=\"line\">// outputs True:</span><br><span class=\"line\">Console.WriteLine(s.Equals(&quot;straße&quot;, StringComparison.CurrentCulture));</span><br><span class=\"line\">Console.WriteLine(s.Equals(&quot;Straße&quot;, StringComparison.CurrentCultureIgnoreCase));</span><br></pre></td></tr></table></figure>\n\n<p>最安全的做法是始终为该Equals方法提供comparisonType参数。以下是一些基本准则：</p>\n<ul>\n<li>在比较用户输入的字符串或要显示给用户的字符串时，请使用区分区域性的比较（CurrentCulture或CurrentCultureIgnoreCase）。</li>\n<li>比较程序字符串时，请使用序数比较（Ordinal或OrdinalIgnoreCase）。</li>\n<li>InvariantCulture和InvariantCultureIgnoreCase一般不被除了在非常有限的情况下使用，因为顺序比较是更有效的。如果需要进行文化意识比较，则通常应针对当前文化或其他特定文化进行比较。</li>\n</ul>\n<p>除了Equals方法之外，字符串还提供了 Compare方法，该方法为您提供有关字符串相对顺序的信息，而不仅仅是进行相等性测试。此方法是优选的&lt;，&lt;=，&gt;和&gt;=运算符，对于上述的为讨论避免C＃的问题同样的原因。</p>\n<h2 id=\"常见的C＃编程错误＃4：使用迭代（而不是声明性）语句来操作集合\"><a href=\"#常见的C＃编程错误＃4：使用迭代（而不是声明性）语句来操作集合\" class=\"headerlink\" title=\"常见的C＃编程错误＃4：使用迭代（而不是声明性）语句来操作集合\"></a>常见的C＃编程错误＃4：使用迭代（而不是声明性）语句来操作集合</h2><p>在C＃3.0中，向<a href=\"http://msdn.microsoft.com/en-us/library/bb308959.aspx\" target=\"_blank\" rel=\"noopener\">语言</a>添加<a href=\"http://msdn.microsoft.com/en-us/library/bb308959.aspx\" target=\"_blank\" rel=\"noopener\">语言集成查询</a>（LINQ）永远改变了查询和操作集合的方式。从那时起，如果您使用迭代语句来操作集合，那么您本来应该使用LINQ。</p>\n<p>一些C＃程序员甚至不知道LINQ的存在，但是幸运的是，这个数目正在变得越来越小。但是，许多人仍然认为，由于LINQ关键字和SQL语句之间的相似性，它的唯一用途是在查询数据库的代码中。</p>\n<p>尽管数据库查询是LINQ语句的一种非常普遍的用法，但它们实际上是在任何可枚举的集合（即，实现IEnumerable接口的任何对象）上工作的。因此，例如，如果您有一个Accounts数组，而不是为每个each编写一个C＃List：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      decimal total = 0;</span><br><span class=\"line\">      foreach (Account account in myAccounts) &#123;</span><br><span class=\"line\">        if (account.Status == &quot;active&quot;) &#123;</span><br><span class=\"line\">          total += account.Balance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">你可以这样写：</span><br><span class=\"line\">      decimal total = (from account in myAccounts</span><br><span class=\"line\">                       where account.Status == &quot;active&quot;</span><br><span class=\"line\">                       select account.Balance).Sum();</span><br></pre></td></tr></table></figure>\n\n<p>尽管这是一个非常简单的示例，说明如何避免这种常见的C＃编程问题，但在某些情况下，单个LINQ语句可以轻松替换代码中的迭代循环（或嵌套循环）中的数十个语句。更少的通用代码意味着更少的引入错误的机会。但是请记住，在性能方面可能会有所取舍。在对性能有严格要求的情况下，尤其是在迭代代码能够对LINQ无法进行的集合进行假设的情况下，请确保在这两种方法之间进行性能比较。</p>\n<h2 id=\"常见的C＃编程错误＃5：无法考虑LINQ语句中的基础对象\"><a href=\"#常见的C＃编程错误＃5：无法考虑LINQ语句中的基础对象\" class=\"headerlink\" title=\"常见的C＃编程错误＃5：无法考虑LINQ语句中的基础对象\"></a>常见的C＃编程错误＃5：无法考虑LINQ语句中的基础对象</h2><p>LINQ非常适合抽象处理集合的任务，无论它们是内存中对象，数据库表还是XML文档。在理想环境中，您不需要知道底层对象是什么。但是这里的错误是假设我们生活在一个完美的世界中。实际上，如果相同的LINQ语句恰好采用不同的格式，则当它们对完全相同的数据执行时，它们可以返回不同的结果。</p>\n<p>例如，考虑以下语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">decimal total = (from account in myAccounts</span><br><span class=\"line\">                 where account.Status == &quot;active&quot;</span><br><span class=\"line\">                 select account.Balance).Sum();</span><br></pre></td></tr></table></figure>\n\n<p>如果对象的其中一个account.Status等于“活动”（请注意大写字母A）会怎样？好吧，如果myAccounts是一个DbSet对象（使用默认的不区分大小写的默认配置设置），则where表达式仍会匹配该元素。但是，如果myAccounts位于内存阵列中，则它将不匹配，因此将产生总计不同的结果。<br>等一下 在前面讨论字符串比较时，我们看到==运算符对字符串进行了序数比较。那么，为什么在这种情况下==操作员执行不区分大小写的比较？</p>\n<p><em>答案是，当LINQ语句中的基础对象是对SQL表数据的引用时（如本示例中的Entity Framework DbSet对象一样），该语句将转换为T-SQL语句。然后，操作员将遵循T-SQL编程规则，而不是C＃编程规则，因此，上述情况下的比较最终不区分大小写。</em></p>\n<p>通常，即使LINQ是查询对象集合的有用且一致的方式，实际上，您仍然需要知道您的语句是否将转换为C＃以外的其他内容，以确保代码的行为能够在运行时达到预期。</p>\n<h2 id=\"常见的C＃编程错误＃6：扩展方法使您感到困惑或冒充\"><a href=\"#常见的C＃编程错误＃6：扩展方法使您感到困惑或冒充\" class=\"headerlink\" title=\"常见的C＃编程错误＃6：扩展方法使您感到困惑或冒充\"></a>常见的C＃编程错误＃6：扩展方法使您感到困惑或冒充</h2><p>如前所述，LINQ语句可在实现IEnumerable的任何对象上工作。例如，以下简单功能将在任何帐户集合上累加余额：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public decimal SumAccounts(IEnumerable&lt;Account&gt; myAccounts) &#123;</span><br><span class=\"line\">    return myAccounts.Sum(a =&gt; a.Balance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，myAccounts参数的类型声明为 IEnumerable<account>。由于myAccounts引用Sum方法（C＃使用熟悉的“点符号”来引用类或接口上的方法），因此我们希望看到Sum()在IEnumerable<t>接口定义上调用的方法。但是，定义 IEnumerable<t>未引用任何Sum方法，而只是这样：</t></t></account></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface IEnumerable&lt;out T&gt; : IEnumerable &#123;</span><br><span class=\"line\">    IEnumerator&lt;T&gt; GetEnumerator();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么该Sum()方法在哪里定义？C＃是强类型的，因此，如果对该Sum方法的引用无效，则C＃编译器肯定会将其标记为错误。因此，我们知道它必须存在，但是在哪里？此外，LINQ为查询或汇总这些集合提供的所有其他方法的定义在哪里？<br>答案是这Sum()不是IEnumerable接口上定义的方法 。相反，它是在System.Linq.Enumerable类上定义的静态方法（称为“扩展方法”）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace System.Linq &#123;</span><br><span class=\"line\">  public static class Enumerable &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    // the reference here to “this IEnumerable&lt;TSource&gt; source” is</span><br><span class=\"line\">    // the magic sauce that provides access to the extension method Sum</span><br><span class=\"line\">    public static decimal Sum&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source,</span><br><span class=\"line\">                                       Func&lt;TSource, decimal&gt; selector);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，什么使扩展方法与任何其他静态方法不同，又使我们能够在其他类中访问它呢？<br>扩展方法的显着特征是this其第一个参数上的 修饰符。这是“魔术”，可以将其标识为编译器的扩展方法。它修改的参数的类型（在本例中为IEnumerable<tsource>）表示将要实现此方法的类或接口。</tsource></p>\n<p>（另一方面，IEnumerable接口名称和Enumerable定义扩展方法的类的名称 之间的相似性并没有什么神奇的。这种相似性只是一个任意的样式选择。）</p>\n<p>有了这种理解，我们还可以看到sumAccounts上面介绍的功能可以改为如下实现：</p>\n<pre><code>public decimal SumAccounts(IEnumerable&lt;Account&gt; myAccounts) {\n\n    return Enumerable.Sum(myAccounts, a =&gt; a.Balance);\n\n}</code></pre><p>我们本可以以这种方式实现它的事实反而引起了一个问题，为什么根本没有扩展方法？ <a href=\"http://msdn.microsoft.com/en-us/library/bb383977.aspx\" target=\"_blank\" rel=\"noopener\">扩展方法</a>本质上是C＃编程语言的一种便利，它使您可以将方法“添加”到现有类型，而无需创建新的派生类型，重新编译或修改原始类型。</p>\n<p>通过using [namespace];在文件顶部包含一条语句，可将扩展方法纳入范围。您需要知道哪个C＃名称空间包含要查找的扩展方法，但是一旦知道要查找的内容，就很容易确定。</p>\n<p>当C＃编译器在对象的实例上遇到方法调用，但未找到在引用的对象类上定义的方法时，它将查看范围内的所有扩展方法，以尝试查找与所需方法匹配的扩展方法。签名和类。如果找到一个，它将实例引用作为该扩展方法的第一个参数传递，然后其余参数（如果有）将作为后续参数传递给扩展方法。（如果C＃编译器在范围内找不到任何相应的扩展方法，它将抛出错误。）</p>\n<p>扩展方法是C＃编译器中“语法糖”的一个示例，它使我们能够编写（通常）更清晰，更可维护的代码。更清楚的是，如果您知道它们的用法。否则，可能会有些混乱，尤其是在开始时。</p>\n<p>尽管使用扩展方法当然具有优势，但它们可能会引起问题，并且对于那些不了解它们或不正确理解它们的开发人员，C＃编程帮助会大声疾呼。当在线查看代码示例或任何其他预先编写的代码时，尤其如此。当此类代码产生编译器错误时（因为它调用的类显然没有定义方法），人们倾向于认为该代码适用于该库的不同版本，或完全适用于不同的库。可能会花费大量时间搜索不存在的新版本或幻影“缺少库”。</p>\n<p>当对象上存在具有相同名称的方法时，即使熟悉扩展方法的开发人员仍然偶尔会被捕获，但是其方法签名与扩展方法的方法签名之间存在细微的差异。寻找错别字或错误可能会浪费很多时间。</p>\n<p>在C＃库中使用扩展方法变得越来越普遍。除LINQ之外，<a href=\"http://msdn.microsoft.com/en-us/library/ff648512.aspx\" target=\"_blank\" rel=\"noopener\">Unity Application Block</a>和<a href=\"http://msdn.microsoft.com/en-us/library/hh833994%28v=vs.108%29.aspx\" target=\"_blank\" rel=\"noopener\">Web API框架</a>是Microsoft经常使用的两个现代库的示例，它们也使用扩展方法，并且还有许多其他方法。框架越现代，就越有可能包含扩展方法。</p>\n<p>当然，您也可以编写自己的扩展方法。请意识到，尽管扩展方法看起来像常规实例方法一样被调用，但这实际上只是一种幻想。特别是，您的扩展方法不能引用它们正在扩展的类的私有成员或受保护成员，因此不能完全替代更传统的类继承。</p>\n<h2 id=\"常见的C＃编程错误＃7：为当前任务使用错误的集合类型\"><a href=\"#常见的C＃编程错误＃7：为当前任务使用错误的集合类型\" class=\"headerlink\" title=\"常见的C＃编程错误＃7：为当前任务使用错误的集合类型\"></a>常见的C＃编程错误＃7：为当前任务使用错误的集合类型</h2><p>C＃提供了大量的各种对象集合，具有以下仅为部分清单：</p>\n<p>Array，ArrayList，BitArray，BitVector32，Dictionary&lt;K,V&gt;，HashTable，HybridDictionary，List<t>，NameValueCollection，OrderedDictionary，Queue, Queue<t>，SortedList，Stack, Stack<t>，StringCollection，StringDictionary。</t></t></t></p>\n<p>尽管在某些情况下，太多的选择和不足的选择一样糟糕，但对于集合对象却并非如此。可用的选项数量肯定可以使您受益。预先花一些时间进行研究，然后为您的目的选择最佳的收集类型。这可能会导致更好的性能和更少的错误空间。</p>\n<p>如果有一种收集类型专门针对您拥有的元素类型（例如字符串或位），则倾向于首先使用该元素。当针对特定类型的元素时，实现通常会更高效。</p>\n<p>为了利用C＃的类型安全性，通常应首选使用通用接口而不是非通用接口。泛型接口的元素是您在声明对象时指定的类型，而非泛型接口的元素则是object类型。使用非泛型接口时，C＃编译器无法对您的代码进行类型检查。同样，在处理原始值类型的集合时，使用非泛型集合将导致这些类型的重复 <a href=\"http://msdn.microsoft.com/en-us/library/yz2be5wk.aspx\" target=\"_blank\" rel=\"noopener\">装箱/拆箱</a>，与适当类型的泛型集合相比，可能会对性能产生重大的负面影响。</p>\n<p>另一个常见的C＃问题是编写您自己的集合对象。但这并不是说它永远不合适，但是通过提供.NET提供的广泛选择，您可以通过使用或扩展已经存在的扩展而不是重新发明轮子来节省大量时间。特别是，用于C＃和CLI的C5通用集合库“开箱即用”提供了各种各样的附加集合，例如持久树数据结构，基于堆的优先级队列，哈希索引数组列表，链接列表等等。</p>\n<h2 id=\"常见的C＃编程错误＃8：忽略释放资源\"><a href=\"#常见的C＃编程错误＃8：忽略释放资源\" class=\"headerlink\" title=\"常见的C＃编程错误＃8：忽略释放资源\"></a>常见的C＃编程错误＃8：忽略释放资源</h2><p>CLR环境使用垃圾回收器，因此您无需显式释放为任何对象创建的内存。实际上，您不能。没有C ++ delete运算符或free()这样的函数。但这并不意味着您在使用完所有对象后就可以忘记所有对象。许多类型的对象封装了其他类型的系统资源（例如，磁盘文件，数据库连接，网络套接字等）。保持这些资源开放状态会迅速耗尽系统资源的总数，从而降低性能并最终导致程序错误。</p>\n<p>尽管可以在任何C＃类上定义析构函数方法，但析构函数（在C＃中也称为终结器）存在的问题是，您不确定是否会调用它们。它们在将来的不确定时间内被垃圾收集器调用（在单独的线程上，这可能会导致其他问题）。尝试通过强制使用垃圾回收来克服这些限制 GC.Collect()不是<a href=\"https://orcharddojo.net/orchard-resources/Library/DevelopmentGuidelines/BestPractices/CSharp\" target=\"_blank\" rel=\"noopener\">C＃最佳实践</a>，因为这将在线程收集所有符合收集条件的对象时在未知时间内阻塞线程。</p>\n<p>这并不是说终结器没有很好的用途，但是以确定性方式释放资源并不是其中之一。相反，当您在文件，网络或数据库连接上进行操作时，您希望在完成使用后立即显式释放基础资源。</p>\n<p>在几乎<a href=\"https://www.toptal.com/c-sharp/how-to-make-an-android-and-ios-app-in-c-on-a-mac\" target=\"_blank\" rel=\"noopener\">所有环境中，</a>资源泄漏都是一个问题。但是，C＃提供了一种健壮且易于使用的机制，如果使用该机制，则使泄漏的情况更加罕见。.NET框架定义了IDisposable仅由Dispose()方法组成的接口 。任何实现的对象都IDisposable希望在对象的使用者完成对它的操作后才调用该方法。这导致显式，确定性的资源释放。</p>\n<p>如果要在单个代码块的上下文中创建和处理对象，则忘记调用基本上是不可原谅的 Dispose()，因为C＃提供了一条using语句， Dispose()无论代码块如何退出（无论它是例外，return陈述式，或是干脆关闭区块）。是的，这与using前面提到的语句相同，该语句用于在文件顶部包含C＃名称空间。它有第二个完全不相关的目的，许多C＃开发人员都不知道。即，确保Dispose()在退出代码块时对对象进行调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using (FileStream myFile = File.OpenRead(&quot;foo.txt&quot;)) &#123;</span><br><span class=\"line\">  myFile.Read(buffer, 0, 100);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过using 在上面的示例中创建一个块，您可以确定 myFile.Dispose()在处理完文件后立即调用该块，无论是否Read()引发异常。</p>\n<h2 id=\"常见的C＃编程错误＃9：回避异常\"><a href=\"#常见的C＃编程错误＃9：回避异常\" class=\"headerlink\" title=\"常见的C＃编程错误＃9：回避异常\"></a>常见的C＃编程错误＃9：回避异常</h2><p>C＃将其类型安全性强制实施到运行时。这使您能够比在C ++等语言中更快地查明C＃中的许多类型的错误，在C＃中错误的类型转换可能导致将任意值分配给对象的字段。但是，程序员再次可以浪费这一强大功能，从而导致C＃问题。之所以陷入这种陷阱，是因为C＃提供了两种不同的处理方式，一种可以引发异常，而另一种则不能。有些人会回避异常路由，认为不必编写try / catch块可以节省一些代码。</p>\n<p>例如，以下两种方法可以在C＃中执行显式类型转换：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// METHOD 1:</span><br><span class=\"line\">// Throws an exception if account can&apos;t be cast to SavingsAccount</span><br><span class=\"line\">SavingsAccount savingsAccount = (SavingsAccount)account;</span><br><span class=\"line\"></span><br><span class=\"line\">// METHOD 2:</span><br><span class=\"line\">// Does NOT throw an exception if account can&apos;t be cast to</span><br><span class=\"line\">// SavingsAccount; will just set savingsAccount to null instead</span><br><span class=\"line\">SavingsAccount savingsAccount = account as SavingsAccount;</span><br></pre></td></tr></table></figure>\n\n<p>使用方法2可能发生的最明显的错误是无法检查返回值。这可能会导致最终的NullReferenceException，该异常可能会在更晚的时间浮出水面，从而更加难以找到问题的根源。相反，方法1会立即抛出一个 InvalidCastException问题，使问题的根源更加明显。<br>而且，即使您记得在方法2中检查过返回值，如果发现它为空，您将怎么办？您编写的方法是否适合报告错误？如果强制转换失败，您还可以尝试其他方法吗？如果不是，那么抛出异常是正确的事，因此您最好让它尽可能地靠近问题的根源。</p>\n<p>这是其他两个常见方法对的两个示例，其中一个抛出异常而另一个不抛出异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int.Parse();     // throws exception if argument can’t be parsed</span><br><span class=\"line\">int.TryParse();  // returns a bool to denote whether parse succeeded</span><br><span class=\"line\"></span><br><span class=\"line\">IEnumerable.First();           // throws exception if sequence is empty</span><br><span class=\"line\">IEnumerable.FirstOrDefault();  // returns null/default value if sequence is empty</span><br></pre></td></tr></table></figure>\n\n<p>一些C＃开发人员是如此“异常不利”，以至于他们自动认为不抛出异常的方法是更好的。尽管在某些特定情况下这可能是正确的，但作为概括，它根本不正确。<br>作为一个特定的示例，如果您有替代的合法（例如，默认）操作要发生，那么将产生异常，那么非异常方法可能是一个合法的选择。在这种情况下，写这样的东西确实更好：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (int.TryParse(myString, out myInt)) &#123;</span><br><span class=\"line\">  // use myInt</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  // use default value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代替：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">  myInt = int.Parse(myString);</span><br><span class=\"line\">  // use myInt</span><br><span class=\"line\">&#125; catch (FormatException) &#123;</span><br><span class=\"line\">  // use default value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，认为TryParse必然是“更好”的方法是不正确的。有时候是这种情况，有时候不是。这就是为什么有两种方法可以做到这一点。在您所处的环境中使用正确的方法，请记住，作为开发人员，异常肯定可以成为您的朋友。</p>\n<h2 id=\"常见的C＃编程错误＃10：允许编译器警告累积\"><a href=\"#常见的C＃编程错误＃10：允许编译器警告累积\" class=\"headerlink\" title=\"常见的C＃编程错误＃10：允许编译器警告累积\"></a>常见的C＃编程错误＃10：允许编译器警告累积</h2><p>尽管此问题绝对不是C＃特有的，但由于放弃了C＃编译器提供的严格类型检查的优点，因此在C＃编程中尤为突出。</p>\n<p>产生警告是有原因的。尽管所有C＃编译器错误都表明您的代码有缺陷，但许多警告也是如此。两者的区别在于，在出现警告的情况下，编译器在发出代码所表示的指令时没有问题。即使这样，它也会发现您的代码有些混乱，并且您的代码有可能无法准确反映您的意图。</p>\n<p>就本C＃编程教程而言，一个常见的简单示例是，当您修改算法以消除对正在使用的变量的使用时，却忘记了删除变量声明。该程序将完美运行，但编译器将标记无用的变量声明。程序运行完美的事实导致程序员忽略了修复警告原因的方法。此外，编码人员还利用了Visual Studio功能，该功能使他们可以轻松地将警告隐藏在“错误列表”窗口中，从而使他们只能专注于错误。很快就出现了数十种警告，所有这些警告都被幸福地忽略了（或更糟的是隐藏了）。</p>\n<p>但是，如果您迟早忽略这种类型的警告，则类似这样的内容很可能会在您的代码中找到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Account &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    int myId;</span><br><span class=\"line\">    int Id;   // compiler warned you about this, but you didn’t listen!</span><br><span class=\"line\">  </span><br><span class=\"line\">    // Constructor</span><br><span class=\"line\">    Account(int id) &#123;</span><br><span class=\"line\">        this.myId = Id;     // OOPS!</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而且，以Intellisense允许我们编写代码的速度，此错误并不像看起来那样不可能。<br>现在，您的程序中出现了严重错误（尽管出于已经说明的原因，编译器仅将其标记为警告），并且根据程序的复杂程度，您可能会浪费大量时间来跟踪该程序。如果您首先注意了此警告，则只需五秒钟即可解决此问题。</p>\n<p><strong>记住，如果您正在侦听，C Sharp编译器会为您提供有关代码健壮性的许多有用信息。不要忽略警告。</strong>通常，它们只需要花费几秒钟的时间进行修复，而在发生新问题时修复它们可以节省您的时间。训练自己，使Visual Studio“错误列表”窗口显示“ 0错误，0警告”，以便所有警告使您感到不舒服，无法立即解决它们。</p>\n<p>当然，每个规则都有例外。因此，有时您的代码对编译器来说似乎有些混乱，即使这正是您的预期。在极少数情况下，请#pragma warning disable [warning id]仅在周围使用触发警告的代码，并仅使用其触发的警告ID。这将取消该警告，并且仅禁止该警告，因此您仍然可以保持警惕以防出现新的警告。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>C＃是一种功能强大且灵活的语言，具有许多可以极大地提高生产率的机制和范例。但是，就像使用任何软件工具或语言一样，对其功能的有限了解或欣赏有时可能更多的是障碍而不是收益，可能会导致生产环境代码的问题频发。为此，我们需要更多的了解C#语言中那些常见的错误，并不断的持续优化，确保每一行代码都处于可控的状态。</p>\n<p>在你的日常开发过程中，你是否也曾经遇到过这些常见错误？赶紧跟你身边的伙伴一起分享吧~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>原文来自：<a href=\"https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make\" target=\"_blank\" rel=\"noopener\">https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make</a></p>\n<p>帕特里克·赖德（PATRICK RYDER）在Microsoft工作期间帮助创建了VB 1.0和更高版本的.NET平台。自2000年以来，他专注于全栈项目。</p>\n<p>C＃是针对Microsoft 公共语言运行库（CLR）的几种语言之一。面向CLR的语言受益于多种功能，例如跨语言集成和异常处理，增强的安全性，简化的组件交互模型以及调试和性能分析服务。在当今的CLR语言中，C＃被广泛用于针对Windows台式机，移动或服务器环境的复杂，专业的开发项目中。(译者注，目前已支持各类跨平台的操作系统环境）</p>\n<p>C＃是一种面向对象的强类型语言。在编译和运行时，C＃中严格的类型检查会导致尽早报告大多数典型的C＃编程错误，并准确定位其位置。这可以在C Sharp编程中节省大量时间，相比之下，在更自由地执行类型安全的语言中，跟踪令人困惑的错误的原因可能会在违规操作发生很久之后才发生。但是，许多C＃编码人员无意间（或不小心）放弃了这种检测的好处，这导致了本C＃教程中讨论的一些问题。</p>\n<h2 id=\"关于本C-Sharp编程教程\"><a href=\"#关于本C-Sharp编程教程\" class=\"headerlink\" title=\"关于本C Sharp编程教程\"></a>关于本C Sharp编程教程</h2><p><strong>本教程描述了C＃程序员犯下的10种最常见的C＃编程错误或应避免的问题，并为他们提供了帮助。</strong></p>\n<p>尽管本文中讨论的大多数错误都是C＃特定的，但有些错误也与其他以CLR为目标或使用框架类库（FCL）的语言有关。</p>\n<h2 id=\"常见的C＃编程错误＃1：使用值类型与引用相等，或反过来\"><a href=\"#常见的C＃编程错误＃1：使用值类型与引用相等，或反过来\" class=\"headerlink\" title=\"常见的C＃编程错误＃1：使用值类型与引用相等，或反过来\"></a>常见的C＃编程错误＃1：使用值类型与引用相等，或反过来</h2><p>C ++和许多其他语言的程序员习惯于控制他们分配给变量的值是简单的值还是对现有对象的引用。但是，在C Sharp编程中，该决定由编写对象的程序员决定，而不是由实例化该对象并将其分配给变量的程序员做出。对于那些试图学习C＃编程的人来说，这是一个常见的“陷阱”。</p>\n<p>如果您不知道所使用的对象是值类型还是引用类型，则可能会遇到一些意外。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point point1 = new Point(20, 30);</span><br><span class=\"line\">Point point2 = point1;</span><br><span class=\"line\">point2.X = 50;</span><br><span class=\"line\">Console.WriteLine(point1.X);       // 20 (does this surprise you?)</span><br><span class=\"line\">Console.WriteLine(point2.X);       // 50</span><br><span class=\"line\"></span><br><span class=\"line\">Pen pen1 = new Pen(Color.Black);</span><br><span class=\"line\">Pen pen2 = pen1;</span><br><span class=\"line\">pen2.Color = Color.Blue;</span><br><span class=\"line\">Console.WriteLine(pen1.Color);     // Blue (or does this surprise you?)</span><br><span class=\"line\">Console.WriteLine(pen2.Color);     // Blue</span><br></pre></td></tr></table></figure>\n\n<p>正如你所看到的，都Point和Pen对象创建方式不尽相同，但值point1保持不变，当一个新的X坐标值被分配到point2，而价值pen1 <em>是</em>当一个新的颜色被分配到修改pen2。因此，我们可以<em>推断出<em>，point1并且point2每个Point对象都包含自己的对象副本，而pen1和pen2都包含对同一Pen对象的引用。</em>但是，如果不进行此实验，我们怎么知道呢？</em><br>答案是查看对象类型的定义（您可以在Visual Studio中通过将光标置于对象类型的名称上并按F12轻松地完成此操作）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public struct Point &#123; ... &#125;     // defines a “value” type</span><br><span class=\"line\">public class Pen &#123; ... &#125;        // defines a “reference” type</span><br></pre></td></tr></table></figure>\n\n<p>如上所示，在C＃编程中，struct关键字用于定义值类型，而class关键字用于定义引用类型。<em>对于那些具有C ++背景的人，由于C ++和C＃关键字之间的许多相似之处而陷入一种错误的安全感，这种行为可能会让人感到意外，您可能会从C＃教程中寻求帮助。</em><br>如果您要依赖值和引用类型之间不同的某些行为（例如，将对象作为方法参数传递并让该方法更改对象状态的能力），请确保您正在处理正确的对象类型，以避免C＃编程问题。</p>\n<h2 id=\"常见的C＃编程错误＃2：误解了未初始化变量的默认值\"><a href=\"#常见的C＃编程错误＃2：误解了未初始化变量的默认值\" class=\"headerlink\" title=\"常见的C＃编程错误＃2：误解了未初始化变量的默认值\"></a>常见的C＃编程错误＃2：误解了未初始化变量的默认值</h2><p>在C＃中，值类型不能为null。根据定义，值类型具有值，甚至值类型的未初始化变量也必须具有值。这称为该类型的默认值。当检查变量是否未初始化时，这会导致以下结果，通常是意外的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Program &#123;</span><br><span class=\"line\">    static Point point1;</span><br><span class=\"line\">    static Pen pen1;</span><br><span class=\"line\">    static void Main(string[] args) &#123;</span><br><span class=\"line\">        Console.WriteLine(pen1 == null);      // True</span><br><span class=\"line\">        Console.WriteLine(point1 == null);    // False (huh?)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么point1不为空？答案是Point是值类型，它的默认值为Point（0,0），而不是null。未能意识到这一点是在C＃中非常容易（也是常见）的错误。<br>许多（但不是全部）值类型都有一个IsEmpty属性，您可以检查该属性是否等于其默认值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Console.WriteLine(point1.IsEmpty);        // True</span><br></pre></td></tr></table></figure>\n\n<p>当您检查变量是否已初始化时，请确保您知道该类型的未初始化变量在默认情况下将具有什么值，并且不要依赖于它为null。</p>\n<h2 id=\"常见的C＃编程错误＃3：使用不正确或未指定的字符串比较方法\"><a href=\"#常见的C＃编程错误＃3：使用不正确或未指定的字符串比较方法\" class=\"headerlink\" title=\"常见的C＃编程错误＃3：使用不正确或未指定的字符串比较方法\"></a>常见的C＃编程错误＃3：使用不正确或未指定的字符串比较方法</h2><p>比较C＃中的字符串有很多不同的方法。</p>\n<p>尽管许多程序员使用==运算符进行字符串比较，但这实际上是最不希望采用的方法之一，主要是因为它没有在代码中明确指定需要哪种类型的比较。</p>\n<p>相反，在C＃编程中测试字符串相等性的首选方法是使用以下Equals方法：</p>\n<pre><code>public bool Equals(string value);\n\npublic bool Equals(string value, StringComparison comparisonType);</code></pre><p>第一个方法签名（即不带comparisonType参数）实际上与使用==运算符相同，但是具有显式应用于字符串的好处。它执行字符串的序数比较，基本上是逐字节比较。在很多情况下，这正是您想要的比较类型，尤其是在比较以编程方式设置值的字符串（例如文件名，环境变量，属性等）时。在这些情况下，只要序数比较确实是正确的类型这种情况下的比较，使用Equals方法不带 comparisonType参数的唯一缺点是，阅读代码的人可能不知道您要进行哪种类型的比较。</p>\n<p>但是，使用Equals每次比较字符串包含comparisonType的方法签名，不仅可以使代码更清晰，还可以使您明确考虑需要进行哪种类型的比较。这是一件值得做的事情，因为即使英语在序数比较和对文化敏感的比较之间不能提供很多差异，其他语言也可以提供很多好处，而忽略其他语言的可能性正在为您提供巨大的潜力错误的道路。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s = &quot;strasse&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// outputs False:</span><br><span class=\"line\">Console.WriteLine(s == &quot;straße&quot;);</span><br><span class=\"line\">Console.WriteLine(s.Equals(&quot;straße&quot;));</span><br><span class=\"line\">Console.WriteLine(s.Equals(&quot;straße&quot;, StringComparison.Ordinal));</span><br><span class=\"line\">Console.WriteLine(s.Equals(&quot;Straße&quot;, StringComparison.CurrentCulture));        </span><br><span class=\"line\">Console.WriteLine(s.Equals(&quot;straße&quot;, StringComparison.OrdinalIgnoreCase));</span><br><span class=\"line\"></span><br><span class=\"line\">// outputs True:</span><br><span class=\"line\">Console.WriteLine(s.Equals(&quot;straße&quot;, StringComparison.CurrentCulture));</span><br><span class=\"line\">Console.WriteLine(s.Equals(&quot;Straße&quot;, StringComparison.CurrentCultureIgnoreCase));</span><br></pre></td></tr></table></figure>\n\n<p>最安全的做法是始终为该Equals方法提供comparisonType参数。以下是一些基本准则：</p>\n<ul>\n<li>在比较用户输入的字符串或要显示给用户的字符串时，请使用区分区域性的比较（CurrentCulture或CurrentCultureIgnoreCase）。</li>\n<li>比较程序字符串时，请使用序数比较（Ordinal或OrdinalIgnoreCase）。</li>\n<li>InvariantCulture和InvariantCultureIgnoreCase一般不被除了在非常有限的情况下使用，因为顺序比较是更有效的。如果需要进行文化意识比较，则通常应针对当前文化或其他特定文化进行比较。</li>\n</ul>\n<p>除了Equals方法之外，字符串还提供了 Compare方法，该方法为您提供有关字符串相对顺序的信息，而不仅仅是进行相等性测试。此方法是优选的&lt;，&lt;=，&gt;和&gt;=运算符，对于上述的为讨论避免C＃的问题同样的原因。</p>\n<h2 id=\"常见的C＃编程错误＃4：使用迭代（而不是声明性）语句来操作集合\"><a href=\"#常见的C＃编程错误＃4：使用迭代（而不是声明性）语句来操作集合\" class=\"headerlink\" title=\"常见的C＃编程错误＃4：使用迭代（而不是声明性）语句来操作集合\"></a>常见的C＃编程错误＃4：使用迭代（而不是声明性）语句来操作集合</h2><p>在C＃3.0中，向<a href=\"http://msdn.microsoft.com/en-us/library/bb308959.aspx\" target=\"_blank\" rel=\"noopener\">语言</a>添加<a href=\"http://msdn.microsoft.com/en-us/library/bb308959.aspx\" target=\"_blank\" rel=\"noopener\">语言集成查询</a>（LINQ）永远改变了查询和操作集合的方式。从那时起，如果您使用迭代语句来操作集合，那么您本来应该使用LINQ。</p>\n<p>一些C＃程序员甚至不知道LINQ的存在，但是幸运的是，这个数目正在变得越来越小。但是，许多人仍然认为，由于LINQ关键字和SQL语句之间的相似性，它的唯一用途是在查询数据库的代码中。</p>\n<p>尽管数据库查询是LINQ语句的一种非常普遍的用法，但它们实际上是在任何可枚举的集合（即，实现IEnumerable接口的任何对象）上工作的。因此，例如，如果您有一个Accounts数组，而不是为每个each编写一个C＃List：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      decimal total = 0;</span><br><span class=\"line\">      foreach (Account account in myAccounts) &#123;</span><br><span class=\"line\">        if (account.Status == &quot;active&quot;) &#123;</span><br><span class=\"line\">          total += account.Balance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">你可以这样写：</span><br><span class=\"line\">      decimal total = (from account in myAccounts</span><br><span class=\"line\">                       where account.Status == &quot;active&quot;</span><br><span class=\"line\">                       select account.Balance).Sum();</span><br></pre></td></tr></table></figure>\n\n<p>尽管这是一个非常简单的示例，说明如何避免这种常见的C＃编程问题，但在某些情况下，单个LINQ语句可以轻松替换代码中的迭代循环（或嵌套循环）中的数十个语句。更少的通用代码意味着更少的引入错误的机会。但是请记住，在性能方面可能会有所取舍。在对性能有严格要求的情况下，尤其是在迭代代码能够对LINQ无法进行的集合进行假设的情况下，请确保在这两种方法之间进行性能比较。</p>\n<h2 id=\"常见的C＃编程错误＃5：无法考虑LINQ语句中的基础对象\"><a href=\"#常见的C＃编程错误＃5：无法考虑LINQ语句中的基础对象\" class=\"headerlink\" title=\"常见的C＃编程错误＃5：无法考虑LINQ语句中的基础对象\"></a>常见的C＃编程错误＃5：无法考虑LINQ语句中的基础对象</h2><p>LINQ非常适合抽象处理集合的任务，无论它们是内存中对象，数据库表还是XML文档。在理想环境中，您不需要知道底层对象是什么。但是这里的错误是假设我们生活在一个完美的世界中。实际上，如果相同的LINQ语句恰好采用不同的格式，则当它们对完全相同的数据执行时，它们可以返回不同的结果。</p>\n<p>例如，考虑以下语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">decimal total = (from account in myAccounts</span><br><span class=\"line\">                 where account.Status == &quot;active&quot;</span><br><span class=\"line\">                 select account.Balance).Sum();</span><br></pre></td></tr></table></figure>\n\n<p>如果对象的其中一个account.Status等于“活动”（请注意大写字母A）会怎样？好吧，如果myAccounts是一个DbSet对象（使用默认的不区分大小写的默认配置设置），则where表达式仍会匹配该元素。但是，如果myAccounts位于内存阵列中，则它将不匹配，因此将产生总计不同的结果。<br>等一下 在前面讨论字符串比较时，我们看到==运算符对字符串进行了序数比较。那么，为什么在这种情况下==操作员执行不区分大小写的比较？</p>\n<p><em>答案是，当LINQ语句中的基础对象是对SQL表数据的引用时（如本示例中的Entity Framework DbSet对象一样），该语句将转换为T-SQL语句。然后，操作员将遵循T-SQL编程规则，而不是C＃编程规则，因此，上述情况下的比较最终不区分大小写。</em></p>\n<p>通常，即使LINQ是查询对象集合的有用且一致的方式，实际上，您仍然需要知道您的语句是否将转换为C＃以外的其他内容，以确保代码的行为能够在运行时达到预期。</p>\n<h2 id=\"常见的C＃编程错误＃6：扩展方法使您感到困惑或冒充\"><a href=\"#常见的C＃编程错误＃6：扩展方法使您感到困惑或冒充\" class=\"headerlink\" title=\"常见的C＃编程错误＃6：扩展方法使您感到困惑或冒充\"></a>常见的C＃编程错误＃6：扩展方法使您感到困惑或冒充</h2><p>如前所述，LINQ语句可在实现IEnumerable的任何对象上工作。例如，以下简单功能将在任何帐户集合上累加余额：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public decimal SumAccounts(IEnumerable&lt;Account&gt; myAccounts) &#123;</span><br><span class=\"line\">    return myAccounts.Sum(a =&gt; a.Balance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，myAccounts参数的类型声明为 IEnumerable<account>。由于myAccounts引用Sum方法（C＃使用熟悉的“点符号”来引用类或接口上的方法），因此我们希望看到Sum()在IEnumerable<t>接口定义上调用的方法。但是，定义 IEnumerable<t>未引用任何Sum方法，而只是这样：</t></t></account></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface IEnumerable&lt;out T&gt; : IEnumerable &#123;</span><br><span class=\"line\">    IEnumerator&lt;T&gt; GetEnumerator();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么该Sum()方法在哪里定义？C＃是强类型的，因此，如果对该Sum方法的引用无效，则C＃编译器肯定会将其标记为错误。因此，我们知道它必须存在，但是在哪里？此外，LINQ为查询或汇总这些集合提供的所有其他方法的定义在哪里？<br>答案是这Sum()不是IEnumerable接口上定义的方法 。相反，它是在System.Linq.Enumerable类上定义的静态方法（称为“扩展方法”）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace System.Linq &#123;</span><br><span class=\"line\">  public static class Enumerable &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    // the reference here to “this IEnumerable&lt;TSource&gt; source” is</span><br><span class=\"line\">    // the magic sauce that provides access to the extension method Sum</span><br><span class=\"line\">    public static decimal Sum&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source,</span><br><span class=\"line\">                                       Func&lt;TSource, decimal&gt; selector);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，什么使扩展方法与任何其他静态方法不同，又使我们能够在其他类中访问它呢？<br>扩展方法的显着特征是this其第一个参数上的 修饰符。这是“魔术”，可以将其标识为编译器的扩展方法。它修改的参数的类型（在本例中为IEnumerable<tsource>）表示将要实现此方法的类或接口。</tsource></p>\n<p>（另一方面，IEnumerable接口名称和Enumerable定义扩展方法的类的名称 之间的相似性并没有什么神奇的。这种相似性只是一个任意的样式选择。）</p>\n<p>有了这种理解，我们还可以看到sumAccounts上面介绍的功能可以改为如下实现：</p>\n<pre><code>public decimal SumAccounts(IEnumerable&lt;Account&gt; myAccounts) {\n\n    return Enumerable.Sum(myAccounts, a =&gt; a.Balance);\n\n}</code></pre><p>我们本可以以这种方式实现它的事实反而引起了一个问题，为什么根本没有扩展方法？ <a href=\"http://msdn.microsoft.com/en-us/library/bb383977.aspx\" target=\"_blank\" rel=\"noopener\">扩展方法</a>本质上是C＃编程语言的一种便利，它使您可以将方法“添加”到现有类型，而无需创建新的派生类型，重新编译或修改原始类型。</p>\n<p>通过using [namespace];在文件顶部包含一条语句，可将扩展方法纳入范围。您需要知道哪个C＃名称空间包含要查找的扩展方法，但是一旦知道要查找的内容，就很容易确定。</p>\n<p>当C＃编译器在对象的实例上遇到方法调用，但未找到在引用的对象类上定义的方法时，它将查看范围内的所有扩展方法，以尝试查找与所需方法匹配的扩展方法。签名和类。如果找到一个，它将实例引用作为该扩展方法的第一个参数传递，然后其余参数（如果有）将作为后续参数传递给扩展方法。（如果C＃编译器在范围内找不到任何相应的扩展方法，它将抛出错误。）</p>\n<p>扩展方法是C＃编译器中“语法糖”的一个示例，它使我们能够编写（通常）更清晰，更可维护的代码。更清楚的是，如果您知道它们的用法。否则，可能会有些混乱，尤其是在开始时。</p>\n<p>尽管使用扩展方法当然具有优势，但它们可能会引起问题，并且对于那些不了解它们或不正确理解它们的开发人员，C＃编程帮助会大声疾呼。当在线查看代码示例或任何其他预先编写的代码时，尤其如此。当此类代码产生编译器错误时（因为它调用的类显然没有定义方法），人们倾向于认为该代码适用于该库的不同版本，或完全适用于不同的库。可能会花费大量时间搜索不存在的新版本或幻影“缺少库”。</p>\n<p>当对象上存在具有相同名称的方法时，即使熟悉扩展方法的开发人员仍然偶尔会被捕获，但是其方法签名与扩展方法的方法签名之间存在细微的差异。寻找错别字或错误可能会浪费很多时间。</p>\n<p>在C＃库中使用扩展方法变得越来越普遍。除LINQ之外，<a href=\"http://msdn.microsoft.com/en-us/library/ff648512.aspx\" target=\"_blank\" rel=\"noopener\">Unity Application Block</a>和<a href=\"http://msdn.microsoft.com/en-us/library/hh833994%28v=vs.108%29.aspx\" target=\"_blank\" rel=\"noopener\">Web API框架</a>是Microsoft经常使用的两个现代库的示例，它们也使用扩展方法，并且还有许多其他方法。框架越现代，就越有可能包含扩展方法。</p>\n<p>当然，您也可以编写自己的扩展方法。请意识到，尽管扩展方法看起来像常规实例方法一样被调用，但这实际上只是一种幻想。特别是，您的扩展方法不能引用它们正在扩展的类的私有成员或受保护成员，因此不能完全替代更传统的类继承。</p>\n<h2 id=\"常见的C＃编程错误＃7：为当前任务使用错误的集合类型\"><a href=\"#常见的C＃编程错误＃7：为当前任务使用错误的集合类型\" class=\"headerlink\" title=\"常见的C＃编程错误＃7：为当前任务使用错误的集合类型\"></a>常见的C＃编程错误＃7：为当前任务使用错误的集合类型</h2><p>C＃提供了大量的各种对象集合，具有以下仅为部分清单：</p>\n<p>Array，ArrayList，BitArray，BitVector32，Dictionary&lt;K,V&gt;，HashTable，HybridDictionary，List<t>，NameValueCollection，OrderedDictionary，Queue, Queue<t>，SortedList，Stack, Stack<t>，StringCollection，StringDictionary。</t></t></t></p>\n<p>尽管在某些情况下，太多的选择和不足的选择一样糟糕，但对于集合对象却并非如此。可用的选项数量肯定可以使您受益。预先花一些时间进行研究，然后为您的目的选择最佳的收集类型。这可能会导致更好的性能和更少的错误空间。</p>\n<p>如果有一种收集类型专门针对您拥有的元素类型（例如字符串或位），则倾向于首先使用该元素。当针对特定类型的元素时，实现通常会更高效。</p>\n<p>为了利用C＃的类型安全性，通常应首选使用通用接口而不是非通用接口。泛型接口的元素是您在声明对象时指定的类型，而非泛型接口的元素则是object类型。使用非泛型接口时，C＃编译器无法对您的代码进行类型检查。同样，在处理原始值类型的集合时，使用非泛型集合将导致这些类型的重复 <a href=\"http://msdn.microsoft.com/en-us/library/yz2be5wk.aspx\" target=\"_blank\" rel=\"noopener\">装箱/拆箱</a>，与适当类型的泛型集合相比，可能会对性能产生重大的负面影响。</p>\n<p>另一个常见的C＃问题是编写您自己的集合对象。但这并不是说它永远不合适，但是通过提供.NET提供的广泛选择，您可以通过使用或扩展已经存在的扩展而不是重新发明轮子来节省大量时间。特别是，用于C＃和CLI的C5通用集合库“开箱即用”提供了各种各样的附加集合，例如持久树数据结构，基于堆的优先级队列，哈希索引数组列表，链接列表等等。</p>\n<h2 id=\"常见的C＃编程错误＃8：忽略释放资源\"><a href=\"#常见的C＃编程错误＃8：忽略释放资源\" class=\"headerlink\" title=\"常见的C＃编程错误＃8：忽略释放资源\"></a>常见的C＃编程错误＃8：忽略释放资源</h2><p>CLR环境使用垃圾回收器，因此您无需显式释放为任何对象创建的内存。实际上，您不能。没有C ++ delete运算符或free()这样的函数。但这并不意味着您在使用完所有对象后就可以忘记所有对象。许多类型的对象封装了其他类型的系统资源（例如，磁盘文件，数据库连接，网络套接字等）。保持这些资源开放状态会迅速耗尽系统资源的总数，从而降低性能并最终导致程序错误。</p>\n<p>尽管可以在任何C＃类上定义析构函数方法，但析构函数（在C＃中也称为终结器）存在的问题是，您不确定是否会调用它们。它们在将来的不确定时间内被垃圾收集器调用（在单独的线程上，这可能会导致其他问题）。尝试通过强制使用垃圾回收来克服这些限制 GC.Collect()不是<a href=\"https://orcharddojo.net/orchard-resources/Library/DevelopmentGuidelines/BestPractices/CSharp\" target=\"_blank\" rel=\"noopener\">C＃最佳实践</a>，因为这将在线程收集所有符合收集条件的对象时在未知时间内阻塞线程。</p>\n<p>这并不是说终结器没有很好的用途，但是以确定性方式释放资源并不是其中之一。相反，当您在文件，网络或数据库连接上进行操作时，您希望在完成使用后立即显式释放基础资源。</p>\n<p>在几乎<a href=\"https://www.toptal.com/c-sharp/how-to-make-an-android-and-ios-app-in-c-on-a-mac\" target=\"_blank\" rel=\"noopener\">所有环境中，</a>资源泄漏都是一个问题。但是，C＃提供了一种健壮且易于使用的机制，如果使用该机制，则使泄漏的情况更加罕见。.NET框架定义了IDisposable仅由Dispose()方法组成的接口 。任何实现的对象都IDisposable希望在对象的使用者完成对它的操作后才调用该方法。这导致显式，确定性的资源释放。</p>\n<p>如果要在单个代码块的上下文中创建和处理对象，则忘记调用基本上是不可原谅的 Dispose()，因为C＃提供了一条using语句， Dispose()无论代码块如何退出（无论它是例外，return陈述式，或是干脆关闭区块）。是的，这与using前面提到的语句相同，该语句用于在文件顶部包含C＃名称空间。它有第二个完全不相关的目的，许多C＃开发人员都不知道。即，确保Dispose()在退出代码块时对对象进行调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using (FileStream myFile = File.OpenRead(&quot;foo.txt&quot;)) &#123;</span><br><span class=\"line\">  myFile.Read(buffer, 0, 100);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过using 在上面的示例中创建一个块，您可以确定 myFile.Dispose()在处理完文件后立即调用该块，无论是否Read()引发异常。</p>\n<h2 id=\"常见的C＃编程错误＃9：回避异常\"><a href=\"#常见的C＃编程错误＃9：回避异常\" class=\"headerlink\" title=\"常见的C＃编程错误＃9：回避异常\"></a>常见的C＃编程错误＃9：回避异常</h2><p>C＃将其类型安全性强制实施到运行时。这使您能够比在C ++等语言中更快地查明C＃中的许多类型的错误，在C＃中错误的类型转换可能导致将任意值分配给对象的字段。但是，程序员再次可以浪费这一强大功能，从而导致C＃问题。之所以陷入这种陷阱，是因为C＃提供了两种不同的处理方式，一种可以引发异常，而另一种则不能。有些人会回避异常路由，认为不必编写try / catch块可以节省一些代码。</p>\n<p>例如，以下两种方法可以在C＃中执行显式类型转换：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// METHOD 1:</span><br><span class=\"line\">// Throws an exception if account can&apos;t be cast to SavingsAccount</span><br><span class=\"line\">SavingsAccount savingsAccount = (SavingsAccount)account;</span><br><span class=\"line\"></span><br><span class=\"line\">// METHOD 2:</span><br><span class=\"line\">// Does NOT throw an exception if account can&apos;t be cast to</span><br><span class=\"line\">// SavingsAccount; will just set savingsAccount to null instead</span><br><span class=\"line\">SavingsAccount savingsAccount = account as SavingsAccount;</span><br></pre></td></tr></table></figure>\n\n<p>使用方法2可能发生的最明显的错误是无法检查返回值。这可能会导致最终的NullReferenceException，该异常可能会在更晚的时间浮出水面，从而更加难以找到问题的根源。相反，方法1会立即抛出一个 InvalidCastException问题，使问题的根源更加明显。<br>而且，即使您记得在方法2中检查过返回值，如果发现它为空，您将怎么办？您编写的方法是否适合报告错误？如果强制转换失败，您还可以尝试其他方法吗？如果不是，那么抛出异常是正确的事，因此您最好让它尽可能地靠近问题的根源。</p>\n<p>这是其他两个常见方法对的两个示例，其中一个抛出异常而另一个不抛出异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int.Parse();     // throws exception if argument can’t be parsed</span><br><span class=\"line\">int.TryParse();  // returns a bool to denote whether parse succeeded</span><br><span class=\"line\"></span><br><span class=\"line\">IEnumerable.First();           // throws exception if sequence is empty</span><br><span class=\"line\">IEnumerable.FirstOrDefault();  // returns null/default value if sequence is empty</span><br></pre></td></tr></table></figure>\n\n<p>一些C＃开发人员是如此“异常不利”，以至于他们自动认为不抛出异常的方法是更好的。尽管在某些特定情况下这可能是正确的，但作为概括，它根本不正确。<br>作为一个特定的示例，如果您有替代的合法（例如，默认）操作要发生，那么将产生异常，那么非异常方法可能是一个合法的选择。在这种情况下，写这样的东西确实更好：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (int.TryParse(myString, out myInt)) &#123;</span><br><span class=\"line\">  // use myInt</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  // use default value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代替：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">  myInt = int.Parse(myString);</span><br><span class=\"line\">  // use myInt</span><br><span class=\"line\">&#125; catch (FormatException) &#123;</span><br><span class=\"line\">  // use default value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，认为TryParse必然是“更好”的方法是不正确的。有时候是这种情况，有时候不是。这就是为什么有两种方法可以做到这一点。在您所处的环境中使用正确的方法，请记住，作为开发人员，异常肯定可以成为您的朋友。</p>\n<h2 id=\"常见的C＃编程错误＃10：允许编译器警告累积\"><a href=\"#常见的C＃编程错误＃10：允许编译器警告累积\" class=\"headerlink\" title=\"常见的C＃编程错误＃10：允许编译器警告累积\"></a>常见的C＃编程错误＃10：允许编译器警告累积</h2><p>尽管此问题绝对不是C＃特有的，但由于放弃了C＃编译器提供的严格类型检查的优点，因此在C＃编程中尤为突出。</p>\n<p>产生警告是有原因的。尽管所有C＃编译器错误都表明您的代码有缺陷，但许多警告也是如此。两者的区别在于，在出现警告的情况下，编译器在发出代码所表示的指令时没有问题。即使这样，它也会发现您的代码有些混乱，并且您的代码有可能无法准确反映您的意图。</p>\n<p>就本C＃编程教程而言，一个常见的简单示例是，当您修改算法以消除对正在使用的变量的使用时，却忘记了删除变量声明。该程序将完美运行，但编译器将标记无用的变量声明。程序运行完美的事实导致程序员忽略了修复警告原因的方法。此外，编码人员还利用了Visual Studio功能，该功能使他们可以轻松地将警告隐藏在“错误列表”窗口中，从而使他们只能专注于错误。很快就出现了数十种警告，所有这些警告都被幸福地忽略了（或更糟的是隐藏了）。</p>\n<p>但是，如果您迟早忽略这种类型的警告，则类似这样的内容很可能会在您的代码中找到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Account &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    int myId;</span><br><span class=\"line\">    int Id;   // compiler warned you about this, but you didn’t listen!</span><br><span class=\"line\">  </span><br><span class=\"line\">    // Constructor</span><br><span class=\"line\">    Account(int id) &#123;</span><br><span class=\"line\">        this.myId = Id;     // OOPS!</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而且，以Intellisense允许我们编写代码的速度，此错误并不像看起来那样不可能。<br>现在，您的程序中出现了严重错误（尽管出于已经说明的原因，编译器仅将其标记为警告），并且根据程序的复杂程度，您可能会浪费大量时间来跟踪该程序。如果您首先注意了此警告，则只需五秒钟即可解决此问题。</p>\n<p><strong>记住，如果您正在侦听，C Sharp编译器会为您提供有关代码健壮性的许多有用信息。不要忽略警告。</strong>通常，它们只需要花费几秒钟的时间进行修复，而在发生新问题时修复它们可以节省您的时间。训练自己，使Visual Studio“错误列表”窗口显示“ 0错误，0警告”，以便所有警告使您感到不舒服，无法立即解决它们。</p>\n<p>当然，每个规则都有例外。因此，有时您的代码对编译器来说似乎有些混乱，即使这正是您的预期。在极少数情况下，请#pragma warning disable [warning id]仅在周围使用触发警告的代码，并仅使用其触发的警告ID。这将取消该警告，并且仅禁止该警告，因此您仍然可以保持警惕以防出现新的警告。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>C＃是一种功能强大且灵活的语言，具有许多可以极大地提高生产率的机制和范例。但是，就像使用任何软件工具或语言一样，对其功能的有限了解或欣赏有时可能更多的是障碍而不是收益，可能会导致生产环境代码的问题频发。为此，我们需要更多的了解C#语言中那些常见的错误，并不断的持续优化，确保每一行代码都处于可控的状态。</p>\n<p>在你的日常开发过程中，你是否也曾经遇到过这些常见错误？赶紧跟你身边的伙伴一起分享吧~</p>\n"},{"title":"在.NET应用程序中分析CPU使用率过高的问题","date":"2020-04-09T13:24:00.000Z","author":"邹溪源","_content":"\n作者:胡安·帕勃罗·希达，JUAN PABLO SCIDA是一位软件架构师，在软件开发方面拥有10多年的经验。他是经过认证的.NET和Java开发人员。在过去的几年中，他还热衷于使用Node.js，MongoDB和Erlang。\n\n原文来自：[https://www.toptal.com/dot-net/hunting-high-cpu-usage-in-dot-net](https://www.toptal.com/dot-net/hunting-high-cpu-usage-in-dot-net)\n\n软件开发可能是一个非常复杂的过程。作为开发人员，我们需要考虑很多不同的变量。有些不在我们的控制之下，有些在实际代码执行时对我们来说是未知的，有些则由我们直接控制。 [.NET开发人员](https://www.toptal.com/dot-net)也毫不例外。\n\n考虑到这样的现实情况，当我们在受控环境中工作时，事情通常会按计划进行。假设就是我们的开发机器或我们可以完全访问的集成环境。我们可以使用工具来分析影响我们的代码和软件的不同变量。我们也不必处理服务器的繁重负载，也不必处理并发用户尝试同时执行相同操作的情况。\n\n在可描述和安全的情况下，我们的代码通常可以正常工作，但是在生产环境下，如果处于过度负载或其他一些外部因素的影响，可能会发生意外问题。生产环境的软件性能很难分析。在大多数情况下，我们必须在理论上处理潜在的问题：我们知道可能会发生问题，但无法测试。这就是为什么我们需要以我们所用语言的最佳实践和文档为基础进行开发，并避免[常见错误](https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make)。\n\n如前所述，当软件上线时，可能会出错，并且代码可能会以我们未计划的方式开始执行。当我们不得不处理问题而又无法调试或确定发生了什么情况时，我们可能会遇到这种情况。在这种情况下我们该怎么办？\n\n![图片](https://uploader.shimo.im/f/nLECb8q0ecw5UN4q.png!thumbnail)\n\n如果某个进程长时间使用超过90％的CPU，则我们会遇到麻烦\n\n\n在本文中，我们将分析基于Windows的服务器上. net web应用程序的高CPU使用率的实际案例场景、涉及到的识别问题的过程，以及更重要的问题，为什么会出现这个问题以及我们如何解决它。\n\nCPU使用率和内存消耗是广泛讨论的主题。通常，很难确定某个特定进程应使用的资源（CPU，RAM，I / O）的正确数量以及持续的时间段。尽管可以肯定的是-如果某个进程长时间使用了超过90％的CPU，那么我们将特别麻烦，因为在这种情况下服务器将无法处理任何其他请求。\n\n这是否意味着流程本身存在问题？不必要。该过程可能需要更多的处理能力，或者正在处理大量数据。首先，我们唯一能做的就是尝试确定发生这种情况的原因。\n\n所有操作系统都有几种不同的工具来监视服务器中发生的事情。Windows服务器专门具有任务管理器[Performance Monitor](https://technet.microsoft.com/en-us/library/cc749115.aspx)，在本例中，我们使用了[New Relic Servers](http://newrelic.com/server-monitoring)，它是监视服务器的绝佳工具。\n\n## 最初症状和问题分析\n部署应用程序后，在头两周的时间里，我们开始看到服务器的CPU使用率达到峰值，这使服务器无响应。为了使其再次可用，我们必须重新启动它，并且该事件在该时间段内发生了3次。如前所述，我们使用New Relic Servers作为服务器监视器，它表明w3wp.exe在服务器崩溃时，该进程占用了94％的CPU。\n\nInternet信息服务（IIS）工作进程是Windows进程（w3wp.exe），它运行Web应用程序，并负责处理发送到特定应用程序池的Web服务器的请求。IIS服务器可能有多个应用程序池（和几个不同的w3wp.exe进程），这些池可能会产生问题。根据该进程具有的用户（这在New Relic报告中显示），我们确定问题出在我们的.NET C＃Web表单旧版应用程序。\n\n.NET Framework与Windows调试工具紧密集成在一起，因此，我们要做的第一件事是查看事件查看器和应用程序日志文件，以查找有关正在发生的事情的有用信息。无论我们是否在事件查看器中记录了一些异常，它们都没有提供足够的数据来进行分析。这就是为什么我们决定更进一步并收集更多数据的原因，因此当事件再次发生时，我们将做好准备。\n\n## 数据采集\n收集用户模式进程转储的最简单方法是使用[Debug Diagnostic Tools v2.0](https://www.microsoft.com/en-us/download/details.aspx?id=49924)或仅使用DebugDiag。DebugDiag具有一组用于收集数据（DebugDiag集合）和分析数据（DebugDiag分析）的工具。\n\n因此，让我们开始定义使用调试诊断工具收集数据的规则：\n\n1. 打开DebugDiag集合，然后选择Performance。![图片](https://uploader.shimo.im/f/pUEaTdjUQ34gG4NI.png!thumbnail)\n2. 选择Performance Counters并单击Next。\n3. 点击Add Perf Triggers。\n4. 展开Processor（不是Process）对象，然后选择% Processor Time。请注意，如果您使用的是Windows Server 2008 R2，并且具有64个以上的处理器，请选择该Processor Information对象而不是该Processor对象。\n5. 在实例列表中，选择_Total。\n6. 单击Add，然后单击确定OK。\n7. 选择新添加的触发器，然后单击确定Edit Thresholds。![图片](https://uploader.shimo.im/f/YLVYmJ9IXEsw2vyW.png!thumbnail)\n8. Above在下拉菜单中选择。\n9. 将阈值更改为80。\n10. 输入20秒数。您可以根据需要调整该值，但请注意不要指定小数秒，以防止错误触发。![图片](https://uploader.shimo.im/f/o4CEqvo7SO4tN36e.png!thumbnail)\n11. 点击OK。\n12. 点击Next。\n13. 点击Add Dump Target。\n14. Web Application Pool从下拉菜单中选择。\n15. 从应用程序池列表中选择您的应用程序池。\n16. 点击OK。\n17. 点击Next。\n18. Next再点击一次。\n19. 如果需要，请输入规则名称，并记下转储的保存位置。您可以根据需要更改此位置。\n20. 点击Next。\n21. 选择Activate the Rule Now并单击Finish。\n\n描述的规则将创建一组小型转储文件，这些文件的大小将非常小。最终转储将是具有完整内存的转储，并且该转储会更大。现在，我们只需要等待高CPU事件再次发生即可。\n\n将转储文件保存在所选文件夹中后，我们将使用DebugDiag Analysis工具来分析收集的数据：\n\n1. 选择性能分析器。![图片](https://uploader.shimo.im/f/TMJu2hTrqlgsk72i.png!thumbnail)\n2. 添加转储文件。![图片](https://uploader.shimo.im/f/FiLI9Fm8THwFbtHC.png!thumbnail)\n3. 开始分析。\n\nDebugDiag将花费几分钟（或数分钟）来解析转储并提供分析。完成分析后，您将看到一个网页，其中包含摘要以及有关线程的大量信息，类似于以下内容：\n\n![图片](https://uploader.shimo.im/f/g0Ju109AJTgK2mGc.png!thumbnail)\n\n正如您在摘要中看到的那样，有一条警告说：“在一个或多个线程上检测到转储文件之间的CPU使用率过高。” 如果单击建议，我们将开始了解应用程序存在问题的地方。我们的示例报告如下所示：\n\n![图片](https://uploader.shimo.im/f/8yUwhsUG7wg9LalW.png!thumbnail)\n\n正如我们在报告中看到的那样，有一个关于CPU使用率的模式。所有CPU使用率高的线程都与同一类相关。在跳到代码之前，让我们看一下第一个。\n\n![图片](https://uploader.shimo.im/f/UejsVGxAkYEiBRaH.png!thumbnail)\n\n这是我们遇到的第一个线程的细节。对我们来说有趣的部分是：\n\n![图片](https://uploader.shimo.im/f/oBHnRyDQWvU0RxZP.png!thumbnail)\n\n在这里，我们有一个代码调用，GameHub.OnDisconnected()该代码触发了有问题的操作，但是在此调用之前，我们有两个Dictionary调用，它们可以使您对发生的事情有所了解。让我们看一下.NET代码，看看该方法在做什么：\n\npublic override Task OnDisconnected() {\n\n    \ttry\n\n    \t{\n\n        \tvar userId = GetUserId();\n\n        \tstring connId;\n\n        \tif (onlineSessions.TryGetValue(userId, out connId))\n\n            \tonlineSessions.Remove(userId);\n\n    \t}\n\n    \tcatch (Exception)\n\n    \t{\n\n        \t// ignored\n\n    \t}\n\n    \treturn base.OnDisconnected();\n\n    \t}\n\n我们显然在这里有问题。报告的调用堆栈说问题出在字典上，在这段代码中我们正在访问字典，特别是引起问题的那一行是：\n\nif (onlineSessions.TryGetValue(userId, out connId))\n\n这是字典声明：\n\nstatic Dictionary<int, string> onlineSessions = new Dictionary<int, string>();\n\n## .NET代码有什么问题？\n具有面向对象编程经验的每个人都知道静态变量将由此类的所有实例共享。让我们更深入地了解.NET世界中静态的含义。\n\n根据.NET C＃规范：\n\n>使用[static](https://msdn.microsoft.com/en-us/library/98f28cdx.aspx)修饰符声明一个静态成员，该成员属于类型本身而不是特定对象。\n\n这就是.NET C＃语言规范关于[静态类和成员的说明](https://msdn.microsoft.com/en-us/library/79b3xss3.aspx)：\n\n>与所有类类型一样，当加载引用该类的程序时，.NET Framework公共语言运行库（CLR）将加载静态类的类型信息。程序无法确切指定何时加载类。但是，可以保证在程序中首次引用该类之前，将其加载并初始化其字段并调用其静态构造函数。静态构造函数仅被调用一次，并且静态类在程序所在的应用程序域的生存期内保留在内存中。\n>非静态类可以包含静态方法，字段，属性或事件。即使没有创建该类的实例，该静态成员也可以在该类上调用。始终通过类名称而不是实例名称访问静态成员。无论创建多少个类实例，静态成员只有一个副本。静态方法和属性无法访问其包含类型的非静态字段和事件，并且除非在方法参数中显式传递了实例变量，否则它们无法访问任何对象的实例变量。\n\n这意味着静态成员属于类型本身，而不是对象。它们也由CLR加载到应用程序域中，因此静态成员属于承载应用程序的进程，而不是特定线程。\n\n鉴于Web环境是多线程环境，因为每个请求都是由w3wp.exe进程产生的新线程；考虑到静态成员是该过程的一部分，我们可能会遇到以下情况：几个不同的线程尝试访问静态（由多个线程共享的）变量的数据，这最终可能会导致多线程问题。\n\n线程安全性下的Dictionary [文档](https://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.100%29.aspx)声明以下内容：\n\n>Dictionary<TKey, TValue>只要不修改集合，A 就可以同时支持多个阅读器。即使这样，通过集合进行枚举本质上也不是线程安全的过程。在极少的枚举与写访问竞争的情况下，必须在整个枚举期间锁定集合。要允许多个线程访问该集合进行读写，您必须实现自己的同步。\n\n此声明解释了为什么我们可能会遇到此问题。根据转储信息，问题出在字典的FindEntry方法上：\n\n![图片](https://uploader.shimo.im/f/RrbDyIKOrqQQ2qt0.png!thumbnail)\n\n如果查看字典的FindEntry [实现，](http://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,bcd13bb775d408f1)我们可以看到该方法遍历内部结构（存储桶）以查找值。\n\n因此，以下.NET代码枚举了集合，这不是线程安全的操作。\n\n```\npublic override Task OnDisconnected() {\n    \ttry\n    \t{\n        \tvar userId = GetUserId();\n        \tstring connId;\n        \tif (onlineSessions.TryGetValue(userId, out connId))\n            \tonlineSessions.Remove(userId);\n    \t}\n    \tcatch (Exception)\n    \t{\n        \t// ignored\n    \t}\n    \treturn base.OnDisconnected();\n\t}\n```\n## 结论\n正如我们在转储中看到的那样，有多个线程试图同时迭代和修改共享资源（静态字典），最终导致迭代进入无限循环，从而导致线程消耗超过90％的CPU。 。\n\n有几种可能的解决方案。我们首先实现的方法是锁定和同步对字典的访问，但会损失性能。那时服务器每天都崩溃，因此我们需要尽快解决此问题。即使这不是最佳解决方案，它也解决了该问题。\n\n解决这个问题的下一步是分析代码并找到最优解决方案。重构代码是一个选项:新的ConcurrentDictionary类可以解决这个问题，因为它只锁定在一个桶级别，这将提高整体性能。尽管这是一大步，还需要进一步的分析。\n\n","source":"_posts/技术/try-to-find-high-cpu-usage-in-netcore.md","raw":"---\ntitle:  在.NET应用程序中分析CPU使用率过高的问题\ndate: 2020-04-9 21:24\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n\n作者:胡安·帕勃罗·希达，JUAN PABLO SCIDA是一位软件架构师，在软件开发方面拥有10多年的经验。他是经过认证的.NET和Java开发人员。在过去的几年中，他还热衷于使用Node.js，MongoDB和Erlang。\n\n原文来自：[https://www.toptal.com/dot-net/hunting-high-cpu-usage-in-dot-net](https://www.toptal.com/dot-net/hunting-high-cpu-usage-in-dot-net)\n\n软件开发可能是一个非常复杂的过程。作为开发人员，我们需要考虑很多不同的变量。有些不在我们的控制之下，有些在实际代码执行时对我们来说是未知的，有些则由我们直接控制。 [.NET开发人员](https://www.toptal.com/dot-net)也毫不例外。\n\n考虑到这样的现实情况，当我们在受控环境中工作时，事情通常会按计划进行。假设就是我们的开发机器或我们可以完全访问的集成环境。我们可以使用工具来分析影响我们的代码和软件的不同变量。我们也不必处理服务器的繁重负载，也不必处理并发用户尝试同时执行相同操作的情况。\n\n在可描述和安全的情况下，我们的代码通常可以正常工作，但是在生产环境下，如果处于过度负载或其他一些外部因素的影响，可能会发生意外问题。生产环境的软件性能很难分析。在大多数情况下，我们必须在理论上处理潜在的问题：我们知道可能会发生问题，但无法测试。这就是为什么我们需要以我们所用语言的最佳实践和文档为基础进行开发，并避免[常见错误](https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make)。\n\n如前所述，当软件上线时，可能会出错，并且代码可能会以我们未计划的方式开始执行。当我们不得不处理问题而又无法调试或确定发生了什么情况时，我们可能会遇到这种情况。在这种情况下我们该怎么办？\n\n![图片](https://uploader.shimo.im/f/nLECb8q0ecw5UN4q.png!thumbnail)\n\n如果某个进程长时间使用超过90％的CPU，则我们会遇到麻烦\n\n\n在本文中，我们将分析基于Windows的服务器上. net web应用程序的高CPU使用率的实际案例场景、涉及到的识别问题的过程，以及更重要的问题，为什么会出现这个问题以及我们如何解决它。\n\nCPU使用率和内存消耗是广泛讨论的主题。通常，很难确定某个特定进程应使用的资源（CPU，RAM，I / O）的正确数量以及持续的时间段。尽管可以肯定的是-如果某个进程长时间使用了超过90％的CPU，那么我们将特别麻烦，因为在这种情况下服务器将无法处理任何其他请求。\n\n这是否意味着流程本身存在问题？不必要。该过程可能需要更多的处理能力，或者正在处理大量数据。首先，我们唯一能做的就是尝试确定发生这种情况的原因。\n\n所有操作系统都有几种不同的工具来监视服务器中发生的事情。Windows服务器专门具有任务管理器[Performance Monitor](https://technet.microsoft.com/en-us/library/cc749115.aspx)，在本例中，我们使用了[New Relic Servers](http://newrelic.com/server-monitoring)，它是监视服务器的绝佳工具。\n\n## 最初症状和问题分析\n部署应用程序后，在头两周的时间里，我们开始看到服务器的CPU使用率达到峰值，这使服务器无响应。为了使其再次可用，我们必须重新启动它，并且该事件在该时间段内发生了3次。如前所述，我们使用New Relic Servers作为服务器监视器，它表明w3wp.exe在服务器崩溃时，该进程占用了94％的CPU。\n\nInternet信息服务（IIS）工作进程是Windows进程（w3wp.exe），它运行Web应用程序，并负责处理发送到特定应用程序池的Web服务器的请求。IIS服务器可能有多个应用程序池（和几个不同的w3wp.exe进程），这些池可能会产生问题。根据该进程具有的用户（这在New Relic报告中显示），我们确定问题出在我们的.NET C＃Web表单旧版应用程序。\n\n.NET Framework与Windows调试工具紧密集成在一起，因此，我们要做的第一件事是查看事件查看器和应用程序日志文件，以查找有关正在发生的事情的有用信息。无论我们是否在事件查看器中记录了一些异常，它们都没有提供足够的数据来进行分析。这就是为什么我们决定更进一步并收集更多数据的原因，因此当事件再次发生时，我们将做好准备。\n\n## 数据采集\n收集用户模式进程转储的最简单方法是使用[Debug Diagnostic Tools v2.0](https://www.microsoft.com/en-us/download/details.aspx?id=49924)或仅使用DebugDiag。DebugDiag具有一组用于收集数据（DebugDiag集合）和分析数据（DebugDiag分析）的工具。\n\n因此，让我们开始定义使用调试诊断工具收集数据的规则：\n\n1. 打开DebugDiag集合，然后选择Performance。![图片](https://uploader.shimo.im/f/pUEaTdjUQ34gG4NI.png!thumbnail)\n2. 选择Performance Counters并单击Next。\n3. 点击Add Perf Triggers。\n4. 展开Processor（不是Process）对象，然后选择% Processor Time。请注意，如果您使用的是Windows Server 2008 R2，并且具有64个以上的处理器，请选择该Processor Information对象而不是该Processor对象。\n5. 在实例列表中，选择_Total。\n6. 单击Add，然后单击确定OK。\n7. 选择新添加的触发器，然后单击确定Edit Thresholds。![图片](https://uploader.shimo.im/f/YLVYmJ9IXEsw2vyW.png!thumbnail)\n8. Above在下拉菜单中选择。\n9. 将阈值更改为80。\n10. 输入20秒数。您可以根据需要调整该值，但请注意不要指定小数秒，以防止错误触发。![图片](https://uploader.shimo.im/f/o4CEqvo7SO4tN36e.png!thumbnail)\n11. 点击OK。\n12. 点击Next。\n13. 点击Add Dump Target。\n14. Web Application Pool从下拉菜单中选择。\n15. 从应用程序池列表中选择您的应用程序池。\n16. 点击OK。\n17. 点击Next。\n18. Next再点击一次。\n19. 如果需要，请输入规则名称，并记下转储的保存位置。您可以根据需要更改此位置。\n20. 点击Next。\n21. 选择Activate the Rule Now并单击Finish。\n\n描述的规则将创建一组小型转储文件，这些文件的大小将非常小。最终转储将是具有完整内存的转储，并且该转储会更大。现在，我们只需要等待高CPU事件再次发生即可。\n\n将转储文件保存在所选文件夹中后，我们将使用DebugDiag Analysis工具来分析收集的数据：\n\n1. 选择性能分析器。![图片](https://uploader.shimo.im/f/TMJu2hTrqlgsk72i.png!thumbnail)\n2. 添加转储文件。![图片](https://uploader.shimo.im/f/FiLI9Fm8THwFbtHC.png!thumbnail)\n3. 开始分析。\n\nDebugDiag将花费几分钟（或数分钟）来解析转储并提供分析。完成分析后，您将看到一个网页，其中包含摘要以及有关线程的大量信息，类似于以下内容：\n\n![图片](https://uploader.shimo.im/f/g0Ju109AJTgK2mGc.png!thumbnail)\n\n正如您在摘要中看到的那样，有一条警告说：“在一个或多个线程上检测到转储文件之间的CPU使用率过高。” 如果单击建议，我们将开始了解应用程序存在问题的地方。我们的示例报告如下所示：\n\n![图片](https://uploader.shimo.im/f/8yUwhsUG7wg9LalW.png!thumbnail)\n\n正如我们在报告中看到的那样，有一个关于CPU使用率的模式。所有CPU使用率高的线程都与同一类相关。在跳到代码之前，让我们看一下第一个。\n\n![图片](https://uploader.shimo.im/f/UejsVGxAkYEiBRaH.png!thumbnail)\n\n这是我们遇到的第一个线程的细节。对我们来说有趣的部分是：\n\n![图片](https://uploader.shimo.im/f/oBHnRyDQWvU0RxZP.png!thumbnail)\n\n在这里，我们有一个代码调用，GameHub.OnDisconnected()该代码触发了有问题的操作，但是在此调用之前，我们有两个Dictionary调用，它们可以使您对发生的事情有所了解。让我们看一下.NET代码，看看该方法在做什么：\n\npublic override Task OnDisconnected() {\n\n    \ttry\n\n    \t{\n\n        \tvar userId = GetUserId();\n\n        \tstring connId;\n\n        \tif (onlineSessions.TryGetValue(userId, out connId))\n\n            \tonlineSessions.Remove(userId);\n\n    \t}\n\n    \tcatch (Exception)\n\n    \t{\n\n        \t// ignored\n\n    \t}\n\n    \treturn base.OnDisconnected();\n\n    \t}\n\n我们显然在这里有问题。报告的调用堆栈说问题出在字典上，在这段代码中我们正在访问字典，特别是引起问题的那一行是：\n\nif (onlineSessions.TryGetValue(userId, out connId))\n\n这是字典声明：\n\nstatic Dictionary<int, string> onlineSessions = new Dictionary<int, string>();\n\n## .NET代码有什么问题？\n具有面向对象编程经验的每个人都知道静态变量将由此类的所有实例共享。让我们更深入地了解.NET世界中静态的含义。\n\n根据.NET C＃规范：\n\n>使用[static](https://msdn.microsoft.com/en-us/library/98f28cdx.aspx)修饰符声明一个静态成员，该成员属于类型本身而不是特定对象。\n\n这就是.NET C＃语言规范关于[静态类和成员的说明](https://msdn.microsoft.com/en-us/library/79b3xss3.aspx)：\n\n>与所有类类型一样，当加载引用该类的程序时，.NET Framework公共语言运行库（CLR）将加载静态类的类型信息。程序无法确切指定何时加载类。但是，可以保证在程序中首次引用该类之前，将其加载并初始化其字段并调用其静态构造函数。静态构造函数仅被调用一次，并且静态类在程序所在的应用程序域的生存期内保留在内存中。\n>非静态类可以包含静态方法，字段，属性或事件。即使没有创建该类的实例，该静态成员也可以在该类上调用。始终通过类名称而不是实例名称访问静态成员。无论创建多少个类实例，静态成员只有一个副本。静态方法和属性无法访问其包含类型的非静态字段和事件，并且除非在方法参数中显式传递了实例变量，否则它们无法访问任何对象的实例变量。\n\n这意味着静态成员属于类型本身，而不是对象。它们也由CLR加载到应用程序域中，因此静态成员属于承载应用程序的进程，而不是特定线程。\n\n鉴于Web环境是多线程环境，因为每个请求都是由w3wp.exe进程产生的新线程；考虑到静态成员是该过程的一部分，我们可能会遇到以下情况：几个不同的线程尝试访问静态（由多个线程共享的）变量的数据，这最终可能会导致多线程问题。\n\n线程安全性下的Dictionary [文档](https://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.100%29.aspx)声明以下内容：\n\n>Dictionary<TKey, TValue>只要不修改集合，A 就可以同时支持多个阅读器。即使这样，通过集合进行枚举本质上也不是线程安全的过程。在极少的枚举与写访问竞争的情况下，必须在整个枚举期间锁定集合。要允许多个线程访问该集合进行读写，您必须实现自己的同步。\n\n此声明解释了为什么我们可能会遇到此问题。根据转储信息，问题出在字典的FindEntry方法上：\n\n![图片](https://uploader.shimo.im/f/RrbDyIKOrqQQ2qt0.png!thumbnail)\n\n如果查看字典的FindEntry [实现，](http://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,bcd13bb775d408f1)我们可以看到该方法遍历内部结构（存储桶）以查找值。\n\n因此，以下.NET代码枚举了集合，这不是线程安全的操作。\n\n```\npublic override Task OnDisconnected() {\n    \ttry\n    \t{\n        \tvar userId = GetUserId();\n        \tstring connId;\n        \tif (onlineSessions.TryGetValue(userId, out connId))\n            \tonlineSessions.Remove(userId);\n    \t}\n    \tcatch (Exception)\n    \t{\n        \t// ignored\n    \t}\n    \treturn base.OnDisconnected();\n\t}\n```\n## 结论\n正如我们在转储中看到的那样，有多个线程试图同时迭代和修改共享资源（静态字典），最终导致迭代进入无限循环，从而导致线程消耗超过90％的CPU。 。\n\n有几种可能的解决方案。我们首先实现的方法是锁定和同步对字典的访问，但会损失性能。那时服务器每天都崩溃，因此我们需要尽快解决此问题。即使这不是最佳解决方案，它也解决了该问题。\n\n解决这个问题的下一步是分析代码并找到最优解决方案。重构代码是一个选项:新的ConcurrentDictionary类可以解决这个问题，因为它只锁定在一个桶级别，这将提高整体性能。尽管这是一大步，还需要进一步的分析。\n\n","slug":"技术/try-to-find-high-cpu-usage-in-netcore","published":1,"updated":"2020-04-09T13:38:26.101Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt74000mn4vig1utmtje","content":"<p>作者:胡安·帕勃罗·希达，JUAN PABLO SCIDA是一位软件架构师，在软件开发方面拥有10多年的经验。他是经过认证的.NET和Java开发人员。在过去的几年中，他还热衷于使用Node.js，MongoDB和Erlang。</p>\n<p>原文来自：<a href=\"https://www.toptal.com/dot-net/hunting-high-cpu-usage-in-dot-net\" target=\"_blank\" rel=\"noopener\">https://www.toptal.com/dot-net/hunting-high-cpu-usage-in-dot-net</a></p>\n<p>软件开发可能是一个非常复杂的过程。作为开发人员，我们需要考虑很多不同的变量。有些不在我们的控制之下，有些在实际代码执行时对我们来说是未知的，有些则由我们直接控制。 <a href=\"https://www.toptal.com/dot-net\" target=\"_blank\" rel=\"noopener\">.NET开发人员</a>也毫不例外。</p>\n<p>考虑到这样的现实情况，当我们在受控环境中工作时，事情通常会按计划进行。假设就是我们的开发机器或我们可以完全访问的集成环境。我们可以使用工具来分析影响我们的代码和软件的不同变量。我们也不必处理服务器的繁重负载，也不必处理并发用户尝试同时执行相同操作的情况。</p>\n<p>在可描述和安全的情况下，我们的代码通常可以正常工作，但是在生产环境下，如果处于过度负载或其他一些外部因素的影响，可能会发生意外问题。生产环境的软件性能很难分析。在大多数情况下，我们必须在理论上处理潜在的问题：我们知道可能会发生问题，但无法测试。这就是为什么我们需要以我们所用语言的最佳实践和文档为基础进行开发，并避免<a href=\"https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make\" target=\"_blank\" rel=\"noopener\">常见错误</a>。</p>\n<p>如前所述，当软件上线时，可能会出错，并且代码可能会以我们未计划的方式开始执行。当我们不得不处理问题而又无法调试或确定发生了什么情况时，我们可能会遇到这种情况。在这种情况下我们该怎么办？</p>\n<p><img src=\"https://uploader.shimo.im/f/nLECb8q0ecw5UN4q.png!thumbnail\" alt=\"图片\"></p>\n<p>如果某个进程长时间使用超过90％的CPU，则我们会遇到麻烦</p>\n<p>在本文中，我们将分析基于Windows的服务器上. net web应用程序的高CPU使用率的实际案例场景、涉及到的识别问题的过程，以及更重要的问题，为什么会出现这个问题以及我们如何解决它。</p>\n<p>CPU使用率和内存消耗是广泛讨论的主题。通常，很难确定某个特定进程应使用的资源（CPU，RAM，I / O）的正确数量以及持续的时间段。尽管可以肯定的是-如果某个进程长时间使用了超过90％的CPU，那么我们将特别麻烦，因为在这种情况下服务器将无法处理任何其他请求。</p>\n<p>这是否意味着流程本身存在问题？不必要。该过程可能需要更多的处理能力，或者正在处理大量数据。首先，我们唯一能做的就是尝试确定发生这种情况的原因。</p>\n<p>所有操作系统都有几种不同的工具来监视服务器中发生的事情。Windows服务器专门具有任务管理器<a href=\"https://technet.microsoft.com/en-us/library/cc749115.aspx\" target=\"_blank\" rel=\"noopener\">Performance Monitor</a>，在本例中，我们使用了<a href=\"http://newrelic.com/server-monitoring\" target=\"_blank\" rel=\"noopener\">New Relic Servers</a>，它是监视服务器的绝佳工具。</p>\n<h2 id=\"最初症状和问题分析\"><a href=\"#最初症状和问题分析\" class=\"headerlink\" title=\"最初症状和问题分析\"></a>最初症状和问题分析</h2><p>部署应用程序后，在头两周的时间里，我们开始看到服务器的CPU使用率达到峰值，这使服务器无响应。为了使其再次可用，我们必须重新启动它，并且该事件在该时间段内发生了3次。如前所述，我们使用New Relic Servers作为服务器监视器，它表明w3wp.exe在服务器崩溃时，该进程占用了94％的CPU。</p>\n<p>Internet信息服务（IIS）工作进程是Windows进程（w3wp.exe），它运行Web应用程序，并负责处理发送到特定应用程序池的Web服务器的请求。IIS服务器可能有多个应用程序池（和几个不同的w3wp.exe进程），这些池可能会产生问题。根据该进程具有的用户（这在New Relic报告中显示），我们确定问题出在我们的.NET C＃Web表单旧版应用程序。</p>\n<p>.NET Framework与Windows调试工具紧密集成在一起，因此，我们要做的第一件事是查看事件查看器和应用程序日志文件，以查找有关正在发生的事情的有用信息。无论我们是否在事件查看器中记录了一些异常，它们都没有提供足够的数据来进行分析。这就是为什么我们决定更进一步并收集更多数据的原因，因此当事件再次发生时，我们将做好准备。</p>\n<h2 id=\"数据采集\"><a href=\"#数据采集\" class=\"headerlink\" title=\"数据采集\"></a>数据采集</h2><p>收集用户模式进程转储的最简单方法是使用<a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=49924\" target=\"_blank\" rel=\"noopener\">Debug Diagnostic Tools v2.0</a>或仅使用DebugDiag。DebugDiag具有一组用于收集数据（DebugDiag集合）和分析数据（DebugDiag分析）的工具。</p>\n<p>因此，让我们开始定义使用调试诊断工具收集数据的规则：</p>\n<ol>\n<li>打开DebugDiag集合，然后选择Performance。<img src=\"https://uploader.shimo.im/f/pUEaTdjUQ34gG4NI.png!thumbnail\" alt=\"图片\"></li>\n<li>选择Performance Counters并单击Next。</li>\n<li>点击Add Perf Triggers。</li>\n<li>展开Processor（不是Process）对象，然后选择% Processor Time。请注意，如果您使用的是Windows Server 2008 R2，并且具有64个以上的处理器，请选择该Processor Information对象而不是该Processor对象。</li>\n<li>在实例列表中，选择_Total。</li>\n<li>单击Add，然后单击确定OK。</li>\n<li>选择新添加的触发器，然后单击确定Edit Thresholds。<img src=\"https://uploader.shimo.im/f/YLVYmJ9IXEsw2vyW.png!thumbnail\" alt=\"图片\"></li>\n<li>Above在下拉菜单中选择。</li>\n<li>将阈值更改为80。</li>\n<li>输入20秒数。您可以根据需要调整该值，但请注意不要指定小数秒，以防止错误触发。<img src=\"https://uploader.shimo.im/f/o4CEqvo7SO4tN36e.png!thumbnail\" alt=\"图片\"></li>\n<li>点击OK。</li>\n<li>点击Next。</li>\n<li>点击Add Dump Target。</li>\n<li>Web Application Pool从下拉菜单中选择。</li>\n<li>从应用程序池列表中选择您的应用程序池。</li>\n<li>点击OK。</li>\n<li>点击Next。</li>\n<li>Next再点击一次。</li>\n<li>如果需要，请输入规则名称，并记下转储的保存位置。您可以根据需要更改此位置。</li>\n<li>点击Next。</li>\n<li>选择Activate the Rule Now并单击Finish。</li>\n</ol>\n<p>描述的规则将创建一组小型转储文件，这些文件的大小将非常小。最终转储将是具有完整内存的转储，并且该转储会更大。现在，我们只需要等待高CPU事件再次发生即可。</p>\n<p>将转储文件保存在所选文件夹中后，我们将使用DebugDiag Analysis工具来分析收集的数据：</p>\n<ol>\n<li>选择性能分析器。<img src=\"https://uploader.shimo.im/f/TMJu2hTrqlgsk72i.png!thumbnail\" alt=\"图片\"></li>\n<li>添加转储文件。<img src=\"https://uploader.shimo.im/f/FiLI9Fm8THwFbtHC.png!thumbnail\" alt=\"图片\"></li>\n<li>开始分析。</li>\n</ol>\n<p>DebugDiag将花费几分钟（或数分钟）来解析转储并提供分析。完成分析后，您将看到一个网页，其中包含摘要以及有关线程的大量信息，类似于以下内容：</p>\n<p><img src=\"https://uploader.shimo.im/f/g0Ju109AJTgK2mGc.png!thumbnail\" alt=\"图片\"></p>\n<p>正如您在摘要中看到的那样，有一条警告说：“在一个或多个线程上检测到转储文件之间的CPU使用率过高。” 如果单击建议，我们将开始了解应用程序存在问题的地方。我们的示例报告如下所示：</p>\n<p><img src=\"https://uploader.shimo.im/f/8yUwhsUG7wg9LalW.png!thumbnail\" alt=\"图片\"></p>\n<p>正如我们在报告中看到的那样，有一个关于CPU使用率的模式。所有CPU使用率高的线程都与同一类相关。在跳到代码之前，让我们看一下第一个。</p>\n<p><img src=\"https://uploader.shimo.im/f/UejsVGxAkYEiBRaH.png!thumbnail\" alt=\"图片\"></p>\n<p>这是我们遇到的第一个线程的细节。对我们来说有趣的部分是：</p>\n<p><img src=\"https://uploader.shimo.im/f/oBHnRyDQWvU0RxZP.png!thumbnail\" alt=\"图片\"></p>\n<p>在这里，我们有一个代码调用，GameHub.OnDisconnected()该代码触发了有问题的操作，但是在此调用之前，我们有两个Dictionary调用，它们可以使您对发生的事情有所了解。让我们看一下.NET代码，看看该方法在做什么：</p>\n<p>public override Task OnDisconnected() {</p>\n<pre><code>try\n\n{\n\n    var userId = GetUserId();\n\n    string connId;\n\n    if (onlineSessions.TryGetValue(userId, out connId))\n\n        onlineSessions.Remove(userId);\n\n}\n\ncatch (Exception)\n\n{\n\n    // ignored\n\n}\n\nreturn base.OnDisconnected();\n\n}</code></pre><p>我们显然在这里有问题。报告的调用堆栈说问题出在字典上，在这段代码中我们正在访问字典，特别是引起问题的那一行是：</p>\n<p>if (onlineSessions.TryGetValue(userId, out connId))</p>\n<p>这是字典声明：</p>\n<p>static Dictionary&lt;int, string&gt; onlineSessions = new Dictionary&lt;int, string&gt;();</p>\n<h2 id=\"NET代码有什么问题？\"><a href=\"#NET代码有什么问题？\" class=\"headerlink\" title=\".NET代码有什么问题？\"></a>.NET代码有什么问题？</h2><p>具有面向对象编程经验的每个人都知道静态变量将由此类的所有实例共享。让我们更深入地了解.NET世界中静态的含义。</p>\n<p>根据.NET C＃规范：</p>\n<blockquote>\n<p>使用<a href=\"https://msdn.microsoft.com/en-us/library/98f28cdx.aspx\" target=\"_blank\" rel=\"noopener\">static</a>修饰符声明一个静态成员，该成员属于类型本身而不是特定对象。</p>\n</blockquote>\n<p>这就是.NET C＃语言规范关于<a href=\"https://msdn.microsoft.com/en-us/library/79b3xss3.aspx\" target=\"_blank\" rel=\"noopener\">静态类和成员的说明</a>：</p>\n<blockquote>\n<p>与所有类类型一样，当加载引用该类的程序时，.NET Framework公共语言运行库（CLR）将加载静态类的类型信息。程序无法确切指定何时加载类。但是，可以保证在程序中首次引用该类之前，将其加载并初始化其字段并调用其静态构造函数。静态构造函数仅被调用一次，并且静态类在程序所在的应用程序域的生存期内保留在内存中。<br>非静态类可以包含静态方法，字段，属性或事件。即使没有创建该类的实例，该静态成员也可以在该类上调用。始终通过类名称而不是实例名称访问静态成员。无论创建多少个类实例，静态成员只有一个副本。静态方法和属性无法访问其包含类型的非静态字段和事件，并且除非在方法参数中显式传递了实例变量，否则它们无法访问任何对象的实例变量。</p>\n</blockquote>\n<p>这意味着静态成员属于类型本身，而不是对象。它们也由CLR加载到应用程序域中，因此静态成员属于承载应用程序的进程，而不是特定线程。</p>\n<p>鉴于Web环境是多线程环境，因为每个请求都是由w3wp.exe进程产生的新线程；考虑到静态成员是该过程的一部分，我们可能会遇到以下情况：几个不同的线程尝试访问静态（由多个线程共享的）变量的数据，这最终可能会导致多线程问题。</p>\n<p>线程安全性下的Dictionary <a href=\"https://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.100%29.aspx\" target=\"_blank\" rel=\"noopener\">文档</a>声明以下内容：</p>\n<blockquote>\n<p>Dictionary&lt;TKey, TValue&gt;只要不修改集合，A 就可以同时支持多个阅读器。即使这样，通过集合进行枚举本质上也不是线程安全的过程。在极少的枚举与写访问竞争的情况下，必须在整个枚举期间锁定集合。要允许多个线程访问该集合进行读写，您必须实现自己的同步。</p>\n</blockquote>\n<p>此声明解释了为什么我们可能会遇到此问题。根据转储信息，问题出在字典的FindEntry方法上：</p>\n<p><img src=\"https://uploader.shimo.im/f/RrbDyIKOrqQQ2qt0.png!thumbnail\" alt=\"图片\"></p>\n<p>如果查看字典的FindEntry <a href=\"http://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,bcd13bb775d408f1\" target=\"_blank\" rel=\"noopener\">实现，</a>我们可以看到该方法遍历内部结构（存储桶）以查找值。</p>\n<p>因此，以下.NET代码枚举了集合，这不是线程安全的操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public override Task OnDisconnected() &#123;</span><br><span class=\"line\">    \ttry</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">        \tvar userId = GetUserId();</span><br><span class=\"line\">        \tstring connId;</span><br><span class=\"line\">        \tif (onlineSessions.TryGetValue(userId, out connId))</span><br><span class=\"line\">            \tonlineSessions.Remove(userId);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \tcatch (Exception)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">        \t// ignored</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \treturn base.OnDisconnected();</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>正如我们在转储中看到的那样，有多个线程试图同时迭代和修改共享资源（静态字典），最终导致迭代进入无限循环，从而导致线程消耗超过90％的CPU。 。</p>\n<p>有几种可能的解决方案。我们首先实现的方法是锁定和同步对字典的访问，但会损失性能。那时服务器每天都崩溃，因此我们需要尽快解决此问题。即使这不是最佳解决方案，它也解决了该问题。</p>\n<p>解决这个问题的下一步是分析代码并找到最优解决方案。重构代码是一个选项:新的ConcurrentDictionary类可以解决这个问题，因为它只锁定在一个桶级别，这将提高整体性能。尽管这是一大步，还需要进一步的分析。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>作者:胡安·帕勃罗·希达，JUAN PABLO SCIDA是一位软件架构师，在软件开发方面拥有10多年的经验。他是经过认证的.NET和Java开发人员。在过去的几年中，他还热衷于使用Node.js，MongoDB和Erlang。</p>\n<p>原文来自：<a href=\"https://www.toptal.com/dot-net/hunting-high-cpu-usage-in-dot-net\" target=\"_blank\" rel=\"noopener\">https://www.toptal.com/dot-net/hunting-high-cpu-usage-in-dot-net</a></p>\n<p>软件开发可能是一个非常复杂的过程。作为开发人员，我们需要考虑很多不同的变量。有些不在我们的控制之下，有些在实际代码执行时对我们来说是未知的，有些则由我们直接控制。 <a href=\"https://www.toptal.com/dot-net\" target=\"_blank\" rel=\"noopener\">.NET开发人员</a>也毫不例外。</p>\n<p>考虑到这样的现实情况，当我们在受控环境中工作时，事情通常会按计划进行。假设就是我们的开发机器或我们可以完全访问的集成环境。我们可以使用工具来分析影响我们的代码和软件的不同变量。我们也不必处理服务器的繁重负载，也不必处理并发用户尝试同时执行相同操作的情况。</p>\n<p>在可描述和安全的情况下，我们的代码通常可以正常工作，但是在生产环境下，如果处于过度负载或其他一些外部因素的影响，可能会发生意外问题。生产环境的软件性能很难分析。在大多数情况下，我们必须在理论上处理潜在的问题：我们知道可能会发生问题，但无法测试。这就是为什么我们需要以我们所用语言的最佳实践和文档为基础进行开发，并避免<a href=\"https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make\" target=\"_blank\" rel=\"noopener\">常见错误</a>。</p>\n<p>如前所述，当软件上线时，可能会出错，并且代码可能会以我们未计划的方式开始执行。当我们不得不处理问题而又无法调试或确定发生了什么情况时，我们可能会遇到这种情况。在这种情况下我们该怎么办？</p>\n<p><img src=\"https://uploader.shimo.im/f/nLECb8q0ecw5UN4q.png!thumbnail\" alt=\"图片\"></p>\n<p>如果某个进程长时间使用超过90％的CPU，则我们会遇到麻烦</p>\n<p>在本文中，我们将分析基于Windows的服务器上. net web应用程序的高CPU使用率的实际案例场景、涉及到的识别问题的过程，以及更重要的问题，为什么会出现这个问题以及我们如何解决它。</p>\n<p>CPU使用率和内存消耗是广泛讨论的主题。通常，很难确定某个特定进程应使用的资源（CPU，RAM，I / O）的正确数量以及持续的时间段。尽管可以肯定的是-如果某个进程长时间使用了超过90％的CPU，那么我们将特别麻烦，因为在这种情况下服务器将无法处理任何其他请求。</p>\n<p>这是否意味着流程本身存在问题？不必要。该过程可能需要更多的处理能力，或者正在处理大量数据。首先，我们唯一能做的就是尝试确定发生这种情况的原因。</p>\n<p>所有操作系统都有几种不同的工具来监视服务器中发生的事情。Windows服务器专门具有任务管理器<a href=\"https://technet.microsoft.com/en-us/library/cc749115.aspx\" target=\"_blank\" rel=\"noopener\">Performance Monitor</a>，在本例中，我们使用了<a href=\"http://newrelic.com/server-monitoring\" target=\"_blank\" rel=\"noopener\">New Relic Servers</a>，它是监视服务器的绝佳工具。</p>\n<h2 id=\"最初症状和问题分析\"><a href=\"#最初症状和问题分析\" class=\"headerlink\" title=\"最初症状和问题分析\"></a>最初症状和问题分析</h2><p>部署应用程序后，在头两周的时间里，我们开始看到服务器的CPU使用率达到峰值，这使服务器无响应。为了使其再次可用，我们必须重新启动它，并且该事件在该时间段内发生了3次。如前所述，我们使用New Relic Servers作为服务器监视器，它表明w3wp.exe在服务器崩溃时，该进程占用了94％的CPU。</p>\n<p>Internet信息服务（IIS）工作进程是Windows进程（w3wp.exe），它运行Web应用程序，并负责处理发送到特定应用程序池的Web服务器的请求。IIS服务器可能有多个应用程序池（和几个不同的w3wp.exe进程），这些池可能会产生问题。根据该进程具有的用户（这在New Relic报告中显示），我们确定问题出在我们的.NET C＃Web表单旧版应用程序。</p>\n<p>.NET Framework与Windows调试工具紧密集成在一起，因此，我们要做的第一件事是查看事件查看器和应用程序日志文件，以查找有关正在发生的事情的有用信息。无论我们是否在事件查看器中记录了一些异常，它们都没有提供足够的数据来进行分析。这就是为什么我们决定更进一步并收集更多数据的原因，因此当事件再次发生时，我们将做好准备。</p>\n<h2 id=\"数据采集\"><a href=\"#数据采集\" class=\"headerlink\" title=\"数据采集\"></a>数据采集</h2><p>收集用户模式进程转储的最简单方法是使用<a href=\"https://www.microsoft.com/en-us/download/details.aspx?id=49924\" target=\"_blank\" rel=\"noopener\">Debug Diagnostic Tools v2.0</a>或仅使用DebugDiag。DebugDiag具有一组用于收集数据（DebugDiag集合）和分析数据（DebugDiag分析）的工具。</p>\n<p>因此，让我们开始定义使用调试诊断工具收集数据的规则：</p>\n<ol>\n<li>打开DebugDiag集合，然后选择Performance。<img src=\"https://uploader.shimo.im/f/pUEaTdjUQ34gG4NI.png!thumbnail\" alt=\"图片\"></li>\n<li>选择Performance Counters并单击Next。</li>\n<li>点击Add Perf Triggers。</li>\n<li>展开Processor（不是Process）对象，然后选择% Processor Time。请注意，如果您使用的是Windows Server 2008 R2，并且具有64个以上的处理器，请选择该Processor Information对象而不是该Processor对象。</li>\n<li>在实例列表中，选择_Total。</li>\n<li>单击Add，然后单击确定OK。</li>\n<li>选择新添加的触发器，然后单击确定Edit Thresholds。<img src=\"https://uploader.shimo.im/f/YLVYmJ9IXEsw2vyW.png!thumbnail\" alt=\"图片\"></li>\n<li>Above在下拉菜单中选择。</li>\n<li>将阈值更改为80。</li>\n<li>输入20秒数。您可以根据需要调整该值，但请注意不要指定小数秒，以防止错误触发。<img src=\"https://uploader.shimo.im/f/o4CEqvo7SO4tN36e.png!thumbnail\" alt=\"图片\"></li>\n<li>点击OK。</li>\n<li>点击Next。</li>\n<li>点击Add Dump Target。</li>\n<li>Web Application Pool从下拉菜单中选择。</li>\n<li>从应用程序池列表中选择您的应用程序池。</li>\n<li>点击OK。</li>\n<li>点击Next。</li>\n<li>Next再点击一次。</li>\n<li>如果需要，请输入规则名称，并记下转储的保存位置。您可以根据需要更改此位置。</li>\n<li>点击Next。</li>\n<li>选择Activate the Rule Now并单击Finish。</li>\n</ol>\n<p>描述的规则将创建一组小型转储文件，这些文件的大小将非常小。最终转储将是具有完整内存的转储，并且该转储会更大。现在，我们只需要等待高CPU事件再次发生即可。</p>\n<p>将转储文件保存在所选文件夹中后，我们将使用DebugDiag Analysis工具来分析收集的数据：</p>\n<ol>\n<li>选择性能分析器。<img src=\"https://uploader.shimo.im/f/TMJu2hTrqlgsk72i.png!thumbnail\" alt=\"图片\"></li>\n<li>添加转储文件。<img src=\"https://uploader.shimo.im/f/FiLI9Fm8THwFbtHC.png!thumbnail\" alt=\"图片\"></li>\n<li>开始分析。</li>\n</ol>\n<p>DebugDiag将花费几分钟（或数分钟）来解析转储并提供分析。完成分析后，您将看到一个网页，其中包含摘要以及有关线程的大量信息，类似于以下内容：</p>\n<p><img src=\"https://uploader.shimo.im/f/g0Ju109AJTgK2mGc.png!thumbnail\" alt=\"图片\"></p>\n<p>正如您在摘要中看到的那样，有一条警告说：“在一个或多个线程上检测到转储文件之间的CPU使用率过高。” 如果单击建议，我们将开始了解应用程序存在问题的地方。我们的示例报告如下所示：</p>\n<p><img src=\"https://uploader.shimo.im/f/8yUwhsUG7wg9LalW.png!thumbnail\" alt=\"图片\"></p>\n<p>正如我们在报告中看到的那样，有一个关于CPU使用率的模式。所有CPU使用率高的线程都与同一类相关。在跳到代码之前，让我们看一下第一个。</p>\n<p><img src=\"https://uploader.shimo.im/f/UejsVGxAkYEiBRaH.png!thumbnail\" alt=\"图片\"></p>\n<p>这是我们遇到的第一个线程的细节。对我们来说有趣的部分是：</p>\n<p><img src=\"https://uploader.shimo.im/f/oBHnRyDQWvU0RxZP.png!thumbnail\" alt=\"图片\"></p>\n<p>在这里，我们有一个代码调用，GameHub.OnDisconnected()该代码触发了有问题的操作，但是在此调用之前，我们有两个Dictionary调用，它们可以使您对发生的事情有所了解。让我们看一下.NET代码，看看该方法在做什么：</p>\n<p>public override Task OnDisconnected() {</p>\n<pre><code>try\n\n{\n\n    var userId = GetUserId();\n\n    string connId;\n\n    if (onlineSessions.TryGetValue(userId, out connId))\n\n        onlineSessions.Remove(userId);\n\n}\n\ncatch (Exception)\n\n{\n\n    // ignored\n\n}\n\nreturn base.OnDisconnected();\n\n}</code></pre><p>我们显然在这里有问题。报告的调用堆栈说问题出在字典上，在这段代码中我们正在访问字典，特别是引起问题的那一行是：</p>\n<p>if (onlineSessions.TryGetValue(userId, out connId))</p>\n<p>这是字典声明：</p>\n<p>static Dictionary&lt;int, string&gt; onlineSessions = new Dictionary&lt;int, string&gt;();</p>\n<h2 id=\"NET代码有什么问题？\"><a href=\"#NET代码有什么问题？\" class=\"headerlink\" title=\".NET代码有什么问题？\"></a>.NET代码有什么问题？</h2><p>具有面向对象编程经验的每个人都知道静态变量将由此类的所有实例共享。让我们更深入地了解.NET世界中静态的含义。</p>\n<p>根据.NET C＃规范：</p>\n<blockquote>\n<p>使用<a href=\"https://msdn.microsoft.com/en-us/library/98f28cdx.aspx\" target=\"_blank\" rel=\"noopener\">static</a>修饰符声明一个静态成员，该成员属于类型本身而不是特定对象。</p>\n</blockquote>\n<p>这就是.NET C＃语言规范关于<a href=\"https://msdn.microsoft.com/en-us/library/79b3xss3.aspx\" target=\"_blank\" rel=\"noopener\">静态类和成员的说明</a>：</p>\n<blockquote>\n<p>与所有类类型一样，当加载引用该类的程序时，.NET Framework公共语言运行库（CLR）将加载静态类的类型信息。程序无法确切指定何时加载类。但是，可以保证在程序中首次引用该类之前，将其加载并初始化其字段并调用其静态构造函数。静态构造函数仅被调用一次，并且静态类在程序所在的应用程序域的生存期内保留在内存中。<br>非静态类可以包含静态方法，字段，属性或事件。即使没有创建该类的实例，该静态成员也可以在该类上调用。始终通过类名称而不是实例名称访问静态成员。无论创建多少个类实例，静态成员只有一个副本。静态方法和属性无法访问其包含类型的非静态字段和事件，并且除非在方法参数中显式传递了实例变量，否则它们无法访问任何对象的实例变量。</p>\n</blockquote>\n<p>这意味着静态成员属于类型本身，而不是对象。它们也由CLR加载到应用程序域中，因此静态成员属于承载应用程序的进程，而不是特定线程。</p>\n<p>鉴于Web环境是多线程环境，因为每个请求都是由w3wp.exe进程产生的新线程；考虑到静态成员是该过程的一部分，我们可能会遇到以下情况：几个不同的线程尝试访问静态（由多个线程共享的）变量的数据，这最终可能会导致多线程问题。</p>\n<p>线程安全性下的Dictionary <a href=\"https://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.100%29.aspx\" target=\"_blank\" rel=\"noopener\">文档</a>声明以下内容：</p>\n<blockquote>\n<p>Dictionary&lt;TKey, TValue&gt;只要不修改集合，A 就可以同时支持多个阅读器。即使这样，通过集合进行枚举本质上也不是线程安全的过程。在极少的枚举与写访问竞争的情况下，必须在整个枚举期间锁定集合。要允许多个线程访问该集合进行读写，您必须实现自己的同步。</p>\n</blockquote>\n<p>此声明解释了为什么我们可能会遇到此问题。根据转储信息，问题出在字典的FindEntry方法上：</p>\n<p><img src=\"https://uploader.shimo.im/f/RrbDyIKOrqQQ2qt0.png!thumbnail\" alt=\"图片\"></p>\n<p>如果查看字典的FindEntry <a href=\"http://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,bcd13bb775d408f1\" target=\"_blank\" rel=\"noopener\">实现，</a>我们可以看到该方法遍历内部结构（存储桶）以查找值。</p>\n<p>因此，以下.NET代码枚举了集合，这不是线程安全的操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public override Task OnDisconnected() &#123;</span><br><span class=\"line\">    \ttry</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">        \tvar userId = GetUserId();</span><br><span class=\"line\">        \tstring connId;</span><br><span class=\"line\">        \tif (onlineSessions.TryGetValue(userId, out connId))</span><br><span class=\"line\">            \tonlineSessions.Remove(userId);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \tcatch (Exception)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">        \t// ignored</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \treturn base.OnDisconnected();</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>正如我们在转储中看到的那样，有多个线程试图同时迭代和修改共享资源（静态字典），最终导致迭代进入无限循环，从而导致线程消耗超过90％的CPU。 。</p>\n<p>有几种可能的解决方案。我们首先实现的方法是锁定和同步对字典的访问，但会损失性能。那时服务器每天都崩溃，因此我们需要尽快解决此问题。即使这不是最佳解决方案，它也解决了该问题。</p>\n<p>解决这个问题的下一步是分析代码并找到最优解决方案。重构代码是一个选项:新的ConcurrentDictionary类可以解决这个问题，因为它只锁定在一个桶级别，这将提高整体性能。尽管这是一大步，还需要进一步的分析。</p>\n"},{"title":"了解.NET中的垃圾回收","date":"2020-04-05T08:28:00.000Z","author":"邹溪源","_content":"# 了解.NET中的垃圾回收\n\n>  一旦了解了.NET的垃圾收集器是如何工作的，那么可能会触及.NET应用程序的一些更为神秘的问题的原因就会变得更加清楚。NET可能已承诺要结束显式内存管理，但在开发.NET应用程序时，仍然有必要分析内存的使用情况，以便避免与内存相关的错误和某些性能问题。 \n\n.NET的垃圾收集器已在Windows应用程序中作为显式内存管理和内存泄漏的结束而出售给我们：这个想法是，在后台运行垃圾收集器的情况下，开发人员不再需要担心管理它们创建的对象的生命周期–应用程序完成处理后，垃圾收集器将对其进行处理。\n\n但是，实际情况要复杂得多。垃圾收集器无疑解决了非托管程序中最常见的泄漏-由开发人员在完成使用后忘记释放内存而引起的泄漏。它还解决了内存释放过早的相关问题，但是当垃圾收集器对开发人员对对象是否仍然处于“活动状态”并且能够进行开发时有不同的看法时，解决该问题的方式可能导致内存泄漏。要使用的。解决这些问题之前，您需要对收集器的工作方式有所了解。\n\n# 垃圾收集器如何工作\n\n那么，垃圾收集器如何实现其魔力？基本思想非常简单：它检查对象在内存中的布局方式，并通过遵循一系列引用来标识正在运行的程序可以“访问”的所有那些对象。\n\n当垃圾回收开始时，它将查看一组称为“ GC根”的引用。这些是由于某种原因总是可以访问的内存位置，并且包含对程序创建的对象的引用。它将这些对象标记为“活动”，然后查看它们引用的所有对象。它也将这些标记为“实时”。它以这种方式继续，遍历它知道是“活动”的所有对象。它将它们引用的所有内容都标记为也被使用，直到找不到其他对象为止。\n\n如果某个对象或其超类之一的字段包含另一个对象，则该对象由垃圾收集器标识为引用另一个对象。\n\n一旦知道了所有这些活动对象，就可以丢弃所有剩余的对象，并将空间重新用于新对象。.NET压缩内存，以确保没有间隙（有效地压缩丢弃的对象不存在）–这意味着空闲内存始终位于堆的末尾，并可以非常快速地分配新对象。\n\nGC根本身不是对象，而是对对象的引用。GC根引用的任何对象将自动在下一个垃圾回收中保留下来。.NET中有四种主要的根：\n\n当前正在运行的方法中的局部变量被视为GC根。这些变量引用的对象始终可以通过声明它们的方法立即访问，因此必须保留它们。这些根的生命周期可以取决于程序的构建方式。在调试版本中，局部变量的持续时间与方法在堆栈上的时间一样长。在发行版本中，JIT能够查看程序结构以找出执行过程中该方法可以使用变量的最后一点，并在不再需要该变量时将其丢弃。这种策略并不总是使用，可以通过例如在调试器中运行程序来关闭。\n\n静态变量也始终被视为GC根。声明它们的类可以随时访问它们引用的对象（如果是公共的，则可以访问程序的其余部分），因此.NET将始终保持它们不变。声明为“线程静态”的变量仅会在该线程运行时持续存在。\n\n如果通过互操作将托管对象传递给非托管COM +库，则该对象也将成为具有引用计数的GC根。这是因为COM +不进行垃圾收集：它使用引用计数系统；通过将引用计数设置为0，一旦COM +库完成了该对象，它将不再是GC根目录，并且可以再次收集。\n\n如果对象具有终结器，则在垃圾回收器确定该对象不再“处于活动状态”时，不会立即将其删除。相反，它成为一种特殊的根，直到.NET调用了finalizer方法。这意味着这些对象通常需要从内存中删除一个以上的垃圾回收，因为它们在第一次发现未使用时仍将生存。\n\n## 对象图\n\n总体而言，.NET中的内存形成了一个复杂的，打结的引用和交叉引用图。这可能使得很难确定特定对象使用的内存量。例如，List <X>对象使用的内存非常小，因为List <X>类只有几个字段。但是，其中之一是列表中的对象数组：如果列表中有许多条目，则这可能会很大。这几乎总是由列表“独占”，因此关系非常简单：列表的总大小是小的初始对象和它引用的大数组的大小。但是，数组中的对象可能完全是另一回事：很可能存在通过内存的其他路径来访问它们。在这种情况下，\n\n当循环引用开始起作用时，事情变得更加混乱。\n\n![737-image001.jpg](https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image001.jpg)\n\n在开发代码时，通常将内存视为组织为更容易理解的结构：从各个根开始的树：\n\n![737-image002.jpg](https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image002.jpg)\n\n确实，以这种方式进行思考确实使（更确实可能）思考对象在内存中的布局方式。这也是编写程序或使用调试器时表示数据的方式，但这很容易忘记一个对象可以附加到多个根。这通常是.NET中内存泄漏的来源：开发人员忘记或从未意识到，一个对象锚定到多个根。考虑一下此处所示的情况：将GC root 2设置为null实际上不会允许垃圾收集器删除任何对象，这可以从查看完整图形中看到，而不能从树中看到。\n\n内存剖析器可以从另一个角度查看图形，就像树根植于单个对象并向后跟随引用以将GC根放在叶子上一样。对于根2引用的ClassC对象，我们可以向后跟随引用以获取下图：\n\n![737-image003.jpg](https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image003.jpg)\n\n通过这种方式的思考表明，ClassC对象具有两个最终的“所有者”，在垃圾收集器将其删除之前，这两个对象都必须放弃它。一旦将GC根目录2设置为null，就可以断开GC根目录3与该对象之间的任何链接，以便将其删除。\n\n在实际的.NET应用程序中，这种情况很容易出现。最常见的是，数据对象被用户界面中的元素引用，但在数据处理完毕后不会被删除。这种情况并不是很泄漏：当用新数据更新UI控件时，将回收内存，但是这可能意味着应用程序使用的内存比预期的要多得多。事件处理程序是另一个常见原因：很容易忘记一个对象的寿命至少与它从中接收事件的对象一样长，对于某些全局事件处理程序（如Application类中的事件），这种情况永远存在。\n\n实际的应用程序，尤其是那些具有用户界面组件的应用程序，具有比这复杂得多的图形。甚至可以从大量不同的地方引用对话框中的标签之类的简单内容…\n\n![737-image004.jpg](https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image004.jpg)\n\n很容易看到偶然的物体如何在迷宫中丢失。\n\n# 垃圾收集器的局限性\n\n## 仍在引用的未使用对象\n\n.NET中垃圾收集器的最大局限性是一个细微的限制：虽然它可以检测和删除未使用的对象，但实际上它会找到*未引用的*对象。这是一个重要的区别：程序可能永远不会再引用对象。但是，尽管有一些路径导致它可能仍被使用，但它永远不会从内存中释放出来。这导致内存泄漏；在.NET中，当将不再使用的对象保持引用状态时，会发生这些情况。\n\n尽管内存使用率上升的症状很明显，但这些泄漏的来源可能很难发现。有必要确定哪些未使用的对象保留在内存中，然后跟踪引用以找出为什么不收集它们。内存分析器对于此任务至关重要：通过比较发生泄漏时的内存状态，可以找到麻烦的未使用对象，但是没有调试器可以向后跟踪对象引用。\n\n垃圾收集器旨在处理大量资源，也就是说，释放对象的位置无关紧要。在现代系统上，内存属于这一类（何时回收内存无关紧要，只要及时完成以防止新分配失败）。仍然有一些资源不属于此类：例如，需要快速关闭文件句柄以避免引起应用程序之间的共享冲突。这些资源不能由垃圾收集器完全管理，因此.NET为管理这些资源的对象提供`Dispose`（）方法以及`using`（）构造。在这些情况下，对象的稀缺资源可通过实施`Dispose` 方法，但是紧要的内存要少得多，然后由垃圾回收器释放。\n\n`Dispose`意味着.NET没有什么特别的，因此仍必须取消引用已处置的对象。这使已处置但尚未回收的对象成为内存泄漏源的良好候选对象。\n\n## 堆的碎片\n\n.NET中一个鲜为人知的限制是大对象堆的限制。成为该堆一部分的对象不会在运行时移动，这可能导致程序过早地耗尽内存。当某些对象的寿命比其他对象长时，这将导致堆在对象过去所在的位置形成孔-这称为碎片。当程序要求一个大的内存块，但堆变得非常分散，以至于没有单个内存区域足以容纳它时，就会发生问题。内存分析器可以估计程序可以分配的最大对象：如果该对象正在下降，则很可能是原因。一个`OutOfMemoryException`当程序显然具有大量可用内存时，通常会发生由碎片引起的错误–在32位系统上，进程应至少能够使用1.5Gb，但是由于碎片导致的故障通常会在使用该碎片之前开始发生很多内存。\n\n碎片化的另一个征兆是.NET通常必须保留分配给应用程序的空洞所使用的内存。这显然导致它使用比在任务管理器中查看所需的内存更多的内存。这种效果通常相对来说是无害的：Windows非常擅长于意识到未被占用的孔所占用的内存并将其分页，并且如果碎片没有恶化，则程序将不会耗尽内存。但是，对于用户而言，这看起来并不好，他们可能会认为该应用程序浪费且“ blo肿”。当探查器显示程序分配的对象仅使用少量内存，而任务管理器显示该进程占用大量空间时，通常会发生这种情况。\n\n# 垃圾收集器的性能\n\n在性能方面，垃圾收集系统的最重要特征是垃圾收集器可以随时开始执行。这使它们不适用于定时至关重要的情况，因为任何操作的定时都可能被收集器的操作所抛弃。\n\n.NET收集器有两种主要的操作模式：并发和同步（有时称为工作站和服务器）。默认情况下，并发垃圾收集用于桌面应用程序，同步用于服务器应用程序（例如ASP.NET）。\n\n在并发模式下，.NET将尝试避免在进行收集时停止正在运行的程序。这意味着在给定的时间内应用程序可以完成的总次数较少，但应用程序不会暂停。这对交互式应用程序很有用，在交互应用程序中，给用户留下印象，即应用程序应立即做出响应，这一点很重要。\n\n在同步模式下，.NET将在垃圾收集器运行时挂起正在运行的应用程序。实际上，这总体上比并发模式更有效–垃圾回收花费相同的时间，但是不必与程序继续运行进行竞争–但是，这意味着必须执行完整的回收时会有明显的暂停。 。\n\n如果默认设置不合适，则可以在应用程序的配置文件中设置垃圾收集器的类型。当更重要的是应用程序具有高吞吐量而不是显示响应时，选择同步收集器可能很有用。\n\n在大型应用程序中，垃圾收集器需要处理的对象数量会变得非常大，这意味着访问和重新排列所有对象都将花费很长时间。为了解决这个问题，.NET使用了“分代”垃圾收集器，该垃圾收集器试图将优先级赋予较小的一组对象。这个想法是，最近创建的对象更有可能被快速释放，因此，当试图释放内存时，分代垃圾收集器会优先处理它们，因此.NET首先查看自上一次垃圾收集以来已分配的对象，并且只会开始如果无法通过这种方式释放足够的空间，请考虑使用较旧的对象。\n\n如果.NET可以自行选择收集时间，则此系统效果最佳，并且如果`GC.Collect`调用（）会中断该系统，因为这通常会导致新对象过早地变旧，这增加了在不久的将来再次进行昂贵的完整收集的可能性。\n\n具有终结器的类也会破坏垃圾收集器的平稳运行。这些类的对象不能立即删除：相反，它们进入终结器队列，并在运行终结器后从内存中删除。这意味着它们所引用的任何对象（以及那些对象所引用的任何对象，依此类推）至少也必须在此之前保留在内存中，并且在内存再次可用之前需要两次垃圾回收。如果该图包含带有终结器的许多对象，则这可能意味着垃圾收集器需要多次通过才能完全释放所有未引用的对象。\n\n有一个避免此问题的简单方法：`IDisposable`在可终结类上实现，将完成对象所需的操作移到`Dispose()`方法中并`GC.SuppressFinalize()`在最后调用。然后可以修改终结器以调用该`Dispose()`方法。`GC.SuppressFinalize()`告诉垃圾回收器，该对象不再需要终结，可以立即被垃圾回收，这可以导致更快地回收内存。\n\n# 结论\n\n如果您花一些时间了解垃圾收集器的工作方式，则更容易理解应用程序中的内存和性能问题。它表明，尽管.NET减轻了内存管理的负担，但并不能完全消除跟踪和管理资源的需求。但是，使用内存分析器来诊断和修复.NET中的问题更加容易。考虑到.NET在开发中尽早管理内存的方式可以帮助减少问题，但是即使那样，由于框架或第三方库的复杂性，此类问题仍然可能出现。","source":"_posts/技术/understanding-garbage-collection-in-.net.md","raw":"---\ntitle: 了解.NET中的垃圾回收\ndate: 2020-4-5 16:28\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n# 了解.NET中的垃圾回收\n\n>  一旦了解了.NET的垃圾收集器是如何工作的，那么可能会触及.NET应用程序的一些更为神秘的问题的原因就会变得更加清楚。NET可能已承诺要结束显式内存管理，但在开发.NET应用程序时，仍然有必要分析内存的使用情况，以便避免与内存相关的错误和某些性能问题。 \n\n.NET的垃圾收集器已在Windows应用程序中作为显式内存管理和内存泄漏的结束而出售给我们：这个想法是，在后台运行垃圾收集器的情况下，开发人员不再需要担心管理它们创建的对象的生命周期–应用程序完成处理后，垃圾收集器将对其进行处理。\n\n但是，实际情况要复杂得多。垃圾收集器无疑解决了非托管程序中最常见的泄漏-由开发人员在完成使用后忘记释放内存而引起的泄漏。它还解决了内存释放过早的相关问题，但是当垃圾收集器对开发人员对对象是否仍然处于“活动状态”并且能够进行开发时有不同的看法时，解决该问题的方式可能导致内存泄漏。要使用的。解决这些问题之前，您需要对收集器的工作方式有所了解。\n\n# 垃圾收集器如何工作\n\n那么，垃圾收集器如何实现其魔力？基本思想非常简单：它检查对象在内存中的布局方式，并通过遵循一系列引用来标识正在运行的程序可以“访问”的所有那些对象。\n\n当垃圾回收开始时，它将查看一组称为“ GC根”的引用。这些是由于某种原因总是可以访问的内存位置，并且包含对程序创建的对象的引用。它将这些对象标记为“活动”，然后查看它们引用的所有对象。它也将这些标记为“实时”。它以这种方式继续，遍历它知道是“活动”的所有对象。它将它们引用的所有内容都标记为也被使用，直到找不到其他对象为止。\n\n如果某个对象或其超类之一的字段包含另一个对象，则该对象由垃圾收集器标识为引用另一个对象。\n\n一旦知道了所有这些活动对象，就可以丢弃所有剩余的对象，并将空间重新用于新对象。.NET压缩内存，以确保没有间隙（有效地压缩丢弃的对象不存在）–这意味着空闲内存始终位于堆的末尾，并可以非常快速地分配新对象。\n\nGC根本身不是对象，而是对对象的引用。GC根引用的任何对象将自动在下一个垃圾回收中保留下来。.NET中有四种主要的根：\n\n当前正在运行的方法中的局部变量被视为GC根。这些变量引用的对象始终可以通过声明它们的方法立即访问，因此必须保留它们。这些根的生命周期可以取决于程序的构建方式。在调试版本中，局部变量的持续时间与方法在堆栈上的时间一样长。在发行版本中，JIT能够查看程序结构以找出执行过程中该方法可以使用变量的最后一点，并在不再需要该变量时将其丢弃。这种策略并不总是使用，可以通过例如在调试器中运行程序来关闭。\n\n静态变量也始终被视为GC根。声明它们的类可以随时访问它们引用的对象（如果是公共的，则可以访问程序的其余部分），因此.NET将始终保持它们不变。声明为“线程静态”的变量仅会在该线程运行时持续存在。\n\n如果通过互操作将托管对象传递给非托管COM +库，则该对象也将成为具有引用计数的GC根。这是因为COM +不进行垃圾收集：它使用引用计数系统；通过将引用计数设置为0，一旦COM +库完成了该对象，它将不再是GC根目录，并且可以再次收集。\n\n如果对象具有终结器，则在垃圾回收器确定该对象不再“处于活动状态”时，不会立即将其删除。相反，它成为一种特殊的根，直到.NET调用了finalizer方法。这意味着这些对象通常需要从内存中删除一个以上的垃圾回收，因为它们在第一次发现未使用时仍将生存。\n\n## 对象图\n\n总体而言，.NET中的内存形成了一个复杂的，打结的引用和交叉引用图。这可能使得很难确定特定对象使用的内存量。例如，List <X>对象使用的内存非常小，因为List <X>类只有几个字段。但是，其中之一是列表中的对象数组：如果列表中有许多条目，则这可能会很大。这几乎总是由列表“独占”，因此关系非常简单：列表的总大小是小的初始对象和它引用的大数组的大小。但是，数组中的对象可能完全是另一回事：很可能存在通过内存的其他路径来访问它们。在这种情况下，\n\n当循环引用开始起作用时，事情变得更加混乱。\n\n![737-image001.jpg](https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image001.jpg)\n\n在开发代码时，通常将内存视为组织为更容易理解的结构：从各个根开始的树：\n\n![737-image002.jpg](https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image002.jpg)\n\n确实，以这种方式进行思考确实使（更确实可能）思考对象在内存中的布局方式。这也是编写程序或使用调试器时表示数据的方式，但这很容易忘记一个对象可以附加到多个根。这通常是.NET中内存泄漏的来源：开发人员忘记或从未意识到，一个对象锚定到多个根。考虑一下此处所示的情况：将GC root 2设置为null实际上不会允许垃圾收集器删除任何对象，这可以从查看完整图形中看到，而不能从树中看到。\n\n内存剖析器可以从另一个角度查看图形，就像树根植于单个对象并向后跟随引用以将GC根放在叶子上一样。对于根2引用的ClassC对象，我们可以向后跟随引用以获取下图：\n\n![737-image003.jpg](https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image003.jpg)\n\n通过这种方式的思考表明，ClassC对象具有两个最终的“所有者”，在垃圾收集器将其删除之前，这两个对象都必须放弃它。一旦将GC根目录2设置为null，就可以断开GC根目录3与该对象之间的任何链接，以便将其删除。\n\n在实际的.NET应用程序中，这种情况很容易出现。最常见的是，数据对象被用户界面中的元素引用，但在数据处理完毕后不会被删除。这种情况并不是很泄漏：当用新数据更新UI控件时，将回收内存，但是这可能意味着应用程序使用的内存比预期的要多得多。事件处理程序是另一个常见原因：很容易忘记一个对象的寿命至少与它从中接收事件的对象一样长，对于某些全局事件处理程序（如Application类中的事件），这种情况永远存在。\n\n实际的应用程序，尤其是那些具有用户界面组件的应用程序，具有比这复杂得多的图形。甚至可以从大量不同的地方引用对话框中的标签之类的简单内容…\n\n![737-image004.jpg](https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image004.jpg)\n\n很容易看到偶然的物体如何在迷宫中丢失。\n\n# 垃圾收集器的局限性\n\n## 仍在引用的未使用对象\n\n.NET中垃圾收集器的最大局限性是一个细微的限制：虽然它可以检测和删除未使用的对象，但实际上它会找到*未引用的*对象。这是一个重要的区别：程序可能永远不会再引用对象。但是，尽管有一些路径导致它可能仍被使用，但它永远不会从内存中释放出来。这导致内存泄漏；在.NET中，当将不再使用的对象保持引用状态时，会发生这些情况。\n\n尽管内存使用率上升的症状很明显，但这些泄漏的来源可能很难发现。有必要确定哪些未使用的对象保留在内存中，然后跟踪引用以找出为什么不收集它们。内存分析器对于此任务至关重要：通过比较发生泄漏时的内存状态，可以找到麻烦的未使用对象，但是没有调试器可以向后跟踪对象引用。\n\n垃圾收集器旨在处理大量资源，也就是说，释放对象的位置无关紧要。在现代系统上，内存属于这一类（何时回收内存无关紧要，只要及时完成以防止新分配失败）。仍然有一些资源不属于此类：例如，需要快速关闭文件句柄以避免引起应用程序之间的共享冲突。这些资源不能由垃圾收集器完全管理，因此.NET为管理这些资源的对象提供`Dispose`（）方法以及`using`（）构造。在这些情况下，对象的稀缺资源可通过实施`Dispose` 方法，但是紧要的内存要少得多，然后由垃圾回收器释放。\n\n`Dispose`意味着.NET没有什么特别的，因此仍必须取消引用已处置的对象。这使已处置但尚未回收的对象成为内存泄漏源的良好候选对象。\n\n## 堆的碎片\n\n.NET中一个鲜为人知的限制是大对象堆的限制。成为该堆一部分的对象不会在运行时移动，这可能导致程序过早地耗尽内存。当某些对象的寿命比其他对象长时，这将导致堆在对象过去所在的位置形成孔-这称为碎片。当程序要求一个大的内存块，但堆变得非常分散，以至于没有单个内存区域足以容纳它时，就会发生问题。内存分析器可以估计程序可以分配的最大对象：如果该对象正在下降，则很可能是原因。一个`OutOfMemoryException`当程序显然具有大量可用内存时，通常会发生由碎片引起的错误–在32位系统上，进程应至少能够使用1.5Gb，但是由于碎片导致的故障通常会在使用该碎片之前开始发生很多内存。\n\n碎片化的另一个征兆是.NET通常必须保留分配给应用程序的空洞所使用的内存。这显然导致它使用比在任务管理器中查看所需的内存更多的内存。这种效果通常相对来说是无害的：Windows非常擅长于意识到未被占用的孔所占用的内存并将其分页，并且如果碎片没有恶化，则程序将不会耗尽内存。但是，对于用户而言，这看起来并不好，他们可能会认为该应用程序浪费且“ blo肿”。当探查器显示程序分配的对象仅使用少量内存，而任务管理器显示该进程占用大量空间时，通常会发生这种情况。\n\n# 垃圾收集器的性能\n\n在性能方面，垃圾收集系统的最重要特征是垃圾收集器可以随时开始执行。这使它们不适用于定时至关重要的情况，因为任何操作的定时都可能被收集器的操作所抛弃。\n\n.NET收集器有两种主要的操作模式：并发和同步（有时称为工作站和服务器）。默认情况下，并发垃圾收集用于桌面应用程序，同步用于服务器应用程序（例如ASP.NET）。\n\n在并发模式下，.NET将尝试避免在进行收集时停止正在运行的程序。这意味着在给定的时间内应用程序可以完成的总次数较少，但应用程序不会暂停。这对交互式应用程序很有用，在交互应用程序中，给用户留下印象，即应用程序应立即做出响应，这一点很重要。\n\n在同步模式下，.NET将在垃圾收集器运行时挂起正在运行的应用程序。实际上，这总体上比并发模式更有效–垃圾回收花费相同的时间，但是不必与程序继续运行进行竞争–但是，这意味着必须执行完整的回收时会有明显的暂停。 。\n\n如果默认设置不合适，则可以在应用程序的配置文件中设置垃圾收集器的类型。当更重要的是应用程序具有高吞吐量而不是显示响应时，选择同步收集器可能很有用。\n\n在大型应用程序中，垃圾收集器需要处理的对象数量会变得非常大，这意味着访问和重新排列所有对象都将花费很长时间。为了解决这个问题，.NET使用了“分代”垃圾收集器，该垃圾收集器试图将优先级赋予较小的一组对象。这个想法是，最近创建的对象更有可能被快速释放，因此，当试图释放内存时，分代垃圾收集器会优先处理它们，因此.NET首先查看自上一次垃圾收集以来已分配的对象，并且只会开始如果无法通过这种方式释放足够的空间，请考虑使用较旧的对象。\n\n如果.NET可以自行选择收集时间，则此系统效果最佳，并且如果`GC.Collect`调用（）会中断该系统，因为这通常会导致新对象过早地变旧，这增加了在不久的将来再次进行昂贵的完整收集的可能性。\n\n具有终结器的类也会破坏垃圾收集器的平稳运行。这些类的对象不能立即删除：相反，它们进入终结器队列，并在运行终结器后从内存中删除。这意味着它们所引用的任何对象（以及那些对象所引用的任何对象，依此类推）至少也必须在此之前保留在内存中，并且在内存再次可用之前需要两次垃圾回收。如果该图包含带有终结器的许多对象，则这可能意味着垃圾收集器需要多次通过才能完全释放所有未引用的对象。\n\n有一个避免此问题的简单方法：`IDisposable`在可终结类上实现，将完成对象所需的操作移到`Dispose()`方法中并`GC.SuppressFinalize()`在最后调用。然后可以修改终结器以调用该`Dispose()`方法。`GC.SuppressFinalize()`告诉垃圾回收器，该对象不再需要终结，可以立即被垃圾回收，这可以导致更快地回收内存。\n\n# 结论\n\n如果您花一些时间了解垃圾收集器的工作方式，则更容易理解应用程序中的内存和性能问题。它表明，尽管.NET减轻了内存管理的负担，但并不能完全消除跟踪和管理资源的需求。但是，使用内存分析器来诊断和修复.NET中的问题更加容易。考虑到.NET在开发中尽早管理内存的方式可以帮助减少问题，但是即使那样，由于框架或第三方库的复杂性，此类问题仍然可能出现。","slug":"技术/understanding-garbage-collection-in-.net","published":1,"updated":"2020-04-22T15:00:35.366Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt77000pn4vif3gd2810","content":"<h1 id=\"了解-NET中的垃圾回收\"><a href=\"#了解-NET中的垃圾回收\" class=\"headerlink\" title=\"了解.NET中的垃圾回收\"></a>了解.NET中的垃圾回收</h1><blockquote>\n<p> 一旦了解了.NET的垃圾收集器是如何工作的，那么可能会触及.NET应用程序的一些更为神秘的问题的原因就会变得更加清楚。NET可能已承诺要结束显式内存管理，但在开发.NET应用程序时，仍然有必要分析内存的使用情况，以便避免与内存相关的错误和某些性能问题。 </p>\n</blockquote>\n<p>.NET的垃圾收集器已在Windows应用程序中作为显式内存管理和内存泄漏的结束而出售给我们：这个想法是，在后台运行垃圾收集器的情况下，开发人员不再需要担心管理它们创建的对象的生命周期–应用程序完成处理后，垃圾收集器将对其进行处理。</p>\n<p>但是，实际情况要复杂得多。垃圾收集器无疑解决了非托管程序中最常见的泄漏-由开发人员在完成使用后忘记释放内存而引起的泄漏。它还解决了内存释放过早的相关问题，但是当垃圾收集器对开发人员对对象是否仍然处于“活动状态”并且能够进行开发时有不同的看法时，解决该问题的方式可能导致内存泄漏。要使用的。解决这些问题之前，您需要对收集器的工作方式有所了解。</p>\n<h1 id=\"垃圾收集器如何工作\"><a href=\"#垃圾收集器如何工作\" class=\"headerlink\" title=\"垃圾收集器如何工作\"></a>垃圾收集器如何工作</h1><p>那么，垃圾收集器如何实现其魔力？基本思想非常简单：它检查对象在内存中的布局方式，并通过遵循一系列引用来标识正在运行的程序可以“访问”的所有那些对象。</p>\n<p>当垃圾回收开始时，它将查看一组称为“ GC根”的引用。这些是由于某种原因总是可以访问的内存位置，并且包含对程序创建的对象的引用。它将这些对象标记为“活动”，然后查看它们引用的所有对象。它也将这些标记为“实时”。它以这种方式继续，遍历它知道是“活动”的所有对象。它将它们引用的所有内容都标记为也被使用，直到找不到其他对象为止。</p>\n<p>如果某个对象或其超类之一的字段包含另一个对象，则该对象由垃圾收集器标识为引用另一个对象。</p>\n<p>一旦知道了所有这些活动对象，就可以丢弃所有剩余的对象，并将空间重新用于新对象。.NET压缩内存，以确保没有间隙（有效地压缩丢弃的对象不存在）–这意味着空闲内存始终位于堆的末尾，并可以非常快速地分配新对象。</p>\n<p>GC根本身不是对象，而是对对象的引用。GC根引用的任何对象将自动在下一个垃圾回收中保留下来。.NET中有四种主要的根：</p>\n<p>当前正在运行的方法中的局部变量被视为GC根。这些变量引用的对象始终可以通过声明它们的方法立即访问，因此必须保留它们。这些根的生命周期可以取决于程序的构建方式。在调试版本中，局部变量的持续时间与方法在堆栈上的时间一样长。在发行版本中，JIT能够查看程序结构以找出执行过程中该方法可以使用变量的最后一点，并在不再需要该变量时将其丢弃。这种策略并不总是使用，可以通过例如在调试器中运行程序来关闭。</p>\n<p>静态变量也始终被视为GC根。声明它们的类可以随时访问它们引用的对象（如果是公共的，则可以访问程序的其余部分），因此.NET将始终保持它们不变。声明为“线程静态”的变量仅会在该线程运行时持续存在。</p>\n<p>如果通过互操作将托管对象传递给非托管COM +库，则该对象也将成为具有引用计数的GC根。这是因为COM +不进行垃圾收集：它使用引用计数系统；通过将引用计数设置为0，一旦COM +库完成了该对象，它将不再是GC根目录，并且可以再次收集。</p>\n<p>如果对象具有终结器，则在垃圾回收器确定该对象不再“处于活动状态”时，不会立即将其删除。相反，它成为一种特殊的根，直到.NET调用了finalizer方法。这意味着这些对象通常需要从内存中删除一个以上的垃圾回收，因为它们在第一次发现未使用时仍将生存。</p>\n<h2 id=\"对象图\"><a href=\"#对象图\" class=\"headerlink\" title=\"对象图\"></a>对象图</h2><p>总体而言，.NET中的内存形成了一个复杂的，打结的引用和交叉引用图。这可能使得很难确定特定对象使用的内存量。例如，List <x>对象使用的内存非常小，因为List <x>类只有几个字段。但是，其中之一是列表中的对象数组：如果列表中有许多条目，则这可能会很大。这几乎总是由列表“独占”，因此关系非常简单：列表的总大小是小的初始对象和它引用的大数组的大小。但是，数组中的对象可能完全是另一回事：很可能存在通过内存的其他路径来访问它们。在这种情况下，</x></x></p>\n<p>当循环引用开始起作用时，事情变得更加混乱。</p>\n<p><img src=\"https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image001.jpg\" alt=\"737-image001.jpg\"></p>\n<p>在开发代码时，通常将内存视为组织为更容易理解的结构：从各个根开始的树：</p>\n<p><img src=\"https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image002.jpg\" alt=\"737-image002.jpg\"></p>\n<p>确实，以这种方式进行思考确实使（更确实可能）思考对象在内存中的布局方式。这也是编写程序或使用调试器时表示数据的方式，但这很容易忘记一个对象可以附加到多个根。这通常是.NET中内存泄漏的来源：开发人员忘记或从未意识到，一个对象锚定到多个根。考虑一下此处所示的情况：将GC root 2设置为null实际上不会允许垃圾收集器删除任何对象，这可以从查看完整图形中看到，而不能从树中看到。</p>\n<p>内存剖析器可以从另一个角度查看图形，就像树根植于单个对象并向后跟随引用以将GC根放在叶子上一样。对于根2引用的ClassC对象，我们可以向后跟随引用以获取下图：</p>\n<p><img src=\"https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image003.jpg\" alt=\"737-image003.jpg\"></p>\n<p>通过这种方式的思考表明，ClassC对象具有两个最终的“所有者”，在垃圾收集器将其删除之前，这两个对象都必须放弃它。一旦将GC根目录2设置为null，就可以断开GC根目录3与该对象之间的任何链接，以便将其删除。</p>\n<p>在实际的.NET应用程序中，这种情况很容易出现。最常见的是，数据对象被用户界面中的元素引用，但在数据处理完毕后不会被删除。这种情况并不是很泄漏：当用新数据更新UI控件时，将回收内存，但是这可能意味着应用程序使用的内存比预期的要多得多。事件处理程序是另一个常见原因：很容易忘记一个对象的寿命至少与它从中接收事件的对象一样长，对于某些全局事件处理程序（如Application类中的事件），这种情况永远存在。</p>\n<p>实际的应用程序，尤其是那些具有用户界面组件的应用程序，具有比这复杂得多的图形。甚至可以从大量不同的地方引用对话框中的标签之类的简单内容…</p>\n<p><img src=\"https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image004.jpg\" alt=\"737-image004.jpg\"></p>\n<p>很容易看到偶然的物体如何在迷宫中丢失。</p>\n<h1 id=\"垃圾收集器的局限性\"><a href=\"#垃圾收集器的局限性\" class=\"headerlink\" title=\"垃圾收集器的局限性\"></a>垃圾收集器的局限性</h1><h2 id=\"仍在引用的未使用对象\"><a href=\"#仍在引用的未使用对象\" class=\"headerlink\" title=\"仍在引用的未使用对象\"></a>仍在引用的未使用对象</h2><p>.NET中垃圾收集器的最大局限性是一个细微的限制：虽然它可以检测和删除未使用的对象，但实际上它会找到<em>未引用的</em>对象。这是一个重要的区别：程序可能永远不会再引用对象。但是，尽管有一些路径导致它可能仍被使用，但它永远不会从内存中释放出来。这导致内存泄漏；在.NET中，当将不再使用的对象保持引用状态时，会发生这些情况。</p>\n<p>尽管内存使用率上升的症状很明显，但这些泄漏的来源可能很难发现。有必要确定哪些未使用的对象保留在内存中，然后跟踪引用以找出为什么不收集它们。内存分析器对于此任务至关重要：通过比较发生泄漏时的内存状态，可以找到麻烦的未使用对象，但是没有调试器可以向后跟踪对象引用。</p>\n<p>垃圾收集器旨在处理大量资源，也就是说，释放对象的位置无关紧要。在现代系统上，内存属于这一类（何时回收内存无关紧要，只要及时完成以防止新分配失败）。仍然有一些资源不属于此类：例如，需要快速关闭文件句柄以避免引起应用程序之间的共享冲突。这些资源不能由垃圾收集器完全管理，因此.NET为管理这些资源的对象提供<code>Dispose</code>（）方法以及<code>using</code>（）构造。在这些情况下，对象的稀缺资源可通过实施<code>Dispose</code> 方法，但是紧要的内存要少得多，然后由垃圾回收器释放。</p>\n<p><code>Dispose</code>意味着.NET没有什么特别的，因此仍必须取消引用已处置的对象。这使已处置但尚未回收的对象成为内存泄漏源的良好候选对象。</p>\n<h2 id=\"堆的碎片\"><a href=\"#堆的碎片\" class=\"headerlink\" title=\"堆的碎片\"></a>堆的碎片</h2><p>.NET中一个鲜为人知的限制是大对象堆的限制。成为该堆一部分的对象不会在运行时移动，这可能导致程序过早地耗尽内存。当某些对象的寿命比其他对象长时，这将导致堆在对象过去所在的位置形成孔-这称为碎片。当程序要求一个大的内存块，但堆变得非常分散，以至于没有单个内存区域足以容纳它时，就会发生问题。内存分析器可以估计程序可以分配的最大对象：如果该对象正在下降，则很可能是原因。一个<code>OutOfMemoryException</code>当程序显然具有大量可用内存时，通常会发生由碎片引起的错误–在32位系统上，进程应至少能够使用1.5Gb，但是由于碎片导致的故障通常会在使用该碎片之前开始发生很多内存。</p>\n<p>碎片化的另一个征兆是.NET通常必须保留分配给应用程序的空洞所使用的内存。这显然导致它使用比在任务管理器中查看所需的内存更多的内存。这种效果通常相对来说是无害的：Windows非常擅长于意识到未被占用的孔所占用的内存并将其分页，并且如果碎片没有恶化，则程序将不会耗尽内存。但是，对于用户而言，这看起来并不好，他们可能会认为该应用程序浪费且“ blo肿”。当探查器显示程序分配的对象仅使用少量内存，而任务管理器显示该进程占用大量空间时，通常会发生这种情况。</p>\n<h1 id=\"垃圾收集器的性能\"><a href=\"#垃圾收集器的性能\" class=\"headerlink\" title=\"垃圾收集器的性能\"></a>垃圾收集器的性能</h1><p>在性能方面，垃圾收集系统的最重要特征是垃圾收集器可以随时开始执行。这使它们不适用于定时至关重要的情况，因为任何操作的定时都可能被收集器的操作所抛弃。</p>\n<p>.NET收集器有两种主要的操作模式：并发和同步（有时称为工作站和服务器）。默认情况下，并发垃圾收集用于桌面应用程序，同步用于服务器应用程序（例如ASP.NET）。</p>\n<p>在并发模式下，.NET将尝试避免在进行收集时停止正在运行的程序。这意味着在给定的时间内应用程序可以完成的总次数较少，但应用程序不会暂停。这对交互式应用程序很有用，在交互应用程序中，给用户留下印象，即应用程序应立即做出响应，这一点很重要。</p>\n<p>在同步模式下，.NET将在垃圾收集器运行时挂起正在运行的应用程序。实际上，这总体上比并发模式更有效–垃圾回收花费相同的时间，但是不必与程序继续运行进行竞争–但是，这意味着必须执行完整的回收时会有明显的暂停。 。</p>\n<p>如果默认设置不合适，则可以在应用程序的配置文件中设置垃圾收集器的类型。当更重要的是应用程序具有高吞吐量而不是显示响应时，选择同步收集器可能很有用。</p>\n<p>在大型应用程序中，垃圾收集器需要处理的对象数量会变得非常大，这意味着访问和重新排列所有对象都将花费很长时间。为了解决这个问题，.NET使用了“分代”垃圾收集器，该垃圾收集器试图将优先级赋予较小的一组对象。这个想法是，最近创建的对象更有可能被快速释放，因此，当试图释放内存时，分代垃圾收集器会优先处理它们，因此.NET首先查看自上一次垃圾收集以来已分配的对象，并且只会开始如果无法通过这种方式释放足够的空间，请考虑使用较旧的对象。</p>\n<p>如果.NET可以自行选择收集时间，则此系统效果最佳，并且如果<code>GC.Collect</code>调用（）会中断该系统，因为这通常会导致新对象过早地变旧，这增加了在不久的将来再次进行昂贵的完整收集的可能性。</p>\n<p>具有终结器的类也会破坏垃圾收集器的平稳运行。这些类的对象不能立即删除：相反，它们进入终结器队列，并在运行终结器后从内存中删除。这意味着它们所引用的任何对象（以及那些对象所引用的任何对象，依此类推）至少也必须在此之前保留在内存中，并且在内存再次可用之前需要两次垃圾回收。如果该图包含带有终结器的许多对象，则这可能意味着垃圾收集器需要多次通过才能完全释放所有未引用的对象。</p>\n<p>有一个避免此问题的简单方法：<code>IDisposable</code>在可终结类上实现，将完成对象所需的操作移到<code>Dispose()</code>方法中并<code>GC.SuppressFinalize()</code>在最后调用。然后可以修改终结器以调用该<code>Dispose()</code>方法。<code>GC.SuppressFinalize()</code>告诉垃圾回收器，该对象不再需要终结，可以立即被垃圾回收，这可以导致更快地回收内存。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>如果您花一些时间了解垃圾收集器的工作方式，则更容易理解应用程序中的内存和性能问题。它表明，尽管.NET减轻了内存管理的负担，但并不能完全消除跟踪和管理资源的需求。但是，使用内存分析器来诊断和修复.NET中的问题更加容易。考虑到.NET在开发中尽早管理内存的方式可以帮助减少问题，但是即使那样，由于框架或第三方库的复杂性，此类问题仍然可能出现。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"了解-NET中的垃圾回收\"><a href=\"#了解-NET中的垃圾回收\" class=\"headerlink\" title=\"了解.NET中的垃圾回收\"></a>了解.NET中的垃圾回收</h1><blockquote>\n<p> 一旦了解了.NET的垃圾收集器是如何工作的，那么可能会触及.NET应用程序的一些更为神秘的问题的原因就会变得更加清楚。NET可能已承诺要结束显式内存管理，但在开发.NET应用程序时，仍然有必要分析内存的使用情况，以便避免与内存相关的错误和某些性能问题。 </p>\n</blockquote>\n<p>.NET的垃圾收集器已在Windows应用程序中作为显式内存管理和内存泄漏的结束而出售给我们：这个想法是，在后台运行垃圾收集器的情况下，开发人员不再需要担心管理它们创建的对象的生命周期–应用程序完成处理后，垃圾收集器将对其进行处理。</p>\n<p>但是，实际情况要复杂得多。垃圾收集器无疑解决了非托管程序中最常见的泄漏-由开发人员在完成使用后忘记释放内存而引起的泄漏。它还解决了内存释放过早的相关问题，但是当垃圾收集器对开发人员对对象是否仍然处于“活动状态”并且能够进行开发时有不同的看法时，解决该问题的方式可能导致内存泄漏。要使用的。解决这些问题之前，您需要对收集器的工作方式有所了解。</p>\n<h1 id=\"垃圾收集器如何工作\"><a href=\"#垃圾收集器如何工作\" class=\"headerlink\" title=\"垃圾收集器如何工作\"></a>垃圾收集器如何工作</h1><p>那么，垃圾收集器如何实现其魔力？基本思想非常简单：它检查对象在内存中的布局方式，并通过遵循一系列引用来标识正在运行的程序可以“访问”的所有那些对象。</p>\n<p>当垃圾回收开始时，它将查看一组称为“ GC根”的引用。这些是由于某种原因总是可以访问的内存位置，并且包含对程序创建的对象的引用。它将这些对象标记为“活动”，然后查看它们引用的所有对象。它也将这些标记为“实时”。它以这种方式继续，遍历它知道是“活动”的所有对象。它将它们引用的所有内容都标记为也被使用，直到找不到其他对象为止。</p>\n<p>如果某个对象或其超类之一的字段包含另一个对象，则该对象由垃圾收集器标识为引用另一个对象。</p>\n<p>一旦知道了所有这些活动对象，就可以丢弃所有剩余的对象，并将空间重新用于新对象。.NET压缩内存，以确保没有间隙（有效地压缩丢弃的对象不存在）–这意味着空闲内存始终位于堆的末尾，并可以非常快速地分配新对象。</p>\n<p>GC根本身不是对象，而是对对象的引用。GC根引用的任何对象将自动在下一个垃圾回收中保留下来。.NET中有四种主要的根：</p>\n<p>当前正在运行的方法中的局部变量被视为GC根。这些变量引用的对象始终可以通过声明它们的方法立即访问，因此必须保留它们。这些根的生命周期可以取决于程序的构建方式。在调试版本中，局部变量的持续时间与方法在堆栈上的时间一样长。在发行版本中，JIT能够查看程序结构以找出执行过程中该方法可以使用变量的最后一点，并在不再需要该变量时将其丢弃。这种策略并不总是使用，可以通过例如在调试器中运行程序来关闭。</p>\n<p>静态变量也始终被视为GC根。声明它们的类可以随时访问它们引用的对象（如果是公共的，则可以访问程序的其余部分），因此.NET将始终保持它们不变。声明为“线程静态”的变量仅会在该线程运行时持续存在。</p>\n<p>如果通过互操作将托管对象传递给非托管COM +库，则该对象也将成为具有引用计数的GC根。这是因为COM +不进行垃圾收集：它使用引用计数系统；通过将引用计数设置为0，一旦COM +库完成了该对象，它将不再是GC根目录，并且可以再次收集。</p>\n<p>如果对象具有终结器，则在垃圾回收器确定该对象不再“处于活动状态”时，不会立即将其删除。相反，它成为一种特殊的根，直到.NET调用了finalizer方法。这意味着这些对象通常需要从内存中删除一个以上的垃圾回收，因为它们在第一次发现未使用时仍将生存。</p>\n<h2 id=\"对象图\"><a href=\"#对象图\" class=\"headerlink\" title=\"对象图\"></a>对象图</h2><p>总体而言，.NET中的内存形成了一个复杂的，打结的引用和交叉引用图。这可能使得很难确定特定对象使用的内存量。例如，List <x>对象使用的内存非常小，因为List <x>类只有几个字段。但是，其中之一是列表中的对象数组：如果列表中有许多条目，则这可能会很大。这几乎总是由列表“独占”，因此关系非常简单：列表的总大小是小的初始对象和它引用的大数组的大小。但是，数组中的对象可能完全是另一回事：很可能存在通过内存的其他路径来访问它们。在这种情况下，</x></x></p>\n<p>当循环引用开始起作用时，事情变得更加混乱。</p>\n<p><img src=\"https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image001.jpg\" alt=\"737-image001.jpg\"></p>\n<p>在开发代码时，通常将内存视为组织为更容易理解的结构：从各个根开始的树：</p>\n<p><img src=\"https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image002.jpg\" alt=\"737-image002.jpg\"></p>\n<p>确实，以这种方式进行思考确实使（更确实可能）思考对象在内存中的布局方式。这也是编写程序或使用调试器时表示数据的方式，但这很容易忘记一个对象可以附加到多个根。这通常是.NET中内存泄漏的来源：开发人员忘记或从未意识到，一个对象锚定到多个根。考虑一下此处所示的情况：将GC root 2设置为null实际上不会允许垃圾收集器删除任何对象，这可以从查看完整图形中看到，而不能从树中看到。</p>\n<p>内存剖析器可以从另一个角度查看图形，就像树根植于单个对象并向后跟随引用以将GC根放在叶子上一样。对于根2引用的ClassC对象，我们可以向后跟随引用以获取下图：</p>\n<p><img src=\"https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image003.jpg\" alt=\"737-image003.jpg\"></p>\n<p>通过这种方式的思考表明，ClassC对象具有两个最终的“所有者”，在垃圾收集器将其删除之前，这两个对象都必须放弃它。一旦将GC根目录2设置为null，就可以断开GC根目录3与该对象之间的任何链接，以便将其删除。</p>\n<p>在实际的.NET应用程序中，这种情况很容易出现。最常见的是，数据对象被用户界面中的元素引用，但在数据处理完毕后不会被删除。这种情况并不是很泄漏：当用新数据更新UI控件时，将回收内存，但是这可能意味着应用程序使用的内存比预期的要多得多。事件处理程序是另一个常见原因：很容易忘记一个对象的寿命至少与它从中接收事件的对象一样长，对于某些全局事件处理程序（如Application类中的事件），这种情况永远存在。</p>\n<p>实际的应用程序，尤其是那些具有用户界面组件的应用程序，具有比这复杂得多的图形。甚至可以从大量不同的地方引用对话框中的标签之类的简单内容…</p>\n<p><img src=\"https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image004.jpg\" alt=\"737-image004.jpg\"></p>\n<p>很容易看到偶然的物体如何在迷宫中丢失。</p>\n<h1 id=\"垃圾收集器的局限性\"><a href=\"#垃圾收集器的局限性\" class=\"headerlink\" title=\"垃圾收集器的局限性\"></a>垃圾收集器的局限性</h1><h2 id=\"仍在引用的未使用对象\"><a href=\"#仍在引用的未使用对象\" class=\"headerlink\" title=\"仍在引用的未使用对象\"></a>仍在引用的未使用对象</h2><p>.NET中垃圾收集器的最大局限性是一个细微的限制：虽然它可以检测和删除未使用的对象，但实际上它会找到<em>未引用的</em>对象。这是一个重要的区别：程序可能永远不会再引用对象。但是，尽管有一些路径导致它可能仍被使用，但它永远不会从内存中释放出来。这导致内存泄漏；在.NET中，当将不再使用的对象保持引用状态时，会发生这些情况。</p>\n<p>尽管内存使用率上升的症状很明显，但这些泄漏的来源可能很难发现。有必要确定哪些未使用的对象保留在内存中，然后跟踪引用以找出为什么不收集它们。内存分析器对于此任务至关重要：通过比较发生泄漏时的内存状态，可以找到麻烦的未使用对象，但是没有调试器可以向后跟踪对象引用。</p>\n<p>垃圾收集器旨在处理大量资源，也就是说，释放对象的位置无关紧要。在现代系统上，内存属于这一类（何时回收内存无关紧要，只要及时完成以防止新分配失败）。仍然有一些资源不属于此类：例如，需要快速关闭文件句柄以避免引起应用程序之间的共享冲突。这些资源不能由垃圾收集器完全管理，因此.NET为管理这些资源的对象提供<code>Dispose</code>（）方法以及<code>using</code>（）构造。在这些情况下，对象的稀缺资源可通过实施<code>Dispose</code> 方法，但是紧要的内存要少得多，然后由垃圾回收器释放。</p>\n<p><code>Dispose</code>意味着.NET没有什么特别的，因此仍必须取消引用已处置的对象。这使已处置但尚未回收的对象成为内存泄漏源的良好候选对象。</p>\n<h2 id=\"堆的碎片\"><a href=\"#堆的碎片\" class=\"headerlink\" title=\"堆的碎片\"></a>堆的碎片</h2><p>.NET中一个鲜为人知的限制是大对象堆的限制。成为该堆一部分的对象不会在运行时移动，这可能导致程序过早地耗尽内存。当某些对象的寿命比其他对象长时，这将导致堆在对象过去所在的位置形成孔-这称为碎片。当程序要求一个大的内存块，但堆变得非常分散，以至于没有单个内存区域足以容纳它时，就会发生问题。内存分析器可以估计程序可以分配的最大对象：如果该对象正在下降，则很可能是原因。一个<code>OutOfMemoryException</code>当程序显然具有大量可用内存时，通常会发生由碎片引起的错误–在32位系统上，进程应至少能够使用1.5Gb，但是由于碎片导致的故障通常会在使用该碎片之前开始发生很多内存。</p>\n<p>碎片化的另一个征兆是.NET通常必须保留分配给应用程序的空洞所使用的内存。这显然导致它使用比在任务管理器中查看所需的内存更多的内存。这种效果通常相对来说是无害的：Windows非常擅长于意识到未被占用的孔所占用的内存并将其分页，并且如果碎片没有恶化，则程序将不会耗尽内存。但是，对于用户而言，这看起来并不好，他们可能会认为该应用程序浪费且“ blo肿”。当探查器显示程序分配的对象仅使用少量内存，而任务管理器显示该进程占用大量空间时，通常会发生这种情况。</p>\n<h1 id=\"垃圾收集器的性能\"><a href=\"#垃圾收集器的性能\" class=\"headerlink\" title=\"垃圾收集器的性能\"></a>垃圾收集器的性能</h1><p>在性能方面，垃圾收集系统的最重要特征是垃圾收集器可以随时开始执行。这使它们不适用于定时至关重要的情况，因为任何操作的定时都可能被收集器的操作所抛弃。</p>\n<p>.NET收集器有两种主要的操作模式：并发和同步（有时称为工作站和服务器）。默认情况下，并发垃圾收集用于桌面应用程序，同步用于服务器应用程序（例如ASP.NET）。</p>\n<p>在并发模式下，.NET将尝试避免在进行收集时停止正在运行的程序。这意味着在给定的时间内应用程序可以完成的总次数较少，但应用程序不会暂停。这对交互式应用程序很有用，在交互应用程序中，给用户留下印象，即应用程序应立即做出响应，这一点很重要。</p>\n<p>在同步模式下，.NET将在垃圾收集器运行时挂起正在运行的应用程序。实际上，这总体上比并发模式更有效–垃圾回收花费相同的时间，但是不必与程序继续运行进行竞争–但是，这意味着必须执行完整的回收时会有明显的暂停。 。</p>\n<p>如果默认设置不合适，则可以在应用程序的配置文件中设置垃圾收集器的类型。当更重要的是应用程序具有高吞吐量而不是显示响应时，选择同步收集器可能很有用。</p>\n<p>在大型应用程序中，垃圾收集器需要处理的对象数量会变得非常大，这意味着访问和重新排列所有对象都将花费很长时间。为了解决这个问题，.NET使用了“分代”垃圾收集器，该垃圾收集器试图将优先级赋予较小的一组对象。这个想法是，最近创建的对象更有可能被快速释放，因此，当试图释放内存时，分代垃圾收集器会优先处理它们，因此.NET首先查看自上一次垃圾收集以来已分配的对象，并且只会开始如果无法通过这种方式释放足够的空间，请考虑使用较旧的对象。</p>\n<p>如果.NET可以自行选择收集时间，则此系统效果最佳，并且如果<code>GC.Collect</code>调用（）会中断该系统，因为这通常会导致新对象过早地变旧，这增加了在不久的将来再次进行昂贵的完整收集的可能性。</p>\n<p>具有终结器的类也会破坏垃圾收集器的平稳运行。这些类的对象不能立即删除：相反，它们进入终结器队列，并在运行终结器后从内存中删除。这意味着它们所引用的任何对象（以及那些对象所引用的任何对象，依此类推）至少也必须在此之前保留在内存中，并且在内存再次可用之前需要两次垃圾回收。如果该图包含带有终结器的许多对象，则这可能意味着垃圾收集器需要多次通过才能完全释放所有未引用的对象。</p>\n<p>有一个避免此问题的简单方法：<code>IDisposable</code>在可终结类上实现，将完成对象所需的操作移到<code>Dispose()</code>方法中并<code>GC.SuppressFinalize()</code>在最后调用。然后可以修改终结器以调用该<code>Dispose()</code>方法。<code>GC.SuppressFinalize()</code>告诉垃圾回收器，该对象不再需要终结，可以立即被垃圾回收，这可以导致更快地回收内存。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>如果您花一些时间了解垃圾收集器的工作方式，则更容易理解应用程序中的内存和性能问题。它表明，尽管.NET减轻了内存管理的负担，但并不能完全消除跟踪和管理资源的需求。但是，使用内存分析器来诊断和修复.NET中的问题更加容易。考虑到.NET在开发中尽早管理内存的方式可以帮助减少问题，但是即使那样，由于框架或第三方库的复杂性，此类问题仍然可能出现。</p>\n"},{"title":".TDD学习笔记（一）单元测试","date":"2020-04-30T11:07:00.000Z","author":"邹溪源","_content":"# 引子\n## 回顾\n虽然我很早以前就听说单元测试，也曾经多次在项目中引入单元测试框架和单元测试的实践为代码质量的提升带来了一丝助力。\n\n但这种方式更多的是从软件调试的角度出发，即将单元测试作为一种测试方法可用性的入口，而非从TDD、极限编程、或从\"Fail Fast,Fix Fast”这种获得快速反馈的方式来使用单元测试，使得实际过程中单元测试的效果并不明显。\n\n直到去年8月下旬开始参加极客学院的[TDD实战课](https://www.jiker.com/plus/2?_comefrom=jikexueyuan&_code_slot=6&_creative=190)才进一步深入了解基于TDD的单元测试的流程、方法和实践的全过程，当时也间歇性的练习了一点Args等Kata项目，才逐步体会到TDD的妙处。\n\n虽然到目前为止对于TDD的了解依然很浅，但在开发过程中，总是有意无意的“站在调用者的角度思考业务逻辑”，并尽可能的思考如何“编写可测试的代码”，总归是一种进步。\n\n## 我的教训\n总结自己学习TDD的一些经验教训：\n\n1. 需求的识别，总是按惯性一次性把整个需求全部提取了。\n2. 总是习惯于拿着代码一把梭，没有按照“Arange,Assert,Art”的步骤来规划任务。\n3. 步子迈得太大，方法拆得不够细，过程式代码的味道很浓，例如，在练习String Calculate过程中，就有非常明显的问题。当然，这也是许多初学TDD开发者的通病。\n\n![图片](https://uploader.shimo.im/f/idWlhCM560UviNjE.png!thumbnail)\n\n![图片](https://uploader.shimo.im/f/k1eYNKHvgyQAHJL8.png!thumbnail)\n\n4. 没有深刻理解“重构”的意义，只是把通过单元测试当做一个目的。\n5. Kata的练习频率依然不高，一周只有两到三次，每次不到一个小时。 \n6. 单元测试和方法的命名不太规范，无法让人产生直接的理解。\n7. 方法的代码行较多，不符合优质代码的标准。\n8. 方法间适当的空行（分段）很重要。\n# 什么是TDD\n## 定义\nTDD的全称是“测试驱动开发”，也是一种旨在提升代码质量的开发实践。这种开发实践的主要步骤是在编写产品代码之前，先编写单元测试代码，然后再由测试代码来决定写什么产品代码，其目的是取得快速反馈，并使用“illustrate the main line”方法来构建程序。\n\n测试驱动开发是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。\n\n## 原则\n在上述经验教训过程中，有些步骤其实与TDD的三原则相违背，让我们来回顾一下这三个原则：\n\n* 不允许编写任何产品代码，除非允许失败的测试通过。\n* 不允许编写多余一个的失败测试，编译成功也是失败。\n* 不允许编写多于恰好让测试通过的产品代码。\n## 步骤\nTDD其实也有一系列完整的操作流程，包括如下五个步骤：\n\n* 添加一个小的测试\n* 运行所有测试并且失败\n* 做一点修改\n* 运行所有测试并且成功\n* 重构以消除重复\n\n![图片](https://uploader.shimo.im/f/dRjAx1w2z20tzyt1.png!thumbnail)\n\n[图1（红绿重构）](https://xp123.com/articles/tdd-tcr-commits/)\n\n## 可行性之争\nTDD也是一种充满争议的开发实践，许多人都吐槽，这种方式在原本开发代码之余，还得额外花三分之一的时间来编写测试代码。不过，我还是推荐《[代码整洁之道-程序员的自我修养](https://item.jd.com/11977659.html)》这本书中，Robert Bob大叔在第5.1小节说的几句话：\n\n>1、此事已有定论！\n>2、争论已经结束！\n>3、GOTO是有害的！\n>4、TDD确实可行。\n\n他明确指出：\n\n>过去人们对TDD充满争议，就此发表了不少博客和文章，如今争议依旧来袭。所不同的是，以前人们是认真尝试着去批判和理解TDD，而现在只有夸夸奇谈而已。结论很清楚，TDD的确切实可行，而且每个开发人员都要适应和掌握TDD。\n## TCR\n在《极限中国社区》曾经介绍了一种测试驱动开发过程中的实践模式，这种实践被称为“[TCR](https://xp123.com/articles/tdd-tcr-commits/)”。\n\n在实践过程中，开发者始终保持着测试，成功则提交，失败则回滚到上次的代码这样的循环。在并使用了插件来进行自动化回滚，确保每个方法的开发时间被控制在非常小的时间粒度上。这样保证了开发者能够以非常小的步子，非常快的频率，实现代码的开发过程。\n\n![图片](https://uploader.shimo.im/f/BKMKzoRcX7MbRVwk.png!thumbnail)\n\n[TCR](https://xp123.com/articles/tdd-tcr-commits/)\n\n# Kata\n优秀的代码从来不是天生的，而是通过后天不断的练习培养出来的，尤其是要想写出符合面向对象设计的的好代码，更是需要“刻意练习”。\n\nKata被人称为是唯一的一种[练习TDD](http://www.peterprovost.org/blog/2012/05/02/kata-the-only-way-to-learn-tdd/)的形式。\n\n“Kata”是一种来自日语词汇“形式”的翻译，它描述了武术练习中，通过一种精心编排的动作模式，用来训练自己达到肌肉记忆的水平。\n\nKata的练习例子是[如此之多](http://codingdojo.org/kata/)，只要你有心，总是能在海量的示例代码中找到最适合自己的一个例子。\n\n例如，我所使用的Roy Osherove设计的例子“String Calculate”就是一个非常不错的示例。（当然，我给出的是一段反例代码。）\n\n```\n1、An empty string returns zero\n2、A single number returns the value\n3、Two numbers, comma delimited, returns the sum\n4、Two numbers, newline delimited, returns the sum\n5、Three numbers, delimited either way, returns the sum\n6、Negative numbers throw an exception\n7、Numbers greater than 1000 are ignored\n8、A single char delimiter can be defined on the first line (e.g. //# for a ‘#’ as the delimiter)\n9、A multi char delimiter can be defined on the first line (e.g. //[###] for ‘###’ as the delimiter)\n10、Many single or multi-char delimiters can be defined (each wrapped in square brackets)\n```\n当然，[FizzBuzz](http://codingkata.net/Katas/Beginner/FizzBuzz)或[The Prime Factors Kata](http://www.butunclebob.com/ArticleS.UncleBob.ThePrimeFactorsKata)，Args也是一个非常不错的示例。重要的并非例子本身，而是通过持续不断的练习，形成自己的肌肉记忆。\n在[引文](http://www.peterprovost.org/blog/2012/05/02/kata-the-only-way-to-learn-tdd/)中，作者Peter Provost认为，最好的办法：\n\n>我对人们的建议是连续两周每天早上做一个30分钟的练习。然后再选一个，每天做一次，坚持两周\n>我不建议大家在工作中练习Kata，除非他们已经准备好了。你应该通过练习一周或六次，直到你已经决定对TDD的循环非常适应为止。否则，就像参加了一场没有技术水平的比赛。\n","source":"_posts/技术/什么是TDD（一）.md","raw":"---\ntitle:  .TDD学习笔记（一）单元测试\ndate: 2020-4-30 19:07\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n# 引子\n## 回顾\n虽然我很早以前就听说单元测试，也曾经多次在项目中引入单元测试框架和单元测试的实践为代码质量的提升带来了一丝助力。\n\n但这种方式更多的是从软件调试的角度出发，即将单元测试作为一种测试方法可用性的入口，而非从TDD、极限编程、或从\"Fail Fast,Fix Fast”这种获得快速反馈的方式来使用单元测试，使得实际过程中单元测试的效果并不明显。\n\n直到去年8月下旬开始参加极客学院的[TDD实战课](https://www.jiker.com/plus/2?_comefrom=jikexueyuan&_code_slot=6&_creative=190)才进一步深入了解基于TDD的单元测试的流程、方法和实践的全过程，当时也间歇性的练习了一点Args等Kata项目，才逐步体会到TDD的妙处。\n\n虽然到目前为止对于TDD的了解依然很浅，但在开发过程中，总是有意无意的“站在调用者的角度思考业务逻辑”，并尽可能的思考如何“编写可测试的代码”，总归是一种进步。\n\n## 我的教训\n总结自己学习TDD的一些经验教训：\n\n1. 需求的识别，总是按惯性一次性把整个需求全部提取了。\n2. 总是习惯于拿着代码一把梭，没有按照“Arange,Assert,Art”的步骤来规划任务。\n3. 步子迈得太大，方法拆得不够细，过程式代码的味道很浓，例如，在练习String Calculate过程中，就有非常明显的问题。当然，这也是许多初学TDD开发者的通病。\n\n![图片](https://uploader.shimo.im/f/idWlhCM560UviNjE.png!thumbnail)\n\n![图片](https://uploader.shimo.im/f/k1eYNKHvgyQAHJL8.png!thumbnail)\n\n4. 没有深刻理解“重构”的意义，只是把通过单元测试当做一个目的。\n5. Kata的练习频率依然不高，一周只有两到三次，每次不到一个小时。 \n6. 单元测试和方法的命名不太规范，无法让人产生直接的理解。\n7. 方法的代码行较多，不符合优质代码的标准。\n8. 方法间适当的空行（分段）很重要。\n# 什么是TDD\n## 定义\nTDD的全称是“测试驱动开发”，也是一种旨在提升代码质量的开发实践。这种开发实践的主要步骤是在编写产品代码之前，先编写单元测试代码，然后再由测试代码来决定写什么产品代码，其目的是取得快速反馈，并使用“illustrate the main line”方法来构建程序。\n\n测试驱动开发是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。\n\n## 原则\n在上述经验教训过程中，有些步骤其实与TDD的三原则相违背，让我们来回顾一下这三个原则：\n\n* 不允许编写任何产品代码，除非允许失败的测试通过。\n* 不允许编写多余一个的失败测试，编译成功也是失败。\n* 不允许编写多于恰好让测试通过的产品代码。\n## 步骤\nTDD其实也有一系列完整的操作流程，包括如下五个步骤：\n\n* 添加一个小的测试\n* 运行所有测试并且失败\n* 做一点修改\n* 运行所有测试并且成功\n* 重构以消除重复\n\n![图片](https://uploader.shimo.im/f/dRjAx1w2z20tzyt1.png!thumbnail)\n\n[图1（红绿重构）](https://xp123.com/articles/tdd-tcr-commits/)\n\n## 可行性之争\nTDD也是一种充满争议的开发实践，许多人都吐槽，这种方式在原本开发代码之余，还得额外花三分之一的时间来编写测试代码。不过，我还是推荐《[代码整洁之道-程序员的自我修养](https://item.jd.com/11977659.html)》这本书中，Robert Bob大叔在第5.1小节说的几句话：\n\n>1、此事已有定论！\n>2、争论已经结束！\n>3、GOTO是有害的！\n>4、TDD确实可行。\n\n他明确指出：\n\n>过去人们对TDD充满争议，就此发表了不少博客和文章，如今争议依旧来袭。所不同的是，以前人们是认真尝试着去批判和理解TDD，而现在只有夸夸奇谈而已。结论很清楚，TDD的确切实可行，而且每个开发人员都要适应和掌握TDD。\n## TCR\n在《极限中国社区》曾经介绍了一种测试驱动开发过程中的实践模式，这种实践被称为“[TCR](https://xp123.com/articles/tdd-tcr-commits/)”。\n\n在实践过程中，开发者始终保持着测试，成功则提交，失败则回滚到上次的代码这样的循环。在并使用了插件来进行自动化回滚，确保每个方法的开发时间被控制在非常小的时间粒度上。这样保证了开发者能够以非常小的步子，非常快的频率，实现代码的开发过程。\n\n![图片](https://uploader.shimo.im/f/BKMKzoRcX7MbRVwk.png!thumbnail)\n\n[TCR](https://xp123.com/articles/tdd-tcr-commits/)\n\n# Kata\n优秀的代码从来不是天生的，而是通过后天不断的练习培养出来的，尤其是要想写出符合面向对象设计的的好代码，更是需要“刻意练习”。\n\nKata被人称为是唯一的一种[练习TDD](http://www.peterprovost.org/blog/2012/05/02/kata-the-only-way-to-learn-tdd/)的形式。\n\n“Kata”是一种来自日语词汇“形式”的翻译，它描述了武术练习中，通过一种精心编排的动作模式，用来训练自己达到肌肉记忆的水平。\n\nKata的练习例子是[如此之多](http://codingdojo.org/kata/)，只要你有心，总是能在海量的示例代码中找到最适合自己的一个例子。\n\n例如，我所使用的Roy Osherove设计的例子“String Calculate”就是一个非常不错的示例。（当然，我给出的是一段反例代码。）\n\n```\n1、An empty string returns zero\n2、A single number returns the value\n3、Two numbers, comma delimited, returns the sum\n4、Two numbers, newline delimited, returns the sum\n5、Three numbers, delimited either way, returns the sum\n6、Negative numbers throw an exception\n7、Numbers greater than 1000 are ignored\n8、A single char delimiter can be defined on the first line (e.g. //# for a ‘#’ as the delimiter)\n9、A multi char delimiter can be defined on the first line (e.g. //[###] for ‘###’ as the delimiter)\n10、Many single or multi-char delimiters can be defined (each wrapped in square brackets)\n```\n当然，[FizzBuzz](http://codingkata.net/Katas/Beginner/FizzBuzz)或[The Prime Factors Kata](http://www.butunclebob.com/ArticleS.UncleBob.ThePrimeFactorsKata)，Args也是一个非常不错的示例。重要的并非例子本身，而是通过持续不断的练习，形成自己的肌肉记忆。\n在[引文](http://www.peterprovost.org/blog/2012/05/02/kata-the-only-way-to-learn-tdd/)中，作者Peter Provost认为，最好的办法：\n\n>我对人们的建议是连续两周每天早上做一个30分钟的练习。然后再选一个，每天做一次，坚持两周\n>我不建议大家在工作中练习Kata，除非他们已经准备好了。你应该通过练习一周或六次，直到你已经决定对TDD的循环非常适应为止。否则，就像参加了一场没有技术水平的比赛。\n","slug":"技术/什么是TDD（一）","published":1,"updated":"2020-05-26T11:08:52.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt7a000sn4vi1dumzrjm","content":"<h1 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h1><h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>虽然我很早以前就听说单元测试，也曾经多次在项目中引入单元测试框架和单元测试的实践为代码质量的提升带来了一丝助力。</p>\n<p>但这种方式更多的是从软件调试的角度出发，即将单元测试作为一种测试方法可用性的入口，而非从TDD、极限编程、或从”Fail Fast,Fix Fast”这种获得快速反馈的方式来使用单元测试，使得实际过程中单元测试的效果并不明显。</p>\n<p>直到去年8月下旬开始参加极客学院的<a href=\"https://www.jiker.com/plus/2?_comefrom=jikexueyuan&_code_slot=6&_creative=190\" target=\"_blank\" rel=\"noopener\">TDD实战课</a>才进一步深入了解基于TDD的单元测试的流程、方法和实践的全过程，当时也间歇性的练习了一点Args等Kata项目，才逐步体会到TDD的妙处。</p>\n<p>虽然到目前为止对于TDD的了解依然很浅，但在开发过程中，总是有意无意的“站在调用者的角度思考业务逻辑”，并尽可能的思考如何“编写可测试的代码”，总归是一种进步。</p>\n<h2 id=\"我的教训\"><a href=\"#我的教训\" class=\"headerlink\" title=\"我的教训\"></a>我的教训</h2><p>总结自己学习TDD的一些经验教训：</p>\n<ol>\n<li>需求的识别，总是按惯性一次性把整个需求全部提取了。</li>\n<li>总是习惯于拿着代码一把梭，没有按照“Arange,Assert,Art”的步骤来规划任务。</li>\n<li>步子迈得太大，方法拆得不够细，过程式代码的味道很浓，例如，在练习String Calculate过程中，就有非常明显的问题。当然，这也是许多初学TDD开发者的通病。</li>\n</ol>\n<p><img src=\"https://uploader.shimo.im/f/idWlhCM560UviNjE.png!thumbnail\" alt=\"图片\"></p>\n<p><img src=\"https://uploader.shimo.im/f/k1eYNKHvgyQAHJL8.png!thumbnail\" alt=\"图片\"></p>\n<ol start=\"4\">\n<li>没有深刻理解“重构”的意义，只是把通过单元测试当做一个目的。</li>\n<li>Kata的练习频率依然不高，一周只有两到三次，每次不到一个小时。 </li>\n<li>单元测试和方法的命名不太规范，无法让人产生直接的理解。</li>\n<li>方法的代码行较多，不符合优质代码的标准。</li>\n<li>方法间适当的空行（分段）很重要。<h1 id=\"什么是TDD\"><a href=\"#什么是TDD\" class=\"headerlink\" title=\"什么是TDD\"></a>什么是TDD</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2>TDD的全称是“测试驱动开发”，也是一种旨在提升代码质量的开发实践。这种开发实践的主要步骤是在编写产品代码之前，先编写单元测试代码，然后再由测试代码来决定写什么产品代码，其目的是取得快速反馈，并使用“illustrate the main line”方法来构建程序。</li>\n</ol>\n<p>测试驱动开发是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。</p>\n<h2 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h2><p>在上述经验教训过程中，有些步骤其实与TDD的三原则相违背，让我们来回顾一下这三个原则：</p>\n<ul>\n<li><p>不允许编写任何产品代码，除非允许失败的测试通过。</p>\n</li>\n<li><p>不允许编写多余一个的失败测试，编译成功也是失败。</p>\n</li>\n<li><p>不允许编写多于恰好让测试通过的产品代码。</p>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><p>TDD其实也有一系列完整的操作流程，包括如下五个步骤：</p>\n</li>\n<li><p>添加一个小的测试</p>\n</li>\n<li><p>运行所有测试并且失败</p>\n</li>\n<li><p>做一点修改</p>\n</li>\n<li><p>运行所有测试并且成功</p>\n</li>\n<li><p>重构以消除重复</p>\n</li>\n</ul>\n<p><img src=\"https://uploader.shimo.im/f/dRjAx1w2z20tzyt1.png!thumbnail\" alt=\"图片\"></p>\n<p><a href=\"https://xp123.com/articles/tdd-tcr-commits/\" target=\"_blank\" rel=\"noopener\">图1（红绿重构）</a></p>\n<h2 id=\"可行性之争\"><a href=\"#可行性之争\" class=\"headerlink\" title=\"可行性之争\"></a>可行性之争</h2><p>TDD也是一种充满争议的开发实践，许多人都吐槽，这种方式在原本开发代码之余，还得额外花三分之一的时间来编写测试代码。不过，我还是推荐《<a href=\"https://item.jd.com/11977659.html\" target=\"_blank\" rel=\"noopener\">代码整洁之道-程序员的自我修养</a>》这本书中，Robert Bob大叔在第5.1小节说的几句话：</p>\n<blockquote>\n<p>1、此事已有定论！<br>2、争论已经结束！<br>3、GOTO是有害的！<br>4、TDD确实可行。</p>\n</blockquote>\n<p>他明确指出：</p>\n<blockquote>\n<p>过去人们对TDD充满争议，就此发表了不少博客和文章，如今争议依旧来袭。所不同的是，以前人们是认真尝试着去批判和理解TDD，而现在只有夸夸奇谈而已。结论很清楚，TDD的确切实可行，而且每个开发人员都要适应和掌握TDD。</p>\n</blockquote>\n<h2 id=\"TCR\"><a href=\"#TCR\" class=\"headerlink\" title=\"TCR\"></a>TCR</h2><p>在《极限中国社区》曾经介绍了一种测试驱动开发过程中的实践模式，这种实践被称为“<a href=\"https://xp123.com/articles/tdd-tcr-commits/\" target=\"_blank\" rel=\"noopener\">TCR</a>”。</p>\n<p>在实践过程中，开发者始终保持着测试，成功则提交，失败则回滚到上次的代码这样的循环。在并使用了插件来进行自动化回滚，确保每个方法的开发时间被控制在非常小的时间粒度上。这样保证了开发者能够以非常小的步子，非常快的频率，实现代码的开发过程。</p>\n<p><img src=\"https://uploader.shimo.im/f/BKMKzoRcX7MbRVwk.png!thumbnail\" alt=\"图片\"></p>\n<p><a href=\"https://xp123.com/articles/tdd-tcr-commits/\" target=\"_blank\" rel=\"noopener\">TCR</a></p>\n<h1 id=\"Kata\"><a href=\"#Kata\" class=\"headerlink\" title=\"Kata\"></a>Kata</h1><p>优秀的代码从来不是天生的，而是通过后天不断的练习培养出来的，尤其是要想写出符合面向对象设计的的好代码，更是需要“刻意练习”。</p>\n<p>Kata被人称为是唯一的一种<a href=\"http://www.peterprovost.org/blog/2012/05/02/kata-the-only-way-to-learn-tdd/\" target=\"_blank\" rel=\"noopener\">练习TDD</a>的形式。</p>\n<p>“Kata”是一种来自日语词汇“形式”的翻译，它描述了武术练习中，通过一种精心编排的动作模式，用来训练自己达到肌肉记忆的水平。</p>\n<p>Kata的练习例子是<a href=\"http://codingdojo.org/kata/\" target=\"_blank\" rel=\"noopener\">如此之多</a>，只要你有心，总是能在海量的示例代码中找到最适合自己的一个例子。</p>\n<p>例如，我所使用的Roy Osherove设计的例子“String Calculate”就是一个非常不错的示例。（当然，我给出的是一段反例代码。）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、An empty string returns zero</span><br><span class=\"line\">2、A single number returns the value</span><br><span class=\"line\">3、Two numbers, comma delimited, returns the sum</span><br><span class=\"line\">4、Two numbers, newline delimited, returns the sum</span><br><span class=\"line\">5、Three numbers, delimited either way, returns the sum</span><br><span class=\"line\">6、Negative numbers throw an exception</span><br><span class=\"line\">7、Numbers greater than 1000 are ignored</span><br><span class=\"line\">8、A single char delimiter can be defined on the first line (e.g. //# for a ‘#’ as the delimiter)</span><br><span class=\"line\">9、A multi char delimiter can be defined on the first line (e.g. //[###] for ‘###’ as the delimiter)</span><br><span class=\"line\">10、Many single or multi-char delimiters can be defined (each wrapped in square brackets)</span><br></pre></td></tr></table></figure>\n\n<p>当然，<a href=\"http://codingkata.net/Katas/Beginner/FizzBuzz\" target=\"_blank\" rel=\"noopener\">FizzBuzz</a>或<a href=\"http://www.butunclebob.com/ArticleS.UncleBob.ThePrimeFactorsKata\" target=\"_blank\" rel=\"noopener\">The Prime Factors Kata</a>，Args也是一个非常不错的示例。重要的并非例子本身，而是通过持续不断的练习，形成自己的肌肉记忆。<br>在<a href=\"http://www.peterprovost.org/blog/2012/05/02/kata-the-only-way-to-learn-tdd/\" target=\"_blank\" rel=\"noopener\">引文</a>中，作者Peter Provost认为，最好的办法：</p>\n<blockquote>\n<p>我对人们的建议是连续两周每天早上做一个30分钟的练习。然后再选一个，每天做一次，坚持两周<br>我不建议大家在工作中练习Kata，除非他们已经准备好了。你应该通过练习一周或六次，直到你已经决定对TDD的循环非常适应为止。否则，就像参加了一场没有技术水平的比赛。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h1><h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>虽然我很早以前就听说单元测试，也曾经多次在项目中引入单元测试框架和单元测试的实践为代码质量的提升带来了一丝助力。</p>\n<p>但这种方式更多的是从软件调试的角度出发，即将单元测试作为一种测试方法可用性的入口，而非从TDD、极限编程、或从”Fail Fast,Fix Fast”这种获得快速反馈的方式来使用单元测试，使得实际过程中单元测试的效果并不明显。</p>\n<p>直到去年8月下旬开始参加极客学院的<a href=\"https://www.jiker.com/plus/2?_comefrom=jikexueyuan&_code_slot=6&_creative=190\" target=\"_blank\" rel=\"noopener\">TDD实战课</a>才进一步深入了解基于TDD的单元测试的流程、方法和实践的全过程，当时也间歇性的练习了一点Args等Kata项目，才逐步体会到TDD的妙处。</p>\n<p>虽然到目前为止对于TDD的了解依然很浅，但在开发过程中，总是有意无意的“站在调用者的角度思考业务逻辑”，并尽可能的思考如何“编写可测试的代码”，总归是一种进步。</p>\n<h2 id=\"我的教训\"><a href=\"#我的教训\" class=\"headerlink\" title=\"我的教训\"></a>我的教训</h2><p>总结自己学习TDD的一些经验教训：</p>\n<ol>\n<li>需求的识别，总是按惯性一次性把整个需求全部提取了。</li>\n<li>总是习惯于拿着代码一把梭，没有按照“Arange,Assert,Art”的步骤来规划任务。</li>\n<li>步子迈得太大，方法拆得不够细，过程式代码的味道很浓，例如，在练习String Calculate过程中，就有非常明显的问题。当然，这也是许多初学TDD开发者的通病。</li>\n</ol>\n<p><img src=\"https://uploader.shimo.im/f/idWlhCM560UviNjE.png!thumbnail\" alt=\"图片\"></p>\n<p><img src=\"https://uploader.shimo.im/f/k1eYNKHvgyQAHJL8.png!thumbnail\" alt=\"图片\"></p>\n<ol start=\"4\">\n<li>没有深刻理解“重构”的意义，只是把通过单元测试当做一个目的。</li>\n<li>Kata的练习频率依然不高，一周只有两到三次，每次不到一个小时。 </li>\n<li>单元测试和方法的命名不太规范，无法让人产生直接的理解。</li>\n<li>方法的代码行较多，不符合优质代码的标准。</li>\n<li>方法间适当的空行（分段）很重要。<h1 id=\"什么是TDD\"><a href=\"#什么是TDD\" class=\"headerlink\" title=\"什么是TDD\"></a>什么是TDD</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2>TDD的全称是“测试驱动开发”，也是一种旨在提升代码质量的开发实践。这种开发实践的主要步骤是在编写产品代码之前，先编写单元测试代码，然后再由测试代码来决定写什么产品代码，其目的是取得快速反馈，并使用“illustrate the main line”方法来构建程序。</li>\n</ol>\n<p>测试驱动开发是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。</p>\n<h2 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h2><p>在上述经验教训过程中，有些步骤其实与TDD的三原则相违背，让我们来回顾一下这三个原则：</p>\n<ul>\n<li><p>不允许编写任何产品代码，除非允许失败的测试通过。</p>\n</li>\n<li><p>不允许编写多余一个的失败测试，编译成功也是失败。</p>\n</li>\n<li><p>不允许编写多于恰好让测试通过的产品代码。</p>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><p>TDD其实也有一系列完整的操作流程，包括如下五个步骤：</p>\n</li>\n<li><p>添加一个小的测试</p>\n</li>\n<li><p>运行所有测试并且失败</p>\n</li>\n<li><p>做一点修改</p>\n</li>\n<li><p>运行所有测试并且成功</p>\n</li>\n<li><p>重构以消除重复</p>\n</li>\n</ul>\n<p><img src=\"https://uploader.shimo.im/f/dRjAx1w2z20tzyt1.png!thumbnail\" alt=\"图片\"></p>\n<p><a href=\"https://xp123.com/articles/tdd-tcr-commits/\" target=\"_blank\" rel=\"noopener\">图1（红绿重构）</a></p>\n<h2 id=\"可行性之争\"><a href=\"#可行性之争\" class=\"headerlink\" title=\"可行性之争\"></a>可行性之争</h2><p>TDD也是一种充满争议的开发实践，许多人都吐槽，这种方式在原本开发代码之余，还得额外花三分之一的时间来编写测试代码。不过，我还是推荐《<a href=\"https://item.jd.com/11977659.html\" target=\"_blank\" rel=\"noopener\">代码整洁之道-程序员的自我修养</a>》这本书中，Robert Bob大叔在第5.1小节说的几句话：</p>\n<blockquote>\n<p>1、此事已有定论！<br>2、争论已经结束！<br>3、GOTO是有害的！<br>4、TDD确实可行。</p>\n</blockquote>\n<p>他明确指出：</p>\n<blockquote>\n<p>过去人们对TDD充满争议，就此发表了不少博客和文章，如今争议依旧来袭。所不同的是，以前人们是认真尝试着去批判和理解TDD，而现在只有夸夸奇谈而已。结论很清楚，TDD的确切实可行，而且每个开发人员都要适应和掌握TDD。</p>\n</blockquote>\n<h2 id=\"TCR\"><a href=\"#TCR\" class=\"headerlink\" title=\"TCR\"></a>TCR</h2><p>在《极限中国社区》曾经介绍了一种测试驱动开发过程中的实践模式，这种实践被称为“<a href=\"https://xp123.com/articles/tdd-tcr-commits/\" target=\"_blank\" rel=\"noopener\">TCR</a>”。</p>\n<p>在实践过程中，开发者始终保持着测试，成功则提交，失败则回滚到上次的代码这样的循环。在并使用了插件来进行自动化回滚，确保每个方法的开发时间被控制在非常小的时间粒度上。这样保证了开发者能够以非常小的步子，非常快的频率，实现代码的开发过程。</p>\n<p><img src=\"https://uploader.shimo.im/f/BKMKzoRcX7MbRVwk.png!thumbnail\" alt=\"图片\"></p>\n<p><a href=\"https://xp123.com/articles/tdd-tcr-commits/\" target=\"_blank\" rel=\"noopener\">TCR</a></p>\n<h1 id=\"Kata\"><a href=\"#Kata\" class=\"headerlink\" title=\"Kata\"></a>Kata</h1><p>优秀的代码从来不是天生的，而是通过后天不断的练习培养出来的，尤其是要想写出符合面向对象设计的的好代码，更是需要“刻意练习”。</p>\n<p>Kata被人称为是唯一的一种<a href=\"http://www.peterprovost.org/blog/2012/05/02/kata-the-only-way-to-learn-tdd/\" target=\"_blank\" rel=\"noopener\">练习TDD</a>的形式。</p>\n<p>“Kata”是一种来自日语词汇“形式”的翻译，它描述了武术练习中，通过一种精心编排的动作模式，用来训练自己达到肌肉记忆的水平。</p>\n<p>Kata的练习例子是<a href=\"http://codingdojo.org/kata/\" target=\"_blank\" rel=\"noopener\">如此之多</a>，只要你有心，总是能在海量的示例代码中找到最适合自己的一个例子。</p>\n<p>例如，我所使用的Roy Osherove设计的例子“String Calculate”就是一个非常不错的示例。（当然，我给出的是一段反例代码。）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、An empty string returns zero</span><br><span class=\"line\">2、A single number returns the value</span><br><span class=\"line\">3、Two numbers, comma delimited, returns the sum</span><br><span class=\"line\">4、Two numbers, newline delimited, returns the sum</span><br><span class=\"line\">5、Three numbers, delimited either way, returns the sum</span><br><span class=\"line\">6、Negative numbers throw an exception</span><br><span class=\"line\">7、Numbers greater than 1000 are ignored</span><br><span class=\"line\">8、A single char delimiter can be defined on the first line (e.g. //# for a ‘#’ as the delimiter)</span><br><span class=\"line\">9、A multi char delimiter can be defined on the first line (e.g. //[###] for ‘###’ as the delimiter)</span><br><span class=\"line\">10、Many single or multi-char delimiters can be defined (each wrapped in square brackets)</span><br></pre></td></tr></table></figure>\n\n<p>当然，<a href=\"http://codingkata.net/Katas/Beginner/FizzBuzz\" target=\"_blank\" rel=\"noopener\">FizzBuzz</a>或<a href=\"http://www.butunclebob.com/ArticleS.UncleBob.ThePrimeFactorsKata\" target=\"_blank\" rel=\"noopener\">The Prime Factors Kata</a>，Args也是一个非常不错的示例。重要的并非例子本身，而是通过持续不断的练习，形成自己的肌肉记忆。<br>在<a href=\"http://www.peterprovost.org/blog/2012/05/02/kata-the-only-way-to-learn-tdd/\" target=\"_blank\" rel=\"noopener\">引文</a>中，作者Peter Provost认为，最好的办法：</p>\n<blockquote>\n<p>我对人们的建议是连续两周每天早上做一个30分钟的练习。然后再选一个，每天做一次，坚持两周<br>我不建议大家在工作中练习Kata，除非他们已经准备好了。你应该通过练习一周或六次，直到你已经决定对TDD的循环非常适应为止。否则，就像参加了一场没有技术水平的比赛。</p>\n</blockquote>\n"},{"title":"从零开始学习TDD，测试驱动开发","date":"2019-10-09T08:28:00.000Z","author":"邹溪源","_content":"\n# 前言\n最近有幸跟随资深ThoughtWorks咨询师熊节老师一起学习测试驱动设计，经过短暂的十几天培训，对测试驱动设计的基本原则、实践模式、技巧有了一点点初步的认识。 \n在此之前，经常自嘲我经历的公司实践也似乎是TDD， 这种实践往往都是由测试工程师来驱动开发者完成bug的修改，虽然也是测试来驱动开发，但是却与真正的TDD大相径庭。\n# 什么是TDD\n在维基百科中是这样对TDD下定义的：\n>测试驱动开发（英语：Test-driven development，缩写为TDD）是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名。测试驱动开发始于20世纪90年代。测试驱动开发的目的是取得快速反馈并使用“illustrate the main line”方法来构建程序。\n>测试驱动开发是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。\n\n测试驱动开发也是国外许多优秀开发者向开发者们推荐的一种普遍适用的开发模式，而在熊节老师的培训课程中，他时刻在向开发者灌输来自TDD的三条原则，要求我们的编写生产代码前，一定应该先编写单元测试。\n>定律一：在编写不能通过的单元测试前，不可编写生产代码。\n>定律二：只可编写刚好无法通过的单元测试，不能编译也算不通过。\n>定律三：只可编写刚好足以通过当前失败测试的生产代码。\n# 简单实践\n在我之前的编码实践过程中，总是习惯梳理一遍逻辑后，在根据项目的实际情况对代码进行重构，而随着我自以为掌握了单元测试的技巧之后，就开始把逻辑代码往单元测试上套，导致这样的单元测试实际上并非为了实现测试，而仅仅只是程序的入口而已。\n如果使用TDD的方法，则需要首先规划需要实现的目标，然后再定义测试方法和测试需要实现的逻辑。\n例如，代码大概是这样的：\n![图片](https://uploader.shimo.im/f/Ky6gDprfAkoDZ6AX.png!thumbnail)\n我的目标是实现对Schema对象的解析，测试类采用SchemaUnitTest，并采用“should_xxx_when_xxx”的命名方式，定义了测试方法“should_return_true_when_bool”，然后定义一个Schemas的类，再定义其需要实现的需求（断言），以及需求的实现。\n对单元测试方法的命名，不同的书籍有不同的命名方法，在这个项目实践中，采用的是should命名方法，而在之前看过的《单元测试的艺术》一书中，使用的is_when_return_xxx的方式，这两者只是命名方法的不同，本质上没有任何区别；使用xunit和mstest实际上也没有太多区别。\n此时，这个定义的方法GetParameter是未实现的，所以会进入一个“红-绿-重构”的工作流程。\n![图片](https://uploader.shimo.im/f/XnO1c85HR4k6zVZ9.png!thumbnail)\n\n1）编写一个会失败的测试，以证明产品中代码或功能的缺失。编写代码时，要假设产品代码已经能工作了，这样测试的失败就说明产品代码中有缺陷。例如我定义的GetParameter方法使用xunit进行测试会提示失败， 只有在添加需要的代码后，编译才能通过。\n2）编写符合测试预期的产品代码，使测试通过，产品代码应该尽量简单。\n3）重构代码。如果测试通过了，你就可以编写下一个单元测试，或者重构，消除异味或提高代码可读性。\n最终，我完成了一个这样的方法。（即便是这样的代码，依然有许多可以进一步提升的空间。）\n![图片](https://uploader.shimo.im/f/9MoD9JaGfQ4JoECK.png!thumbnail)\n显然这是一个逻辑非常简单的代码，但是如果采用全键盘操作，不使用鼠标来完成，仍然耗费了我不少时间，这个过程中，也让我对Visual Studio的快捷键操作更加熟练。\n# 测试的不同阶段\n在我们的产品研发过程中，经常遇到以下三种不同形式的测试\n![图片](https://uploader.shimo.im/f/G6n019QZVDUYWkee.png!thumbnail)\n* 端到端测试：端到端测试侧重于软件功能应用层面的测试，主要使用人工或自动化的形式对用户界面进行测试。往往需要覆盖系统的各个功能，需要耗费的人力物力较大。\n* 服务测试：主要集中在服务接口层的测试，可以通过PostMan等测试工具对接口的稳定性和可用性进行测试。侧重于接口行为实现。\n* 单元测试：针对代码层面，例如单个方法或单个类实现的测试。属于白盒测试的一种。\n\n三种测试从上到下实施的容易程度递增，但是测试效果递减。端到端测试最费时费力，但是通过测试后我们对系统最有信心。单元测试最容易实施，效率也最高，但是测试后不能保证整个系统没有问题。\n在我们的项目实践中，更多的采用的依然是端到端测试的模式，似乎只有通过测试者的人肉测试，才能让我们的代码更加令人满意。\n单元测试事实上极少在我们的项目中得到实践，其主要原因大概是因为要掌握单元测试方法，本身需要对开发者的主观能动性提出了更高的要求，但是996开发者...太容易内卷化了。\n# 总结\n写好单元测试从来就是技术活，有一段时间过分在意理论概念和工具的用法，忽略了实践，所以实际上看了好几本书，依然不知道如何写单元测试，这次参与了培训，终于摸到了一点点影子。\n现阶段我大概可以这样做来逐步提高自己的技能水平：\n* 1、小步快跑，注意节奏：不要过度在意某个需求的快速实现，而是编写能够在五分钟内快速完成的代码，并确保其通过。代码行控制在五行以内，代码的缩进层次，控制在两到三层。\n* 2、练习，练习，再练习：写代码从来不是一件容易的事情，按照一万小时定律的说法，如果指望几天就熟练掌握显然不太现实，未来需要更加积极的练习，才能真正掌握。 \n* 多思考、努力写好代码：写几行代码其实并不难，难的是写高质量的代码。不要急于代码实现，要多思考上下文逻辑，让代码更加优美。\n\n参考资料：\n* [https://docs.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-best-practices](https://docs.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-best-practices) \n* [https://juejin.im/post/5c715e7d6fb9a04a0c2f12f4](https://juejin.im/post/5c715e7d6fb9a04a0c2f12f4)\n\n","source":"_posts/技术/从零开始学习TDD，测试驱动开发.md","raw":"---\ntitle:  从零开始学习TDD，测试驱动开发\ndate: 2019-10-09 16:28\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n\n# 前言\n最近有幸跟随资深ThoughtWorks咨询师熊节老师一起学习测试驱动设计，经过短暂的十几天培训，对测试驱动设计的基本原则、实践模式、技巧有了一点点初步的认识。 \n在此之前，经常自嘲我经历的公司实践也似乎是TDD， 这种实践往往都是由测试工程师来驱动开发者完成bug的修改，虽然也是测试来驱动开发，但是却与真正的TDD大相径庭。\n# 什么是TDD\n在维基百科中是这样对TDD下定义的：\n>测试驱动开发（英语：Test-driven development，缩写为TDD）是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名。测试驱动开发始于20世纪90年代。测试驱动开发的目的是取得快速反馈并使用“illustrate the main line”方法来构建程序。\n>测试驱动开发是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。\n\n测试驱动开发也是国外许多优秀开发者向开发者们推荐的一种普遍适用的开发模式，而在熊节老师的培训课程中，他时刻在向开发者灌输来自TDD的三条原则，要求我们的编写生产代码前，一定应该先编写单元测试。\n>定律一：在编写不能通过的单元测试前，不可编写生产代码。\n>定律二：只可编写刚好无法通过的单元测试，不能编译也算不通过。\n>定律三：只可编写刚好足以通过当前失败测试的生产代码。\n# 简单实践\n在我之前的编码实践过程中，总是习惯梳理一遍逻辑后，在根据项目的实际情况对代码进行重构，而随着我自以为掌握了单元测试的技巧之后，就开始把逻辑代码往单元测试上套，导致这样的单元测试实际上并非为了实现测试，而仅仅只是程序的入口而已。\n如果使用TDD的方法，则需要首先规划需要实现的目标，然后再定义测试方法和测试需要实现的逻辑。\n例如，代码大概是这样的：\n![图片](https://uploader.shimo.im/f/Ky6gDprfAkoDZ6AX.png!thumbnail)\n我的目标是实现对Schema对象的解析，测试类采用SchemaUnitTest，并采用“should_xxx_when_xxx”的命名方式，定义了测试方法“should_return_true_when_bool”，然后定义一个Schemas的类，再定义其需要实现的需求（断言），以及需求的实现。\n对单元测试方法的命名，不同的书籍有不同的命名方法，在这个项目实践中，采用的是should命名方法，而在之前看过的《单元测试的艺术》一书中，使用的is_when_return_xxx的方式，这两者只是命名方法的不同，本质上没有任何区别；使用xunit和mstest实际上也没有太多区别。\n此时，这个定义的方法GetParameter是未实现的，所以会进入一个“红-绿-重构”的工作流程。\n![图片](https://uploader.shimo.im/f/XnO1c85HR4k6zVZ9.png!thumbnail)\n\n1）编写一个会失败的测试，以证明产品中代码或功能的缺失。编写代码时，要假设产品代码已经能工作了，这样测试的失败就说明产品代码中有缺陷。例如我定义的GetParameter方法使用xunit进行测试会提示失败， 只有在添加需要的代码后，编译才能通过。\n2）编写符合测试预期的产品代码，使测试通过，产品代码应该尽量简单。\n3）重构代码。如果测试通过了，你就可以编写下一个单元测试，或者重构，消除异味或提高代码可读性。\n最终，我完成了一个这样的方法。（即便是这样的代码，依然有许多可以进一步提升的空间。）\n![图片](https://uploader.shimo.im/f/9MoD9JaGfQ4JoECK.png!thumbnail)\n显然这是一个逻辑非常简单的代码，但是如果采用全键盘操作，不使用鼠标来完成，仍然耗费了我不少时间，这个过程中，也让我对Visual Studio的快捷键操作更加熟练。\n# 测试的不同阶段\n在我们的产品研发过程中，经常遇到以下三种不同形式的测试\n![图片](https://uploader.shimo.im/f/G6n019QZVDUYWkee.png!thumbnail)\n* 端到端测试：端到端测试侧重于软件功能应用层面的测试，主要使用人工或自动化的形式对用户界面进行测试。往往需要覆盖系统的各个功能，需要耗费的人力物力较大。\n* 服务测试：主要集中在服务接口层的测试，可以通过PostMan等测试工具对接口的稳定性和可用性进行测试。侧重于接口行为实现。\n* 单元测试：针对代码层面，例如单个方法或单个类实现的测试。属于白盒测试的一种。\n\n三种测试从上到下实施的容易程度递增，但是测试效果递减。端到端测试最费时费力，但是通过测试后我们对系统最有信心。单元测试最容易实施，效率也最高，但是测试后不能保证整个系统没有问题。\n在我们的项目实践中，更多的采用的依然是端到端测试的模式，似乎只有通过测试者的人肉测试，才能让我们的代码更加令人满意。\n单元测试事实上极少在我们的项目中得到实践，其主要原因大概是因为要掌握单元测试方法，本身需要对开发者的主观能动性提出了更高的要求，但是996开发者...太容易内卷化了。\n# 总结\n写好单元测试从来就是技术活，有一段时间过分在意理论概念和工具的用法，忽略了实践，所以实际上看了好几本书，依然不知道如何写单元测试，这次参与了培训，终于摸到了一点点影子。\n现阶段我大概可以这样做来逐步提高自己的技能水平：\n* 1、小步快跑，注意节奏：不要过度在意某个需求的快速实现，而是编写能够在五分钟内快速完成的代码，并确保其通过。代码行控制在五行以内，代码的缩进层次，控制在两到三层。\n* 2、练习，练习，再练习：写代码从来不是一件容易的事情，按照一万小时定律的说法，如果指望几天就熟练掌握显然不太现实，未来需要更加积极的练习，才能真正掌握。 \n* 多思考、努力写好代码：写几行代码其实并不难，难的是写高质量的代码。不要急于代码实现，要多思考上下文逻辑，让代码更加优美。\n\n参考资料：\n* [https://docs.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-best-practices](https://docs.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-best-practices) \n* [https://juejin.im/post/5c715e7d6fb9a04a0c2f12f4](https://juejin.im/post/5c715e7d6fb9a04a0c2f12f4)\n\n","slug":"技术/从零开始学习TDD，测试驱动开发","published":1,"updated":"2019-10-09T10:46:01.823Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt7d000vn4vi6aa067nd","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近有幸跟随资深ThoughtWorks咨询师熊节老师一起学习测试驱动设计，经过短暂的十几天培训，对测试驱动设计的基本原则、实践模式、技巧有了一点点初步的认识。<br>在此之前，经常自嘲我经历的公司实践也似乎是TDD， 这种实践往往都是由测试工程师来驱动开发者完成bug的修改，虽然也是测试来驱动开发，但是却与真正的TDD大相径庭。</p>\n<h1 id=\"什么是TDD\"><a href=\"#什么是TDD\" class=\"headerlink\" title=\"什么是TDD\"></a>什么是TDD</h1><p>在维基百科中是这样对TDD下定义的：</p>\n<blockquote>\n<p>测试驱动开发（英语：Test-driven development，缩写为TDD）是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名。测试驱动开发始于20世纪90年代。测试驱动开发的目的是取得快速反馈并使用“illustrate the main line”方法来构建程序。<br>测试驱动开发是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。</p>\n</blockquote>\n<p>测试驱动开发也是国外许多优秀开发者向开发者们推荐的一种普遍适用的开发模式，而在熊节老师的培训课程中，他时刻在向开发者灌输来自TDD的三条原则，要求我们的编写生产代码前，一定应该先编写单元测试。</p>\n<blockquote>\n<p>定律一：在编写不能通过的单元测试前，不可编写生产代码。<br>定律二：只可编写刚好无法通过的单元测试，不能编译也算不通过。<br>定律三：只可编写刚好足以通过当前失败测试的生产代码。</p>\n</blockquote>\n<h1 id=\"简单实践\"><a href=\"#简单实践\" class=\"headerlink\" title=\"简单实践\"></a>简单实践</h1><p>在我之前的编码实践过程中，总是习惯梳理一遍逻辑后，在根据项目的实际情况对代码进行重构，而随着我自以为掌握了单元测试的技巧之后，就开始把逻辑代码往单元测试上套，导致这样的单元测试实际上并非为了实现测试，而仅仅只是程序的入口而已。<br>如果使用TDD的方法，则需要首先规划需要实现的目标，然后再定义测试方法和测试需要实现的逻辑。<br>例如，代码大概是这样的：<br><img src=\"https://uploader.shimo.im/f/Ky6gDprfAkoDZ6AX.png!thumbnail\" alt=\"图片\"><br>我的目标是实现对Schema对象的解析，测试类采用SchemaUnitTest，并采用“should_xxx_when_xxx”的命名方式，定义了测试方法“should_return_true_when_bool”，然后定义一个Schemas的类，再定义其需要实现的需求（断言），以及需求的实现。<br>对单元测试方法的命名，不同的书籍有不同的命名方法，在这个项目实践中，采用的是should命名方法，而在之前看过的《单元测试的艺术》一书中，使用的is_when_return_xxx的方式，这两者只是命名方法的不同，本质上没有任何区别；使用xunit和mstest实际上也没有太多区别。<br>此时，这个定义的方法GetParameter是未实现的，所以会进入一个“红-绿-重构”的工作流程。<br><img src=\"https://uploader.shimo.im/f/XnO1c85HR4k6zVZ9.png!thumbnail\" alt=\"图片\"></p>\n<p>1）编写一个会失败的测试，以证明产品中代码或功能的缺失。编写代码时，要假设产品代码已经能工作了，这样测试的失败就说明产品代码中有缺陷。例如我定义的GetParameter方法使用xunit进行测试会提示失败， 只有在添加需要的代码后，编译才能通过。<br>2）编写符合测试预期的产品代码，使测试通过，产品代码应该尽量简单。<br>3）重构代码。如果测试通过了，你就可以编写下一个单元测试，或者重构，消除异味或提高代码可读性。<br>最终，我完成了一个这样的方法。（即便是这样的代码，依然有许多可以进一步提升的空间。）<br><img src=\"https://uploader.shimo.im/f/9MoD9JaGfQ4JoECK.png!thumbnail\" alt=\"图片\"><br>显然这是一个逻辑非常简单的代码，但是如果采用全键盘操作，不使用鼠标来完成，仍然耗费了我不少时间，这个过程中，也让我对Visual Studio的快捷键操作更加熟练。</p>\n<h1 id=\"测试的不同阶段\"><a href=\"#测试的不同阶段\" class=\"headerlink\" title=\"测试的不同阶段\"></a>测试的不同阶段</h1><p>在我们的产品研发过程中，经常遇到以下三种不同形式的测试<br><img src=\"https://uploader.shimo.im/f/G6n019QZVDUYWkee.png!thumbnail\" alt=\"图片\"></p>\n<ul>\n<li>端到端测试：端到端测试侧重于软件功能应用层面的测试，主要使用人工或自动化的形式对用户界面进行测试。往往需要覆盖系统的各个功能，需要耗费的人力物力较大。</li>\n<li>服务测试：主要集中在服务接口层的测试，可以通过PostMan等测试工具对接口的稳定性和可用性进行测试。侧重于接口行为实现。</li>\n<li>单元测试：针对代码层面，例如单个方法或单个类实现的测试。属于白盒测试的一种。</li>\n</ul>\n<p>三种测试从上到下实施的容易程度递增，但是测试效果递减。端到端测试最费时费力，但是通过测试后我们对系统最有信心。单元测试最容易实施，效率也最高，但是测试后不能保证整个系统没有问题。<br>在我们的项目实践中，更多的采用的依然是端到端测试的模式，似乎只有通过测试者的人肉测试，才能让我们的代码更加令人满意。<br>单元测试事实上极少在我们的项目中得到实践，其主要原因大概是因为要掌握单元测试方法，本身需要对开发者的主观能动性提出了更高的要求，但是996开发者…太容易内卷化了。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>写好单元测试从来就是技术活，有一段时间过分在意理论概念和工具的用法，忽略了实践，所以实际上看了好几本书，依然不知道如何写单元测试，这次参与了培训，终于摸到了一点点影子。<br>现阶段我大概可以这样做来逐步提高自己的技能水平：</p>\n<ul>\n<li>1、小步快跑，注意节奏：不要过度在意某个需求的快速实现，而是编写能够在五分钟内快速完成的代码，并确保其通过。代码行控制在五行以内，代码的缩进层次，控制在两到三层。</li>\n<li>2、练习，练习，再练习：写代码从来不是一件容易的事情，按照一万小时定律的说法，如果指望几天就熟练掌握显然不太现实，未来需要更加积极的练习，才能真正掌握。 </li>\n<li>多思考、努力写好代码：写几行代码其实并不难，难的是写高质量的代码。不要急于代码实现，要多思考上下文逻辑，让代码更加优美。</li>\n</ul>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://docs.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-best-practices\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-best-practices</a> </li>\n<li><a href=\"https://juejin.im/post/5c715e7d6fb9a04a0c2f12f4\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c715e7d6fb9a04a0c2f12f4</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近有幸跟随资深ThoughtWorks咨询师熊节老师一起学习测试驱动设计，经过短暂的十几天培训，对测试驱动设计的基本原则、实践模式、技巧有了一点点初步的认识。<br>在此之前，经常自嘲我经历的公司实践也似乎是TDD， 这种实践往往都是由测试工程师来驱动开发者完成bug的修改，虽然也是测试来驱动开发，但是却与真正的TDD大相径庭。</p>\n<h1 id=\"什么是TDD\"><a href=\"#什么是TDD\" class=\"headerlink\" title=\"什么是TDD\"></a>什么是TDD</h1><p>在维基百科中是这样对TDD下定义的：</p>\n<blockquote>\n<p>测试驱动开发（英语：Test-driven development，缩写为TDD）是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名。测试驱动开发始于20世纪90年代。测试驱动开发的目的是取得快速反馈并使用“illustrate the main line”方法来构建程序。<br>测试驱动开发是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。</p>\n</blockquote>\n<p>测试驱动开发也是国外许多优秀开发者向开发者们推荐的一种普遍适用的开发模式，而在熊节老师的培训课程中，他时刻在向开发者灌输来自TDD的三条原则，要求我们的编写生产代码前，一定应该先编写单元测试。</p>\n<blockquote>\n<p>定律一：在编写不能通过的单元测试前，不可编写生产代码。<br>定律二：只可编写刚好无法通过的单元测试，不能编译也算不通过。<br>定律三：只可编写刚好足以通过当前失败测试的生产代码。</p>\n</blockquote>\n<h1 id=\"简单实践\"><a href=\"#简单实践\" class=\"headerlink\" title=\"简单实践\"></a>简单实践</h1><p>在我之前的编码实践过程中，总是习惯梳理一遍逻辑后，在根据项目的实际情况对代码进行重构，而随着我自以为掌握了单元测试的技巧之后，就开始把逻辑代码往单元测试上套，导致这样的单元测试实际上并非为了实现测试，而仅仅只是程序的入口而已。<br>如果使用TDD的方法，则需要首先规划需要实现的目标，然后再定义测试方法和测试需要实现的逻辑。<br>例如，代码大概是这样的：<br><img src=\"https://uploader.shimo.im/f/Ky6gDprfAkoDZ6AX.png!thumbnail\" alt=\"图片\"><br>我的目标是实现对Schema对象的解析，测试类采用SchemaUnitTest，并采用“should_xxx_when_xxx”的命名方式，定义了测试方法“should_return_true_when_bool”，然后定义一个Schemas的类，再定义其需要实现的需求（断言），以及需求的实现。<br>对单元测试方法的命名，不同的书籍有不同的命名方法，在这个项目实践中，采用的是should命名方法，而在之前看过的《单元测试的艺术》一书中，使用的is_when_return_xxx的方式，这两者只是命名方法的不同，本质上没有任何区别；使用xunit和mstest实际上也没有太多区别。<br>此时，这个定义的方法GetParameter是未实现的，所以会进入一个“红-绿-重构”的工作流程。<br><img src=\"https://uploader.shimo.im/f/XnO1c85HR4k6zVZ9.png!thumbnail\" alt=\"图片\"></p>\n<p>1）编写一个会失败的测试，以证明产品中代码或功能的缺失。编写代码时，要假设产品代码已经能工作了，这样测试的失败就说明产品代码中有缺陷。例如我定义的GetParameter方法使用xunit进行测试会提示失败， 只有在添加需要的代码后，编译才能通过。<br>2）编写符合测试预期的产品代码，使测试通过，产品代码应该尽量简单。<br>3）重构代码。如果测试通过了，你就可以编写下一个单元测试，或者重构，消除异味或提高代码可读性。<br>最终，我完成了一个这样的方法。（即便是这样的代码，依然有许多可以进一步提升的空间。）<br><img src=\"https://uploader.shimo.im/f/9MoD9JaGfQ4JoECK.png!thumbnail\" alt=\"图片\"><br>显然这是一个逻辑非常简单的代码，但是如果采用全键盘操作，不使用鼠标来完成，仍然耗费了我不少时间，这个过程中，也让我对Visual Studio的快捷键操作更加熟练。</p>\n<h1 id=\"测试的不同阶段\"><a href=\"#测试的不同阶段\" class=\"headerlink\" title=\"测试的不同阶段\"></a>测试的不同阶段</h1><p>在我们的产品研发过程中，经常遇到以下三种不同形式的测试<br><img src=\"https://uploader.shimo.im/f/G6n019QZVDUYWkee.png!thumbnail\" alt=\"图片\"></p>\n<ul>\n<li>端到端测试：端到端测试侧重于软件功能应用层面的测试，主要使用人工或自动化的形式对用户界面进行测试。往往需要覆盖系统的各个功能，需要耗费的人力物力较大。</li>\n<li>服务测试：主要集中在服务接口层的测试，可以通过PostMan等测试工具对接口的稳定性和可用性进行测试。侧重于接口行为实现。</li>\n<li>单元测试：针对代码层面，例如单个方法或单个类实现的测试。属于白盒测试的一种。</li>\n</ul>\n<p>三种测试从上到下实施的容易程度递增，但是测试效果递减。端到端测试最费时费力，但是通过测试后我们对系统最有信心。单元测试最容易实施，效率也最高，但是测试后不能保证整个系统没有问题。<br>在我们的项目实践中，更多的采用的依然是端到端测试的模式，似乎只有通过测试者的人肉测试，才能让我们的代码更加令人满意。<br>单元测试事实上极少在我们的项目中得到实践，其主要原因大概是因为要掌握单元测试方法，本身需要对开发者的主观能动性提出了更高的要求，但是996开发者…太容易内卷化了。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>写好单元测试从来就是技术活，有一段时间过分在意理论概念和工具的用法，忽略了实践，所以实际上看了好几本书，依然不知道如何写单元测试，这次参与了培训，终于摸到了一点点影子。<br>现阶段我大概可以这样做来逐步提高自己的技能水平：</p>\n<ul>\n<li>1、小步快跑，注意节奏：不要过度在意某个需求的快速实现，而是编写能够在五分钟内快速完成的代码，并确保其通过。代码行控制在五行以内，代码的缩进层次，控制在两到三层。</li>\n<li>2、练习，练习，再练习：写代码从来不是一件容易的事情，按照一万小时定律的说法，如果指望几天就熟练掌握显然不太现实，未来需要更加积极的练习，才能真正掌握。 </li>\n<li>多思考、努力写好代码：写几行代码其实并不难，难的是写高质量的代码。不要急于代码实现，要多思考上下文逻辑，让代码更加优美。</li>\n</ul>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://docs.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-best-practices\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-best-practices</a> </li>\n<li><a href=\"https://juejin.im/post/5c715e7d6fb9a04a0c2f12f4\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c715e7d6fb9a04a0c2f12f4</a></li>\n</ul>\n"},{"title":"你或许以为你不需要领域驱动设计","date":"2019-11-05T08:28:00.000Z","author":"邹溪源","_content":"# 一、易于腐化的软件设计\n犹记得刚刚参加工作时，是地图厂商四维图新集团旗下的一家子公司，主要从事规划测绘相关软件研发的公司。当时我的项目是为勘测设计院提供相对应的应用软件，对地理信息和规划相关的图纸信息，几乎已经专业水平。事实上，规划设计大概和软件设计类似，有规划的设计、或无规划的设计，造成的结果几乎是天壤之别。  \n\n我们或许很容易就能设想到一个毫无规划设计的城市，纵横交错的路网、杂乱无章式的建筑布局、各种凌乱的棚户区设计，恰好象征着软件设计的无序性，也恰好体现了软件企业在经费不足、组织缺乏管理、开发者能力不足、软件随时随地想改就改时的行业现状，只能说这样的软件是最能符合当时实际劳动生产力水平的产品。  \n\n![巴西棚户区](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/22240044.jpg) \n\n如图一所示，巴西棚户区，层层叠叠、风格迥异、密密麻麻，如果作为一个外人贸然来到这样的地方，大概很容易迷失期间、更不用说充斥在棚户区的各类毒品和黑社会。杂乱无章的建筑和街区，就像代码中错综复杂的调用链；而借助贫民区搞事的黑社会就像是代码中的异味或者bug，表面上看起来如此平静、与世无争、但是你永远也不知道啥时候会来一冷枪。 \n\n不要以为离我们很远，我们其实轻易就能写出这样的软件工程项目。不一定是“大泥球”系统，也有可能只是一些看似简单的业务系统，但内部代码逻辑，可能会复杂到令人窒息的程度。也许那个时候有个别开发者也许会试图靠自己的能力来改变局面，但是往往也会碍于屎山太大，难以下咽。\n\n大概只有最顶级的规划设计师、耗费足够多的资源，才能将这样的软件系统进行整改。然而，即便如此，如果以后没有持续维护的手段、更好的设计、仅靠老程序员或个别架构师、盲目相信将单体服务拆分成微服务，几乎不太可能实现软件未来的可持续发展。  \n\n一个良好的软件产品的一生、或许其实是一家企业一生的真实写照。\n\n在特定组织架构下，缺乏技术基因的组织有时候期待技术变革，却会开启新的泥坑。而那些渴望靠技术改变一切的技术专家，虽然拥有某些大厂微服务式架构、以及架构改造的经验，他们也试图通过自己的努力，为企业业务腾飞助力。而在他们过去的经验中，往往相信组织遇到的问题，用微服务一定能解决问题。然后大肆扩招，一年内从几个人的规模、扩招到数百人的规模，将原来的系统从单体服务、改良成为微服务。但是靠单枪匹马根本无力拯救大势，没有更好的业务拆分策略，就只能按照数据库的表名关系实现了最简单的拆分。架构改造并非每次都会百试百灵，有时甚至连原来的需求都包不住，毕竟只能看到用户界面层外观上的表面逻辑，而隐藏在业务中的那数十万行代码，哪怕包含了企业最有价值的经验财富，也由于代码过于混乱，最终抛弃在源代码管理器中，堪称化神奇为腐朽。  \n\n# # 二、易于腐化的面向过程开发\n老系统改造也好、新系统开发也好，毫无疑问，我们最容易相信的其实是老程序员经验，而程序员们掌控系统的方式，就是靠数据库建模来驱动软件开发的古老模式，而且几乎都是面向过程式的代码，这些代码的流程几乎一模一样，只需简单的按照步骤，一步步套模式，轻易就能学会。\n\n1、查看用户界面，定义需要绑定到界面的模型和层级结构。 \n\n2、设计数据库，不管什么类型的项目，先根据客户提供的业务表单、将其转化成实体关系（ER图）、然后建立对应的代码模型。有可能使用专业软件设计ER图，也有可能会使用Navicat软件设计ER图。\n\n3、设计接口，然后把数据拼凑成用户界面层所需的对象。  \n\n \n\n4、代码层次结构为传统的三层架构，严格按照用户界面层、业务逻辑层、数据访问层进行设计，有时候会引入依赖注入框架，实现不同层次间的解耦。\n\n但是有时候程序员不会严格区分需要编写的代码，究竟是属于哪个层次应该囊括的内容。于是毫无疑问，如果代码是为了实现用户界面上某些数据绑定操作，代码就往用户界面层写；或者代码是为了实现从数据库中抽取某些复杂数据、并构造成满足用户表现层逻辑的查询对象，那么就可以看到数据访问层代码中那些臃肿的SQL语句或查询方法。 \n\n正如“罗马不是一天建成的”，屎山也同样如此。这样的写法在代码刚刚编写之初并没有问题，只是随着业务变化、时间的积累、程序员的水平、方法重构、新技术新组件的引入，代码将成为屎山。\n\n这时，高级程序员们的价值，就在于他如何能够在屎山中快速找到bug、并解决问题的能力，这大概是一种不能复用、不可再生的能力，因为永远有让人看不懂的垃圾代码，而且每家企业都有自己的特点，不同企业间往往不能循环利用。我一位朋友经常吐槽，他感觉自己的价值就是守住公司那份拥有8年历史的古老代码，以便其他程序员在进行代码修改时，不会引发莫名其妙的bug让系统无法运转。\n\n \n\n\n\n# 三、过程式开发和事务脚本模式\n在现代软件工程学的教科书中，都会指出面向对象是解决软件复杂性的方法，但实际上掌握这种方法的开发者并不多。由于开发者普遍缺乏抽象化思维，所以面向数据库、面向过程式的编程习惯能够成为业界主流，并非时代的倒退，而仅仅只是在短期效率和长期维护性上，被迫做出的艰难选择。\n\n假设我们设计出的符合三层架构的系统结构图简化后，如下图所示：\n\n![简单结构](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/struct.png)\n\n我们来看看这种数据库建模的开发流程中的输出成果：\n\n1、会定义两种对象，分别是是面向UI层的模型（DTO)和数据实体（Entity）。在领域驱动设计中，将这两种称为所谓贫血模型，贫血模型，只有赋值器Set和取值器Get，（在Java里面会使用POJO 这个名词来定义）。贫血模型是为了作为保存状态或传递对象而存在，他并非按照实际用例场景对某类具体事务的抽象、也没有与对象相关的行为。\n\n2、定义数据访问层来实现数据的持久化、或者从持久层实现数据的创建过程。数据访问层存在的目的是为了构建上述贫血模型对象，这种访问机制被成为“事务脚本”。事务脚本与对象行为割裂，而且容易导致异味产生。\n\n3、与用户行为相关的操作割裂的存放在不同层。有的可能放在用户界面层、有的可能放在数据访问层、有的可能放在业务逻辑层，造成了领域知识的丢失。\n\n4、用户界面层使用接口作为外观或者一种行为、开发者会使用自己独立的风格习惯来定义这种行为，就容易造成术语和规则不统一，也会为后期产品的维护迭代造成问题。\n\n5、现在的软件设计，往往要求输出一份高保真的原型图、也会按照敏捷项目管理的流程对这份原型图建立持续更新的机制，确保原型图是需求的具体表达，但是产品语言并非统一语言，也许产品语言具有业务含义，但是由于不能指导开发者进行接口、类、持久层的设计，造成了代码与需求的割裂。在张逸老师的《领域驱动战术实践》提到他曾经使用dimension和metric两种不同的对象来定义一个维度对象，为代码造成了不必要的麻烦。我也曾经在一个项目，遇到过产品术语未能澄清，导致开发中使用style和theme两种截然不同的定义来定义与“风格”相关术语，为代码引入了不必要的纠结。\n\n# 四、领域驱动设计是什么？\n领域驱动设计引入了以下概念，但是我们无需在这篇文章中深刻理解这些概念的具体含义，我们只需知道，有这个东西。当我们开始按照领域驱动设计的方法设计一个系统时，按照前人整理的领域驱动的sample，往往就会将概念融汇贯通，达到更好的理解效果。\n\n1、统一语言：定义好产品原型，需要建立统一语言。这是一种在内部和外部都能使用的规范化用语，包括UML、适当的图、一致性的描述、以及专业术语和术语对应的英文描述。\n\n2、实体：在领域中可以通过标识进行唯一值定位的对象。\n\n3、值对象：在领域中，从其他领域或某个实体中分离出只包含某些特定属性的对象。由于不具备唯一性特征，往往无需用于数据持久化。\n\n4、聚合、聚合根：将具有相关性的对象聚合在一起，并以聚合根的形式统一对外提供访问方法和属性字段成员。\n\n5、限界上下文：领域包含核心领域、子域和通用子域，而限界上下文则是一个具体业务的流程。每个限界上下文独立于其他限界上下文而存在，独立演进、功能完备。限界上下文的识别充满技术含量。\n\n6、领域服务：包括仓储服务和工厂服务，前者负责实现对象与数据库的操作过程、封装了一系列数据库操作的方法；后者则侧重于对象的创建过程。个人认为从三层架构演进到领域驱动架构过程中，仓储服务是最接近于数据访问层的逻辑，也是让大部分领域驱动架构最终又回归到三层架构的一种通病。从对数据访问层中抽出对象、行为、数据访问，是战术设计的关键步骤。\n\n领域驱动设计引入了一堆新的架构形式，包括经典的四层架构、EDA（事件驱动架构）、CQRS架构（命令查询职责分离）。而由于Evans的原书没有过分讨论如何识别领域，后来又有许多大佬在他的基础上进行了完善，提出了许多方法，包括名词、形容词、动词建模法、事件风暴、四色建模等方法，限于篇幅，且听下回分解。\n\n![领域驱动的结构](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/ddd.png)\n\n# 五、思维的转变，才是最大的困难\n领域驱动设计，或许是解决这些问题的一剂良方，但也或许是开启了暗黑世界的大门。\n\n概念晦涩难懂、程序员们不愿意开始思维变革、技术上可能存在不预期的坑、都可能让新方法的实践陷入一滩烂泥。还有许多人以为自己看懂了领域驱动设计（包括笔者），在往项目中运用时，总是有意无意的会被过程式代码的思维定式控制，让架构回退到三层架构。\n\n由于微服务架构的兴起，让复杂系统的开发维护成为大家普遍关心的问题，使得Eric Evans于十五年前提出的这套理论，在今天绽放出了新的光芒。当然领域驱动设计仅仅只是众多面向对象编程的一种实践，通过领域驱动设计将UML等方法灵活的运用其中，通过打破原有数据库关系建模给代码造成的桎梏，让开发者能够真正的实现面向对象编程。\n\n然而思维模式的转换并非易事，从过程式代码中，抽离出与对象有关的行为，远比理解这几个概念要复杂，这需要大量经验的积累。\n\n![领域的复杂性](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/ddd-complex.png)\n\n毋庸置疑，数据库建模驱动软件开发具有速度快、学习成本低的显著特点，在许多项目中，能在短期内可以给开发者带来许多便利；而应用领域驱动设计，则可以在更长的维护周期内，给软件维护带来实质性好处。\n\n两种不同类型的开发模式，根据企业实际出发进行选择，还只是开始，但能真正运用好领域驱动设计或者UML、面向对象设计这种软件工程的美学思维来改造我们的系统，让系统绽放出更加璀璨的光芒，这才是软件设计的乐趣所在。\n\n![如何画马](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/drawhorse.png)\n\n","source":"_posts/技术/你或许以为你不需要领域驱动设计.md","raw":"\n---\ntitle:  你或许以为你不需要领域驱动设计\ndate: 2019-11-5 16:28\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n# 一、易于腐化的软件设计\n犹记得刚刚参加工作时，是地图厂商四维图新集团旗下的一家子公司，主要从事规划测绘相关软件研发的公司。当时我的项目是为勘测设计院提供相对应的应用软件，对地理信息和规划相关的图纸信息，几乎已经专业水平。事实上，规划设计大概和软件设计类似，有规划的设计、或无规划的设计，造成的结果几乎是天壤之别。  \n\n我们或许很容易就能设想到一个毫无规划设计的城市，纵横交错的路网、杂乱无章式的建筑布局、各种凌乱的棚户区设计，恰好象征着软件设计的无序性，也恰好体现了软件企业在经费不足、组织缺乏管理、开发者能力不足、软件随时随地想改就改时的行业现状，只能说这样的软件是最能符合当时实际劳动生产力水平的产品。  \n\n![巴西棚户区](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/22240044.jpg) \n\n如图一所示，巴西棚户区，层层叠叠、风格迥异、密密麻麻，如果作为一个外人贸然来到这样的地方，大概很容易迷失期间、更不用说充斥在棚户区的各类毒品和黑社会。杂乱无章的建筑和街区，就像代码中错综复杂的调用链；而借助贫民区搞事的黑社会就像是代码中的异味或者bug，表面上看起来如此平静、与世无争、但是你永远也不知道啥时候会来一冷枪。 \n\n不要以为离我们很远，我们其实轻易就能写出这样的软件工程项目。不一定是“大泥球”系统，也有可能只是一些看似简单的业务系统，但内部代码逻辑，可能会复杂到令人窒息的程度。也许那个时候有个别开发者也许会试图靠自己的能力来改变局面，但是往往也会碍于屎山太大，难以下咽。\n\n大概只有最顶级的规划设计师、耗费足够多的资源，才能将这样的软件系统进行整改。然而，即便如此，如果以后没有持续维护的手段、更好的设计、仅靠老程序员或个别架构师、盲目相信将单体服务拆分成微服务，几乎不太可能实现软件未来的可持续发展。  \n\n一个良好的软件产品的一生、或许其实是一家企业一生的真实写照。\n\n在特定组织架构下，缺乏技术基因的组织有时候期待技术变革，却会开启新的泥坑。而那些渴望靠技术改变一切的技术专家，虽然拥有某些大厂微服务式架构、以及架构改造的经验，他们也试图通过自己的努力，为企业业务腾飞助力。而在他们过去的经验中，往往相信组织遇到的问题，用微服务一定能解决问题。然后大肆扩招，一年内从几个人的规模、扩招到数百人的规模，将原来的系统从单体服务、改良成为微服务。但是靠单枪匹马根本无力拯救大势，没有更好的业务拆分策略，就只能按照数据库的表名关系实现了最简单的拆分。架构改造并非每次都会百试百灵，有时甚至连原来的需求都包不住，毕竟只能看到用户界面层外观上的表面逻辑，而隐藏在业务中的那数十万行代码，哪怕包含了企业最有价值的经验财富，也由于代码过于混乱，最终抛弃在源代码管理器中，堪称化神奇为腐朽。  \n\n# # 二、易于腐化的面向过程开发\n老系统改造也好、新系统开发也好，毫无疑问，我们最容易相信的其实是老程序员经验，而程序员们掌控系统的方式，就是靠数据库建模来驱动软件开发的古老模式，而且几乎都是面向过程式的代码，这些代码的流程几乎一模一样，只需简单的按照步骤，一步步套模式，轻易就能学会。\n\n1、查看用户界面，定义需要绑定到界面的模型和层级结构。 \n\n2、设计数据库，不管什么类型的项目，先根据客户提供的业务表单、将其转化成实体关系（ER图）、然后建立对应的代码模型。有可能使用专业软件设计ER图，也有可能会使用Navicat软件设计ER图。\n\n3、设计接口，然后把数据拼凑成用户界面层所需的对象。  \n\n \n\n4、代码层次结构为传统的三层架构，严格按照用户界面层、业务逻辑层、数据访问层进行设计，有时候会引入依赖注入框架，实现不同层次间的解耦。\n\n但是有时候程序员不会严格区分需要编写的代码，究竟是属于哪个层次应该囊括的内容。于是毫无疑问，如果代码是为了实现用户界面上某些数据绑定操作，代码就往用户界面层写；或者代码是为了实现从数据库中抽取某些复杂数据、并构造成满足用户表现层逻辑的查询对象，那么就可以看到数据访问层代码中那些臃肿的SQL语句或查询方法。 \n\n正如“罗马不是一天建成的”，屎山也同样如此。这样的写法在代码刚刚编写之初并没有问题，只是随着业务变化、时间的积累、程序员的水平、方法重构、新技术新组件的引入，代码将成为屎山。\n\n这时，高级程序员们的价值，就在于他如何能够在屎山中快速找到bug、并解决问题的能力，这大概是一种不能复用、不可再生的能力，因为永远有让人看不懂的垃圾代码，而且每家企业都有自己的特点，不同企业间往往不能循环利用。我一位朋友经常吐槽，他感觉自己的价值就是守住公司那份拥有8年历史的古老代码，以便其他程序员在进行代码修改时，不会引发莫名其妙的bug让系统无法运转。\n\n \n\n\n\n# 三、过程式开发和事务脚本模式\n在现代软件工程学的教科书中，都会指出面向对象是解决软件复杂性的方法，但实际上掌握这种方法的开发者并不多。由于开发者普遍缺乏抽象化思维，所以面向数据库、面向过程式的编程习惯能够成为业界主流，并非时代的倒退，而仅仅只是在短期效率和长期维护性上，被迫做出的艰难选择。\n\n假设我们设计出的符合三层架构的系统结构图简化后，如下图所示：\n\n![简单结构](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/struct.png)\n\n我们来看看这种数据库建模的开发流程中的输出成果：\n\n1、会定义两种对象，分别是是面向UI层的模型（DTO)和数据实体（Entity）。在领域驱动设计中，将这两种称为所谓贫血模型，贫血模型，只有赋值器Set和取值器Get，（在Java里面会使用POJO 这个名词来定义）。贫血模型是为了作为保存状态或传递对象而存在，他并非按照实际用例场景对某类具体事务的抽象、也没有与对象相关的行为。\n\n2、定义数据访问层来实现数据的持久化、或者从持久层实现数据的创建过程。数据访问层存在的目的是为了构建上述贫血模型对象，这种访问机制被成为“事务脚本”。事务脚本与对象行为割裂，而且容易导致异味产生。\n\n3、与用户行为相关的操作割裂的存放在不同层。有的可能放在用户界面层、有的可能放在数据访问层、有的可能放在业务逻辑层，造成了领域知识的丢失。\n\n4、用户界面层使用接口作为外观或者一种行为、开发者会使用自己独立的风格习惯来定义这种行为，就容易造成术语和规则不统一，也会为后期产品的维护迭代造成问题。\n\n5、现在的软件设计，往往要求输出一份高保真的原型图、也会按照敏捷项目管理的流程对这份原型图建立持续更新的机制，确保原型图是需求的具体表达，但是产品语言并非统一语言，也许产品语言具有业务含义，但是由于不能指导开发者进行接口、类、持久层的设计，造成了代码与需求的割裂。在张逸老师的《领域驱动战术实践》提到他曾经使用dimension和metric两种不同的对象来定义一个维度对象，为代码造成了不必要的麻烦。我也曾经在一个项目，遇到过产品术语未能澄清，导致开发中使用style和theme两种截然不同的定义来定义与“风格”相关术语，为代码引入了不必要的纠结。\n\n# 四、领域驱动设计是什么？\n领域驱动设计引入了以下概念，但是我们无需在这篇文章中深刻理解这些概念的具体含义，我们只需知道，有这个东西。当我们开始按照领域驱动设计的方法设计一个系统时，按照前人整理的领域驱动的sample，往往就会将概念融汇贯通，达到更好的理解效果。\n\n1、统一语言：定义好产品原型，需要建立统一语言。这是一种在内部和外部都能使用的规范化用语，包括UML、适当的图、一致性的描述、以及专业术语和术语对应的英文描述。\n\n2、实体：在领域中可以通过标识进行唯一值定位的对象。\n\n3、值对象：在领域中，从其他领域或某个实体中分离出只包含某些特定属性的对象。由于不具备唯一性特征，往往无需用于数据持久化。\n\n4、聚合、聚合根：将具有相关性的对象聚合在一起，并以聚合根的形式统一对外提供访问方法和属性字段成员。\n\n5、限界上下文：领域包含核心领域、子域和通用子域，而限界上下文则是一个具体业务的流程。每个限界上下文独立于其他限界上下文而存在，独立演进、功能完备。限界上下文的识别充满技术含量。\n\n6、领域服务：包括仓储服务和工厂服务，前者负责实现对象与数据库的操作过程、封装了一系列数据库操作的方法；后者则侧重于对象的创建过程。个人认为从三层架构演进到领域驱动架构过程中，仓储服务是最接近于数据访问层的逻辑，也是让大部分领域驱动架构最终又回归到三层架构的一种通病。从对数据访问层中抽出对象、行为、数据访问，是战术设计的关键步骤。\n\n领域驱动设计引入了一堆新的架构形式，包括经典的四层架构、EDA（事件驱动架构）、CQRS架构（命令查询职责分离）。而由于Evans的原书没有过分讨论如何识别领域，后来又有许多大佬在他的基础上进行了完善，提出了许多方法，包括名词、形容词、动词建模法、事件风暴、四色建模等方法，限于篇幅，且听下回分解。\n\n![领域驱动的结构](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/ddd.png)\n\n# 五、思维的转变，才是最大的困难\n领域驱动设计，或许是解决这些问题的一剂良方，但也或许是开启了暗黑世界的大门。\n\n概念晦涩难懂、程序员们不愿意开始思维变革、技术上可能存在不预期的坑、都可能让新方法的实践陷入一滩烂泥。还有许多人以为自己看懂了领域驱动设计（包括笔者），在往项目中运用时，总是有意无意的会被过程式代码的思维定式控制，让架构回退到三层架构。\n\n由于微服务架构的兴起，让复杂系统的开发维护成为大家普遍关心的问题，使得Eric Evans于十五年前提出的这套理论，在今天绽放出了新的光芒。当然领域驱动设计仅仅只是众多面向对象编程的一种实践，通过领域驱动设计将UML等方法灵活的运用其中，通过打破原有数据库关系建模给代码造成的桎梏，让开发者能够真正的实现面向对象编程。\n\n然而思维模式的转换并非易事，从过程式代码中，抽离出与对象有关的行为，远比理解这几个概念要复杂，这需要大量经验的积累。\n\n![领域的复杂性](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/ddd-complex.png)\n\n毋庸置疑，数据库建模驱动软件开发具有速度快、学习成本低的显著特点，在许多项目中，能在短期内可以给开发者带来许多便利；而应用领域驱动设计，则可以在更长的维护周期内，给软件维护带来实质性好处。\n\n两种不同类型的开发模式，根据企业实际出发进行选择，还只是开始，但能真正运用好领域驱动设计或者UML、面向对象设计这种软件工程的美学思维来改造我们的系统，让系统绽放出更加璀璨的光芒，这才是软件设计的乐趣所在。\n\n![如何画马](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/drawhorse.png)\n\n","slug":"技术/你或许以为你不需要领域驱动设计","published":1,"updated":"2019-11-05T08:52:38.486Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt7g000yn4vi9p4ezdbd","content":"<h1 id=\"一、易于腐化的软件设计\"><a href=\"#一、易于腐化的软件设计\" class=\"headerlink\" title=\"一、易于腐化的软件设计\"></a>一、易于腐化的软件设计</h1><p>犹记得刚刚参加工作时，是地图厂商四维图新集团旗下的一家子公司，主要从事规划测绘相关软件研发的公司。当时我的项目是为勘测设计院提供相对应的应用软件，对地理信息和规划相关的图纸信息，几乎已经专业水平。事实上，规划设计大概和软件设计类似，有规划的设计、或无规划的设计，造成的结果几乎是天壤之别。  </p>\n<p>我们或许很容易就能设想到一个毫无规划设计的城市，纵横交错的路网、杂乱无章式的建筑布局、各种凌乱的棚户区设计，恰好象征着软件设计的无序性，也恰好体现了软件企业在经费不足、组织缺乏管理、开发者能力不足、软件随时随地想改就改时的行业现状，只能说这样的软件是最能符合当时实际劳动生产力水平的产品。  </p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/22240044.jpg\" alt=\"巴西棚户区\"> </p>\n<p>如图一所示，巴西棚户区，层层叠叠、风格迥异、密密麻麻，如果作为一个外人贸然来到这样的地方，大概很容易迷失期间、更不用说充斥在棚户区的各类毒品和黑社会。杂乱无章的建筑和街区，就像代码中错综复杂的调用链；而借助贫民区搞事的黑社会就像是代码中的异味或者bug，表面上看起来如此平静、与世无争、但是你永远也不知道啥时候会来一冷枪。 </p>\n<p>不要以为离我们很远，我们其实轻易就能写出这样的软件工程项目。不一定是“大泥球”系统，也有可能只是一些看似简单的业务系统，但内部代码逻辑，可能会复杂到令人窒息的程度。也许那个时候有个别开发者也许会试图靠自己的能力来改变局面，但是往往也会碍于屎山太大，难以下咽。</p>\n<p>大概只有最顶级的规划设计师、耗费足够多的资源，才能将这样的软件系统进行整改。然而，即便如此，如果以后没有持续维护的手段、更好的设计、仅靠老程序员或个别架构师、盲目相信将单体服务拆分成微服务，几乎不太可能实现软件未来的可持续发展。  </p>\n<p>一个良好的软件产品的一生、或许其实是一家企业一生的真实写照。</p>\n<p>在特定组织架构下，缺乏技术基因的组织有时候期待技术变革，却会开启新的泥坑。而那些渴望靠技术改变一切的技术专家，虽然拥有某些大厂微服务式架构、以及架构改造的经验，他们也试图通过自己的努力，为企业业务腾飞助力。而在他们过去的经验中，往往相信组织遇到的问题，用微服务一定能解决问题。然后大肆扩招，一年内从几个人的规模、扩招到数百人的规模，将原来的系统从单体服务、改良成为微服务。但是靠单枪匹马根本无力拯救大势，没有更好的业务拆分策略，就只能按照数据库的表名关系实现了最简单的拆分。架构改造并非每次都会百试百灵，有时甚至连原来的需求都包不住，毕竟只能看到用户界面层外观上的表面逻辑，而隐藏在业务中的那数十万行代码，哪怕包含了企业最有价值的经验财富，也由于代码过于混乱，最终抛弃在源代码管理器中，堪称化神奇为腐朽。  </p>\n<h1 id=\"二、易于腐化的面向过程开发\"><a href=\"#二、易于腐化的面向过程开发\" class=\"headerlink\" title=\"# 二、易于腐化的面向过程开发\"></a># 二、易于腐化的面向过程开发</h1><p>老系统改造也好、新系统开发也好，毫无疑问，我们最容易相信的其实是老程序员经验，而程序员们掌控系统的方式，就是靠数据库建模来驱动软件开发的古老模式，而且几乎都是面向过程式的代码，这些代码的流程几乎一模一样，只需简单的按照步骤，一步步套模式，轻易就能学会。</p>\n<p>1、查看用户界面，定义需要绑定到界面的模型和层级结构。 </p>\n<p>2、设计数据库，不管什么类型的项目，先根据客户提供的业务表单、将其转化成实体关系（ER图）、然后建立对应的代码模型。有可能使用专业软件设计ER图，也有可能会使用Navicat软件设计ER图。</p>\n<p>3、设计接口，然后把数据拼凑成用户界面层所需的对象。  </p>\n<p>4、代码层次结构为传统的三层架构，严格按照用户界面层、业务逻辑层、数据访问层进行设计，有时候会引入依赖注入框架，实现不同层次间的解耦。</p>\n<p>但是有时候程序员不会严格区分需要编写的代码，究竟是属于哪个层次应该囊括的内容。于是毫无疑问，如果代码是为了实现用户界面上某些数据绑定操作，代码就往用户界面层写；或者代码是为了实现从数据库中抽取某些复杂数据、并构造成满足用户表现层逻辑的查询对象，那么就可以看到数据访问层代码中那些臃肿的SQL语句或查询方法。 </p>\n<p>正如“罗马不是一天建成的”，屎山也同样如此。这样的写法在代码刚刚编写之初并没有问题，只是随着业务变化、时间的积累、程序员的水平、方法重构、新技术新组件的引入，代码将成为屎山。</p>\n<p>这时，高级程序员们的价值，就在于他如何能够在屎山中快速找到bug、并解决问题的能力，这大概是一种不能复用、不可再生的能力，因为永远有让人看不懂的垃圾代码，而且每家企业都有自己的特点，不同企业间往往不能循环利用。我一位朋友经常吐槽，他感觉自己的价值就是守住公司那份拥有8年历史的古老代码，以便其他程序员在进行代码修改时，不会引发莫名其妙的bug让系统无法运转。</p>\n<h1 id=\"三、过程式开发和事务脚本模式\"><a href=\"#三、过程式开发和事务脚本模式\" class=\"headerlink\" title=\"三、过程式开发和事务脚本模式\"></a>三、过程式开发和事务脚本模式</h1><p>在现代软件工程学的教科书中，都会指出面向对象是解决软件复杂性的方法，但实际上掌握这种方法的开发者并不多。由于开发者普遍缺乏抽象化思维，所以面向数据库、面向过程式的编程习惯能够成为业界主流，并非时代的倒退，而仅仅只是在短期效率和长期维护性上，被迫做出的艰难选择。</p>\n<p>假设我们设计出的符合三层架构的系统结构图简化后，如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/struct.png\" alt=\"简单结构\"></p>\n<p>我们来看看这种数据库建模的开发流程中的输出成果：</p>\n<p>1、会定义两种对象，分别是是面向UI层的模型（DTO)和数据实体（Entity）。在领域驱动设计中，将这两种称为所谓贫血模型，贫血模型，只有赋值器Set和取值器Get，（在Java里面会使用POJO 这个名词来定义）。贫血模型是为了作为保存状态或传递对象而存在，他并非按照实际用例场景对某类具体事务的抽象、也没有与对象相关的行为。</p>\n<p>2、定义数据访问层来实现数据的持久化、或者从持久层实现数据的创建过程。数据访问层存在的目的是为了构建上述贫血模型对象，这种访问机制被成为“事务脚本”。事务脚本与对象行为割裂，而且容易导致异味产生。</p>\n<p>3、与用户行为相关的操作割裂的存放在不同层。有的可能放在用户界面层、有的可能放在数据访问层、有的可能放在业务逻辑层，造成了领域知识的丢失。</p>\n<p>4、用户界面层使用接口作为外观或者一种行为、开发者会使用自己独立的风格习惯来定义这种行为，就容易造成术语和规则不统一，也会为后期产品的维护迭代造成问题。</p>\n<p>5、现在的软件设计，往往要求输出一份高保真的原型图、也会按照敏捷项目管理的流程对这份原型图建立持续更新的机制，确保原型图是需求的具体表达，但是产品语言并非统一语言，也许产品语言具有业务含义，但是由于不能指导开发者进行接口、类、持久层的设计，造成了代码与需求的割裂。在张逸老师的《领域驱动战术实践》提到他曾经使用dimension和metric两种不同的对象来定义一个维度对象，为代码造成了不必要的麻烦。我也曾经在一个项目，遇到过产品术语未能澄清，导致开发中使用style和theme两种截然不同的定义来定义与“风格”相关术语，为代码引入了不必要的纠结。</p>\n<h1 id=\"四、领域驱动设计是什么？\"><a href=\"#四、领域驱动设计是什么？\" class=\"headerlink\" title=\"四、领域驱动设计是什么？\"></a>四、领域驱动设计是什么？</h1><p>领域驱动设计引入了以下概念，但是我们无需在这篇文章中深刻理解这些概念的具体含义，我们只需知道，有这个东西。当我们开始按照领域驱动设计的方法设计一个系统时，按照前人整理的领域驱动的sample，往往就会将概念融汇贯通，达到更好的理解效果。</p>\n<p>1、统一语言：定义好产品原型，需要建立统一语言。这是一种在内部和外部都能使用的规范化用语，包括UML、适当的图、一致性的描述、以及专业术语和术语对应的英文描述。</p>\n<p>2、实体：在领域中可以通过标识进行唯一值定位的对象。</p>\n<p>3、值对象：在领域中，从其他领域或某个实体中分离出只包含某些特定属性的对象。由于不具备唯一性特征，往往无需用于数据持久化。</p>\n<p>4、聚合、聚合根：将具有相关性的对象聚合在一起，并以聚合根的形式统一对外提供访问方法和属性字段成员。</p>\n<p>5、限界上下文：领域包含核心领域、子域和通用子域，而限界上下文则是一个具体业务的流程。每个限界上下文独立于其他限界上下文而存在，独立演进、功能完备。限界上下文的识别充满技术含量。</p>\n<p>6、领域服务：包括仓储服务和工厂服务，前者负责实现对象与数据库的操作过程、封装了一系列数据库操作的方法；后者则侧重于对象的创建过程。个人认为从三层架构演进到领域驱动架构过程中，仓储服务是最接近于数据访问层的逻辑，也是让大部分领域驱动架构最终又回归到三层架构的一种通病。从对数据访问层中抽出对象、行为、数据访问，是战术设计的关键步骤。</p>\n<p>领域驱动设计引入了一堆新的架构形式，包括经典的四层架构、EDA（事件驱动架构）、CQRS架构（命令查询职责分离）。而由于Evans的原书没有过分讨论如何识别领域，后来又有许多大佬在他的基础上进行了完善，提出了许多方法，包括名词、形容词、动词建模法、事件风暴、四色建模等方法，限于篇幅，且听下回分解。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/ddd.png\" alt=\"领域驱动的结构\"></p>\n<h1 id=\"五、思维的转变，才是最大的困难\"><a href=\"#五、思维的转变，才是最大的困难\" class=\"headerlink\" title=\"五、思维的转变，才是最大的困难\"></a>五、思维的转变，才是最大的困难</h1><p>领域驱动设计，或许是解决这些问题的一剂良方，但也或许是开启了暗黑世界的大门。</p>\n<p>概念晦涩难懂、程序员们不愿意开始思维变革、技术上可能存在不预期的坑、都可能让新方法的实践陷入一滩烂泥。还有许多人以为自己看懂了领域驱动设计（包括笔者），在往项目中运用时，总是有意无意的会被过程式代码的思维定式控制，让架构回退到三层架构。</p>\n<p>由于微服务架构的兴起，让复杂系统的开发维护成为大家普遍关心的问题，使得Eric Evans于十五年前提出的这套理论，在今天绽放出了新的光芒。当然领域驱动设计仅仅只是众多面向对象编程的一种实践，通过领域驱动设计将UML等方法灵活的运用其中，通过打破原有数据库关系建模给代码造成的桎梏，让开发者能够真正的实现面向对象编程。</p>\n<p>然而思维模式的转换并非易事，从过程式代码中，抽离出与对象有关的行为，远比理解这几个概念要复杂，这需要大量经验的积累。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/ddd-complex.png\" alt=\"领域的复杂性\"></p>\n<p>毋庸置疑，数据库建模驱动软件开发具有速度快、学习成本低的显著特点，在许多项目中，能在短期内可以给开发者带来许多便利；而应用领域驱动设计，则可以在更长的维护周期内，给软件维护带来实质性好处。</p>\n<p>两种不同类型的开发模式，根据企业实际出发进行选择，还只是开始，但能真正运用好领域驱动设计或者UML、面向对象设计这种软件工程的美学思维来改造我们的系统，让系统绽放出更加璀璨的光芒，这才是软件设计的乐趣所在。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/drawhorse.png\" alt=\"如何画马\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、易于腐化的软件设计\"><a href=\"#一、易于腐化的软件设计\" class=\"headerlink\" title=\"一、易于腐化的软件设计\"></a>一、易于腐化的软件设计</h1><p>犹记得刚刚参加工作时，是地图厂商四维图新集团旗下的一家子公司，主要从事规划测绘相关软件研发的公司。当时我的项目是为勘测设计院提供相对应的应用软件，对地理信息和规划相关的图纸信息，几乎已经专业水平。事实上，规划设计大概和软件设计类似，有规划的设计、或无规划的设计，造成的结果几乎是天壤之别。  </p>\n<p>我们或许很容易就能设想到一个毫无规划设计的城市，纵横交错的路网、杂乱无章式的建筑布局、各种凌乱的棚户区设计，恰好象征着软件设计的无序性，也恰好体现了软件企业在经费不足、组织缺乏管理、开发者能力不足、软件随时随地想改就改时的行业现状，只能说这样的软件是最能符合当时实际劳动生产力水平的产品。  </p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/22240044.jpg\" alt=\"巴西棚户区\"> </p>\n<p>如图一所示，巴西棚户区，层层叠叠、风格迥异、密密麻麻，如果作为一个外人贸然来到这样的地方，大概很容易迷失期间、更不用说充斥在棚户区的各类毒品和黑社会。杂乱无章的建筑和街区，就像代码中错综复杂的调用链；而借助贫民区搞事的黑社会就像是代码中的异味或者bug，表面上看起来如此平静、与世无争、但是你永远也不知道啥时候会来一冷枪。 </p>\n<p>不要以为离我们很远，我们其实轻易就能写出这样的软件工程项目。不一定是“大泥球”系统，也有可能只是一些看似简单的业务系统，但内部代码逻辑，可能会复杂到令人窒息的程度。也许那个时候有个别开发者也许会试图靠自己的能力来改变局面，但是往往也会碍于屎山太大，难以下咽。</p>\n<p>大概只有最顶级的规划设计师、耗费足够多的资源，才能将这样的软件系统进行整改。然而，即便如此，如果以后没有持续维护的手段、更好的设计、仅靠老程序员或个别架构师、盲目相信将单体服务拆分成微服务，几乎不太可能实现软件未来的可持续发展。  </p>\n<p>一个良好的软件产品的一生、或许其实是一家企业一生的真实写照。</p>\n<p>在特定组织架构下，缺乏技术基因的组织有时候期待技术变革，却会开启新的泥坑。而那些渴望靠技术改变一切的技术专家，虽然拥有某些大厂微服务式架构、以及架构改造的经验，他们也试图通过自己的努力，为企业业务腾飞助力。而在他们过去的经验中，往往相信组织遇到的问题，用微服务一定能解决问题。然后大肆扩招，一年内从几个人的规模、扩招到数百人的规模，将原来的系统从单体服务、改良成为微服务。但是靠单枪匹马根本无力拯救大势，没有更好的业务拆分策略，就只能按照数据库的表名关系实现了最简单的拆分。架构改造并非每次都会百试百灵，有时甚至连原来的需求都包不住，毕竟只能看到用户界面层外观上的表面逻辑，而隐藏在业务中的那数十万行代码，哪怕包含了企业最有价值的经验财富，也由于代码过于混乱，最终抛弃在源代码管理器中，堪称化神奇为腐朽。  </p>\n<h1 id=\"二、易于腐化的面向过程开发\"><a href=\"#二、易于腐化的面向过程开发\" class=\"headerlink\" title=\"# 二、易于腐化的面向过程开发\"></a># 二、易于腐化的面向过程开发</h1><p>老系统改造也好、新系统开发也好，毫无疑问，我们最容易相信的其实是老程序员经验，而程序员们掌控系统的方式，就是靠数据库建模来驱动软件开发的古老模式，而且几乎都是面向过程式的代码，这些代码的流程几乎一模一样，只需简单的按照步骤，一步步套模式，轻易就能学会。</p>\n<p>1、查看用户界面，定义需要绑定到界面的模型和层级结构。 </p>\n<p>2、设计数据库，不管什么类型的项目，先根据客户提供的业务表单、将其转化成实体关系（ER图）、然后建立对应的代码模型。有可能使用专业软件设计ER图，也有可能会使用Navicat软件设计ER图。</p>\n<p>3、设计接口，然后把数据拼凑成用户界面层所需的对象。  </p>\n<p>4、代码层次结构为传统的三层架构，严格按照用户界面层、业务逻辑层、数据访问层进行设计，有时候会引入依赖注入框架，实现不同层次间的解耦。</p>\n<p>但是有时候程序员不会严格区分需要编写的代码，究竟是属于哪个层次应该囊括的内容。于是毫无疑问，如果代码是为了实现用户界面上某些数据绑定操作，代码就往用户界面层写；或者代码是为了实现从数据库中抽取某些复杂数据、并构造成满足用户表现层逻辑的查询对象，那么就可以看到数据访问层代码中那些臃肿的SQL语句或查询方法。 </p>\n<p>正如“罗马不是一天建成的”，屎山也同样如此。这样的写法在代码刚刚编写之初并没有问题，只是随着业务变化、时间的积累、程序员的水平、方法重构、新技术新组件的引入，代码将成为屎山。</p>\n<p>这时，高级程序员们的价值，就在于他如何能够在屎山中快速找到bug、并解决问题的能力，这大概是一种不能复用、不可再生的能力，因为永远有让人看不懂的垃圾代码，而且每家企业都有自己的特点，不同企业间往往不能循环利用。我一位朋友经常吐槽，他感觉自己的价值就是守住公司那份拥有8年历史的古老代码，以便其他程序员在进行代码修改时，不会引发莫名其妙的bug让系统无法运转。</p>\n<h1 id=\"三、过程式开发和事务脚本模式\"><a href=\"#三、过程式开发和事务脚本模式\" class=\"headerlink\" title=\"三、过程式开发和事务脚本模式\"></a>三、过程式开发和事务脚本模式</h1><p>在现代软件工程学的教科书中，都会指出面向对象是解决软件复杂性的方法，但实际上掌握这种方法的开发者并不多。由于开发者普遍缺乏抽象化思维，所以面向数据库、面向过程式的编程习惯能够成为业界主流，并非时代的倒退，而仅仅只是在短期效率和长期维护性上，被迫做出的艰难选择。</p>\n<p>假设我们设计出的符合三层架构的系统结构图简化后，如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/struct.png\" alt=\"简单结构\"></p>\n<p>我们来看看这种数据库建模的开发流程中的输出成果：</p>\n<p>1、会定义两种对象，分别是是面向UI层的模型（DTO)和数据实体（Entity）。在领域驱动设计中，将这两种称为所谓贫血模型，贫血模型，只有赋值器Set和取值器Get，（在Java里面会使用POJO 这个名词来定义）。贫血模型是为了作为保存状态或传递对象而存在，他并非按照实际用例场景对某类具体事务的抽象、也没有与对象相关的行为。</p>\n<p>2、定义数据访问层来实现数据的持久化、或者从持久层实现数据的创建过程。数据访问层存在的目的是为了构建上述贫血模型对象，这种访问机制被成为“事务脚本”。事务脚本与对象行为割裂，而且容易导致异味产生。</p>\n<p>3、与用户行为相关的操作割裂的存放在不同层。有的可能放在用户界面层、有的可能放在数据访问层、有的可能放在业务逻辑层，造成了领域知识的丢失。</p>\n<p>4、用户界面层使用接口作为外观或者一种行为、开发者会使用自己独立的风格习惯来定义这种行为，就容易造成术语和规则不统一，也会为后期产品的维护迭代造成问题。</p>\n<p>5、现在的软件设计，往往要求输出一份高保真的原型图、也会按照敏捷项目管理的流程对这份原型图建立持续更新的机制，确保原型图是需求的具体表达，但是产品语言并非统一语言，也许产品语言具有业务含义，但是由于不能指导开发者进行接口、类、持久层的设计，造成了代码与需求的割裂。在张逸老师的《领域驱动战术实践》提到他曾经使用dimension和metric两种不同的对象来定义一个维度对象，为代码造成了不必要的麻烦。我也曾经在一个项目，遇到过产品术语未能澄清，导致开发中使用style和theme两种截然不同的定义来定义与“风格”相关术语，为代码引入了不必要的纠结。</p>\n<h1 id=\"四、领域驱动设计是什么？\"><a href=\"#四、领域驱动设计是什么？\" class=\"headerlink\" title=\"四、领域驱动设计是什么？\"></a>四、领域驱动设计是什么？</h1><p>领域驱动设计引入了以下概念，但是我们无需在这篇文章中深刻理解这些概念的具体含义，我们只需知道，有这个东西。当我们开始按照领域驱动设计的方法设计一个系统时，按照前人整理的领域驱动的sample，往往就会将概念融汇贯通，达到更好的理解效果。</p>\n<p>1、统一语言：定义好产品原型，需要建立统一语言。这是一种在内部和外部都能使用的规范化用语，包括UML、适当的图、一致性的描述、以及专业术语和术语对应的英文描述。</p>\n<p>2、实体：在领域中可以通过标识进行唯一值定位的对象。</p>\n<p>3、值对象：在领域中，从其他领域或某个实体中分离出只包含某些特定属性的对象。由于不具备唯一性特征，往往无需用于数据持久化。</p>\n<p>4、聚合、聚合根：将具有相关性的对象聚合在一起，并以聚合根的形式统一对外提供访问方法和属性字段成员。</p>\n<p>5、限界上下文：领域包含核心领域、子域和通用子域，而限界上下文则是一个具体业务的流程。每个限界上下文独立于其他限界上下文而存在，独立演进、功能完备。限界上下文的识别充满技术含量。</p>\n<p>6、领域服务：包括仓储服务和工厂服务，前者负责实现对象与数据库的操作过程、封装了一系列数据库操作的方法；后者则侧重于对象的创建过程。个人认为从三层架构演进到领域驱动架构过程中，仓储服务是最接近于数据访问层的逻辑，也是让大部分领域驱动架构最终又回归到三层架构的一种通病。从对数据访问层中抽出对象、行为、数据访问，是战术设计的关键步骤。</p>\n<p>领域驱动设计引入了一堆新的架构形式，包括经典的四层架构、EDA（事件驱动架构）、CQRS架构（命令查询职责分离）。而由于Evans的原书没有过分讨论如何识别领域，后来又有许多大佬在他的基础上进行了完善，提出了许多方法，包括名词、形容词、动词建模法、事件风暴、四色建模等方法，限于篇幅，且听下回分解。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/ddd.png\" alt=\"领域驱动的结构\"></p>\n<h1 id=\"五、思维的转变，才是最大的困难\"><a href=\"#五、思维的转变，才是最大的困难\" class=\"headerlink\" title=\"五、思维的转变，才是最大的困难\"></a>五、思维的转变，才是最大的困难</h1><p>领域驱动设计，或许是解决这些问题的一剂良方，但也或许是开启了暗黑世界的大门。</p>\n<p>概念晦涩难懂、程序员们不愿意开始思维变革、技术上可能存在不预期的坑、都可能让新方法的实践陷入一滩烂泥。还有许多人以为自己看懂了领域驱动设计（包括笔者），在往项目中运用时，总是有意无意的会被过程式代码的思维定式控制，让架构回退到三层架构。</p>\n<p>由于微服务架构的兴起，让复杂系统的开发维护成为大家普遍关心的问题，使得Eric Evans于十五年前提出的这套理论，在今天绽放出了新的光芒。当然领域驱动设计仅仅只是众多面向对象编程的一种实践，通过领域驱动设计将UML等方法灵活的运用其中，通过打破原有数据库关系建模给代码造成的桎梏，让开发者能够真正的实现面向对象编程。</p>\n<p>然而思维模式的转换并非易事，从过程式代码中，抽离出与对象有关的行为，远比理解这几个概念要复杂，这需要大量经验的积累。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/ddd-complex.png\" alt=\"领域的复杂性\"></p>\n<p>毋庸置疑，数据库建模驱动软件开发具有速度快、学习成本低的显著特点，在许多项目中，能在短期内可以给开发者带来许多便利；而应用领域驱动设计，则可以在更长的维护周期内，给软件维护带来实质性好处。</p>\n<p>两种不同类型的开发模式，根据企业实际出发进行选择，还只是开始，但能真正运用好领域驱动设计或者UML、面向对象设计这种软件工程的美学思维来改造我们的系统，让系统绽放出更加璀璨的光芒，这才是软件设计的乐趣所在。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/ddd-9/drawhorse.png\" alt=\"如何画马\"></p>\n"},{"title":"使用自定义DelegatingHandler编写更整洁的Typed HttpClient","date":"2020-04-30T11:07:00.000Z","author":"邹溪源","_content":"# 使用自定义DelegatingHandler编写更整洁的Typed HttpClient\n\n## **简介**﻿\n\n我写了很多[HttpClient](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0)，包括类型化的客户端。自从我发现[Refit](https://github.com/reactiveui/refit)以来，我只使用了那一个，所以我只编写了很少的代码！但是我想到了你！你们中的某些人不一定会使用[Refit，](https://github.com/reactiveui/refit)因此，我将为您提供一些技巧，以使用[HttpClient消息处理程序](https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/httpclient-message-handlers)（尤其是[DelegatingHandlers）](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8)编写具有最大可重用性的[类型化HttpClient](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests)。\n\n## **编写类型化的HttpClient来转发JWT并记录错误**\n\n这是要清理的[键入的HttpClient](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests)：\n\n```\nusing DemoRefit.Models;\nusing DemoRefit.Repositories;\nusing Microsoft.AspNetCore.Authentication;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading.Tasks;\n\nnamespace DemoRefit.HttpClients\n{\n    public class CountryRepositoryClient : ICountryRepositoryClient\n    {\n        private readonly HttpClient _client;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n        private readonly ILogger<CountryRepositoryClient> _logger;\n\n        public CountryRepositoryClient(HttpClient client, ILogger<CountryRepositoryClient> logger, IHttpContextAccessor httpContextAccessor)\n        {\n            _client = client;\n            _logger = logger;\n            _httpContextAccessor = httpContextAccessor;\n        }\n\n        public async Task<IEnumerable<Country>> GetAsync()\n        {\n            try\n            {\n                string accessToken = await _httpContextAccessor.HttpContext.GetTokenAsync(\"access_token\");\n                if (string.IsNullOrEmpty(accessToken))\n                {\n                    throw new Exception(\"Access token is missing\");\n                }\n                _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"bearer\", accessToken);\n\n                var headers = _httpContextAccessor.HttpContext.Request.Headers;\n                if (headers.ContainsKey(\"X-Correlation-ID\") && !string.IsNullOrEmpty(headers[\"X-Correlation-ID\"]))\n                {\n                    _client.DefaultRequestHeaders.Add(\"X-Correlation-ID\", headers[\"X-Correlation-ID\"].ToString());\n                }\n                \n                using (HttpResponseMessage response = await _client.GetAsync(\"/api/democrud\"))\n                {\n                    response.EnsureSuccessStatusCode();\n                    return await response.Content.ReadAsAsync<IEnumerable<Country>>();\n                }\n            }\n            catch (Exception e)\n            {\n                _logger.LogError(e, \"Failed to run http query\");\n                return null;\n            }\n        }\n    }\n}\n```\n\n这里有许多事情需要清理，因为它们在您将在同一应用程序中编写的每个客户端中可能都是多余的：\n\n- 从**HttpContext**读取访问令牌\n- 令牌为空时，管理访问令牌\n- 将访问令牌附加到[HttpClient](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0)进行委派\n- 从**HttpContext**读取CorrelationId\n- 将CorrelationId附加到[HttpClient](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0)进行委托\n- 使用*EnsureSuccessStatusCode（）*验证Http查询是否成功\n\n## **编写自定义的DelegatingHandler来处理冗余代码**\n\n这是[DelegatingHandler](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8)： \t \t\n\n```\nusing Microsoft.AspNetCore.Authentication;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace DemoRefit.Handlers\n{\n    public class MyDelegatingHandler : DelegatingHandler\n    {\n        private readonly IHttpContextAccessor _httpContextAccessor;\n        private readonly ILogger<MyDelegatingHandler> _logger;\n\n        public MyDelegatingHandler(IHttpContextAccessor httpContextAccessor, ILogger<MyDelegatingHandler> logger)\n        {\n            _httpContextAccessor = httpContextAccessor;\n            _logger = logger;\n        }\n\n        protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n        {\n            HttpResponseMessage httpResponseMessage;\n            try\n            {\n                string accessToken = await _httpContextAccessor.HttpContext.GetTokenAsync(\"access_token\");\n                if (string.IsNullOrEmpty(accessToken))\n                {\n                    throw new Exception($\"Access token is missing for the request {request.RequestUri}\");\n                }\n                request.Headers.Authorization = new AuthenticationHeaderValue(\"bearer\", accessToken);\n\n                var headers = _httpContextAccessor.HttpContext.Request.Headers;\n                if (headers.ContainsKey(\"X-Correlation-ID\") && !string.IsNullOrEmpty(headers[\"X-Correlation-ID\"]))\n                {\n                    request.Headers.Add(\"X-Correlation-ID\", headers[\"X-Correlation-ID\"].ToString());\n                }\n\n                httpResponseMessage = await base.SendAsync(request, cancellationToken);\n                httpResponseMessage.EnsureSuccessStatusCode();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to run http query {RequestUri}\", request.RequestUri);\n                throw;\n            }\n            return httpResponseMessage;\n        }\n    }\n}\n```\n\n如您所见，现在它封装了用于同一应用程序中每个[HttpClient](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0)的冗余逻辑 。\n\n现在，清理后的[HttpClient](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0)如下所示：\n\n```\nusing DemoRefit.Models;\nusing DemoRefit.Repositories;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace DemoRefit.HttpClients\n{\n    public class CountryRepositoryClientV2 : ICountryRepositoryClient\n    {\n        private readonly HttpClient _client;\n        private readonly ILogger<CountryRepositoryClient> _logger;\n\n        public CountryRepositoryClientV2(HttpClient client, ILogger<CountryRepositoryClient> logger)\n        {\n            _client = client;\n            _logger = logger;\n        }\n\n        public async Task<IEnumerable<Country>> GetAsync()\n        {\n            using (HttpResponseMessage response = await _client.GetAsync(\"/api/democrud\"))\n            {\n                try\n                {\n                    return await response.Content.ReadAsAsync<IEnumerable<Country>>();\n                }\n                catch (Exception e)\n                {\n                    _logger.LogError(e, \"Failed to read content\");\n                    return null;\n                }\n            }\n        }\n    }\n}\n```\n\n好多了不是吗？🙂\n\n最后，让我们将[DelegatingHandler](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8)附加到Startup.cs中的[HttpClient](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0)：\n\n```\nusing DemoRefit.Handlers;\nusing DemoRefit.HttpClients;\nusing DemoRefit.Repositories;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Refit;\nusing System;\n\nnamespace DemoRefit\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddHttpContextAccessor();\n\n            services.AddControllers();\n\n            services.AddHttpClient<ICountryRepositoryClient, CountryRepositoryClientV2>()\n                    .ConfigureHttpClient(c => c.BaseAddress = new Uri(Configuration.GetSection(\"Apis:CountryApi:Url\").Value))\n                    .AddHttpMessageHandler<MyDelegatingHandler>();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```\n\n\n\n## **使用Refit**\n\n如果您正在使用[Refit](https://github.com/reactiveui/refit)，则绝对可以重用该[DelegatingHandler](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8)！\n\n例：\n\n```\nusing DemoRefit.Handlers;\nusing DemoRefit.HttpClients;\nusing DemoRefit.Repositories;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Refit;\nusing System;\n\nnamespace DemoRefit\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddHttpContextAccessor();\n\n            services.AddControllers();\n\n            services.AddRefitClient<ICountryRepositoryClient>()\n                    .ConfigureHttpClient(c => c.BaseAddress = new Uri(Configuration.GetSection(\"Apis:CountryApi:Url\").Value));\n                    .AddHttpMessageHandler<MyDelegatingHandler>();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```\n\n##### 轮子介绍：\n\nRefit是一个深受Square的 Retrofit 库启发的库,目前在github上共有star 4000枚，通过这个框架，可以把你的REST API变成了一个活的接口:\n\n```\npublic interface IGitHubApi\n{\n    [Get(\"/users/{user}\")]\n    Task<User> GetUser(string user);\n}\n```\n\nRestService类生成一个IGitHubApi的实现，它使用HttpClient进行调用:\n\n```\nvar gitHubApi = RestService.For<IGitHubApi>(\"https://api.github.com\");\n\nvar octocat = await gitHubApi.GetUser(\"octocat\");\n```\n\n查看更多： https://reactiveui.github.io/refit/ ","source":"_posts/技术/使用自定义DelegatingHandler编写更清洁的Typed HttpClient.md","raw":"---\ntitle:  使用自定义DelegatingHandler编写更整洁的Typed HttpClient\ndate: 2020-4-30 19:07\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n# 使用自定义DelegatingHandler编写更整洁的Typed HttpClient\n\n## **简介**﻿\n\n我写了很多[HttpClient](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0)，包括类型化的客户端。自从我发现[Refit](https://github.com/reactiveui/refit)以来，我只使用了那一个，所以我只编写了很少的代码！但是我想到了你！你们中的某些人不一定会使用[Refit，](https://github.com/reactiveui/refit)因此，我将为您提供一些技巧，以使用[HttpClient消息处理程序](https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/httpclient-message-handlers)（尤其是[DelegatingHandlers）](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8)编写具有最大可重用性的[类型化HttpClient](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests)。\n\n## **编写类型化的HttpClient来转发JWT并记录错误**\n\n这是要清理的[键入的HttpClient](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests)：\n\n```\nusing DemoRefit.Models;\nusing DemoRefit.Repositories;\nusing Microsoft.AspNetCore.Authentication;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading.Tasks;\n\nnamespace DemoRefit.HttpClients\n{\n    public class CountryRepositoryClient : ICountryRepositoryClient\n    {\n        private readonly HttpClient _client;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n        private readonly ILogger<CountryRepositoryClient> _logger;\n\n        public CountryRepositoryClient(HttpClient client, ILogger<CountryRepositoryClient> logger, IHttpContextAccessor httpContextAccessor)\n        {\n            _client = client;\n            _logger = logger;\n            _httpContextAccessor = httpContextAccessor;\n        }\n\n        public async Task<IEnumerable<Country>> GetAsync()\n        {\n            try\n            {\n                string accessToken = await _httpContextAccessor.HttpContext.GetTokenAsync(\"access_token\");\n                if (string.IsNullOrEmpty(accessToken))\n                {\n                    throw new Exception(\"Access token is missing\");\n                }\n                _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"bearer\", accessToken);\n\n                var headers = _httpContextAccessor.HttpContext.Request.Headers;\n                if (headers.ContainsKey(\"X-Correlation-ID\") && !string.IsNullOrEmpty(headers[\"X-Correlation-ID\"]))\n                {\n                    _client.DefaultRequestHeaders.Add(\"X-Correlation-ID\", headers[\"X-Correlation-ID\"].ToString());\n                }\n                \n                using (HttpResponseMessage response = await _client.GetAsync(\"/api/democrud\"))\n                {\n                    response.EnsureSuccessStatusCode();\n                    return await response.Content.ReadAsAsync<IEnumerable<Country>>();\n                }\n            }\n            catch (Exception e)\n            {\n                _logger.LogError(e, \"Failed to run http query\");\n                return null;\n            }\n        }\n    }\n}\n```\n\n这里有许多事情需要清理，因为它们在您将在同一应用程序中编写的每个客户端中可能都是多余的：\n\n- 从**HttpContext**读取访问令牌\n- 令牌为空时，管理访问令牌\n- 将访问令牌附加到[HttpClient](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0)进行委派\n- 从**HttpContext**读取CorrelationId\n- 将CorrelationId附加到[HttpClient](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0)进行委托\n- 使用*EnsureSuccessStatusCode（）*验证Http查询是否成功\n\n## **编写自定义的DelegatingHandler来处理冗余代码**\n\n这是[DelegatingHandler](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8)： \t \t\n\n```\nusing Microsoft.AspNetCore.Authentication;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace DemoRefit.Handlers\n{\n    public class MyDelegatingHandler : DelegatingHandler\n    {\n        private readonly IHttpContextAccessor _httpContextAccessor;\n        private readonly ILogger<MyDelegatingHandler> _logger;\n\n        public MyDelegatingHandler(IHttpContextAccessor httpContextAccessor, ILogger<MyDelegatingHandler> logger)\n        {\n            _httpContextAccessor = httpContextAccessor;\n            _logger = logger;\n        }\n\n        protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n        {\n            HttpResponseMessage httpResponseMessage;\n            try\n            {\n                string accessToken = await _httpContextAccessor.HttpContext.GetTokenAsync(\"access_token\");\n                if (string.IsNullOrEmpty(accessToken))\n                {\n                    throw new Exception($\"Access token is missing for the request {request.RequestUri}\");\n                }\n                request.Headers.Authorization = new AuthenticationHeaderValue(\"bearer\", accessToken);\n\n                var headers = _httpContextAccessor.HttpContext.Request.Headers;\n                if (headers.ContainsKey(\"X-Correlation-ID\") && !string.IsNullOrEmpty(headers[\"X-Correlation-ID\"]))\n                {\n                    request.Headers.Add(\"X-Correlation-ID\", headers[\"X-Correlation-ID\"].ToString());\n                }\n\n                httpResponseMessage = await base.SendAsync(request, cancellationToken);\n                httpResponseMessage.EnsureSuccessStatusCode();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to run http query {RequestUri}\", request.RequestUri);\n                throw;\n            }\n            return httpResponseMessage;\n        }\n    }\n}\n```\n\n如您所见，现在它封装了用于同一应用程序中每个[HttpClient](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0)的冗余逻辑 。\n\n现在，清理后的[HttpClient](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0)如下所示：\n\n```\nusing DemoRefit.Models;\nusing DemoRefit.Repositories;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace DemoRefit.HttpClients\n{\n    public class CountryRepositoryClientV2 : ICountryRepositoryClient\n    {\n        private readonly HttpClient _client;\n        private readonly ILogger<CountryRepositoryClient> _logger;\n\n        public CountryRepositoryClientV2(HttpClient client, ILogger<CountryRepositoryClient> logger)\n        {\n            _client = client;\n            _logger = logger;\n        }\n\n        public async Task<IEnumerable<Country>> GetAsync()\n        {\n            using (HttpResponseMessage response = await _client.GetAsync(\"/api/democrud\"))\n            {\n                try\n                {\n                    return await response.Content.ReadAsAsync<IEnumerable<Country>>();\n                }\n                catch (Exception e)\n                {\n                    _logger.LogError(e, \"Failed to read content\");\n                    return null;\n                }\n            }\n        }\n    }\n}\n```\n\n好多了不是吗？🙂\n\n最后，让我们将[DelegatingHandler](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8)附加到Startup.cs中的[HttpClient](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0)：\n\n```\nusing DemoRefit.Handlers;\nusing DemoRefit.HttpClients;\nusing DemoRefit.Repositories;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Refit;\nusing System;\n\nnamespace DemoRefit\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddHttpContextAccessor();\n\n            services.AddControllers();\n\n            services.AddHttpClient<ICountryRepositoryClient, CountryRepositoryClientV2>()\n                    .ConfigureHttpClient(c => c.BaseAddress = new Uri(Configuration.GetSection(\"Apis:CountryApi:Url\").Value))\n                    .AddHttpMessageHandler<MyDelegatingHandler>();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```\n\n\n\n## **使用Refit**\n\n如果您正在使用[Refit](https://github.com/reactiveui/refit)，则绝对可以重用该[DelegatingHandler](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8)！\n\n例：\n\n```\nusing DemoRefit.Handlers;\nusing DemoRefit.HttpClients;\nusing DemoRefit.Repositories;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Refit;\nusing System;\n\nnamespace DemoRefit\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        // This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddHttpContextAccessor();\n\n            services.AddControllers();\n\n            services.AddRefitClient<ICountryRepositoryClient>()\n                    .ConfigureHttpClient(c => c.BaseAddress = new Uri(Configuration.GetSection(\"Apis:CountryApi:Url\").Value));\n                    .AddHttpMessageHandler<MyDelegatingHandler>();\n        }\n\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```\n\n##### 轮子介绍：\n\nRefit是一个深受Square的 Retrofit 库启发的库,目前在github上共有star 4000枚，通过这个框架，可以把你的REST API变成了一个活的接口:\n\n```\npublic interface IGitHubApi\n{\n    [Get(\"/users/{user}\")]\n    Task<User> GetUser(string user);\n}\n```\n\nRestService类生成一个IGitHubApi的实现，它使用HttpClient进行调用:\n\n```\nvar gitHubApi = RestService.For<IGitHubApi>(\"https://api.github.com\");\n\nvar octocat = await gitHubApi.GetUser(\"octocat\");\n```\n\n查看更多： https://reactiveui.github.io/refit/ ","slug":"技术/使用自定义DelegatingHandler编写更清洁的Typed HttpClient","published":1,"updated":"2020-06-25T14:03:08.735Z","_id":"ckbuujt7h0011n4vivzxt16h1","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"使用自定义DelegatingHandler编写更整洁的Typed-HttpClient\"><a href=\"#使用自定义DelegatingHandler编写更整洁的Typed-HttpClient\" class=\"headerlink\" title=\"使用自定义DelegatingHandler编写更整洁的Typed HttpClient\"></a>使用自定义DelegatingHandler编写更整洁的Typed HttpClient</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介﻿\"></a><strong>简介</strong>﻿</h2><p>我写了很多<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0\" target=\"_blank\" rel=\"noopener\">HttpClient</a>，包括类型化的客户端。自从我发现<a href=\"https://github.com/reactiveui/refit\" target=\"_blank\" rel=\"noopener\">Refit</a>以来，我只使用了那一个，所以我只编写了很少的代码！但是我想到了你！你们中的某些人不一定会使用<a href=\"https://github.com/reactiveui/refit\" target=\"_blank\" rel=\"noopener\">Refit，</a>因此，我将为您提供一些技巧，以使用<a href=\"https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/httpclient-message-handlers\" target=\"_blank\" rel=\"noopener\">HttpClient消息处理程序</a>（尤其是<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">DelegatingHandlers）</a>编写具有最大可重用性的<a href=\"https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests\" target=\"_blank\" rel=\"noopener\">类型化HttpClient</a>。</p>\n<h2 id=\"编写类型化的HttpClient来转发JWT并记录错误\"><a href=\"#编写类型化的HttpClient来转发JWT并记录错误\" class=\"headerlink\" title=\"编写类型化的HttpClient来转发JWT并记录错误\"></a><strong>编写类型化的HttpClient来转发JWT并记录错误</strong></h2><p>这是要清理的<a href=\"https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests\" target=\"_blank\" rel=\"noopener\">键入的HttpClient</a>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using DemoRefit.Models;</span><br><span class=\"line\">using DemoRefit.Repositories;</span><br><span class=\"line\">using Microsoft.AspNetCore.Authentication;</span><br><span class=\"line\">using Microsoft.AspNetCore.Http;</span><br><span class=\"line\">using Microsoft.Extensions.Logging;</span><br><span class=\"line\">using System;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using System.Net.Http;</span><br><span class=\"line\">using System.Net.Http.Headers;</span><br><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace DemoRefit.HttpClients</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public class CountryRepositoryClient : ICountryRepositoryClient</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private readonly HttpClient _client;</span><br><span class=\"line\">        private readonly IHttpContextAccessor _httpContextAccessor;</span><br><span class=\"line\">        private readonly ILogger&lt;CountryRepositoryClient&gt; _logger;</span><br><span class=\"line\"></span><br><span class=\"line\">        public CountryRepositoryClient(HttpClient client, ILogger&lt;CountryRepositoryClient&gt; logger, IHttpContextAccessor httpContextAccessor)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _client = client;</span><br><span class=\"line\">            _logger = logger;</span><br><span class=\"line\">            _httpContextAccessor = httpContextAccessor;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public async Task&lt;IEnumerable&lt;Country&gt;&gt; GetAsync()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            try</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                string accessToken = await _httpContextAccessor.HttpContext.GetTokenAsync(&quot;access_token&quot;);</span><br><span class=\"line\">                if (string.IsNullOrEmpty(accessToken))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    throw new Exception(&quot;Access token is missing&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(&quot;bearer&quot;, accessToken);</span><br><span class=\"line\"></span><br><span class=\"line\">                var headers = _httpContextAccessor.HttpContext.Request.Headers;</span><br><span class=\"line\">                if (headers.ContainsKey(&quot;X-Correlation-ID&quot;) &amp;&amp; !string.IsNullOrEmpty(headers[&quot;X-Correlation-ID&quot;]))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    _client.DefaultRequestHeaders.Add(&quot;X-Correlation-ID&quot;, headers[&quot;X-Correlation-ID&quot;].ToString());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                using (HttpResponseMessage response = await _client.GetAsync(&quot;/api/democrud&quot;))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    response.EnsureSuccessStatusCode();</span><br><span class=\"line\">                    return await response.Content.ReadAsAsync&lt;IEnumerable&lt;Country&gt;&gt;();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            catch (Exception e)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                _logger.LogError(e, &quot;Failed to run http query&quot;);</span><br><span class=\"line\">                return null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有许多事情需要清理，因为它们在您将在同一应用程序中编写的每个客户端中可能都是多余的：</p>\n<ul>\n<li>从<strong>HttpContext</strong>读取访问令牌</li>\n<li>令牌为空时，管理访问令牌</li>\n<li>将访问令牌附加到<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0\" target=\"_blank\" rel=\"noopener\">HttpClient</a>进行委派</li>\n<li>从<strong>HttpContext</strong>读取CorrelationId</li>\n<li>将CorrelationId附加到<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0\" target=\"_blank\" rel=\"noopener\">HttpClient</a>进行委托</li>\n<li>使用<em>EnsureSuccessStatusCode（）</em>验证Http查询是否成功</li>\n</ul>\n<h2 id=\"编写自定义的DelegatingHandler来处理冗余代码\"><a href=\"#编写自定义的DelegatingHandler来处理冗余代码\" class=\"headerlink\" title=\"编写自定义的DelegatingHandler来处理冗余代码\"></a><strong>编写自定义的DelegatingHandler来处理冗余代码</strong></h2><p>这是<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">DelegatingHandler</a>：          </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Microsoft.AspNetCore.Authentication;</span><br><span class=\"line\">using Microsoft.AspNetCore.Http;</span><br><span class=\"line\">using Microsoft.Extensions.Logging;</span><br><span class=\"line\">using System;</span><br><span class=\"line\">using System.Net.Http;</span><br><span class=\"line\">using System.Net.Http.Headers;</span><br><span class=\"line\">using System.Threading;</span><br><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace DemoRefit.Handlers</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public class MyDelegatingHandler : DelegatingHandler</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private readonly IHttpContextAccessor _httpContextAccessor;</span><br><span class=\"line\">        private readonly ILogger&lt;MyDelegatingHandler&gt; _logger;</span><br><span class=\"line\"></span><br><span class=\"line\">        public MyDelegatingHandler(IHttpContextAccessor httpContextAccessor, ILogger&lt;MyDelegatingHandler&gt; logger)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _httpContextAccessor = httpContextAccessor;</span><br><span class=\"line\">            _logger = logger;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        protected override async Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            HttpResponseMessage httpResponseMessage;</span><br><span class=\"line\">            try</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                string accessToken = await _httpContextAccessor.HttpContext.GetTokenAsync(&quot;access_token&quot;);</span><br><span class=\"line\">                if (string.IsNullOrEmpty(accessToken))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    throw new Exception($&quot;Access token is missing for the request &#123;request.RequestUri&#125;&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                request.Headers.Authorization = new AuthenticationHeaderValue(&quot;bearer&quot;, accessToken);</span><br><span class=\"line\"></span><br><span class=\"line\">                var headers = _httpContextAccessor.HttpContext.Request.Headers;</span><br><span class=\"line\">                if (headers.ContainsKey(&quot;X-Correlation-ID&quot;) &amp;&amp; !string.IsNullOrEmpty(headers[&quot;X-Correlation-ID&quot;]))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    request.Headers.Add(&quot;X-Correlation-ID&quot;, headers[&quot;X-Correlation-ID&quot;].ToString());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                httpResponseMessage = await base.SendAsync(request, cancellationToken);</span><br><span class=\"line\">                httpResponseMessage.EnsureSuccessStatusCode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            catch (Exception ex)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                _logger.LogError(ex, &quot;Failed to run http query &#123;RequestUri&#125;&quot;, request.RequestUri);</span><br><span class=\"line\">                throw;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return httpResponseMessage;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如您所见，现在它封装了用于同一应用程序中每个<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0\" target=\"_blank\" rel=\"noopener\">HttpClient</a>的冗余逻辑 。</p>\n<p>现在，清理后的<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0\" target=\"_blank\" rel=\"noopener\">HttpClient</a>如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using DemoRefit.Models;</span><br><span class=\"line\">using DemoRefit.Repositories;</span><br><span class=\"line\">using Microsoft.Extensions.Logging;</span><br><span class=\"line\">using System;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using System.Net.Http;</span><br><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace DemoRefit.HttpClients</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public class CountryRepositoryClientV2 : ICountryRepositoryClient</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private readonly HttpClient _client;</span><br><span class=\"line\">        private readonly ILogger&lt;CountryRepositoryClient&gt; _logger;</span><br><span class=\"line\"></span><br><span class=\"line\">        public CountryRepositoryClientV2(HttpClient client, ILogger&lt;CountryRepositoryClient&gt; logger)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _client = client;</span><br><span class=\"line\">            _logger = logger;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public async Task&lt;IEnumerable&lt;Country&gt;&gt; GetAsync()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            using (HttpResponseMessage response = await _client.GetAsync(&quot;/api/democrud&quot;))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                try</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    return await response.Content.ReadAsAsync&lt;IEnumerable&lt;Country&gt;&gt;();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                catch (Exception e)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    _logger.LogError(e, &quot;Failed to read content&quot;);</span><br><span class=\"line\">                    return null;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>好多了不是吗？🙂</p>\n<p>最后，让我们将<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">DelegatingHandler</a>附加到Startup.cs中的<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0\" target=\"_blank\" rel=\"noopener\">HttpClient</a>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using DemoRefit.Handlers;</span><br><span class=\"line\">using DemoRefit.HttpClients;</span><br><span class=\"line\">using DemoRefit.Repositories;</span><br><span class=\"line\">using Microsoft.AspNetCore.Builder;</span><br><span class=\"line\">using Microsoft.AspNetCore.Hosting;</span><br><span class=\"line\">using Microsoft.Extensions.Configuration;</span><br><span class=\"line\">using Microsoft.Extensions.DependencyInjection;</span><br><span class=\"line\">using Microsoft.Extensions.Hosting;</span><br><span class=\"line\">using Refit;</span><br><span class=\"line\">using System;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace DemoRefit</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public class Startup</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        public Startup(IConfiguration configuration)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Configuration = configuration;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public IConfiguration Configuration &#123; get; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // This method gets called by the runtime. Use this method to add services to the container.</span><br><span class=\"line\">        public void ConfigureServices(IServiceCollection services)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            services.AddHttpContextAccessor();</span><br><span class=\"line\"></span><br><span class=\"line\">            services.AddControllers();</span><br><span class=\"line\"></span><br><span class=\"line\">            services.AddHttpClient&lt;ICountryRepositoryClient, CountryRepositoryClientV2&gt;()</span><br><span class=\"line\">                    .ConfigureHttpClient(c =&gt; c.BaseAddress = new Uri(Configuration.GetSection(&quot;Apis:CountryApi:Url&quot;).Value))</span><br><span class=\"line\">                    .AddHttpMessageHandler&lt;MyDelegatingHandler&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span><br><span class=\"line\">        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (env.IsDevelopment())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                app.UseDeveloperExceptionPage();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseHttpsRedirection();</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseRouting();</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseAuthorization();</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseEndpoints(endpoints =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                endpoints.MapControllers();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用Refit\"><a href=\"#使用Refit\" class=\"headerlink\" title=\"使用Refit\"></a><strong>使用Refit</strong></h2><p>如果您正在使用<a href=\"https://github.com/reactiveui/refit\" target=\"_blank\" rel=\"noopener\">Refit</a>，则绝对可以重用该<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">DelegatingHandler</a>！</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using DemoRefit.Handlers;</span><br><span class=\"line\">using DemoRefit.HttpClients;</span><br><span class=\"line\">using DemoRefit.Repositories;</span><br><span class=\"line\">using Microsoft.AspNetCore.Builder;</span><br><span class=\"line\">using Microsoft.AspNetCore.Hosting;</span><br><span class=\"line\">using Microsoft.Extensions.Configuration;</span><br><span class=\"line\">using Microsoft.Extensions.DependencyInjection;</span><br><span class=\"line\">using Microsoft.Extensions.Hosting;</span><br><span class=\"line\">using Refit;</span><br><span class=\"line\">using System;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace DemoRefit</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public class Startup</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        public Startup(IConfiguration configuration)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Configuration = configuration;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public IConfiguration Configuration &#123; get; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // This method gets called by the runtime. Use this method to add services to the container.</span><br><span class=\"line\">        public void ConfigureServices(IServiceCollection services)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            services.AddHttpContextAccessor();</span><br><span class=\"line\"></span><br><span class=\"line\">            services.AddControllers();</span><br><span class=\"line\"></span><br><span class=\"line\">            services.AddRefitClient&lt;ICountryRepositoryClient&gt;()</span><br><span class=\"line\">                    .ConfigureHttpClient(c =&gt; c.BaseAddress = new Uri(Configuration.GetSection(&quot;Apis:CountryApi:Url&quot;).Value));</span><br><span class=\"line\">                    .AddHttpMessageHandler&lt;MyDelegatingHandler&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span><br><span class=\"line\">        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (env.IsDevelopment())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                app.UseDeveloperExceptionPage();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseHttpsRedirection();</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseRouting();</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseAuthorization();</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseEndpoints(endpoints =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                endpoints.MapControllers();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"轮子介绍：\"><a href=\"#轮子介绍：\" class=\"headerlink\" title=\"轮子介绍：\"></a>轮子介绍：</h5><p>Refit是一个深受Square的 Retrofit 库启发的库,目前在github上共有star 4000枚，通过这个框架，可以把你的REST API变成了一个活的接口:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface IGitHubApi</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [Get(&quot;/users/&#123;user&#125;&quot;)]</span><br><span class=\"line\">    Task&lt;User&gt; GetUser(string user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>RestService类生成一个IGitHubApi的实现，它使用HttpClient进行调用:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gitHubApi = RestService.For&lt;IGitHubApi&gt;(&quot;https://api.github.com&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">var octocat = await gitHubApi.GetUser(&quot;octocat&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>查看更多： <a href=\"https://reactiveui.github.io/refit/\" target=\"_blank\" rel=\"noopener\">https://reactiveui.github.io/refit/</a> </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用自定义DelegatingHandler编写更整洁的Typed-HttpClient\"><a href=\"#使用自定义DelegatingHandler编写更整洁的Typed-HttpClient\" class=\"headerlink\" title=\"使用自定义DelegatingHandler编写更整洁的Typed HttpClient\"></a>使用自定义DelegatingHandler编写更整洁的Typed HttpClient</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介﻿\"></a><strong>简介</strong>﻿</h2><p>我写了很多<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0\" target=\"_blank\" rel=\"noopener\">HttpClient</a>，包括类型化的客户端。自从我发现<a href=\"https://github.com/reactiveui/refit\" target=\"_blank\" rel=\"noopener\">Refit</a>以来，我只使用了那一个，所以我只编写了很少的代码！但是我想到了你！你们中的某些人不一定会使用<a href=\"https://github.com/reactiveui/refit\" target=\"_blank\" rel=\"noopener\">Refit，</a>因此，我将为您提供一些技巧，以使用<a href=\"https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/httpclient-message-handlers\" target=\"_blank\" rel=\"noopener\">HttpClient消息处理程序</a>（尤其是<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">DelegatingHandlers）</a>编写具有最大可重用性的<a href=\"https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests\" target=\"_blank\" rel=\"noopener\">类型化HttpClient</a>。</p>\n<h2 id=\"编写类型化的HttpClient来转发JWT并记录错误\"><a href=\"#编写类型化的HttpClient来转发JWT并记录错误\" class=\"headerlink\" title=\"编写类型化的HttpClient来转发JWT并记录错误\"></a><strong>编写类型化的HttpClient来转发JWT并记录错误</strong></h2><p>这是要清理的<a href=\"https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests\" target=\"_blank\" rel=\"noopener\">键入的HttpClient</a>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using DemoRefit.Models;</span><br><span class=\"line\">using DemoRefit.Repositories;</span><br><span class=\"line\">using Microsoft.AspNetCore.Authentication;</span><br><span class=\"line\">using Microsoft.AspNetCore.Http;</span><br><span class=\"line\">using Microsoft.Extensions.Logging;</span><br><span class=\"line\">using System;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using System.Net.Http;</span><br><span class=\"line\">using System.Net.Http.Headers;</span><br><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace DemoRefit.HttpClients</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public class CountryRepositoryClient : ICountryRepositoryClient</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private readonly HttpClient _client;</span><br><span class=\"line\">        private readonly IHttpContextAccessor _httpContextAccessor;</span><br><span class=\"line\">        private readonly ILogger&lt;CountryRepositoryClient&gt; _logger;</span><br><span class=\"line\"></span><br><span class=\"line\">        public CountryRepositoryClient(HttpClient client, ILogger&lt;CountryRepositoryClient&gt; logger, IHttpContextAccessor httpContextAccessor)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _client = client;</span><br><span class=\"line\">            _logger = logger;</span><br><span class=\"line\">            _httpContextAccessor = httpContextAccessor;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public async Task&lt;IEnumerable&lt;Country&gt;&gt; GetAsync()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            try</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                string accessToken = await _httpContextAccessor.HttpContext.GetTokenAsync(&quot;access_token&quot;);</span><br><span class=\"line\">                if (string.IsNullOrEmpty(accessToken))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    throw new Exception(&quot;Access token is missing&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(&quot;bearer&quot;, accessToken);</span><br><span class=\"line\"></span><br><span class=\"line\">                var headers = _httpContextAccessor.HttpContext.Request.Headers;</span><br><span class=\"line\">                if (headers.ContainsKey(&quot;X-Correlation-ID&quot;) &amp;&amp; !string.IsNullOrEmpty(headers[&quot;X-Correlation-ID&quot;]))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    _client.DefaultRequestHeaders.Add(&quot;X-Correlation-ID&quot;, headers[&quot;X-Correlation-ID&quot;].ToString());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                using (HttpResponseMessage response = await _client.GetAsync(&quot;/api/democrud&quot;))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    response.EnsureSuccessStatusCode();</span><br><span class=\"line\">                    return await response.Content.ReadAsAsync&lt;IEnumerable&lt;Country&gt;&gt;();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            catch (Exception e)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                _logger.LogError(e, &quot;Failed to run http query&quot;);</span><br><span class=\"line\">                return null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有许多事情需要清理，因为它们在您将在同一应用程序中编写的每个客户端中可能都是多余的：</p>\n<ul>\n<li>从<strong>HttpContext</strong>读取访问令牌</li>\n<li>令牌为空时，管理访问令牌</li>\n<li>将访问令牌附加到<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0\" target=\"_blank\" rel=\"noopener\">HttpClient</a>进行委派</li>\n<li>从<strong>HttpContext</strong>读取CorrelationId</li>\n<li>将CorrelationId附加到<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0\" target=\"_blank\" rel=\"noopener\">HttpClient</a>进行委托</li>\n<li>使用<em>EnsureSuccessStatusCode（）</em>验证Http查询是否成功</li>\n</ul>\n<h2 id=\"编写自定义的DelegatingHandler来处理冗余代码\"><a href=\"#编写自定义的DelegatingHandler来处理冗余代码\" class=\"headerlink\" title=\"编写自定义的DelegatingHandler来处理冗余代码\"></a><strong>编写自定义的DelegatingHandler来处理冗余代码</strong></h2><p>这是<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">DelegatingHandler</a>：          </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Microsoft.AspNetCore.Authentication;</span><br><span class=\"line\">using Microsoft.AspNetCore.Http;</span><br><span class=\"line\">using Microsoft.Extensions.Logging;</span><br><span class=\"line\">using System;</span><br><span class=\"line\">using System.Net.Http;</span><br><span class=\"line\">using System.Net.Http.Headers;</span><br><span class=\"line\">using System.Threading;</span><br><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace DemoRefit.Handlers</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public class MyDelegatingHandler : DelegatingHandler</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private readonly IHttpContextAccessor _httpContextAccessor;</span><br><span class=\"line\">        private readonly ILogger&lt;MyDelegatingHandler&gt; _logger;</span><br><span class=\"line\"></span><br><span class=\"line\">        public MyDelegatingHandler(IHttpContextAccessor httpContextAccessor, ILogger&lt;MyDelegatingHandler&gt; logger)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _httpContextAccessor = httpContextAccessor;</span><br><span class=\"line\">            _logger = logger;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        protected override async Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            HttpResponseMessage httpResponseMessage;</span><br><span class=\"line\">            try</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                string accessToken = await _httpContextAccessor.HttpContext.GetTokenAsync(&quot;access_token&quot;);</span><br><span class=\"line\">                if (string.IsNullOrEmpty(accessToken))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    throw new Exception($&quot;Access token is missing for the request &#123;request.RequestUri&#125;&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                request.Headers.Authorization = new AuthenticationHeaderValue(&quot;bearer&quot;, accessToken);</span><br><span class=\"line\"></span><br><span class=\"line\">                var headers = _httpContextAccessor.HttpContext.Request.Headers;</span><br><span class=\"line\">                if (headers.ContainsKey(&quot;X-Correlation-ID&quot;) &amp;&amp; !string.IsNullOrEmpty(headers[&quot;X-Correlation-ID&quot;]))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    request.Headers.Add(&quot;X-Correlation-ID&quot;, headers[&quot;X-Correlation-ID&quot;].ToString());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                httpResponseMessage = await base.SendAsync(request, cancellationToken);</span><br><span class=\"line\">                httpResponseMessage.EnsureSuccessStatusCode();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            catch (Exception ex)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                _logger.LogError(ex, &quot;Failed to run http query &#123;RequestUri&#125;&quot;, request.RequestUri);</span><br><span class=\"line\">                throw;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return httpResponseMessage;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如您所见，现在它封装了用于同一应用程序中每个<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0\" target=\"_blank\" rel=\"noopener\">HttpClient</a>的冗余逻辑 。</p>\n<p>现在，清理后的<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0\" target=\"_blank\" rel=\"noopener\">HttpClient</a>如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using DemoRefit.Models;</span><br><span class=\"line\">using DemoRefit.Repositories;</span><br><span class=\"line\">using Microsoft.Extensions.Logging;</span><br><span class=\"line\">using System;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using System.Net.Http;</span><br><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace DemoRefit.HttpClients</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public class CountryRepositoryClientV2 : ICountryRepositoryClient</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private readonly HttpClient _client;</span><br><span class=\"line\">        private readonly ILogger&lt;CountryRepositoryClient&gt; _logger;</span><br><span class=\"line\"></span><br><span class=\"line\">        public CountryRepositoryClientV2(HttpClient client, ILogger&lt;CountryRepositoryClient&gt; logger)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _client = client;</span><br><span class=\"line\">            _logger = logger;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public async Task&lt;IEnumerable&lt;Country&gt;&gt; GetAsync()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            using (HttpResponseMessage response = await _client.GetAsync(&quot;/api/democrud&quot;))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                try</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    return await response.Content.ReadAsAsync&lt;IEnumerable&lt;Country&gt;&gt;();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                catch (Exception e)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    _logger.LogError(e, &quot;Failed to read content&quot;);</span><br><span class=\"line\">                    return null;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>好多了不是吗？🙂</p>\n<p>最后，让我们将<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">DelegatingHandler</a>附加到Startup.cs中的<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0\" target=\"_blank\" rel=\"noopener\">HttpClient</a>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using DemoRefit.Handlers;</span><br><span class=\"line\">using DemoRefit.HttpClients;</span><br><span class=\"line\">using DemoRefit.Repositories;</span><br><span class=\"line\">using Microsoft.AspNetCore.Builder;</span><br><span class=\"line\">using Microsoft.AspNetCore.Hosting;</span><br><span class=\"line\">using Microsoft.Extensions.Configuration;</span><br><span class=\"line\">using Microsoft.Extensions.DependencyInjection;</span><br><span class=\"line\">using Microsoft.Extensions.Hosting;</span><br><span class=\"line\">using Refit;</span><br><span class=\"line\">using System;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace DemoRefit</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public class Startup</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        public Startup(IConfiguration configuration)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Configuration = configuration;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public IConfiguration Configuration &#123; get; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // This method gets called by the runtime. Use this method to add services to the container.</span><br><span class=\"line\">        public void ConfigureServices(IServiceCollection services)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            services.AddHttpContextAccessor();</span><br><span class=\"line\"></span><br><span class=\"line\">            services.AddControllers();</span><br><span class=\"line\"></span><br><span class=\"line\">            services.AddHttpClient&lt;ICountryRepositoryClient, CountryRepositoryClientV2&gt;()</span><br><span class=\"line\">                    .ConfigureHttpClient(c =&gt; c.BaseAddress = new Uri(Configuration.GetSection(&quot;Apis:CountryApi:Url&quot;).Value))</span><br><span class=\"line\">                    .AddHttpMessageHandler&lt;MyDelegatingHandler&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span><br><span class=\"line\">        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (env.IsDevelopment())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                app.UseDeveloperExceptionPage();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseHttpsRedirection();</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseRouting();</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseAuthorization();</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseEndpoints(endpoints =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                endpoints.MapControllers();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用Refit\"><a href=\"#使用Refit\" class=\"headerlink\" title=\"使用Refit\"></a><strong>使用Refit</strong></h2><p>如果您正在使用<a href=\"https://github.com/reactiveui/refit\" target=\"_blank\" rel=\"noopener\">Refit</a>，则绝对可以重用该<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8\" target=\"_blank\" rel=\"noopener\">DelegatingHandler</a>！</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using DemoRefit.Handlers;</span><br><span class=\"line\">using DemoRefit.HttpClients;</span><br><span class=\"line\">using DemoRefit.Repositories;</span><br><span class=\"line\">using Microsoft.AspNetCore.Builder;</span><br><span class=\"line\">using Microsoft.AspNetCore.Hosting;</span><br><span class=\"line\">using Microsoft.Extensions.Configuration;</span><br><span class=\"line\">using Microsoft.Extensions.DependencyInjection;</span><br><span class=\"line\">using Microsoft.Extensions.Hosting;</span><br><span class=\"line\">using Refit;</span><br><span class=\"line\">using System;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace DemoRefit</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public class Startup</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        public Startup(IConfiguration configuration)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Configuration = configuration;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public IConfiguration Configuration &#123; get; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // This method gets called by the runtime. Use this method to add services to the container.</span><br><span class=\"line\">        public void ConfigureServices(IServiceCollection services)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            services.AddHttpContextAccessor();</span><br><span class=\"line\"></span><br><span class=\"line\">            services.AddControllers();</span><br><span class=\"line\"></span><br><span class=\"line\">            services.AddRefitClient&lt;ICountryRepositoryClient&gt;()</span><br><span class=\"line\">                    .ConfigureHttpClient(c =&gt; c.BaseAddress = new Uri(Configuration.GetSection(&quot;Apis:CountryApi:Url&quot;).Value));</span><br><span class=\"line\">                    .AddHttpMessageHandler&lt;MyDelegatingHandler&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span><br><span class=\"line\">        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (env.IsDevelopment())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                app.UseDeveloperExceptionPage();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseHttpsRedirection();</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseRouting();</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseAuthorization();</span><br><span class=\"line\"></span><br><span class=\"line\">            app.UseEndpoints(endpoints =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                endpoints.MapControllers();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"轮子介绍：\"><a href=\"#轮子介绍：\" class=\"headerlink\" title=\"轮子介绍：\"></a>轮子介绍：</h5><p>Refit是一个深受Square的 Retrofit 库启发的库,目前在github上共有star 4000枚，通过这个框架，可以把你的REST API变成了一个活的接口:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface IGitHubApi</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [Get(&quot;/users/&#123;user&#125;&quot;)]</span><br><span class=\"line\">    Task&lt;User&gt; GetUser(string user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>RestService类生成一个IGitHubApi的实现，它使用HttpClient进行调用:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gitHubApi = RestService.For&lt;IGitHubApi&gt;(&quot;https://api.github.com&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">var octocat = await gitHubApi.GetUser(&quot;octocat&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>查看更多： <a href=\"https://reactiveui.github.io/refit/\" target=\"_blank\" rel=\"noopener\">https://reactiveui.github.io/refit/</a> </p>\n"},{"title":"关注细节，成就卓越代码","date":"2019-10-09T08:28:00.000Z","author":"邹溪源","_content":"\n# 开篇\n* 我们总是很容易就能写出满足某个特定功能的代码，却很难写出优雅代码。又最欣赏那些优雅的代码，因为优雅代码更能体现一个开发者的积累。\n* 就像写一篇散文，有的就像初学者不得其门而入，遣词造句都非常困难，然后纠纠结结，最终不了了之。或者啰哩吧嗦，看起来说了一堆，其实就像是村妇闲聊，毫无重点，不过是口水文而已。\n* 好代码应该是这样的，如涓涓细流、如同一首诗，一篇优美的故事，将作者编写代码时的情感慢慢铺垫开来，或是高潮迭起，此起彼伏，或是平铺直述，却蕴含道理。我始终相信优秀的代码是有灵魂的，代码的灵魂就是作者的逻辑思维。\n* 编写整洁代码 or 非整洁代码，就像平时生活中是否注意爱护环境的一点点小习惯，一旦坏味道代码没有及时处理，就会成为破窗效应，然后逐渐的代码越写越烂，最终这些代码要么以重构收场，要么就被抛弃。\n* 我们见过太多没有毫无质量可言的代码，许多时候开发者们由于能力原因、或者时间有限，写了许多能够满足当前工作的代码，然后就弃置高阁，不再理会。于是，代码写之前的只有自己和上帝能理解代码的意思，而写完了之后，只有上帝能懂了；还有一些开发者说：我只会写代码，不会优化代码，他们仿佛特别勤奋，每天都会比其他人都热衷于熬工时，但是写出的代码，实际上是一个个难以维护的技术债。而且许多代码的作者总喜欢找各种借口来抵赖，例如喜欢说代码出了问题都是底层框架太垃圾了、或者别人的代码封装得太差。他们总是抱怨这抱怨那，但是即便有优秀的框架、技术，就一定能写出优秀的代码么？\n* 在这里笔者列举了平时看到过一些自认为不太整洁的代码，以及与《代码整洁之道》（Clean Code · A Handbook of Agile Software Craftsmanship）一书中相对应的范例，欢迎大家一起来拍砖。\n* （经验有限，时间仓促，请轻喷。）\n# 一些栗子\n* 1、命名规则\n  * 1.1 变量命名和方法命名\n\n在我们刚刚开始学习写代码的古老时代，或许会有下面这种习惯。\n```\n/// <summary>\n/// author:zhangsan\n/// </summary>\nclass ZhangsanTest\n{\n    private void TestGetData()\n    {\n        int a, b, c;\n    }\n    private int ZhangsanGet(int s1, int s2)\n    {\n        int s3 = s1 + s2;\n        return s3;\n    } \n    private List<string> GetData()\n    {\n        return null;\n    }\n}\n```\n这是一个喜欢用自己的姓名来命名类和方法的作者，在他的代码中，经常可以看到这样奇怪的对象定义，而且他还喜欢用a,b,c,d,e,f或者s1,s2这样的命名，仿佛他的代码自带混淆特效。这样的代码嗅起来会不会觉得充斥着奇怪的味道？\n另外，有没有发现有许多开发者喜欢用 GetData() 来定义获取数据的方法？然后这个方法就成为一个万金油的方法，不管是爬虫采集、或者数据绑定，无论是 C# 写的后端或者 Java 写的后端代码，或者用 vue 写的前端代码，仿佛在任何场景、任何数据应用都可以看到这样的方法。\n如果一个项目中，有十几个地方都出现了这个** GetData() **方法，那种感觉一定非常难受。\n  * 1.2 Model、Dto 傻傻分不清楚\n\n随着技能的增长，或许我们会学到一些新的代码概念，例如，Model、DTO 是经常容易弄混淆的一种概念，但是在某些代码中，出现了下面的命名方式就有点令人窒息了。\n```\npublic class XXXModelDto\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n        public string Alias { get; set; }\n    }\n```\n这是大概是一位对概念严重消化不良的资深开发者，居然同时把 Model 和 DTO 复用在一个对象上，\n（当然，一个开发者定义变量的背后一定有他的动机）。\n他到底是想要的是用来在 MVC 模式解决数据传输和对象绑定的模型对象？还是用于传输数据的 DTO 呢？\n--其实他定义这个对象，是为了定义存储数据对象的实体（ Entity ）。\n  * 1.3特殊情况术语和字段对照表非常重要\n\n近年来开发者素质越来越高，所以许多优秀开发者会倾向于使用翻译软件来翻译变量名，然后用英语来命名，但是即便如此，许多政务项目总是能嗅出一些奇怪的味道。\n例如前不久看到一条这样的短信：（原图已经消失）\n```\nxxx公积金中心提醒您：您于{TQSJ}日进行了{TQCZ}操作，账上剩余金额为{SYJE}元。\n```\n这是个bug将xxx公积金中心的某些秘密透露在大家面前。作为一个严谨的项目，居然使用中文首字母大写命名法，这让习惯于大驼峰、小驼峰的我看了之后尴尬癌犯了，很不舒服。但是这也是许多政务信息化项目的中字段命名的规范，而且在这种情况下，往往会输出一份非常规范的数据库字段对照表，确保中文和首字母的语义不让人产生歧义。\n所以特定语境下，变量和方法本身没有严格的规定，但是一定要使用恰当的语境概念，对于这样的特定场景，尽量维护一份实时更新的术语表吧。\n* 2、状态码返回值\n  * 2.1业务逻辑状态码\n\n似乎在对外提供接口时，使用下列接口状态码是一种比较常见的惯例。提供统一格式的 code 状态码以及返回的消息和成功返回结果时的填充数据，能够让开发者高效的完成接口对接，无需关心http状态码背后的含义。\n```\n{\"code\":\"100101\",\"message\":\"success\",\"data\":{},\"count\":\"\"}\n```\n  * 2.2用 http 状态码为什么不够？\n\n上面这是一种经典的流派，还有一种流派则会使用http状态码来返回指定的数据，事实上 http 协议本身已经提供了许多状态码，例如下面的这些大家都非常熟悉的状态码。\n但是这些状态码为啥不够？主要是为了减少前后端、服务上下游之间接口对接的难度，也是一种提高效率的方式。 但是 http 状态码是一种通用的格式，应尽量使用这种方式，而不应该通过解析正常响应后的 json 来判断是否正确操作。\n```\n\t200 ：正常响应 标准成功代码和默认选项。\t\n\t201 ：创建对象。 适用于存储行为。\t\n\t204 ：没有内容。 当一个动作成功执行，但没有任何内容可以返回。\t\n\t206 ：部分内容。 当您必须返回分页的资源列表时很有用。\t\n\t400 ：请求不正确 无法通过验证的请求的标准选项。\t\n\t401 ：未经授权 用户需要进行身份验证。\t\n\t403 ：禁止 用户已通过身份验证，但没有执行操作的权限。\t\n\t404 ：找不到资源自动返回。\t\n\t500 ：内部服务器错误。 理想情况下，您不会明确地返回此消息，但是如果发生意外中断，这是您的用户将会收到的。\t\n\t503 ：服务不可用 相当自我解释，还有一个不会被应用程序显式返回的代码。\n```\n \n* 3、switch 语句与判断语句\n  * 3.1 面向过程式或面向对象式\n\n我曾经跟小组中一位大佬交流他的一段代码，他的这段代码大概是这样的。\n```\n/// <summary>\n/// 流程处理\n/// </summary>\npublic void FlowProcess(int auditType)\n{\n  switch (auditType)\n  {                \n      case 1://通过\n          //此处省略通过场景下的50行代码\n          break;\n      case 2://不通过\n          //此处省略不通过场景下的50行代码\n          break;\n      case 3://再审通过\n          //此处省略再审通过场景下的50行代码\n          break;\n      case 4://再审不通过\n          //此处省略再审不通过场景下的50行代码\n          break;\n  }\n}\n```\n（读者卒。）\n且不说这位大佬的代码是写得好或者不好，仅仅就这200多行代码的4个大switch读起来大概会让人便秘难受吧。于是在我读完这段代码之后，我冒死向他请教这么写代码的原因，他说我这个流程处理就是一个简单的用例场景，哪里还有什么可以优化的余地？\n我跟他介绍了20分钟代码封装的必要性，于是，他把代码写成了这样。\n```\n/// <summary>\n/// 流程处理\n/// </summary>\npublic void FlowProcess(int auditType)\n{\n    switch (auditType)\n    {                \n        case 1://通过\n            AuditOK();\n            break;\n        case 2://不通过\n            AuditNotOK();\n            break;\n        case 3://再审通过\n            ReAuditOK();\n            break;\n        case 4://再审不通过\n            ReAuditNotOK();\n            break;\n    }\n}\npublic void AuditOK()\n{\n    //此处省略通过场景下的50行代码\n}\npublic void AuditNotOK()\n{\n    //此处省略不通过场景下的50行代码\n}\npublic void ReAuditOK()\n{\n    //此处省略再审通过场景下的50行代码\n}\npublic void ReAuditNotOK()\n{\n    //此处省略再审不通过场景下的50行代码\n}\n```\n这酸爽令人简直难以置信。（事实上这个新鲜出炉的遗留应用，正是这样一点点堆积了许多总代码行超过千行的类文件）\n《代码整洁之道》书上有一个类似的例子，大概与上文类似，Robert 大叔给出了这样的建议：\n```\n对于switch 语句，我的规矩是如果只出现一次，用于创建多态对象，而且隐藏在某个集成关系中，在系统中其他部分看不到，就还能容忍。当然也要就事论事，有时我也会部分或全部违反这条规矩。\n```\n上文我给出的示例，有点像面向过程的代码风格，而 Robert 大叔在他的书中写下的示例是这样的（抽象工厂模式的示例）。\n![图片](https://uploader.shimo.im/f/YMu9U5cRYngc1GUE.png!thumbnail)\n这清爽的感觉，让人很舒服啊。\n  * 3.2 孰优孰劣？\n\n当然，原示例是一个流程处理的例子，似乎大家的流程处理代码都习惯于使用这种面向过程风格的写法，反正要加判定条件，就加一个 case 就可以了。\n而在某些特定情况下，甚至用 if / else 来写逻辑判断更简单，于是我们经常在某些销量很好的快速开发平台中，看到这样的例子。\n![图片](https://uploader.shimo.im/f/R3b6TAsMcoMPjUar.png!thumbnail)\n这些典型的面向过程风格的代码，确实读起来似乎更加简单、而且也易于实现。\n```\nRobert 大叔是这样说的：过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数，面向对象代码便于在不改动既有函数的前提下添加新类。\n反过来讲也说得通：过程式代码难以添加新数据结构，因为必须修改所有函数，面向对象代码难以添加新函数，因为必须修改所有类。\n```\n所以究竟是使用面向过程式代码，还是面向对象式代码？没有万试万灵的灵丹妙药。\n* 4、奥卡姆剃刀定律、得墨忒耳律\n  * 4.1“如非必要，勿增实体”\n\n一旦开始初步掌握面向对象开发的基本原则，于是我们就会新建许多各种不同的模型对象。尤其是在webapi接口开发过程中，更是如此。\n>\t切勿浪费较多东西去做，用较少的东西，同样可以做好的事情。\n  * 4.2 得墨忒耳律\n\n假设有一段代码是这样的。\n```\npublic  class GrandParent\n{\n    public Father Son { get; set; }\n    public string Name { get; set; }\n    public Father GetSon()\n    {\n        return Son;\n    }\n}\npublic class Father\n{\n    public Me Son { get; set; }\n    public string Name { get; set; }\n    public Father GetSon()\n    {\n        return Son;\n    }\n}\npublic class Me\n{\n    public Son Son { get; set; }\n    public string Name { get; set; }\n    public Son GetSon()\n    {\n        return Son;\n    }\n}\npublic class Son\n{\n    public GrandSon GrandSon { get; set; }\n    public string Name { get; set; }\n    public GrandSon GetSon()\n    {\n        return GrandSon;\n    }\n}\npublic class GrandSon\n{\n   public string Name { get; set; }\n    public string GetSon()\n    {\n        return Name;\n    }\n}\n```\n会不会为了获得某些数据，而写出这样的代码呢？\n```\nreturn new GrandParent().GetSon().GetSon().GetSon().Name;\n```\n这样就是典型的对得墨忒耳律的违背。这个原则指出：\n```\n模块不应了解它所操作对象的内部情形。\n更准确的说，得墨忒耳律认为，类C的方法f只应该调用以下对象的方法：\nC（本身）\n由方法f创建的对象。\n作为参数传递给f的对象；\n由C的实体变量持有的对象。\n对象不应调用由任何函数返回的对象的方法。换言之，只跟朋友说话，不与陌生人说话。\n```\n在上文中我举的例子，祖父只跟自己的亲儿子（Father）说话，而不跟孙子说话。\n* 5、圈复杂度\n\n在软件测试的概念里，圈复杂度用来衡量一个模块判定结构的复杂程度，数量上表现为线性无关的路径条数，即合理的预防错误所需测试的最少路径条数。圈复杂度大说明程序代码可能质量低且难于测试和维护，根据经验，程序的可能错误和高的圈复杂度有着很大关系。\n据说在Oracle数据库中有一些屎山代码，是通过一堆标识量来判断某些特定逻辑的，大概是这样的。\n（示例仅供参考，由于资源限制，未能考证，还请大佬指正一二。）\n```\n/// <summary>\n/// 一个高复杂度的方法\n/// </summary>\npublic string HighCCMethod()\n{\n    int flag = 1;\n    int flag1 = 2;\n    int flag2 = 3;\n    int flag3 = 4;\n    int flag4 = 5;\n    if (flag == 1)\n    {\n        //do something\n        if (flag1 == 2)\n        {\n            //dosomething\n            if (flag2 == 3)\n            {\n                //dosomething\n                if (flag3 == 4 && flag4 == 5)\n                {\n                    return \"编译器 die\";\n                }\n            }\n        } \n    }\n    return \"...\";\n}\n```\n这是一个圈复杂度非常复杂的方法，我想任何一个读到这样代码的开发者都会对自己的人生充满了积极而乐观的判断，那就是“活着比一切都好”。\n对于这样的代码，我们应该尽可能的降低代码的圈复杂度，让程序满足基本可读的需求。\n* 6、注释\n```\npublic void UploadImg()\n{\n    int flag = 3;\n    //标识量为3标识什么意思我也不知道，我在网上看到的。\n    if (flag == 3)\n    {\n        //dosomething\n    }\n    //uploadfile();\n}\n```\n我曾经参加过一个使用objectc编写的应用的，其中有一段代码是这样的，这个flag大概是魔法值，作者未经考证直接就在代码中使用了。然后一直流传下来，成为一段佳（gui）话（hua）。\n还有这样的注释。傻傻分不清楚。\n```\n/// <summary>\n/// 为true标识为真，为false标识为假\n/// </summary>\npublic bool IsTrue { get; set; }\n/// <summary>\n/// 是否可见，为true标识可见，为false标识不可见\n/// </summary>\npublic bool IsVisible { get; set; }\n```\n还有这样的。\n```\n//do something\nThread.Sleep(3000); //项目经理说此处要暂停3000毫秒，以便作为下次性能改进的需求点\n```\nRobert大叔如是说：\n```\n什么也比不上放置良好的注释来得有用。什么也比不会乱七八糟的注释更有本事搞乱一个模块。什么也不会比陈旧、提供错误信息的注释更有破坏性。\n```\n当然很多中国程序员自称其变量命名是自注释的，例如大概是这样的。万能的 Is 命名法，只要是判断状态皆可用。\n（每个程序员能够成功的生存下来都不容易，他一定有异于常人的本事。)\n```\npublic bool IsShow { get; set; }\npublic bool IsGet { get; set; }\npublic bool IsUsed { get; set; }\n```\n* 7、霰弹式修改\n\nCRUD开发者或许经常会看到这样的代码，例如，如果我要对某一个对象的状态（ Status）进行更改，可能会这么做：\n```\npublic class ShotGun1\n{\n    public void Method1()\n    {\n        DataStatus dataStatus = new DataStatus();\n        dataStatus.Flag = 1 * 3;\n        dataStatus.Status = \"1234\";\n    }\n}\npublic class ShotGun2\n{\n    public void Method2(int i, int status)\n    {\n        DataStatus dataStatus = new DataStatus();\n        dataStatus.Flag = 1 * 3;\n        dataStatus.Status = \"1234\";\n    }\n}\n```\n这种霰弹式代码中，一处代码规则的变化，可能会需要对许多处代码进行同步修改，使得我们的代码异常的难以维护。\n* 8、异常\n\n有时候可能会遇到这样的代码，在方法中定义一些文本的状态码，然后调用方法时，再去判断这个状态码的内容，当返回错误码时，要求调用者立即处理错误。\n```\npublic class XXXApi\n{\n    public CurrentUser CurrentUser { get; }\n    public string DoSomething()\n    {\n        if (GetCurrentUid() == \"用户为空\")\n        {\n            //do something\n        }\n        else\n        {\n            //dosomething\n        }\n        return \"\";\n    }\n    public string GetCurrentUid()\n    {\n        if (CurrentUser == null)\n        {\n            return \"用户为空\";\n        }\n        return \"\";\n    }\n}\npublic class CurrentUser\n{\n    public string Uid { get; set; }\n}\n```\n不如直接抛出异常，让异常处理机制进行处理吧。\n```\npublic string GetCurrentUid()\n{\n    if (CurrentUser == null)\n        throw new NoLoginExecption(\"\");\n    return \"\";\n}\n```\n# 9、边界\n## 9.1 模块间的边界\n即便是简单的CRUD应用系统，优秀的开发者也能更好的处理应用程序模块间的边界。某种意义上讲，应用程序内部的边界看起来或许没有明确的界限之分，但是稍不留心就可能导致应用程序间关系过于紊乱，让其他开发者捉摸不透。\n例如，假设有一段代码是这样的，在用户操作类中，加入了一个获取应用数据的方法，确实会让人很费解吧。（而应用领域驱动设计的思维，或许是一种不错的模式。）\n```\npublic class UserService\n{\n    public string GetAppData(string config)\n    {\n        //do something\n    }\n}\n```\n## 9.2应用间的边界\n相对而言，或许应用间的边界似乎能相对清晰的分析出来？并非如此。\n在当今时代，我们很少开发完全与其他应用系统没有任何关联的独立软件，这意味着我们或许无时无刻都得与其他第三方应用进行接口行为或数据的交换。这让我们必须确保采取措施让外来代码干净利落地整合进自己的代码中。\n假设有一段代码是这样的：\n```\npublic class UserService\n{ \n    public string GetAppData(string config)\n    {\n        //do something\n    }\n    public string UploadOssData(string file)\n    {\n        OssConfig oss = new OssConfig();\n        OssSdk ossSdk = OssSdk.CreateInstance();\n        ossSdk.UploadFile(file);\n    }\n}\n```\n在《代码整洁之道》书中，Robert大叔推荐应该第三方接口进行隔离，通过Map那样包装或者使用适配器模式将我们的接口转换成第三方提供的接口。让代码更好地与我们沟通，在边界两边推动内部一致的用法，当第三方代码有改动时修改点也会更少。\n# 总结\n写代码是开发者的基础技能，无论你是.NET 开发者，或者 Java 开发者，你都在努力用代码实现自己的梦想。如同韩磊老师在译作《代码整理之道》封面上总结全书，写下的那句诗\n```\n“细节之中自有天地，整洁成就卓越代码”。\n```\n卓越代码从来不仅仅只是功能完善、代码齐全，做好细节，每个细节就是一方小天地。优雅的代码，不仅仅只是开发者的个人能力的体现，更是开发者的立足之本。努力改善坏习惯，提高代码质量，时刻消除异味，时刻提高自己，更有助于个人技能的全面发展。\n","source":"_posts/技术/关注细节，成就卓越代码.md","raw":"---\ntitle:  关注细节，成就卓越代码\ndate: 2019-10-09 16:28\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n\n# 开篇\n* 我们总是很容易就能写出满足某个特定功能的代码，却很难写出优雅代码。又最欣赏那些优雅的代码，因为优雅代码更能体现一个开发者的积累。\n* 就像写一篇散文，有的就像初学者不得其门而入，遣词造句都非常困难，然后纠纠结结，最终不了了之。或者啰哩吧嗦，看起来说了一堆，其实就像是村妇闲聊，毫无重点，不过是口水文而已。\n* 好代码应该是这样的，如涓涓细流、如同一首诗，一篇优美的故事，将作者编写代码时的情感慢慢铺垫开来，或是高潮迭起，此起彼伏，或是平铺直述，却蕴含道理。我始终相信优秀的代码是有灵魂的，代码的灵魂就是作者的逻辑思维。\n* 编写整洁代码 or 非整洁代码，就像平时生活中是否注意爱护环境的一点点小习惯，一旦坏味道代码没有及时处理，就会成为破窗效应，然后逐渐的代码越写越烂，最终这些代码要么以重构收场，要么就被抛弃。\n* 我们见过太多没有毫无质量可言的代码，许多时候开发者们由于能力原因、或者时间有限，写了许多能够满足当前工作的代码，然后就弃置高阁，不再理会。于是，代码写之前的只有自己和上帝能理解代码的意思，而写完了之后，只有上帝能懂了；还有一些开发者说：我只会写代码，不会优化代码，他们仿佛特别勤奋，每天都会比其他人都热衷于熬工时，但是写出的代码，实际上是一个个难以维护的技术债。而且许多代码的作者总喜欢找各种借口来抵赖，例如喜欢说代码出了问题都是底层框架太垃圾了、或者别人的代码封装得太差。他们总是抱怨这抱怨那，但是即便有优秀的框架、技术，就一定能写出优秀的代码么？\n* 在这里笔者列举了平时看到过一些自认为不太整洁的代码，以及与《代码整洁之道》（Clean Code · A Handbook of Agile Software Craftsmanship）一书中相对应的范例，欢迎大家一起来拍砖。\n* （经验有限，时间仓促，请轻喷。）\n# 一些栗子\n* 1、命名规则\n  * 1.1 变量命名和方法命名\n\n在我们刚刚开始学习写代码的古老时代，或许会有下面这种习惯。\n```\n/// <summary>\n/// author:zhangsan\n/// </summary>\nclass ZhangsanTest\n{\n    private void TestGetData()\n    {\n        int a, b, c;\n    }\n    private int ZhangsanGet(int s1, int s2)\n    {\n        int s3 = s1 + s2;\n        return s3;\n    } \n    private List<string> GetData()\n    {\n        return null;\n    }\n}\n```\n这是一个喜欢用自己的姓名来命名类和方法的作者，在他的代码中，经常可以看到这样奇怪的对象定义，而且他还喜欢用a,b,c,d,e,f或者s1,s2这样的命名，仿佛他的代码自带混淆特效。这样的代码嗅起来会不会觉得充斥着奇怪的味道？\n另外，有没有发现有许多开发者喜欢用 GetData() 来定义获取数据的方法？然后这个方法就成为一个万金油的方法，不管是爬虫采集、或者数据绑定，无论是 C# 写的后端或者 Java 写的后端代码，或者用 vue 写的前端代码，仿佛在任何场景、任何数据应用都可以看到这样的方法。\n如果一个项目中，有十几个地方都出现了这个** GetData() **方法，那种感觉一定非常难受。\n  * 1.2 Model、Dto 傻傻分不清楚\n\n随着技能的增长，或许我们会学到一些新的代码概念，例如，Model、DTO 是经常容易弄混淆的一种概念，但是在某些代码中，出现了下面的命名方式就有点令人窒息了。\n```\npublic class XXXModelDto\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n        public string Alias { get; set; }\n    }\n```\n这是大概是一位对概念严重消化不良的资深开发者，居然同时把 Model 和 DTO 复用在一个对象上，\n（当然，一个开发者定义变量的背后一定有他的动机）。\n他到底是想要的是用来在 MVC 模式解决数据传输和对象绑定的模型对象？还是用于传输数据的 DTO 呢？\n--其实他定义这个对象，是为了定义存储数据对象的实体（ Entity ）。\n  * 1.3特殊情况术语和字段对照表非常重要\n\n近年来开发者素质越来越高，所以许多优秀开发者会倾向于使用翻译软件来翻译变量名，然后用英语来命名，但是即便如此，许多政务项目总是能嗅出一些奇怪的味道。\n例如前不久看到一条这样的短信：（原图已经消失）\n```\nxxx公积金中心提醒您：您于{TQSJ}日进行了{TQCZ}操作，账上剩余金额为{SYJE}元。\n```\n这是个bug将xxx公积金中心的某些秘密透露在大家面前。作为一个严谨的项目，居然使用中文首字母大写命名法，这让习惯于大驼峰、小驼峰的我看了之后尴尬癌犯了，很不舒服。但是这也是许多政务信息化项目的中字段命名的规范，而且在这种情况下，往往会输出一份非常规范的数据库字段对照表，确保中文和首字母的语义不让人产生歧义。\n所以特定语境下，变量和方法本身没有严格的规定，但是一定要使用恰当的语境概念，对于这样的特定场景，尽量维护一份实时更新的术语表吧。\n* 2、状态码返回值\n  * 2.1业务逻辑状态码\n\n似乎在对外提供接口时，使用下列接口状态码是一种比较常见的惯例。提供统一格式的 code 状态码以及返回的消息和成功返回结果时的填充数据，能够让开发者高效的完成接口对接，无需关心http状态码背后的含义。\n```\n{\"code\":\"100101\",\"message\":\"success\",\"data\":{},\"count\":\"\"}\n```\n  * 2.2用 http 状态码为什么不够？\n\n上面这是一种经典的流派，还有一种流派则会使用http状态码来返回指定的数据，事实上 http 协议本身已经提供了许多状态码，例如下面的这些大家都非常熟悉的状态码。\n但是这些状态码为啥不够？主要是为了减少前后端、服务上下游之间接口对接的难度，也是一种提高效率的方式。 但是 http 状态码是一种通用的格式，应尽量使用这种方式，而不应该通过解析正常响应后的 json 来判断是否正确操作。\n```\n\t200 ：正常响应 标准成功代码和默认选项。\t\n\t201 ：创建对象。 适用于存储行为。\t\n\t204 ：没有内容。 当一个动作成功执行，但没有任何内容可以返回。\t\n\t206 ：部分内容。 当您必须返回分页的资源列表时很有用。\t\n\t400 ：请求不正确 无法通过验证的请求的标准选项。\t\n\t401 ：未经授权 用户需要进行身份验证。\t\n\t403 ：禁止 用户已通过身份验证，但没有执行操作的权限。\t\n\t404 ：找不到资源自动返回。\t\n\t500 ：内部服务器错误。 理想情况下，您不会明确地返回此消息，但是如果发生意外中断，这是您的用户将会收到的。\t\n\t503 ：服务不可用 相当自我解释，还有一个不会被应用程序显式返回的代码。\n```\n \n* 3、switch 语句与判断语句\n  * 3.1 面向过程式或面向对象式\n\n我曾经跟小组中一位大佬交流他的一段代码，他的这段代码大概是这样的。\n```\n/// <summary>\n/// 流程处理\n/// </summary>\npublic void FlowProcess(int auditType)\n{\n  switch (auditType)\n  {                \n      case 1://通过\n          //此处省略通过场景下的50行代码\n          break;\n      case 2://不通过\n          //此处省略不通过场景下的50行代码\n          break;\n      case 3://再审通过\n          //此处省略再审通过场景下的50行代码\n          break;\n      case 4://再审不通过\n          //此处省略再审不通过场景下的50行代码\n          break;\n  }\n}\n```\n（读者卒。）\n且不说这位大佬的代码是写得好或者不好，仅仅就这200多行代码的4个大switch读起来大概会让人便秘难受吧。于是在我读完这段代码之后，我冒死向他请教这么写代码的原因，他说我这个流程处理就是一个简单的用例场景，哪里还有什么可以优化的余地？\n我跟他介绍了20分钟代码封装的必要性，于是，他把代码写成了这样。\n```\n/// <summary>\n/// 流程处理\n/// </summary>\npublic void FlowProcess(int auditType)\n{\n    switch (auditType)\n    {                \n        case 1://通过\n            AuditOK();\n            break;\n        case 2://不通过\n            AuditNotOK();\n            break;\n        case 3://再审通过\n            ReAuditOK();\n            break;\n        case 4://再审不通过\n            ReAuditNotOK();\n            break;\n    }\n}\npublic void AuditOK()\n{\n    //此处省略通过场景下的50行代码\n}\npublic void AuditNotOK()\n{\n    //此处省略不通过场景下的50行代码\n}\npublic void ReAuditOK()\n{\n    //此处省略再审通过场景下的50行代码\n}\npublic void ReAuditNotOK()\n{\n    //此处省略再审不通过场景下的50行代码\n}\n```\n这酸爽令人简直难以置信。（事实上这个新鲜出炉的遗留应用，正是这样一点点堆积了许多总代码行超过千行的类文件）\n《代码整洁之道》书上有一个类似的例子，大概与上文类似，Robert 大叔给出了这样的建议：\n```\n对于switch 语句，我的规矩是如果只出现一次，用于创建多态对象，而且隐藏在某个集成关系中，在系统中其他部分看不到，就还能容忍。当然也要就事论事，有时我也会部分或全部违反这条规矩。\n```\n上文我给出的示例，有点像面向过程的代码风格，而 Robert 大叔在他的书中写下的示例是这样的（抽象工厂模式的示例）。\n![图片](https://uploader.shimo.im/f/YMu9U5cRYngc1GUE.png!thumbnail)\n这清爽的感觉，让人很舒服啊。\n  * 3.2 孰优孰劣？\n\n当然，原示例是一个流程处理的例子，似乎大家的流程处理代码都习惯于使用这种面向过程风格的写法，反正要加判定条件，就加一个 case 就可以了。\n而在某些特定情况下，甚至用 if / else 来写逻辑判断更简单，于是我们经常在某些销量很好的快速开发平台中，看到这样的例子。\n![图片](https://uploader.shimo.im/f/R3b6TAsMcoMPjUar.png!thumbnail)\n这些典型的面向过程风格的代码，确实读起来似乎更加简单、而且也易于实现。\n```\nRobert 大叔是这样说的：过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数，面向对象代码便于在不改动既有函数的前提下添加新类。\n反过来讲也说得通：过程式代码难以添加新数据结构，因为必须修改所有函数，面向对象代码难以添加新函数，因为必须修改所有类。\n```\n所以究竟是使用面向过程式代码，还是面向对象式代码？没有万试万灵的灵丹妙药。\n* 4、奥卡姆剃刀定律、得墨忒耳律\n  * 4.1“如非必要，勿增实体”\n\n一旦开始初步掌握面向对象开发的基本原则，于是我们就会新建许多各种不同的模型对象。尤其是在webapi接口开发过程中，更是如此。\n>\t切勿浪费较多东西去做，用较少的东西，同样可以做好的事情。\n  * 4.2 得墨忒耳律\n\n假设有一段代码是这样的。\n```\npublic  class GrandParent\n{\n    public Father Son { get; set; }\n    public string Name { get; set; }\n    public Father GetSon()\n    {\n        return Son;\n    }\n}\npublic class Father\n{\n    public Me Son { get; set; }\n    public string Name { get; set; }\n    public Father GetSon()\n    {\n        return Son;\n    }\n}\npublic class Me\n{\n    public Son Son { get; set; }\n    public string Name { get; set; }\n    public Son GetSon()\n    {\n        return Son;\n    }\n}\npublic class Son\n{\n    public GrandSon GrandSon { get; set; }\n    public string Name { get; set; }\n    public GrandSon GetSon()\n    {\n        return GrandSon;\n    }\n}\npublic class GrandSon\n{\n   public string Name { get; set; }\n    public string GetSon()\n    {\n        return Name;\n    }\n}\n```\n会不会为了获得某些数据，而写出这样的代码呢？\n```\nreturn new GrandParent().GetSon().GetSon().GetSon().Name;\n```\n这样就是典型的对得墨忒耳律的违背。这个原则指出：\n```\n模块不应了解它所操作对象的内部情形。\n更准确的说，得墨忒耳律认为，类C的方法f只应该调用以下对象的方法：\nC（本身）\n由方法f创建的对象。\n作为参数传递给f的对象；\n由C的实体变量持有的对象。\n对象不应调用由任何函数返回的对象的方法。换言之，只跟朋友说话，不与陌生人说话。\n```\n在上文中我举的例子，祖父只跟自己的亲儿子（Father）说话，而不跟孙子说话。\n* 5、圈复杂度\n\n在软件测试的概念里，圈复杂度用来衡量一个模块判定结构的复杂程度，数量上表现为线性无关的路径条数，即合理的预防错误所需测试的最少路径条数。圈复杂度大说明程序代码可能质量低且难于测试和维护，根据经验，程序的可能错误和高的圈复杂度有着很大关系。\n据说在Oracle数据库中有一些屎山代码，是通过一堆标识量来判断某些特定逻辑的，大概是这样的。\n（示例仅供参考，由于资源限制，未能考证，还请大佬指正一二。）\n```\n/// <summary>\n/// 一个高复杂度的方法\n/// </summary>\npublic string HighCCMethod()\n{\n    int flag = 1;\n    int flag1 = 2;\n    int flag2 = 3;\n    int flag3 = 4;\n    int flag4 = 5;\n    if (flag == 1)\n    {\n        //do something\n        if (flag1 == 2)\n        {\n            //dosomething\n            if (flag2 == 3)\n            {\n                //dosomething\n                if (flag3 == 4 && flag4 == 5)\n                {\n                    return \"编译器 die\";\n                }\n            }\n        } \n    }\n    return \"...\";\n}\n```\n这是一个圈复杂度非常复杂的方法，我想任何一个读到这样代码的开发者都会对自己的人生充满了积极而乐观的判断，那就是“活着比一切都好”。\n对于这样的代码，我们应该尽可能的降低代码的圈复杂度，让程序满足基本可读的需求。\n* 6、注释\n```\npublic void UploadImg()\n{\n    int flag = 3;\n    //标识量为3标识什么意思我也不知道，我在网上看到的。\n    if (flag == 3)\n    {\n        //dosomething\n    }\n    //uploadfile();\n}\n```\n我曾经参加过一个使用objectc编写的应用的，其中有一段代码是这样的，这个flag大概是魔法值，作者未经考证直接就在代码中使用了。然后一直流传下来，成为一段佳（gui）话（hua）。\n还有这样的注释。傻傻分不清楚。\n```\n/// <summary>\n/// 为true标识为真，为false标识为假\n/// </summary>\npublic bool IsTrue { get; set; }\n/// <summary>\n/// 是否可见，为true标识可见，为false标识不可见\n/// </summary>\npublic bool IsVisible { get; set; }\n```\n还有这样的。\n```\n//do something\nThread.Sleep(3000); //项目经理说此处要暂停3000毫秒，以便作为下次性能改进的需求点\n```\nRobert大叔如是说：\n```\n什么也比不上放置良好的注释来得有用。什么也比不会乱七八糟的注释更有本事搞乱一个模块。什么也不会比陈旧、提供错误信息的注释更有破坏性。\n```\n当然很多中国程序员自称其变量命名是自注释的，例如大概是这样的。万能的 Is 命名法，只要是判断状态皆可用。\n（每个程序员能够成功的生存下来都不容易，他一定有异于常人的本事。)\n```\npublic bool IsShow { get; set; }\npublic bool IsGet { get; set; }\npublic bool IsUsed { get; set; }\n```\n* 7、霰弹式修改\n\nCRUD开发者或许经常会看到这样的代码，例如，如果我要对某一个对象的状态（ Status）进行更改，可能会这么做：\n```\npublic class ShotGun1\n{\n    public void Method1()\n    {\n        DataStatus dataStatus = new DataStatus();\n        dataStatus.Flag = 1 * 3;\n        dataStatus.Status = \"1234\";\n    }\n}\npublic class ShotGun2\n{\n    public void Method2(int i, int status)\n    {\n        DataStatus dataStatus = new DataStatus();\n        dataStatus.Flag = 1 * 3;\n        dataStatus.Status = \"1234\";\n    }\n}\n```\n这种霰弹式代码中，一处代码规则的变化，可能会需要对许多处代码进行同步修改，使得我们的代码异常的难以维护。\n* 8、异常\n\n有时候可能会遇到这样的代码，在方法中定义一些文本的状态码，然后调用方法时，再去判断这个状态码的内容，当返回错误码时，要求调用者立即处理错误。\n```\npublic class XXXApi\n{\n    public CurrentUser CurrentUser { get; }\n    public string DoSomething()\n    {\n        if (GetCurrentUid() == \"用户为空\")\n        {\n            //do something\n        }\n        else\n        {\n            //dosomething\n        }\n        return \"\";\n    }\n    public string GetCurrentUid()\n    {\n        if (CurrentUser == null)\n        {\n            return \"用户为空\";\n        }\n        return \"\";\n    }\n}\npublic class CurrentUser\n{\n    public string Uid { get; set; }\n}\n```\n不如直接抛出异常，让异常处理机制进行处理吧。\n```\npublic string GetCurrentUid()\n{\n    if (CurrentUser == null)\n        throw new NoLoginExecption(\"\");\n    return \"\";\n}\n```\n# 9、边界\n## 9.1 模块间的边界\n即便是简单的CRUD应用系统，优秀的开发者也能更好的处理应用程序模块间的边界。某种意义上讲，应用程序内部的边界看起来或许没有明确的界限之分，但是稍不留心就可能导致应用程序间关系过于紊乱，让其他开发者捉摸不透。\n例如，假设有一段代码是这样的，在用户操作类中，加入了一个获取应用数据的方法，确实会让人很费解吧。（而应用领域驱动设计的思维，或许是一种不错的模式。）\n```\npublic class UserService\n{\n    public string GetAppData(string config)\n    {\n        //do something\n    }\n}\n```\n## 9.2应用间的边界\n相对而言，或许应用间的边界似乎能相对清晰的分析出来？并非如此。\n在当今时代，我们很少开发完全与其他应用系统没有任何关联的独立软件，这意味着我们或许无时无刻都得与其他第三方应用进行接口行为或数据的交换。这让我们必须确保采取措施让外来代码干净利落地整合进自己的代码中。\n假设有一段代码是这样的：\n```\npublic class UserService\n{ \n    public string GetAppData(string config)\n    {\n        //do something\n    }\n    public string UploadOssData(string file)\n    {\n        OssConfig oss = new OssConfig();\n        OssSdk ossSdk = OssSdk.CreateInstance();\n        ossSdk.UploadFile(file);\n    }\n}\n```\n在《代码整洁之道》书中，Robert大叔推荐应该第三方接口进行隔离，通过Map那样包装或者使用适配器模式将我们的接口转换成第三方提供的接口。让代码更好地与我们沟通，在边界两边推动内部一致的用法，当第三方代码有改动时修改点也会更少。\n# 总结\n写代码是开发者的基础技能，无论你是.NET 开发者，或者 Java 开发者，你都在努力用代码实现自己的梦想。如同韩磊老师在译作《代码整理之道》封面上总结全书，写下的那句诗\n```\n“细节之中自有天地，整洁成就卓越代码”。\n```\n卓越代码从来不仅仅只是功能完善、代码齐全，做好细节，每个细节就是一方小天地。优雅的代码，不仅仅只是开发者的个人能力的体现，更是开发者的立足之本。努力改善坏习惯，提高代码质量，时刻消除异味，时刻提高自己，更有助于个人技能的全面发展。\n","slug":"技术/关注细节，成就卓越代码","published":1,"updated":"2019-10-09T10:54:50.517Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt7l0014n4vipfviey3z","content":"<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><ul>\n<li>我们总是很容易就能写出满足某个特定功能的代码，却很难写出优雅代码。又最欣赏那些优雅的代码，因为优雅代码更能体现一个开发者的积累。</li>\n<li>就像写一篇散文，有的就像初学者不得其门而入，遣词造句都非常困难，然后纠纠结结，最终不了了之。或者啰哩吧嗦，看起来说了一堆，其实就像是村妇闲聊，毫无重点，不过是口水文而已。</li>\n<li>好代码应该是这样的，如涓涓细流、如同一首诗，一篇优美的故事，将作者编写代码时的情感慢慢铺垫开来，或是高潮迭起，此起彼伏，或是平铺直述，却蕴含道理。我始终相信优秀的代码是有灵魂的，代码的灵魂就是作者的逻辑思维。</li>\n<li>编写整洁代码 or 非整洁代码，就像平时生活中是否注意爱护环境的一点点小习惯，一旦坏味道代码没有及时处理，就会成为破窗效应，然后逐渐的代码越写越烂，最终这些代码要么以重构收场，要么就被抛弃。</li>\n<li>我们见过太多没有毫无质量可言的代码，许多时候开发者们由于能力原因、或者时间有限，写了许多能够满足当前工作的代码，然后就弃置高阁，不再理会。于是，代码写之前的只有自己和上帝能理解代码的意思，而写完了之后，只有上帝能懂了；还有一些开发者说：我只会写代码，不会优化代码，他们仿佛特别勤奋，每天都会比其他人都热衷于熬工时，但是写出的代码，实际上是一个个难以维护的技术债。而且许多代码的作者总喜欢找各种借口来抵赖，例如喜欢说代码出了问题都是底层框架太垃圾了、或者别人的代码封装得太差。他们总是抱怨这抱怨那，但是即便有优秀的框架、技术，就一定能写出优秀的代码么？</li>\n<li>在这里笔者列举了平时看到过一些自认为不太整洁的代码，以及与《代码整洁之道》（Clean Code · A Handbook of Agile Software Craftsmanship）一书中相对应的范例，欢迎大家一起来拍砖。</li>\n<li>（经验有限，时间仓促，请轻喷。）<h1 id=\"一些栗子\"><a href=\"#一些栗子\" class=\"headerlink\" title=\"一些栗子\"></a>一些栗子</h1></li>\n<li>1、命名规则<ul>\n<li>1.1 变量命名和方法命名</li>\n</ul>\n</li>\n</ul>\n<p>在我们刚刚开始学习写代码的古老时代，或许会有下面这种习惯。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// author:zhangsan</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">class ZhangsanTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private void TestGetData()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int a, b, c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private int ZhangsanGet(int s1, int s2)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int s3 = s1 + s2;</span><br><span class=\"line\">        return s3;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    private List&lt;string&gt; GetData()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个喜欢用自己的姓名来命名类和方法的作者，在他的代码中，经常可以看到这样奇怪的对象定义，而且他还喜欢用a,b,c,d,e,f或者s1,s2这样的命名，仿佛他的代码自带混淆特效。这样的代码嗅起来会不会觉得充斥着奇怪的味道？<br>另外，有没有发现有许多开发者喜欢用 GetData() 来定义获取数据的方法？然后这个方法就成为一个万金油的方法，不管是爬虫采集、或者数据绑定，无论是 C# 写的后端或者 Java 写的后端代码，或者用 vue 写的前端代码，仿佛在任何场景、任何数据应用都可以看到这样的方法。<br>如果一个项目中，有十几个地方都出现了这个** GetData() **方法，那种感觉一定非常难受。</p>\n<ul>\n<li>1.2 Model、Dto 傻傻分不清楚</li>\n</ul>\n<p>随着技能的增长，或许我们会学到一些新的代码概念，例如，Model、DTO 是经常容易弄混淆的一种概念，但是在某些代码中，出现了下面的命名方式就有点令人窒息了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class XXXModelDto</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        public int Id &#123; get; set; &#125;</span><br><span class=\"line\">        public string Name &#123; get; set; &#125;</span><br><span class=\"line\">        public string Alias &#123; get; set; &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是大概是一位对概念严重消化不良的资深开发者，居然同时把 Model 和 DTO 复用在一个对象上，<br>（当然，一个开发者定义变量的背后一定有他的动机）。<br>他到底是想要的是用来在 MVC 模式解决数据传输和对象绑定的模型对象？还是用于传输数据的 DTO 呢？<br>–其实他定义这个对象，是为了定义存储数据对象的实体（ Entity ）。</p>\n<ul>\n<li>1.3特殊情况术语和字段对照表非常重要</li>\n</ul>\n<p>近年来开发者素质越来越高，所以许多优秀开发者会倾向于使用翻译软件来翻译变量名，然后用英语来命名，但是即便如此，许多政务项目总是能嗅出一些奇怪的味道。<br>例如前不久看到一条这样的短信：（原图已经消失）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxx公积金中心提醒您：您于&#123;TQSJ&#125;日进行了&#123;TQCZ&#125;操作，账上剩余金额为&#123;SYJE&#125;元。</span><br></pre></td></tr></table></figure>\n\n<p>这是个bug将xxx公积金中心的某些秘密透露在大家面前。作为一个严谨的项目，居然使用中文首字母大写命名法，这让习惯于大驼峰、小驼峰的我看了之后尴尬癌犯了，很不舒服。但是这也是许多政务信息化项目的中字段命名的规范，而且在这种情况下，往往会输出一份非常规范的数据库字段对照表，确保中文和首字母的语义不让人产生歧义。<br>所以特定语境下，变量和方法本身没有严格的规定，但是一定要使用恰当的语境概念，对于这样的特定场景，尽量维护一份实时更新的术语表吧。</p>\n<ul>\n<li>2、状态码返回值<ul>\n<li>2.1业务逻辑状态码</li>\n</ul>\n</li>\n</ul>\n<p>似乎在对外提供接口时，使用下列接口状态码是一种比较常见的惯例。提供统一格式的 code 状态码以及返回的消息和成功返回结果时的填充数据，能够让开发者高效的完成接口对接，无需关心http状态码背后的含义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;code&quot;:&quot;100101&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:&#123;&#125;,&quot;count&quot;:&quot;&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>2.2用 http 状态码为什么不够？</li>\n</ul>\n<p>上面这是一种经典的流派，还有一种流派则会使用http状态码来返回指定的数据，事实上 http 协议本身已经提供了许多状态码，例如下面的这些大家都非常熟悉的状态码。<br>但是这些状态码为啥不够？主要是为了减少前后端、服务上下游之间接口对接的难度，也是一种提高效率的方式。 但是 http 状态码是一种通用的格式，应尽量使用这种方式，而不应该通过解析正常响应后的 json 来判断是否正确操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">200 ：正常响应 标准成功代码和默认选项。\t</span><br><span class=\"line\">201 ：创建对象。 适用于存储行为。\t</span><br><span class=\"line\">204 ：没有内容。 当一个动作成功执行，但没有任何内容可以返回。\t</span><br><span class=\"line\">206 ：部分内容。 当您必须返回分页的资源列表时很有用。\t</span><br><span class=\"line\">400 ：请求不正确 无法通过验证的请求的标准选项。\t</span><br><span class=\"line\">401 ：未经授权 用户需要进行身份验证。\t</span><br><span class=\"line\">403 ：禁止 用户已通过身份验证，但没有执行操作的权限。\t</span><br><span class=\"line\">404 ：找不到资源自动返回。\t</span><br><span class=\"line\">500 ：内部服务器错误。 理想情况下，您不会明确地返回此消息，但是如果发生意外中断，这是您的用户将会收到的。\t</span><br><span class=\"line\">503 ：服务不可用 相当自我解释，还有一个不会被应用程序显式返回的代码。</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>3、switch 语句与判断语句<ul>\n<li>3.1 面向过程式或面向对象式</li>\n</ul>\n</li>\n</ul>\n<p>我曾经跟小组中一位大佬交流他的一段代码，他的这段代码大概是这样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 流程处理</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">public void FlowProcess(int auditType)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  switch (auditType)</span><br><span class=\"line\">  &#123;                </span><br><span class=\"line\">      case 1://通过</span><br><span class=\"line\">          //此处省略通过场景下的50行代码</span><br><span class=\"line\">          break;</span><br><span class=\"line\">      case 2://不通过</span><br><span class=\"line\">          //此处省略不通过场景下的50行代码</span><br><span class=\"line\">          break;</span><br><span class=\"line\">      case 3://再审通过</span><br><span class=\"line\">          //此处省略再审通过场景下的50行代码</span><br><span class=\"line\">          break;</span><br><span class=\"line\">      case 4://再审不通过</span><br><span class=\"line\">          //此处省略再审不通过场景下的50行代码</span><br><span class=\"line\">          break;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（读者卒。）<br>且不说这位大佬的代码是写得好或者不好，仅仅就这200多行代码的4个大switch读起来大概会让人便秘难受吧。于是在我读完这段代码之后，我冒死向他请教这么写代码的原因，他说我这个流程处理就是一个简单的用例场景，哪里还有什么可以优化的余地？<br>我跟他介绍了20分钟代码封装的必要性，于是，他把代码写成了这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 流程处理</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">public void FlowProcess(int auditType)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    switch (auditType)</span><br><span class=\"line\">    &#123;                </span><br><span class=\"line\">        case 1://通过</span><br><span class=\"line\">            AuditOK();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 2://不通过</span><br><span class=\"line\">            AuditNotOK();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 3://再审通过</span><br><span class=\"line\">            ReAuditOK();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 4://再审不通过</span><br><span class=\"line\">            ReAuditNotOK();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void AuditOK()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //此处省略通过场景下的50行代码</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void AuditNotOK()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //此处省略不通过场景下的50行代码</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void ReAuditOK()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //此处省略再审通过场景下的50行代码</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void ReAuditNotOK()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //此处省略再审不通过场景下的50行代码</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这酸爽令人简直难以置信。（事实上这个新鲜出炉的遗留应用，正是这样一点点堆积了许多总代码行超过千行的类文件）<br>《代码整洁之道》书上有一个类似的例子，大概与上文类似，Robert 大叔给出了这样的建议：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于switch 语句，我的规矩是如果只出现一次，用于创建多态对象，而且隐藏在某个集成关系中，在系统中其他部分看不到，就还能容忍。当然也要就事论事，有时我也会部分或全部违反这条规矩。</span><br></pre></td></tr></table></figure>\n\n<p>上文我给出的示例，有点像面向过程的代码风格，而 Robert 大叔在他的书中写下的示例是这样的（抽象工厂模式的示例）。<br><img src=\"https://uploader.shimo.im/f/YMu9U5cRYngc1GUE.png!thumbnail\" alt=\"图片\"><br>这清爽的感觉，让人很舒服啊。</p>\n<ul>\n<li>3.2 孰优孰劣？</li>\n</ul>\n<p>当然，原示例是一个流程处理的例子，似乎大家的流程处理代码都习惯于使用这种面向过程风格的写法，反正要加判定条件，就加一个 case 就可以了。<br>而在某些特定情况下，甚至用 if / else 来写逻辑判断更简单，于是我们经常在某些销量很好的快速开发平台中，看到这样的例子。<br><img src=\"https://uploader.shimo.im/f/R3b6TAsMcoMPjUar.png!thumbnail\" alt=\"图片\"><br>这些典型的面向过程风格的代码，确实读起来似乎更加简单、而且也易于实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Robert 大叔是这样说的：过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数，面向对象代码便于在不改动既有函数的前提下添加新类。</span><br><span class=\"line\">反过来讲也说得通：过程式代码难以添加新数据结构，因为必须修改所有函数，面向对象代码难以添加新函数，因为必须修改所有类。</span><br></pre></td></tr></table></figure>\n\n<p>所以究竟是使用面向过程式代码，还是面向对象式代码？没有万试万灵的灵丹妙药。</p>\n<ul>\n<li>4、奥卡姆剃刀定律、得墨忒耳律<ul>\n<li>4.1“如非必要，勿增实体”</li>\n</ul>\n</li>\n</ul>\n<p>一旦开始初步掌握面向对象开发的基本原则，于是我们就会新建许多各种不同的模型对象。尤其是在webapi接口开发过程中，更是如此。</p>\n<blockquote>\n<p>   切勿浪费较多东西去做，用较少的东西，同样可以做好的事情。</p>\n</blockquote>\n<ul>\n<li>4.2 得墨忒耳律</li>\n</ul>\n<p>假设有一段代码是这样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public  class GrandParent</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public Father Son &#123; get; set; &#125;</span><br><span class=\"line\">    public string Name &#123; get; set; &#125;</span><br><span class=\"line\">    public Father GetSon()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return Son;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Father</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public Me Son &#123; get; set; &#125;</span><br><span class=\"line\">    public string Name &#123; get; set; &#125;</span><br><span class=\"line\">    public Father GetSon()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return Son;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Me</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public Son Son &#123; get; set; &#125;</span><br><span class=\"line\">    public string Name &#123; get; set; &#125;</span><br><span class=\"line\">    public Son GetSon()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return Son;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Son</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public GrandSon GrandSon &#123; get; set; &#125;</span><br><span class=\"line\">    public string Name &#123; get; set; &#125;</span><br><span class=\"line\">    public GrandSon GetSon()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return GrandSon;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class GrandSon</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   public string Name &#123; get; set; &#125;</span><br><span class=\"line\">    public string GetSon()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return Name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>会不会为了获得某些数据，而写出这样的代码呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return new GrandParent().GetSon().GetSon().GetSon().Name;</span><br></pre></td></tr></table></figure>\n\n<p>这样就是典型的对得墨忒耳律的违背。这个原则指出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">模块不应了解它所操作对象的内部情形。</span><br><span class=\"line\">更准确的说，得墨忒耳律认为，类C的方法f只应该调用以下对象的方法：</span><br><span class=\"line\">C（本身）</span><br><span class=\"line\">由方法f创建的对象。</span><br><span class=\"line\">作为参数传递给f的对象；</span><br><span class=\"line\">由C的实体变量持有的对象。</span><br><span class=\"line\">对象不应调用由任何函数返回的对象的方法。换言之，只跟朋友说话，不与陌生人说话。</span><br></pre></td></tr></table></figure>\n\n<p>在上文中我举的例子，祖父只跟自己的亲儿子（Father）说话，而不跟孙子说话。</p>\n<ul>\n<li>5、圈复杂度</li>\n</ul>\n<p>在软件测试的概念里，圈复杂度用来衡量一个模块判定结构的复杂程度，数量上表现为线性无关的路径条数，即合理的预防错误所需测试的最少路径条数。圈复杂度大说明程序代码可能质量低且难于测试和维护，根据经验，程序的可能错误和高的圈复杂度有着很大关系。<br>据说在Oracle数据库中有一些屎山代码，是通过一堆标识量来判断某些特定逻辑的，大概是这样的。<br>（示例仅供参考，由于资源限制，未能考证，还请大佬指正一二。）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 一个高复杂度的方法</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">public string HighCCMethod()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int flag = 1;</span><br><span class=\"line\">    int flag1 = 2;</span><br><span class=\"line\">    int flag2 = 3;</span><br><span class=\"line\">    int flag3 = 4;</span><br><span class=\"line\">    int flag4 = 5;</span><br><span class=\"line\">    if (flag == 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //do something</span><br><span class=\"line\">        if (flag1 == 2)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //dosomething</span><br><span class=\"line\">            if (flag2 == 3)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                //dosomething</span><br><span class=\"line\">                if (flag3 == 4 &amp;&amp; flag4 == 5)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    return &quot;编译器 die&quot;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &quot;...&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个圈复杂度非常复杂的方法，我想任何一个读到这样代码的开发者都会对自己的人生充满了积极而乐观的判断，那就是“活着比一切都好”。<br>对于这样的代码，我们应该尽可能的降低代码的圈复杂度，让程序满足基本可读的需求。</p>\n<ul>\n<li>6、注释<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void UploadImg()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int flag = 3;</span><br><span class=\"line\">    //标识量为3标识什么意思我也不知道，我在网上看到的。</span><br><span class=\"line\">    if (flag == 3)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //dosomething</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //uploadfile();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>我曾经参加过一个使用objectc编写的应用的，其中有一段代码是这样的，这个flag大概是魔法值，作者未经考证直接就在代码中使用了。然后一直流传下来，成为一段佳（gui）话（hua）。<br>还有这样的注释。傻傻分不清楚。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 为true标识为真，为false标识为假</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">public bool IsTrue &#123; get; set; &#125;</span><br><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 是否可见，为true标识可见，为false标识不可见</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">public bool IsVisible &#123; get; set; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有这样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//do something</span><br><span class=\"line\">Thread.Sleep(3000); //项目经理说此处要暂停3000毫秒，以便作为下次性能改进的需求点</span><br></pre></td></tr></table></figure>\n\n<p>Robert大叔如是说：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">什么也比不上放置良好的注释来得有用。什么也比不会乱七八糟的注释更有本事搞乱一个模块。什么也不会比陈旧、提供错误信息的注释更有破坏性。</span><br></pre></td></tr></table></figure>\n\n<p>当然很多中国程序员自称其变量命名是自注释的，例如大概是这样的。万能的 Is 命名法，只要是判断状态皆可用。<br>（每个程序员能够成功的生存下来都不容易，他一定有异于常人的本事。)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public bool IsShow &#123; get; set; &#125;</span><br><span class=\"line\">public bool IsGet &#123; get; set; &#125;</span><br><span class=\"line\">public bool IsUsed &#123; get; set; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>7、霰弹式修改</li>\n</ul>\n<p>CRUD开发者或许经常会看到这样的代码，例如，如果我要对某一个对象的状态（ Status）进行更改，可能会这么做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ShotGun1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public void Method1()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        DataStatus dataStatus = new DataStatus();</span><br><span class=\"line\">        dataStatus.Flag = 1 * 3;</span><br><span class=\"line\">        dataStatus.Status = &quot;1234&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class ShotGun2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public void Method2(int i, int status)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        DataStatus dataStatus = new DataStatus();</span><br><span class=\"line\">        dataStatus.Flag = 1 * 3;</span><br><span class=\"line\">        dataStatus.Status = &quot;1234&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种霰弹式代码中，一处代码规则的变化，可能会需要对许多处代码进行同步修改，使得我们的代码异常的难以维护。</p>\n<ul>\n<li>8、异常</li>\n</ul>\n<p>有时候可能会遇到这样的代码，在方法中定义一些文本的状态码，然后调用方法时，再去判断这个状态码的内容，当返回错误码时，要求调用者立即处理错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class XXXApi</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public CurrentUser CurrentUser &#123; get; &#125;</span><br><span class=\"line\">    public string DoSomething()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (GetCurrentUid() == &quot;用户为空&quot;)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //do something</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //dosomething</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return &quot;&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public string GetCurrentUid()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (CurrentUser == null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return &quot;用户为空&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return &quot;&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class CurrentUser</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public string Uid &#123; get; set; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不如直接抛出异常，让异常处理机制进行处理吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string GetCurrentUid()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (CurrentUser == null)</span><br><span class=\"line\">        throw new NoLoginExecption(&quot;&quot;);</span><br><span class=\"line\">    return &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"9、边界\"><a href=\"#9、边界\" class=\"headerlink\" title=\"9、边界\"></a>9、边界</h1><h2 id=\"9-1-模块间的边界\"><a href=\"#9-1-模块间的边界\" class=\"headerlink\" title=\"9.1 模块间的边界\"></a>9.1 模块间的边界</h2><p>即便是简单的CRUD应用系统，优秀的开发者也能更好的处理应用程序模块间的边界。某种意义上讲，应用程序内部的边界看起来或许没有明确的界限之分，但是稍不留心就可能导致应用程序间关系过于紊乱，让其他开发者捉摸不透。<br>例如，假设有一段代码是这样的，在用户操作类中，加入了一个获取应用数据的方法，确实会让人很费解吧。（而应用领域驱动设计的思维，或许是一种不错的模式。）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class UserService</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public string GetAppData(string config)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //do something</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-2应用间的边界\"><a href=\"#9-2应用间的边界\" class=\"headerlink\" title=\"9.2应用间的边界\"></a>9.2应用间的边界</h2><p>相对而言，或许应用间的边界似乎能相对清晰的分析出来？并非如此。<br>在当今时代，我们很少开发完全与其他应用系统没有任何关联的独立软件，这意味着我们或许无时无刻都得与其他第三方应用进行接口行为或数据的交换。这让我们必须确保采取措施让外来代码干净利落地整合进自己的代码中。<br>假设有一段代码是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class UserService</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    public string GetAppData(string config)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //do something</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public string UploadOssData(string file)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        OssConfig oss = new OssConfig();</span><br><span class=\"line\">        OssSdk ossSdk = OssSdk.CreateInstance();</span><br><span class=\"line\">        ossSdk.UploadFile(file);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在《代码整洁之道》书中，Robert大叔推荐应该第三方接口进行隔离，通过Map那样包装或者使用适配器模式将我们的接口转换成第三方提供的接口。让代码更好地与我们沟通，在边界两边推动内部一致的用法，当第三方代码有改动时修改点也会更少。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>写代码是开发者的基础技能，无论你是.NET 开发者，或者 Java 开发者，你都在努力用代码实现自己的梦想。如同韩磊老师在译作《代码整理之道》封面上总结全书，写下的那句诗</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“细节之中自有天地，整洁成就卓越代码”。</span><br></pre></td></tr></table></figure>\n\n<p>卓越代码从来不仅仅只是功能完善、代码齐全，做好细节，每个细节就是一方小天地。优雅的代码，不仅仅只是开发者的个人能力的体现，更是开发者的立足之本。努力改善坏习惯，提高代码质量，时刻消除异味，时刻提高自己，更有助于个人技能的全面发展。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><ul>\n<li>我们总是很容易就能写出满足某个特定功能的代码，却很难写出优雅代码。又最欣赏那些优雅的代码，因为优雅代码更能体现一个开发者的积累。</li>\n<li>就像写一篇散文，有的就像初学者不得其门而入，遣词造句都非常困难，然后纠纠结结，最终不了了之。或者啰哩吧嗦，看起来说了一堆，其实就像是村妇闲聊，毫无重点，不过是口水文而已。</li>\n<li>好代码应该是这样的，如涓涓细流、如同一首诗，一篇优美的故事，将作者编写代码时的情感慢慢铺垫开来，或是高潮迭起，此起彼伏，或是平铺直述，却蕴含道理。我始终相信优秀的代码是有灵魂的，代码的灵魂就是作者的逻辑思维。</li>\n<li>编写整洁代码 or 非整洁代码，就像平时生活中是否注意爱护环境的一点点小习惯，一旦坏味道代码没有及时处理，就会成为破窗效应，然后逐渐的代码越写越烂，最终这些代码要么以重构收场，要么就被抛弃。</li>\n<li>我们见过太多没有毫无质量可言的代码，许多时候开发者们由于能力原因、或者时间有限，写了许多能够满足当前工作的代码，然后就弃置高阁，不再理会。于是，代码写之前的只有自己和上帝能理解代码的意思，而写完了之后，只有上帝能懂了；还有一些开发者说：我只会写代码，不会优化代码，他们仿佛特别勤奋，每天都会比其他人都热衷于熬工时，但是写出的代码，实际上是一个个难以维护的技术债。而且许多代码的作者总喜欢找各种借口来抵赖，例如喜欢说代码出了问题都是底层框架太垃圾了、或者别人的代码封装得太差。他们总是抱怨这抱怨那，但是即便有优秀的框架、技术，就一定能写出优秀的代码么？</li>\n<li>在这里笔者列举了平时看到过一些自认为不太整洁的代码，以及与《代码整洁之道》（Clean Code · A Handbook of Agile Software Craftsmanship）一书中相对应的范例，欢迎大家一起来拍砖。</li>\n<li>（经验有限，时间仓促，请轻喷。）<h1 id=\"一些栗子\"><a href=\"#一些栗子\" class=\"headerlink\" title=\"一些栗子\"></a>一些栗子</h1></li>\n<li>1、命名规则<ul>\n<li>1.1 变量命名和方法命名</li>\n</ul>\n</li>\n</ul>\n<p>在我们刚刚开始学习写代码的古老时代，或许会有下面这种习惯。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// author:zhangsan</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">class ZhangsanTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private void TestGetData()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int a, b, c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private int ZhangsanGet(int s1, int s2)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int s3 = s1 + s2;</span><br><span class=\"line\">        return s3;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    private List&lt;string&gt; GetData()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个喜欢用自己的姓名来命名类和方法的作者，在他的代码中，经常可以看到这样奇怪的对象定义，而且他还喜欢用a,b,c,d,e,f或者s1,s2这样的命名，仿佛他的代码自带混淆特效。这样的代码嗅起来会不会觉得充斥着奇怪的味道？<br>另外，有没有发现有许多开发者喜欢用 GetData() 来定义获取数据的方法？然后这个方法就成为一个万金油的方法，不管是爬虫采集、或者数据绑定，无论是 C# 写的后端或者 Java 写的后端代码，或者用 vue 写的前端代码，仿佛在任何场景、任何数据应用都可以看到这样的方法。<br>如果一个项目中，有十几个地方都出现了这个** GetData() **方法，那种感觉一定非常难受。</p>\n<ul>\n<li>1.2 Model、Dto 傻傻分不清楚</li>\n</ul>\n<p>随着技能的增长，或许我们会学到一些新的代码概念，例如，Model、DTO 是经常容易弄混淆的一种概念，但是在某些代码中，出现了下面的命名方式就有点令人窒息了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class XXXModelDto</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        public int Id &#123; get; set; &#125;</span><br><span class=\"line\">        public string Name &#123; get; set; &#125;</span><br><span class=\"line\">        public string Alias &#123; get; set; &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是大概是一位对概念严重消化不良的资深开发者，居然同时把 Model 和 DTO 复用在一个对象上，<br>（当然，一个开发者定义变量的背后一定有他的动机）。<br>他到底是想要的是用来在 MVC 模式解决数据传输和对象绑定的模型对象？还是用于传输数据的 DTO 呢？<br>–其实他定义这个对象，是为了定义存储数据对象的实体（ Entity ）。</p>\n<ul>\n<li>1.3特殊情况术语和字段对照表非常重要</li>\n</ul>\n<p>近年来开发者素质越来越高，所以许多优秀开发者会倾向于使用翻译软件来翻译变量名，然后用英语来命名，但是即便如此，许多政务项目总是能嗅出一些奇怪的味道。<br>例如前不久看到一条这样的短信：（原图已经消失）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxx公积金中心提醒您：您于&#123;TQSJ&#125;日进行了&#123;TQCZ&#125;操作，账上剩余金额为&#123;SYJE&#125;元。</span><br></pre></td></tr></table></figure>\n\n<p>这是个bug将xxx公积金中心的某些秘密透露在大家面前。作为一个严谨的项目，居然使用中文首字母大写命名法，这让习惯于大驼峰、小驼峰的我看了之后尴尬癌犯了，很不舒服。但是这也是许多政务信息化项目的中字段命名的规范，而且在这种情况下，往往会输出一份非常规范的数据库字段对照表，确保中文和首字母的语义不让人产生歧义。<br>所以特定语境下，变量和方法本身没有严格的规定，但是一定要使用恰当的语境概念，对于这样的特定场景，尽量维护一份实时更新的术语表吧。</p>\n<ul>\n<li>2、状态码返回值<ul>\n<li>2.1业务逻辑状态码</li>\n</ul>\n</li>\n</ul>\n<p>似乎在对外提供接口时，使用下列接口状态码是一种比较常见的惯例。提供统一格式的 code 状态码以及返回的消息和成功返回结果时的填充数据，能够让开发者高效的完成接口对接，无需关心http状态码背后的含义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;code&quot;:&quot;100101&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:&#123;&#125;,&quot;count&quot;:&quot;&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>2.2用 http 状态码为什么不够？</li>\n</ul>\n<p>上面这是一种经典的流派，还有一种流派则会使用http状态码来返回指定的数据，事实上 http 协议本身已经提供了许多状态码，例如下面的这些大家都非常熟悉的状态码。<br>但是这些状态码为啥不够？主要是为了减少前后端、服务上下游之间接口对接的难度，也是一种提高效率的方式。 但是 http 状态码是一种通用的格式，应尽量使用这种方式，而不应该通过解析正常响应后的 json 来判断是否正确操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">200 ：正常响应 标准成功代码和默认选项。\t</span><br><span class=\"line\">201 ：创建对象。 适用于存储行为。\t</span><br><span class=\"line\">204 ：没有内容。 当一个动作成功执行，但没有任何内容可以返回。\t</span><br><span class=\"line\">206 ：部分内容。 当您必须返回分页的资源列表时很有用。\t</span><br><span class=\"line\">400 ：请求不正确 无法通过验证的请求的标准选项。\t</span><br><span class=\"line\">401 ：未经授权 用户需要进行身份验证。\t</span><br><span class=\"line\">403 ：禁止 用户已通过身份验证，但没有执行操作的权限。\t</span><br><span class=\"line\">404 ：找不到资源自动返回。\t</span><br><span class=\"line\">500 ：内部服务器错误。 理想情况下，您不会明确地返回此消息，但是如果发生意外中断，这是您的用户将会收到的。\t</span><br><span class=\"line\">503 ：服务不可用 相当自我解释，还有一个不会被应用程序显式返回的代码。</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>3、switch 语句与判断语句<ul>\n<li>3.1 面向过程式或面向对象式</li>\n</ul>\n</li>\n</ul>\n<p>我曾经跟小组中一位大佬交流他的一段代码，他的这段代码大概是这样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 流程处理</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">public void FlowProcess(int auditType)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  switch (auditType)</span><br><span class=\"line\">  &#123;                </span><br><span class=\"line\">      case 1://通过</span><br><span class=\"line\">          //此处省略通过场景下的50行代码</span><br><span class=\"line\">          break;</span><br><span class=\"line\">      case 2://不通过</span><br><span class=\"line\">          //此处省略不通过场景下的50行代码</span><br><span class=\"line\">          break;</span><br><span class=\"line\">      case 3://再审通过</span><br><span class=\"line\">          //此处省略再审通过场景下的50行代码</span><br><span class=\"line\">          break;</span><br><span class=\"line\">      case 4://再审不通过</span><br><span class=\"line\">          //此处省略再审不通过场景下的50行代码</span><br><span class=\"line\">          break;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（读者卒。）<br>且不说这位大佬的代码是写得好或者不好，仅仅就这200多行代码的4个大switch读起来大概会让人便秘难受吧。于是在我读完这段代码之后，我冒死向他请教这么写代码的原因，他说我这个流程处理就是一个简单的用例场景，哪里还有什么可以优化的余地？<br>我跟他介绍了20分钟代码封装的必要性，于是，他把代码写成了这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 流程处理</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">public void FlowProcess(int auditType)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    switch (auditType)</span><br><span class=\"line\">    &#123;                </span><br><span class=\"line\">        case 1://通过</span><br><span class=\"line\">            AuditOK();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 2://不通过</span><br><span class=\"line\">            AuditNotOK();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 3://再审通过</span><br><span class=\"line\">            ReAuditOK();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 4://再审不通过</span><br><span class=\"line\">            ReAuditNotOK();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void AuditOK()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //此处省略通过场景下的50行代码</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void AuditNotOK()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //此处省略不通过场景下的50行代码</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void ReAuditOK()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //此处省略再审通过场景下的50行代码</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void ReAuditNotOK()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //此处省略再审不通过场景下的50行代码</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这酸爽令人简直难以置信。（事实上这个新鲜出炉的遗留应用，正是这样一点点堆积了许多总代码行超过千行的类文件）<br>《代码整洁之道》书上有一个类似的例子，大概与上文类似，Robert 大叔给出了这样的建议：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于switch 语句，我的规矩是如果只出现一次，用于创建多态对象，而且隐藏在某个集成关系中，在系统中其他部分看不到，就还能容忍。当然也要就事论事，有时我也会部分或全部违反这条规矩。</span><br></pre></td></tr></table></figure>\n\n<p>上文我给出的示例，有点像面向过程的代码风格，而 Robert 大叔在他的书中写下的示例是这样的（抽象工厂模式的示例）。<br><img src=\"https://uploader.shimo.im/f/YMu9U5cRYngc1GUE.png!thumbnail\" alt=\"图片\"><br>这清爽的感觉，让人很舒服啊。</p>\n<ul>\n<li>3.2 孰优孰劣？</li>\n</ul>\n<p>当然，原示例是一个流程处理的例子，似乎大家的流程处理代码都习惯于使用这种面向过程风格的写法，反正要加判定条件，就加一个 case 就可以了。<br>而在某些特定情况下，甚至用 if / else 来写逻辑判断更简单，于是我们经常在某些销量很好的快速开发平台中，看到这样的例子。<br><img src=\"https://uploader.shimo.im/f/R3b6TAsMcoMPjUar.png!thumbnail\" alt=\"图片\"><br>这些典型的面向过程风格的代码，确实读起来似乎更加简单、而且也易于实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Robert 大叔是这样说的：过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数，面向对象代码便于在不改动既有函数的前提下添加新类。</span><br><span class=\"line\">反过来讲也说得通：过程式代码难以添加新数据结构，因为必须修改所有函数，面向对象代码难以添加新函数，因为必须修改所有类。</span><br></pre></td></tr></table></figure>\n\n<p>所以究竟是使用面向过程式代码，还是面向对象式代码？没有万试万灵的灵丹妙药。</p>\n<ul>\n<li>4、奥卡姆剃刀定律、得墨忒耳律<ul>\n<li>4.1“如非必要，勿增实体”</li>\n</ul>\n</li>\n</ul>\n<p>一旦开始初步掌握面向对象开发的基本原则，于是我们就会新建许多各种不同的模型对象。尤其是在webapi接口开发过程中，更是如此。</p>\n<blockquote>\n<p>   切勿浪费较多东西去做，用较少的东西，同样可以做好的事情。</p>\n</blockquote>\n<ul>\n<li>4.2 得墨忒耳律</li>\n</ul>\n<p>假设有一段代码是这样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public  class GrandParent</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public Father Son &#123; get; set; &#125;</span><br><span class=\"line\">    public string Name &#123; get; set; &#125;</span><br><span class=\"line\">    public Father GetSon()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return Son;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Father</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public Me Son &#123; get; set; &#125;</span><br><span class=\"line\">    public string Name &#123; get; set; &#125;</span><br><span class=\"line\">    public Father GetSon()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return Son;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Me</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public Son Son &#123; get; set; &#125;</span><br><span class=\"line\">    public string Name &#123; get; set; &#125;</span><br><span class=\"line\">    public Son GetSon()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return Son;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Son</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public GrandSon GrandSon &#123; get; set; &#125;</span><br><span class=\"line\">    public string Name &#123; get; set; &#125;</span><br><span class=\"line\">    public GrandSon GetSon()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return GrandSon;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class GrandSon</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   public string Name &#123; get; set; &#125;</span><br><span class=\"line\">    public string GetSon()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return Name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>会不会为了获得某些数据，而写出这样的代码呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return new GrandParent().GetSon().GetSon().GetSon().Name;</span><br></pre></td></tr></table></figure>\n\n<p>这样就是典型的对得墨忒耳律的违背。这个原则指出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">模块不应了解它所操作对象的内部情形。</span><br><span class=\"line\">更准确的说，得墨忒耳律认为，类C的方法f只应该调用以下对象的方法：</span><br><span class=\"line\">C（本身）</span><br><span class=\"line\">由方法f创建的对象。</span><br><span class=\"line\">作为参数传递给f的对象；</span><br><span class=\"line\">由C的实体变量持有的对象。</span><br><span class=\"line\">对象不应调用由任何函数返回的对象的方法。换言之，只跟朋友说话，不与陌生人说话。</span><br></pre></td></tr></table></figure>\n\n<p>在上文中我举的例子，祖父只跟自己的亲儿子（Father）说话，而不跟孙子说话。</p>\n<ul>\n<li>5、圈复杂度</li>\n</ul>\n<p>在软件测试的概念里，圈复杂度用来衡量一个模块判定结构的复杂程度，数量上表现为线性无关的路径条数，即合理的预防错误所需测试的最少路径条数。圈复杂度大说明程序代码可能质量低且难于测试和维护，根据经验，程序的可能错误和高的圈复杂度有着很大关系。<br>据说在Oracle数据库中有一些屎山代码，是通过一堆标识量来判断某些特定逻辑的，大概是这样的。<br>（示例仅供参考，由于资源限制，未能考证，还请大佬指正一二。）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 一个高复杂度的方法</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">public string HighCCMethod()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int flag = 1;</span><br><span class=\"line\">    int flag1 = 2;</span><br><span class=\"line\">    int flag2 = 3;</span><br><span class=\"line\">    int flag3 = 4;</span><br><span class=\"line\">    int flag4 = 5;</span><br><span class=\"line\">    if (flag == 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //do something</span><br><span class=\"line\">        if (flag1 == 2)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //dosomething</span><br><span class=\"line\">            if (flag2 == 3)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                //dosomething</span><br><span class=\"line\">                if (flag3 == 4 &amp;&amp; flag4 == 5)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    return &quot;编译器 die&quot;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &quot;...&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个圈复杂度非常复杂的方法，我想任何一个读到这样代码的开发者都会对自己的人生充满了积极而乐观的判断，那就是“活着比一切都好”。<br>对于这样的代码，我们应该尽可能的降低代码的圈复杂度，让程序满足基本可读的需求。</p>\n<ul>\n<li>6、注释<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void UploadImg()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int flag = 3;</span><br><span class=\"line\">    //标识量为3标识什么意思我也不知道，我在网上看到的。</span><br><span class=\"line\">    if (flag == 3)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //dosomething</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //uploadfile();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>我曾经参加过一个使用objectc编写的应用的，其中有一段代码是这样的，这个flag大概是魔法值，作者未经考证直接就在代码中使用了。然后一直流传下来，成为一段佳（gui）话（hua）。<br>还有这样的注释。傻傻分不清楚。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 为true标识为真，为false标识为假</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">public bool IsTrue &#123; get; set; &#125;</span><br><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 是否可见，为true标识可见，为false标识不可见</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">public bool IsVisible &#123; get; set; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有这样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//do something</span><br><span class=\"line\">Thread.Sleep(3000); //项目经理说此处要暂停3000毫秒，以便作为下次性能改进的需求点</span><br></pre></td></tr></table></figure>\n\n<p>Robert大叔如是说：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">什么也比不上放置良好的注释来得有用。什么也比不会乱七八糟的注释更有本事搞乱一个模块。什么也不会比陈旧、提供错误信息的注释更有破坏性。</span><br></pre></td></tr></table></figure>\n\n<p>当然很多中国程序员自称其变量命名是自注释的，例如大概是这样的。万能的 Is 命名法，只要是判断状态皆可用。<br>（每个程序员能够成功的生存下来都不容易，他一定有异于常人的本事。)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public bool IsShow &#123; get; set; &#125;</span><br><span class=\"line\">public bool IsGet &#123; get; set; &#125;</span><br><span class=\"line\">public bool IsUsed &#123; get; set; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>7、霰弹式修改</li>\n</ul>\n<p>CRUD开发者或许经常会看到这样的代码，例如，如果我要对某一个对象的状态（ Status）进行更改，可能会这么做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ShotGun1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public void Method1()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        DataStatus dataStatus = new DataStatus();</span><br><span class=\"line\">        dataStatus.Flag = 1 * 3;</span><br><span class=\"line\">        dataStatus.Status = &quot;1234&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class ShotGun2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public void Method2(int i, int status)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        DataStatus dataStatus = new DataStatus();</span><br><span class=\"line\">        dataStatus.Flag = 1 * 3;</span><br><span class=\"line\">        dataStatus.Status = &quot;1234&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种霰弹式代码中，一处代码规则的变化，可能会需要对许多处代码进行同步修改，使得我们的代码异常的难以维护。</p>\n<ul>\n<li>8、异常</li>\n</ul>\n<p>有时候可能会遇到这样的代码，在方法中定义一些文本的状态码，然后调用方法时，再去判断这个状态码的内容，当返回错误码时，要求调用者立即处理错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class XXXApi</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public CurrentUser CurrentUser &#123; get; &#125;</span><br><span class=\"line\">    public string DoSomething()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (GetCurrentUid() == &quot;用户为空&quot;)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //do something</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            //dosomething</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return &quot;&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public string GetCurrentUid()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (CurrentUser == null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return &quot;用户为空&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return &quot;&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class CurrentUser</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public string Uid &#123; get; set; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不如直接抛出异常，让异常处理机制进行处理吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string GetCurrentUid()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (CurrentUser == null)</span><br><span class=\"line\">        throw new NoLoginExecption(&quot;&quot;);</span><br><span class=\"line\">    return &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"9、边界\"><a href=\"#9、边界\" class=\"headerlink\" title=\"9、边界\"></a>9、边界</h1><h2 id=\"9-1-模块间的边界\"><a href=\"#9-1-模块间的边界\" class=\"headerlink\" title=\"9.1 模块间的边界\"></a>9.1 模块间的边界</h2><p>即便是简单的CRUD应用系统，优秀的开发者也能更好的处理应用程序模块间的边界。某种意义上讲，应用程序内部的边界看起来或许没有明确的界限之分，但是稍不留心就可能导致应用程序间关系过于紊乱，让其他开发者捉摸不透。<br>例如，假设有一段代码是这样的，在用户操作类中，加入了一个获取应用数据的方法，确实会让人很费解吧。（而应用领域驱动设计的思维，或许是一种不错的模式。）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class UserService</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public string GetAppData(string config)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //do something</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-2应用间的边界\"><a href=\"#9-2应用间的边界\" class=\"headerlink\" title=\"9.2应用间的边界\"></a>9.2应用间的边界</h2><p>相对而言，或许应用间的边界似乎能相对清晰的分析出来？并非如此。<br>在当今时代，我们很少开发完全与其他应用系统没有任何关联的独立软件，这意味着我们或许无时无刻都得与其他第三方应用进行接口行为或数据的交换。这让我们必须确保采取措施让外来代码干净利落地整合进自己的代码中。<br>假设有一段代码是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class UserService</span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    public string GetAppData(string config)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //do something</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public string UploadOssData(string file)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        OssConfig oss = new OssConfig();</span><br><span class=\"line\">        OssSdk ossSdk = OssSdk.CreateInstance();</span><br><span class=\"line\">        ossSdk.UploadFile(file);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在《代码整洁之道》书中，Robert大叔推荐应该第三方接口进行隔离，通过Map那样包装或者使用适配器模式将我们的接口转换成第三方提供的接口。让代码更好地与我们沟通，在边界两边推动内部一致的用法，当第三方代码有改动时修改点也会更少。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>写代码是开发者的基础技能，无论你是.NET 开发者，或者 Java 开发者，你都在努力用代码实现自己的梦想。如同韩磊老师在译作《代码整理之道》封面上总结全书，写下的那句诗</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“细节之中自有天地，整洁成就卓越代码”。</span><br></pre></td></tr></table></figure>\n\n<p>卓越代码从来不仅仅只是功能完善、代码齐全，做好细节，每个细节就是一方小天地。优雅的代码，不仅仅只是开发者的个人能力的体现，更是开发者的立足之本。努力改善坏习惯，提高代码质量，时刻消除异味，时刻提高自己，更有助于个人技能的全面发展。</p>\n"},{"title":"分析EFCore中的内存泄漏","date":"2020-04-22T14:28:00.000Z","author":"邹溪源","_content":"# 分析EFCore中的内存泄漏\n\n ![消防漏水入水坑](https://dzone.com/storage/temp/12517247-pic-fire-house-leaking-water-into-puddle.jpg) \n\n术语“内存泄漏”和“ .NET应用程序”不是经常一起使用。但是，我们最近在一个.NET Core Web应用程序中出现了一系列内存不足异常。事实证明，此问题是由Entity Framework Core中的行为更改引起的，尽管最终的解决方案非常简单，但实现该目标的过程既充满挑战又有趣。\n\n该系统本身托管在Azure中，由Angular SPA前端和后端的.NET Core API组成，使用Entity Framework Core与Azure SQL数据库进行通信。作为专门从事.NET开发的软件咨询公司，我们之前已经编写了许多类似的应用程序。因此[，内存不足崩溃](https://dzone.com/articles/what-causes-outofmemoryerror)是无法预料的，因此我们立即知道这是需要认真对待的事情。使用Azure门户中的指标，我们可以看到内存使用率稳步上升，然后突然下降：此下降是应用程序崩溃。\n\n![修复之前](https://dzone.com/storage/temp/12481545-before.png)\n\n*修复之前*\n\n因此，我们花了一些时间进行调查并逐步进行更改，以解决看似经典的内存泄漏问题。.NET泄漏的常见原因是未正确处理某些问题，在我们的案例中很可能是EF Core数据库上下文。因此，我们遍历了源代码，以寻找可能无法处理上下文的潜在原因。这变成了空白。\n\n我们将Entity Framework Core升级到了最新版本，因为最近的更新包括各种内存泄漏的修复程序和总体效率的提高。\n\n我们还在使用的Application Insights版本中发现了可能的内存泄漏（请参阅https://github.com/microsoft/ApplicationInsights-dotnet/issues/594），因此我们也对该软件包进行了升级。\n\n这些都不能解决问题，因此我们解剖了从Azure应用服务中获取的内存转储（请参阅https://blogs.msdn.microsoft.com/jpsanders/2017/02/02/how-to-get-a-full-memory-dump-in-azure-app-services/）。\n\n我们注意到，绝大多数托管内存最终都由MemoryCache类使用。进一步深入研究表明，大多数缓存数据都是原始SQL查询的形式。我们看到大量的根本上是同一查询的事件被多次缓存，并且参数本身被硬编码在查询中而不是被参数化。\n\n例如，与其像这样缓存查询：\n\n```sql\nSELECT TOP (1) UserId, FirstName, LastName, EmailAddress\nFROM Users\nWHERE UserId = @param_1\n```\n\n\n\n我们发现这样的多个查询：\n\n```\nSELECT TOP (1) UserId, FirstName, LastName, EmailAddress\nFROM Users\nWHERE UserId = 5\n```\n\n\n\n因此，我们进行了一些搜索，寻找可能与之相关的EF核心问题，并遇到了这个问题：[https](https://github.com/aspnet/EntityFrameworkCore/issues/10535) : [//github.com/aspnet/EntityFrameworkCore/issues/10535](https://github.com/aspnet/EntityFrameworkCore/issues/10535)。\n\n关于这个问题的主题指出了这个问题：我们正在建立一个动态表达式树，并使用它  `Expressions.Expression.Constant` 来为where子句提供参数。使用常量表达式意味着Entity Framework Core不会参数化SQL查询，并且是Entity Framework 6的行为更改。\n\n我们到处都使用这个表达式树，通过它的ID来获取某些东西，这就是为什么它是一个很大的问题。\n\n因此，这就是我们所做的更改：\n\n```c#\n// Before\nvar param = Expressions.Expression.Parameter(typeof(T));\nExpression = Expressions.Expression.Lambda<Func<T, bool>>(\n  Expressions.Expression.Call(\n    Expressions.Expression.Constant(valuesToFilter),\n    \"Contains\",\n    Type.EmptyTypes,\n    Expressions.Expression.Property(param, propertyName)),\n  param);\n// After\nvar param = Expressions.Expression.Parameter(typeof(T));\n// This is what we added\nExpression<Func<List<int>>> valuesToFilterLambda = () => valuesToFilter;\nExpression = Expressions.Expression.Lambda<Func<T, bool>>(\n  Expressions.Expression.Call(\n    valuesToFilterLambda.Body,\n    \"Contains\",\n    Type.EmptyTypes,\n    Expressions.Expression.Property(param, propertyName)),\n  param);\n```\n\n\n\n使用lambda表达式获取表达式主体会使[Entity Framework Core](https://dzone.com/articles/entity-framework-core-30-and-sql-server-2019-perfo)对SQL查询进行参数化，因此仅缓存它的一个实例。\n\n这是包括修订版本在内的一段时间内的内存使用情况。该版本以红色标记，您可以看到差异很大。稳定的内存使用量从未超过200MB，而不断攀升至超过1GB，然后发生崩溃。\n\n![修复后](https://dzone.com/storage/temp/12481549-release.png)\n\n*修复后*\n\n最初进行调查时，真正的解决方案不是我们要注意的事情，而是通过检查内存转储并遵循证据我们最终到达那里。\n\n从此调查中可以汲取的教训是：\n\n- 内存转储不会说谎-如果内存泄漏，请先查看证据。\n- 微软已经开放了EF Core的源代码，所有问题在那里所有人都可以看到，对有需求的开发者来说非常方便。\n- 简单的代码更改（在这种情况下为一行）可能会产生巨大的影响。","source":"_posts/技术/分析EFCore中的内存泄漏.md","raw":"---\ntitle:  分析EFCore中的内存泄漏\ndate: 2020-4-22 22:28\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n# 分析EFCore中的内存泄漏\n\n ![消防漏水入水坑](https://dzone.com/storage/temp/12517247-pic-fire-house-leaking-water-into-puddle.jpg) \n\n术语“内存泄漏”和“ .NET应用程序”不是经常一起使用。但是，我们最近在一个.NET Core Web应用程序中出现了一系列内存不足异常。事实证明，此问题是由Entity Framework Core中的行为更改引起的，尽管最终的解决方案非常简单，但实现该目标的过程既充满挑战又有趣。\n\n该系统本身托管在Azure中，由Angular SPA前端和后端的.NET Core API组成，使用Entity Framework Core与Azure SQL数据库进行通信。作为专门从事.NET开发的软件咨询公司，我们之前已经编写了许多类似的应用程序。因此[，内存不足崩溃](https://dzone.com/articles/what-causes-outofmemoryerror)是无法预料的，因此我们立即知道这是需要认真对待的事情。使用Azure门户中的指标，我们可以看到内存使用率稳步上升，然后突然下降：此下降是应用程序崩溃。\n\n![修复之前](https://dzone.com/storage/temp/12481545-before.png)\n\n*修复之前*\n\n因此，我们花了一些时间进行调查并逐步进行更改，以解决看似经典的内存泄漏问题。.NET泄漏的常见原因是未正确处理某些问题，在我们的案例中很可能是EF Core数据库上下文。因此，我们遍历了源代码，以寻找可能无法处理上下文的潜在原因。这变成了空白。\n\n我们将Entity Framework Core升级到了最新版本，因为最近的更新包括各种内存泄漏的修复程序和总体效率的提高。\n\n我们还在使用的Application Insights版本中发现了可能的内存泄漏（请参阅https://github.com/microsoft/ApplicationInsights-dotnet/issues/594），因此我们也对该软件包进行了升级。\n\n这些都不能解决问题，因此我们解剖了从Azure应用服务中获取的内存转储（请参阅https://blogs.msdn.microsoft.com/jpsanders/2017/02/02/how-to-get-a-full-memory-dump-in-azure-app-services/）。\n\n我们注意到，绝大多数托管内存最终都由MemoryCache类使用。进一步深入研究表明，大多数缓存数据都是原始SQL查询的形式。我们看到大量的根本上是同一查询的事件被多次缓存，并且参数本身被硬编码在查询中而不是被参数化。\n\n例如，与其像这样缓存查询：\n\n```sql\nSELECT TOP (1) UserId, FirstName, LastName, EmailAddress\nFROM Users\nWHERE UserId = @param_1\n```\n\n\n\n我们发现这样的多个查询：\n\n```\nSELECT TOP (1) UserId, FirstName, LastName, EmailAddress\nFROM Users\nWHERE UserId = 5\n```\n\n\n\n因此，我们进行了一些搜索，寻找可能与之相关的EF核心问题，并遇到了这个问题：[https](https://github.com/aspnet/EntityFrameworkCore/issues/10535) : [//github.com/aspnet/EntityFrameworkCore/issues/10535](https://github.com/aspnet/EntityFrameworkCore/issues/10535)。\n\n关于这个问题的主题指出了这个问题：我们正在建立一个动态表达式树，并使用它  `Expressions.Expression.Constant` 来为where子句提供参数。使用常量表达式意味着Entity Framework Core不会参数化SQL查询，并且是Entity Framework 6的行为更改。\n\n我们到处都使用这个表达式树，通过它的ID来获取某些东西，这就是为什么它是一个很大的问题。\n\n因此，这就是我们所做的更改：\n\n```c#\n// Before\nvar param = Expressions.Expression.Parameter(typeof(T));\nExpression = Expressions.Expression.Lambda<Func<T, bool>>(\n  Expressions.Expression.Call(\n    Expressions.Expression.Constant(valuesToFilter),\n    \"Contains\",\n    Type.EmptyTypes,\n    Expressions.Expression.Property(param, propertyName)),\n  param);\n// After\nvar param = Expressions.Expression.Parameter(typeof(T));\n// This is what we added\nExpression<Func<List<int>>> valuesToFilterLambda = () => valuesToFilter;\nExpression = Expressions.Expression.Lambda<Func<T, bool>>(\n  Expressions.Expression.Call(\n    valuesToFilterLambda.Body,\n    \"Contains\",\n    Type.EmptyTypes,\n    Expressions.Expression.Property(param, propertyName)),\n  param);\n```\n\n\n\n使用lambda表达式获取表达式主体会使[Entity Framework Core](https://dzone.com/articles/entity-framework-core-30-and-sql-server-2019-perfo)对SQL查询进行参数化，因此仅缓存它的一个实例。\n\n这是包括修订版本在内的一段时间内的内存使用情况。该版本以红色标记，您可以看到差异很大。稳定的内存使用量从未超过200MB，而不断攀升至超过1GB，然后发生崩溃。\n\n![修复后](https://dzone.com/storage/temp/12481549-release.png)\n\n*修复后*\n\n最初进行调查时，真正的解决方案不是我们要注意的事情，而是通过检查内存转储并遵循证据我们最终到达那里。\n\n从此调查中可以汲取的教训是：\n\n- 内存转储不会说谎-如果内存泄漏，请先查看证据。\n- 微软已经开放了EF Core的源代码，所有问题在那里所有人都可以看到，对有需求的开发者来说非常方便。\n- 简单的代码更改（在这种情况下为一行）可能会产生巨大的影响。","slug":"技术/分析EFCore中的内存泄漏","published":1,"updated":"2020-04-22T14:57:45.196Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt7n0017n4vi7sojq6vh","content":"<h1 id=\"分析EFCore中的内存泄漏\"><a href=\"#分析EFCore中的内存泄漏\" class=\"headerlink\" title=\"分析EFCore中的内存泄漏\"></a>分析EFCore中的内存泄漏</h1><p> <img src=\"https://dzone.com/storage/temp/12517247-pic-fire-house-leaking-water-into-puddle.jpg\" alt=\"消防漏水入水坑\"> </p>\n<p>术语“内存泄漏”和“ .NET应用程序”不是经常一起使用。但是，我们最近在一个.NET Core Web应用程序中出现了一系列内存不足异常。事实证明，此问题是由Entity Framework Core中的行为更改引起的，尽管最终的解决方案非常简单，但实现该目标的过程既充满挑战又有趣。</p>\n<p>该系统本身托管在Azure中，由Angular SPA前端和后端的.NET Core API组成，使用Entity Framework Core与Azure SQL数据库进行通信。作为专门从事.NET开发的软件咨询公司，我们之前已经编写了许多类似的应用程序。因此<a href=\"https://dzone.com/articles/what-causes-outofmemoryerror\" target=\"_blank\" rel=\"noopener\">，内存不足崩溃</a>是无法预料的，因此我们立即知道这是需要认真对待的事情。使用Azure门户中的指标，我们可以看到内存使用率稳步上升，然后突然下降：此下降是应用程序崩溃。</p>\n<p><img src=\"https://dzone.com/storage/temp/12481545-before.png\" alt=\"修复之前\"></p>\n<p><em>修复之前</em></p>\n<p>因此，我们花了一些时间进行调查并逐步进行更改，以解决看似经典的内存泄漏问题。.NET泄漏的常见原因是未正确处理某些问题，在我们的案例中很可能是EF Core数据库上下文。因此，我们遍历了源代码，以寻找可能无法处理上下文的潜在原因。这变成了空白。</p>\n<p>我们将Entity Framework Core升级到了最新版本，因为最近的更新包括各种内存泄漏的修复程序和总体效率的提高。</p>\n<p>我们还在使用的Application Insights版本中发现了可能的内存泄漏（请参阅<a href=\"https://github.com/microsoft/ApplicationInsights-dotnet/issues/594），因此我们也对该软件包进行了升级。\" target=\"_blank\" rel=\"noopener\">https://github.com/microsoft/ApplicationInsights-dotnet/issues/594），因此我们也对该软件包进行了升级。</a></p>\n<p>这些都不能解决问题，因此我们解剖了从Azure应用服务中获取的内存转储（请参阅<a href=\"https://blogs.msdn.microsoft.com/jpsanders/2017/02/02/how-to-get-a-full-memory-dump-in-azure-app-services/）。\" target=\"_blank\" rel=\"noopener\">https://blogs.msdn.microsoft.com/jpsanders/2017/02/02/how-to-get-a-full-memory-dump-in-azure-app-services/）。</a></p>\n<p>我们注意到，绝大多数托管内存最终都由MemoryCache类使用。进一步深入研究表明，大多数缓存数据都是原始SQL查询的形式。我们看到大量的根本上是同一查询的事件被多次缓存，并且参数本身被硬编码在查询中而不是被参数化。</p>\n<p>例如，与其像这样缓存查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> TOP (<span class=\"number\">1</span>) UserId, FirstName, LastName, EmailAddress</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> <span class=\"keyword\">Users</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> UserId = @param_1</span><br></pre></td></tr></table></figure>\n\n<p>我们发现这样的多个查询：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT TOP (1) UserId, FirstName, LastName, EmailAddress</span><br><span class=\"line\">FROM Users</span><br><span class=\"line\">WHERE UserId = 5</span><br></pre></td></tr></table></figure>\n\n<p>因此，我们进行了一些搜索，寻找可能与之相关的EF核心问题，并遇到了这个问题：<a href=\"https://github.com/aspnet/EntityFrameworkCore/issues/10535\" target=\"_blank\" rel=\"noopener\">https</a> : <a href=\"https://github.com/aspnet/EntityFrameworkCore/issues/10535\" target=\"_blank\" rel=\"noopener\">//github.com/aspnet/EntityFrameworkCore/issues/10535</a>。</p>\n<p>关于这个问题的主题指出了这个问题：我们正在建立一个动态表达式树，并使用它  <code>Expressions.Expression.Constant</code> 来为where子句提供参数。使用常量表达式意味着Entity Framework Core不会参数化SQL查询，并且是Entity Framework 6的行为更改。</p>\n<p>我们到处都使用这个表达式树，通过它的ID来获取某些东西，这就是为什么它是一个很大的问题。</p>\n<p>因此，这就是我们所做的更改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Before</span><br><span class=\"line\">var param = Expressions.Expression.Parameter(typeof(T));</span><br><span class=\"line\">Expression = Expressions.Expression.Lambda&lt;Func&lt;T, bool&gt;&gt;(</span><br><span class=\"line\">  Expressions.Expression.Call(</span><br><span class=\"line\">    Expressions.Expression.Constant(valuesToFilter),</span><br><span class=\"line\">    &quot;Contains&quot;,</span><br><span class=\"line\">    Type.EmptyTypes,</span><br><span class=\"line\">    Expressions.Expression.Property(param, propertyName)),</span><br><span class=\"line\">  param);</span><br><span class=\"line\">// After</span><br><span class=\"line\">var param = Expressions.Expression.Parameter(typeof(T));</span><br><span class=\"line\">// This is what we added</span><br><span class=\"line\">Expression&lt;Func&lt;List&lt;int&gt;&gt;&gt; valuesToFilterLambda = () =&gt; valuesToFilter;</span><br><span class=\"line\">Expression = Expressions.Expression.Lambda&lt;Func&lt;T, bool&gt;&gt;(</span><br><span class=\"line\">  Expressions.Expression.Call(</span><br><span class=\"line\">    valuesToFilterLambda.Body,</span><br><span class=\"line\">    &quot;Contains&quot;,</span><br><span class=\"line\">    Type.EmptyTypes,</span><br><span class=\"line\">    Expressions.Expression.Property(param, propertyName)),</span><br><span class=\"line\">  param);</span><br></pre></td></tr></table></figure>\n\n<p>使用lambda表达式获取表达式主体会使<a href=\"https://dzone.com/articles/entity-framework-core-30-and-sql-server-2019-perfo\" target=\"_blank\" rel=\"noopener\">Entity Framework Core</a>对SQL查询进行参数化，因此仅缓存它的一个实例。</p>\n<p>这是包括修订版本在内的一段时间内的内存使用情况。该版本以红色标记，您可以看到差异很大。稳定的内存使用量从未超过200MB，而不断攀升至超过1GB，然后发生崩溃。</p>\n<p><img src=\"https://dzone.com/storage/temp/12481549-release.png\" alt=\"修复后\"></p>\n<p><em>修复后</em></p>\n<p>最初进行调查时，真正的解决方案不是我们要注意的事情，而是通过检查内存转储并遵循证据我们最终到达那里。</p>\n<p>从此调查中可以汲取的教训是：</p>\n<ul>\n<li>内存转储不会说谎-如果内存泄漏，请先查看证据。</li>\n<li>微软已经开放了EF Core的源代码，所有问题在那里所有人都可以看到，对有需求的开发者来说非常方便。</li>\n<li>简单的代码更改（在这种情况下为一行）可能会产生巨大的影响。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"分析EFCore中的内存泄漏\"><a href=\"#分析EFCore中的内存泄漏\" class=\"headerlink\" title=\"分析EFCore中的内存泄漏\"></a>分析EFCore中的内存泄漏</h1><p> <img src=\"https://dzone.com/storage/temp/12517247-pic-fire-house-leaking-water-into-puddle.jpg\" alt=\"消防漏水入水坑\"> </p>\n<p>术语“内存泄漏”和“ .NET应用程序”不是经常一起使用。但是，我们最近在一个.NET Core Web应用程序中出现了一系列内存不足异常。事实证明，此问题是由Entity Framework Core中的行为更改引起的，尽管最终的解决方案非常简单，但实现该目标的过程既充满挑战又有趣。</p>\n<p>该系统本身托管在Azure中，由Angular SPA前端和后端的.NET Core API组成，使用Entity Framework Core与Azure SQL数据库进行通信。作为专门从事.NET开发的软件咨询公司，我们之前已经编写了许多类似的应用程序。因此<a href=\"https://dzone.com/articles/what-causes-outofmemoryerror\" target=\"_blank\" rel=\"noopener\">，内存不足崩溃</a>是无法预料的，因此我们立即知道这是需要认真对待的事情。使用Azure门户中的指标，我们可以看到内存使用率稳步上升，然后突然下降：此下降是应用程序崩溃。</p>\n<p><img src=\"https://dzone.com/storage/temp/12481545-before.png\" alt=\"修复之前\"></p>\n<p><em>修复之前</em></p>\n<p>因此，我们花了一些时间进行调查并逐步进行更改，以解决看似经典的内存泄漏问题。.NET泄漏的常见原因是未正确处理某些问题，在我们的案例中很可能是EF Core数据库上下文。因此，我们遍历了源代码，以寻找可能无法处理上下文的潜在原因。这变成了空白。</p>\n<p>我们将Entity Framework Core升级到了最新版本，因为最近的更新包括各种内存泄漏的修复程序和总体效率的提高。</p>\n<p>我们还在使用的Application Insights版本中发现了可能的内存泄漏（请参阅<a href=\"https://github.com/microsoft/ApplicationInsights-dotnet/issues/594），因此我们也对该软件包进行了升级。\" target=\"_blank\" rel=\"noopener\">https://github.com/microsoft/ApplicationInsights-dotnet/issues/594），因此我们也对该软件包进行了升级。</a></p>\n<p>这些都不能解决问题，因此我们解剖了从Azure应用服务中获取的内存转储（请参阅<a href=\"https://blogs.msdn.microsoft.com/jpsanders/2017/02/02/how-to-get-a-full-memory-dump-in-azure-app-services/）。\" target=\"_blank\" rel=\"noopener\">https://blogs.msdn.microsoft.com/jpsanders/2017/02/02/how-to-get-a-full-memory-dump-in-azure-app-services/）。</a></p>\n<p>我们注意到，绝大多数托管内存最终都由MemoryCache类使用。进一步深入研究表明，大多数缓存数据都是原始SQL查询的形式。我们看到大量的根本上是同一查询的事件被多次缓存，并且参数本身被硬编码在查询中而不是被参数化。</p>\n<p>例如，与其像这样缓存查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> TOP (<span class=\"number\">1</span>) UserId, FirstName, LastName, EmailAddress</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> <span class=\"keyword\">Users</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> UserId = @param_1</span><br></pre></td></tr></table></figure>\n\n<p>我们发现这样的多个查询：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT TOP (1) UserId, FirstName, LastName, EmailAddress</span><br><span class=\"line\">FROM Users</span><br><span class=\"line\">WHERE UserId = 5</span><br></pre></td></tr></table></figure>\n\n<p>因此，我们进行了一些搜索，寻找可能与之相关的EF核心问题，并遇到了这个问题：<a href=\"https://github.com/aspnet/EntityFrameworkCore/issues/10535\" target=\"_blank\" rel=\"noopener\">https</a> : <a href=\"https://github.com/aspnet/EntityFrameworkCore/issues/10535\" target=\"_blank\" rel=\"noopener\">//github.com/aspnet/EntityFrameworkCore/issues/10535</a>。</p>\n<p>关于这个问题的主题指出了这个问题：我们正在建立一个动态表达式树，并使用它  <code>Expressions.Expression.Constant</code> 来为where子句提供参数。使用常量表达式意味着Entity Framework Core不会参数化SQL查询，并且是Entity Framework 6的行为更改。</p>\n<p>我们到处都使用这个表达式树，通过它的ID来获取某些东西，这就是为什么它是一个很大的问题。</p>\n<p>因此，这就是我们所做的更改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Before</span><br><span class=\"line\">var param = Expressions.Expression.Parameter(typeof(T));</span><br><span class=\"line\">Expression = Expressions.Expression.Lambda&lt;Func&lt;T, bool&gt;&gt;(</span><br><span class=\"line\">  Expressions.Expression.Call(</span><br><span class=\"line\">    Expressions.Expression.Constant(valuesToFilter),</span><br><span class=\"line\">    &quot;Contains&quot;,</span><br><span class=\"line\">    Type.EmptyTypes,</span><br><span class=\"line\">    Expressions.Expression.Property(param, propertyName)),</span><br><span class=\"line\">  param);</span><br><span class=\"line\">// After</span><br><span class=\"line\">var param = Expressions.Expression.Parameter(typeof(T));</span><br><span class=\"line\">// This is what we added</span><br><span class=\"line\">Expression&lt;Func&lt;List&lt;int&gt;&gt;&gt; valuesToFilterLambda = () =&gt; valuesToFilter;</span><br><span class=\"line\">Expression = Expressions.Expression.Lambda&lt;Func&lt;T, bool&gt;&gt;(</span><br><span class=\"line\">  Expressions.Expression.Call(</span><br><span class=\"line\">    valuesToFilterLambda.Body,</span><br><span class=\"line\">    &quot;Contains&quot;,</span><br><span class=\"line\">    Type.EmptyTypes,</span><br><span class=\"line\">    Expressions.Expression.Property(param, propertyName)),</span><br><span class=\"line\">  param);</span><br></pre></td></tr></table></figure>\n\n<p>使用lambda表达式获取表达式主体会使<a href=\"https://dzone.com/articles/entity-framework-core-30-and-sql-server-2019-perfo\" target=\"_blank\" rel=\"noopener\">Entity Framework Core</a>对SQL查询进行参数化，因此仅缓存它的一个实例。</p>\n<p>这是包括修订版本在内的一段时间内的内存使用情况。该版本以红色标记，您可以看到差异很大。稳定的内存使用量从未超过200MB，而不断攀升至超过1GB，然后发生崩溃。</p>\n<p><img src=\"https://dzone.com/storage/temp/12481549-release.png\" alt=\"修复后\"></p>\n<p><em>修复后</em></p>\n<p>最初进行调查时，真正的解决方案不是我们要注意的事情，而是通过检查内存转储并遵循证据我们最终到达那里。</p>\n<p>从此调查中可以汲取的教训是：</p>\n<ul>\n<li>内存转储不会说谎-如果内存泄漏，请先查看证据。</li>\n<li>微软已经开放了EF Core的源代码，所有问题在那里所有人都可以看到，对有需求的开发者来说非常方便。</li>\n<li>简单的代码更改（在这种情况下为一行）可能会产生巨大的影响。</li>\n</ul>\n"},{"title":"在C＃中使用RESTful API的几种好方法","date":"2020-04-28T15:28:00.000Z","author":"邹溪源","_content":"# 在C＃中使用RESTful API的几种好方法\n\n [Vladimir Pecanac](https://code-maze.com/author/codemaze_blog/) \n\n通过Web开发的路径，您发现自己迟早需要处理外部API（应用程序编程接口）。在本文中，我的目标是列出在C＃项目中使用RESTful API的方法的最全面列表，并通过一些简单示例向您展示如何做到这一点。\n\n阅读该文章后，您将更深入地了解可以使用哪些选项，以及下次需要使用[RESTful API](https://code-maze.com/ultimate-aspnet-core-3-web-api/)时如何选择正确的选项。\n\n## 什么是RESTful API？\n\n因此，在开始之前，您可能想知道[API](https://code-maze.com/ultimate-aspnet-core-3-web-api/)代表什么，以及RESTful的全部含义是什么？\n\n简而言之，API是软件应用程序之间的层。您可以将请求发送到[API](https://code-maze.com/ultimate-aspnet-core-3-web-api/)，并从中获得响应。API隐藏了软件应用程序具体实现的所有细节，并公开了您用于与该应用程序通信的接口。\n\n整个互联网是由API组成的大型蜘蛛网。我们使用API在应用程序之间通信和关联信息。我们有一个[API](https://code-maze.com/ultimate-aspnet-core-3-web-api/)，可以处理几乎所有内容。您每天使用的大多数服务都有自己的API（GoogleMaps，Facebook，Twitter，Instagram，天气门户…）\n\nRESTful部分意味着API是根据REST（表示状态传输）的原理和规则来实现的，REST是网络的基础架构原理。RESTful API在大多数情况下会返回纯文本，JSON或XML响应。更详细地解释REST不在本文的讨论范围之内，但是您可以在我们的文章[REST API最佳实践中](https://code-maze.com/top-rest-api-best-practices/)阅读有关REST的更多信息。\n\n## 如何使用RESTful API\n\n好吧，让我们进入整个故事中最重要的部分。\n\n有几种方法可以在C＃中使用RESTful API：\n\n- [**HttpWebRequest/Response Class**](https://code-maze.com/different-ways-consume-restful-api-csharp/#HttpWebRequest)\n- [**WebClient Class**](https://code-maze.com/different-ways-consume-restful-api-csharp/#webclient)\n- [**HttpClient Class**](https://code-maze.com/different-ways-consume-restful-api-csharp/#HttpClient)\n- [**RestSharp NuGet Package**](https://code-maze.com/different-ways-consume-restful-api-csharp/#RestSharp)\n- [**ServiceStack Http Utils**](https://code-maze.com/different-ways-consume-restful-api-csharp/#ServiceStack)\n- **[Flurl](https://code-maze.com/different-ways-consume-restful-api-csharp/#flurl)**\n- **[DalSoft.RestClient](https://code-maze.com/different-ways-consume-restful-api-csharp/#dalsoft)**\n\n这些中的每一个都有优点和缺点，因此让我们仔细研究它们，看看它们提供了什么。\n\n例如，我们将通过GitHub API收集有关RestSharp回购版本及其发布日期的信息。此信息是公开可用的，您可以在此处查看原始JSON响应的外观： [RestSharp版本](https://api.github.com/repos/restsharp/restsharp/releases)\n\n我们将利用Json.NET库的帮助来反序列化获得的响应。同样，对于某些示例，我们将使用库的内置反序列化机制。选择哪种方式取决于您，因为没有正确的方法。（您可以在[源代码中](https://github.com/CodeMazeBlog/ConsumeRestfulApisExamples)看到这两种机制的实现）。\n\n我期望通过接下来的几个示例得到一个反序列化`JArray`（为简单起见），其中包含RestSharp发布信息。之后，我们可以遍历它以获得以下结果。\n\n ![img](https://code-maze.com/wp-content/uploads/2017/06/RestSharp-releases.png) \n\n## HttpWebRequest / Response类\n\n这是`WebRequest` 类的特定于HTTP的实现，该实现最初用于处理HTTP请求，但已过时并由`WebClient`该类代替 。\n\n该`HttpWebRequest` 提供细粒度控制的要求制定过程的每一个环节。您可以想象，这可能是一把双刃剑，您很容易浪费大量时间来微调您的请求。另一方面，这可能正是您针对特定案例所需要的。\n\n`HttpWebRequest` 类不会阻止用户界面，也就是说，我相信您会同意这一点，这一点非常重要。\n\n`HttpWebResponse` 类为传入的响应提供了一个容器。\n\n这是有关如何使用这些类使用API的简单示例。\n\n```\npublic class HttpWebRequestHandler : IRequestHandler\n{\n    public string GetReleases(string url)\n    {\n        var request = (HttpWebRequest)WebRequest.Create(url);\n\n        request.Method = \"GET\";\n        request.UserAgent = RequestConstants.UserAgentValue;\n        request.AutomaticDecompression = DecompressionMethods.Deflate | DecompressionMethods.GZip;\n\n        var content = string.Empty;\n\n        using (var response = (HttpWebResponse)request.GetResponse())\n        {\n            using (var stream = response.GetResponseStream())\n            {\n                using (var sr = new StreamReader(stream))\n                {\n                    content = sr.ReadToEnd();\n                }\n            }\n        }\n\n        return content;\n    }\n}\n```\n\n 尽管是一个简单的示例，但是当您需要处理更复杂的方案（例如，发布表单信息，授权等）时，它会变得更加复杂。 \n\n## WebClient类别\n\n这个类对`HttpWebRequest`的包装。它通过`HttpWebRequest`从开发人员中提取的细节来简化流程。该代码更容易编写，并且您通过这种方式犯错误的可能性较小。如果您想编写更少的代码，而不用担心所有细节，并且执行速度是不重要的，请考虑使用`WebClient`class。\n\n这个示例应该使您大致了解`WebClient`与`HttpWebRequest`/ `HttpWebResponse`方法相比使用起来要容易得多。\n\n```\npublic string GetReleases(string url)\n{\n    var client = new WebClient();\n    client.Headers.Add(RequestConstants.UserAgent, RequestConstants.UserAgentValue);\n\n    var response = client.DownloadString(url);\n\n    return response;\n}\n```\n\n容易得多，对吗？\n\n除了其他`DownloadString`方法，`WebClient`类还提供了许多其他有用的方法，使我们的生活更轻松。我们可以轻松地使用它来操作字符串，文件或字节数组，并且价格比`HttpWebRequest`/ `HttpWebResponse`方法要慢几毫秒。\n\n无论是`HttpWebRequest`/ `HttpWebResponse`和`WebClient`类在旧版本的.NET可供选择。如果您对其他产品感兴趣，请务必查看[MSDN](https://msdn.microsoft.com/en-us/library/system.net.webclient(v=vs.110).aspx)`WebClient`。\n\n## HttpClient类\n\n`HttpClient` 是“新人”，它提供了旧库所缺乏的一些现代.NET功能。例如，您可以使用的单个实例发送多个请求`HttpClient`，它不绑定到特定的HTTP服务器或主机，而是使用async / await机制。\n\n您可以[在此视频中](https://channel9.msdn.com/Events/Build/2013/4-092)找到[使用HttpClient](https://channel9.msdn.com/Events/Build/2013/4-092)的[五个很好的理由](https://channel9.msdn.com/Events/Build/2013/4-092)：\n\n- 强类型标题。\n- 共享缓存，cookie和凭据\n- 访问cookie和共享cookie\n- 控制缓存和共享缓存。\n- 将您的代码模块注入ASP.NET管道。清洁和模块化的代码。\n\n`HttpClient`在我们的示例中，这是实际的：\n\n```\npublic string GetReleases(string url)\n{\n    using (var httpClient = new HttpClient())\n    {\n        httpClient.DefaultRequestHeaders.Add(RequestConstants.UserAgent, RequestConstants.UserAgentValue);\n\n        var response = httpClient.GetStringAsync(new Uri(url)).Result;\n\n        return response;\n    }\n}\n```\n\n为了简单起见，我同步实现了它。每个`HttpClient`方法都应异步使用，应该以这种方式使用。\n\n另外，我还要提到一件事。**是否`HttpClient`应该包装在using块中还是在应用程序级别上进行静态讨论。尽管它实现了`IDisposable`，但似乎通过将它包装在using块中，[会使应用程序出现故障并获得SocketException](https://aspnetmonsters.com/2016/08/2016-08-27-httpclientwrong/)。**而在ANKIT博客中，提供了基于[很多有利于静态初始化的](https://ankitvijay.net/2016/09/25/dispose-httpclient-or-have-a-static-instance/)的`HttpClient`性能测试结果是。**请务必阅读这些博客文章，**因为它们可以帮助您更了解该`HttpClient` 库的正确用法。（原文编写时间比较旧，在新版的.NET Core3.1中，相关问题已经解决）\n\n并且不要忘记，由于是新的，`HttpClient`是.NET 4.5以上版本才有，因此在某些旧项目中使用它可能会遇到麻烦。\n\n## RestSharp\n\nRestSharp是标准.NET库的OpenSource替代品，也是目前最酷的.NET库之一。它以NuGet软件包的形式提供，出于某些原因，您应该考虑尝试一下。\n\n就像`HttpClient`RestSharp 一样，它是一个现代而全面的库，易于使用且令人愉悦，同时仍支持旧版本的.NET Framework。它具有内置的[身份验证](https://github.com/restsharp/RestSharp/wiki/Authenticators)和[序列化/反序列化机制，](https://github.com/restsharp/RestSharp/wiki/Deserialization)但允许您使用自定义[机制](https://github.com/restsharp/RestSharp/wiki/Deserialization)覆盖它们。它[可跨平台使用，](https://github.com/restsharp/RestSharp/wiki/Cross-Platform-Support)并支持OAuth1，OAuth2，基本，NTLM和基于参数的身份验证。您可以选择同步或异步工作。该库还有很多其他功能，而这些只是它提供的众多好处中的一部分。有关RestSharp的用法和功能的详细信息，您可以访问[GitHub上](https://github.com/restsharp/RestSharp/wiki/Getting-Started)的RestSharp [页面](https://github.com/restsharp/RestSharp/wiki/Getting-Started)。\n\n现在，让我们尝试使用RestSharp get获取RestSharp版本的列表。\n\n```\npublic string GetReleases(string url)\n{\n    var client = new RestClient(url);\n\n    var response = client.Execute(new RestRequest());\n\n    return response.Content;\n}\n```\n\n很简单。RestSharp非常灵活，拥有使用RESTful API时几乎可以实现所有功能所需的所有工具。\n\n在此示例中要注意的一件事是，由于示例的一致性，我没有使用RestSharp的反序列化机制，这有点浪费，但是我鼓励您使用它，因为它确实非常容易和方便。因此，您可以轻松地制作一个这样的容器：\n\n```\npublic class GitHubRelease\n{\n    [JsonProperty(PropertyName = \"name\")]\n    public string Name { get; set; }\n    [JsonProperty(PropertyName = \"published_at\")]\n    public string PublishedAt { get; set; }\n}\n```\n\n 然后使用该`Execute`方法直接反序列化对该容器的响应。您可以仅添加所需的属性，并使用属性`JsonProperty`将它们映射到C＃属性（很好的触摸）。由于我们在响应中获得了发布列表，因此我们将`List` 用作包含类型。 \n\n```\npublic List<GitHubRelease> GetDeserializedReleases(string url)\n{\n    var client = new RestClient(url);\n\n    var response = client.Execute<List<GitHubRelease>>(new RestRequest());\n\n    return response.Data;\n}\n```\n\n一种非常直接而优雅的方式来获取我们的数据。\n\nRestSharp不仅具有发送`GET`请求的功能，还可以自己探索并观察它的酷炫之处。\n\n在RestSharp案例中要补充的最后一点是，其存储库需要维护者。如果您想了解更多有关这个很棒的库的信息，我敦促您前往[RestSharp存储库](https://github.com/restsharp/RestSharp)，帮助该项目继续发展并变得更好。\n\n## ServiceStack Http实用程序\n\n另一个库，但与RestSharp不同，ServiceStack似乎得到了适当维护，并与现代[API](https://code-maze.com/ultimate-aspnet-core-3-web-api/)趋势保持同步。ServiceStack功能列表令人印象深刻，并且肯定具有各种应用程序。\n\n在这里对我们最有用的是演示如何使用外部RESTful API。ServiceStack具有一种专门的方式来处理称为[Http Utils的](http://docs.servicestack.net/http-utils)第三方HTTP API 。\n\n让我们看看如何首先使用Json.NET解析器来获取RestSharp版本是如何使用ServiceStack Http Utils。\n\n```\npublic string GetReleases(string url)\n{\n    var response = url.GetJsonFromUrl(webReq =>\n    {\n        webReq.UserAgent = RequestConstants.UserAgentValue;\n    });\n\n    return response;\n}\n```\n\n 您还可以选择将其留给ServiceStack解析器。我们可以重用本文前面定义的`Release`类 。 \n\n```\npublic List<GitHubRelease> GetDeserializedReleases(string url)\n{\n    var releases = url.GetJsonFromUrl(webReq =>\n    {\n        webReq.UserAgent = RequestConstants.UserAgentValue;\n    }).FromJson<List<GitHubRelease>>();\n\n    return releases;\n}\n```\n\n如您所见，无论哪种方式都可以正常工作，并且您可以选择是获取字符串响应还是立即反序列化它。\n\n尽管ServiceStack是我们偶然发现的最后一个库，但令我感到惊讶的是，它使用起来如此容易，而且我认为它将来可能成为我处理API和服务的首选工具。\n\n## Flurl\n\n评论库中许多人要求的图书馆之一，并在Internet上受到许多人的喜爱，但仍吸引着人们。\n\nFlurl代表Fluent Url Builder，这是库构建其查询的方式。对于不熟悉flurl的做事方式的人来说，flurl只是意味着库的构建方式是将方法链接在一起以实现更高的可读性，类似于人类语言。\n\n为了使事情更容易理解，让我们举一些例子（这个例子来自官方文档）：\n\n```\n// Flurl will use 1 HttpClient instance per host\nvar person = await \"https://api.com\"\n    .AppendPathSegment(\"person\")\n    .SetQueryParams(new { a = 1, b = 2 })\n    .WithOAuthBearerToken(\"my_oauth_token\")\n    .PostJsonAsync(new\n    {\n        first_name = \"Claire\",\n        last_name = \"Underwood\"\n    })\n    .ReceiveJson<Person>();\n```\n\n您可以看到方法如何链接在一起以完成“句子”。\n\n在后台，Flurl使用HttpClient或通过自己的语法糖增强HttpClient库。因此，这意味着Flurl是一个异步库，因此请牢记这一点。\n\n与其他高级库一样，我们可以通过两种不同的方式来做到这一点：\n\n```\npublic string GetReleases(string url)\n{\n    var result = url\n        .WithHeader(RequestConstants.UserAgent, RequestConstants.UserAgentValue)\n        .GetJsonAsync<List<GitHubRelease>>()\n        .Result;\n\n    return JsonConvert.SerializeObject(result);\n}\n```\n\n这种方式相当糟糕，因为我们只是序列化结果，以便稍后对其进行反序列化。如果您使用的是Flurl之类的库，则不应以这种方式进行操作。\n\n更好的做事方式是：\n\n```\npublic List<GitHubRelease> GetDeserializedReleases(string url)\n{\n    var result = url\n        .WithHeader(RequestConstants.UserAgent, RequestConstants.UserAgentValue)\n        .GetJsonAsync<List<GitHubRelease>>()\n        .Result;\n\n    return result;\n}\n```\n\n 随着`.Result`我们强迫代码的同步行为。使用Flurl的实际和预期方式如下所示： \n\n```\npublic async Task<List<GitHubRelease>> GetDeserializedReleases(string url)\n{\n    var result = await url\n        .WithHeader(RequestConstants.UserAgent, RequestConstants.UserAgentValue)\n        .GetJsonAsync<List<GitHubRelease>>();\n\n    return result;\n}\n```\n\n这展示了Flurl库的全部潜力。\n\n如果您想了解更多有关如何在不同的现实生活场景使用Flurl，看看我们的 [消费GitHub的API（REST）随着](https://code-maze.com/consuming-github-api-rest-with-flurl/)[Flurl](https://code-maze.com/wp-admin/post.php?post=4822&action=edit) 文章\n\n总而言之，它就像广告一样：易于使用，现代，可读性和可测试性。您对这个库还有什么期望？要开源？[签](https://github.com/tmenier/Flurl)出： [Flurl存储库](https://github.com/tmenier/Flurl)，如果您愿意，可以贡献自己的力量！\n\n## DalSoft.RestClient\n\n现在，此列表与该列表中的任何内容都有些不同。但这一点有所不同。\n\n让我们看看如何使用DalSoft.RestClient来使用GitHub API，然后谈论我们已完成的工作。\n\n首先，您可以通过输入以下内容，通过NuGet软件包管理器下载DalSoft.RestClient： `Install-Package DalSoft.RestClient`\n\n或通过.NET Core CLI： `dotnet add package DalSoft.RestClient`\n\n两种方法都可以。\n\n拥有图书馆后，我们可以执行以下操作：\n\n```\npublic string GetReleases(string url)\n{\n    dynamic client = new RestClient(RequestConstants.BaseUrl,\n        new Headers { { RequestConstants.UserAgent, RequestConstants.UserAgentValue } });\n\n    var response = client.repos.restsharp.restsharp.releases.Get().Result.ToString();\n\n    return response;\n}\n```\n\n 或最好使用DalSoft.RestClient在充分利用其功能的同时立即反序列化响应： \n\n```\npublic async Task<List<GitHubRelease>> GetDeserializedReleases(string url)\n{\n    dynamic client = new RestClient(RequestConstants.BaseUrl,\n        new Headers { { RequestConstants.UserAgent, RequestConstants.UserAgentValue } });\n\n    var response = await client.repos.restsharp.restsharp.releases.Get();\n\n    return response;\n}\n```\n\n因此，让我们稍微讨论一下这些例子。\n\n乍一看，它似乎并不比我们使用的其他一些现代库简单得多。\n\n但这归结为形成请求的方式，那就是利用RestClient的动态特性。例如，我们的BaseUrl是`https://api.github.com` ，我们需要进入`https://api.github.com/repos/restsharp/restsharp/releases`。我们可以通过动态创建客户端，然后通过链接Url的“部分”来形成Url来做到这一点：\n\n```\nawait client.repos.restsharp.restsharp.releases.Get();\n```\n\n形成请求的一种非常独特的方法。还有一个非常灵活的！\n\n因此，一旦我们设置了基本的网址，就可以轻松地使用不同的端点。\n\n还值得一提的是，我们得到的JSON响应会自动进行类型转换。如您在第二个示例中看到的那样，我们方法的返回值是`Task>.` So，该库足够聪明，可以将响应转换为我们的类型（依赖于Json.NET）。这使我们的生活更加轻松。\n\n除了易于理解和使用之外，DalSoft.RestClient还具有现代库应具备的所有功能。它是可**配置的，异步的，可扩展的，可测试的，并且支持多个平台**。\n\n我们仅演示了DalSoft.RestClient功能的一小部分。如果您对使用DalSoft.RestClient感兴趣，请转至[我们的文章，](https://code-maze.com/dalsoft-restclient-consume-any-rest-api/)以学习如何在不同情况下使用它，或参阅 [GitHub官方仓库](https://github.com/DalSoft/DalSoft.RestClient)和[文档](https://restclient.dalsoft.io/)。\n\n## 其他选择\n\n对于您的特定问题，还有许多其他选项可用。您可以使用任何这些库来使用特定的RESTful API。例如，[octokit.net专门 ](https://github.com/octokit/octokit.net)用于GitHub API，[Facebook SDK](https://github.com/facebook-csharp-sdk/facebook-csharp-sdk) 用于使用Facebook API，并且还有许多其他功能可用于任何用途。\n\n虽然这些库是专门为这些API而设计的，并且可能擅长于它们的用途，但它们的用途是有限的，因为您经常需要在应用程序中连接多个[API](https://code-maze.com/ultimate-aspnet-core-3-web-api/)。这可能会导致每个实现都有不同的实现方式，以及更多的依赖关系，这可能导致重复并且容易出错。库越具体，其灵活性就越差。\n\n## GitHub上的源代码\n\n[GitHub上的源代码](https://github.com/CodeMazeBlog/ConsumeRestfulApisExamples)\n\n## 结论\n\n因此，总而言之，我们已经讨论了可用于使用RESTful API的不同工具。我们已经提到了一些.NET库，可以这样做`HttpWebRequest`，`WebClient`和`HttpClient`，以及一些惊人的第三方工具，如RestSharp和ServiceStack。您还对这些工具进行了简短的介绍，并给出了一些非常简单的示例来向您展示如何开始使用它们。\n\n我认为您现在至少有95％准备使用一些REST。继续展开翅膀，探索并找到更多有趣且有趣的方式来使用和连接不同的API。","source":"_posts/技术/在C＃中使用RESTful API的几种好方法.md","raw":"---\ntitle:  在C＃中使用RESTful API的几种好方法\ndate: 2020-04-28 23:28\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n# 在C＃中使用RESTful API的几种好方法\n\n [Vladimir Pecanac](https://code-maze.com/author/codemaze_blog/) \n\n通过Web开发的路径，您发现自己迟早需要处理外部API（应用程序编程接口）。在本文中，我的目标是列出在C＃项目中使用RESTful API的方法的最全面列表，并通过一些简单示例向您展示如何做到这一点。\n\n阅读该文章后，您将更深入地了解可以使用哪些选项，以及下次需要使用[RESTful API](https://code-maze.com/ultimate-aspnet-core-3-web-api/)时如何选择正确的选项。\n\n## 什么是RESTful API？\n\n因此，在开始之前，您可能想知道[API](https://code-maze.com/ultimate-aspnet-core-3-web-api/)代表什么，以及RESTful的全部含义是什么？\n\n简而言之，API是软件应用程序之间的层。您可以将请求发送到[API](https://code-maze.com/ultimate-aspnet-core-3-web-api/)，并从中获得响应。API隐藏了软件应用程序具体实现的所有细节，并公开了您用于与该应用程序通信的接口。\n\n整个互联网是由API组成的大型蜘蛛网。我们使用API在应用程序之间通信和关联信息。我们有一个[API](https://code-maze.com/ultimate-aspnet-core-3-web-api/)，可以处理几乎所有内容。您每天使用的大多数服务都有自己的API（GoogleMaps，Facebook，Twitter，Instagram，天气门户…）\n\nRESTful部分意味着API是根据REST（表示状态传输）的原理和规则来实现的，REST是网络的基础架构原理。RESTful API在大多数情况下会返回纯文本，JSON或XML响应。更详细地解释REST不在本文的讨论范围之内，但是您可以在我们的文章[REST API最佳实践中](https://code-maze.com/top-rest-api-best-practices/)阅读有关REST的更多信息。\n\n## 如何使用RESTful API\n\n好吧，让我们进入整个故事中最重要的部分。\n\n有几种方法可以在C＃中使用RESTful API：\n\n- [**HttpWebRequest/Response Class**](https://code-maze.com/different-ways-consume-restful-api-csharp/#HttpWebRequest)\n- [**WebClient Class**](https://code-maze.com/different-ways-consume-restful-api-csharp/#webclient)\n- [**HttpClient Class**](https://code-maze.com/different-ways-consume-restful-api-csharp/#HttpClient)\n- [**RestSharp NuGet Package**](https://code-maze.com/different-ways-consume-restful-api-csharp/#RestSharp)\n- [**ServiceStack Http Utils**](https://code-maze.com/different-ways-consume-restful-api-csharp/#ServiceStack)\n- **[Flurl](https://code-maze.com/different-ways-consume-restful-api-csharp/#flurl)**\n- **[DalSoft.RestClient](https://code-maze.com/different-ways-consume-restful-api-csharp/#dalsoft)**\n\n这些中的每一个都有优点和缺点，因此让我们仔细研究它们，看看它们提供了什么。\n\n例如，我们将通过GitHub API收集有关RestSharp回购版本及其发布日期的信息。此信息是公开可用的，您可以在此处查看原始JSON响应的外观： [RestSharp版本](https://api.github.com/repos/restsharp/restsharp/releases)\n\n我们将利用Json.NET库的帮助来反序列化获得的响应。同样，对于某些示例，我们将使用库的内置反序列化机制。选择哪种方式取决于您，因为没有正确的方法。（您可以在[源代码中](https://github.com/CodeMazeBlog/ConsumeRestfulApisExamples)看到这两种机制的实现）。\n\n我期望通过接下来的几个示例得到一个反序列化`JArray`（为简单起见），其中包含RestSharp发布信息。之后，我们可以遍历它以获得以下结果。\n\n ![img](https://code-maze.com/wp-content/uploads/2017/06/RestSharp-releases.png) \n\n## HttpWebRequest / Response类\n\n这是`WebRequest` 类的特定于HTTP的实现，该实现最初用于处理HTTP请求，但已过时并由`WebClient`该类代替 。\n\n该`HttpWebRequest` 提供细粒度控制的要求制定过程的每一个环节。您可以想象，这可能是一把双刃剑，您很容易浪费大量时间来微调您的请求。另一方面，这可能正是您针对特定案例所需要的。\n\n`HttpWebRequest` 类不会阻止用户界面，也就是说，我相信您会同意这一点，这一点非常重要。\n\n`HttpWebResponse` 类为传入的响应提供了一个容器。\n\n这是有关如何使用这些类使用API的简单示例。\n\n```\npublic class HttpWebRequestHandler : IRequestHandler\n{\n    public string GetReleases(string url)\n    {\n        var request = (HttpWebRequest)WebRequest.Create(url);\n\n        request.Method = \"GET\";\n        request.UserAgent = RequestConstants.UserAgentValue;\n        request.AutomaticDecompression = DecompressionMethods.Deflate | DecompressionMethods.GZip;\n\n        var content = string.Empty;\n\n        using (var response = (HttpWebResponse)request.GetResponse())\n        {\n            using (var stream = response.GetResponseStream())\n            {\n                using (var sr = new StreamReader(stream))\n                {\n                    content = sr.ReadToEnd();\n                }\n            }\n        }\n\n        return content;\n    }\n}\n```\n\n 尽管是一个简单的示例，但是当您需要处理更复杂的方案（例如，发布表单信息，授权等）时，它会变得更加复杂。 \n\n## WebClient类别\n\n这个类对`HttpWebRequest`的包装。它通过`HttpWebRequest`从开发人员中提取的细节来简化流程。该代码更容易编写，并且您通过这种方式犯错误的可能性较小。如果您想编写更少的代码，而不用担心所有细节，并且执行速度是不重要的，请考虑使用`WebClient`class。\n\n这个示例应该使您大致了解`WebClient`与`HttpWebRequest`/ `HttpWebResponse`方法相比使用起来要容易得多。\n\n```\npublic string GetReleases(string url)\n{\n    var client = new WebClient();\n    client.Headers.Add(RequestConstants.UserAgent, RequestConstants.UserAgentValue);\n\n    var response = client.DownloadString(url);\n\n    return response;\n}\n```\n\n容易得多，对吗？\n\n除了其他`DownloadString`方法，`WebClient`类还提供了许多其他有用的方法，使我们的生活更轻松。我们可以轻松地使用它来操作字符串，文件或字节数组，并且价格比`HttpWebRequest`/ `HttpWebResponse`方法要慢几毫秒。\n\n无论是`HttpWebRequest`/ `HttpWebResponse`和`WebClient`类在旧版本的.NET可供选择。如果您对其他产品感兴趣，请务必查看[MSDN](https://msdn.microsoft.com/en-us/library/system.net.webclient(v=vs.110).aspx)`WebClient`。\n\n## HttpClient类\n\n`HttpClient` 是“新人”，它提供了旧库所缺乏的一些现代.NET功能。例如，您可以使用的单个实例发送多个请求`HttpClient`，它不绑定到特定的HTTP服务器或主机，而是使用async / await机制。\n\n您可以[在此视频中](https://channel9.msdn.com/Events/Build/2013/4-092)找到[使用HttpClient](https://channel9.msdn.com/Events/Build/2013/4-092)的[五个很好的理由](https://channel9.msdn.com/Events/Build/2013/4-092)：\n\n- 强类型标题。\n- 共享缓存，cookie和凭据\n- 访问cookie和共享cookie\n- 控制缓存和共享缓存。\n- 将您的代码模块注入ASP.NET管道。清洁和模块化的代码。\n\n`HttpClient`在我们的示例中，这是实际的：\n\n```\npublic string GetReleases(string url)\n{\n    using (var httpClient = new HttpClient())\n    {\n        httpClient.DefaultRequestHeaders.Add(RequestConstants.UserAgent, RequestConstants.UserAgentValue);\n\n        var response = httpClient.GetStringAsync(new Uri(url)).Result;\n\n        return response;\n    }\n}\n```\n\n为了简单起见，我同步实现了它。每个`HttpClient`方法都应异步使用，应该以这种方式使用。\n\n另外，我还要提到一件事。**是否`HttpClient`应该包装在using块中还是在应用程序级别上进行静态讨论。尽管它实现了`IDisposable`，但似乎通过将它包装在using块中，[会使应用程序出现故障并获得SocketException](https://aspnetmonsters.com/2016/08/2016-08-27-httpclientwrong/)。**而在ANKIT博客中，提供了基于[很多有利于静态初始化的](https://ankitvijay.net/2016/09/25/dispose-httpclient-or-have-a-static-instance/)的`HttpClient`性能测试结果是。**请务必阅读这些博客文章，**因为它们可以帮助您更了解该`HttpClient` 库的正确用法。（原文编写时间比较旧，在新版的.NET Core3.1中，相关问题已经解决）\n\n并且不要忘记，由于是新的，`HttpClient`是.NET 4.5以上版本才有，因此在某些旧项目中使用它可能会遇到麻烦。\n\n## RestSharp\n\nRestSharp是标准.NET库的OpenSource替代品，也是目前最酷的.NET库之一。它以NuGet软件包的形式提供，出于某些原因，您应该考虑尝试一下。\n\n就像`HttpClient`RestSharp 一样，它是一个现代而全面的库，易于使用且令人愉悦，同时仍支持旧版本的.NET Framework。它具有内置的[身份验证](https://github.com/restsharp/RestSharp/wiki/Authenticators)和[序列化/反序列化机制，](https://github.com/restsharp/RestSharp/wiki/Deserialization)但允许您使用自定义[机制](https://github.com/restsharp/RestSharp/wiki/Deserialization)覆盖它们。它[可跨平台使用，](https://github.com/restsharp/RestSharp/wiki/Cross-Platform-Support)并支持OAuth1，OAuth2，基本，NTLM和基于参数的身份验证。您可以选择同步或异步工作。该库还有很多其他功能，而这些只是它提供的众多好处中的一部分。有关RestSharp的用法和功能的详细信息，您可以访问[GitHub上](https://github.com/restsharp/RestSharp/wiki/Getting-Started)的RestSharp [页面](https://github.com/restsharp/RestSharp/wiki/Getting-Started)。\n\n现在，让我们尝试使用RestSharp get获取RestSharp版本的列表。\n\n```\npublic string GetReleases(string url)\n{\n    var client = new RestClient(url);\n\n    var response = client.Execute(new RestRequest());\n\n    return response.Content;\n}\n```\n\n很简单。RestSharp非常灵活，拥有使用RESTful API时几乎可以实现所有功能所需的所有工具。\n\n在此示例中要注意的一件事是，由于示例的一致性，我没有使用RestSharp的反序列化机制，这有点浪费，但是我鼓励您使用它，因为它确实非常容易和方便。因此，您可以轻松地制作一个这样的容器：\n\n```\npublic class GitHubRelease\n{\n    [JsonProperty(PropertyName = \"name\")]\n    public string Name { get; set; }\n    [JsonProperty(PropertyName = \"published_at\")]\n    public string PublishedAt { get; set; }\n}\n```\n\n 然后使用该`Execute`方法直接反序列化对该容器的响应。您可以仅添加所需的属性，并使用属性`JsonProperty`将它们映射到C＃属性（很好的触摸）。由于我们在响应中获得了发布列表，因此我们将`List` 用作包含类型。 \n\n```\npublic List<GitHubRelease> GetDeserializedReleases(string url)\n{\n    var client = new RestClient(url);\n\n    var response = client.Execute<List<GitHubRelease>>(new RestRequest());\n\n    return response.Data;\n}\n```\n\n一种非常直接而优雅的方式来获取我们的数据。\n\nRestSharp不仅具有发送`GET`请求的功能，还可以自己探索并观察它的酷炫之处。\n\n在RestSharp案例中要补充的最后一点是，其存储库需要维护者。如果您想了解更多有关这个很棒的库的信息，我敦促您前往[RestSharp存储库](https://github.com/restsharp/RestSharp)，帮助该项目继续发展并变得更好。\n\n## ServiceStack Http实用程序\n\n另一个库，但与RestSharp不同，ServiceStack似乎得到了适当维护，并与现代[API](https://code-maze.com/ultimate-aspnet-core-3-web-api/)趋势保持同步。ServiceStack功能列表令人印象深刻，并且肯定具有各种应用程序。\n\n在这里对我们最有用的是演示如何使用外部RESTful API。ServiceStack具有一种专门的方式来处理称为[Http Utils的](http://docs.servicestack.net/http-utils)第三方HTTP API 。\n\n让我们看看如何首先使用Json.NET解析器来获取RestSharp版本是如何使用ServiceStack Http Utils。\n\n```\npublic string GetReleases(string url)\n{\n    var response = url.GetJsonFromUrl(webReq =>\n    {\n        webReq.UserAgent = RequestConstants.UserAgentValue;\n    });\n\n    return response;\n}\n```\n\n 您还可以选择将其留给ServiceStack解析器。我们可以重用本文前面定义的`Release`类 。 \n\n```\npublic List<GitHubRelease> GetDeserializedReleases(string url)\n{\n    var releases = url.GetJsonFromUrl(webReq =>\n    {\n        webReq.UserAgent = RequestConstants.UserAgentValue;\n    }).FromJson<List<GitHubRelease>>();\n\n    return releases;\n}\n```\n\n如您所见，无论哪种方式都可以正常工作，并且您可以选择是获取字符串响应还是立即反序列化它。\n\n尽管ServiceStack是我们偶然发现的最后一个库，但令我感到惊讶的是，它使用起来如此容易，而且我认为它将来可能成为我处理API和服务的首选工具。\n\n## Flurl\n\n评论库中许多人要求的图书馆之一，并在Internet上受到许多人的喜爱，但仍吸引着人们。\n\nFlurl代表Fluent Url Builder，这是库构建其查询的方式。对于不熟悉flurl的做事方式的人来说，flurl只是意味着库的构建方式是将方法链接在一起以实现更高的可读性，类似于人类语言。\n\n为了使事情更容易理解，让我们举一些例子（这个例子来自官方文档）：\n\n```\n// Flurl will use 1 HttpClient instance per host\nvar person = await \"https://api.com\"\n    .AppendPathSegment(\"person\")\n    .SetQueryParams(new { a = 1, b = 2 })\n    .WithOAuthBearerToken(\"my_oauth_token\")\n    .PostJsonAsync(new\n    {\n        first_name = \"Claire\",\n        last_name = \"Underwood\"\n    })\n    .ReceiveJson<Person>();\n```\n\n您可以看到方法如何链接在一起以完成“句子”。\n\n在后台，Flurl使用HttpClient或通过自己的语法糖增强HttpClient库。因此，这意味着Flurl是一个异步库，因此请牢记这一点。\n\n与其他高级库一样，我们可以通过两种不同的方式来做到这一点：\n\n```\npublic string GetReleases(string url)\n{\n    var result = url\n        .WithHeader(RequestConstants.UserAgent, RequestConstants.UserAgentValue)\n        .GetJsonAsync<List<GitHubRelease>>()\n        .Result;\n\n    return JsonConvert.SerializeObject(result);\n}\n```\n\n这种方式相当糟糕，因为我们只是序列化结果，以便稍后对其进行反序列化。如果您使用的是Flurl之类的库，则不应以这种方式进行操作。\n\n更好的做事方式是：\n\n```\npublic List<GitHubRelease> GetDeserializedReleases(string url)\n{\n    var result = url\n        .WithHeader(RequestConstants.UserAgent, RequestConstants.UserAgentValue)\n        .GetJsonAsync<List<GitHubRelease>>()\n        .Result;\n\n    return result;\n}\n```\n\n 随着`.Result`我们强迫代码的同步行为。使用Flurl的实际和预期方式如下所示： \n\n```\npublic async Task<List<GitHubRelease>> GetDeserializedReleases(string url)\n{\n    var result = await url\n        .WithHeader(RequestConstants.UserAgent, RequestConstants.UserAgentValue)\n        .GetJsonAsync<List<GitHubRelease>>();\n\n    return result;\n}\n```\n\n这展示了Flurl库的全部潜力。\n\n如果您想了解更多有关如何在不同的现实生活场景使用Flurl，看看我们的 [消费GitHub的API（REST）随着](https://code-maze.com/consuming-github-api-rest-with-flurl/)[Flurl](https://code-maze.com/wp-admin/post.php?post=4822&action=edit) 文章\n\n总而言之，它就像广告一样：易于使用，现代，可读性和可测试性。您对这个库还有什么期望？要开源？[签](https://github.com/tmenier/Flurl)出： [Flurl存储库](https://github.com/tmenier/Flurl)，如果您愿意，可以贡献自己的力量！\n\n## DalSoft.RestClient\n\n现在，此列表与该列表中的任何内容都有些不同。但这一点有所不同。\n\n让我们看看如何使用DalSoft.RestClient来使用GitHub API，然后谈论我们已完成的工作。\n\n首先，您可以通过输入以下内容，通过NuGet软件包管理器下载DalSoft.RestClient： `Install-Package DalSoft.RestClient`\n\n或通过.NET Core CLI： `dotnet add package DalSoft.RestClient`\n\n两种方法都可以。\n\n拥有图书馆后，我们可以执行以下操作：\n\n```\npublic string GetReleases(string url)\n{\n    dynamic client = new RestClient(RequestConstants.BaseUrl,\n        new Headers { { RequestConstants.UserAgent, RequestConstants.UserAgentValue } });\n\n    var response = client.repos.restsharp.restsharp.releases.Get().Result.ToString();\n\n    return response;\n}\n```\n\n 或最好使用DalSoft.RestClient在充分利用其功能的同时立即反序列化响应： \n\n```\npublic async Task<List<GitHubRelease>> GetDeserializedReleases(string url)\n{\n    dynamic client = new RestClient(RequestConstants.BaseUrl,\n        new Headers { { RequestConstants.UserAgent, RequestConstants.UserAgentValue } });\n\n    var response = await client.repos.restsharp.restsharp.releases.Get();\n\n    return response;\n}\n```\n\n因此，让我们稍微讨论一下这些例子。\n\n乍一看，它似乎并不比我们使用的其他一些现代库简单得多。\n\n但这归结为形成请求的方式，那就是利用RestClient的动态特性。例如，我们的BaseUrl是`https://api.github.com` ，我们需要进入`https://api.github.com/repos/restsharp/restsharp/releases`。我们可以通过动态创建客户端，然后通过链接Url的“部分”来形成Url来做到这一点：\n\n```\nawait client.repos.restsharp.restsharp.releases.Get();\n```\n\n形成请求的一种非常独特的方法。还有一个非常灵活的！\n\n因此，一旦我们设置了基本的网址，就可以轻松地使用不同的端点。\n\n还值得一提的是，我们得到的JSON响应会自动进行类型转换。如您在第二个示例中看到的那样，我们方法的返回值是`Task>.` So，该库足够聪明，可以将响应转换为我们的类型（依赖于Json.NET）。这使我们的生活更加轻松。\n\n除了易于理解和使用之外，DalSoft.RestClient还具有现代库应具备的所有功能。它是可**配置的，异步的，可扩展的，可测试的，并且支持多个平台**。\n\n我们仅演示了DalSoft.RestClient功能的一小部分。如果您对使用DalSoft.RestClient感兴趣，请转至[我们的文章，](https://code-maze.com/dalsoft-restclient-consume-any-rest-api/)以学习如何在不同情况下使用它，或参阅 [GitHub官方仓库](https://github.com/DalSoft/DalSoft.RestClient)和[文档](https://restclient.dalsoft.io/)。\n\n## 其他选择\n\n对于您的特定问题，还有许多其他选项可用。您可以使用任何这些库来使用特定的RESTful API。例如，[octokit.net专门 ](https://github.com/octokit/octokit.net)用于GitHub API，[Facebook SDK](https://github.com/facebook-csharp-sdk/facebook-csharp-sdk) 用于使用Facebook API，并且还有许多其他功能可用于任何用途。\n\n虽然这些库是专门为这些API而设计的，并且可能擅长于它们的用途，但它们的用途是有限的，因为您经常需要在应用程序中连接多个[API](https://code-maze.com/ultimate-aspnet-core-3-web-api/)。这可能会导致每个实现都有不同的实现方式，以及更多的依赖关系，这可能导致重复并且容易出错。库越具体，其灵活性就越差。\n\n## GitHub上的源代码\n\n[GitHub上的源代码](https://github.com/CodeMazeBlog/ConsumeRestfulApisExamples)\n\n## 结论\n\n因此，总而言之，我们已经讨论了可用于使用RESTful API的不同工具。我们已经提到了一些.NET库，可以这样做`HttpWebRequest`，`WebClient`和`HttpClient`，以及一些惊人的第三方工具，如RestSharp和ServiceStack。您还对这些工具进行了简短的介绍，并给出了一些非常简单的示例来向您展示如何开始使用它们。\n\n我认为您现在至少有95％准备使用一些REST。继续展开翅膀，探索并找到更多有趣且有趣的方式来使用和连接不同的API。","slug":"技术/在C＃中使用RESTful API的几种好方法","published":1,"updated":"2020-05-26T11:10:12.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt7p001an4vikdrwcvmj","content":"<h1 id=\"在C＃中使用RESTful-API的几种好方法\"><a href=\"#在C＃中使用RESTful-API的几种好方法\" class=\"headerlink\" title=\"在C＃中使用RESTful API的几种好方法\"></a>在C＃中使用RESTful API的几种好方法</h1><p> <a href=\"https://code-maze.com/author/codemaze_blog/\" target=\"_blank\" rel=\"noopener\">Vladimir Pecanac</a> </p>\n<p>通过Web开发的路径，您发现自己迟早需要处理外部API（应用程序编程接口）。在本文中，我的目标是列出在C＃项目中使用RESTful API的方法的最全面列表，并通过一些简单示例向您展示如何做到这一点。</p>\n<p>阅读该文章后，您将更深入地了解可以使用哪些选项，以及下次需要使用<a href=\"https://code-maze.com/ultimate-aspnet-core-3-web-api/\" target=\"_blank\" rel=\"noopener\">RESTful API</a>时如何选择正确的选项。</p>\n<h2 id=\"什么是RESTful-API？\"><a href=\"#什么是RESTful-API？\" class=\"headerlink\" title=\"什么是RESTful API？\"></a>什么是RESTful API？</h2><p>因此，在开始之前，您可能想知道<a href=\"https://code-maze.com/ultimate-aspnet-core-3-web-api/\" target=\"_blank\" rel=\"noopener\">API</a>代表什么，以及RESTful的全部含义是什么？</p>\n<p>简而言之，API是软件应用程序之间的层。您可以将请求发送到<a href=\"https://code-maze.com/ultimate-aspnet-core-3-web-api/\" target=\"_blank\" rel=\"noopener\">API</a>，并从中获得响应。API隐藏了软件应用程序具体实现的所有细节，并公开了您用于与该应用程序通信的接口。</p>\n<p>整个互联网是由API组成的大型蜘蛛网。我们使用API在应用程序之间通信和关联信息。我们有一个<a href=\"https://code-maze.com/ultimate-aspnet-core-3-web-api/\" target=\"_blank\" rel=\"noopener\">API</a>，可以处理几乎所有内容。您每天使用的大多数服务都有自己的API（GoogleMaps，Facebook，Twitter，Instagram，天气门户…）</p>\n<p>RESTful部分意味着API是根据REST（表示状态传输）的原理和规则来实现的，REST是网络的基础架构原理。RESTful API在大多数情况下会返回纯文本，JSON或XML响应。更详细地解释REST不在本文的讨论范围之内，但是您可以在我们的文章<a href=\"https://code-maze.com/top-rest-api-best-practices/\" target=\"_blank\" rel=\"noopener\">REST API最佳实践中</a>阅读有关REST的更多信息。</p>\n<h2 id=\"如何使用RESTful-API\"><a href=\"#如何使用RESTful-API\" class=\"headerlink\" title=\"如何使用RESTful API\"></a>如何使用RESTful API</h2><p>好吧，让我们进入整个故事中最重要的部分。</p>\n<p>有几种方法可以在C＃中使用RESTful API：</p>\n<ul>\n<li><a href=\"https://code-maze.com/different-ways-consume-restful-api-csharp/#HttpWebRequest\" target=\"_blank\" rel=\"noopener\"><strong>HttpWebRequest/Response Class</strong></a></li>\n<li><a href=\"https://code-maze.com/different-ways-consume-restful-api-csharp/#webclient\" target=\"_blank\" rel=\"noopener\"><strong>WebClient Class</strong></a></li>\n<li><a href=\"https://code-maze.com/different-ways-consume-restful-api-csharp/#HttpClient\" target=\"_blank\" rel=\"noopener\"><strong>HttpClient Class</strong></a></li>\n<li><a href=\"https://code-maze.com/different-ways-consume-restful-api-csharp/#RestSharp\" target=\"_blank\" rel=\"noopener\"><strong>RestSharp NuGet Package</strong></a></li>\n<li><a href=\"https://code-maze.com/different-ways-consume-restful-api-csharp/#ServiceStack\" target=\"_blank\" rel=\"noopener\"><strong>ServiceStack Http Utils</strong></a></li>\n<li><strong><a href=\"https://code-maze.com/different-ways-consume-restful-api-csharp/#flurl\" target=\"_blank\" rel=\"noopener\">Flurl</a></strong></li>\n<li><strong><a href=\"https://code-maze.com/different-ways-consume-restful-api-csharp/#dalsoft\" target=\"_blank\" rel=\"noopener\">DalSoft.RestClient</a></strong></li>\n</ul>\n<p>这些中的每一个都有优点和缺点，因此让我们仔细研究它们，看看它们提供了什么。</p>\n<p>例如，我们将通过GitHub API收集有关RestSharp回购版本及其发布日期的信息。此信息是公开可用的，您可以在此处查看原始JSON响应的外观： <a href=\"https://api.github.com/repos/restsharp/restsharp/releases\" target=\"_blank\" rel=\"noopener\">RestSharp版本</a></p>\n<p>我们将利用Json.NET库的帮助来反序列化获得的响应。同样，对于某些示例，我们将使用库的内置反序列化机制。选择哪种方式取决于您，因为没有正确的方法。（您可以在<a href=\"https://github.com/CodeMazeBlog/ConsumeRestfulApisExamples\" target=\"_blank\" rel=\"noopener\">源代码中</a>看到这两种机制的实现）。</p>\n<p>我期望通过接下来的几个示例得到一个反序列化<code>JArray</code>（为简单起见），其中包含RestSharp发布信息。之后，我们可以遍历它以获得以下结果。</p>\n<p> <img src=\"https://code-maze.com/wp-content/uploads/2017/06/RestSharp-releases.png\" alt=\"img\"> </p>\n<h2 id=\"HttpWebRequest-Response类\"><a href=\"#HttpWebRequest-Response类\" class=\"headerlink\" title=\"HttpWebRequest / Response类\"></a>HttpWebRequest / Response类</h2><p>这是<code>WebRequest</code> 类的特定于HTTP的实现，该实现最初用于处理HTTP请求，但已过时并由<code>WebClient</code>该类代替 。</p>\n<p>该<code>HttpWebRequest</code> 提供细粒度控制的要求制定过程的每一个环节。您可以想象，这可能是一把双刃剑，您很容易浪费大量时间来微调您的请求。另一方面，这可能正是您针对特定案例所需要的。</p>\n<p><code>HttpWebRequest</code> 类不会阻止用户界面，也就是说，我相信您会同意这一点，这一点非常重要。</p>\n<p><code>HttpWebResponse</code> 类为传入的响应提供了一个容器。</p>\n<p>这是有关如何使用这些类使用API的简单示例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HttpWebRequestHandler : IRequestHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public string GetReleases(string url)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        var request = (HttpWebRequest)WebRequest.Create(url);</span><br><span class=\"line\"></span><br><span class=\"line\">        request.Method = &quot;GET&quot;;</span><br><span class=\"line\">        request.UserAgent = RequestConstants.UserAgentValue;</span><br><span class=\"line\">        request.AutomaticDecompression = DecompressionMethods.Deflate | DecompressionMethods.GZip;</span><br><span class=\"line\"></span><br><span class=\"line\">        var content = string.Empty;</span><br><span class=\"line\"></span><br><span class=\"line\">        using (var response = (HttpWebResponse)request.GetResponse())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            using (var stream = response.GetResponseStream())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                using (var sr = new StreamReader(stream))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    content = sr.ReadToEnd();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 尽管是一个简单的示例，但是当您需要处理更复杂的方案（例如，发布表单信息，授权等）时，它会变得更加复杂。 </p>\n<h2 id=\"WebClient类别\"><a href=\"#WebClient类别\" class=\"headerlink\" title=\"WebClient类别\"></a>WebClient类别</h2><p>这个类对<code>HttpWebRequest</code>的包装。它通过<code>HttpWebRequest</code>从开发人员中提取的细节来简化流程。该代码更容易编写，并且您通过这种方式犯错误的可能性较小。如果您想编写更少的代码，而不用担心所有细节，并且执行速度是不重要的，请考虑使用<code>WebClient</code>class。</p>\n<p>这个示例应该使您大致了解<code>WebClient</code>与<code>HttpWebRequest</code>/ <code>HttpWebResponse</code>方法相比使用起来要容易得多。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string GetReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var client = new WebClient();</span><br><span class=\"line\">    client.Headers.Add(RequestConstants.UserAgent, RequestConstants.UserAgentValue);</span><br><span class=\"line\"></span><br><span class=\"line\">    var response = client.DownloadString(url);</span><br><span class=\"line\"></span><br><span class=\"line\">    return response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>容易得多，对吗？</p>\n<p>除了其他<code>DownloadString</code>方法，<code>WebClient</code>类还提供了许多其他有用的方法，使我们的生活更轻松。我们可以轻松地使用它来操作字符串，文件或字节数组，并且价格比<code>HttpWebRequest</code>/ <code>HttpWebResponse</code>方法要慢几毫秒。</p>\n<p>无论是<code>HttpWebRequest</code>/ <code>HttpWebResponse</code>和<code>WebClient</code>类在旧版本的.NET可供选择。如果您对其他产品感兴趣，请务必查看<a href=\"https://msdn.microsoft.com/en-us/library/system.net.webclient(v=vs.110).aspx\" target=\"_blank\" rel=\"noopener\">MSDN</a><code>WebClient</code>。</p>\n<h2 id=\"HttpClient类\"><a href=\"#HttpClient类\" class=\"headerlink\" title=\"HttpClient类\"></a>HttpClient类</h2><p><code>HttpClient</code> 是“新人”，它提供了旧库所缺乏的一些现代.NET功能。例如，您可以使用的单个实例发送多个请求<code>HttpClient</code>，它不绑定到特定的HTTP服务器或主机，而是使用async / await机制。</p>\n<p>您可以<a href=\"https://channel9.msdn.com/Events/Build/2013/4-092\" target=\"_blank\" rel=\"noopener\">在此视频中</a>找到<a href=\"https://channel9.msdn.com/Events/Build/2013/4-092\" target=\"_blank\" rel=\"noopener\">使用HttpClient</a>的<a href=\"https://channel9.msdn.com/Events/Build/2013/4-092\" target=\"_blank\" rel=\"noopener\">五个很好的理由</a>：</p>\n<ul>\n<li>强类型标题。</li>\n<li>共享缓存，cookie和凭据</li>\n<li>访问cookie和共享cookie</li>\n<li>控制缓存和共享缓存。</li>\n<li>将您的代码模块注入ASP.NET管道。清洁和模块化的代码。</li>\n</ul>\n<p><code>HttpClient</code>在我们的示例中，这是实际的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string GetReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    using (var httpClient = new HttpClient())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        httpClient.DefaultRequestHeaders.Add(RequestConstants.UserAgent, RequestConstants.UserAgentValue);</span><br><span class=\"line\"></span><br><span class=\"line\">        var response = httpClient.GetStringAsync(new Uri(url)).Result;</span><br><span class=\"line\"></span><br><span class=\"line\">        return response;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了简单起见，我同步实现了它。每个<code>HttpClient</code>方法都应异步使用，应该以这种方式使用。</p>\n<p>另外，我还要提到一件事。<strong>是否<code>HttpClient</code>应该包装在using块中还是在应用程序级别上进行静态讨论。尽管它实现了<code>IDisposable</code>，但似乎通过将它包装在using块中，<a href=\"https://aspnetmonsters.com/2016/08/2016-08-27-httpclientwrong/\" target=\"_blank\" rel=\"noopener\">会使应用程序出现故障并获得SocketException</a>。</strong>而在ANKIT博客中，提供了基于<a href=\"https://ankitvijay.net/2016/09/25/dispose-httpclient-or-have-a-static-instance/\" target=\"_blank\" rel=\"noopener\">很多有利于静态初始化的</a>的<code>HttpClient</code>性能测试结果是。<strong>请务必阅读这些博客文章，</strong>因为它们可以帮助您更了解该<code>HttpClient</code> 库的正确用法。（原文编写时间比较旧，在新版的.NET Core3.1中，相关问题已经解决）</p>\n<p>并且不要忘记，由于是新的，<code>HttpClient</code>是.NET 4.5以上版本才有，因此在某些旧项目中使用它可能会遇到麻烦。</p>\n<h2 id=\"RestSharp\"><a href=\"#RestSharp\" class=\"headerlink\" title=\"RestSharp\"></a>RestSharp</h2><p>RestSharp是标准.NET库的OpenSource替代品，也是目前最酷的.NET库之一。它以NuGet软件包的形式提供，出于某些原因，您应该考虑尝试一下。</p>\n<p>就像<code>HttpClient</code>RestSharp 一样，它是一个现代而全面的库，易于使用且令人愉悦，同时仍支持旧版本的.NET Framework。它具有内置的<a href=\"https://github.com/restsharp/RestSharp/wiki/Authenticators\" target=\"_blank\" rel=\"noopener\">身份验证</a>和<a href=\"https://github.com/restsharp/RestSharp/wiki/Deserialization\" target=\"_blank\" rel=\"noopener\">序列化/反序列化机制，</a>但允许您使用自定义<a href=\"https://github.com/restsharp/RestSharp/wiki/Deserialization\" target=\"_blank\" rel=\"noopener\">机制</a>覆盖它们。它<a href=\"https://github.com/restsharp/RestSharp/wiki/Cross-Platform-Support\" target=\"_blank\" rel=\"noopener\">可跨平台使用，</a>并支持OAuth1，OAuth2，基本，NTLM和基于参数的身份验证。您可以选择同步或异步工作。该库还有很多其他功能，而这些只是它提供的众多好处中的一部分。有关RestSharp的用法和功能的详细信息，您可以访问<a href=\"https://github.com/restsharp/RestSharp/wiki/Getting-Started\" target=\"_blank\" rel=\"noopener\">GitHub上</a>的RestSharp <a href=\"https://github.com/restsharp/RestSharp/wiki/Getting-Started\" target=\"_blank\" rel=\"noopener\">页面</a>。</p>\n<p>现在，让我们尝试使用RestSharp get获取RestSharp版本的列表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string GetReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var client = new RestClient(url);</span><br><span class=\"line\"></span><br><span class=\"line\">    var response = client.Execute(new RestRequest());</span><br><span class=\"line\"></span><br><span class=\"line\">    return response.Content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很简单。RestSharp非常灵活，拥有使用RESTful API时几乎可以实现所有功能所需的所有工具。</p>\n<p>在此示例中要注意的一件事是，由于示例的一致性，我没有使用RestSharp的反序列化机制，这有点浪费，但是我鼓励您使用它，因为它确实非常容易和方便。因此，您可以轻松地制作一个这样的容器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class GitHubRelease</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [JsonProperty(PropertyName = &quot;name&quot;)]</span><br><span class=\"line\">    public string Name &#123; get; set; &#125;</span><br><span class=\"line\">    [JsonProperty(PropertyName = &quot;published_at&quot;)]</span><br><span class=\"line\">    public string PublishedAt &#123; get; set; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 然后使用该<code>Execute</code>方法直接反序列化对该容器的响应。您可以仅添加所需的属性，并使用属性<code>JsonProperty</code>将它们映射到C＃属性（很好的触摸）。由于我们在响应中获得了发布列表，因此我们将<code>List</code> 用作包含类型。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;GitHubRelease&gt; GetDeserializedReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var client = new RestClient(url);</span><br><span class=\"line\"></span><br><span class=\"line\">    var response = client.Execute&lt;List&lt;GitHubRelease&gt;&gt;(new RestRequest());</span><br><span class=\"line\"></span><br><span class=\"line\">    return response.Data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一种非常直接而优雅的方式来获取我们的数据。</p>\n<p>RestSharp不仅具有发送<code>GET</code>请求的功能，还可以自己探索并观察它的酷炫之处。</p>\n<p>在RestSharp案例中要补充的最后一点是，其存储库需要维护者。如果您想了解更多有关这个很棒的库的信息，我敦促您前往<a href=\"https://github.com/restsharp/RestSharp\" target=\"_blank\" rel=\"noopener\">RestSharp存储库</a>，帮助该项目继续发展并变得更好。</p>\n<h2 id=\"ServiceStack-Http实用程序\"><a href=\"#ServiceStack-Http实用程序\" class=\"headerlink\" title=\"ServiceStack Http实用程序\"></a>ServiceStack Http实用程序</h2><p>另一个库，但与RestSharp不同，ServiceStack似乎得到了适当维护，并与现代<a href=\"https://code-maze.com/ultimate-aspnet-core-3-web-api/\" target=\"_blank\" rel=\"noopener\">API</a>趋势保持同步。ServiceStack功能列表令人印象深刻，并且肯定具有各种应用程序。</p>\n<p>在这里对我们最有用的是演示如何使用外部RESTful API。ServiceStack具有一种专门的方式来处理称为<a href=\"http://docs.servicestack.net/http-utils\" target=\"_blank\" rel=\"noopener\">Http Utils的</a>第三方HTTP API 。</p>\n<p>让我们看看如何首先使用Json.NET解析器来获取RestSharp版本是如何使用ServiceStack Http Utils。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string GetReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var response = url.GetJsonFromUrl(webReq =&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        webReq.UserAgent = RequestConstants.UserAgentValue;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 您还可以选择将其留给ServiceStack解析器。我们可以重用本文前面定义的<code>Release</code>类 。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;GitHubRelease&gt; GetDeserializedReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var releases = url.GetJsonFromUrl(webReq =&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        webReq.UserAgent = RequestConstants.UserAgentValue;</span><br><span class=\"line\">    &#125;).FromJson&lt;List&lt;GitHubRelease&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    return releases;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如您所见，无论哪种方式都可以正常工作，并且您可以选择是获取字符串响应还是立即反序列化它。</p>\n<p>尽管ServiceStack是我们偶然发现的最后一个库，但令我感到惊讶的是，它使用起来如此容易，而且我认为它将来可能成为我处理API和服务的首选工具。</p>\n<h2 id=\"Flurl\"><a href=\"#Flurl\" class=\"headerlink\" title=\"Flurl\"></a>Flurl</h2><p>评论库中许多人要求的图书馆之一，并在Internet上受到许多人的喜爱，但仍吸引着人们。</p>\n<p>Flurl代表Fluent Url Builder，这是库构建其查询的方式。对于不熟悉flurl的做事方式的人来说，flurl只是意味着库的构建方式是将方法链接在一起以实现更高的可读性，类似于人类语言。</p>\n<p>为了使事情更容易理解，让我们举一些例子（这个例子来自官方文档）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Flurl will use 1 HttpClient instance per host</span><br><span class=\"line\">var person = await &quot;https://api.com&quot;</span><br><span class=\"line\">    .AppendPathSegment(&quot;person&quot;)</span><br><span class=\"line\">    .SetQueryParams(new &#123; a = 1, b = 2 &#125;)</span><br><span class=\"line\">    .WithOAuthBearerToken(&quot;my_oauth_token&quot;)</span><br><span class=\"line\">    .PostJsonAsync(new</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        first_name = &quot;Claire&quot;,</span><br><span class=\"line\">        last_name = &quot;Underwood&quot;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .ReceiveJson&lt;Person&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>您可以看到方法如何链接在一起以完成“句子”。</p>\n<p>在后台，Flurl使用HttpClient或通过自己的语法糖增强HttpClient库。因此，这意味着Flurl是一个异步库，因此请牢记这一点。</p>\n<p>与其他高级库一样，我们可以通过两种不同的方式来做到这一点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string GetReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var result = url</span><br><span class=\"line\">        .WithHeader(RequestConstants.UserAgent, RequestConstants.UserAgentValue)</span><br><span class=\"line\">        .GetJsonAsync&lt;List&lt;GitHubRelease&gt;&gt;()</span><br><span class=\"line\">        .Result;</span><br><span class=\"line\"></span><br><span class=\"line\">    return JsonConvert.SerializeObject(result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式相当糟糕，因为我们只是序列化结果，以便稍后对其进行反序列化。如果您使用的是Flurl之类的库，则不应以这种方式进行操作。</p>\n<p>更好的做事方式是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;GitHubRelease&gt; GetDeserializedReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var result = url</span><br><span class=\"line\">        .WithHeader(RequestConstants.UserAgent, RequestConstants.UserAgentValue)</span><br><span class=\"line\">        .GetJsonAsync&lt;List&lt;GitHubRelease&gt;&gt;()</span><br><span class=\"line\">        .Result;</span><br><span class=\"line\"></span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 随着<code>.Result</code>我们强迫代码的同步行为。使用Flurl的实际和预期方式如下所示： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public async Task&lt;List&lt;GitHubRelease&gt;&gt; GetDeserializedReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var result = await url</span><br><span class=\"line\">        .WithHeader(RequestConstants.UserAgent, RequestConstants.UserAgentValue)</span><br><span class=\"line\">        .GetJsonAsync&lt;List&lt;GitHubRelease&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这展示了Flurl库的全部潜力。</p>\n<p>如果您想了解更多有关如何在不同的现实生活场景使用Flurl，看看我们的 <a href=\"https://code-maze.com/consuming-github-api-rest-with-flurl/\" target=\"_blank\" rel=\"noopener\">消费GitHub的API（REST）随着</a><a href=\"https://code-maze.com/wp-admin/post.php?post=4822&action=edit\" target=\"_blank\" rel=\"noopener\">Flurl</a> 文章</p>\n<p>总而言之，它就像广告一样：易于使用，现代，可读性和可测试性。您对这个库还有什么期望？要开源？<a href=\"https://github.com/tmenier/Flurl\" target=\"_blank\" rel=\"noopener\">签</a>出： <a href=\"https://github.com/tmenier/Flurl\" target=\"_blank\" rel=\"noopener\">Flurl存储库</a>，如果您愿意，可以贡献自己的力量！</p>\n<h2 id=\"DalSoft-RestClient\"><a href=\"#DalSoft-RestClient\" class=\"headerlink\" title=\"DalSoft.RestClient\"></a>DalSoft.RestClient</h2><p>现在，此列表与该列表中的任何内容都有些不同。但这一点有所不同。</p>\n<p>让我们看看如何使用DalSoft.RestClient来使用GitHub API，然后谈论我们已完成的工作。</p>\n<p>首先，您可以通过输入以下内容，通过NuGet软件包管理器下载DalSoft.RestClient： <code>Install-Package DalSoft.RestClient</code></p>\n<p>或通过.NET Core CLI： <code>dotnet add package DalSoft.RestClient</code></p>\n<p>两种方法都可以。</p>\n<p>拥有图书馆后，我们可以执行以下操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string GetReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dynamic client = new RestClient(RequestConstants.BaseUrl,</span><br><span class=\"line\">        new Headers &#123; &#123; RequestConstants.UserAgent, RequestConstants.UserAgentValue &#125; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var response = client.repos.restsharp.restsharp.releases.Get().Result.ToString();</span><br><span class=\"line\"></span><br><span class=\"line\">    return response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 或最好使用DalSoft.RestClient在充分利用其功能的同时立即反序列化响应： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public async Task&lt;List&lt;GitHubRelease&gt;&gt; GetDeserializedReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dynamic client = new RestClient(RequestConstants.BaseUrl,</span><br><span class=\"line\">        new Headers &#123; &#123; RequestConstants.UserAgent, RequestConstants.UserAgentValue &#125; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var response = await client.repos.restsharp.restsharp.releases.Get();</span><br><span class=\"line\"></span><br><span class=\"line\">    return response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，让我们稍微讨论一下这些例子。</p>\n<p>乍一看，它似乎并不比我们使用的其他一些现代库简单得多。</p>\n<p>但这归结为形成请求的方式，那就是利用RestClient的动态特性。例如，我们的BaseUrl是<code>https://api.github.com</code> ，我们需要进入<code>https://api.github.com/repos/restsharp/restsharp/releases</code>。我们可以通过动态创建客户端，然后通过链接Url的“部分”来形成Url来做到这一点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">await client.repos.restsharp.restsharp.releases.Get();</span><br></pre></td></tr></table></figure>\n\n<p>形成请求的一种非常独特的方法。还有一个非常灵活的！</p>\n<p>因此，一旦我们设置了基本的网址，就可以轻松地使用不同的端点。</p>\n<p>还值得一提的是，我们得到的JSON响应会自动进行类型转换。如您在第二个示例中看到的那样，我们方法的返回值是<code>Task&gt;.</code> So，该库足够聪明，可以将响应转换为我们的类型（依赖于Json.NET）。这使我们的生活更加轻松。</p>\n<p>除了易于理解和使用之外，DalSoft.RestClient还具有现代库应具备的所有功能。它是可<strong>配置的，异步的，可扩展的，可测试的，并且支持多个平台</strong>。</p>\n<p>我们仅演示了DalSoft.RestClient功能的一小部分。如果您对使用DalSoft.RestClient感兴趣，请转至<a href=\"https://code-maze.com/dalsoft-restclient-consume-any-rest-api/\" target=\"_blank\" rel=\"noopener\">我们的文章，</a>以学习如何在不同情况下使用它，或参阅 <a href=\"https://github.com/DalSoft/DalSoft.RestClient\" target=\"_blank\" rel=\"noopener\">GitHub官方仓库</a>和<a href=\"https://restclient.dalsoft.io/\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h2 id=\"其他选择\"><a href=\"#其他选择\" class=\"headerlink\" title=\"其他选择\"></a>其他选择</h2><p>对于您的特定问题，还有许多其他选项可用。您可以使用任何这些库来使用特定的RESTful API。例如，<a href=\"https://github.com/octokit/octokit.net\" target=\"_blank\" rel=\"noopener\">octokit.net专门 </a>用于GitHub API，<a href=\"https://github.com/facebook-csharp-sdk/facebook-csharp-sdk\" target=\"_blank\" rel=\"noopener\">Facebook SDK</a> 用于使用Facebook API，并且还有许多其他功能可用于任何用途。</p>\n<p>虽然这些库是专门为这些API而设计的，并且可能擅长于它们的用途，但它们的用途是有限的，因为您经常需要在应用程序中连接多个<a href=\"https://code-maze.com/ultimate-aspnet-core-3-web-api/\" target=\"_blank\" rel=\"noopener\">API</a>。这可能会导致每个实现都有不同的实现方式，以及更多的依赖关系，这可能导致重复并且容易出错。库越具体，其灵活性就越差。</p>\n<h2 id=\"GitHub上的源代码\"><a href=\"#GitHub上的源代码\" class=\"headerlink\" title=\"GitHub上的源代码\"></a>GitHub上的源代码</h2><p><a href=\"https://github.com/CodeMazeBlog/ConsumeRestfulApisExamples\" target=\"_blank\" rel=\"noopener\">GitHub上的源代码</a></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>因此，总而言之，我们已经讨论了可用于使用RESTful API的不同工具。我们已经提到了一些.NET库，可以这样做<code>HttpWebRequest</code>，<code>WebClient</code>和<code>HttpClient</code>，以及一些惊人的第三方工具，如RestSharp和ServiceStack。您还对这些工具进行了简短的介绍，并给出了一些非常简单的示例来向您展示如何开始使用它们。</p>\n<p>我认为您现在至少有95％准备使用一些REST。继续展开翅膀，探索并找到更多有趣且有趣的方式来使用和连接不同的API。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"在C＃中使用RESTful-API的几种好方法\"><a href=\"#在C＃中使用RESTful-API的几种好方法\" class=\"headerlink\" title=\"在C＃中使用RESTful API的几种好方法\"></a>在C＃中使用RESTful API的几种好方法</h1><p> <a href=\"https://code-maze.com/author/codemaze_blog/\" target=\"_blank\" rel=\"noopener\">Vladimir Pecanac</a> </p>\n<p>通过Web开发的路径，您发现自己迟早需要处理外部API（应用程序编程接口）。在本文中，我的目标是列出在C＃项目中使用RESTful API的方法的最全面列表，并通过一些简单示例向您展示如何做到这一点。</p>\n<p>阅读该文章后，您将更深入地了解可以使用哪些选项，以及下次需要使用<a href=\"https://code-maze.com/ultimate-aspnet-core-3-web-api/\" target=\"_blank\" rel=\"noopener\">RESTful API</a>时如何选择正确的选项。</p>\n<h2 id=\"什么是RESTful-API？\"><a href=\"#什么是RESTful-API？\" class=\"headerlink\" title=\"什么是RESTful API？\"></a>什么是RESTful API？</h2><p>因此，在开始之前，您可能想知道<a href=\"https://code-maze.com/ultimate-aspnet-core-3-web-api/\" target=\"_blank\" rel=\"noopener\">API</a>代表什么，以及RESTful的全部含义是什么？</p>\n<p>简而言之，API是软件应用程序之间的层。您可以将请求发送到<a href=\"https://code-maze.com/ultimate-aspnet-core-3-web-api/\" target=\"_blank\" rel=\"noopener\">API</a>，并从中获得响应。API隐藏了软件应用程序具体实现的所有细节，并公开了您用于与该应用程序通信的接口。</p>\n<p>整个互联网是由API组成的大型蜘蛛网。我们使用API在应用程序之间通信和关联信息。我们有一个<a href=\"https://code-maze.com/ultimate-aspnet-core-3-web-api/\" target=\"_blank\" rel=\"noopener\">API</a>，可以处理几乎所有内容。您每天使用的大多数服务都有自己的API（GoogleMaps，Facebook，Twitter，Instagram，天气门户…）</p>\n<p>RESTful部分意味着API是根据REST（表示状态传输）的原理和规则来实现的，REST是网络的基础架构原理。RESTful API在大多数情况下会返回纯文本，JSON或XML响应。更详细地解释REST不在本文的讨论范围之内，但是您可以在我们的文章<a href=\"https://code-maze.com/top-rest-api-best-practices/\" target=\"_blank\" rel=\"noopener\">REST API最佳实践中</a>阅读有关REST的更多信息。</p>\n<h2 id=\"如何使用RESTful-API\"><a href=\"#如何使用RESTful-API\" class=\"headerlink\" title=\"如何使用RESTful API\"></a>如何使用RESTful API</h2><p>好吧，让我们进入整个故事中最重要的部分。</p>\n<p>有几种方法可以在C＃中使用RESTful API：</p>\n<ul>\n<li><a href=\"https://code-maze.com/different-ways-consume-restful-api-csharp/#HttpWebRequest\" target=\"_blank\" rel=\"noopener\"><strong>HttpWebRequest/Response Class</strong></a></li>\n<li><a href=\"https://code-maze.com/different-ways-consume-restful-api-csharp/#webclient\" target=\"_blank\" rel=\"noopener\"><strong>WebClient Class</strong></a></li>\n<li><a href=\"https://code-maze.com/different-ways-consume-restful-api-csharp/#HttpClient\" target=\"_blank\" rel=\"noopener\"><strong>HttpClient Class</strong></a></li>\n<li><a href=\"https://code-maze.com/different-ways-consume-restful-api-csharp/#RestSharp\" target=\"_blank\" rel=\"noopener\"><strong>RestSharp NuGet Package</strong></a></li>\n<li><a href=\"https://code-maze.com/different-ways-consume-restful-api-csharp/#ServiceStack\" target=\"_blank\" rel=\"noopener\"><strong>ServiceStack Http Utils</strong></a></li>\n<li><strong><a href=\"https://code-maze.com/different-ways-consume-restful-api-csharp/#flurl\" target=\"_blank\" rel=\"noopener\">Flurl</a></strong></li>\n<li><strong><a href=\"https://code-maze.com/different-ways-consume-restful-api-csharp/#dalsoft\" target=\"_blank\" rel=\"noopener\">DalSoft.RestClient</a></strong></li>\n</ul>\n<p>这些中的每一个都有优点和缺点，因此让我们仔细研究它们，看看它们提供了什么。</p>\n<p>例如，我们将通过GitHub API收集有关RestSharp回购版本及其发布日期的信息。此信息是公开可用的，您可以在此处查看原始JSON响应的外观： <a href=\"https://api.github.com/repos/restsharp/restsharp/releases\" target=\"_blank\" rel=\"noopener\">RestSharp版本</a></p>\n<p>我们将利用Json.NET库的帮助来反序列化获得的响应。同样，对于某些示例，我们将使用库的内置反序列化机制。选择哪种方式取决于您，因为没有正确的方法。（您可以在<a href=\"https://github.com/CodeMazeBlog/ConsumeRestfulApisExamples\" target=\"_blank\" rel=\"noopener\">源代码中</a>看到这两种机制的实现）。</p>\n<p>我期望通过接下来的几个示例得到一个反序列化<code>JArray</code>（为简单起见），其中包含RestSharp发布信息。之后，我们可以遍历它以获得以下结果。</p>\n<p> <img src=\"https://code-maze.com/wp-content/uploads/2017/06/RestSharp-releases.png\" alt=\"img\"> </p>\n<h2 id=\"HttpWebRequest-Response类\"><a href=\"#HttpWebRequest-Response类\" class=\"headerlink\" title=\"HttpWebRequest / Response类\"></a>HttpWebRequest / Response类</h2><p>这是<code>WebRequest</code> 类的特定于HTTP的实现，该实现最初用于处理HTTP请求，但已过时并由<code>WebClient</code>该类代替 。</p>\n<p>该<code>HttpWebRequest</code> 提供细粒度控制的要求制定过程的每一个环节。您可以想象，这可能是一把双刃剑，您很容易浪费大量时间来微调您的请求。另一方面，这可能正是您针对特定案例所需要的。</p>\n<p><code>HttpWebRequest</code> 类不会阻止用户界面，也就是说，我相信您会同意这一点，这一点非常重要。</p>\n<p><code>HttpWebResponse</code> 类为传入的响应提供了一个容器。</p>\n<p>这是有关如何使用这些类使用API的简单示例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HttpWebRequestHandler : IRequestHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public string GetReleases(string url)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        var request = (HttpWebRequest)WebRequest.Create(url);</span><br><span class=\"line\"></span><br><span class=\"line\">        request.Method = &quot;GET&quot;;</span><br><span class=\"line\">        request.UserAgent = RequestConstants.UserAgentValue;</span><br><span class=\"line\">        request.AutomaticDecompression = DecompressionMethods.Deflate | DecompressionMethods.GZip;</span><br><span class=\"line\"></span><br><span class=\"line\">        var content = string.Empty;</span><br><span class=\"line\"></span><br><span class=\"line\">        using (var response = (HttpWebResponse)request.GetResponse())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            using (var stream = response.GetResponseStream())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                using (var sr = new StreamReader(stream))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    content = sr.ReadToEnd();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 尽管是一个简单的示例，但是当您需要处理更复杂的方案（例如，发布表单信息，授权等）时，它会变得更加复杂。 </p>\n<h2 id=\"WebClient类别\"><a href=\"#WebClient类别\" class=\"headerlink\" title=\"WebClient类别\"></a>WebClient类别</h2><p>这个类对<code>HttpWebRequest</code>的包装。它通过<code>HttpWebRequest</code>从开发人员中提取的细节来简化流程。该代码更容易编写，并且您通过这种方式犯错误的可能性较小。如果您想编写更少的代码，而不用担心所有细节，并且执行速度是不重要的，请考虑使用<code>WebClient</code>class。</p>\n<p>这个示例应该使您大致了解<code>WebClient</code>与<code>HttpWebRequest</code>/ <code>HttpWebResponse</code>方法相比使用起来要容易得多。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string GetReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var client = new WebClient();</span><br><span class=\"line\">    client.Headers.Add(RequestConstants.UserAgent, RequestConstants.UserAgentValue);</span><br><span class=\"line\"></span><br><span class=\"line\">    var response = client.DownloadString(url);</span><br><span class=\"line\"></span><br><span class=\"line\">    return response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>容易得多，对吗？</p>\n<p>除了其他<code>DownloadString</code>方法，<code>WebClient</code>类还提供了许多其他有用的方法，使我们的生活更轻松。我们可以轻松地使用它来操作字符串，文件或字节数组，并且价格比<code>HttpWebRequest</code>/ <code>HttpWebResponse</code>方法要慢几毫秒。</p>\n<p>无论是<code>HttpWebRequest</code>/ <code>HttpWebResponse</code>和<code>WebClient</code>类在旧版本的.NET可供选择。如果您对其他产品感兴趣，请务必查看<a href=\"https://msdn.microsoft.com/en-us/library/system.net.webclient(v=vs.110).aspx\" target=\"_blank\" rel=\"noopener\">MSDN</a><code>WebClient</code>。</p>\n<h2 id=\"HttpClient类\"><a href=\"#HttpClient类\" class=\"headerlink\" title=\"HttpClient类\"></a>HttpClient类</h2><p><code>HttpClient</code> 是“新人”，它提供了旧库所缺乏的一些现代.NET功能。例如，您可以使用的单个实例发送多个请求<code>HttpClient</code>，它不绑定到特定的HTTP服务器或主机，而是使用async / await机制。</p>\n<p>您可以<a href=\"https://channel9.msdn.com/Events/Build/2013/4-092\" target=\"_blank\" rel=\"noopener\">在此视频中</a>找到<a href=\"https://channel9.msdn.com/Events/Build/2013/4-092\" target=\"_blank\" rel=\"noopener\">使用HttpClient</a>的<a href=\"https://channel9.msdn.com/Events/Build/2013/4-092\" target=\"_blank\" rel=\"noopener\">五个很好的理由</a>：</p>\n<ul>\n<li>强类型标题。</li>\n<li>共享缓存，cookie和凭据</li>\n<li>访问cookie和共享cookie</li>\n<li>控制缓存和共享缓存。</li>\n<li>将您的代码模块注入ASP.NET管道。清洁和模块化的代码。</li>\n</ul>\n<p><code>HttpClient</code>在我们的示例中，这是实际的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string GetReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    using (var httpClient = new HttpClient())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        httpClient.DefaultRequestHeaders.Add(RequestConstants.UserAgent, RequestConstants.UserAgentValue);</span><br><span class=\"line\"></span><br><span class=\"line\">        var response = httpClient.GetStringAsync(new Uri(url)).Result;</span><br><span class=\"line\"></span><br><span class=\"line\">        return response;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了简单起见，我同步实现了它。每个<code>HttpClient</code>方法都应异步使用，应该以这种方式使用。</p>\n<p>另外，我还要提到一件事。<strong>是否<code>HttpClient</code>应该包装在using块中还是在应用程序级别上进行静态讨论。尽管它实现了<code>IDisposable</code>，但似乎通过将它包装在using块中，<a href=\"https://aspnetmonsters.com/2016/08/2016-08-27-httpclientwrong/\" target=\"_blank\" rel=\"noopener\">会使应用程序出现故障并获得SocketException</a>。</strong>而在ANKIT博客中，提供了基于<a href=\"https://ankitvijay.net/2016/09/25/dispose-httpclient-or-have-a-static-instance/\" target=\"_blank\" rel=\"noopener\">很多有利于静态初始化的</a>的<code>HttpClient</code>性能测试结果是。<strong>请务必阅读这些博客文章，</strong>因为它们可以帮助您更了解该<code>HttpClient</code> 库的正确用法。（原文编写时间比较旧，在新版的.NET Core3.1中，相关问题已经解决）</p>\n<p>并且不要忘记，由于是新的，<code>HttpClient</code>是.NET 4.5以上版本才有，因此在某些旧项目中使用它可能会遇到麻烦。</p>\n<h2 id=\"RestSharp\"><a href=\"#RestSharp\" class=\"headerlink\" title=\"RestSharp\"></a>RestSharp</h2><p>RestSharp是标准.NET库的OpenSource替代品，也是目前最酷的.NET库之一。它以NuGet软件包的形式提供，出于某些原因，您应该考虑尝试一下。</p>\n<p>就像<code>HttpClient</code>RestSharp 一样，它是一个现代而全面的库，易于使用且令人愉悦，同时仍支持旧版本的.NET Framework。它具有内置的<a href=\"https://github.com/restsharp/RestSharp/wiki/Authenticators\" target=\"_blank\" rel=\"noopener\">身份验证</a>和<a href=\"https://github.com/restsharp/RestSharp/wiki/Deserialization\" target=\"_blank\" rel=\"noopener\">序列化/反序列化机制，</a>但允许您使用自定义<a href=\"https://github.com/restsharp/RestSharp/wiki/Deserialization\" target=\"_blank\" rel=\"noopener\">机制</a>覆盖它们。它<a href=\"https://github.com/restsharp/RestSharp/wiki/Cross-Platform-Support\" target=\"_blank\" rel=\"noopener\">可跨平台使用，</a>并支持OAuth1，OAuth2，基本，NTLM和基于参数的身份验证。您可以选择同步或异步工作。该库还有很多其他功能，而这些只是它提供的众多好处中的一部分。有关RestSharp的用法和功能的详细信息，您可以访问<a href=\"https://github.com/restsharp/RestSharp/wiki/Getting-Started\" target=\"_blank\" rel=\"noopener\">GitHub上</a>的RestSharp <a href=\"https://github.com/restsharp/RestSharp/wiki/Getting-Started\" target=\"_blank\" rel=\"noopener\">页面</a>。</p>\n<p>现在，让我们尝试使用RestSharp get获取RestSharp版本的列表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string GetReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var client = new RestClient(url);</span><br><span class=\"line\"></span><br><span class=\"line\">    var response = client.Execute(new RestRequest());</span><br><span class=\"line\"></span><br><span class=\"line\">    return response.Content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很简单。RestSharp非常灵活，拥有使用RESTful API时几乎可以实现所有功能所需的所有工具。</p>\n<p>在此示例中要注意的一件事是，由于示例的一致性，我没有使用RestSharp的反序列化机制，这有点浪费，但是我鼓励您使用它，因为它确实非常容易和方便。因此，您可以轻松地制作一个这样的容器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class GitHubRelease</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [JsonProperty(PropertyName = &quot;name&quot;)]</span><br><span class=\"line\">    public string Name &#123; get; set; &#125;</span><br><span class=\"line\">    [JsonProperty(PropertyName = &quot;published_at&quot;)]</span><br><span class=\"line\">    public string PublishedAt &#123; get; set; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 然后使用该<code>Execute</code>方法直接反序列化对该容器的响应。您可以仅添加所需的属性，并使用属性<code>JsonProperty</code>将它们映射到C＃属性（很好的触摸）。由于我们在响应中获得了发布列表，因此我们将<code>List</code> 用作包含类型。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;GitHubRelease&gt; GetDeserializedReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var client = new RestClient(url);</span><br><span class=\"line\"></span><br><span class=\"line\">    var response = client.Execute&lt;List&lt;GitHubRelease&gt;&gt;(new RestRequest());</span><br><span class=\"line\"></span><br><span class=\"line\">    return response.Data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一种非常直接而优雅的方式来获取我们的数据。</p>\n<p>RestSharp不仅具有发送<code>GET</code>请求的功能，还可以自己探索并观察它的酷炫之处。</p>\n<p>在RestSharp案例中要补充的最后一点是，其存储库需要维护者。如果您想了解更多有关这个很棒的库的信息，我敦促您前往<a href=\"https://github.com/restsharp/RestSharp\" target=\"_blank\" rel=\"noopener\">RestSharp存储库</a>，帮助该项目继续发展并变得更好。</p>\n<h2 id=\"ServiceStack-Http实用程序\"><a href=\"#ServiceStack-Http实用程序\" class=\"headerlink\" title=\"ServiceStack Http实用程序\"></a>ServiceStack Http实用程序</h2><p>另一个库，但与RestSharp不同，ServiceStack似乎得到了适当维护，并与现代<a href=\"https://code-maze.com/ultimate-aspnet-core-3-web-api/\" target=\"_blank\" rel=\"noopener\">API</a>趋势保持同步。ServiceStack功能列表令人印象深刻，并且肯定具有各种应用程序。</p>\n<p>在这里对我们最有用的是演示如何使用外部RESTful API。ServiceStack具有一种专门的方式来处理称为<a href=\"http://docs.servicestack.net/http-utils\" target=\"_blank\" rel=\"noopener\">Http Utils的</a>第三方HTTP API 。</p>\n<p>让我们看看如何首先使用Json.NET解析器来获取RestSharp版本是如何使用ServiceStack Http Utils。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string GetReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var response = url.GetJsonFromUrl(webReq =&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        webReq.UserAgent = RequestConstants.UserAgentValue;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 您还可以选择将其留给ServiceStack解析器。我们可以重用本文前面定义的<code>Release</code>类 。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;GitHubRelease&gt; GetDeserializedReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var releases = url.GetJsonFromUrl(webReq =&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        webReq.UserAgent = RequestConstants.UserAgentValue;</span><br><span class=\"line\">    &#125;).FromJson&lt;List&lt;GitHubRelease&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    return releases;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如您所见，无论哪种方式都可以正常工作，并且您可以选择是获取字符串响应还是立即反序列化它。</p>\n<p>尽管ServiceStack是我们偶然发现的最后一个库，但令我感到惊讶的是，它使用起来如此容易，而且我认为它将来可能成为我处理API和服务的首选工具。</p>\n<h2 id=\"Flurl\"><a href=\"#Flurl\" class=\"headerlink\" title=\"Flurl\"></a>Flurl</h2><p>评论库中许多人要求的图书馆之一，并在Internet上受到许多人的喜爱，但仍吸引着人们。</p>\n<p>Flurl代表Fluent Url Builder，这是库构建其查询的方式。对于不熟悉flurl的做事方式的人来说，flurl只是意味着库的构建方式是将方法链接在一起以实现更高的可读性，类似于人类语言。</p>\n<p>为了使事情更容易理解，让我们举一些例子（这个例子来自官方文档）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Flurl will use 1 HttpClient instance per host</span><br><span class=\"line\">var person = await &quot;https://api.com&quot;</span><br><span class=\"line\">    .AppendPathSegment(&quot;person&quot;)</span><br><span class=\"line\">    .SetQueryParams(new &#123; a = 1, b = 2 &#125;)</span><br><span class=\"line\">    .WithOAuthBearerToken(&quot;my_oauth_token&quot;)</span><br><span class=\"line\">    .PostJsonAsync(new</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        first_name = &quot;Claire&quot;,</span><br><span class=\"line\">        last_name = &quot;Underwood&quot;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .ReceiveJson&lt;Person&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>您可以看到方法如何链接在一起以完成“句子”。</p>\n<p>在后台，Flurl使用HttpClient或通过自己的语法糖增强HttpClient库。因此，这意味着Flurl是一个异步库，因此请牢记这一点。</p>\n<p>与其他高级库一样，我们可以通过两种不同的方式来做到这一点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string GetReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var result = url</span><br><span class=\"line\">        .WithHeader(RequestConstants.UserAgent, RequestConstants.UserAgentValue)</span><br><span class=\"line\">        .GetJsonAsync&lt;List&lt;GitHubRelease&gt;&gt;()</span><br><span class=\"line\">        .Result;</span><br><span class=\"line\"></span><br><span class=\"line\">    return JsonConvert.SerializeObject(result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式相当糟糕，因为我们只是序列化结果，以便稍后对其进行反序列化。如果您使用的是Flurl之类的库，则不应以这种方式进行操作。</p>\n<p>更好的做事方式是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;GitHubRelease&gt; GetDeserializedReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var result = url</span><br><span class=\"line\">        .WithHeader(RequestConstants.UserAgent, RequestConstants.UserAgentValue)</span><br><span class=\"line\">        .GetJsonAsync&lt;List&lt;GitHubRelease&gt;&gt;()</span><br><span class=\"line\">        .Result;</span><br><span class=\"line\"></span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 随着<code>.Result</code>我们强迫代码的同步行为。使用Flurl的实际和预期方式如下所示： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public async Task&lt;List&lt;GitHubRelease&gt;&gt; GetDeserializedReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var result = await url</span><br><span class=\"line\">        .WithHeader(RequestConstants.UserAgent, RequestConstants.UserAgentValue)</span><br><span class=\"line\">        .GetJsonAsync&lt;List&lt;GitHubRelease&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这展示了Flurl库的全部潜力。</p>\n<p>如果您想了解更多有关如何在不同的现实生活场景使用Flurl，看看我们的 <a href=\"https://code-maze.com/consuming-github-api-rest-with-flurl/\" target=\"_blank\" rel=\"noopener\">消费GitHub的API（REST）随着</a><a href=\"https://code-maze.com/wp-admin/post.php?post=4822&action=edit\" target=\"_blank\" rel=\"noopener\">Flurl</a> 文章</p>\n<p>总而言之，它就像广告一样：易于使用，现代，可读性和可测试性。您对这个库还有什么期望？要开源？<a href=\"https://github.com/tmenier/Flurl\" target=\"_blank\" rel=\"noopener\">签</a>出： <a href=\"https://github.com/tmenier/Flurl\" target=\"_blank\" rel=\"noopener\">Flurl存储库</a>，如果您愿意，可以贡献自己的力量！</p>\n<h2 id=\"DalSoft-RestClient\"><a href=\"#DalSoft-RestClient\" class=\"headerlink\" title=\"DalSoft.RestClient\"></a>DalSoft.RestClient</h2><p>现在，此列表与该列表中的任何内容都有些不同。但这一点有所不同。</p>\n<p>让我们看看如何使用DalSoft.RestClient来使用GitHub API，然后谈论我们已完成的工作。</p>\n<p>首先，您可以通过输入以下内容，通过NuGet软件包管理器下载DalSoft.RestClient： <code>Install-Package DalSoft.RestClient</code></p>\n<p>或通过.NET Core CLI： <code>dotnet add package DalSoft.RestClient</code></p>\n<p>两种方法都可以。</p>\n<p>拥有图书馆后，我们可以执行以下操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string GetReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dynamic client = new RestClient(RequestConstants.BaseUrl,</span><br><span class=\"line\">        new Headers &#123; &#123; RequestConstants.UserAgent, RequestConstants.UserAgentValue &#125; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var response = client.repos.restsharp.restsharp.releases.Get().Result.ToString();</span><br><span class=\"line\"></span><br><span class=\"line\">    return response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 或最好使用DalSoft.RestClient在充分利用其功能的同时立即反序列化响应： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public async Task&lt;List&lt;GitHubRelease&gt;&gt; GetDeserializedReleases(string url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dynamic client = new RestClient(RequestConstants.BaseUrl,</span><br><span class=\"line\">        new Headers &#123; &#123; RequestConstants.UserAgent, RequestConstants.UserAgentValue &#125; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var response = await client.repos.restsharp.restsharp.releases.Get();</span><br><span class=\"line\"></span><br><span class=\"line\">    return response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，让我们稍微讨论一下这些例子。</p>\n<p>乍一看，它似乎并不比我们使用的其他一些现代库简单得多。</p>\n<p>但这归结为形成请求的方式，那就是利用RestClient的动态特性。例如，我们的BaseUrl是<code>https://api.github.com</code> ，我们需要进入<code>https://api.github.com/repos/restsharp/restsharp/releases</code>。我们可以通过动态创建客户端，然后通过链接Url的“部分”来形成Url来做到这一点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">await client.repos.restsharp.restsharp.releases.Get();</span><br></pre></td></tr></table></figure>\n\n<p>形成请求的一种非常独特的方法。还有一个非常灵活的！</p>\n<p>因此，一旦我们设置了基本的网址，就可以轻松地使用不同的端点。</p>\n<p>还值得一提的是，我们得到的JSON响应会自动进行类型转换。如您在第二个示例中看到的那样，我们方法的返回值是<code>Task&gt;.</code> So，该库足够聪明，可以将响应转换为我们的类型（依赖于Json.NET）。这使我们的生活更加轻松。</p>\n<p>除了易于理解和使用之外，DalSoft.RestClient还具有现代库应具备的所有功能。它是可<strong>配置的，异步的，可扩展的，可测试的，并且支持多个平台</strong>。</p>\n<p>我们仅演示了DalSoft.RestClient功能的一小部分。如果您对使用DalSoft.RestClient感兴趣，请转至<a href=\"https://code-maze.com/dalsoft-restclient-consume-any-rest-api/\" target=\"_blank\" rel=\"noopener\">我们的文章，</a>以学习如何在不同情况下使用它，或参阅 <a href=\"https://github.com/DalSoft/DalSoft.RestClient\" target=\"_blank\" rel=\"noopener\">GitHub官方仓库</a>和<a href=\"https://restclient.dalsoft.io/\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h2 id=\"其他选择\"><a href=\"#其他选择\" class=\"headerlink\" title=\"其他选择\"></a>其他选择</h2><p>对于您的特定问题，还有许多其他选项可用。您可以使用任何这些库来使用特定的RESTful API。例如，<a href=\"https://github.com/octokit/octokit.net\" target=\"_blank\" rel=\"noopener\">octokit.net专门 </a>用于GitHub API，<a href=\"https://github.com/facebook-csharp-sdk/facebook-csharp-sdk\" target=\"_blank\" rel=\"noopener\">Facebook SDK</a> 用于使用Facebook API，并且还有许多其他功能可用于任何用途。</p>\n<p>虽然这些库是专门为这些API而设计的，并且可能擅长于它们的用途，但它们的用途是有限的，因为您经常需要在应用程序中连接多个<a href=\"https://code-maze.com/ultimate-aspnet-core-3-web-api/\" target=\"_blank\" rel=\"noopener\">API</a>。这可能会导致每个实现都有不同的实现方式，以及更多的依赖关系，这可能导致重复并且容易出错。库越具体，其灵活性就越差。</p>\n<h2 id=\"GitHub上的源代码\"><a href=\"#GitHub上的源代码\" class=\"headerlink\" title=\"GitHub上的源代码\"></a>GitHub上的源代码</h2><p><a href=\"https://github.com/CodeMazeBlog/ConsumeRestfulApisExamples\" target=\"_blank\" rel=\"noopener\">GitHub上的源代码</a></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>因此，总而言之，我们已经讨论了可用于使用RESTful API的不同工具。我们已经提到了一些.NET库，可以这样做<code>HttpWebRequest</code>，<code>WebClient</code>和<code>HttpClient</code>，以及一些惊人的第三方工具，如RestSharp和ServiceStack。您还对这些工具进行了简短的介绍，并给出了一些非常简单的示例来向您展示如何开始使用它们。</p>\n<p>我认为您现在至少有95％准备使用一些REST。继续展开翅膀，探索并找到更多有趣且有趣的方式来使用和连接不同的API。</p>\n"},{"title":"如何在ASP.NET Core中使用SignalR构建与Angular通信的实时通信应用程序","date":"2020-06-25T12:05:00.000Z","author":"邹溪源","_content":"![图片](https://uploader.shimo.im/f/ByiYlxtK4DIP8lsr.png!thumbnail)\n\n假设我们要创建一个监视Web应用程序，该应用程序为用户提供了一个能够显示一系列信息的仪表板，这些信息会随着时间的推移而更新。\n\n第一种方法是在定义的时间间隔（*轮询*）定期调用API 以更新仪表板上的数据。\n\n无论如何，还是有一个问题：如果没有更新的数据，我们会因请求而不必要地增加网络流量。一种替代方法是*长轮询*技术：如果服务器没有可用数据，则它可以使请求保持活动状态，直到发生某种情况或达到预设的超时时间为止，而不是发送空响应。如果存在新数据，则完整的响应将到达客户端。完全不同的方法是反转角色：当有新数据可用（推送）时，后端与客户端联系。\n\n请记住，HTML 5具有标准化的WebSocket，这是一个永久的双向连接，可以在兼容的浏览器中使用Javascript接口进行配置。不幸的是，必须在客户端和服务器端都对WebSocket提供完全支持，以使其可用。然后，我们需要提供替代系统（*fallback*），无论如何，该替代系统都允许我们的应用程序运行。\n\n微软于2013年发布了一个名为**SignalR** for **ASP.NET**的开源库，该库**已于** 2018年为ASP.NET Core进行了重写。SignalR从与通信机制有关的所有细节中进行抽象，并从可用的信息中选择最佳的一种。结果是有可能编写代码，就像我们一直处于*push-mode一样*。使用SignalR，服务器可以在其所有连接的客户端或特定客户端上调用JavaScript方法。\n\n我们使用web-api模板创建一个ASP.NET Core项目，删除已生成的示例控制器。使用NuGet，我们将*Microsoft.AspNet.SignalR*添加到项目中，以创建**Hub**。集线器是能够调用客户端代码，发送包含所请求方法的名称和参数的消息的高级管道。作为参数发送的对象将使用适当的协议反序列化。客户端在页面代码中搜索与名称相对应的方法，如果找到该名称，则将其调用并传递反序列化的数据作为参数。\n\n```plain\nusing Microsoft.AspNetCore.SignalR;\n \nnamespace SignalR.Hubs\n{\n    public class NotificationHub : Hub { }\n}\n```\n您可能知道，在ASP.NET Core中，可以配置HTTP请求的管理管道，以添加一些**中间件**，该**中间件**可拦截请求，添加已配置的功能并使其进入下一个中间件。必须预先配置SignalR中间件，在**Startup**  类的*ConfigureServices*方法中添加扩展方法*services.AddSignalR（）*。现在，我们可以使用Startup类的*Configure*方法中的扩展方法app.UseSignalR（）将中间件添加到管道中。在此操作期间，我们可以传递配置参数，包括集线器的路由：\n```plain\napp.UseSignalR(route =>\n{\n    route.MapHub<notificationhub>(\"/notificationHub\");\n})\n```\n一个有趣的场景允许我们查看ASP.NET Core中的另一个有趣功能，即在**后台工作**进程上下文中*托管* SignalR Hub 。\n假设我们要实现以下用例：\n\n* 运行业务逻辑\n* 等一下\n* 决定是停止还是重复该过程。\n\n在ASP.NET Core中，我们可以使用框架提供的*IHostedService*接口在.NET Core应用程序中在后台实现进程的执行。方法要实现是*StartAsync（）*和*StopAsync（） *。非常简单：StartAsync调用到主机启动，而StopAsync调用到主机关闭。\n\n然后，我们将一个类*DashboardHostedService*添加到项目中，该类实现*IHostedService*。我们在Startup类的*ConfigureServices*方法中添加接口注册：\n\n```plain\nservices.AddHostedService<dashboardhostedservice>();\n```\n在类构造函数*DashboardHostedService中，*我们注入*IHubContext* 访问添加到我们应用程序的集线器。\n在方法StartAsync中，我们设置了一个计时器，它将每两秒钟运行一次方法DoWork（）中包含的代码。此方法发送带有四个随意生成的字符串的消息。\n\n但是它向谁传播呢？在我们的示例中，我们正在将消息发送到所有连接的客户端。但是，SignalR提供了向单个用户或用户组发送消息的机会。在[本文中](https://docs.microsoft.com/en-us/aspnet/core/signalr/groups?view=aspnetcore-2.2)，您将找到涉及ASP.NET Core中的身份验证和授权功能的详细信息。有趣的是，用户可以同时在台式机和移动设备上连接。每个设备都有一个单独的SignalR连接，但是它们都将与同一用户关联。\n\n```plain\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.Extensions.Hosting;\nusing SignalR.Hubs;\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\n \nnamespace SignalR\n{\n    public class DashboardHostedService: IHostedService\n    {\n        private Timer _timer;\n        private readonly IHubContext<notificationhub> _hubContext;\n \n        public DashboardHostedService(IHubContext<notificationhub> hubContext)\n        {\n            _hubContext = hubContext;\n        }\n \n        public Task StartAsync(CancellationToken cancellationToken)\n        {\n            _timer = new Timer(DoWork, null, TimeSpan.Zero,\n            TimeSpan.FromSeconds(2));\n \n            return Task.CompletedTask;\n        }\n \n        private void DoWork(object state)\n        {\n            _hubContext.Clients.All.SendAsync(\"SendMessage\", \n                new {\n                    val1 = getRandomString(),\n                    val2 = getRandomString(),\n                    val3 = getRandomString(),\n                    val4 = getRandomString()\n                });\n        }\n \n        public Task StopAsync(CancellationToken cancellationToken)\n        {\n            _timer?.Change(Timeout.Infinite, 0);\n \n            return Task.CompletedTask;\n        }\n    }\n}\n```\n让我们看看如何管理客户端部分。例如，我们使用Angular CLI的*ng new SignalR*命令创建Angular应用程序。然后我们安装SignalR的包节点（*npm i @ aspnet / signalr*）。然后添加一个服务，该服务使我们可以连接到先前创建的集线器并接收消息。\n在这里，第一种可能的方法是，基于服务getMessage（）中Observable <Message>的服务，通过使用私有声明的Subject <Message>来返回（Message是与从Object返回的对象相对应的Typescript接口。后端）：\n\n```plain\n@Injectable({\n providedIn: 'root'\n})\nexport class SignalRService {\n private message$: Subject<message>;\n private connection: signalR.HubConnection;\n \n constructor() {\n   this.message$ = new Subject<message>();\n   this.connection = new signalR.HubConnectionBuilder()\n   .withUrl(environment.hubUrl)\n   .build();\n   this.connect();\n }\n private connect() {\n   this.connection.start().catch(err => console.log(err));\n   this.connection.on('SendMessage', (message) => {\n     this.message$.next(message);\n   });\n }\n public getMessage(): Observable<message> {\n   return this.message$.asObservable();\n }\n public disconnect() {\n   this.connection.stop();\n }\n}\n```\n在constructor（）内部，我们创建一个SignalR.HubConnection类型对象，该对象将用于连接到服务器。我们通过使用文件environment.ts将其传递到其中心URL：\n```plain\nthis.connection = new signalR.HubConnectionBuilder()\n   .withUrl(environment.hubUrl)\n   .build();\n```\n构造函数还负责调用connect（）方法，该方法进行实际连接，并在控制台中记录可能的错误。\n```plain\nthis.connection.start().catch(err => console.log(err));\nthis.connection.on('SendMessage', (message) => {\n  this.message$.next(message);\n});\n```\n想要显示来自后端的消息的组件（将其注入到构造函数中的服务），应该订阅getMessage（）方法并管理到达的消息。以AppComponent为例，例如：\n```plain\n@Component({\n selector: 'app-root',\n templateUrl: './app.component.html',\n styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnDestroy {\n private signalRSubscription: Subscription;\n \n public content: Message;\n \n constructor(private signalrService: SignalRService) {\n   this.signalRSubscription = this.signalrService.getMessage().subscribe(\n     (message) => {\n       this.content = message;\n   });\n }\n ngOnDestroy(): void {\n   this.signalrService.disconnect();\n   this.signalRSubscription.unsubscribe();\n }\n}\n```\n使用主题<Message>允许我们同时管理更多组件，而无论从中心返回的消息（用于订阅还是用于取消订阅）都可以，但是我们必须注意对主题的粗心使用。让我们考虑以下getMessage（）版本：\n```plain\npublic getMessage(): Observable<message> {\n   return this.message$;\n}\n```\n现在，该组件也可以使用以下简单代码发送一条消息：\n```plain\nconst produceMessage = this.signalrService.getMessage() as Subject<any>;\n produceMessage.next( {val1: 'a'});\n</any>\n```\n如果方法getMessage（）返回Subject <Message> asObservable，则此代码将引发异常！\n我们可以在单个组件的情况下使用的第二种方法（更简单）对管理来自后端的消息感兴趣：\n\n```plain\n@Injectable({\n providedIn: 'root'\n})\nexport class SignalrService {\n connection: signalR.HubConnection;\n \n constructor() {\n   this.connection = new signalR.HubConnectionBuilder()\n   .withUrl(environment.hubAddress)\n   .build();\n   this.connect();\n }\n \n public connect() {\n   if (this.connection.state === signalR.HubConnectionState.Disconnected) {\n     this.connection.start().catch(err => console.log(err));\n   }\n }\n \n public getMessage(next) {\n     this.connection.on('SendMessage', (message) => {\n       next(message);\n     });\n }\n \n public disconnect() {\n   this.connection.stop();\n }\n}\n```\n我们可以简单地将函数回调传递给方法getMessage，该函数将来自后端的消息作为参数。在这种情况下，AppComponent可以成为：\n```plain\npublic content: IMessage;\nconstructor(private signalrService: SignalrService) {\n   this.signalrService.getMessage(\n     (message: IMessage) => {\n       this.content = message;\n     }\n   );\n}\nngOnDestroy(): void {\n   this.signalrService.disconnect();\n}\n```\n最后几行代码分别位于*app.component.html*和*app.component.css中*，以赋予一些时尚，并且该应用程序已完成。\n```plain\n<div style=\"text-align:center\">\n  <h1>\n    DASHBOARD\n  </h1>\n</div>\n<div class=\"card-container\">\n  <div class=\"card\">\n    <div class=\"container\">\n      <h4><b>Valore 1</b></h4>\n      <p>{{content.val1}}</p>\n    </div>\n  </div>\n  <div class=\"card\">\n    <div class=\"container\">\n      <h4><b>Valore 2</b></h4>\n      <p>{{content.val2}}</p>\n    </div>\n  </div>\n  <div class=\"card\">\n    <div class=\"container\">\n      <h4><b>Valore 3</b></h4>\n      <p>{{content.val3}}</p>\n    </div>\n  </div>\n  <div class=\"card\">\n    <div class=\"container\">\n      <h4><b>Valore 4</b></h4>\n      <p>{{content.val4}}</p>\n    </div>\n  </div>\n</div>\n \n.card-container {\n  display: flex;\n  flex-wrap: wrap;\n}\n \n.card {\n  box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);\n  transition: 0.3s;\n  width: 40%;\n  flex-grow: 1;\n  margin: 10px;\n}\n \n.card:hover {\n  box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);\n}\n \n.container {\n  padding: 2px 16px;\n}\n```\n我们首先启动后端，然后启动前端并检查最终结果：\n![图片](https://uploader.shimo.im/f/TJ3iFEnLIx8DuW8y.gif)\n\n看起来不错！您可以在这里找到代码：[https](https://github.com/AARNOLD87/SignalRWithAngular) : [//github.com/AARNOLD87/SignalRWithAngular](https://github.com/AARNOLD87/SignalRWithAngular)\n\n下次见！\n\n","source":"_posts/技术/如何在ASP.NET Core中使用SignalR构建与Angular通信的实时通信应用程序.md","raw":"---\ntitle:  如何在ASP.NET Core中使用SignalR构建与Angular通信的实时通信应用程序\ndate: 2020-6-25 20:05\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n![图片](https://uploader.shimo.im/f/ByiYlxtK4DIP8lsr.png!thumbnail)\n\n假设我们要创建一个监视Web应用程序，该应用程序为用户提供了一个能够显示一系列信息的仪表板，这些信息会随着时间的推移而更新。\n\n第一种方法是在定义的时间间隔（*轮询*）定期调用API 以更新仪表板上的数据。\n\n无论如何，还是有一个问题：如果没有更新的数据，我们会因请求而不必要地增加网络流量。一种替代方法是*长轮询*技术：如果服务器没有可用数据，则它可以使请求保持活动状态，直到发生某种情况或达到预设的超时时间为止，而不是发送空响应。如果存在新数据，则完整的响应将到达客户端。完全不同的方法是反转角色：当有新数据可用（推送）时，后端与客户端联系。\n\n请记住，HTML 5具有标准化的WebSocket，这是一个永久的双向连接，可以在兼容的浏览器中使用Javascript接口进行配置。不幸的是，必须在客户端和服务器端都对WebSocket提供完全支持，以使其可用。然后，我们需要提供替代系统（*fallback*），无论如何，该替代系统都允许我们的应用程序运行。\n\n微软于2013年发布了一个名为**SignalR** for **ASP.NET**的开源库，该库**已于** 2018年为ASP.NET Core进行了重写。SignalR从与通信机制有关的所有细节中进行抽象，并从可用的信息中选择最佳的一种。结果是有可能编写代码，就像我们一直处于*push-mode一样*。使用SignalR，服务器可以在其所有连接的客户端或特定客户端上调用JavaScript方法。\n\n我们使用web-api模板创建一个ASP.NET Core项目，删除已生成的示例控制器。使用NuGet，我们将*Microsoft.AspNet.SignalR*添加到项目中，以创建**Hub**。集线器是能够调用客户端代码，发送包含所请求方法的名称和参数的消息的高级管道。作为参数发送的对象将使用适当的协议反序列化。客户端在页面代码中搜索与名称相对应的方法，如果找到该名称，则将其调用并传递反序列化的数据作为参数。\n\n```plain\nusing Microsoft.AspNetCore.SignalR;\n \nnamespace SignalR.Hubs\n{\n    public class NotificationHub : Hub { }\n}\n```\n您可能知道，在ASP.NET Core中，可以配置HTTP请求的管理管道，以添加一些**中间件**，该**中间件**可拦截请求，添加已配置的功能并使其进入下一个中间件。必须预先配置SignalR中间件，在**Startup**  类的*ConfigureServices*方法中添加扩展方法*services.AddSignalR（）*。现在，我们可以使用Startup类的*Configure*方法中的扩展方法app.UseSignalR（）将中间件添加到管道中。在此操作期间，我们可以传递配置参数，包括集线器的路由：\n```plain\napp.UseSignalR(route =>\n{\n    route.MapHub<notificationhub>(\"/notificationHub\");\n})\n```\n一个有趣的场景允许我们查看ASP.NET Core中的另一个有趣功能，即在**后台工作**进程上下文中*托管* SignalR Hub 。\n假设我们要实现以下用例：\n\n* 运行业务逻辑\n* 等一下\n* 决定是停止还是重复该过程。\n\n在ASP.NET Core中，我们可以使用框架提供的*IHostedService*接口在.NET Core应用程序中在后台实现进程的执行。方法要实现是*StartAsync（）*和*StopAsync（） *。非常简单：StartAsync调用到主机启动，而StopAsync调用到主机关闭。\n\n然后，我们将一个类*DashboardHostedService*添加到项目中，该类实现*IHostedService*。我们在Startup类的*ConfigureServices*方法中添加接口注册：\n\n```plain\nservices.AddHostedService<dashboardhostedservice>();\n```\n在类构造函数*DashboardHostedService中，*我们注入*IHubContext* 访问添加到我们应用程序的集线器。\n在方法StartAsync中，我们设置了一个计时器，它将每两秒钟运行一次方法DoWork（）中包含的代码。此方法发送带有四个随意生成的字符串的消息。\n\n但是它向谁传播呢？在我们的示例中，我们正在将消息发送到所有连接的客户端。但是，SignalR提供了向单个用户或用户组发送消息的机会。在[本文中](https://docs.microsoft.com/en-us/aspnet/core/signalr/groups?view=aspnetcore-2.2)，您将找到涉及ASP.NET Core中的身份验证和授权功能的详细信息。有趣的是，用户可以同时在台式机和移动设备上连接。每个设备都有一个单独的SignalR连接，但是它们都将与同一用户关联。\n\n```plain\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.Extensions.Hosting;\nusing SignalR.Hubs;\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\n \nnamespace SignalR\n{\n    public class DashboardHostedService: IHostedService\n    {\n        private Timer _timer;\n        private readonly IHubContext<notificationhub> _hubContext;\n \n        public DashboardHostedService(IHubContext<notificationhub> hubContext)\n        {\n            _hubContext = hubContext;\n        }\n \n        public Task StartAsync(CancellationToken cancellationToken)\n        {\n            _timer = new Timer(DoWork, null, TimeSpan.Zero,\n            TimeSpan.FromSeconds(2));\n \n            return Task.CompletedTask;\n        }\n \n        private void DoWork(object state)\n        {\n            _hubContext.Clients.All.SendAsync(\"SendMessage\", \n                new {\n                    val1 = getRandomString(),\n                    val2 = getRandomString(),\n                    val3 = getRandomString(),\n                    val4 = getRandomString()\n                });\n        }\n \n        public Task StopAsync(CancellationToken cancellationToken)\n        {\n            _timer?.Change(Timeout.Infinite, 0);\n \n            return Task.CompletedTask;\n        }\n    }\n}\n```\n让我们看看如何管理客户端部分。例如，我们使用Angular CLI的*ng new SignalR*命令创建Angular应用程序。然后我们安装SignalR的包节点（*npm i @ aspnet / signalr*）。然后添加一个服务，该服务使我们可以连接到先前创建的集线器并接收消息。\n在这里，第一种可能的方法是，基于服务getMessage（）中Observable <Message>的服务，通过使用私有声明的Subject <Message>来返回（Message是与从Object返回的对象相对应的Typescript接口。后端）：\n\n```plain\n@Injectable({\n providedIn: 'root'\n})\nexport class SignalRService {\n private message$: Subject<message>;\n private connection: signalR.HubConnection;\n \n constructor() {\n   this.message$ = new Subject<message>();\n   this.connection = new signalR.HubConnectionBuilder()\n   .withUrl(environment.hubUrl)\n   .build();\n   this.connect();\n }\n private connect() {\n   this.connection.start().catch(err => console.log(err));\n   this.connection.on('SendMessage', (message) => {\n     this.message$.next(message);\n   });\n }\n public getMessage(): Observable<message> {\n   return this.message$.asObservable();\n }\n public disconnect() {\n   this.connection.stop();\n }\n}\n```\n在constructor（）内部，我们创建一个SignalR.HubConnection类型对象，该对象将用于连接到服务器。我们通过使用文件environment.ts将其传递到其中心URL：\n```plain\nthis.connection = new signalR.HubConnectionBuilder()\n   .withUrl(environment.hubUrl)\n   .build();\n```\n构造函数还负责调用connect（）方法，该方法进行实际连接，并在控制台中记录可能的错误。\n```plain\nthis.connection.start().catch(err => console.log(err));\nthis.connection.on('SendMessage', (message) => {\n  this.message$.next(message);\n});\n```\n想要显示来自后端的消息的组件（将其注入到构造函数中的服务），应该订阅getMessage（）方法并管理到达的消息。以AppComponent为例，例如：\n```plain\n@Component({\n selector: 'app-root',\n templateUrl: './app.component.html',\n styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnDestroy {\n private signalRSubscription: Subscription;\n \n public content: Message;\n \n constructor(private signalrService: SignalRService) {\n   this.signalRSubscription = this.signalrService.getMessage().subscribe(\n     (message) => {\n       this.content = message;\n   });\n }\n ngOnDestroy(): void {\n   this.signalrService.disconnect();\n   this.signalRSubscription.unsubscribe();\n }\n}\n```\n使用主题<Message>允许我们同时管理更多组件，而无论从中心返回的消息（用于订阅还是用于取消订阅）都可以，但是我们必须注意对主题的粗心使用。让我们考虑以下getMessage（）版本：\n```plain\npublic getMessage(): Observable<message> {\n   return this.message$;\n}\n```\n现在，该组件也可以使用以下简单代码发送一条消息：\n```plain\nconst produceMessage = this.signalrService.getMessage() as Subject<any>;\n produceMessage.next( {val1: 'a'});\n</any>\n```\n如果方法getMessage（）返回Subject <Message> asObservable，则此代码将引发异常！\n我们可以在单个组件的情况下使用的第二种方法（更简单）对管理来自后端的消息感兴趣：\n\n```plain\n@Injectable({\n providedIn: 'root'\n})\nexport class SignalrService {\n connection: signalR.HubConnection;\n \n constructor() {\n   this.connection = new signalR.HubConnectionBuilder()\n   .withUrl(environment.hubAddress)\n   .build();\n   this.connect();\n }\n \n public connect() {\n   if (this.connection.state === signalR.HubConnectionState.Disconnected) {\n     this.connection.start().catch(err => console.log(err));\n   }\n }\n \n public getMessage(next) {\n     this.connection.on('SendMessage', (message) => {\n       next(message);\n     });\n }\n \n public disconnect() {\n   this.connection.stop();\n }\n}\n```\n我们可以简单地将函数回调传递给方法getMessage，该函数将来自后端的消息作为参数。在这种情况下，AppComponent可以成为：\n```plain\npublic content: IMessage;\nconstructor(private signalrService: SignalrService) {\n   this.signalrService.getMessage(\n     (message: IMessage) => {\n       this.content = message;\n     }\n   );\n}\nngOnDestroy(): void {\n   this.signalrService.disconnect();\n}\n```\n最后几行代码分别位于*app.component.html*和*app.component.css中*，以赋予一些时尚，并且该应用程序已完成。\n```plain\n<div style=\"text-align:center\">\n  <h1>\n    DASHBOARD\n  </h1>\n</div>\n<div class=\"card-container\">\n  <div class=\"card\">\n    <div class=\"container\">\n      <h4><b>Valore 1</b></h4>\n      <p>{{content.val1}}</p>\n    </div>\n  </div>\n  <div class=\"card\">\n    <div class=\"container\">\n      <h4><b>Valore 2</b></h4>\n      <p>{{content.val2}}</p>\n    </div>\n  </div>\n  <div class=\"card\">\n    <div class=\"container\">\n      <h4><b>Valore 3</b></h4>\n      <p>{{content.val3}}</p>\n    </div>\n  </div>\n  <div class=\"card\">\n    <div class=\"container\">\n      <h4><b>Valore 4</b></h4>\n      <p>{{content.val4}}</p>\n    </div>\n  </div>\n</div>\n \n.card-container {\n  display: flex;\n  flex-wrap: wrap;\n}\n \n.card {\n  box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);\n  transition: 0.3s;\n  width: 40%;\n  flex-grow: 1;\n  margin: 10px;\n}\n \n.card:hover {\n  box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);\n}\n \n.container {\n  padding: 2px 16px;\n}\n```\n我们首先启动后端，然后启动前端并检查最终结果：\n![图片](https://uploader.shimo.im/f/TJ3iFEnLIx8DuW8y.gif)\n\n看起来不错！您可以在这里找到代码：[https](https://github.com/AARNOLD87/SignalRWithAngular) : [//github.com/AARNOLD87/SignalRWithAngular](https://github.com/AARNOLD87/SignalRWithAngular)\n\n下次见！\n\n","slug":"技术/如何在ASP.NET Core中使用SignalR构建与Angular通信的实时通信应用程序","published":1,"updated":"2020-06-25T13:59:43.054Z","_id":"ckbuujt7q001dn4vic76zncve","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://uploader.shimo.im/f/ByiYlxtK4DIP8lsr.png!thumbnail\" alt=\"图片\"></p>\n<p>假设我们要创建一个监视Web应用程序，该应用程序为用户提供了一个能够显示一系列信息的仪表板，这些信息会随着时间的推移而更新。</p>\n<p>第一种方法是在定义的时间间隔（<em>轮询</em>）定期调用API 以更新仪表板上的数据。</p>\n<p>无论如何，还是有一个问题：如果没有更新的数据，我们会因请求而不必要地增加网络流量。一种替代方法是<em>长轮询</em>技术：如果服务器没有可用数据，则它可以使请求保持活动状态，直到发生某种情况或达到预设的超时时间为止，而不是发送空响应。如果存在新数据，则完整的响应将到达客户端。完全不同的方法是反转角色：当有新数据可用（推送）时，后端与客户端联系。</p>\n<p>请记住，HTML 5具有标准化的WebSocket，这是一个永久的双向连接，可以在兼容的浏览器中使用Javascript接口进行配置。不幸的是，必须在客户端和服务器端都对WebSocket提供完全支持，以使其可用。然后，我们需要提供替代系统（<em>fallback</em>），无论如何，该替代系统都允许我们的应用程序运行。</p>\n<p>微软于2013年发布了一个名为<strong>SignalR</strong> for <strong>ASP.NET</strong>的开源库，该库<strong>已于</strong> 2018年为ASP.NET Core进行了重写。SignalR从与通信机制有关的所有细节中进行抽象，并从可用的信息中选择最佳的一种。结果是有可能编写代码，就像我们一直处于<em>push-mode一样</em>。使用SignalR，服务器可以在其所有连接的客户端或特定客户端上调用JavaScript方法。</p>\n<p>我们使用web-api模板创建一个ASP.NET Core项目，删除已生成的示例控制器。使用NuGet，我们将<em>Microsoft.AspNet.SignalR</em>添加到项目中，以创建<strong>Hub</strong>。集线器是能够调用客户端代码，发送包含所请求方法的名称和参数的消息的高级管道。作为参数发送的对象将使用适当的协议反序列化。客户端在页面代码中搜索与名称相对应的方法，如果找到该名称，则将其调用并传递反序列化的数据作为参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Microsoft.AspNetCore.SignalR;</span><br><span class=\"line\"> </span><br><span class=\"line\">namespace SignalR.Hubs</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public class NotificationHub : Hub &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>您可能知道，在ASP.NET Core中，可以配置HTTP请求的管理管道，以添加一些<strong>中间件</strong>，该<strong>中间件</strong>可拦截请求，添加已配置的功能并使其进入下一个中间件。必须预先配置SignalR中间件，在<strong>Startup</strong>  类的<em>ConfigureServices</em>方法中添加扩展方法<em>services.AddSignalR（）</em>。现在，我们可以使用Startup类的<em>Configure</em>方法中的扩展方法app.UseSignalR（）将中间件添加到管道中。在此操作期间，我们可以传递配置参数，包括集线器的路由：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.UseSignalR(route =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    route.MapHub&lt;notificationhub&gt;(&quot;/notificationHub&quot;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>一个有趣的场景允许我们查看ASP.NET Core中的另一个有趣功能，即在<strong>后台工作</strong>进程上下文中<em>托管</em> SignalR Hub 。<br>假设我们要实现以下用例：</p>\n<ul>\n<li>运行业务逻辑</li>\n<li>等一下</li>\n<li>决定是停止还是重复该过程。</li>\n</ul>\n<p>在ASP.NET Core中，我们可以使用框架提供的<em>IHostedService</em>接口在.NET Core应用程序中在后台实现进程的执行。方法要实现是<em>StartAsync（）</em>和*StopAsync（） *。非常简单：StartAsync调用到主机启动，而StopAsync调用到主机关闭。</p>\n<p>然后，我们将一个类<em>DashboardHostedService</em>添加到项目中，该类实现<em>IHostedService</em>。我们在Startup类的<em>ConfigureServices</em>方法中添加接口注册：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">services.AddHostedService&lt;dashboardhostedservice&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>在类构造函数<em>DashboardHostedService中，<em>我们注入</em>IHubContext</em> 访问添加到我们应用程序的集线器。<br>在方法StartAsync中，我们设置了一个计时器，它将每两秒钟运行一次方法DoWork（）中包含的代码。此方法发送带有四个随意生成的字符串的消息。</p>\n<p>但是它向谁传播呢？在我们的示例中，我们正在将消息发送到所有连接的客户端。但是，SignalR提供了向单个用户或用户组发送消息的机会。在<a href=\"https://docs.microsoft.com/en-us/aspnet/core/signalr/groups?view=aspnetcore-2.2\" target=\"_blank\" rel=\"noopener\">本文中</a>，您将找到涉及ASP.NET Core中的身份验证和授权功能的详细信息。有趣的是，用户可以同时在台式机和移动设备上连接。每个设备都有一个单独的SignalR连接，但是它们都将与同一用户关联。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Microsoft.AspNetCore.SignalR;</span><br><span class=\"line\">using Microsoft.Extensions.Hosting;</span><br><span class=\"line\">using SignalR.Hubs;</span><br><span class=\"line\">using System;</span><br><span class=\"line\">using System.Linq;</span><br><span class=\"line\">using System.Threading;</span><br><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\"> </span><br><span class=\"line\">namespace SignalR</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public class DashboardHostedService: IHostedService</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private Timer _timer;</span><br><span class=\"line\">        private readonly IHubContext&lt;notificationhub&gt; _hubContext;</span><br><span class=\"line\"> </span><br><span class=\"line\">        public DashboardHostedService(IHubContext&lt;notificationhub&gt; hubContext)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _hubContext = hubContext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        public Task StartAsync(CancellationToken cancellationToken)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _timer = new Timer(DoWork, null, TimeSpan.Zero,</span><br><span class=\"line\">            TimeSpan.FromSeconds(2));</span><br><span class=\"line\"> </span><br><span class=\"line\">            return Task.CompletedTask;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        private void DoWork(object state)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _hubContext.Clients.All.SendAsync(&quot;SendMessage&quot;, </span><br><span class=\"line\">                new &#123;</span><br><span class=\"line\">                    val1 = getRandomString(),</span><br><span class=\"line\">                    val2 = getRandomString(),</span><br><span class=\"line\">                    val3 = getRandomString(),</span><br><span class=\"line\">                    val4 = getRandomString()</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        public Task StopAsync(CancellationToken cancellationToken)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _timer?.Change(Timeout.Infinite, 0);</span><br><span class=\"line\"> </span><br><span class=\"line\">            return Task.CompletedTask;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>让我们看看如何管理客户端部分。例如，我们使用Angular CLI的<em>ng new SignalR</em>命令创建Angular应用程序。然后我们安装SignalR的包节点（<em>npm i @ aspnet / signalr</em>）。然后添加一个服务，该服务使我们可以连接到先前创建的集线器并接收消息。<br>在这里，第一种可能的方法是，基于服务getMessage（）中Observable <message>的服务，通过使用私有声明的Subject <message>来返回（Message是与从Object返回的对象相对应的Typescript接口。后端）：</message></message></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Injectable(&#123;</span><br><span class=\"line\"> providedIn: &apos;root&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class SignalRService &#123;</span><br><span class=\"line\"> private message$: Subject&lt;message&gt;;</span><br><span class=\"line\"> private connection: signalR.HubConnection;</span><br><span class=\"line\"> </span><br><span class=\"line\"> constructor() &#123;</span><br><span class=\"line\">   this.message$ = new Subject&lt;message&gt;();</span><br><span class=\"line\">   this.connection = new signalR.HubConnectionBuilder()</span><br><span class=\"line\">   .withUrl(environment.hubUrl)</span><br><span class=\"line\">   .build();</span><br><span class=\"line\">   this.connect();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> private connect() &#123;</span><br><span class=\"line\">   this.connection.start().catch(err =&gt; console.log(err));</span><br><span class=\"line\">   this.connection.on(&apos;SendMessage&apos;, (message) =&gt; &#123;</span><br><span class=\"line\">     this.message$.next(message);</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> public getMessage(): Observable&lt;message&gt; &#123;</span><br><span class=\"line\">   return this.message$.asObservable();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> public disconnect() &#123;</span><br><span class=\"line\">   this.connection.stop();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在constructor（）内部，我们创建一个SignalR.HubConnection类型对象，该对象将用于连接到服务器。我们通过使用文件environment.ts将其传递到其中心URL：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.connection = new signalR.HubConnectionBuilder()</span><br><span class=\"line\">   .withUrl(environment.hubUrl)</span><br><span class=\"line\">   .build();</span><br></pre></td></tr></table></figure>\n\n<p>构造函数还负责调用connect（）方法，该方法进行实际连接，并在控制台中记录可能的错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.connection.start().catch(err =&gt; console.log(err));</span><br><span class=\"line\">this.connection.on(&apos;SendMessage&apos;, (message) =&gt; &#123;</span><br><span class=\"line\">  this.message$.next(message);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>想要显示来自后端的消息的组件（将其注入到构造函数中的服务），应该订阅getMessage（）方法并管理到达的消息。以AppComponent为例，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component(&#123;</span><br><span class=\"line\"> selector: &apos;app-root&apos;,</span><br><span class=\"line\"> templateUrl: &apos;./app.component.html&apos;,</span><br><span class=\"line\"> styleUrls: [&apos;./app.component.css&apos;]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class AppComponent implements OnDestroy &#123;</span><br><span class=\"line\"> private signalRSubscription: Subscription;</span><br><span class=\"line\"> </span><br><span class=\"line\"> public content: Message;</span><br><span class=\"line\"> </span><br><span class=\"line\"> constructor(private signalrService: SignalRService) &#123;</span><br><span class=\"line\">   this.signalRSubscription = this.signalrService.getMessage().subscribe(</span><br><span class=\"line\">     (message) =&gt; &#123;</span><br><span class=\"line\">       this.content = message;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> ngOnDestroy(): void &#123;</span><br><span class=\"line\">   this.signalrService.disconnect();</span><br><span class=\"line\">   this.signalRSubscription.unsubscribe();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用主题<message>允许我们同时管理更多组件，而无论从中心返回的消息（用于订阅还是用于取消订阅）都可以，但是我们必须注意对主题的粗心使用。让我们考虑以下getMessage（）版本：</message></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public getMessage(): Observable&lt;message&gt; &#123;</span><br><span class=\"line\">   return this.message$;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，该组件也可以使用以下简单代码发送一条消息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const produceMessage = this.signalrService.getMessage() as Subject&lt;any&gt;;</span><br><span class=\"line\"> produceMessage.next( &#123;val1: &apos;a&apos;&#125;);</span><br><span class=\"line\">&lt;/any&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果方法getMessage（）返回Subject <message> asObservable，则此代码将引发异常！<br>我们可以在单个组件的情况下使用的第二种方法（更简单）对管理来自后端的消息感兴趣：</message></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Injectable(&#123;</span><br><span class=\"line\"> providedIn: &apos;root&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class SignalrService &#123;</span><br><span class=\"line\"> connection: signalR.HubConnection;</span><br><span class=\"line\"> </span><br><span class=\"line\"> constructor() &#123;</span><br><span class=\"line\">   this.connection = new signalR.HubConnectionBuilder()</span><br><span class=\"line\">   .withUrl(environment.hubAddress)</span><br><span class=\"line\">   .build();</span><br><span class=\"line\">   this.connect();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> public connect() &#123;</span><br><span class=\"line\">   if (this.connection.state === signalR.HubConnectionState.Disconnected) &#123;</span><br><span class=\"line\">     this.connection.start().catch(err =&gt; console.log(err));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> public getMessage(next) &#123;</span><br><span class=\"line\">     this.connection.on(&apos;SendMessage&apos;, (message) =&gt; &#123;</span><br><span class=\"line\">       next(message);</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> public disconnect() &#123;</span><br><span class=\"line\">   this.connection.stop();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以简单地将函数回调传递给方法getMessage，该函数将来自后端的消息作为参数。在这种情况下，AppComponent可以成为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public content: IMessage;</span><br><span class=\"line\">constructor(private signalrService: SignalrService) &#123;</span><br><span class=\"line\">   this.signalrService.getMessage(</span><br><span class=\"line\">     (message: IMessage) =&gt; &#123;</span><br><span class=\"line\">       this.content = message;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ngOnDestroy(): void &#123;</span><br><span class=\"line\">   this.signalrService.disconnect();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后几行代码分别位于<em>app.component.html</em>和<em>app.component.css中</em>，以赋予一些时尚，并且该应用程序已完成。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&quot;text-align:center&quot;&gt;</span><br><span class=\"line\">  &lt;h1&gt;</span><br><span class=\"line\">    DASHBOARD</span><br><span class=\"line\">  &lt;/h1&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;card-container&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;card&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">      &lt;h4&gt;&lt;b&gt;Valore 1&lt;/b&gt;&lt;/h4&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;&#123;content.val1&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;card&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">      &lt;h4&gt;&lt;b&gt;Valore 2&lt;/b&gt;&lt;/h4&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;&#123;content.val2&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;card&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">      &lt;h4&gt;&lt;b&gt;Valore 3&lt;/b&gt;&lt;/h4&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;&#123;content.val3&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;card&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">      &lt;h4&gt;&lt;b&gt;Valore 4&lt;/b&gt;&lt;/h4&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;&#123;content.val4&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">.card-container &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-wrap: wrap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">.card &#123;</span><br><span class=\"line\">  box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);</span><br><span class=\"line\">  transition: 0.3s;</span><br><span class=\"line\">  width: 40%;</span><br><span class=\"line\">  flex-grow: 1;</span><br><span class=\"line\">  margin: 10px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">.card:hover &#123;</span><br><span class=\"line\">  box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">  padding: 2px 16px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们首先启动后端，然后启动前端并检查最终结果：<br><img src=\"https://uploader.shimo.im/f/TJ3iFEnLIx8DuW8y.gif\" alt=\"图片\"></p>\n<p>看起来不错！您可以在这里找到代码：<a href=\"https://github.com/AARNOLD87/SignalRWithAngular\" target=\"_blank\" rel=\"noopener\">https</a> : <a href=\"https://github.com/AARNOLD87/SignalRWithAngular\" target=\"_blank\" rel=\"noopener\">//github.com/AARNOLD87/SignalRWithAngular</a></p>\n<p>下次见！</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://uploader.shimo.im/f/ByiYlxtK4DIP8lsr.png!thumbnail\" alt=\"图片\"></p>\n<p>假设我们要创建一个监视Web应用程序，该应用程序为用户提供了一个能够显示一系列信息的仪表板，这些信息会随着时间的推移而更新。</p>\n<p>第一种方法是在定义的时间间隔（<em>轮询</em>）定期调用API 以更新仪表板上的数据。</p>\n<p>无论如何，还是有一个问题：如果没有更新的数据，我们会因请求而不必要地增加网络流量。一种替代方法是<em>长轮询</em>技术：如果服务器没有可用数据，则它可以使请求保持活动状态，直到发生某种情况或达到预设的超时时间为止，而不是发送空响应。如果存在新数据，则完整的响应将到达客户端。完全不同的方法是反转角色：当有新数据可用（推送）时，后端与客户端联系。</p>\n<p>请记住，HTML 5具有标准化的WebSocket，这是一个永久的双向连接，可以在兼容的浏览器中使用Javascript接口进行配置。不幸的是，必须在客户端和服务器端都对WebSocket提供完全支持，以使其可用。然后，我们需要提供替代系统（<em>fallback</em>），无论如何，该替代系统都允许我们的应用程序运行。</p>\n<p>微软于2013年发布了一个名为<strong>SignalR</strong> for <strong>ASP.NET</strong>的开源库，该库<strong>已于</strong> 2018年为ASP.NET Core进行了重写。SignalR从与通信机制有关的所有细节中进行抽象，并从可用的信息中选择最佳的一种。结果是有可能编写代码，就像我们一直处于<em>push-mode一样</em>。使用SignalR，服务器可以在其所有连接的客户端或特定客户端上调用JavaScript方法。</p>\n<p>我们使用web-api模板创建一个ASP.NET Core项目，删除已生成的示例控制器。使用NuGet，我们将<em>Microsoft.AspNet.SignalR</em>添加到项目中，以创建<strong>Hub</strong>。集线器是能够调用客户端代码，发送包含所请求方法的名称和参数的消息的高级管道。作为参数发送的对象将使用适当的协议反序列化。客户端在页面代码中搜索与名称相对应的方法，如果找到该名称，则将其调用并传递反序列化的数据作为参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Microsoft.AspNetCore.SignalR;</span><br><span class=\"line\"> </span><br><span class=\"line\">namespace SignalR.Hubs</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public class NotificationHub : Hub &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>您可能知道，在ASP.NET Core中，可以配置HTTP请求的管理管道，以添加一些<strong>中间件</strong>，该<strong>中间件</strong>可拦截请求，添加已配置的功能并使其进入下一个中间件。必须预先配置SignalR中间件，在<strong>Startup</strong>  类的<em>ConfigureServices</em>方法中添加扩展方法<em>services.AddSignalR（）</em>。现在，我们可以使用Startup类的<em>Configure</em>方法中的扩展方法app.UseSignalR（）将中间件添加到管道中。在此操作期间，我们可以传递配置参数，包括集线器的路由：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.UseSignalR(route =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    route.MapHub&lt;notificationhub&gt;(&quot;/notificationHub&quot;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>一个有趣的场景允许我们查看ASP.NET Core中的另一个有趣功能，即在<strong>后台工作</strong>进程上下文中<em>托管</em> SignalR Hub 。<br>假设我们要实现以下用例：</p>\n<ul>\n<li>运行业务逻辑</li>\n<li>等一下</li>\n<li>决定是停止还是重复该过程。</li>\n</ul>\n<p>在ASP.NET Core中，我们可以使用框架提供的<em>IHostedService</em>接口在.NET Core应用程序中在后台实现进程的执行。方法要实现是<em>StartAsync（）</em>和*StopAsync（） *。非常简单：StartAsync调用到主机启动，而StopAsync调用到主机关闭。</p>\n<p>然后，我们将一个类<em>DashboardHostedService</em>添加到项目中，该类实现<em>IHostedService</em>。我们在Startup类的<em>ConfigureServices</em>方法中添加接口注册：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">services.AddHostedService&lt;dashboardhostedservice&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>在类构造函数<em>DashboardHostedService中，<em>我们注入</em>IHubContext</em> 访问添加到我们应用程序的集线器。<br>在方法StartAsync中，我们设置了一个计时器，它将每两秒钟运行一次方法DoWork（）中包含的代码。此方法发送带有四个随意生成的字符串的消息。</p>\n<p>但是它向谁传播呢？在我们的示例中，我们正在将消息发送到所有连接的客户端。但是，SignalR提供了向单个用户或用户组发送消息的机会。在<a href=\"https://docs.microsoft.com/en-us/aspnet/core/signalr/groups?view=aspnetcore-2.2\" target=\"_blank\" rel=\"noopener\">本文中</a>，您将找到涉及ASP.NET Core中的身份验证和授权功能的详细信息。有趣的是，用户可以同时在台式机和移动设备上连接。每个设备都有一个单独的SignalR连接，但是它们都将与同一用户关联。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Microsoft.AspNetCore.SignalR;</span><br><span class=\"line\">using Microsoft.Extensions.Hosting;</span><br><span class=\"line\">using SignalR.Hubs;</span><br><span class=\"line\">using System;</span><br><span class=\"line\">using System.Linq;</span><br><span class=\"line\">using System.Threading;</span><br><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\"> </span><br><span class=\"line\">namespace SignalR</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public class DashboardHostedService: IHostedService</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private Timer _timer;</span><br><span class=\"line\">        private readonly IHubContext&lt;notificationhub&gt; _hubContext;</span><br><span class=\"line\"> </span><br><span class=\"line\">        public DashboardHostedService(IHubContext&lt;notificationhub&gt; hubContext)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _hubContext = hubContext;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        public Task StartAsync(CancellationToken cancellationToken)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _timer = new Timer(DoWork, null, TimeSpan.Zero,</span><br><span class=\"line\">            TimeSpan.FromSeconds(2));</span><br><span class=\"line\"> </span><br><span class=\"line\">            return Task.CompletedTask;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        private void DoWork(object state)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _hubContext.Clients.All.SendAsync(&quot;SendMessage&quot;, </span><br><span class=\"line\">                new &#123;</span><br><span class=\"line\">                    val1 = getRandomString(),</span><br><span class=\"line\">                    val2 = getRandomString(),</span><br><span class=\"line\">                    val3 = getRandomString(),</span><br><span class=\"line\">                    val4 = getRandomString()</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        public Task StopAsync(CancellationToken cancellationToken)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _timer?.Change(Timeout.Infinite, 0);</span><br><span class=\"line\"> </span><br><span class=\"line\">            return Task.CompletedTask;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>让我们看看如何管理客户端部分。例如，我们使用Angular CLI的<em>ng new SignalR</em>命令创建Angular应用程序。然后我们安装SignalR的包节点（<em>npm i @ aspnet / signalr</em>）。然后添加一个服务，该服务使我们可以连接到先前创建的集线器并接收消息。<br>在这里，第一种可能的方法是，基于服务getMessage（）中Observable <message>的服务，通过使用私有声明的Subject <message>来返回（Message是与从Object返回的对象相对应的Typescript接口。后端）：</message></message></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Injectable(&#123;</span><br><span class=\"line\"> providedIn: &apos;root&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class SignalRService &#123;</span><br><span class=\"line\"> private message$: Subject&lt;message&gt;;</span><br><span class=\"line\"> private connection: signalR.HubConnection;</span><br><span class=\"line\"> </span><br><span class=\"line\"> constructor() &#123;</span><br><span class=\"line\">   this.message$ = new Subject&lt;message&gt;();</span><br><span class=\"line\">   this.connection = new signalR.HubConnectionBuilder()</span><br><span class=\"line\">   .withUrl(environment.hubUrl)</span><br><span class=\"line\">   .build();</span><br><span class=\"line\">   this.connect();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> private connect() &#123;</span><br><span class=\"line\">   this.connection.start().catch(err =&gt; console.log(err));</span><br><span class=\"line\">   this.connection.on(&apos;SendMessage&apos;, (message) =&gt; &#123;</span><br><span class=\"line\">     this.message$.next(message);</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> public getMessage(): Observable&lt;message&gt; &#123;</span><br><span class=\"line\">   return this.message$.asObservable();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> public disconnect() &#123;</span><br><span class=\"line\">   this.connection.stop();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在constructor（）内部，我们创建一个SignalR.HubConnection类型对象，该对象将用于连接到服务器。我们通过使用文件environment.ts将其传递到其中心URL：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.connection = new signalR.HubConnectionBuilder()</span><br><span class=\"line\">   .withUrl(environment.hubUrl)</span><br><span class=\"line\">   .build();</span><br></pre></td></tr></table></figure>\n\n<p>构造函数还负责调用connect（）方法，该方法进行实际连接，并在控制台中记录可能的错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.connection.start().catch(err =&gt; console.log(err));</span><br><span class=\"line\">this.connection.on(&apos;SendMessage&apos;, (message) =&gt; &#123;</span><br><span class=\"line\">  this.message$.next(message);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>想要显示来自后端的消息的组件（将其注入到构造函数中的服务），应该订阅getMessage（）方法并管理到达的消息。以AppComponent为例，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component(&#123;</span><br><span class=\"line\"> selector: &apos;app-root&apos;,</span><br><span class=\"line\"> templateUrl: &apos;./app.component.html&apos;,</span><br><span class=\"line\"> styleUrls: [&apos;./app.component.css&apos;]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class AppComponent implements OnDestroy &#123;</span><br><span class=\"line\"> private signalRSubscription: Subscription;</span><br><span class=\"line\"> </span><br><span class=\"line\"> public content: Message;</span><br><span class=\"line\"> </span><br><span class=\"line\"> constructor(private signalrService: SignalRService) &#123;</span><br><span class=\"line\">   this.signalRSubscription = this.signalrService.getMessage().subscribe(</span><br><span class=\"line\">     (message) =&gt; &#123;</span><br><span class=\"line\">       this.content = message;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> ngOnDestroy(): void &#123;</span><br><span class=\"line\">   this.signalrService.disconnect();</span><br><span class=\"line\">   this.signalRSubscription.unsubscribe();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用主题<message>允许我们同时管理更多组件，而无论从中心返回的消息（用于订阅还是用于取消订阅）都可以，但是我们必须注意对主题的粗心使用。让我们考虑以下getMessage（）版本：</message></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public getMessage(): Observable&lt;message&gt; &#123;</span><br><span class=\"line\">   return this.message$;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，该组件也可以使用以下简单代码发送一条消息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const produceMessage = this.signalrService.getMessage() as Subject&lt;any&gt;;</span><br><span class=\"line\"> produceMessage.next( &#123;val1: &apos;a&apos;&#125;);</span><br><span class=\"line\">&lt;/any&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果方法getMessage（）返回Subject <message> asObservable，则此代码将引发异常！<br>我们可以在单个组件的情况下使用的第二种方法（更简单）对管理来自后端的消息感兴趣：</message></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Injectable(&#123;</span><br><span class=\"line\"> providedIn: &apos;root&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class SignalrService &#123;</span><br><span class=\"line\"> connection: signalR.HubConnection;</span><br><span class=\"line\"> </span><br><span class=\"line\"> constructor() &#123;</span><br><span class=\"line\">   this.connection = new signalR.HubConnectionBuilder()</span><br><span class=\"line\">   .withUrl(environment.hubAddress)</span><br><span class=\"line\">   .build();</span><br><span class=\"line\">   this.connect();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> public connect() &#123;</span><br><span class=\"line\">   if (this.connection.state === signalR.HubConnectionState.Disconnected) &#123;</span><br><span class=\"line\">     this.connection.start().catch(err =&gt; console.log(err));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> public getMessage(next) &#123;</span><br><span class=\"line\">     this.connection.on(&apos;SendMessage&apos;, (message) =&gt; &#123;</span><br><span class=\"line\">       next(message);</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> public disconnect() &#123;</span><br><span class=\"line\">   this.connection.stop();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以简单地将函数回调传递给方法getMessage，该函数将来自后端的消息作为参数。在这种情况下，AppComponent可以成为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public content: IMessage;</span><br><span class=\"line\">constructor(private signalrService: SignalrService) &#123;</span><br><span class=\"line\">   this.signalrService.getMessage(</span><br><span class=\"line\">     (message: IMessage) =&gt; &#123;</span><br><span class=\"line\">       this.content = message;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ngOnDestroy(): void &#123;</span><br><span class=\"line\">   this.signalrService.disconnect();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后几行代码分别位于<em>app.component.html</em>和<em>app.component.css中</em>，以赋予一些时尚，并且该应用程序已完成。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&quot;text-align:center&quot;&gt;</span><br><span class=\"line\">  &lt;h1&gt;</span><br><span class=\"line\">    DASHBOARD</span><br><span class=\"line\">  &lt;/h1&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;card-container&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;card&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">      &lt;h4&gt;&lt;b&gt;Valore 1&lt;/b&gt;&lt;/h4&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;&#123;content.val1&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;card&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">      &lt;h4&gt;&lt;b&gt;Valore 2&lt;/b&gt;&lt;/h4&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;&#123;content.val2&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;card&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">      &lt;h4&gt;&lt;b&gt;Valore 3&lt;/b&gt;&lt;/h4&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;&#123;content.val3&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;card&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">      &lt;h4&gt;&lt;b&gt;Valore 4&lt;/b&gt;&lt;/h4&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;&#123;content.val4&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">.card-container &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-wrap: wrap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">.card &#123;</span><br><span class=\"line\">  box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);</span><br><span class=\"line\">  transition: 0.3s;</span><br><span class=\"line\">  width: 40%;</span><br><span class=\"line\">  flex-grow: 1;</span><br><span class=\"line\">  margin: 10px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">.card:hover &#123;</span><br><span class=\"line\">  box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">  padding: 2px 16px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们首先启动后端，然后启动前端并检查最终结果：<br><img src=\"https://uploader.shimo.im/f/TJ3iFEnLIx8DuW8y.gif\" alt=\"图片\"></p>\n<p>看起来不错！您可以在这里找到代码：<a href=\"https://github.com/AARNOLD87/SignalRWithAngular\" target=\"_blank\" rel=\"noopener\">https</a> : <a href=\"https://github.com/AARNOLD87/SignalRWithAngular\" target=\"_blank\" rel=\"noopener\">//github.com/AARNOLD87/SignalRWithAngular</a></p>\n<p>下次见！</p>\n"},{"title":"您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术","date":"2020-04-22T14:58:00.000Z","author":"邹溪源","_content":"# 您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术\n\nC＃（通常是.NET）中的事件注册是内存泄漏的最常见原因。至少从我的经验来看。实际上，我从事件中看到了太多的内存泄漏，因此 在代码中看到 **+ =**将立即使我感到怀疑。\n\n尽管事件很常见，但它们也很危险。如果您不知道要查找的内容，则事件很容易导致内存泄漏。在本文中，我将解释此问题的根本原因，并提供几种最佳实践技术来解决该问题。最后，我将向您展示一个简单的技巧，以找出您是否确实存在内存泄漏。\n\n## 了解内存泄漏\n\n在垃圾收集环境中，术语“内存泄漏”有点反直觉。当有一个垃圾收集器负责收集所有内容时，我的内存如何泄漏？\n\n答案是，在存在垃圾收集器（**GC**）的情况下，内存泄漏表示有些对象仍在引用中，但实际上未被使用。由于已引用它们，因此GC将不会收集它们，并且它们将永久保存，占用内存。\n\n让我们来看一个例子：\n\n```\npublic class WiFiManager\n{\n    public event EventHandler <WifiEventArgs> WiFiSignalChanged;\n    // ...\n}\n```\n\n```\npublic class MyClass\n{\n    public MyClass(WiFiManager wiFiManager)\n    {\n        wiFiManager.WiFiSignalChanged += OnWiFiChanged;\n    }\n \n    private void OnWiFiChanged(object sender, WifiEventArgs e)\n    {\n        // do something\n    }\n```\n\n```\npublic void SomeOperation(WiFiManager wiFiManager)\n{\n    var myClass = new MyClass(wiFiManager);\n    myClass.DoSomething();\n    \n    //... myClass is not used again\n}\n```\n\n在此示例中，我们假设**WiFiManager** 在程序的整个生命周期中都处于活动状态。执行**SomeOperation之后**，将创建**MyClass**的实例，并且不再使用它。程序员可能会认为GC将收集它，但事实并非如此。所述**WiFiManager**保持在其事件MyClass的参考 **WiFiSignalChanged**和它引起了内存泄漏。GC将永远不会收集**MyClass**。\n\n## 1.确保退订\n\n显而易见的解决方案（尽管并非总是最简单的）是记住从事件中注销事件处理程序。一种方法是实现IDisposable：\n\n```\npublic class MyClass : IDisposable\n{\n    private readonly WiFiManager _wiFiManager;\n \n    public MyClass(WiFiManager wiFiManager)\n    {\n        _wiFiManager = wiFiManager;\n        _wiFiManager.WiFiSignalChanged += OnWiFiChanged;\n    }\n \n    public void Dispose()\n    {\n        _wiFiManager.WiFiSignalChanged -= OnWiFiChanged;\n    }\n \n    private void OnWiFiChanged(object sender, WifiEventArgs e)\n    {\n        // do something\n    }\n```\n\n当然，您必须确保调用**Dispose**。如果您有WPF控件，一个简单的解决方案是退订**Unloaded**事件。\n\n```\npublic partial class MyUserControl : UserControl\n{\n    public MyUserControl(WiFiManager wiFiManager)\n    {\n        InitializeComponent();\n        this.Loaded += (sender, args) => wiFiManager.WiFiSignalChanged += OnWiFiChanged;\n        this.Unloaded += (sender, args) => wiFiManager.WiFiSignalChanged -= OnWiFiChanged;\n    }\n \n    private void OnWiFiChanged(object sender, WifiEventArgs e)\n    {\n        // do something\n    }\n}\n```\n\n优点**：简单易读的代码。\n\n**缺点：**您很容易忘记取消订阅，或者在所有情况下都不会取消订阅，这将导致内存泄漏。\n\n###### 注意：并非所有事件注册都会导致内存泄漏。注册到将要**过期**的事件时，不会发生内存泄漏。例如，在WPF **UserControl中，**您可以注册到Button的**Click**事件。这很好，并且不需要注销，因为用户控件是唯一引用该Button的控件。如果没有一个人引用用户控件，那么也将没有一个人引用按钮，并且**GC**将同时收集两者。\n\n## 2.让处理程序退订\n\n在某些情况下，您可能希望事件处理程序仅发生一次。在这种情况下，您将希望代码自己退订。当事件处理程序是命名方法时，它很容易：\n\n```\npublic class MyClass\n{\n    private readonly WiFiManager _wiFiManager;\n \n    public MyClass(WiFiManager wiFiManager)\n    {\n        _wiFiManager = wiFiManager;\n        _wiFiManager.WiFiSignalChanged += OnWiFiChanged;\n    }\n \n    private void OnWiFiChanged(object sender, WifiEventArgs e)\n    {\n        // do something\n        _wiFiManager.WiFiSignalChanged -= OnWiFiChanged;\n    }\n}\n```\n\n但是，有时您希望事件处理程序是lambda表达式。在这种情况下，以下是一种使自己退订的有用技术：\n\n```\n\npublic class MyClass\n{\n    public MyClass(WiFiManager wiFiManager)\n    {\n        var someObject = GetSomeObject();\n        EventHandler<WifiEventArgs> handler = null;\n        handler = (sender, args) =>\n        {\n            Console.WriteLine(someObject);\n            wiFiManager.WiFiSignalChanged -= handler;\n        };\n        wiFiManager.WiFiSignalChanged += handler;\n    }\n}\n```\n\n在上面的示例中，lambda表达式非常有用，因为您可以捕获局部变量**someObject**，而使用处理程序方法则无法做到这一点。\n\n**优点：**简单，易读，只要您确定事件至少会触发一次，就不会发生内存泄漏。\n\n**缺点：**仅在需要处理一次事件的特殊情况下可用。\n\n## 3.将弱事件与事件聚合器一起使用\n\n在.NET中引用对象时，您基本上会告诉GC该对象正在使用中，因此请不要收集它。有一种引用对象的方法，而无需实际说“我正在使用它”。这种参考称为 *弱参考*。您是说“我不需要它，但是如果它仍然存在，那么我会使用它”。在其他换句话说，如果某个对象仅被弱引用引用，则**GC**会收集该对象并释放该内存。这是使用.NET的**WeakReference** 类实现的。\n\n我们可以通过多种方式使用它来防止内存泄漏。一种流行的设计模式是使用[事件聚合器](https://www.codeproject.com/Articles/812461/Event-Aggregator-Pattern)。这个概念是，任何人都可以**订阅** T类型的事件，任何人都可以**发布** T类型的事件。因此，当一个类发布事件时，将调用所有订阅的事件处理程序。事件聚合器使用WeakReference引用所有内容。所以即使有物体提斯 订阅事件，仍然可以对其进行垃圾回收。\n\n这是一个使用**Prism** 流行的事件聚合器（通过NuGet [Prism.Core提供](https://www.nuget.org/packages/Prism.Core/)）的[示例](https://www.nuget.org/packages/Prism.Core/)。\n\n```\npublic class WiFiManager\n{\n    private readonly IEventAggregator _eventAggregator;\n \n    public WiFiManager(IEventAggregator eventAggregator)\n    {\n        _eventAggregator = eventAggregator;\n    }\n \n    public void PublishEvent()\n    {\n        _eventAggregator.GetEvent<WiFiEvent>().Publish(new WifiEventArgs());\n    }\n```\n\n```\npublic class MyClass\n{\n    public MyClass(IEventAggregator eventAggregator)\n    {\n        eventAggregator.GetEvent<WiFiEvent>().Subscribe(OnWiFiChanged);\n \n    }\n \n    private void OnWiFiChanged(WifiEventArgs args)\n    {\n        // do something\n    }\n```\n\n\n\n```\npublic class WiFiEvent : PubSubEvent<WifiEventArgs>\n{\n    // ...\n}\n```\n\n**优点：** 防止内存泄漏，相对易于使用。\n\n**缺点：**\n\n 充当所有事件的全局容器。任何人都可以订阅任何人。这使得系统在过度使用时难以理解。没有分离的关注点。\n\n## 4.对常规事件使用弱事件处理程序\n\n借助一些代码技巧，可以将弱引用与常规事件一起使用。这可以通过几种不同的方式来实现。这是使用Paul Stovell的[WeakEventHandler](http://paulstovell.com/blog/weakevents)的示例：\n\n```\npublic class MyClass\n{\n    public MyClass(WiFiManager wiFiManager)\n    {\n        wiFiManager.WiFiSignalChanged += new WeakEventHandler<WifiEventArgs>(OnWiFiChanged).Handler;\n    }\n \n    private void OnWiFiChanged(object sender, WifiEventArgs e)\n    {\n        // do something\n    }\n}\n```\n\n\n\n```\n\npublic class WiFiManager\n{\n    public event EventHandler<WifiEventArgs> WiFiSignalChanged;\n    // ...\n\n```\n\n```\npublic void SomeOperation(WiFiManager wiFiManager)\n{\n    var myClass = new MyClass(wiFiManager);\n    myClass.DoSomething();\n    \n    //... myClass is not used again\n}\n```\n\n我真的很喜欢这种方法，因为在我们的案例中，发布者**WiFiManager**保留了标准的C＃事件。这只是这种模式的一种实现，但是实际上有很多方法可以解决。**Daniel Grunwald**写了[一篇](https://www.codeproject.com/Articles/29922/Weak-Events-in-C)有关不同实现及其差异的文章。\n\n**优点：**利用标准事件。简单。没有内存泄漏。关注点分离（与事件聚合器不同）。\n\n**缺点：**此模式的不同实现有一些细微之处和不同问题。该示例中的实现实际上创建了一个 注册的**包装**对象，该 **包装**对象从未被GC收集。其他实现可以解决此问题，但还有其他问题，例如其他样板代码。在Daniel的[文章中](https://www.codeproject.com/Articles/29922/Weak-Events-in-C)了解有关此内容的更多信息 。\n\n## WeakReference解决方案存在的问题\n\n使用**WeakReference**意味着**GC**将能够在可能的情况下收集订阅类。但是，GC不会立即收集未引用的对象。就开发商而言，它是随机的。因此，对于弱事件，您可能会在当时不应该存在的对象中调用事件处理程序。\n\n事件处理程序可能会执行无害的操作，例如更新内部状态。或者，它可能会更改程序状态，直到GC决定随机收集某个时间为止。这种行为确实很危险。在[“弱事件模式是危险的”中](https://ladimolnar.com/2015/09/14/the-weak-event-pattern-is-dangerous/)对此进行附加阅读 。\n\n## 5.在没有内存探查器的情况下检测内存泄漏\n\n此技术是为了测试现有的内存泄漏，而不是编码模式以首先避免它们。\n\n假设您怀疑某个类存在内存泄漏。如果您有创建一个实例然后希望**GC**收集它的情况，则可以轻松地确定是否将收集您的实例或是否存在内存泄漏。按着这些次序：\n\n1.将**终结器添加**到您的可疑类中，并在其中放置一个断点：\n\n![img](https://i2.wp.com/michaelscodingspot.com/wp-content/uploads/2018/12/breakpoint-in-finalizer.jpg?w=1080&ssl=1)\n\n2. 在场景**开始**时添加以下要调用的魔术3行：\n\n```\nGC.Collect();\nGC.WaitForPendingFinalizers();\nGC.Collect();\n```\n\n这将迫使GC到目前为止收集所有未引用的实例（不在生产环境中使用），因此它们不会干扰我们的调试。\n\n3.添加相同的3条魔术代码行，以 **在**方案**之后**运行。请记住，该方案是创建并收集可疑对象的方案。\n\n4.运行有问题的方案。\n\n在第1步中，我告诉您在类的终结器中放置一个断点。**在**第一个垃圾回收完成**之后**，您实际上应该注意该断点。否则，您可能会被废弃旧实例感到困惑。需要注意的重要时刻是 您的方案**之后**调试器是否在Finalizer中停止 。 \n\n它还有助于在类的构造函数中放置一个断点。这样，您可以计算创建次数和完成次数。如果触发了终结器中的断点，则GC会收集您的实例，一切正常。如果没有，则可能发生内存泄漏。\n\n这是我调试的一种方案，该方案使用了上一种技术中的WeakEventHandler，并且没有内存泄漏：\n\n<video controls=\"\" src=\"https://michaelscodingspot.com/wp-content/uploads/2018/12/my-class-is-finalized-with-weakEventHandler.mp4\" style=\"box-sizing: border-box; max-width: 100%; margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;\"></video>\n\n这是我使用常规事件注册的另一种情况，它确实存在内存泄漏：\n\n<video controls=\"\" src=\"https://michaelscodingspot.com/wp-content/uploads/2018/12/my-class-is-not-finalized-with-regular-event.mp4\" style=\"box-sizing: border-box; max-width: 100%; margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;\"></video>\n\n## 摘要\n\n总是让我感到惊讶的是，C＃看起来像是一种易于学习的语言，并且提供了一个提供训练平台的环境。但实际上，还远远没有做到。诸如使用事件之类的简单事情，可以由未经培训的手轻松地将您的应用程序变成一堆内存泄漏。\n\n至于在代码中使用的正确模式，我认为本文的结论应该是，在所有情况下都没有正确答案。提供的所有技术，以及他们， 视情况而定是可行的解决方案。 \n\n原来这是一个相对较大的职位，但在此问题上，我仍然处于较高水平。这恰恰证明了在这些问题上存在多少深度，以及软件开发如何永无止境。\n\n有关内存泄漏的更多信息，请查看我的文章[查找，修复和避免C＃.NET：8最佳实践中的内存泄漏](https://michaelscodingspot.com/2019/01/03/find-fix-and-avoid-memory-leaks-in-c-net-8-best-practices/)。从我自己的经验和其他高级.NET开发人员那里获得的大量信息都为我提供了建议。它包括有关内存分析器，非托管代码的内存泄漏，监控内存等信息。\n\n我希望您在评论部分中留下一些反馈。并确保[订阅](https://michaelscodingspot.com/subscribe/)博客并收到新帖子通知。","source":"_posts/技术/您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术.md","raw":"---\ntitle:  您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术\ndate: 2020-4-22 22:58\ntags: 技术\nauthor: 邹溪源  \ncategories:\n  - 技术 \n---\n# 您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术\n\nC＃（通常是.NET）中的事件注册是内存泄漏的最常见原因。至少从我的经验来看。实际上，我从事件中看到了太多的内存泄漏，因此 在代码中看到 **+ =**将立即使我感到怀疑。\n\n尽管事件很常见，但它们也很危险。如果您不知道要查找的内容，则事件很容易导致内存泄漏。在本文中，我将解释此问题的根本原因，并提供几种最佳实践技术来解决该问题。最后，我将向您展示一个简单的技巧，以找出您是否确实存在内存泄漏。\n\n## 了解内存泄漏\n\n在垃圾收集环境中，术语“内存泄漏”有点反直觉。当有一个垃圾收集器负责收集所有内容时，我的内存如何泄漏？\n\n答案是，在存在垃圾收集器（**GC**）的情况下，内存泄漏表示有些对象仍在引用中，但实际上未被使用。由于已引用它们，因此GC将不会收集它们，并且它们将永久保存，占用内存。\n\n让我们来看一个例子：\n\n```\npublic class WiFiManager\n{\n    public event EventHandler <WifiEventArgs> WiFiSignalChanged;\n    // ...\n}\n```\n\n```\npublic class MyClass\n{\n    public MyClass(WiFiManager wiFiManager)\n    {\n        wiFiManager.WiFiSignalChanged += OnWiFiChanged;\n    }\n \n    private void OnWiFiChanged(object sender, WifiEventArgs e)\n    {\n        // do something\n    }\n```\n\n```\npublic void SomeOperation(WiFiManager wiFiManager)\n{\n    var myClass = new MyClass(wiFiManager);\n    myClass.DoSomething();\n    \n    //... myClass is not used again\n}\n```\n\n在此示例中，我们假设**WiFiManager** 在程序的整个生命周期中都处于活动状态。执行**SomeOperation之后**，将创建**MyClass**的实例，并且不再使用它。程序员可能会认为GC将收集它，但事实并非如此。所述**WiFiManager**保持在其事件MyClass的参考 **WiFiSignalChanged**和它引起了内存泄漏。GC将永远不会收集**MyClass**。\n\n## 1.确保退订\n\n显而易见的解决方案（尽管并非总是最简单的）是记住从事件中注销事件处理程序。一种方法是实现IDisposable：\n\n```\npublic class MyClass : IDisposable\n{\n    private readonly WiFiManager _wiFiManager;\n \n    public MyClass(WiFiManager wiFiManager)\n    {\n        _wiFiManager = wiFiManager;\n        _wiFiManager.WiFiSignalChanged += OnWiFiChanged;\n    }\n \n    public void Dispose()\n    {\n        _wiFiManager.WiFiSignalChanged -= OnWiFiChanged;\n    }\n \n    private void OnWiFiChanged(object sender, WifiEventArgs e)\n    {\n        // do something\n    }\n```\n\n当然，您必须确保调用**Dispose**。如果您有WPF控件，一个简单的解决方案是退订**Unloaded**事件。\n\n```\npublic partial class MyUserControl : UserControl\n{\n    public MyUserControl(WiFiManager wiFiManager)\n    {\n        InitializeComponent();\n        this.Loaded += (sender, args) => wiFiManager.WiFiSignalChanged += OnWiFiChanged;\n        this.Unloaded += (sender, args) => wiFiManager.WiFiSignalChanged -= OnWiFiChanged;\n    }\n \n    private void OnWiFiChanged(object sender, WifiEventArgs e)\n    {\n        // do something\n    }\n}\n```\n\n优点**：简单易读的代码。\n\n**缺点：**您很容易忘记取消订阅，或者在所有情况下都不会取消订阅，这将导致内存泄漏。\n\n###### 注意：并非所有事件注册都会导致内存泄漏。注册到将要**过期**的事件时，不会发生内存泄漏。例如，在WPF **UserControl中，**您可以注册到Button的**Click**事件。这很好，并且不需要注销，因为用户控件是唯一引用该Button的控件。如果没有一个人引用用户控件，那么也将没有一个人引用按钮，并且**GC**将同时收集两者。\n\n## 2.让处理程序退订\n\n在某些情况下，您可能希望事件处理程序仅发生一次。在这种情况下，您将希望代码自己退订。当事件处理程序是命名方法时，它很容易：\n\n```\npublic class MyClass\n{\n    private readonly WiFiManager _wiFiManager;\n \n    public MyClass(WiFiManager wiFiManager)\n    {\n        _wiFiManager = wiFiManager;\n        _wiFiManager.WiFiSignalChanged += OnWiFiChanged;\n    }\n \n    private void OnWiFiChanged(object sender, WifiEventArgs e)\n    {\n        // do something\n        _wiFiManager.WiFiSignalChanged -= OnWiFiChanged;\n    }\n}\n```\n\n但是，有时您希望事件处理程序是lambda表达式。在这种情况下，以下是一种使自己退订的有用技术：\n\n```\n\npublic class MyClass\n{\n    public MyClass(WiFiManager wiFiManager)\n    {\n        var someObject = GetSomeObject();\n        EventHandler<WifiEventArgs> handler = null;\n        handler = (sender, args) =>\n        {\n            Console.WriteLine(someObject);\n            wiFiManager.WiFiSignalChanged -= handler;\n        };\n        wiFiManager.WiFiSignalChanged += handler;\n    }\n}\n```\n\n在上面的示例中，lambda表达式非常有用，因为您可以捕获局部变量**someObject**，而使用处理程序方法则无法做到这一点。\n\n**优点：**简单，易读，只要您确定事件至少会触发一次，就不会发生内存泄漏。\n\n**缺点：**仅在需要处理一次事件的特殊情况下可用。\n\n## 3.将弱事件与事件聚合器一起使用\n\n在.NET中引用对象时，您基本上会告诉GC该对象正在使用中，因此请不要收集它。有一种引用对象的方法，而无需实际说“我正在使用它”。这种参考称为 *弱参考*。您是说“我不需要它，但是如果它仍然存在，那么我会使用它”。在其他换句话说，如果某个对象仅被弱引用引用，则**GC**会收集该对象并释放该内存。这是使用.NET的**WeakReference** 类实现的。\n\n我们可以通过多种方式使用它来防止内存泄漏。一种流行的设计模式是使用[事件聚合器](https://www.codeproject.com/Articles/812461/Event-Aggregator-Pattern)。这个概念是，任何人都可以**订阅** T类型的事件，任何人都可以**发布** T类型的事件。因此，当一个类发布事件时，将调用所有订阅的事件处理程序。事件聚合器使用WeakReference引用所有内容。所以即使有物体提斯 订阅事件，仍然可以对其进行垃圾回收。\n\n这是一个使用**Prism** 流行的事件聚合器（通过NuGet [Prism.Core提供](https://www.nuget.org/packages/Prism.Core/)）的[示例](https://www.nuget.org/packages/Prism.Core/)。\n\n```\npublic class WiFiManager\n{\n    private readonly IEventAggregator _eventAggregator;\n \n    public WiFiManager(IEventAggregator eventAggregator)\n    {\n        _eventAggregator = eventAggregator;\n    }\n \n    public void PublishEvent()\n    {\n        _eventAggregator.GetEvent<WiFiEvent>().Publish(new WifiEventArgs());\n    }\n```\n\n```\npublic class MyClass\n{\n    public MyClass(IEventAggregator eventAggregator)\n    {\n        eventAggregator.GetEvent<WiFiEvent>().Subscribe(OnWiFiChanged);\n \n    }\n \n    private void OnWiFiChanged(WifiEventArgs args)\n    {\n        // do something\n    }\n```\n\n\n\n```\npublic class WiFiEvent : PubSubEvent<WifiEventArgs>\n{\n    // ...\n}\n```\n\n**优点：** 防止内存泄漏，相对易于使用。\n\n**缺点：**\n\n 充当所有事件的全局容器。任何人都可以订阅任何人。这使得系统在过度使用时难以理解。没有分离的关注点。\n\n## 4.对常规事件使用弱事件处理程序\n\n借助一些代码技巧，可以将弱引用与常规事件一起使用。这可以通过几种不同的方式来实现。这是使用Paul Stovell的[WeakEventHandler](http://paulstovell.com/blog/weakevents)的示例：\n\n```\npublic class MyClass\n{\n    public MyClass(WiFiManager wiFiManager)\n    {\n        wiFiManager.WiFiSignalChanged += new WeakEventHandler<WifiEventArgs>(OnWiFiChanged).Handler;\n    }\n \n    private void OnWiFiChanged(object sender, WifiEventArgs e)\n    {\n        // do something\n    }\n}\n```\n\n\n\n```\n\npublic class WiFiManager\n{\n    public event EventHandler<WifiEventArgs> WiFiSignalChanged;\n    // ...\n\n```\n\n```\npublic void SomeOperation(WiFiManager wiFiManager)\n{\n    var myClass = new MyClass(wiFiManager);\n    myClass.DoSomething();\n    \n    //... myClass is not used again\n}\n```\n\n我真的很喜欢这种方法，因为在我们的案例中，发布者**WiFiManager**保留了标准的C＃事件。这只是这种模式的一种实现，但是实际上有很多方法可以解决。**Daniel Grunwald**写了[一篇](https://www.codeproject.com/Articles/29922/Weak-Events-in-C)有关不同实现及其差异的文章。\n\n**优点：**利用标准事件。简单。没有内存泄漏。关注点分离（与事件聚合器不同）。\n\n**缺点：**此模式的不同实现有一些细微之处和不同问题。该示例中的实现实际上创建了一个 注册的**包装**对象，该 **包装**对象从未被GC收集。其他实现可以解决此问题，但还有其他问题，例如其他样板代码。在Daniel的[文章中](https://www.codeproject.com/Articles/29922/Weak-Events-in-C)了解有关此内容的更多信息 。\n\n## WeakReference解决方案存在的问题\n\n使用**WeakReference**意味着**GC**将能够在可能的情况下收集订阅类。但是，GC不会立即收集未引用的对象。就开发商而言，它是随机的。因此，对于弱事件，您可能会在当时不应该存在的对象中调用事件处理程序。\n\n事件处理程序可能会执行无害的操作，例如更新内部状态。或者，它可能会更改程序状态，直到GC决定随机收集某个时间为止。这种行为确实很危险。在[“弱事件模式是危险的”中](https://ladimolnar.com/2015/09/14/the-weak-event-pattern-is-dangerous/)对此进行附加阅读 。\n\n## 5.在没有内存探查器的情况下检测内存泄漏\n\n此技术是为了测试现有的内存泄漏，而不是编码模式以首先避免它们。\n\n假设您怀疑某个类存在内存泄漏。如果您有创建一个实例然后希望**GC**收集它的情况，则可以轻松地确定是否将收集您的实例或是否存在内存泄漏。按着这些次序：\n\n1.将**终结器添加**到您的可疑类中，并在其中放置一个断点：\n\n![img](https://i2.wp.com/michaelscodingspot.com/wp-content/uploads/2018/12/breakpoint-in-finalizer.jpg?w=1080&ssl=1)\n\n2. 在场景**开始**时添加以下要调用的魔术3行：\n\n```\nGC.Collect();\nGC.WaitForPendingFinalizers();\nGC.Collect();\n```\n\n这将迫使GC到目前为止收集所有未引用的实例（不在生产环境中使用），因此它们不会干扰我们的调试。\n\n3.添加相同的3条魔术代码行，以 **在**方案**之后**运行。请记住，该方案是创建并收集可疑对象的方案。\n\n4.运行有问题的方案。\n\n在第1步中，我告诉您在类的终结器中放置一个断点。**在**第一个垃圾回收完成**之后**，您实际上应该注意该断点。否则，您可能会被废弃旧实例感到困惑。需要注意的重要时刻是 您的方案**之后**调试器是否在Finalizer中停止 。 \n\n它还有助于在类的构造函数中放置一个断点。这样，您可以计算创建次数和完成次数。如果触发了终结器中的断点，则GC会收集您的实例，一切正常。如果没有，则可能发生内存泄漏。\n\n这是我调试的一种方案，该方案使用了上一种技术中的WeakEventHandler，并且没有内存泄漏：\n\n<video controls=\"\" src=\"https://michaelscodingspot.com/wp-content/uploads/2018/12/my-class-is-finalized-with-weakEventHandler.mp4\" style=\"box-sizing: border-box; max-width: 100%; margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;\"></video>\n\n这是我使用常规事件注册的另一种情况，它确实存在内存泄漏：\n\n<video controls=\"\" src=\"https://michaelscodingspot.com/wp-content/uploads/2018/12/my-class-is-not-finalized-with-regular-event.mp4\" style=\"box-sizing: border-box; max-width: 100%; margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;\"></video>\n\n## 摘要\n\n总是让我感到惊讶的是，C＃看起来像是一种易于学习的语言，并且提供了一个提供训练平台的环境。但实际上，还远远没有做到。诸如使用事件之类的简单事情，可以由未经培训的手轻松地将您的应用程序变成一堆内存泄漏。\n\n至于在代码中使用的正确模式，我认为本文的结论应该是，在所有情况下都没有正确答案。提供的所有技术，以及他们， 视情况而定是可行的解决方案。 \n\n原来这是一个相对较大的职位，但在此问题上，我仍然处于较高水平。这恰恰证明了在这些问题上存在多少深度，以及软件开发如何永无止境。\n\n有关内存泄漏的更多信息，请查看我的文章[查找，修复和避免C＃.NET：8最佳实践中的内存泄漏](https://michaelscodingspot.com/2019/01/03/find-fix-and-avoid-memory-leaks-in-c-net-8-best-practices/)。从我自己的经验和其他高级.NET开发人员那里获得的大量信息都为我提供了建议。它包括有关内存分析器，非托管代码的内存泄漏，监控内存等信息。\n\n我希望您在评论部分中留下一些反馈。并确保[订阅](https://michaelscodingspot.com/subscribe/)博客并收到新帖子通知。","slug":"技术/您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术","published":1,"updated":"2020-04-22T14:56:56.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt7s001gn4vi0dz0pteu","content":"<h1 id=\"您应该知道的5种避免C＃-NET中事件造成的内存泄漏的技术\"><a href=\"#您应该知道的5种避免C＃-NET中事件造成的内存泄漏的技术\" class=\"headerlink\" title=\"您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术\"></a>您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术</h1><p>C＃（通常是.NET）中的事件注册是内存泄漏的最常见原因。至少从我的经验来看。实际上，我从事件中看到了太多的内存泄漏，因此 在代码中看到 <strong>+ =</strong>将立即使我感到怀疑。</p>\n<p>尽管事件很常见，但它们也很危险。如果您不知道要查找的内容，则事件很容易导致内存泄漏。在本文中，我将解释此问题的根本原因，并提供几种最佳实践技术来解决该问题。最后，我将向您展示一个简单的技巧，以找出您是否确实存在内存泄漏。</p>\n<h2 id=\"了解内存泄漏\"><a href=\"#了解内存泄漏\" class=\"headerlink\" title=\"了解内存泄漏\"></a>了解内存泄漏</h2><p>在垃圾收集环境中，术语“内存泄漏”有点反直觉。当有一个垃圾收集器负责收集所有内容时，我的内存如何泄漏？</p>\n<p>答案是，在存在垃圾收集器（<strong>GC</strong>）的情况下，内存泄漏表示有些对象仍在引用中，但实际上未被使用。由于已引用它们，因此GC将不会收集它们，并且它们将永久保存，占用内存。</p>\n<p>让我们来看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WiFiManager</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public event EventHandler &lt;WifiEventArgs&gt; WiFiSignalChanged;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public MyClass(WiFiManager wiFiManager)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        wiFiManager.WiFiSignalChanged += OnWiFiChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private void OnWiFiChanged(object sender, WifiEventArgs e)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void SomeOperation(WiFiManager wiFiManager)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var myClass = new MyClass(wiFiManager);</span><br><span class=\"line\">    myClass.DoSomething();</span><br><span class=\"line\">    </span><br><span class=\"line\">    //... myClass is not used again</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在此示例中，我们假设<strong>WiFiManager</strong> 在程序的整个生命周期中都处于活动状态。执行<strong>SomeOperation之后</strong>，将创建<strong>MyClass</strong>的实例，并且不再使用它。程序员可能会认为GC将收集它，但事实并非如此。所述<strong>WiFiManager</strong>保持在其事件MyClass的参考 <strong>WiFiSignalChanged</strong>和它引起了内存泄漏。GC将永远不会收集<strong>MyClass</strong>。</p>\n<h2 id=\"1-确保退订\"><a href=\"#1-确保退订\" class=\"headerlink\" title=\"1.确保退订\"></a>1.确保退订</h2><p>显而易见的解决方案（尽管并非总是最简单的）是记住从事件中注销事件处理程序。一种方法是实现IDisposable：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyClass : IDisposable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private readonly WiFiManager _wiFiManager;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public MyClass(WiFiManager wiFiManager)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _wiFiManager = wiFiManager;</span><br><span class=\"line\">        _wiFiManager.WiFiSignalChanged += OnWiFiChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public void Dispose()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _wiFiManager.WiFiSignalChanged -= OnWiFiChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private void OnWiFiChanged(object sender, WifiEventArgs e)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，您必须确保调用<strong>Dispose</strong>。如果您有WPF控件，一个简单的解决方案是退订<strong>Unloaded</strong>事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public partial class MyUserControl : UserControl</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public MyUserControl(WiFiManager wiFiManager)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        InitializeComponent();</span><br><span class=\"line\">        this.Loaded += (sender, args) =&gt; wiFiManager.WiFiSignalChanged += OnWiFiChanged;</span><br><span class=\"line\">        this.Unloaded += (sender, args) =&gt; wiFiManager.WiFiSignalChanged -= OnWiFiChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private void OnWiFiChanged(object sender, WifiEventArgs e)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>优点**：简单易读的代码。</p>\n<p><strong>缺点：</strong>您很容易忘记取消订阅，或者在所有情况下都不会取消订阅，这将导致内存泄漏。</p>\n<h6 id=\"注意：并非所有事件注册都会导致内存泄漏。注册到将要过期的事件时，不会发生内存泄漏。例如，在WPF-UserControl中，您可以注册到Button的Click事件。这很好，并且不需要注销，因为用户控件是唯一引用该Button的控件。如果没有一个人引用用户控件，那么也将没有一个人引用按钮，并且GC将同时收集两者。\"><a href=\"#注意：并非所有事件注册都会导致内存泄漏。注册到将要过期的事件时，不会发生内存泄漏。例如，在WPF-UserControl中，您可以注册到Button的Click事件。这很好，并且不需要注销，因为用户控件是唯一引用该Button的控件。如果没有一个人引用用户控件，那么也将没有一个人引用按钮，并且GC将同时收集两者。\" class=\"headerlink\" title=\"注意：并非所有事件注册都会导致内存泄漏。注册到将要过期的事件时，不会发生内存泄漏。例如，在WPF UserControl中，您可以注册到Button的Click事件。这很好，并且不需要注销，因为用户控件是唯一引用该Button的控件。如果没有一个人引用用户控件，那么也将没有一个人引用按钮，并且GC将同时收集两者。\"></a>注意：并非所有事件注册都会导致内存泄漏。注册到将要<strong>过期</strong>的事件时，不会发生内存泄漏。例如，在WPF <strong>UserControl中，</strong>您可以注册到Button的<strong>Click</strong>事件。这很好，并且不需要注销，因为用户控件是唯一引用该Button的控件。如果没有一个人引用用户控件，那么也将没有一个人引用按钮，并且<strong>GC</strong>将同时收集两者。</h6><h2 id=\"2-让处理程序退订\"><a href=\"#2-让处理程序退订\" class=\"headerlink\" title=\"2.让处理程序退订\"></a>2.让处理程序退订</h2><p>在某些情况下，您可能希望事件处理程序仅发生一次。在这种情况下，您将希望代码自己退订。当事件处理程序是命名方法时，它很容易：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private readonly WiFiManager _wiFiManager;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public MyClass(WiFiManager wiFiManager)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _wiFiManager = wiFiManager;</span><br><span class=\"line\">        _wiFiManager.WiFiSignalChanged += OnWiFiChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private void OnWiFiChanged(object sender, WifiEventArgs e)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">        _wiFiManager.WiFiSignalChanged -= OnWiFiChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，有时您希望事件处理程序是lambda表达式。在这种情况下，以下是一种使自己退订的有用技术：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class MyClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public MyClass(WiFiManager wiFiManager)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        var someObject = GetSomeObject();</span><br><span class=\"line\">        EventHandler&lt;WifiEventArgs&gt; handler = null;</span><br><span class=\"line\">        handler = (sender, args) =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Console.WriteLine(someObject);</span><br><span class=\"line\">            wiFiManager.WiFiSignalChanged -= handler;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        wiFiManager.WiFiSignalChanged += handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的示例中，lambda表达式非常有用，因为您可以捕获局部变量<strong>someObject</strong>，而使用处理程序方法则无法做到这一点。</p>\n<p><strong>优点：</strong>简单，易读，只要您确定事件至少会触发一次，就不会发生内存泄漏。</p>\n<p><strong>缺点：</strong>仅在需要处理一次事件的特殊情况下可用。</p>\n<h2 id=\"3-将弱事件与事件聚合器一起使用\"><a href=\"#3-将弱事件与事件聚合器一起使用\" class=\"headerlink\" title=\"3.将弱事件与事件聚合器一起使用\"></a>3.将弱事件与事件聚合器一起使用</h2><p>在.NET中引用对象时，您基本上会告诉GC该对象正在使用中，因此请不要收集它。有一种引用对象的方法，而无需实际说“我正在使用它”。这种参考称为 <em>弱参考</em>。您是说“我不需要它，但是如果它仍然存在，那么我会使用它”。在其他换句话说，如果某个对象仅被弱引用引用，则<strong>GC</strong>会收集该对象并释放该内存。这是使用.NET的<strong>WeakReference</strong> 类实现的。</p>\n<p>我们可以通过多种方式使用它来防止内存泄漏。一种流行的设计模式是使用<a href=\"https://www.codeproject.com/Articles/812461/Event-Aggregator-Pattern\" target=\"_blank\" rel=\"noopener\">事件聚合器</a>。这个概念是，任何人都可以<strong>订阅</strong> T类型的事件，任何人都可以<strong>发布</strong> T类型的事件。因此，当一个类发布事件时，将调用所有订阅的事件处理程序。事件聚合器使用WeakReference引用所有内容。所以即使有物体提斯 订阅事件，仍然可以对其进行垃圾回收。</p>\n<p>这是一个使用<strong>Prism</strong> 流行的事件聚合器（通过NuGet <a href=\"https://www.nuget.org/packages/Prism.Core/\" target=\"_blank\" rel=\"noopener\">Prism.Core提供</a>）的<a href=\"https://www.nuget.org/packages/Prism.Core/\" target=\"_blank\" rel=\"noopener\">示例</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WiFiManager</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private readonly IEventAggregator _eventAggregator;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public WiFiManager(IEventAggregator eventAggregator)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _eventAggregator = eventAggregator;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public void PublishEvent()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _eventAggregator.GetEvent&lt;WiFiEvent&gt;().Publish(new WifiEventArgs());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public MyClass(IEventAggregator eventAggregator)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        eventAggregator.GetEvent&lt;WiFiEvent&gt;().Subscribe(OnWiFiChanged);</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private void OnWiFiChanged(WifiEventArgs args)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WiFiEvent : PubSubEvent&lt;WifiEventArgs&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong> 防止内存泄漏，相对易于使用。</p>\n<p><strong>缺点：</strong></p>\n<p> 充当所有事件的全局容器。任何人都可以订阅任何人。这使得系统在过度使用时难以理解。没有分离的关注点。</p>\n<h2 id=\"4-对常规事件使用弱事件处理程序\"><a href=\"#4-对常规事件使用弱事件处理程序\" class=\"headerlink\" title=\"4.对常规事件使用弱事件处理程序\"></a>4.对常规事件使用弱事件处理程序</h2><p>借助一些代码技巧，可以将弱引用与常规事件一起使用。这可以通过几种不同的方式来实现。这是使用Paul Stovell的<a href=\"http://paulstovell.com/blog/weakevents\" target=\"_blank\" rel=\"noopener\">WeakEventHandler</a>的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public MyClass(WiFiManager wiFiManager)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        wiFiManager.WiFiSignalChanged += new WeakEventHandler&lt;WifiEventArgs&gt;(OnWiFiChanged).Handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private void OnWiFiChanged(object sender, WifiEventArgs e)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class WiFiManager</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public event EventHandler&lt;WifiEventArgs&gt; WiFiSignalChanged;</span><br><span class=\"line\">    // ...</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void SomeOperation(WiFiManager wiFiManager)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var myClass = new MyClass(wiFiManager);</span><br><span class=\"line\">    myClass.DoSomething();</span><br><span class=\"line\">    </span><br><span class=\"line\">    //... myClass is not used again</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我真的很喜欢这种方法，因为在我们的案例中，发布者<strong>WiFiManager</strong>保留了标准的C＃事件。这只是这种模式的一种实现，但是实际上有很多方法可以解决。<strong>Daniel Grunwald</strong>写了<a href=\"https://www.codeproject.com/Articles/29922/Weak-Events-in-C\" target=\"_blank\" rel=\"noopener\">一篇</a>有关不同实现及其差异的文章。</p>\n<p><strong>优点：</strong>利用标准事件。简单。没有内存泄漏。关注点分离（与事件聚合器不同）。</p>\n<p><strong>缺点：</strong>此模式的不同实现有一些细微之处和不同问题。该示例中的实现实际上创建了一个 注册的<strong>包装</strong>对象，该 <strong>包装</strong>对象从未被GC收集。其他实现可以解决此问题，但还有其他问题，例如其他样板代码。在Daniel的<a href=\"https://www.codeproject.com/Articles/29922/Weak-Events-in-C\" target=\"_blank\" rel=\"noopener\">文章中</a>了解有关此内容的更多信息 。</p>\n<h2 id=\"WeakReference解决方案存在的问题\"><a href=\"#WeakReference解决方案存在的问题\" class=\"headerlink\" title=\"WeakReference解决方案存在的问题\"></a>WeakReference解决方案存在的问题</h2><p>使用<strong>WeakReference</strong>意味着<strong>GC</strong>将能够在可能的情况下收集订阅类。但是，GC不会立即收集未引用的对象。就开发商而言，它是随机的。因此，对于弱事件，您可能会在当时不应该存在的对象中调用事件处理程序。</p>\n<p>事件处理程序可能会执行无害的操作，例如更新内部状态。或者，它可能会更改程序状态，直到GC决定随机收集某个时间为止。这种行为确实很危险。在<a href=\"https://ladimolnar.com/2015/09/14/the-weak-event-pattern-is-dangerous/\" target=\"_blank\" rel=\"noopener\">“弱事件模式是危险的”中</a>对此进行附加阅读 。</p>\n<h2 id=\"5-在没有内存探查器的情况下检测内存泄漏\"><a href=\"#5-在没有内存探查器的情况下检测内存泄漏\" class=\"headerlink\" title=\"5.在没有内存探查器的情况下检测内存泄漏\"></a>5.在没有内存探查器的情况下检测内存泄漏</h2><p>此技术是为了测试现有的内存泄漏，而不是编码模式以首先避免它们。</p>\n<p>假设您怀疑某个类存在内存泄漏。如果您有创建一个实例然后希望<strong>GC</strong>收集它的情况，则可以轻松地确定是否将收集您的实例或是否存在内存泄漏。按着这些次序：</p>\n<p>1.将<strong>终结器添加</strong>到您的可疑类中，并在其中放置一个断点：</p>\n<p><img src=\"https://i2.wp.com/michaelscodingspot.com/wp-content/uploads/2018/12/breakpoint-in-finalizer.jpg?w=1080&ssl=1\" alt=\"img\"></p>\n<ol start=\"2\">\n<li>在场景<strong>开始</strong>时添加以下要调用的魔术3行：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GC.Collect();</span><br><span class=\"line\">GC.WaitForPendingFinalizers();</span><br><span class=\"line\">GC.Collect();</span><br></pre></td></tr></table></figure>\n\n<p>这将迫使GC到目前为止收集所有未引用的实例（不在生产环境中使用），因此它们不会干扰我们的调试。</p>\n<p>3.添加相同的3条魔术代码行，以 <strong>在</strong>方案<strong>之后</strong>运行。请记住，该方案是创建并收集可疑对象的方案。</p>\n<p>4.运行有问题的方案。</p>\n<p>在第1步中，我告诉您在类的终结器中放置一个断点。<strong>在</strong>第一个垃圾回收完成<strong>之后</strong>，您实际上应该注意该断点。否则，您可能会被废弃旧实例感到困惑。需要注意的重要时刻是 您的方案<strong>之后</strong>调试器是否在Finalizer中停止 。 </p>\n<p>它还有助于在类的构造函数中放置一个断点。这样，您可以计算创建次数和完成次数。如果触发了终结器中的断点，则GC会收集您的实例，一切正常。如果没有，则可能发生内存泄漏。</p>\n<p>这是我调试的一种方案，该方案使用了上一种技术中的WeakEventHandler，并且没有内存泄漏：</p>\n<p><video controls src=\"https://michaelscodingspot.com/wp-content/uploads/2018/12/my-class-is-finalized-with-weakEventHandler.mp4\" style=\"box-sizing: border-box; max-width: 100%; margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;\"></video></p>\n<p>这是我使用常规事件注册的另一种情况，它确实存在内存泄漏：</p>\n<p><video controls src=\"https://michaelscodingspot.com/wp-content/uploads/2018/12/my-class-is-not-finalized-with-regular-event.mp4\" style=\"box-sizing: border-box; max-width: 100%; margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;\"></video></p>\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>总是让我感到惊讶的是，C＃看起来像是一种易于学习的语言，并且提供了一个提供训练平台的环境。但实际上，还远远没有做到。诸如使用事件之类的简单事情，可以由未经培训的手轻松地将您的应用程序变成一堆内存泄漏。</p>\n<p>至于在代码中使用的正确模式，我认为本文的结论应该是，在所有情况下都没有正确答案。提供的所有技术，以及他们， 视情况而定是可行的解决方案。 </p>\n<p>原来这是一个相对较大的职位，但在此问题上，我仍然处于较高水平。这恰恰证明了在这些问题上存在多少深度，以及软件开发如何永无止境。</p>\n<p>有关内存泄漏的更多信息，请查看我的文章<a href=\"https://michaelscodingspot.com/2019/01/03/find-fix-and-avoid-memory-leaks-in-c-net-8-best-practices/\" target=\"_blank\" rel=\"noopener\">查找，修复和避免C＃.NET：8最佳实践中的内存泄漏</a>。从我自己的经验和其他高级.NET开发人员那里获得的大量信息都为我提供了建议。它包括有关内存分析器，非托管代码的内存泄漏，监控内存等信息。</p>\n<p>我希望您在评论部分中留下一些反馈。并确保<a href=\"https://michaelscodingspot.com/subscribe/\" target=\"_blank\" rel=\"noopener\">订阅</a>博客并收到新帖子通知。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"您应该知道的5种避免C＃-NET中事件造成的内存泄漏的技术\"><a href=\"#您应该知道的5种避免C＃-NET中事件造成的内存泄漏的技术\" class=\"headerlink\" title=\"您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术\"></a>您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术</h1><p>C＃（通常是.NET）中的事件注册是内存泄漏的最常见原因。至少从我的经验来看。实际上，我从事件中看到了太多的内存泄漏，因此 在代码中看到 <strong>+ =</strong>将立即使我感到怀疑。</p>\n<p>尽管事件很常见，但它们也很危险。如果您不知道要查找的内容，则事件很容易导致内存泄漏。在本文中，我将解释此问题的根本原因，并提供几种最佳实践技术来解决该问题。最后，我将向您展示一个简单的技巧，以找出您是否确实存在内存泄漏。</p>\n<h2 id=\"了解内存泄漏\"><a href=\"#了解内存泄漏\" class=\"headerlink\" title=\"了解内存泄漏\"></a>了解内存泄漏</h2><p>在垃圾收集环境中，术语“内存泄漏”有点反直觉。当有一个垃圾收集器负责收集所有内容时，我的内存如何泄漏？</p>\n<p>答案是，在存在垃圾收集器（<strong>GC</strong>）的情况下，内存泄漏表示有些对象仍在引用中，但实际上未被使用。由于已引用它们，因此GC将不会收集它们，并且它们将永久保存，占用内存。</p>\n<p>让我们来看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WiFiManager</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public event EventHandler &lt;WifiEventArgs&gt; WiFiSignalChanged;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public MyClass(WiFiManager wiFiManager)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        wiFiManager.WiFiSignalChanged += OnWiFiChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private void OnWiFiChanged(object sender, WifiEventArgs e)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void SomeOperation(WiFiManager wiFiManager)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var myClass = new MyClass(wiFiManager);</span><br><span class=\"line\">    myClass.DoSomething();</span><br><span class=\"line\">    </span><br><span class=\"line\">    //... myClass is not used again</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在此示例中，我们假设<strong>WiFiManager</strong> 在程序的整个生命周期中都处于活动状态。执行<strong>SomeOperation之后</strong>，将创建<strong>MyClass</strong>的实例，并且不再使用它。程序员可能会认为GC将收集它，但事实并非如此。所述<strong>WiFiManager</strong>保持在其事件MyClass的参考 <strong>WiFiSignalChanged</strong>和它引起了内存泄漏。GC将永远不会收集<strong>MyClass</strong>。</p>\n<h2 id=\"1-确保退订\"><a href=\"#1-确保退订\" class=\"headerlink\" title=\"1.确保退订\"></a>1.确保退订</h2><p>显而易见的解决方案（尽管并非总是最简单的）是记住从事件中注销事件处理程序。一种方法是实现IDisposable：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyClass : IDisposable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private readonly WiFiManager _wiFiManager;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public MyClass(WiFiManager wiFiManager)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _wiFiManager = wiFiManager;</span><br><span class=\"line\">        _wiFiManager.WiFiSignalChanged += OnWiFiChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public void Dispose()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _wiFiManager.WiFiSignalChanged -= OnWiFiChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private void OnWiFiChanged(object sender, WifiEventArgs e)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，您必须确保调用<strong>Dispose</strong>。如果您有WPF控件，一个简单的解决方案是退订<strong>Unloaded</strong>事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public partial class MyUserControl : UserControl</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public MyUserControl(WiFiManager wiFiManager)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        InitializeComponent();</span><br><span class=\"line\">        this.Loaded += (sender, args) =&gt; wiFiManager.WiFiSignalChanged += OnWiFiChanged;</span><br><span class=\"line\">        this.Unloaded += (sender, args) =&gt; wiFiManager.WiFiSignalChanged -= OnWiFiChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private void OnWiFiChanged(object sender, WifiEventArgs e)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>优点**：简单易读的代码。</p>\n<p><strong>缺点：</strong>您很容易忘记取消订阅，或者在所有情况下都不会取消订阅，这将导致内存泄漏。</p>\n<h6 id=\"注意：并非所有事件注册都会导致内存泄漏。注册到将要过期的事件时，不会发生内存泄漏。例如，在WPF-UserControl中，您可以注册到Button的Click事件。这很好，并且不需要注销，因为用户控件是唯一引用该Button的控件。如果没有一个人引用用户控件，那么也将没有一个人引用按钮，并且GC将同时收集两者。\"><a href=\"#注意：并非所有事件注册都会导致内存泄漏。注册到将要过期的事件时，不会发生内存泄漏。例如，在WPF-UserControl中，您可以注册到Button的Click事件。这很好，并且不需要注销，因为用户控件是唯一引用该Button的控件。如果没有一个人引用用户控件，那么也将没有一个人引用按钮，并且GC将同时收集两者。\" class=\"headerlink\" title=\"注意：并非所有事件注册都会导致内存泄漏。注册到将要过期的事件时，不会发生内存泄漏。例如，在WPF UserControl中，您可以注册到Button的Click事件。这很好，并且不需要注销，因为用户控件是唯一引用该Button的控件。如果没有一个人引用用户控件，那么也将没有一个人引用按钮，并且GC将同时收集两者。\"></a>注意：并非所有事件注册都会导致内存泄漏。注册到将要<strong>过期</strong>的事件时，不会发生内存泄漏。例如，在WPF <strong>UserControl中，</strong>您可以注册到Button的<strong>Click</strong>事件。这很好，并且不需要注销，因为用户控件是唯一引用该Button的控件。如果没有一个人引用用户控件，那么也将没有一个人引用按钮，并且<strong>GC</strong>将同时收集两者。</h6><h2 id=\"2-让处理程序退订\"><a href=\"#2-让处理程序退订\" class=\"headerlink\" title=\"2.让处理程序退订\"></a>2.让处理程序退订</h2><p>在某些情况下，您可能希望事件处理程序仅发生一次。在这种情况下，您将希望代码自己退订。当事件处理程序是命名方法时，它很容易：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private readonly WiFiManager _wiFiManager;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public MyClass(WiFiManager wiFiManager)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _wiFiManager = wiFiManager;</span><br><span class=\"line\">        _wiFiManager.WiFiSignalChanged += OnWiFiChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private void OnWiFiChanged(object sender, WifiEventArgs e)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">        _wiFiManager.WiFiSignalChanged -= OnWiFiChanged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，有时您希望事件处理程序是lambda表达式。在这种情况下，以下是一种使自己退订的有用技术：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class MyClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public MyClass(WiFiManager wiFiManager)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        var someObject = GetSomeObject();</span><br><span class=\"line\">        EventHandler&lt;WifiEventArgs&gt; handler = null;</span><br><span class=\"line\">        handler = (sender, args) =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Console.WriteLine(someObject);</span><br><span class=\"line\">            wiFiManager.WiFiSignalChanged -= handler;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        wiFiManager.WiFiSignalChanged += handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的示例中，lambda表达式非常有用，因为您可以捕获局部变量<strong>someObject</strong>，而使用处理程序方法则无法做到这一点。</p>\n<p><strong>优点：</strong>简单，易读，只要您确定事件至少会触发一次，就不会发生内存泄漏。</p>\n<p><strong>缺点：</strong>仅在需要处理一次事件的特殊情况下可用。</p>\n<h2 id=\"3-将弱事件与事件聚合器一起使用\"><a href=\"#3-将弱事件与事件聚合器一起使用\" class=\"headerlink\" title=\"3.将弱事件与事件聚合器一起使用\"></a>3.将弱事件与事件聚合器一起使用</h2><p>在.NET中引用对象时，您基本上会告诉GC该对象正在使用中，因此请不要收集它。有一种引用对象的方法，而无需实际说“我正在使用它”。这种参考称为 <em>弱参考</em>。您是说“我不需要它，但是如果它仍然存在，那么我会使用它”。在其他换句话说，如果某个对象仅被弱引用引用，则<strong>GC</strong>会收集该对象并释放该内存。这是使用.NET的<strong>WeakReference</strong> 类实现的。</p>\n<p>我们可以通过多种方式使用它来防止内存泄漏。一种流行的设计模式是使用<a href=\"https://www.codeproject.com/Articles/812461/Event-Aggregator-Pattern\" target=\"_blank\" rel=\"noopener\">事件聚合器</a>。这个概念是，任何人都可以<strong>订阅</strong> T类型的事件，任何人都可以<strong>发布</strong> T类型的事件。因此，当一个类发布事件时，将调用所有订阅的事件处理程序。事件聚合器使用WeakReference引用所有内容。所以即使有物体提斯 订阅事件，仍然可以对其进行垃圾回收。</p>\n<p>这是一个使用<strong>Prism</strong> 流行的事件聚合器（通过NuGet <a href=\"https://www.nuget.org/packages/Prism.Core/\" target=\"_blank\" rel=\"noopener\">Prism.Core提供</a>）的<a href=\"https://www.nuget.org/packages/Prism.Core/\" target=\"_blank\" rel=\"noopener\">示例</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WiFiManager</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private readonly IEventAggregator _eventAggregator;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public WiFiManager(IEventAggregator eventAggregator)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _eventAggregator = eventAggregator;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public void PublishEvent()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _eventAggregator.GetEvent&lt;WiFiEvent&gt;().Publish(new WifiEventArgs());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public MyClass(IEventAggregator eventAggregator)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        eventAggregator.GetEvent&lt;WiFiEvent&gt;().Subscribe(OnWiFiChanged);</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private void OnWiFiChanged(WifiEventArgs args)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WiFiEvent : PubSubEvent&lt;WifiEventArgs&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong> 防止内存泄漏，相对易于使用。</p>\n<p><strong>缺点：</strong></p>\n<p> 充当所有事件的全局容器。任何人都可以订阅任何人。这使得系统在过度使用时难以理解。没有分离的关注点。</p>\n<h2 id=\"4-对常规事件使用弱事件处理程序\"><a href=\"#4-对常规事件使用弱事件处理程序\" class=\"headerlink\" title=\"4.对常规事件使用弱事件处理程序\"></a>4.对常规事件使用弱事件处理程序</h2><p>借助一些代码技巧，可以将弱引用与常规事件一起使用。这可以通过几种不同的方式来实现。这是使用Paul Stovell的<a href=\"http://paulstovell.com/blog/weakevents\" target=\"_blank\" rel=\"noopener\">WeakEventHandler</a>的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public MyClass(WiFiManager wiFiManager)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        wiFiManager.WiFiSignalChanged += new WeakEventHandler&lt;WifiEventArgs&gt;(OnWiFiChanged).Handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    private void OnWiFiChanged(object sender, WifiEventArgs e)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // do something</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class WiFiManager</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public event EventHandler&lt;WifiEventArgs&gt; WiFiSignalChanged;</span><br><span class=\"line\">    // ...</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void SomeOperation(WiFiManager wiFiManager)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    var myClass = new MyClass(wiFiManager);</span><br><span class=\"line\">    myClass.DoSomething();</span><br><span class=\"line\">    </span><br><span class=\"line\">    //... myClass is not used again</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我真的很喜欢这种方法，因为在我们的案例中，发布者<strong>WiFiManager</strong>保留了标准的C＃事件。这只是这种模式的一种实现，但是实际上有很多方法可以解决。<strong>Daniel Grunwald</strong>写了<a href=\"https://www.codeproject.com/Articles/29922/Weak-Events-in-C\" target=\"_blank\" rel=\"noopener\">一篇</a>有关不同实现及其差异的文章。</p>\n<p><strong>优点：</strong>利用标准事件。简单。没有内存泄漏。关注点分离（与事件聚合器不同）。</p>\n<p><strong>缺点：</strong>此模式的不同实现有一些细微之处和不同问题。该示例中的实现实际上创建了一个 注册的<strong>包装</strong>对象，该 <strong>包装</strong>对象从未被GC收集。其他实现可以解决此问题，但还有其他问题，例如其他样板代码。在Daniel的<a href=\"https://www.codeproject.com/Articles/29922/Weak-Events-in-C\" target=\"_blank\" rel=\"noopener\">文章中</a>了解有关此内容的更多信息 。</p>\n<h2 id=\"WeakReference解决方案存在的问题\"><a href=\"#WeakReference解决方案存在的问题\" class=\"headerlink\" title=\"WeakReference解决方案存在的问题\"></a>WeakReference解决方案存在的问题</h2><p>使用<strong>WeakReference</strong>意味着<strong>GC</strong>将能够在可能的情况下收集订阅类。但是，GC不会立即收集未引用的对象。就开发商而言，它是随机的。因此，对于弱事件，您可能会在当时不应该存在的对象中调用事件处理程序。</p>\n<p>事件处理程序可能会执行无害的操作，例如更新内部状态。或者，它可能会更改程序状态，直到GC决定随机收集某个时间为止。这种行为确实很危险。在<a href=\"https://ladimolnar.com/2015/09/14/the-weak-event-pattern-is-dangerous/\" target=\"_blank\" rel=\"noopener\">“弱事件模式是危险的”中</a>对此进行附加阅读 。</p>\n<h2 id=\"5-在没有内存探查器的情况下检测内存泄漏\"><a href=\"#5-在没有内存探查器的情况下检测内存泄漏\" class=\"headerlink\" title=\"5.在没有内存探查器的情况下检测内存泄漏\"></a>5.在没有内存探查器的情况下检测内存泄漏</h2><p>此技术是为了测试现有的内存泄漏，而不是编码模式以首先避免它们。</p>\n<p>假设您怀疑某个类存在内存泄漏。如果您有创建一个实例然后希望<strong>GC</strong>收集它的情况，则可以轻松地确定是否将收集您的实例或是否存在内存泄漏。按着这些次序：</p>\n<p>1.将<strong>终结器添加</strong>到您的可疑类中，并在其中放置一个断点：</p>\n<p><img src=\"https://i2.wp.com/michaelscodingspot.com/wp-content/uploads/2018/12/breakpoint-in-finalizer.jpg?w=1080&ssl=1\" alt=\"img\"></p>\n<ol start=\"2\">\n<li>在场景<strong>开始</strong>时添加以下要调用的魔术3行：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GC.Collect();</span><br><span class=\"line\">GC.WaitForPendingFinalizers();</span><br><span class=\"line\">GC.Collect();</span><br></pre></td></tr></table></figure>\n\n<p>这将迫使GC到目前为止收集所有未引用的实例（不在生产环境中使用），因此它们不会干扰我们的调试。</p>\n<p>3.添加相同的3条魔术代码行，以 <strong>在</strong>方案<strong>之后</strong>运行。请记住，该方案是创建并收集可疑对象的方案。</p>\n<p>4.运行有问题的方案。</p>\n<p>在第1步中，我告诉您在类的终结器中放置一个断点。<strong>在</strong>第一个垃圾回收完成<strong>之后</strong>，您实际上应该注意该断点。否则，您可能会被废弃旧实例感到困惑。需要注意的重要时刻是 您的方案<strong>之后</strong>调试器是否在Finalizer中停止 。 </p>\n<p>它还有助于在类的构造函数中放置一个断点。这样，您可以计算创建次数和完成次数。如果触发了终结器中的断点，则GC会收集您的实例，一切正常。如果没有，则可能发生内存泄漏。</p>\n<p>这是我调试的一种方案，该方案使用了上一种技术中的WeakEventHandler，并且没有内存泄漏：</p>\n<p><video controls src=\"https://michaelscodingspot.com/wp-content/uploads/2018/12/my-class-is-finalized-with-weakEventHandler.mp4\" style=\"box-sizing: border-box; max-width: 100%; margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;\"></video></p>\n<p>这是我使用常规事件注册的另一种情况，它确实存在内存泄漏：</p>\n<p><video controls src=\"https://michaelscodingspot.com/wp-content/uploads/2018/12/my-class-is-not-finalized-with-regular-event.mp4\" style=\"box-sizing: border-box; max-width: 100%; margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;\"></video></p>\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>总是让我感到惊讶的是，C＃看起来像是一种易于学习的语言，并且提供了一个提供训练平台的环境。但实际上，还远远没有做到。诸如使用事件之类的简单事情，可以由未经培训的手轻松地将您的应用程序变成一堆内存泄漏。</p>\n<p>至于在代码中使用的正确模式，我认为本文的结论应该是，在所有情况下都没有正确答案。提供的所有技术，以及他们， 视情况而定是可行的解决方案。 </p>\n<p>原来这是一个相对较大的职位，但在此问题上，我仍然处于较高水平。这恰恰证明了在这些问题上存在多少深度，以及软件开发如何永无止境。</p>\n<p>有关内存泄漏的更多信息，请查看我的文章<a href=\"https://michaelscodingspot.com/2019/01/03/find-fix-and-avoid-memory-leaks-in-c-net-8-best-practices/\" target=\"_blank\" rel=\"noopener\">查找，修复和避免C＃.NET：8最佳实践中的内存泄漏</a>。从我自己的经验和其他高级.NET开发人员那里获得的大量信息都为我提供了建议。它包括有关内存分析器，非托管代码的内存泄漏，监控内存等信息。</p>\n<p>我希望您在评论部分中留下一些反馈。并确保<a href=\"https://michaelscodingspot.com/subscribe/\" target=\"_blank\" rel=\"noopener\">订阅</a>博客并收到新帖子通知。</p>\n"},{"title":"持续交付全流程思考与实践","date":"2020-01-05T13:28:00.000Z","author":"邹溪源","_content":"\n# 1 从理论开始\n## 什么是DevOps?\n近年来，随着DevOps理念的逐渐深入人心，企业逐渐意识到从看似重复的手工劳动中实现自动化流程处理，对于提高企业劳动生产力已经非常重要，尤其是面向互联网的开发者，往往每次上线时，最大的挑战并非需求的走查或测试和改bug，而是由于发布的流程不够规范，将成果发布到目标环境后可能造成的配置错误或引发其他已知未知问题所造成的额外工作量，使得生产环境的发布流程总会存在不顺利。\n\n而DevOps则致力于统一整合软件开发和软件运维，其特点是强烈倡导对构建软件的所有环节（从集成、测试、发布到部署和基础架构管理）进行全面的自动化监控。目标是缩短软件开发周期，提高部署频率和更可靠的发布，与业务目标保持一致。\n\n在实际操作过程中，对于许多公司而言，开发者和运维者并没有明确的界限，而且即便将运维与开发的岗位职责分开了，也并非意味着双方的职业发展方向将大不相同。实际上在实际操作过程中，开发人员和运维人员依然会使用相同的工具、统一的流程、一致的管理思想，并通过一系列管理手段和工具实现流程的优化。\n\n## 什么是持续集成和持续交付？\n持续集成（Continuous Integration）与持续交付(Continuous Delivery)也正是DevOps中最为基础的两种企业级研发和交付活动。\n\n持续集成来源于敏捷项目管理思想，其核心是团队成员应该经常集成他们的工作，通常每天要求集成一次，当然也可以要求团队成员每天集成多次。每次集成之后，会通过持续集成工具自动运行自动化的构建手段（例如编译、单元测试、集成测试、系统测试），并对集成后的成果进行验证，从而实现了企业管理流程中尽早的发现未知问题的目标。而在传统的软件交付中，可能会将所有问题积压到系统整体测试或甚至UAT（用户验收测试）环节，使得软件的测试时间被拉长，甚至使得软件的问题流入到客户现场，让客户成为小白鼠的情况时有发生。\n\n实际上而言，看似简单的集成，却并非简单，他应该是企业管理过程中的一项铁律，只有严格执行，才能确保软件时刻处于可用状态；否则就意味着所谓交付过程中完成进度的百分之多少，只不过是一个虚无缥缈的空口白话。\n\n持续集成往往离不开持续交付，在乔梁老师翻译的《持续交付》一书中，作者Jez Humber说：持续交付是一种能力，也就是说，能够以可持续的方式，安全快速的把代码变更（包括特性、配置、缺陷和试验）部署到生产环境中，让用户使用。这本书的作者也在书的最后一章中指出：它（持续交付）不仅仅是一种新的软件交付方法论，而且对依赖软件的业务来说，也是一种全新的范式。\n\n持续交付与持续部署看似类似，其实有所区别，前者往往是指将环境推送到用户面前，使用户能够触及和使用它们；而部署则仅仅只是把软件包安装到目标计算机上，用户可能还无法直接使用。\n\n对于面向互联网的软件企业来说，往往都已经在过去若干年间已经建立了一套完整的持续集成/持续交付流程，但对于某些处于飞速发展期的企业来说，依然相对而言后知后觉，主要是由于企业过去飞速发展的背后所依托的人力物力资源，能够足以保证企业的产出能够适应企业发展的需要，然而随着团队规模的发展赶不上企业业务发展的需要时，重复劳动和看似毫无价值的等待期、后期积压的测试任务、无法有效度量的软件功能实现，实质上也会造成企业的管理成本进一步提高。\n\n## 从哪里可以获得系统的方法论？\n对于需要搭建一套完整环境的开发者来说，网上资料很齐全，本文也试图尽可能的对各方面的内容进行综述，努力为开发者提供一个开箱即用的操作流程，但是对于那些想系统的学习持续交付或DevOps领域的知识的开发者来说，你其实不仅仅满足于把环境搭起来，那么你应该看看书。\n\n在持续集成和持续交付领域有大量优秀的作品，而我觉得来自乔梁老师的作品《持续交付2.0》堪称精品，乔梁老师是一位经验丰富的行业专家，在他的职业生涯中积累了与该领域相关非常丰富的产品研发经验，他也身体力行的参与到许多企业的持续交付流程优化过程中，这些经验都让他能够从更全面的视角来分析持续交付的问题。在这本书中介绍了许多直接拿来就可以使用的管理方法、项目案例、工具，能够让有需求在该领域有所作为的开发者带来不少思考。\n\n实质上对于一家要实践持续集成/持续交付的企业来说，将工具搭建完成并非核心难点，难点依然在于如何使用敏捷项目管理的思想，实现软件的细粒度任务拆分，并能够对单个任务进行更好的测试，或许TDD是一种不错的模式，但是却可能给开发者的基础技能提出了更高的要求，这将导致TDD无法落地。\n\n如何快速验证产品需求？在《持续交付2.0》中提出的了一系列的方法，例如装饰窗、最小可行特性法、特区法、定向搜索法、稻草人法、、最小可行产品法等六种方法，通过建立快速验证模型，提高软件从需求到实现的整个流程，能够为企业带来不少便利。\n\n而在研发阶段，可以采用特性分支和特性开关的手法，利用git源代码管理工具分支的妙处，将需求和代码有机的耦合在一起，同时又依托项目管理工具，实现从需求=》实现=》发布的完整闭环，从而为需求的验证提供了双保险；特性开关我最早在刘华老师的《猎豹行动-敏捷转型》一书中看到，通过使用软开关的形式，避免未开发完成的提前上线造成巨大的风险，而在这边书中也同样提到了这样的方法。在.NET中同样也可以使用特性分支组件，后期我将尝试一下。\n\n而对于如何减少等待期，作者提到的方法是：\n\n1、通过“拉动”让价值流动起来，例如，如果是一个生产线的滞留，通过扩大瓶颈的处理能力，让更多的需求能够快速交付，这种手法看似能够临时提高环节处理能力，保障团队的产出，但是显然不是个良好的措施，更合理的措施就是根据下游的生产能力来确定上游的处理能力，由下游来拉动上游的需求。这客观上要求将任务和需求的粒度进一步均匀化，将需求划分成更加易于执行、工作量类似的小需求，使得开发过程更加平滑。\n\n2、任务自助化：也就是让团队掌握某些通用技能，以便在其他人员阻塞时，能够同步完成相关任务，避免了某些关键任务阻塞造成了整体流程的滞后。 \n\n在此我就不过多描述书中的精华了，有兴趣的可以入手一本，绝对物超所值。\n\n# 2、总体流程和环境部署\n接下来我将进入本文的主题，首先我将构建一个简单的企业级持续集成/持续交付的管理流程，然后再对流程的实现过程进行较为详细的介绍。\n\n## 流程图\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/jenkins-pipeline/1.png)\n\n在这个流程中，使用了master/dev的分支模式。\n\n1、对于dev分支提交的代码，经过代码编辑、静态代码扫描、自动化单元测试的流程，在运行通过后，有测试人员进行代码的测试，并在代码测试通过后，通过pull request提交给master分支的审查人员进行代码检查和合并。\n\n2、测试人员对dev提交的代码进行确认，并由master分支代码审查人员进行代码审查，通过后对代码进行确认，并生成用于发布的生成包。\n\n## 涉及的组件和说明\n在流程中，使用了以下工具，依次安装即可。\n\n1、安装OpenJDK\n\n2、安装Jenkins和相关插件\n\n3、安装PostgresDb\n\n4、安装SonarQube\n\n5、安装dotnetsdk3.1\n\n6、安装git\n\n7、安装nexus包管理器 for windows版用以实现包管理。\n\n8、安装Qy Wechat Notification或HTTP Request 用以实现企业微信提醒。\n\n好吧，环境安装就不介绍了。。\n\n## 安装补充说明\n1、其中jenkins安装的版本为2.190.3,OpenJDK安装的版本为openjdk12.0。安装完jenkins和openjdk后，需要进行环境变量的设置。 \n\n2、SonarQube安装的版本为7.9.1，根据官方网站的说明，推荐使用的数据库包括：sqlserver\\oracle\\postgresdb，在7.9.1和更高版本中，已经不再推荐使用mysql。 \n\n3、SonarQube默认使用了基于H2内存数据库的嵌入式数据库，可以在测试环境下使用，但是不建议用于生产环境。 \n\n5、安装完sonarqube、和数据库后，需要修改sonarqube/conf/sonar.properties文件中的数据库配置地址，并将sonarqube的服务重启。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/jenkins-pipeline/2.png)\n\n在windows系统中，点击sonarqube-xxx\\bin\\windows-x86-64文件夹中的InstallNTService.bat用以安装SonarQube的服务，而StartNTService.bat则用于启动SonarQube的应用服务。如果数据库配置失败，则SonarQube会启动失败，并提示以下错误：\n\n> [sonar-1510653879773] exception caught on transport layer [[id: 0x346b46fb, /127.0.0.1:59330 => /127.0.0.1:9001]], closing connection\n>java.io.IOException: An existing connection was forcibly closed by the remote host\n\n6、由于使用了自行搭建的Nuget包源管理器，所以在进行构建时，会提示错误，jenkins会使用\n\n## Jenkins的项目类型\n在jenkins中提供了自由风格、单流水线、多分支流水线、多配置项目等不同类型的项目，可以根据实际情况进行取舍，在本人的尝试过程中，分别总结了三种不同类型的项目可适用的场景：\n\n### 自由风格项目\n操作流程简单，无需配置groovy脚本，即可简单的完成项目的自动化构建。 \n\n在自由风格模式的项目中，实现代码编译的过程主要在构建窗口中，主要使用dotnet -相关命令来完成。包括：\n\n1、dotnet restore 还原依赖包。\n\n2、dotnet build 编译\n\n3、dotnet publish -o ./bin/release 发布到指定目录下。\n\n4、如果需要使用sonarqube来进行静态代码检查，需要在服务器上安装dotnet-sonarscanner组件，这个组件是基于.net core构建的静态代码检查组件，安装的命令为：\n\n>dotnet tool install --global dotnet-sonarscanner --version 4.8.0；\n\n5、如果采用.net framework 传统框架，则可以继续使用原来的SonarScanner.MSBuild.exe组件进行代码检查结果的上传。\n\n6、如果需要在自由风格项目中使用powershell脚本，可以在jenkins=》插件管理=》可用插件中搜索powershell即可。\n\n### 单流水线项目\n单流水线项目：可适用于只有一个分支和一套环境需要部署时的项目构建，其发布流程需要使用groovy脚本来实现。点击查看[pipeline的语法](https://jenkins.io/zh/doc/book/pipeline/syntax/)\n\n1、在流水线项目中，都在项目文件的根目录中添加jenkinsfile文件（无扩展名）作为jenkins编译时的脚本文件，而这个文件的脚本语法采用groovy语言，并支持开发者按照脚本语言进行扩展。\n\n2、在单流水线项目中不支持groovy的分支判断条件，支持逻辑比较简单的脚本。\n\n3、与编译有关的结构均写在jenkinsfile中，因此jenkins的UI界面可以理解为配置与项目相关的环境变量信息。\n\n4、可以在jenkinsfile中定义输入的参数，例如：\n\n>parameters{\n>        string(name:'ProjectName', defaultValue: 'Enter Your ProjectName', description: 'Enter your project name here')\n>        string(name:'Contact', defaultValue: '\"@All\",\"xxx\"', description: 'Enter Your Contract') \n>        string(name:'RepoUrl', defaultValue: 'https://gitee.com/xxx/xxx.git', description: ' gitee代码路径')\n>}\n\n在jenkins界面中，可以显示成\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/jenkins-pipeline/3.png)\n\n在具体场景下就可以通过jenkins界面传入相关参数进行编译的测试了。\n\n### 多流水线项目\n多分支流水线项目：使用于一个仓库下各分支不同环境需要部署时的项目构建，其发布流程也需要使用groovy脚本实现。 \n\n1、多流水线项目支持使用分支判断条件的语法，因此可以使用的场景更多。\n\n2、其他的总体上和单分支流水线差不多，此处就不在赘述了。\n\n以下编写了一个简单的示例，仅供参考。\n\n```\npipeline{\n    agent any \n    parameters{\n        string(name:'Contact', defaultValue: '\"@All\",\"\"', description: 'Enter Your Contract') \n        string(name:'RepoUrl', defaultValue: '', description: ' 代码路径')\n        string(name:'SonarUrl', defaultValue: 'http://localhost:9000', description: ' sonar代码路径')\n    } \n    stages {\n        stage('When Master') { \n            when {\n                expression {BRANCH_NAME==~/(master)/}\n            } \n           steps{        \n               checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'xxx', url: params.RepoUrl]]]) \n            }\n        }\n        stage (\"When Dev\"){\n            when {\n                branch 'dev'\n            } \n            steps{ rojectName}\") \n                checkout([$class: 'GitSCM', branches: [[name: '*/dev']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'xxx', url: params.RepoUrl]]])\n                bat \"dotnet restore ${params.SlnName}\"\n                bat \"dotnet-sonarscanner  begin /k:\\\"${params.SlnName}\\\" /d:sonar.host.url=\\\"${params.SonarUrl}\\\" /d:sonar.login=\\\"${params.SonarToken}\\\"\" \n                bat \"dotnet build ${params.SlnName}\"\n                bat '''if not exist bin\\\\release mkdir bin\\\\release'''\n                bat \"dotnet sonarscanner end /d:sonar.login=\\\"${params.SonarToken}\\\"\"\n                echo \"CodeCheck Success\"\n            }\n        } \n        stage(\"test\"){\n            when{\n                expression{return true}\n            }\n            steps{\n                echo \"OK\"\n            }\n        }    \n        stage('Web Dev Build') {\n            steps{\n                echo env.BRANCH_NAME\n                echo params.RepoUrl\n                echo params.SonarUrl\n                  bat \"dotnet build ${params.SlnName}\"\n                bat '''if not exist bin\\\\release mkdir bin\\\\release'''\n                bat '''\n                dotnet publish -o ./bin/release \n                '''\n                echo 'Publish Success'\n            }\n        }  \n    }\n    post{\n      success{\n        SendToWeChatWork(\"CI Task success,ProjectName is ${params.ProjectName}\") \n        echo 'Publish Success'\n      }\n      failure{\n        SendToWeChatWork(\"CI Task Failure,ProjectName is ${params.ProjectName}\") \n        echo 'Publish Failure'\n        }\n    }\n}\ndef SendToWeChatWork(content) {   \n    def command = \"\"\"{\n          \"msgtype\": \"text\",\n          \"text\": {\n          \"content\": \"${content},See the detail in Control Panel:${params.Jenkins}\",\n          \"mentioned_list\":[\"${params.Contact}\"]\n          }\n         \"\"\"\n    echo(command)\n    response = httpRequest (consoleLogResponseBody: true,\n      contentType: 'APPLICATION_JSON',\n      httpMode: 'POST',\n      requestBody: command,\n      url: \"${params.WeChatWork}\",\n      validResponseCodes: '200')\n    return response\n}\n```\n### 多配置项目\n如果组件代码需要在不同的配置、不同的环境下重复部署，其基本逻辑类似，只是配置不同，就可以使用多配置项目。\n\n好吧，我就没有尝试了，因为我已经用了多流水线项目来实现了。在这篇[示例](http://dtt4725.github.io/blog/2016/07/25/Jenkins%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Multi-Configuration-Projects/)中对多配置项目有比较详细的用法，需要可自取。 \n\n# 总结\n将企业级持续集成的环境搭建起来本身并不难，难的是如何将整套体系与公司现有的开发流程相结合，考虑到受康威定律的影响，不同的组织对于新事物的接受程度总是不同的，原有组织或许已经习惯了基于手工拷贝再部署的模式，而目前采用这种持续集成、持续发布的模式，会产出哪些问题，这需要随时做好应对的方案。\n\n","source":"_posts/技术/持续交付全流程思考与实践.md","raw":"---\ntitle:  持续交付全流程思考与实践\ndate: 2020-01-05 21:28\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n\n# 1 从理论开始\n## 什么是DevOps?\n近年来，随着DevOps理念的逐渐深入人心，企业逐渐意识到从看似重复的手工劳动中实现自动化流程处理，对于提高企业劳动生产力已经非常重要，尤其是面向互联网的开发者，往往每次上线时，最大的挑战并非需求的走查或测试和改bug，而是由于发布的流程不够规范，将成果发布到目标环境后可能造成的配置错误或引发其他已知未知问题所造成的额外工作量，使得生产环境的发布流程总会存在不顺利。\n\n而DevOps则致力于统一整合软件开发和软件运维，其特点是强烈倡导对构建软件的所有环节（从集成、测试、发布到部署和基础架构管理）进行全面的自动化监控。目标是缩短软件开发周期，提高部署频率和更可靠的发布，与业务目标保持一致。\n\n在实际操作过程中，对于许多公司而言，开发者和运维者并没有明确的界限，而且即便将运维与开发的岗位职责分开了，也并非意味着双方的职业发展方向将大不相同。实际上在实际操作过程中，开发人员和运维人员依然会使用相同的工具、统一的流程、一致的管理思想，并通过一系列管理手段和工具实现流程的优化。\n\n## 什么是持续集成和持续交付？\n持续集成（Continuous Integration）与持续交付(Continuous Delivery)也正是DevOps中最为基础的两种企业级研发和交付活动。\n\n持续集成来源于敏捷项目管理思想，其核心是团队成员应该经常集成他们的工作，通常每天要求集成一次，当然也可以要求团队成员每天集成多次。每次集成之后，会通过持续集成工具自动运行自动化的构建手段（例如编译、单元测试、集成测试、系统测试），并对集成后的成果进行验证，从而实现了企业管理流程中尽早的发现未知问题的目标。而在传统的软件交付中，可能会将所有问题积压到系统整体测试或甚至UAT（用户验收测试）环节，使得软件的测试时间被拉长，甚至使得软件的问题流入到客户现场，让客户成为小白鼠的情况时有发生。\n\n实际上而言，看似简单的集成，却并非简单，他应该是企业管理过程中的一项铁律，只有严格执行，才能确保软件时刻处于可用状态；否则就意味着所谓交付过程中完成进度的百分之多少，只不过是一个虚无缥缈的空口白话。\n\n持续集成往往离不开持续交付，在乔梁老师翻译的《持续交付》一书中，作者Jez Humber说：持续交付是一种能力，也就是说，能够以可持续的方式，安全快速的把代码变更（包括特性、配置、缺陷和试验）部署到生产环境中，让用户使用。这本书的作者也在书的最后一章中指出：它（持续交付）不仅仅是一种新的软件交付方法论，而且对依赖软件的业务来说，也是一种全新的范式。\n\n持续交付与持续部署看似类似，其实有所区别，前者往往是指将环境推送到用户面前，使用户能够触及和使用它们；而部署则仅仅只是把软件包安装到目标计算机上，用户可能还无法直接使用。\n\n对于面向互联网的软件企业来说，往往都已经在过去若干年间已经建立了一套完整的持续集成/持续交付流程，但对于某些处于飞速发展期的企业来说，依然相对而言后知后觉，主要是由于企业过去飞速发展的背后所依托的人力物力资源，能够足以保证企业的产出能够适应企业发展的需要，然而随着团队规模的发展赶不上企业业务发展的需要时，重复劳动和看似毫无价值的等待期、后期积压的测试任务、无法有效度量的软件功能实现，实质上也会造成企业的管理成本进一步提高。\n\n## 从哪里可以获得系统的方法论？\n对于需要搭建一套完整环境的开发者来说，网上资料很齐全，本文也试图尽可能的对各方面的内容进行综述，努力为开发者提供一个开箱即用的操作流程，但是对于那些想系统的学习持续交付或DevOps领域的知识的开发者来说，你其实不仅仅满足于把环境搭起来，那么你应该看看书。\n\n在持续集成和持续交付领域有大量优秀的作品，而我觉得来自乔梁老师的作品《持续交付2.0》堪称精品，乔梁老师是一位经验丰富的行业专家，在他的职业生涯中积累了与该领域相关非常丰富的产品研发经验，他也身体力行的参与到许多企业的持续交付流程优化过程中，这些经验都让他能够从更全面的视角来分析持续交付的问题。在这本书中介绍了许多直接拿来就可以使用的管理方法、项目案例、工具，能够让有需求在该领域有所作为的开发者带来不少思考。\n\n实质上对于一家要实践持续集成/持续交付的企业来说，将工具搭建完成并非核心难点，难点依然在于如何使用敏捷项目管理的思想，实现软件的细粒度任务拆分，并能够对单个任务进行更好的测试，或许TDD是一种不错的模式，但是却可能给开发者的基础技能提出了更高的要求，这将导致TDD无法落地。\n\n如何快速验证产品需求？在《持续交付2.0》中提出的了一系列的方法，例如装饰窗、最小可行特性法、特区法、定向搜索法、稻草人法、、最小可行产品法等六种方法，通过建立快速验证模型，提高软件从需求到实现的整个流程，能够为企业带来不少便利。\n\n而在研发阶段，可以采用特性分支和特性开关的手法，利用git源代码管理工具分支的妙处，将需求和代码有机的耦合在一起，同时又依托项目管理工具，实现从需求=》实现=》发布的完整闭环，从而为需求的验证提供了双保险；特性开关我最早在刘华老师的《猎豹行动-敏捷转型》一书中看到，通过使用软开关的形式，避免未开发完成的提前上线造成巨大的风险，而在这边书中也同样提到了这样的方法。在.NET中同样也可以使用特性分支组件，后期我将尝试一下。\n\n而对于如何减少等待期，作者提到的方法是：\n\n1、通过“拉动”让价值流动起来，例如，如果是一个生产线的滞留，通过扩大瓶颈的处理能力，让更多的需求能够快速交付，这种手法看似能够临时提高环节处理能力，保障团队的产出，但是显然不是个良好的措施，更合理的措施就是根据下游的生产能力来确定上游的处理能力，由下游来拉动上游的需求。这客观上要求将任务和需求的粒度进一步均匀化，将需求划分成更加易于执行、工作量类似的小需求，使得开发过程更加平滑。\n\n2、任务自助化：也就是让团队掌握某些通用技能，以便在其他人员阻塞时，能够同步完成相关任务，避免了某些关键任务阻塞造成了整体流程的滞后。 \n\n在此我就不过多描述书中的精华了，有兴趣的可以入手一本，绝对物超所值。\n\n# 2、总体流程和环境部署\n接下来我将进入本文的主题，首先我将构建一个简单的企业级持续集成/持续交付的管理流程，然后再对流程的实现过程进行较为详细的介绍。\n\n## 流程图\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/jenkins-pipeline/1.png)\n\n在这个流程中，使用了master/dev的分支模式。\n\n1、对于dev分支提交的代码，经过代码编辑、静态代码扫描、自动化单元测试的流程，在运行通过后，有测试人员进行代码的测试，并在代码测试通过后，通过pull request提交给master分支的审查人员进行代码检查和合并。\n\n2、测试人员对dev提交的代码进行确认，并由master分支代码审查人员进行代码审查，通过后对代码进行确认，并生成用于发布的生成包。\n\n## 涉及的组件和说明\n在流程中，使用了以下工具，依次安装即可。\n\n1、安装OpenJDK\n\n2、安装Jenkins和相关插件\n\n3、安装PostgresDb\n\n4、安装SonarQube\n\n5、安装dotnetsdk3.1\n\n6、安装git\n\n7、安装nexus包管理器 for windows版用以实现包管理。\n\n8、安装Qy Wechat Notification或HTTP Request 用以实现企业微信提醒。\n\n好吧，环境安装就不介绍了。。\n\n## 安装补充说明\n1、其中jenkins安装的版本为2.190.3,OpenJDK安装的版本为openjdk12.0。安装完jenkins和openjdk后，需要进行环境变量的设置。 \n\n2、SonarQube安装的版本为7.9.1，根据官方网站的说明，推荐使用的数据库包括：sqlserver\\oracle\\postgresdb，在7.9.1和更高版本中，已经不再推荐使用mysql。 \n\n3、SonarQube默认使用了基于H2内存数据库的嵌入式数据库，可以在测试环境下使用，但是不建议用于生产环境。 \n\n5、安装完sonarqube、和数据库后，需要修改sonarqube/conf/sonar.properties文件中的数据库配置地址，并将sonarqube的服务重启。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/jenkins-pipeline/2.png)\n\n在windows系统中，点击sonarqube-xxx\\bin\\windows-x86-64文件夹中的InstallNTService.bat用以安装SonarQube的服务，而StartNTService.bat则用于启动SonarQube的应用服务。如果数据库配置失败，则SonarQube会启动失败，并提示以下错误：\n\n> [sonar-1510653879773] exception caught on transport layer [[id: 0x346b46fb, /127.0.0.1:59330 => /127.0.0.1:9001]], closing connection\n>java.io.IOException: An existing connection was forcibly closed by the remote host\n\n6、由于使用了自行搭建的Nuget包源管理器，所以在进行构建时，会提示错误，jenkins会使用\n\n## Jenkins的项目类型\n在jenkins中提供了自由风格、单流水线、多分支流水线、多配置项目等不同类型的项目，可以根据实际情况进行取舍，在本人的尝试过程中，分别总结了三种不同类型的项目可适用的场景：\n\n### 自由风格项目\n操作流程简单，无需配置groovy脚本，即可简单的完成项目的自动化构建。 \n\n在自由风格模式的项目中，实现代码编译的过程主要在构建窗口中，主要使用dotnet -相关命令来完成。包括：\n\n1、dotnet restore 还原依赖包。\n\n2、dotnet build 编译\n\n3、dotnet publish -o ./bin/release 发布到指定目录下。\n\n4、如果需要使用sonarqube来进行静态代码检查，需要在服务器上安装dotnet-sonarscanner组件，这个组件是基于.net core构建的静态代码检查组件，安装的命令为：\n\n>dotnet tool install --global dotnet-sonarscanner --version 4.8.0；\n\n5、如果采用.net framework 传统框架，则可以继续使用原来的SonarScanner.MSBuild.exe组件进行代码检查结果的上传。\n\n6、如果需要在自由风格项目中使用powershell脚本，可以在jenkins=》插件管理=》可用插件中搜索powershell即可。\n\n### 单流水线项目\n单流水线项目：可适用于只有一个分支和一套环境需要部署时的项目构建，其发布流程需要使用groovy脚本来实现。点击查看[pipeline的语法](https://jenkins.io/zh/doc/book/pipeline/syntax/)\n\n1、在流水线项目中，都在项目文件的根目录中添加jenkinsfile文件（无扩展名）作为jenkins编译时的脚本文件，而这个文件的脚本语法采用groovy语言，并支持开发者按照脚本语言进行扩展。\n\n2、在单流水线项目中不支持groovy的分支判断条件，支持逻辑比较简单的脚本。\n\n3、与编译有关的结构均写在jenkinsfile中，因此jenkins的UI界面可以理解为配置与项目相关的环境变量信息。\n\n4、可以在jenkinsfile中定义输入的参数，例如：\n\n>parameters{\n>        string(name:'ProjectName', defaultValue: 'Enter Your ProjectName', description: 'Enter your project name here')\n>        string(name:'Contact', defaultValue: '\"@All\",\"xxx\"', description: 'Enter Your Contract') \n>        string(name:'RepoUrl', defaultValue: 'https://gitee.com/xxx/xxx.git', description: ' gitee代码路径')\n>}\n\n在jenkins界面中，可以显示成\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/jenkins-pipeline/3.png)\n\n在具体场景下就可以通过jenkins界面传入相关参数进行编译的测试了。\n\n### 多流水线项目\n多分支流水线项目：使用于一个仓库下各分支不同环境需要部署时的项目构建，其发布流程也需要使用groovy脚本实现。 \n\n1、多流水线项目支持使用分支判断条件的语法，因此可以使用的场景更多。\n\n2、其他的总体上和单分支流水线差不多，此处就不在赘述了。\n\n以下编写了一个简单的示例，仅供参考。\n\n```\npipeline{\n    agent any \n    parameters{\n        string(name:'Contact', defaultValue: '\"@All\",\"\"', description: 'Enter Your Contract') \n        string(name:'RepoUrl', defaultValue: '', description: ' 代码路径')\n        string(name:'SonarUrl', defaultValue: 'http://localhost:9000', description: ' sonar代码路径')\n    } \n    stages {\n        stage('When Master') { \n            when {\n                expression {BRANCH_NAME==~/(master)/}\n            } \n           steps{        \n               checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'xxx', url: params.RepoUrl]]]) \n            }\n        }\n        stage (\"When Dev\"){\n            when {\n                branch 'dev'\n            } \n            steps{ rojectName}\") \n                checkout([$class: 'GitSCM', branches: [[name: '*/dev']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'xxx', url: params.RepoUrl]]])\n                bat \"dotnet restore ${params.SlnName}\"\n                bat \"dotnet-sonarscanner  begin /k:\\\"${params.SlnName}\\\" /d:sonar.host.url=\\\"${params.SonarUrl}\\\" /d:sonar.login=\\\"${params.SonarToken}\\\"\" \n                bat \"dotnet build ${params.SlnName}\"\n                bat '''if not exist bin\\\\release mkdir bin\\\\release'''\n                bat \"dotnet sonarscanner end /d:sonar.login=\\\"${params.SonarToken}\\\"\"\n                echo \"CodeCheck Success\"\n            }\n        } \n        stage(\"test\"){\n            when{\n                expression{return true}\n            }\n            steps{\n                echo \"OK\"\n            }\n        }    \n        stage('Web Dev Build') {\n            steps{\n                echo env.BRANCH_NAME\n                echo params.RepoUrl\n                echo params.SonarUrl\n                  bat \"dotnet build ${params.SlnName}\"\n                bat '''if not exist bin\\\\release mkdir bin\\\\release'''\n                bat '''\n                dotnet publish -o ./bin/release \n                '''\n                echo 'Publish Success'\n            }\n        }  \n    }\n    post{\n      success{\n        SendToWeChatWork(\"CI Task success,ProjectName is ${params.ProjectName}\") \n        echo 'Publish Success'\n      }\n      failure{\n        SendToWeChatWork(\"CI Task Failure,ProjectName is ${params.ProjectName}\") \n        echo 'Publish Failure'\n        }\n    }\n}\ndef SendToWeChatWork(content) {   \n    def command = \"\"\"{\n          \"msgtype\": \"text\",\n          \"text\": {\n          \"content\": \"${content},See the detail in Control Panel:${params.Jenkins}\",\n          \"mentioned_list\":[\"${params.Contact}\"]\n          }\n         \"\"\"\n    echo(command)\n    response = httpRequest (consoleLogResponseBody: true,\n      contentType: 'APPLICATION_JSON',\n      httpMode: 'POST',\n      requestBody: command,\n      url: \"${params.WeChatWork}\",\n      validResponseCodes: '200')\n    return response\n}\n```\n### 多配置项目\n如果组件代码需要在不同的配置、不同的环境下重复部署，其基本逻辑类似，只是配置不同，就可以使用多配置项目。\n\n好吧，我就没有尝试了，因为我已经用了多流水线项目来实现了。在这篇[示例](http://dtt4725.github.io/blog/2016/07/25/Jenkins%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Multi-Configuration-Projects/)中对多配置项目有比较详细的用法，需要可自取。 \n\n# 总结\n将企业级持续集成的环境搭建起来本身并不难，难的是如何将整套体系与公司现有的开发流程相结合，考虑到受康威定律的影响，不同的组织对于新事物的接受程度总是不同的，原有组织或许已经习惯了基于手工拷贝再部署的模式，而目前采用这种持续集成、持续发布的模式，会产出哪些问题，这需要随时做好应对的方案。\n\n","slug":"技术/持续交付全流程思考与实践","published":1,"updated":"2020-01-09T14:24:04.412Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt7t001jn4vimcmfg8wh","content":"<h1 id=\"1-从理论开始\"><a href=\"#1-从理论开始\" class=\"headerlink\" title=\"1 从理论开始\"></a>1 从理论开始</h1><h2 id=\"什么是DevOps\"><a href=\"#什么是DevOps\" class=\"headerlink\" title=\"什么是DevOps?\"></a>什么是DevOps?</h2><p>近年来，随着DevOps理念的逐渐深入人心，企业逐渐意识到从看似重复的手工劳动中实现自动化流程处理，对于提高企业劳动生产力已经非常重要，尤其是面向互联网的开发者，往往每次上线时，最大的挑战并非需求的走查或测试和改bug，而是由于发布的流程不够规范，将成果发布到目标环境后可能造成的配置错误或引发其他已知未知问题所造成的额外工作量，使得生产环境的发布流程总会存在不顺利。</p>\n<p>而DevOps则致力于统一整合软件开发和软件运维，其特点是强烈倡导对构建软件的所有环节（从集成、测试、发布到部署和基础架构管理）进行全面的自动化监控。目标是缩短软件开发周期，提高部署频率和更可靠的发布，与业务目标保持一致。</p>\n<p>在实际操作过程中，对于许多公司而言，开发者和运维者并没有明确的界限，而且即便将运维与开发的岗位职责分开了，也并非意味着双方的职业发展方向将大不相同。实际上在实际操作过程中，开发人员和运维人员依然会使用相同的工具、统一的流程、一致的管理思想，并通过一系列管理手段和工具实现流程的优化。</p>\n<h2 id=\"什么是持续集成和持续交付？\"><a href=\"#什么是持续集成和持续交付？\" class=\"headerlink\" title=\"什么是持续集成和持续交付？\"></a>什么是持续集成和持续交付？</h2><p>持续集成（Continuous Integration）与持续交付(Continuous Delivery)也正是DevOps中最为基础的两种企业级研发和交付活动。</p>\n<p>持续集成来源于敏捷项目管理思想，其核心是团队成员应该经常集成他们的工作，通常每天要求集成一次，当然也可以要求团队成员每天集成多次。每次集成之后，会通过持续集成工具自动运行自动化的构建手段（例如编译、单元测试、集成测试、系统测试），并对集成后的成果进行验证，从而实现了企业管理流程中尽早的发现未知问题的目标。而在传统的软件交付中，可能会将所有问题积压到系统整体测试或甚至UAT（用户验收测试）环节，使得软件的测试时间被拉长，甚至使得软件的问题流入到客户现场，让客户成为小白鼠的情况时有发生。</p>\n<p>实际上而言，看似简单的集成，却并非简单，他应该是企业管理过程中的一项铁律，只有严格执行，才能确保软件时刻处于可用状态；否则就意味着所谓交付过程中完成进度的百分之多少，只不过是一个虚无缥缈的空口白话。</p>\n<p>持续集成往往离不开持续交付，在乔梁老师翻译的《持续交付》一书中，作者Jez Humber说：持续交付是一种能力，也就是说，能够以可持续的方式，安全快速的把代码变更（包括特性、配置、缺陷和试验）部署到生产环境中，让用户使用。这本书的作者也在书的最后一章中指出：它（持续交付）不仅仅是一种新的软件交付方法论，而且对依赖软件的业务来说，也是一种全新的范式。</p>\n<p>持续交付与持续部署看似类似，其实有所区别，前者往往是指将环境推送到用户面前，使用户能够触及和使用它们；而部署则仅仅只是把软件包安装到目标计算机上，用户可能还无法直接使用。</p>\n<p>对于面向互联网的软件企业来说，往往都已经在过去若干年间已经建立了一套完整的持续集成/持续交付流程，但对于某些处于飞速发展期的企业来说，依然相对而言后知后觉，主要是由于企业过去飞速发展的背后所依托的人力物力资源，能够足以保证企业的产出能够适应企业发展的需要，然而随着团队规模的发展赶不上企业业务发展的需要时，重复劳动和看似毫无价值的等待期、后期积压的测试任务、无法有效度量的软件功能实现，实质上也会造成企业的管理成本进一步提高。</p>\n<h2 id=\"从哪里可以获得系统的方法论？\"><a href=\"#从哪里可以获得系统的方法论？\" class=\"headerlink\" title=\"从哪里可以获得系统的方法论？\"></a>从哪里可以获得系统的方法论？</h2><p>对于需要搭建一套完整环境的开发者来说，网上资料很齐全，本文也试图尽可能的对各方面的内容进行综述，努力为开发者提供一个开箱即用的操作流程，但是对于那些想系统的学习持续交付或DevOps领域的知识的开发者来说，你其实不仅仅满足于把环境搭起来，那么你应该看看书。</p>\n<p>在持续集成和持续交付领域有大量优秀的作品，而我觉得来自乔梁老师的作品《持续交付2.0》堪称精品，乔梁老师是一位经验丰富的行业专家，在他的职业生涯中积累了与该领域相关非常丰富的产品研发经验，他也身体力行的参与到许多企业的持续交付流程优化过程中，这些经验都让他能够从更全面的视角来分析持续交付的问题。在这本书中介绍了许多直接拿来就可以使用的管理方法、项目案例、工具，能够让有需求在该领域有所作为的开发者带来不少思考。</p>\n<p>实质上对于一家要实践持续集成/持续交付的企业来说，将工具搭建完成并非核心难点，难点依然在于如何使用敏捷项目管理的思想，实现软件的细粒度任务拆分，并能够对单个任务进行更好的测试，或许TDD是一种不错的模式，但是却可能给开发者的基础技能提出了更高的要求，这将导致TDD无法落地。</p>\n<p>如何快速验证产品需求？在《持续交付2.0》中提出的了一系列的方法，例如装饰窗、最小可行特性法、特区法、定向搜索法、稻草人法、、最小可行产品法等六种方法，通过建立快速验证模型，提高软件从需求到实现的整个流程，能够为企业带来不少便利。</p>\n<p>而在研发阶段，可以采用特性分支和特性开关的手法，利用git源代码管理工具分支的妙处，将需求和代码有机的耦合在一起，同时又依托项目管理工具，实现从需求=》实现=》发布的完整闭环，从而为需求的验证提供了双保险；特性开关我最早在刘华老师的《猎豹行动-敏捷转型》一书中看到，通过使用软开关的形式，避免未开发完成的提前上线造成巨大的风险，而在这边书中也同样提到了这样的方法。在.NET中同样也可以使用特性分支组件，后期我将尝试一下。</p>\n<p>而对于如何减少等待期，作者提到的方法是：</p>\n<p>1、通过“拉动”让价值流动起来，例如，如果是一个生产线的滞留，通过扩大瓶颈的处理能力，让更多的需求能够快速交付，这种手法看似能够临时提高环节处理能力，保障团队的产出，但是显然不是个良好的措施，更合理的措施就是根据下游的生产能力来确定上游的处理能力，由下游来拉动上游的需求。这客观上要求将任务和需求的粒度进一步均匀化，将需求划分成更加易于执行、工作量类似的小需求，使得开发过程更加平滑。</p>\n<p>2、任务自助化：也就是让团队掌握某些通用技能，以便在其他人员阻塞时，能够同步完成相关任务，避免了某些关键任务阻塞造成了整体流程的滞后。 </p>\n<p>在此我就不过多描述书中的精华了，有兴趣的可以入手一本，绝对物超所值。</p>\n<h1 id=\"2、总体流程和环境部署\"><a href=\"#2、总体流程和环境部署\" class=\"headerlink\" title=\"2、总体流程和环境部署\"></a>2、总体流程和环境部署</h1><p>接下来我将进入本文的主题，首先我将构建一个简单的企业级持续集成/持续交付的管理流程，然后再对流程的实现过程进行较为详细的介绍。</p>\n<h2 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图</h2><p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/jenkins-pipeline/1.png\" alt=\"图片\"></p>\n<p>在这个流程中，使用了master/dev的分支模式。</p>\n<p>1、对于dev分支提交的代码，经过代码编辑、静态代码扫描、自动化单元测试的流程，在运行通过后，有测试人员进行代码的测试，并在代码测试通过后，通过pull request提交给master分支的审查人员进行代码检查和合并。</p>\n<p>2、测试人员对dev提交的代码进行确认，并由master分支代码审查人员进行代码审查，通过后对代码进行确认，并生成用于发布的生成包。</p>\n<h2 id=\"涉及的组件和说明\"><a href=\"#涉及的组件和说明\" class=\"headerlink\" title=\"涉及的组件和说明\"></a>涉及的组件和说明</h2><p>在流程中，使用了以下工具，依次安装即可。</p>\n<p>1、安装OpenJDK</p>\n<p>2、安装Jenkins和相关插件</p>\n<p>3、安装PostgresDb</p>\n<p>4、安装SonarQube</p>\n<p>5、安装dotnetsdk3.1</p>\n<p>6、安装git</p>\n<p>7、安装nexus包管理器 for windows版用以实现包管理。</p>\n<p>8、安装Qy Wechat Notification或HTTP Request 用以实现企业微信提醒。</p>\n<p>好吧，环境安装就不介绍了。。</p>\n<h2 id=\"安装补充说明\"><a href=\"#安装补充说明\" class=\"headerlink\" title=\"安装补充说明\"></a>安装补充说明</h2><p>1、其中jenkins安装的版本为2.190.3,OpenJDK安装的版本为openjdk12.0。安装完jenkins和openjdk后，需要进行环境变量的设置。 </p>\n<p>2、SonarQube安装的版本为7.9.1，根据官方网站的说明，推荐使用的数据库包括：sqlserver\\oracle\\postgresdb，在7.9.1和更高版本中，已经不再推荐使用mysql。 </p>\n<p>3、SonarQube默认使用了基于H2内存数据库的嵌入式数据库，可以在测试环境下使用，但是不建议用于生产环境。 </p>\n<p>5、安装完sonarqube、和数据库后，需要修改sonarqube/conf/sonar.properties文件中的数据库配置地址，并将sonarqube的服务重启。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/jenkins-pipeline/2.png\" alt=\"图片\"></p>\n<p>在windows系统中，点击sonarqube-xxx\\bin\\windows-x86-64文件夹中的InstallNTService.bat用以安装SonarQube的服务，而StartNTService.bat则用于启动SonarQube的应用服务。如果数据库配置失败，则SonarQube会启动失败，并提示以下错误：</p>\n<blockquote>\n<p>[sonar-1510653879773] exception caught on transport layer [[id: 0x346b46fb, /127.0.0.1:59330 =&gt; /127.0.0.1:9001]], closing connection<br>java.io.IOException: An existing connection was forcibly closed by the remote host</p>\n</blockquote>\n<p>6、由于使用了自行搭建的Nuget包源管理器，所以在进行构建时，会提示错误，jenkins会使用</p>\n<h2 id=\"Jenkins的项目类型\"><a href=\"#Jenkins的项目类型\" class=\"headerlink\" title=\"Jenkins的项目类型\"></a>Jenkins的项目类型</h2><p>在jenkins中提供了自由风格、单流水线、多分支流水线、多配置项目等不同类型的项目，可以根据实际情况进行取舍，在本人的尝试过程中，分别总结了三种不同类型的项目可适用的场景：</p>\n<h3 id=\"自由风格项目\"><a href=\"#自由风格项目\" class=\"headerlink\" title=\"自由风格项目\"></a>自由风格项目</h3><p>操作流程简单，无需配置groovy脚本，即可简单的完成项目的自动化构建。 </p>\n<p>在自由风格模式的项目中，实现代码编译的过程主要在构建窗口中，主要使用dotnet -相关命令来完成。包括：</p>\n<p>1、dotnet restore 还原依赖包。</p>\n<p>2、dotnet build 编译</p>\n<p>3、dotnet publish -o ./bin/release 发布到指定目录下。</p>\n<p>4、如果需要使用sonarqube来进行静态代码检查，需要在服务器上安装dotnet-sonarscanner组件，这个组件是基于.net core构建的静态代码检查组件，安装的命令为：</p>\n<blockquote>\n<p>dotnet tool install –global dotnet-sonarscanner –version 4.8.0；</p>\n</blockquote>\n<p>5、如果采用.net framework 传统框架，则可以继续使用原来的SonarScanner.MSBuild.exe组件进行代码检查结果的上传。</p>\n<p>6、如果需要在自由风格项目中使用powershell脚本，可以在jenkins=》插件管理=》可用插件中搜索powershell即可。</p>\n<h3 id=\"单流水线项目\"><a href=\"#单流水线项目\" class=\"headerlink\" title=\"单流水线项目\"></a>单流水线项目</h3><p>单流水线项目：可适用于只有一个分支和一套环境需要部署时的项目构建，其发布流程需要使用groovy脚本来实现。点击查看<a href=\"https://jenkins.io/zh/doc/book/pipeline/syntax/\" target=\"_blank\" rel=\"noopener\">pipeline的语法</a></p>\n<p>1、在流水线项目中，都在项目文件的根目录中添加jenkinsfile文件（无扩展名）作为jenkins编译时的脚本文件，而这个文件的脚本语法采用groovy语言，并支持开发者按照脚本语言进行扩展。</p>\n<p>2、在单流水线项目中不支持groovy的分支判断条件，支持逻辑比较简单的脚本。</p>\n<p>3、与编译有关的结构均写在jenkinsfile中，因此jenkins的UI界面可以理解为配置与项目相关的环境变量信息。</p>\n<p>4、可以在jenkinsfile中定义输入的参数，例如：</p>\n<blockquote>\n<p>parameters{<br>       string(name:’ProjectName’, defaultValue: ‘Enter Your ProjectName’, description: ‘Enter your project name here’)<br>       string(name:’Contact’, defaultValue: ‘“@All”,”xxx”‘, description: ‘Enter Your Contract’)<br>       string(name:’RepoUrl’, defaultValue: ‘<a href=\"https://gitee.com/xxx/xxx.git&#39;\" target=\"_blank\" rel=\"noopener\">https://gitee.com/xxx/xxx.git&#39;</a>, description: ‘ gitee代码路径’)<br>}</p>\n</blockquote>\n<p>在jenkins界面中，可以显示成</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/jenkins-pipeline/3.png\" alt=\"图片\"></p>\n<p>在具体场景下就可以通过jenkins界面传入相关参数进行编译的测试了。</p>\n<h3 id=\"多流水线项目\"><a href=\"#多流水线项目\" class=\"headerlink\" title=\"多流水线项目\"></a>多流水线项目</h3><p>多分支流水线项目：使用于一个仓库下各分支不同环境需要部署时的项目构建，其发布流程也需要使用groovy脚本实现。 </p>\n<p>1、多流水线项目支持使用分支判断条件的语法，因此可以使用的场景更多。</p>\n<p>2、其他的总体上和单分支流水线差不多，此处就不在赘述了。</p>\n<p>以下编写了一个简单的示例，仅供参考。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline&#123;</span><br><span class=\"line\">    agent any </span><br><span class=\"line\">    parameters&#123;</span><br><span class=\"line\">        string(name:&apos;Contact&apos;, defaultValue: &apos;&quot;@All&quot;,&quot;&quot;&apos;, description: &apos;Enter Your Contract&apos;) </span><br><span class=\"line\">        string(name:&apos;RepoUrl&apos;, defaultValue: &apos;&apos;, description: &apos; 代码路径&apos;)</span><br><span class=\"line\">        string(name:&apos;SonarUrl&apos;, defaultValue: &apos;http://localhost:9000&apos;, description: &apos; sonar代码路径&apos;)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    stages &#123;</span><br><span class=\"line\">        stage(&apos;When Master&apos;) &#123; </span><br><span class=\"line\">            when &#123;</span><br><span class=\"line\">                expression &#123;BRANCH_NAME==~/(master)/&#125;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">           steps&#123;        </span><br><span class=\"line\">               checkout([$class: &apos;GitSCM&apos;, branches: [[name: &apos;*/master&apos;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: &apos;xxx&apos;, url: params.RepoUrl]]]) </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stage (&quot;When Dev&quot;)&#123;</span><br><span class=\"line\">            when &#123;</span><br><span class=\"line\">                branch &apos;dev&apos;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            steps&#123; rojectName&#125;&quot;) </span><br><span class=\"line\">                checkout([$class: &apos;GitSCM&apos;, branches: [[name: &apos;*/dev&apos;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: &apos;xxx&apos;, url: params.RepoUrl]]])</span><br><span class=\"line\">                bat &quot;dotnet restore $&#123;params.SlnName&#125;&quot;</span><br><span class=\"line\">                bat &quot;dotnet-sonarscanner  begin /k:\\&quot;$&#123;params.SlnName&#125;\\&quot; /d:sonar.host.url=\\&quot;$&#123;params.SonarUrl&#125;\\&quot; /d:sonar.login=\\&quot;$&#123;params.SonarToken&#125;\\&quot;&quot; </span><br><span class=\"line\">                bat &quot;dotnet build $&#123;params.SlnName&#125;&quot;</span><br><span class=\"line\">                bat &apos;&apos;&apos;if not exist bin\\\\release mkdir bin\\\\release&apos;&apos;&apos;</span><br><span class=\"line\">                bat &quot;dotnet sonarscanner end /d:sonar.login=\\&quot;$&#123;params.SonarToken&#125;\\&quot;&quot;</span><br><span class=\"line\">                echo &quot;CodeCheck Success&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        stage(&quot;test&quot;)&#123;</span><br><span class=\"line\">            when&#123;</span><br><span class=\"line\">                expression&#123;return true&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            steps&#123;</span><br><span class=\"line\">                echo &quot;OK&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">        stage(&apos;Web Dev Build&apos;) &#123;</span><br><span class=\"line\">            steps&#123;</span><br><span class=\"line\">                echo env.BRANCH_NAME</span><br><span class=\"line\">                echo params.RepoUrl</span><br><span class=\"line\">                echo params.SonarUrl</span><br><span class=\"line\">                  bat &quot;dotnet build $&#123;params.SlnName&#125;&quot;</span><br><span class=\"line\">                bat &apos;&apos;&apos;if not exist bin\\\\release mkdir bin\\\\release&apos;&apos;&apos;</span><br><span class=\"line\">                bat &apos;&apos;&apos;</span><br><span class=\"line\">                dotnet publish -o ./bin/release </span><br><span class=\"line\">                &apos;&apos;&apos;</span><br><span class=\"line\">                echo &apos;Publish Success&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    post&#123;</span><br><span class=\"line\">      success&#123;</span><br><span class=\"line\">        SendToWeChatWork(&quot;CI Task success,ProjectName is $&#123;params.ProjectName&#125;&quot;) </span><br><span class=\"line\">        echo &apos;Publish Success&apos;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      failure&#123;</span><br><span class=\"line\">        SendToWeChatWork(&quot;CI Task Failure,ProjectName is $&#123;params.ProjectName&#125;&quot;) </span><br><span class=\"line\">        echo &apos;Publish Failure&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">def SendToWeChatWork(content) &#123;   </span><br><span class=\"line\">    def command = &quot;&quot;&quot;&#123;</span><br><span class=\"line\">          &quot;msgtype&quot;: &quot;text&quot;,</span><br><span class=\"line\">          &quot;text&quot;: &#123;</span><br><span class=\"line\">          &quot;content&quot;: &quot;$&#123;content&#125;,See the detail in Control Panel:$&#123;params.Jenkins&#125;&quot;,</span><br><span class=\"line\">          &quot;mentioned_list&quot;:[&quot;$&#123;params.Contact&#125;&quot;]</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">         &quot;&quot;&quot;</span><br><span class=\"line\">    echo(command)</span><br><span class=\"line\">    response = httpRequest (consoleLogResponseBody: true,</span><br><span class=\"line\">      contentType: &apos;APPLICATION_JSON&apos;,</span><br><span class=\"line\">      httpMode: &apos;POST&apos;,</span><br><span class=\"line\">      requestBody: command,</span><br><span class=\"line\">      url: &quot;$&#123;params.WeChatWork&#125;&quot;,</span><br><span class=\"line\">      validResponseCodes: &apos;200&apos;)</span><br><span class=\"line\">    return response</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多配置项目\"><a href=\"#多配置项目\" class=\"headerlink\" title=\"多配置项目\"></a>多配置项目</h3><p>如果组件代码需要在不同的配置、不同的环境下重复部署，其基本逻辑类似，只是配置不同，就可以使用多配置项目。</p>\n<p>好吧，我就没有尝试了，因为我已经用了多流水线项目来实现了。在这篇<a href=\"http://dtt4725.github.io/blog/2016/07/25/Jenkins%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Multi-Configuration-Projects/\" target=\"_blank\" rel=\"noopener\">示例</a>中对多配置项目有比较详细的用法，需要可自取。 </p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>将企业级持续集成的环境搭建起来本身并不难，难的是如何将整套体系与公司现有的开发流程相结合，考虑到受康威定律的影响，不同的组织对于新事物的接受程度总是不同的，原有组织或许已经习惯了基于手工拷贝再部署的模式，而目前采用这种持续集成、持续发布的模式，会产出哪些问题，这需要随时做好应对的方案。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-从理论开始\"><a href=\"#1-从理论开始\" class=\"headerlink\" title=\"1 从理论开始\"></a>1 从理论开始</h1><h2 id=\"什么是DevOps\"><a href=\"#什么是DevOps\" class=\"headerlink\" title=\"什么是DevOps?\"></a>什么是DevOps?</h2><p>近年来，随着DevOps理念的逐渐深入人心，企业逐渐意识到从看似重复的手工劳动中实现自动化流程处理，对于提高企业劳动生产力已经非常重要，尤其是面向互联网的开发者，往往每次上线时，最大的挑战并非需求的走查或测试和改bug，而是由于发布的流程不够规范，将成果发布到目标环境后可能造成的配置错误或引发其他已知未知问题所造成的额外工作量，使得生产环境的发布流程总会存在不顺利。</p>\n<p>而DevOps则致力于统一整合软件开发和软件运维，其特点是强烈倡导对构建软件的所有环节（从集成、测试、发布到部署和基础架构管理）进行全面的自动化监控。目标是缩短软件开发周期，提高部署频率和更可靠的发布，与业务目标保持一致。</p>\n<p>在实际操作过程中，对于许多公司而言，开发者和运维者并没有明确的界限，而且即便将运维与开发的岗位职责分开了，也并非意味着双方的职业发展方向将大不相同。实际上在实际操作过程中，开发人员和运维人员依然会使用相同的工具、统一的流程、一致的管理思想，并通过一系列管理手段和工具实现流程的优化。</p>\n<h2 id=\"什么是持续集成和持续交付？\"><a href=\"#什么是持续集成和持续交付？\" class=\"headerlink\" title=\"什么是持续集成和持续交付？\"></a>什么是持续集成和持续交付？</h2><p>持续集成（Continuous Integration）与持续交付(Continuous Delivery)也正是DevOps中最为基础的两种企业级研发和交付活动。</p>\n<p>持续集成来源于敏捷项目管理思想，其核心是团队成员应该经常集成他们的工作，通常每天要求集成一次，当然也可以要求团队成员每天集成多次。每次集成之后，会通过持续集成工具自动运行自动化的构建手段（例如编译、单元测试、集成测试、系统测试），并对集成后的成果进行验证，从而实现了企业管理流程中尽早的发现未知问题的目标。而在传统的软件交付中，可能会将所有问题积压到系统整体测试或甚至UAT（用户验收测试）环节，使得软件的测试时间被拉长，甚至使得软件的问题流入到客户现场，让客户成为小白鼠的情况时有发生。</p>\n<p>实际上而言，看似简单的集成，却并非简单，他应该是企业管理过程中的一项铁律，只有严格执行，才能确保软件时刻处于可用状态；否则就意味着所谓交付过程中完成进度的百分之多少，只不过是一个虚无缥缈的空口白话。</p>\n<p>持续集成往往离不开持续交付，在乔梁老师翻译的《持续交付》一书中，作者Jez Humber说：持续交付是一种能力，也就是说，能够以可持续的方式，安全快速的把代码变更（包括特性、配置、缺陷和试验）部署到生产环境中，让用户使用。这本书的作者也在书的最后一章中指出：它（持续交付）不仅仅是一种新的软件交付方法论，而且对依赖软件的业务来说，也是一种全新的范式。</p>\n<p>持续交付与持续部署看似类似，其实有所区别，前者往往是指将环境推送到用户面前，使用户能够触及和使用它们；而部署则仅仅只是把软件包安装到目标计算机上，用户可能还无法直接使用。</p>\n<p>对于面向互联网的软件企业来说，往往都已经在过去若干年间已经建立了一套完整的持续集成/持续交付流程，但对于某些处于飞速发展期的企业来说，依然相对而言后知后觉，主要是由于企业过去飞速发展的背后所依托的人力物力资源，能够足以保证企业的产出能够适应企业发展的需要，然而随着团队规模的发展赶不上企业业务发展的需要时，重复劳动和看似毫无价值的等待期、后期积压的测试任务、无法有效度量的软件功能实现，实质上也会造成企业的管理成本进一步提高。</p>\n<h2 id=\"从哪里可以获得系统的方法论？\"><a href=\"#从哪里可以获得系统的方法论？\" class=\"headerlink\" title=\"从哪里可以获得系统的方法论？\"></a>从哪里可以获得系统的方法论？</h2><p>对于需要搭建一套完整环境的开发者来说，网上资料很齐全，本文也试图尽可能的对各方面的内容进行综述，努力为开发者提供一个开箱即用的操作流程，但是对于那些想系统的学习持续交付或DevOps领域的知识的开发者来说，你其实不仅仅满足于把环境搭起来，那么你应该看看书。</p>\n<p>在持续集成和持续交付领域有大量优秀的作品，而我觉得来自乔梁老师的作品《持续交付2.0》堪称精品，乔梁老师是一位经验丰富的行业专家，在他的职业生涯中积累了与该领域相关非常丰富的产品研发经验，他也身体力行的参与到许多企业的持续交付流程优化过程中，这些经验都让他能够从更全面的视角来分析持续交付的问题。在这本书中介绍了许多直接拿来就可以使用的管理方法、项目案例、工具，能够让有需求在该领域有所作为的开发者带来不少思考。</p>\n<p>实质上对于一家要实践持续集成/持续交付的企业来说，将工具搭建完成并非核心难点，难点依然在于如何使用敏捷项目管理的思想，实现软件的细粒度任务拆分，并能够对单个任务进行更好的测试，或许TDD是一种不错的模式，但是却可能给开发者的基础技能提出了更高的要求，这将导致TDD无法落地。</p>\n<p>如何快速验证产品需求？在《持续交付2.0》中提出的了一系列的方法，例如装饰窗、最小可行特性法、特区法、定向搜索法、稻草人法、、最小可行产品法等六种方法，通过建立快速验证模型，提高软件从需求到实现的整个流程，能够为企业带来不少便利。</p>\n<p>而在研发阶段，可以采用特性分支和特性开关的手法，利用git源代码管理工具分支的妙处，将需求和代码有机的耦合在一起，同时又依托项目管理工具，实现从需求=》实现=》发布的完整闭环，从而为需求的验证提供了双保险；特性开关我最早在刘华老师的《猎豹行动-敏捷转型》一书中看到，通过使用软开关的形式，避免未开发完成的提前上线造成巨大的风险，而在这边书中也同样提到了这样的方法。在.NET中同样也可以使用特性分支组件，后期我将尝试一下。</p>\n<p>而对于如何减少等待期，作者提到的方法是：</p>\n<p>1、通过“拉动”让价值流动起来，例如，如果是一个生产线的滞留，通过扩大瓶颈的处理能力，让更多的需求能够快速交付，这种手法看似能够临时提高环节处理能力，保障团队的产出，但是显然不是个良好的措施，更合理的措施就是根据下游的生产能力来确定上游的处理能力，由下游来拉动上游的需求。这客观上要求将任务和需求的粒度进一步均匀化，将需求划分成更加易于执行、工作量类似的小需求，使得开发过程更加平滑。</p>\n<p>2、任务自助化：也就是让团队掌握某些通用技能，以便在其他人员阻塞时，能够同步完成相关任务，避免了某些关键任务阻塞造成了整体流程的滞后。 </p>\n<p>在此我就不过多描述书中的精华了，有兴趣的可以入手一本，绝对物超所值。</p>\n<h1 id=\"2、总体流程和环境部署\"><a href=\"#2、总体流程和环境部署\" class=\"headerlink\" title=\"2、总体流程和环境部署\"></a>2、总体流程和环境部署</h1><p>接下来我将进入本文的主题，首先我将构建一个简单的企业级持续集成/持续交付的管理流程，然后再对流程的实现过程进行较为详细的介绍。</p>\n<h2 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图</h2><p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/jenkins-pipeline/1.png\" alt=\"图片\"></p>\n<p>在这个流程中，使用了master/dev的分支模式。</p>\n<p>1、对于dev分支提交的代码，经过代码编辑、静态代码扫描、自动化单元测试的流程，在运行通过后，有测试人员进行代码的测试，并在代码测试通过后，通过pull request提交给master分支的审查人员进行代码检查和合并。</p>\n<p>2、测试人员对dev提交的代码进行确认，并由master分支代码审查人员进行代码审查，通过后对代码进行确认，并生成用于发布的生成包。</p>\n<h2 id=\"涉及的组件和说明\"><a href=\"#涉及的组件和说明\" class=\"headerlink\" title=\"涉及的组件和说明\"></a>涉及的组件和说明</h2><p>在流程中，使用了以下工具，依次安装即可。</p>\n<p>1、安装OpenJDK</p>\n<p>2、安装Jenkins和相关插件</p>\n<p>3、安装PostgresDb</p>\n<p>4、安装SonarQube</p>\n<p>5、安装dotnetsdk3.1</p>\n<p>6、安装git</p>\n<p>7、安装nexus包管理器 for windows版用以实现包管理。</p>\n<p>8、安装Qy Wechat Notification或HTTP Request 用以实现企业微信提醒。</p>\n<p>好吧，环境安装就不介绍了。。</p>\n<h2 id=\"安装补充说明\"><a href=\"#安装补充说明\" class=\"headerlink\" title=\"安装补充说明\"></a>安装补充说明</h2><p>1、其中jenkins安装的版本为2.190.3,OpenJDK安装的版本为openjdk12.0。安装完jenkins和openjdk后，需要进行环境变量的设置。 </p>\n<p>2、SonarQube安装的版本为7.9.1，根据官方网站的说明，推荐使用的数据库包括：sqlserver\\oracle\\postgresdb，在7.9.1和更高版本中，已经不再推荐使用mysql。 </p>\n<p>3、SonarQube默认使用了基于H2内存数据库的嵌入式数据库，可以在测试环境下使用，但是不建议用于生产环境。 </p>\n<p>5、安装完sonarqube、和数据库后，需要修改sonarqube/conf/sonar.properties文件中的数据库配置地址，并将sonarqube的服务重启。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/jenkins-pipeline/2.png\" alt=\"图片\"></p>\n<p>在windows系统中，点击sonarqube-xxx\\bin\\windows-x86-64文件夹中的InstallNTService.bat用以安装SonarQube的服务，而StartNTService.bat则用于启动SonarQube的应用服务。如果数据库配置失败，则SonarQube会启动失败，并提示以下错误：</p>\n<blockquote>\n<p>[sonar-1510653879773] exception caught on transport layer [[id: 0x346b46fb, /127.0.0.1:59330 =&gt; /127.0.0.1:9001]], closing connection<br>java.io.IOException: An existing connection was forcibly closed by the remote host</p>\n</blockquote>\n<p>6、由于使用了自行搭建的Nuget包源管理器，所以在进行构建时，会提示错误，jenkins会使用</p>\n<h2 id=\"Jenkins的项目类型\"><a href=\"#Jenkins的项目类型\" class=\"headerlink\" title=\"Jenkins的项目类型\"></a>Jenkins的项目类型</h2><p>在jenkins中提供了自由风格、单流水线、多分支流水线、多配置项目等不同类型的项目，可以根据实际情况进行取舍，在本人的尝试过程中，分别总结了三种不同类型的项目可适用的场景：</p>\n<h3 id=\"自由风格项目\"><a href=\"#自由风格项目\" class=\"headerlink\" title=\"自由风格项目\"></a>自由风格项目</h3><p>操作流程简单，无需配置groovy脚本，即可简单的完成项目的自动化构建。 </p>\n<p>在自由风格模式的项目中，实现代码编译的过程主要在构建窗口中，主要使用dotnet -相关命令来完成。包括：</p>\n<p>1、dotnet restore 还原依赖包。</p>\n<p>2、dotnet build 编译</p>\n<p>3、dotnet publish -o ./bin/release 发布到指定目录下。</p>\n<p>4、如果需要使用sonarqube来进行静态代码检查，需要在服务器上安装dotnet-sonarscanner组件，这个组件是基于.net core构建的静态代码检查组件，安装的命令为：</p>\n<blockquote>\n<p>dotnet tool install –global dotnet-sonarscanner –version 4.8.0；</p>\n</blockquote>\n<p>5、如果采用.net framework 传统框架，则可以继续使用原来的SonarScanner.MSBuild.exe组件进行代码检查结果的上传。</p>\n<p>6、如果需要在自由风格项目中使用powershell脚本，可以在jenkins=》插件管理=》可用插件中搜索powershell即可。</p>\n<h3 id=\"单流水线项目\"><a href=\"#单流水线项目\" class=\"headerlink\" title=\"单流水线项目\"></a>单流水线项目</h3><p>单流水线项目：可适用于只有一个分支和一套环境需要部署时的项目构建，其发布流程需要使用groovy脚本来实现。点击查看<a href=\"https://jenkins.io/zh/doc/book/pipeline/syntax/\" target=\"_blank\" rel=\"noopener\">pipeline的语法</a></p>\n<p>1、在流水线项目中，都在项目文件的根目录中添加jenkinsfile文件（无扩展名）作为jenkins编译时的脚本文件，而这个文件的脚本语法采用groovy语言，并支持开发者按照脚本语言进行扩展。</p>\n<p>2、在单流水线项目中不支持groovy的分支判断条件，支持逻辑比较简单的脚本。</p>\n<p>3、与编译有关的结构均写在jenkinsfile中，因此jenkins的UI界面可以理解为配置与项目相关的环境变量信息。</p>\n<p>4、可以在jenkinsfile中定义输入的参数，例如：</p>\n<blockquote>\n<p>parameters{<br>       string(name:’ProjectName’, defaultValue: ‘Enter Your ProjectName’, description: ‘Enter your project name here’)<br>       string(name:’Contact’, defaultValue: ‘“@All”,”xxx”‘, description: ‘Enter Your Contract’)<br>       string(name:’RepoUrl’, defaultValue: ‘<a href=\"https://gitee.com/xxx/xxx.git&#39;\" target=\"_blank\" rel=\"noopener\">https://gitee.com/xxx/xxx.git&#39;</a>, description: ‘ gitee代码路径’)<br>}</p>\n</blockquote>\n<p>在jenkins界面中，可以显示成</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/jenkins-pipeline/3.png\" alt=\"图片\"></p>\n<p>在具体场景下就可以通过jenkins界面传入相关参数进行编译的测试了。</p>\n<h3 id=\"多流水线项目\"><a href=\"#多流水线项目\" class=\"headerlink\" title=\"多流水线项目\"></a>多流水线项目</h3><p>多分支流水线项目：使用于一个仓库下各分支不同环境需要部署时的项目构建，其发布流程也需要使用groovy脚本实现。 </p>\n<p>1、多流水线项目支持使用分支判断条件的语法，因此可以使用的场景更多。</p>\n<p>2、其他的总体上和单分支流水线差不多，此处就不在赘述了。</p>\n<p>以下编写了一个简单的示例，仅供参考。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline&#123;</span><br><span class=\"line\">    agent any </span><br><span class=\"line\">    parameters&#123;</span><br><span class=\"line\">        string(name:&apos;Contact&apos;, defaultValue: &apos;&quot;@All&quot;,&quot;&quot;&apos;, description: &apos;Enter Your Contract&apos;) </span><br><span class=\"line\">        string(name:&apos;RepoUrl&apos;, defaultValue: &apos;&apos;, description: &apos; 代码路径&apos;)</span><br><span class=\"line\">        string(name:&apos;SonarUrl&apos;, defaultValue: &apos;http://localhost:9000&apos;, description: &apos; sonar代码路径&apos;)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    stages &#123;</span><br><span class=\"line\">        stage(&apos;When Master&apos;) &#123; </span><br><span class=\"line\">            when &#123;</span><br><span class=\"line\">                expression &#123;BRANCH_NAME==~/(master)/&#125;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">           steps&#123;        </span><br><span class=\"line\">               checkout([$class: &apos;GitSCM&apos;, branches: [[name: &apos;*/master&apos;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: &apos;xxx&apos;, url: params.RepoUrl]]]) </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stage (&quot;When Dev&quot;)&#123;</span><br><span class=\"line\">            when &#123;</span><br><span class=\"line\">                branch &apos;dev&apos;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            steps&#123; rojectName&#125;&quot;) </span><br><span class=\"line\">                checkout([$class: &apos;GitSCM&apos;, branches: [[name: &apos;*/dev&apos;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: &apos;xxx&apos;, url: params.RepoUrl]]])</span><br><span class=\"line\">                bat &quot;dotnet restore $&#123;params.SlnName&#125;&quot;</span><br><span class=\"line\">                bat &quot;dotnet-sonarscanner  begin /k:\\&quot;$&#123;params.SlnName&#125;\\&quot; /d:sonar.host.url=\\&quot;$&#123;params.SonarUrl&#125;\\&quot; /d:sonar.login=\\&quot;$&#123;params.SonarToken&#125;\\&quot;&quot; </span><br><span class=\"line\">                bat &quot;dotnet build $&#123;params.SlnName&#125;&quot;</span><br><span class=\"line\">                bat &apos;&apos;&apos;if not exist bin\\\\release mkdir bin\\\\release&apos;&apos;&apos;</span><br><span class=\"line\">                bat &quot;dotnet sonarscanner end /d:sonar.login=\\&quot;$&#123;params.SonarToken&#125;\\&quot;&quot;</span><br><span class=\"line\">                echo &quot;CodeCheck Success&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        stage(&quot;test&quot;)&#123;</span><br><span class=\"line\">            when&#123;</span><br><span class=\"line\">                expression&#123;return true&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            steps&#123;</span><br><span class=\"line\">                echo &quot;OK&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">        stage(&apos;Web Dev Build&apos;) &#123;</span><br><span class=\"line\">            steps&#123;</span><br><span class=\"line\">                echo env.BRANCH_NAME</span><br><span class=\"line\">                echo params.RepoUrl</span><br><span class=\"line\">                echo params.SonarUrl</span><br><span class=\"line\">                  bat &quot;dotnet build $&#123;params.SlnName&#125;&quot;</span><br><span class=\"line\">                bat &apos;&apos;&apos;if not exist bin\\\\release mkdir bin\\\\release&apos;&apos;&apos;</span><br><span class=\"line\">                bat &apos;&apos;&apos;</span><br><span class=\"line\">                dotnet publish -o ./bin/release </span><br><span class=\"line\">                &apos;&apos;&apos;</span><br><span class=\"line\">                echo &apos;Publish Success&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    post&#123;</span><br><span class=\"line\">      success&#123;</span><br><span class=\"line\">        SendToWeChatWork(&quot;CI Task success,ProjectName is $&#123;params.ProjectName&#125;&quot;) </span><br><span class=\"line\">        echo &apos;Publish Success&apos;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      failure&#123;</span><br><span class=\"line\">        SendToWeChatWork(&quot;CI Task Failure,ProjectName is $&#123;params.ProjectName&#125;&quot;) </span><br><span class=\"line\">        echo &apos;Publish Failure&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">def SendToWeChatWork(content) &#123;   </span><br><span class=\"line\">    def command = &quot;&quot;&quot;&#123;</span><br><span class=\"line\">          &quot;msgtype&quot;: &quot;text&quot;,</span><br><span class=\"line\">          &quot;text&quot;: &#123;</span><br><span class=\"line\">          &quot;content&quot;: &quot;$&#123;content&#125;,See the detail in Control Panel:$&#123;params.Jenkins&#125;&quot;,</span><br><span class=\"line\">          &quot;mentioned_list&quot;:[&quot;$&#123;params.Contact&#125;&quot;]</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">         &quot;&quot;&quot;</span><br><span class=\"line\">    echo(command)</span><br><span class=\"line\">    response = httpRequest (consoleLogResponseBody: true,</span><br><span class=\"line\">      contentType: &apos;APPLICATION_JSON&apos;,</span><br><span class=\"line\">      httpMode: &apos;POST&apos;,</span><br><span class=\"line\">      requestBody: command,</span><br><span class=\"line\">      url: &quot;$&#123;params.WeChatWork&#125;&quot;,</span><br><span class=\"line\">      validResponseCodes: &apos;200&apos;)</span><br><span class=\"line\">    return response</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多配置项目\"><a href=\"#多配置项目\" class=\"headerlink\" title=\"多配置项目\"></a>多配置项目</h3><p>如果组件代码需要在不同的配置、不同的环境下重复部署，其基本逻辑类似，只是配置不同，就可以使用多配置项目。</p>\n<p>好吧，我就没有尝试了，因为我已经用了多流水线项目来实现了。在这篇<a href=\"http://dtt4725.github.io/blog/2016/07/25/Jenkins%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Multi-Configuration-Projects/\" target=\"_blank\" rel=\"noopener\">示例</a>中对多配置项目有比较详细的用法，需要可自取。 </p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>将企业级持续集成的环境搭建起来本身并不难，难的是如何将整套体系与公司现有的开发流程相结合，考虑到受康威定律的影响，不同的组织对于新事物的接受程度总是不同的，原有组织或许已经习惯了基于手工拷贝再部署的模式，而目前采用这种持续集成、持续发布的模式，会产出哪些问题，这需要随时做好应对的方案。</p>\n"},{"title":"提升WebAPI性能的几个小建议","date":"2020-05-03T11:07:00.000Z","author":"邹溪源","_content":"---\ntypora-root-url: ..\\..\\..\\..\\image.techq.xyz\\images\\improve-webapi\n---\n\n# 提升WebAPI性能的几个小建议\n\n本文作者：德本德拉·达什（Debendra Dash）\n\n原文来自： https://www.c-sharpcorner.com/article/Tips-And-Tricks-To-Improve-WEB-API-Performance/ \n\n\n\nWeb API是Microsoft作为.NET框架的一部分而开发的一项技术，它使用户能够与异构平台进行通信，包括网站，移动设备和桌面应用程序等。在编写Web API时，我们应该关注其性能和响应时间。在这里，我列出了在提高Web API性能时需要考虑的几点。\n\n ![1](/1.png)\n\n \n\n## 在Web API中使用并行编程 \n\n \n\nWeb API逻辑主要处理2个重要功能-将数据发布到服务器以进行插入或更新，以及从服务器获取数据。当我们有成千上万的记录要从服务器获取时，响应时间非常高。这是因为有时我们将不得不遍历数据源，进行几次更改，然后将数据发送到客户端。而且，一个简单的foreach循环是一个单线程循环，该循环逐个顺序处理数据以给出结果集。\n\n 因此，在这种情况下，建议在从服务器获取数据时使用并行foreach循环。由于并行的foreach循环在多线程环境中工作，因此执行速度将比foreach循环更快。 \n\n### 并行Foreach循环的执行过程\n\n~~~c#\n\n\n```c#\nList<Employee> li = new List<Employee>();  \nli.Add(new Employee { Id = 1001, Name = \"Sambid\", Company = \"DELL\", Location = \"Bangalore\" });  \nli.Add(new Employee { Id = 1002, Name = \"Sumit\", Company = \"DELL\", Location = \"Bangalore\" });  \nli.Add(new Employee { Id = 1003, Name = \"Koushal\", Company = \"Infosys\", Location = \"New Delhi\" });  \nli.Add(new Employee { Id = 1004, Name = \"Kumar\", Company = \"TCS\", Location = \"Bangalore\" });  \nli.Add(new Employee { Id = 1005, Name = \"Mohan\", Company = \"Microsoft\", Location = \"Hyderabad\" });  \nli.Add(new Employee { Id = 1006, Name = \"Tushar\", Company = \"Samsung\", Location = \"Hyderabad\" });  \nli.Add(new Employee { Id = 1007, Name = \"Jia\", Company = \"TCS\", Location = \"Pune\" });  \nli.Add(new Employee { Id = 1008, Name = \"KIRAN\", Company = \"CTS\", Location = \"Bangalore\" });  \nli.Add(new Employee { Id = 1009, Name = \"Rinku\", Company = \"CGI\", Location = \"Bangalore\" });  \n```\n~~~\n\n 这是Employee类:\n\n```c#\npublic class Employee  \n{  \n    public int Id { get; set; }  \n    public string Name { get; set; }  \n    public string Company { get; set; }  \n    public string Designation { get; set; }  \n    public string Location { get; set; }  \n       \n}  \n```\n\n 这就是我们可以使用Parallel Foreach循环的方式。 \n\n![](/parallel.png)\n\n该循环将立即执行并给出结果。在Foreach循环的情况下，它一一给出结果。假设结果集中有1000条记录，则循环将执行一次1000次以得到结果。\n\n \n\n**注意：** 当您要获取的记录数量很少时，请不要使用Parallel foreach循环。\n\n## 使用异步编程来处理并发的HTTP请求\n\n \n\n同步编程中发生的事情是，每当有请求执行Web API时，就会将线程池中的线程分配给要执行的请求。该线程被阻塞，直到执行该过程并返回结果为止。\n\n![](/as1.png)\n\n在这里，T2 线程一直处于阻塞状态，直到它处理请求并返回结果为止；如果遇到长的执行循环，则它将花费大量时间并一直等待到结束。\n\n \n\n假设我们只有3个线程，并且所有线程都已分配给队列中正在等待的三个请求。在这种情况下，如果第四个请求在我们同步实现时出现，它将发出错误，因为现在它没有任何线程可以处理该请求。\n\n \n\n因此，要处理更多数量的并发HTTP请求，我们必须使用异步编程。\n\n \n\n异步请求处理程序的操作有所不同。当请求到达Web API控制器时，它将获取其线程池线程之一，并将其分配给该请求。\n\n \n\n在进程开始执行的同时，线程将返回到线程池。执行完成后，为该请求分配了另一个线程来带来该请求，因此，该线程将不会等到进程执行完成后才返回到线程池以处理另一个请求。\n\n![](/final.png)\n\n 因此，在这里我给出了一个小的注册示例，以及如何在Web API中使用异步编程。 \n\n```c#\n[AllowAnonymous]  \n[Route(\"Register\")]  \npublic async Task<IHttpActionResult> Register(RegisterBindingModel model)  \n{  \n    Dictionary<object, object> dict = new Dictionary<object, object>();  \n    if (!ModelState.IsValid)  \n    {  \n        return BadRequest(ModelState);  \n    }  \n    var user = new ApplicationUser() { UserName = model.Email, Email = model.Email };  \n    IdentityResult result = await UserManager.CreateAsync(user, model.Password);  \n    if (result.Succeeded)  \n    {  \n        tbl_Users obj = new tbl_Users();  \n        obj.Active = false;  \n        obj.FirstName = model.FirstName;  \n        obj.LastName = model.LastName;  \n        obj.Email = model.Email;  \n        obj.UserId = user.Id;  \n        DefEntity.tbl_Users.Add(obj);  \n        if (DefEntity.SaveChanges() == 1)  \n        {  \n            dict.Add(\"Success\", \"Data Saved Successfully.\");  \n            return Ok(dict);  \n        }  \n        else  \n        {  \n            return Content(HttpStatusCode.BadRequest, \"User Details not Saved.\");  \n        }  \n    }  \n    else  \n    {  \n        return GetErrorResult(result);  \n    }  \n}\n```\n\n## 压缩Web API的结果\n\nWeb API压缩对于提高ASP.NET Web API性能非常重要。在Web中，数据以包（数据包）的形式通过网络传输，从而增加了数据包的大小，这将增加大小并增加Web API的响应时间。因此，减小数据包大小可提高Web API的加载性能。\n\n \n\n通过压缩API响应，我们具有以下两个优点。\n\n- 数据大小将减小\n\n- 响应时间将增加（增加客户端和服务器之间的通信速度。）\n\n  我们可以通过编码和IIS中的某些设置来压缩Web API。我已经在以下链接中介绍了使用编码对Web API进行压缩的方法。\n\n\n\n1. - [使用DotNetZip压缩Web API响应](http://www.c-sharpcorner.com/article/compressing-web-api-response-to-using-dotnetzip/)\n   - [压缩Web API响应](http://www.c-sharpcorner.com/article/compressing-web-api-response-part-two/)\n\n- 同样，我们可以通过检查动态内容压缩模块来启用IIS压缩 。\n\n  ![](/iis1.png)\n\n- 因此，通过这种方式，我们可以压缩Web API响应以实现性能。\n\n## 使用缓存提高性能\n\n \n\n缓存是一种在一定时间段内将常用数据或信息存储在本地存储器中的技术。因此，下一次，当客户端请求相同的信息时，它将从本地内存中提供信息，而不是从数据库中检索信息。缓存的主要优点是它通过减少处理负担来提高性能。我们有几种方法可以在Web api中实现缓存。在下面的链接中，我描述了一种实现缓存的方法。\n\n- [在Web API中实现缓存](http://www.c-sharpcorner.com/article/implementing-caching-in-web-api/)\n\n  因此，在这里您将找到我们如何在Web API中实现缓存以及它将如何帮助提高性能。\n\n## 使用高速JSON序列化器\n\n \n\n我们经常使用JSON而不是XML来在服务提供者和服务客户端之间交换数据。首先，我们使用它是因为JSON是轻量级的。\n\n \n\n在.NET中，有很多序列化器。最受欢迎的是Json.NET，Microsoft选择它作为Web API的默认JSON序列化器。Json.NET之所以出色，是因为它快速，健壮且可配置。\n\n \n\n有几种序列化器比Json.Net更快。下面提到其中一些。\n\n![](/ser.png)\n\n我们可以看到Protobuf-Net和JIL是非常快速的序列化程序，因此，如果可以代替Json.net来实现它们，则显然可以提高性能。协议缓冲区或Protobuf是Google的官方序列化程序。要在.Net中使用JIL序列化程序，我已经写了一篇文章，您可以在下面的链接中进行检查。\n\n- [在C＃中使用Jil序列化器和反序列化器库](http://www.c-sharpcorner.com/article/working-with-jil-serializer-and-deserializer-library-in-c-sharp/)\n\n\n\n## 创建适当的数据库结构\n\n \n\n为了提高任何应用程序的性能，我们应该将重点放在数据库结构上。我可以说数据库结构在提高性能方面起着重要作用。这些是我们在处理数据库时应检查的一些注意事项。\n\n- 尝试使规范化表结构。\n\n- 为所有表提供适当的索引，以便从表中轻松搜索结果。\n\n- 将所有相互关联的表与外键和主键相关联。\n\n  我认为在创建数据库结构以提高性能时，我们必须至少遵循这三个规则。\n\n**尝试从客户端验证某些属性**\n\n \n\n从客户端而不是服务器端验证某些模型属性非常好。一旦我们在未经客户端验证的情况下放置了无效数据，则它将进入服务器并检查其是否为有效数据。如果它是无效的数据，它将从服务器给出错误。因此，在这里我们可以使用客户端验证检查往返行程。因此，如果我们可以通过客户端（移动设备，网站等）进行任何可能的验证，那将是很好的。\n\n![](/valida.jpg)\n\n 因此，我认为，如果我们专注于以上讨论的要点，则可以以某种方式提高Web API的性能。 ","source":"_posts/技术/提升WebAPI性能的几个小建议.md","raw":"---\ntitle: 提升WebAPI性能的几个小建议\ndate: 2020-5-3 19:07\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n---\ntypora-root-url: ..\\..\\..\\..\\image.techq.xyz\\images\\improve-webapi\n---\n\n# 提升WebAPI性能的几个小建议\n\n本文作者：德本德拉·达什（Debendra Dash）\n\n原文来自： https://www.c-sharpcorner.com/article/Tips-And-Tricks-To-Improve-WEB-API-Performance/ \n\n\n\nWeb API是Microsoft作为.NET框架的一部分而开发的一项技术，它使用户能够与异构平台进行通信，包括网站，移动设备和桌面应用程序等。在编写Web API时，我们应该关注其性能和响应时间。在这里，我列出了在提高Web API性能时需要考虑的几点。\n\n ![1](/1.png)\n\n \n\n## 在Web API中使用并行编程 \n\n \n\nWeb API逻辑主要处理2个重要功能-将数据发布到服务器以进行插入或更新，以及从服务器获取数据。当我们有成千上万的记录要从服务器获取时，响应时间非常高。这是因为有时我们将不得不遍历数据源，进行几次更改，然后将数据发送到客户端。而且，一个简单的foreach循环是一个单线程循环，该循环逐个顺序处理数据以给出结果集。\n\n 因此，在这种情况下，建议在从服务器获取数据时使用并行foreach循环。由于并行的foreach循环在多线程环境中工作，因此执行速度将比foreach循环更快。 \n\n### 并行Foreach循环的执行过程\n\n~~~c#\n\n\n```c#\nList<Employee> li = new List<Employee>();  \nli.Add(new Employee { Id = 1001, Name = \"Sambid\", Company = \"DELL\", Location = \"Bangalore\" });  \nli.Add(new Employee { Id = 1002, Name = \"Sumit\", Company = \"DELL\", Location = \"Bangalore\" });  \nli.Add(new Employee { Id = 1003, Name = \"Koushal\", Company = \"Infosys\", Location = \"New Delhi\" });  \nli.Add(new Employee { Id = 1004, Name = \"Kumar\", Company = \"TCS\", Location = \"Bangalore\" });  \nli.Add(new Employee { Id = 1005, Name = \"Mohan\", Company = \"Microsoft\", Location = \"Hyderabad\" });  \nli.Add(new Employee { Id = 1006, Name = \"Tushar\", Company = \"Samsung\", Location = \"Hyderabad\" });  \nli.Add(new Employee { Id = 1007, Name = \"Jia\", Company = \"TCS\", Location = \"Pune\" });  \nli.Add(new Employee { Id = 1008, Name = \"KIRAN\", Company = \"CTS\", Location = \"Bangalore\" });  \nli.Add(new Employee { Id = 1009, Name = \"Rinku\", Company = \"CGI\", Location = \"Bangalore\" });  \n```\n~~~\n\n 这是Employee类:\n\n```c#\npublic class Employee  \n{  \n    public int Id { get; set; }  \n    public string Name { get; set; }  \n    public string Company { get; set; }  \n    public string Designation { get; set; }  \n    public string Location { get; set; }  \n       \n}  \n```\n\n 这就是我们可以使用Parallel Foreach循环的方式。 \n\n![](/parallel.png)\n\n该循环将立即执行并给出结果。在Foreach循环的情况下，它一一给出结果。假设结果集中有1000条记录，则循环将执行一次1000次以得到结果。\n\n \n\n**注意：** 当您要获取的记录数量很少时，请不要使用Parallel foreach循环。\n\n## 使用异步编程来处理并发的HTTP请求\n\n \n\n同步编程中发生的事情是，每当有请求执行Web API时，就会将线程池中的线程分配给要执行的请求。该线程被阻塞，直到执行该过程并返回结果为止。\n\n![](/as1.png)\n\n在这里，T2 线程一直处于阻塞状态，直到它处理请求并返回结果为止；如果遇到长的执行循环，则它将花费大量时间并一直等待到结束。\n\n \n\n假设我们只有3个线程，并且所有线程都已分配给队列中正在等待的三个请求。在这种情况下，如果第四个请求在我们同步实现时出现，它将发出错误，因为现在它没有任何线程可以处理该请求。\n\n \n\n因此，要处理更多数量的并发HTTP请求，我们必须使用异步编程。\n\n \n\n异步请求处理程序的操作有所不同。当请求到达Web API控制器时，它将获取其线程池线程之一，并将其分配给该请求。\n\n \n\n在进程开始执行的同时，线程将返回到线程池。执行完成后，为该请求分配了另一个线程来带来该请求，因此，该线程将不会等到进程执行完成后才返回到线程池以处理另一个请求。\n\n![](/final.png)\n\n 因此，在这里我给出了一个小的注册示例，以及如何在Web API中使用异步编程。 \n\n```c#\n[AllowAnonymous]  \n[Route(\"Register\")]  \npublic async Task<IHttpActionResult> Register(RegisterBindingModel model)  \n{  \n    Dictionary<object, object> dict = new Dictionary<object, object>();  \n    if (!ModelState.IsValid)  \n    {  \n        return BadRequest(ModelState);  \n    }  \n    var user = new ApplicationUser() { UserName = model.Email, Email = model.Email };  \n    IdentityResult result = await UserManager.CreateAsync(user, model.Password);  \n    if (result.Succeeded)  \n    {  \n        tbl_Users obj = new tbl_Users();  \n        obj.Active = false;  \n        obj.FirstName = model.FirstName;  \n        obj.LastName = model.LastName;  \n        obj.Email = model.Email;  \n        obj.UserId = user.Id;  \n        DefEntity.tbl_Users.Add(obj);  \n        if (DefEntity.SaveChanges() == 1)  \n        {  \n            dict.Add(\"Success\", \"Data Saved Successfully.\");  \n            return Ok(dict);  \n        }  \n        else  \n        {  \n            return Content(HttpStatusCode.BadRequest, \"User Details not Saved.\");  \n        }  \n    }  \n    else  \n    {  \n        return GetErrorResult(result);  \n    }  \n}\n```\n\n## 压缩Web API的结果\n\nWeb API压缩对于提高ASP.NET Web API性能非常重要。在Web中，数据以包（数据包）的形式通过网络传输，从而增加了数据包的大小，这将增加大小并增加Web API的响应时间。因此，减小数据包大小可提高Web API的加载性能。\n\n \n\n通过压缩API响应，我们具有以下两个优点。\n\n- 数据大小将减小\n\n- 响应时间将增加（增加客户端和服务器之间的通信速度。）\n\n  我们可以通过编码和IIS中的某些设置来压缩Web API。我已经在以下链接中介绍了使用编码对Web API进行压缩的方法。\n\n\n\n1. - [使用DotNetZip压缩Web API响应](http://www.c-sharpcorner.com/article/compressing-web-api-response-to-using-dotnetzip/)\n   - [压缩Web API响应](http://www.c-sharpcorner.com/article/compressing-web-api-response-part-two/)\n\n- 同样，我们可以通过检查动态内容压缩模块来启用IIS压缩 。\n\n  ![](/iis1.png)\n\n- 因此，通过这种方式，我们可以压缩Web API响应以实现性能。\n\n## 使用缓存提高性能\n\n \n\n缓存是一种在一定时间段内将常用数据或信息存储在本地存储器中的技术。因此，下一次，当客户端请求相同的信息时，它将从本地内存中提供信息，而不是从数据库中检索信息。缓存的主要优点是它通过减少处理负担来提高性能。我们有几种方法可以在Web api中实现缓存。在下面的链接中，我描述了一种实现缓存的方法。\n\n- [在Web API中实现缓存](http://www.c-sharpcorner.com/article/implementing-caching-in-web-api/)\n\n  因此，在这里您将找到我们如何在Web API中实现缓存以及它将如何帮助提高性能。\n\n## 使用高速JSON序列化器\n\n \n\n我们经常使用JSON而不是XML来在服务提供者和服务客户端之间交换数据。首先，我们使用它是因为JSON是轻量级的。\n\n \n\n在.NET中，有很多序列化器。最受欢迎的是Json.NET，Microsoft选择它作为Web API的默认JSON序列化器。Json.NET之所以出色，是因为它快速，健壮且可配置。\n\n \n\n有几种序列化器比Json.Net更快。下面提到其中一些。\n\n![](/ser.png)\n\n我们可以看到Protobuf-Net和JIL是非常快速的序列化程序，因此，如果可以代替Json.net来实现它们，则显然可以提高性能。协议缓冲区或Protobuf是Google的官方序列化程序。要在.Net中使用JIL序列化程序，我已经写了一篇文章，您可以在下面的链接中进行检查。\n\n- [在C＃中使用Jil序列化器和反序列化器库](http://www.c-sharpcorner.com/article/working-with-jil-serializer-and-deserializer-library-in-c-sharp/)\n\n\n\n## 创建适当的数据库结构\n\n \n\n为了提高任何应用程序的性能，我们应该将重点放在数据库结构上。我可以说数据库结构在提高性能方面起着重要作用。这些是我们在处理数据库时应检查的一些注意事项。\n\n- 尝试使规范化表结构。\n\n- 为所有表提供适当的索引，以便从表中轻松搜索结果。\n\n- 将所有相互关联的表与外键和主键相关联。\n\n  我认为在创建数据库结构以提高性能时，我们必须至少遵循这三个规则。\n\n**尝试从客户端验证某些属性**\n\n \n\n从客户端而不是服务器端验证某些模型属性非常好。一旦我们在未经客户端验证的情况下放置了无效数据，则它将进入服务器并检查其是否为有效数据。如果它是无效的数据，它将从服务器给出错误。因此，在这里我们可以使用客户端验证检查往返行程。因此，如果我们可以通过客户端（移动设备，网站等）进行任何可能的验证，那将是很好的。\n\n![](/valida.jpg)\n\n 因此，我认为，如果我们专注于以上讨论的要点，则可以以某种方式提高Web API的性能。 ","slug":"技术/提升WebAPI性能的几个小建议","published":1,"updated":"2020-06-25T14:03:27.923Z","_id":"ckbuujt7v001mn4vi80hy9elj","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<h2 id=\"typora-root-url-image-techq-xyz-images-improve-webapi\"><a href=\"#typora-root-url-image-techq-xyz-images-improve-webapi\" class=\"headerlink\" title=\"typora-root-url: ........\\image.techq.xyz\\images\\improve-webapi\"></a>typora-root-url: ........\\image.techq.xyz\\images\\improve-webapi</h2><h1 id=\"提升WebAPI性能的几个小建议\"><a href=\"#提升WebAPI性能的几个小建议\" class=\"headerlink\" title=\"提升WebAPI性能的几个小建议\"></a>提升WebAPI性能的几个小建议</h1><p>本文作者：德本德拉·达什（Debendra Dash）</p>\n<p>原文来自： <a href=\"https://www.c-sharpcorner.com/article/Tips-And-Tricks-To-Improve-WEB-API-Performance/\" target=\"_blank\" rel=\"noopener\">https://www.c-sharpcorner.com/article/Tips-And-Tricks-To-Improve-WEB-API-Performance/</a> </p>\n<p>Web API是Microsoft作为.NET框架的一部分而开发的一项技术，它使用户能够与异构平台进行通信，包括网站，移动设备和桌面应用程序等。在编写Web API时，我们应该关注其性能和响应时间。在这里，我列出了在提高Web API性能时需要考虑的几点。</p>\n<p> <img src=\"/1.png\" alt=\"1\"></p>\n<h2 id=\"在Web-API中使用并行编程\"><a href=\"#在Web-API中使用并行编程\" class=\"headerlink\" title=\"在Web API中使用并行编程\"></a>在Web API中使用并行编程</h2><p>Web API逻辑主要处理2个重要功能-将数据发布到服务器以进行插入或更新，以及从服务器获取数据。当我们有成千上万的记录要从服务器获取时，响应时间非常高。这是因为有时我们将不得不遍历数据源，进行几次更改，然后将数据发送到客户端。而且，一个简单的foreach循环是一个单线程循环，该循环逐个顺序处理数据以给出结果集。</p>\n<p> 因此，在这种情况下，建议在从服务器获取数据时使用并行foreach循环。由于并行的foreach循环在多线程环境中工作，因此执行速度将比foreach循环更快。 </p>\n<h3 id=\"并行Foreach循环的执行过程\"><a href=\"#并行Foreach循环的执行过程\" class=\"headerlink\" title=\"并行Foreach循环的执行过程\"></a>并行Foreach循环的执行过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">```c#</span><br><span class=\"line\">List&lt;Employee&gt; li = new List&lt;Employee&gt;();  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1001, Name = &quot;Sambid&quot;, Company = &quot;DELL&quot;, Location = &quot;Bangalore&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1002, Name = &quot;Sumit&quot;, Company = &quot;DELL&quot;, Location = &quot;Bangalore&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1003, Name = &quot;Koushal&quot;, Company = &quot;Infosys&quot;, Location = &quot;New Delhi&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1004, Name = &quot;Kumar&quot;, Company = &quot;TCS&quot;, Location = &quot;Bangalore&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1005, Name = &quot;Mohan&quot;, Company = &quot;Microsoft&quot;, Location = &quot;Hyderabad&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1006, Name = &quot;Tushar&quot;, Company = &quot;Samsung&quot;, Location = &quot;Hyderabad&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1007, Name = &quot;Jia&quot;, Company = &quot;TCS&quot;, Location = &quot;Pune&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1008, Name = &quot;KIRAN&quot;, Company = &quot;CTS&quot;, Location = &quot;Bangalore&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1009, Name = &quot;Rinku&quot;, Company = &quot;CGI&quot;, Location = &quot;Bangalore&quot; &#125;);  </span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure>\n\n<p> 这是Employee类:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Employee  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    public int Id &#123; get; set; &#125;  </span><br><span class=\"line\">    public string Name &#123; get; set; &#125;  </span><br><span class=\"line\">    public string Company &#123; get; set; &#125;  </span><br><span class=\"line\">    public string Designation &#123; get; set; &#125;  </span><br><span class=\"line\">    public string Location &#123; get; set; &#125;  </span><br><span class=\"line\">       </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 这就是我们可以使用Parallel Foreach循环的方式。 </p>\n<p><img src=\"/parallel.png\" alt></p>\n<p>该循环将立即执行并给出结果。在Foreach循环的情况下，它一一给出结果。假设结果集中有1000条记录，则循环将执行一次1000次以得到结果。</p>\n<p><strong>注意：</strong> 当您要获取的记录数量很少时，请不要使用Parallel foreach循环。</p>\n<h2 id=\"使用异步编程来处理并发的HTTP请求\"><a href=\"#使用异步编程来处理并发的HTTP请求\" class=\"headerlink\" title=\"使用异步编程来处理并发的HTTP请求\"></a>使用异步编程来处理并发的HTTP请求</h2><p>同步编程中发生的事情是，每当有请求执行Web API时，就会将线程池中的线程分配给要执行的请求。该线程被阻塞，直到执行该过程并返回结果为止。</p>\n<p><img src=\"/as1.png\" alt></p>\n<p>在这里，T2 线程一直处于阻塞状态，直到它处理请求并返回结果为止；如果遇到长的执行循环，则它将花费大量时间并一直等待到结束。</p>\n<p>假设我们只有3个线程，并且所有线程都已分配给队列中正在等待的三个请求。在这种情况下，如果第四个请求在我们同步实现时出现，它将发出错误，因为现在它没有任何线程可以处理该请求。</p>\n<p>因此，要处理更多数量的并发HTTP请求，我们必须使用异步编程。</p>\n<p>异步请求处理程序的操作有所不同。当请求到达Web API控制器时，它将获取其线程池线程之一，并将其分配给该请求。</p>\n<p>在进程开始执行的同时，线程将返回到线程池。执行完成后，为该请求分配了另一个线程来带来该请求，因此，该线程将不会等到进程执行完成后才返回到线程池以处理另一个请求。</p>\n<p><img src=\"/final.png\" alt></p>\n<p> 因此，在这里我给出了一个小的注册示例，以及如何在Web API中使用异步编程。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[AllowAnonymous]  </span><br><span class=\"line\">[Route(&quot;Register&quot;)]  </span><br><span class=\"line\">public async Task&lt;IHttpActionResult&gt; Register(RegisterBindingModel model)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    Dictionary&lt;object, object&gt; dict = new Dictionary&lt;object, object&gt;();  </span><br><span class=\"line\">    if (!ModelState.IsValid)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        return BadRequest(ModelState);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    var user = new ApplicationUser() &#123; UserName = model.Email, Email = model.Email &#125;;  </span><br><span class=\"line\">    IdentityResult result = await UserManager.CreateAsync(user, model.Password);  </span><br><span class=\"line\">    if (result.Succeeded)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        tbl_Users obj = new tbl_Users();  </span><br><span class=\"line\">        obj.Active = false;  </span><br><span class=\"line\">        obj.FirstName = model.FirstName;  </span><br><span class=\"line\">        obj.LastName = model.LastName;  </span><br><span class=\"line\">        obj.Email = model.Email;  </span><br><span class=\"line\">        obj.UserId = user.Id;  </span><br><span class=\"line\">        DefEntity.tbl_Users.Add(obj);  </span><br><span class=\"line\">        if (DefEntity.SaveChanges() == 1)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            dict.Add(&quot;Success&quot;, &quot;Data Saved Successfully.&quot;);  </span><br><span class=\"line\">            return Ok(dict);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        else  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            return Content(HttpStatusCode.BadRequest, &quot;User Details not Saved.&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    else  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        return GetErrorResult(result);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"压缩Web-API的结果\"><a href=\"#压缩Web-API的结果\" class=\"headerlink\" title=\"压缩Web API的结果\"></a>压缩Web API的结果</h2><p>Web API压缩对于提高ASP.NET Web API性能非常重要。在Web中，数据以包（数据包）的形式通过网络传输，从而增加了数据包的大小，这将增加大小并增加Web API的响应时间。因此，减小数据包大小可提高Web API的加载性能。</p>\n<p>通过压缩API响应，我们具有以下两个优点。</p>\n<ul>\n<li><p>数据大小将减小</p>\n</li>\n<li><p>响应时间将增加（增加客户端和服务器之间的通信速度。）</p>\n<p>我们可以通过编码和IIS中的某些设置来压缩Web API。我已经在以下链接中介绍了使用编码对Web API进行压缩的方法。</p>\n</li>\n</ul>\n<ol>\n<li><ul>\n<li><a href=\"http://www.c-sharpcorner.com/article/compressing-web-api-response-to-using-dotnetzip/\" target=\"_blank\" rel=\"noopener\">使用DotNetZip压缩Web API响应</a></li>\n<li><a href=\"http://www.c-sharpcorner.com/article/compressing-web-api-response-part-two/\" target=\"_blank\" rel=\"noopener\">压缩Web API响应</a></li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>同样，我们可以通过检查动态内容压缩模块来启用IIS压缩 。</p>\n<p><img src=\"/iis1.png\" alt></p>\n</li>\n<li><p>因此，通过这种方式，我们可以压缩Web API响应以实现性能。</p>\n</li>\n</ul>\n<h2 id=\"使用缓存提高性能\"><a href=\"#使用缓存提高性能\" class=\"headerlink\" title=\"使用缓存提高性能\"></a>使用缓存提高性能</h2><p>缓存是一种在一定时间段内将常用数据或信息存储在本地存储器中的技术。因此，下一次，当客户端请求相同的信息时，它将从本地内存中提供信息，而不是从数据库中检索信息。缓存的主要优点是它通过减少处理负担来提高性能。我们有几种方法可以在Web api中实现缓存。在下面的链接中，我描述了一种实现缓存的方法。</p>\n<ul>\n<li><p><a href=\"http://www.c-sharpcorner.com/article/implementing-caching-in-web-api/\" target=\"_blank\" rel=\"noopener\">在Web API中实现缓存</a></p>\n<p>因此，在这里您将找到我们如何在Web API中实现缓存以及它将如何帮助提高性能。</p>\n</li>\n</ul>\n<h2 id=\"使用高速JSON序列化器\"><a href=\"#使用高速JSON序列化器\" class=\"headerlink\" title=\"使用高速JSON序列化器\"></a>使用高速JSON序列化器</h2><p>我们经常使用JSON而不是XML来在服务提供者和服务客户端之间交换数据。首先，我们使用它是因为JSON是轻量级的。</p>\n<p>在.NET中，有很多序列化器。最受欢迎的是Json.NET，Microsoft选择它作为Web API的默认JSON序列化器。Json.NET之所以出色，是因为它快速，健壮且可配置。</p>\n<p>有几种序列化器比Json.Net更快。下面提到其中一些。</p>\n<p><img src=\"/ser.png\" alt></p>\n<p>我们可以看到Protobuf-Net和JIL是非常快速的序列化程序，因此，如果可以代替Json.net来实现它们，则显然可以提高性能。协议缓冲区或Protobuf是Google的官方序列化程序。要在.Net中使用JIL序列化程序，我已经写了一篇文章，您可以在下面的链接中进行检查。</p>\n<ul>\n<li><a href=\"http://www.c-sharpcorner.com/article/working-with-jil-serializer-and-deserializer-library-in-c-sharp/\" target=\"_blank\" rel=\"noopener\">在C＃中使用Jil序列化器和反序列化器库</a></li>\n</ul>\n<h2 id=\"创建适当的数据库结构\"><a href=\"#创建适当的数据库结构\" class=\"headerlink\" title=\"创建适当的数据库结构\"></a>创建适当的数据库结构</h2><p>为了提高任何应用程序的性能，我们应该将重点放在数据库结构上。我可以说数据库结构在提高性能方面起着重要作用。这些是我们在处理数据库时应检查的一些注意事项。</p>\n<ul>\n<li><p>尝试使规范化表结构。</p>\n</li>\n<li><p>为所有表提供适当的索引，以便从表中轻松搜索结果。</p>\n</li>\n<li><p>将所有相互关联的表与外键和主键相关联。</p>\n<p>我认为在创建数据库结构以提高性能时，我们必须至少遵循这三个规则。</p>\n</li>\n</ul>\n<p><strong>尝试从客户端验证某些属性</strong></p>\n<p>从客户端而不是服务器端验证某些模型属性非常好。一旦我们在未经客户端验证的情况下放置了无效数据，则它将进入服务器并检查其是否为有效数据。如果它是无效的数据，它将从服务器给出错误。因此，在这里我们可以使用客户端验证检查往返行程。因此，如果我们可以通过客户端（移动设备，网站等）进行任何可能的验证，那将是很好的。</p>\n<p><img src=\"/valida.jpg\" alt></p>\n<p> 因此，我认为，如果我们专注于以上讨论的要点，则可以以某种方式提高Web API的性能。 </p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h2 id=\"typora-root-url-image-techq-xyz-images-improve-webapi\"><a href=\"#typora-root-url-image-techq-xyz-images-improve-webapi\" class=\"headerlink\" title=\"typora-root-url: ........\\image.techq.xyz\\images\\improve-webapi\"></a>typora-root-url: ........\\image.techq.xyz\\images\\improve-webapi</h2><h1 id=\"提升WebAPI性能的几个小建议\"><a href=\"#提升WebAPI性能的几个小建议\" class=\"headerlink\" title=\"提升WebAPI性能的几个小建议\"></a>提升WebAPI性能的几个小建议</h1><p>本文作者：德本德拉·达什（Debendra Dash）</p>\n<p>原文来自： <a href=\"https://www.c-sharpcorner.com/article/Tips-And-Tricks-To-Improve-WEB-API-Performance/\" target=\"_blank\" rel=\"noopener\">https://www.c-sharpcorner.com/article/Tips-And-Tricks-To-Improve-WEB-API-Performance/</a> </p>\n<p>Web API是Microsoft作为.NET框架的一部分而开发的一项技术，它使用户能够与异构平台进行通信，包括网站，移动设备和桌面应用程序等。在编写Web API时，我们应该关注其性能和响应时间。在这里，我列出了在提高Web API性能时需要考虑的几点。</p>\n<p> <img src=\"/1.png\" alt=\"1\"></p>\n<h2 id=\"在Web-API中使用并行编程\"><a href=\"#在Web-API中使用并行编程\" class=\"headerlink\" title=\"在Web API中使用并行编程\"></a>在Web API中使用并行编程</h2><p>Web API逻辑主要处理2个重要功能-将数据发布到服务器以进行插入或更新，以及从服务器获取数据。当我们有成千上万的记录要从服务器获取时，响应时间非常高。这是因为有时我们将不得不遍历数据源，进行几次更改，然后将数据发送到客户端。而且，一个简单的foreach循环是一个单线程循环，该循环逐个顺序处理数据以给出结果集。</p>\n<p> 因此，在这种情况下，建议在从服务器获取数据时使用并行foreach循环。由于并行的foreach循环在多线程环境中工作，因此执行速度将比foreach循环更快。 </p>\n<h3 id=\"并行Foreach循环的执行过程\"><a href=\"#并行Foreach循环的执行过程\" class=\"headerlink\" title=\"并行Foreach循环的执行过程\"></a>并行Foreach循环的执行过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">```c#</span><br><span class=\"line\">List&lt;Employee&gt; li = new List&lt;Employee&gt;();  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1001, Name = &quot;Sambid&quot;, Company = &quot;DELL&quot;, Location = &quot;Bangalore&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1002, Name = &quot;Sumit&quot;, Company = &quot;DELL&quot;, Location = &quot;Bangalore&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1003, Name = &quot;Koushal&quot;, Company = &quot;Infosys&quot;, Location = &quot;New Delhi&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1004, Name = &quot;Kumar&quot;, Company = &quot;TCS&quot;, Location = &quot;Bangalore&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1005, Name = &quot;Mohan&quot;, Company = &quot;Microsoft&quot;, Location = &quot;Hyderabad&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1006, Name = &quot;Tushar&quot;, Company = &quot;Samsung&quot;, Location = &quot;Hyderabad&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1007, Name = &quot;Jia&quot;, Company = &quot;TCS&quot;, Location = &quot;Pune&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1008, Name = &quot;KIRAN&quot;, Company = &quot;CTS&quot;, Location = &quot;Bangalore&quot; &#125;);  </span><br><span class=\"line\">li.Add(new Employee &#123; Id = 1009, Name = &quot;Rinku&quot;, Company = &quot;CGI&quot;, Location = &quot;Bangalore&quot; &#125;);  </span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure>\n\n<p> 这是Employee类:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Employee  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    public int Id &#123; get; set; &#125;  </span><br><span class=\"line\">    public string Name &#123; get; set; &#125;  </span><br><span class=\"line\">    public string Company &#123; get; set; &#125;  </span><br><span class=\"line\">    public string Designation &#123; get; set; &#125;  </span><br><span class=\"line\">    public string Location &#123; get; set; &#125;  </span><br><span class=\"line\">       </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 这就是我们可以使用Parallel Foreach循环的方式。 </p>\n<p><img src=\"/parallel.png\" alt></p>\n<p>该循环将立即执行并给出结果。在Foreach循环的情况下，它一一给出结果。假设结果集中有1000条记录，则循环将执行一次1000次以得到结果。</p>\n<p><strong>注意：</strong> 当您要获取的记录数量很少时，请不要使用Parallel foreach循环。</p>\n<h2 id=\"使用异步编程来处理并发的HTTP请求\"><a href=\"#使用异步编程来处理并发的HTTP请求\" class=\"headerlink\" title=\"使用异步编程来处理并发的HTTP请求\"></a>使用异步编程来处理并发的HTTP请求</h2><p>同步编程中发生的事情是，每当有请求执行Web API时，就会将线程池中的线程分配给要执行的请求。该线程被阻塞，直到执行该过程并返回结果为止。</p>\n<p><img src=\"/as1.png\" alt></p>\n<p>在这里，T2 线程一直处于阻塞状态，直到它处理请求并返回结果为止；如果遇到长的执行循环，则它将花费大量时间并一直等待到结束。</p>\n<p>假设我们只有3个线程，并且所有线程都已分配给队列中正在等待的三个请求。在这种情况下，如果第四个请求在我们同步实现时出现，它将发出错误，因为现在它没有任何线程可以处理该请求。</p>\n<p>因此，要处理更多数量的并发HTTP请求，我们必须使用异步编程。</p>\n<p>异步请求处理程序的操作有所不同。当请求到达Web API控制器时，它将获取其线程池线程之一，并将其分配给该请求。</p>\n<p>在进程开始执行的同时，线程将返回到线程池。执行完成后，为该请求分配了另一个线程来带来该请求，因此，该线程将不会等到进程执行完成后才返回到线程池以处理另一个请求。</p>\n<p><img src=\"/final.png\" alt></p>\n<p> 因此，在这里我给出了一个小的注册示例，以及如何在Web API中使用异步编程。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[AllowAnonymous]  </span><br><span class=\"line\">[Route(&quot;Register&quot;)]  </span><br><span class=\"line\">public async Task&lt;IHttpActionResult&gt; Register(RegisterBindingModel model)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    Dictionary&lt;object, object&gt; dict = new Dictionary&lt;object, object&gt;();  </span><br><span class=\"line\">    if (!ModelState.IsValid)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        return BadRequest(ModelState);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    var user = new ApplicationUser() &#123; UserName = model.Email, Email = model.Email &#125;;  </span><br><span class=\"line\">    IdentityResult result = await UserManager.CreateAsync(user, model.Password);  </span><br><span class=\"line\">    if (result.Succeeded)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        tbl_Users obj = new tbl_Users();  </span><br><span class=\"line\">        obj.Active = false;  </span><br><span class=\"line\">        obj.FirstName = model.FirstName;  </span><br><span class=\"line\">        obj.LastName = model.LastName;  </span><br><span class=\"line\">        obj.Email = model.Email;  </span><br><span class=\"line\">        obj.UserId = user.Id;  </span><br><span class=\"line\">        DefEntity.tbl_Users.Add(obj);  </span><br><span class=\"line\">        if (DefEntity.SaveChanges() == 1)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            dict.Add(&quot;Success&quot;, &quot;Data Saved Successfully.&quot;);  </span><br><span class=\"line\">            return Ok(dict);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        else  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            return Content(HttpStatusCode.BadRequest, &quot;User Details not Saved.&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    else  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        return GetErrorResult(result);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"压缩Web-API的结果\"><a href=\"#压缩Web-API的结果\" class=\"headerlink\" title=\"压缩Web API的结果\"></a>压缩Web API的结果</h2><p>Web API压缩对于提高ASP.NET Web API性能非常重要。在Web中，数据以包（数据包）的形式通过网络传输，从而增加了数据包的大小，这将增加大小并增加Web API的响应时间。因此，减小数据包大小可提高Web API的加载性能。</p>\n<p>通过压缩API响应，我们具有以下两个优点。</p>\n<ul>\n<li><p>数据大小将减小</p>\n</li>\n<li><p>响应时间将增加（增加客户端和服务器之间的通信速度。）</p>\n<p>我们可以通过编码和IIS中的某些设置来压缩Web API。我已经在以下链接中介绍了使用编码对Web API进行压缩的方法。</p>\n</li>\n</ul>\n<ol>\n<li><ul>\n<li><a href=\"http://www.c-sharpcorner.com/article/compressing-web-api-response-to-using-dotnetzip/\" target=\"_blank\" rel=\"noopener\">使用DotNetZip压缩Web API响应</a></li>\n<li><a href=\"http://www.c-sharpcorner.com/article/compressing-web-api-response-part-two/\" target=\"_blank\" rel=\"noopener\">压缩Web API响应</a></li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>同样，我们可以通过检查动态内容压缩模块来启用IIS压缩 。</p>\n<p><img src=\"/iis1.png\" alt></p>\n</li>\n<li><p>因此，通过这种方式，我们可以压缩Web API响应以实现性能。</p>\n</li>\n</ul>\n<h2 id=\"使用缓存提高性能\"><a href=\"#使用缓存提高性能\" class=\"headerlink\" title=\"使用缓存提高性能\"></a>使用缓存提高性能</h2><p>缓存是一种在一定时间段内将常用数据或信息存储在本地存储器中的技术。因此，下一次，当客户端请求相同的信息时，它将从本地内存中提供信息，而不是从数据库中检索信息。缓存的主要优点是它通过减少处理负担来提高性能。我们有几种方法可以在Web api中实现缓存。在下面的链接中，我描述了一种实现缓存的方法。</p>\n<ul>\n<li><p><a href=\"http://www.c-sharpcorner.com/article/implementing-caching-in-web-api/\" target=\"_blank\" rel=\"noopener\">在Web API中实现缓存</a></p>\n<p>因此，在这里您将找到我们如何在Web API中实现缓存以及它将如何帮助提高性能。</p>\n</li>\n</ul>\n<h2 id=\"使用高速JSON序列化器\"><a href=\"#使用高速JSON序列化器\" class=\"headerlink\" title=\"使用高速JSON序列化器\"></a>使用高速JSON序列化器</h2><p>我们经常使用JSON而不是XML来在服务提供者和服务客户端之间交换数据。首先，我们使用它是因为JSON是轻量级的。</p>\n<p>在.NET中，有很多序列化器。最受欢迎的是Json.NET，Microsoft选择它作为Web API的默认JSON序列化器。Json.NET之所以出色，是因为它快速，健壮且可配置。</p>\n<p>有几种序列化器比Json.Net更快。下面提到其中一些。</p>\n<p><img src=\"/ser.png\" alt></p>\n<p>我们可以看到Protobuf-Net和JIL是非常快速的序列化程序，因此，如果可以代替Json.net来实现它们，则显然可以提高性能。协议缓冲区或Protobuf是Google的官方序列化程序。要在.Net中使用JIL序列化程序，我已经写了一篇文章，您可以在下面的链接中进行检查。</p>\n<ul>\n<li><a href=\"http://www.c-sharpcorner.com/article/working-with-jil-serializer-and-deserializer-library-in-c-sharp/\" target=\"_blank\" rel=\"noopener\">在C＃中使用Jil序列化器和反序列化器库</a></li>\n</ul>\n<h2 id=\"创建适当的数据库结构\"><a href=\"#创建适当的数据库结构\" class=\"headerlink\" title=\"创建适当的数据库结构\"></a>创建适当的数据库结构</h2><p>为了提高任何应用程序的性能，我们应该将重点放在数据库结构上。我可以说数据库结构在提高性能方面起着重要作用。这些是我们在处理数据库时应检查的一些注意事项。</p>\n<ul>\n<li><p>尝试使规范化表结构。</p>\n</li>\n<li><p>为所有表提供适当的索引，以便从表中轻松搜索结果。</p>\n</li>\n<li><p>将所有相互关联的表与外键和主键相关联。</p>\n<p>我认为在创建数据库结构以提高性能时，我们必须至少遵循这三个规则。</p>\n</li>\n</ul>\n<p><strong>尝试从客户端验证某些属性</strong></p>\n<p>从客户端而不是服务器端验证某些模型属性非常好。一旦我们在未经客户端验证的情况下放置了无效数据，则它将进入服务器并检查其是否为有效数据。如果它是无效的数据，它将从服务器给出错误。因此，在这里我们可以使用客户端验证检查往返行程。因此，如果我们可以通过客户端（移动设备，网站等）进行任何可能的验证，那将是很好的。</p>\n<p><img src=\"/valida.jpg\" alt></p>\n<p> 因此，我认为，如果我们专注于以上讨论的要点，则可以以某种方式提高Web API的性能。 </p>\n"},{"title":"使用REST API 最佳实践简述","date":"2020-05-12T11:07:00.000Z","author":"邹溪源","_content":"# 使用REST API 最佳实践简述\n\nFacebook，Google，Github，Netflix，Amazon和Twitter等许多巨头都拥有自己的REST（ful）API，您可以访问它们来获取甚至写入数据。\n\n但是，为什么所有都需要REST？\n\n那样好吗，为什么如此盛行？\n\n当然，这不是传达消息的唯一方法吗？\n\nREST和HTTP有什么区别？\n\n好吧，事实证明**REST非常灵活，并且与** Internet所基于的主要协议**HTTP兼容**。由于它是一种架构风格而不是标准，因此它**提供了实现各种设计最佳实践的大量自由**。以及听说它与语言无关？你一定觉得它很棒吧。\n\n在此博客文章中，我们的目标是尽可能清楚地解释REST，以便您可以清楚地了解何时以及如何使用REST，以及它的本质。\n\n我们将介绍一些基础知识和定义，并展示一些**REST API最佳实践**。这应该为您提供了以您喜欢的任何编码语言实现REST API所需的全部知识。\n\n如果您对HTTP不太熟悉，建议您阅读我们的[HTTP系列文章](https://code-maze.com/http-series/)，或者至少阅读其中的[第1部分](https://code-maze.com/http-series-part-1/)，这样您可以更轻松地理解这些资料。\n\n因此，在这篇文章中，我们将讨论：\n\n**关于REST：**\n\n- [什么是REST？](https://code-maze.com/top-rest-api-best-practices/#whatisrest)\n- [REST是否绑定到HTTP？](https://code-maze.com/top-rest-api-best-practices/#restbound)\n- [REST和HATEOAS支持](https://code-maze.com/top-rest-api-best-practices/#hateoas)\n- [RESTful API是什么意思？](https://code-maze.com/top-rest-api-best-practices/#whatdoesitmean)\n- [REST过多又称为RESTafarian综合征](https://code-maze.com/top-rest-api-best-practices/#restafarian)\n\n**REST API最佳做法：**\n\n- [抽象与具体API](https://code-maze.com/top-rest-api-best-practices/#abstractvsconcrete)\n- [URI格式（名词，不是动词）。正确网址与错误网址示例](https://code-maze.com/top-rest-api-best-practices/#urlformat)\n- [错误处理](https://code-maze.com/top-rest-api-best-practices/#errorhandling)\n- [状态码](https://code-maze.com/top-rest-api-best-practices/#statuscodes)\n- [安全](https://code-maze.com/top-rest-api-best-practices/#security)\n- [REST API版本控制](https://code-maze.com/top-rest-api-best-practices/#versioning)\n- [文件的重要性](https://code-maze.com/top-rest-api-best-practices/#documentation)\n\n## 那么REST本质上是什么？\n\nREST（代表性状态转移）是[Roy Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)在其博士学位中创立的一种建筑风格。UC Irvine的论文“ [体系结构样式和基于网络的软件体系结构设计](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm) ”。 他与HTTP 1.1同步提出了这种观点。\n\n我们主要将REST用作**在万维网上的计算机系统之间进行通信的**一种方式。\n\n## REST是否绑定到HTTP？\n\n根据定义，似乎与Http强制绑定？其实并非如此。尽管您可以将其他一些应用程序协议与REST一起使用，但是在实现REST时，[HTTP](https://code-maze.com/http-series/)仍然是应用程序协议中无可争议的冠军。\n\n## REST和HATEOAS支持\n\n**作为应用程序状态引擎的** HATEOAS或**超媒体** 是每个可扩展且灵活的REST API的重要功能。\n\n该[HATEOAS](https://en.wikipedia.org/wiki/HATEOAS)约束建议，客户端和服务器通信完全采用了[超媒体](https://en.wikipedia.org/wiki/Hypermedia)。\n\n使用超媒体有几个优点：\n\n- 使API设计人员能够在每个响应中包括他们所能提供的一切，以正确地提供一件事以及与相关端点的超媒体链接，从而使设计脱钩\n- 帮助API更优雅地发展和成熟\n- 为用户提供更深入地探索API的方法\n\n因此很明显，HATEOAS在**设计时考虑了耐用性**。\n\nGitHub的工作方式如下： \n\n` GET https://api.github.com/users/codemazeblog`\n\n响应：  \n\n```javascript\n{\n  \"login\": \"CodeMazeBlog\",\n  \"id\": 29179238,\n  \"avatar_url\": \"https://avatars0.githubusercontent.com/u/29179238?v=4\",\n  \"gravatar_id\": \"\",\n  \"url\": \"https://api.github.com/users/CodeMazeBlog\",\n  \"html_url\": \"https://github.com/CodeMazeBlog\",\n  \"followers_url\": \"https://api.github.com/users/CodeMazeBlog/followers\",\n  \"following_url\": \"https://api.github.com/users/CodeMazeBlog/following{/other_user}\",\n  \"gists_url\": \"https://api.github.com/users/CodeMazeBlog/gists{/gist_id}\",\n  \"starred_url\": \"https://api.github.com/users/CodeMazeBlog/starred{/owner}{/repo}\",\n  \"subscriptions_url\": \"https://api.github.com/users/CodeMazeBlog/subscriptions\",\n  \"organizations_url\": \"https://api.github.com/users/CodeMazeBlog/orgs\",\n  \"repos_url\": \"https://api.github.com/users/CodeMazeBlog/repos\",\n  \"events_url\": \"https://api.github.com/users/CodeMazeBlog/events{/privacy}\",\n  \"received_events_url\": \"https://api.github.com/users/CodeMazeBlog/received_events\",\n  \"type\": \"User\",\n  \"site_admin\": false,\n  \"name\": \"Code Maze\",\n  \"company\": \"Code Maze\",\n  \"blog\": \"https://code-maze.com\",\n  \"bio\": \"A practical programmers' resource.\",\n  ...\n}\n```\n\n如您所见，除了客户端请求的关键信息之外，您还可以在响应中找到一堆相关的超媒体链接，这些链接将您带到您可以自由浏览的API的其他部分。\n\n## RESTful API是什么意思？\n\n“ RESTful”意味着一些功能：\n\n- **[客户端-服务器体系结构](https://code-maze.com/http-series-part-2)：**完整的服务由作为整个系统前端的“客户端”和作为后端的“服务器”组成\n- **无状态：**服务器不应在不同请求之间保存任何状态。会话状态完全由客户负责。按照REST定义： ***所有REST交互都是无状态的。也就是说，每个请求都包含连接器理解该请求所需的所有信息，而与之前的任何请求无关。（[Roy的论文ch.5.2.2](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)）\\***\n- **[可缓存的](https://code-maze.com/http-series-part-2/#caching)：**客户端应该能够将响应存储在缓存中以提高性能\n\n因此，RESTful API是一项遵循这些规则的服务（希望如此），并使用[HTTP方法](https://code-maze.com/the-http-reference/#requestmethods)来操纵资源集。\n\n但是为什么我们需要或使用RESTful API？\n\n因为它们为我们提供了一种简单，灵活和可扩展的方式来制作可通过Internet进行通信的分布式应用程序。\n\n## 我们可以拥有更多的REST方法吗？\n\n是的，你猜对了。是的，我们可以🙂\n\n正如[Mike Schinkel](http://mikeschinkel.com/about/)定义的那样，对于狂热地遵循REST的人们来说甚至还有一个短语 [。](http://mikeschinkel.com/about/)\n\n> RESTifarian是Roy T. Fielding在他的博士论文第五章中定义的REST软件架构风格的狂热支持者。论文在UCIrvine。你可以在rest - discussion邮件列表中找到野外的RESTifarians。但是要小心，RESTifarians在讨论休息的细节时可能是极其细致的，正如我最近在参与列表时所了解到的。🙂\n\n太多的事情都是不好的。\n\n我们需要一点**实用主义**才能做出好的应用程序和服务。了解和理解一种理论很重要，但是该理论的实现是区分不良与良好与卓越应用的区别。所以要聪明，要牢记最终用户。\n\n因此，让我们走一些使API变得“光彩”的重要点，使用户的生活变得更加轻松。\n\n## 抽象与具体API\n\n在开发软件时，我们经常使用抽象和多态来获取大多数应用程序。我们想重用尽可能多的代码。\n\n那么我们也应该这样写我们的API吗？\n\n好吧，API并非完全如此。对于REST API，**具体要比abstract好**。你能猜出为什么吗？\n\n让我向您展示一些示例：\n\n让我们看两个API版本。它是最好有有一个的API `/entities`，或者有一个API `/owners`，`/blogs`并 `/blogposts` 分别？\n\n作为开发人员，哪一个对您更具描述性？您想使用哪个API？\n\n我总是会选择第二个。\n\n## **URI格式（名词，不是动词）。正确网址与错误网址示例**\n\n这是另一种REST API最佳实践。您应该如何格式化端点？\n\n如果使用软件开发方法，您将得到如下所示的结果：\n\n```\n/getAllBlogPosts\n/updateBlogPost/12\n/deleteBlogPost/12\n/getAuthorById/3\n/deleteAuthor/3\n/updateAuthor/3\n```\n\n您明白了……会有很多端点，每个端点都在做其他事情。有一个更好的系统可以解决这些问题。\n\n将资源视为名词，将HTTP方法视为动词。如果这样做，最终将得到如下结果：\n\n`GET /blogposts` –获取所有博客文章\n\n`GET /blogposts/12` –获取ID为12的博客文章\n\n`POST /blogposts` –添加新的博客文章并返回详细信息\n\n`DELETE /blogposts/12` –删除ID为12的博客文章\n\n`GET /authors/3/blogposts` –获取ID为3的作者的所有博客文章\n\n这是创建API的更简洁，更精确的方法。对于最终用户而言，这是显而易见的，并且有一种解决方法。\n\n通过使用单数而不是复数来表示资源名称，可以使其更加简洁。那取决于你。\n\n## **错误处理**\n\nAPI构建的另一个重要方面。有几种处理错误的好方法。\n\n让我们看看顶级狗如何做到这一点：\n\n**推特：**\n\n- 请求： `GET https://api.twitter.com/1.1/account/settings.json`\n\n- 响应：状态码400\n\n  Twitter response\n\n   \n\n  ```\n  {\"errors\":[{\"code\":215,\"message\":\"Bad Authentication data.\"}]}\n  ```\n\n  \n\nTwitter为您提供状态代码和错误代码，并简要描述了所发生错误的性质。他们让您在“ [响应代码”](https://developer.twitter.com/en/docs/basics/response-codes)页面上查找代码。\n\n**脸书：**\n\n- 请求： `GET https://graph.facebook.com/me/photos`\n\n- 响应：状态码400\n\n  Facebook Response \n\n  ```\n  {  \"error\": {   \"message\": \"An active access token must be used to query information about the current user.\",   \"type\": \"OAuthException\",   \"code\": 2500,   \"fbtrace_id\": \"DzkTMkgIA7V\"  }}\n  ```\n\n  \n\nFacebook为您提供了更具描述性的错误消息。\n\n**特威里奥：**\n\n- 请求： `GET https://api.twilio.com/2010-04-01/Accounts/1234/IncomingPhoneNumbers/1234`\n\n- 响应：状态码404 \n\n  ```\n  <?xml version='1.0' encoding='UTF-8'?><TwilioResponse>  <RestException>    <Code>20404</Code>    <Message>The requested resource /2010-04-01/Accounts/1234/IncomingPhoneNumbers/1234 was not found</Message>    <MoreInfo>https://www.twilio.com/docs/errors/20404</MoreInfo>    <Status>404</Status>  </RestException></TwilioResponse>\n  ```\n\n  \n\nTwilio默认为您提供XML响应，并提供指向文档的链接，您可以在其中找到错误的详细信息。\n\n如您所见，错误处理的方法因实现而异。\n\n重要的是 **不要让REST API的用户“挂断”**，不知道发生了什么，或者漫无目的地在StackOverflow的浪费中徘徊，寻找解释。\n\n## **状态码**\n\n在设计REST API时，我们通过使用[HTTP状态代码](https://code-maze.com/the-http-reference/#statuscodes)与API用户进行通信 。状态代码很多，描述了多种可能的响应。\n\n但是，我们应该使用多少？ **我们在每种情况下都应该有严格的状态码吗？**\n\n就像生活中的许多事情一样， [KISS原则](https://en.wikipedia.org/wiki/KISS_principle) 也适用于这里。那里有70多个状态代码。你内心了解他们吗？潜在的API用户会全部了解它们，还是会再次使用Google搜索？\n\n大多数开发人员都熟悉最常见的状态代码：\n\n- `**200 OK**`\n- `**400 Bad Request**`\n- `**500 Internal Server Error**`\n\n从这三个开始，您可以涵盖REST API的大多数功能。\n\n其他常见的代码包括：\n\n- `**201 Created**`\n- `**204 No Content**`\n- `**401 Unauthorized**`\n- `**403 Forbidden**`\n- `**404 Not Found**`\n\n我们可以使用它们来帮助用户快速找出结果。如果您感觉到状态代码的描述性不如我们在“错误处理”部分中讨论的那样，则可能应该包含某种消息。再一次，我们需要务实，通过使用 **数量有限的代码** 和描述性消息来帮助用户。\n\n您可以在[此处](https://code-maze.com/the-http-reference)找到完整的HTTP状态代码列表，以及[在CodeMaze上总结的](https://code-maze.com/the-http-reference)其他有用的HTTP内容 。\n\n## **安全**\n\n关于[REST API安全的](https://blog.restcase.com/top-5-rest-api-security-guidelines/)说法不多，因为 **REST不处理安全问题**。它依赖于诸如[基本身份验证或摘要身份验证之](https://code-maze.com/http-series-part-4/)类的标准HTTP机制 。\n\n每个请求都应 **通过HTTPS进行**。\n\n有很多技巧可以提高REST API的安全性，但是由于REST的无状态性，因此在实施它们时必须谨慎。记住最后一个请求的状态超出了窗口，**应该**在 **客户端存储和验证状态。**\n\n**时间戳记和日志记录** 请求也可以有所帮助。\n\n关于这个话题还有很多要说的，但这超出了本文的范围。我们有一个不错的职位**[HTTP安全](https://code-maze.com/http-series-part-5/)** 在这里CodeMaze如果您想了解更多关于这一点。 \n\n## **REST API版本控制**\n\n您已经编写了REST API，它已经非常成功，许多人已经使用它并对此感到满意。但是，您拥有的多汁的新功能会破坏系统的其他部分。重大变化。\n\n不用担心，有解决方案！\n\n在开始制作您的API之前，我们可以通过在端点之前加上API版本来对其进行版本控制：\n`https://api.example.com/v1/authors/2/blogposts/13`\n\n这样，只要API发生重大更改，我们就可以始终增加API版本号（例如v2，v3…）。这也向用户发出信号，表明已发生了翻天覆地的变化，在使用新版本时，请务必小心。\n\n## **文件的重要性**\n\n这是不言而喻的。您可能是世界上最好的API设计人员，但是 **如果没有文档，您的API就像死了一样。**\n\n**正确的文档** 对于每个软件产品和Web服务都是**必不可少**的。\n\n我们可以通过保持一致并使用清晰和描述性的语法来帮助用户。但是，好的文档页面并没有真正的替代品。\n\n一些很好的例子：\n\nhttps://www.twilio.com/docs/api/rest/\n\nhttps://developers.facebook.com/docs/\n\nhttps://developers.google.com/maps/documentation/\n\n还有很多其他...\n\n有许多工具可以帮助您记录您的API，但是不要忘记让人参与其中，只有一个人可以正确地理解另一个人。至少现在是这样(看着你)。\n\n## 结论\n\n我们讨论了REST API构建的许多概念，并介绍了一些顶级REST API最佳实践。在一次提供这些API时，您可能会觉得有些奇怪或难以接受，但是请尝试自己创建REST API。并尝试实现一些您在这里学到的REST API最佳实践。 ","source":"_posts/技术/最佳REST API最佳做法.md","raw":"---\ntitle:   使用REST API 最佳实践简述\ndate: 2020-5-12 19:07\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n# 使用REST API 最佳实践简述\n\nFacebook，Google，Github，Netflix，Amazon和Twitter等许多巨头都拥有自己的REST（ful）API，您可以访问它们来获取甚至写入数据。\n\n但是，为什么所有都需要REST？\n\n那样好吗，为什么如此盛行？\n\n当然，这不是传达消息的唯一方法吗？\n\nREST和HTTP有什么区别？\n\n好吧，事实证明**REST非常灵活，并且与** Internet所基于的主要协议**HTTP兼容**。由于它是一种架构风格而不是标准，因此它**提供了实现各种设计最佳实践的大量自由**。以及听说它与语言无关？你一定觉得它很棒吧。\n\n在此博客文章中，我们的目标是尽可能清楚地解释REST，以便您可以清楚地了解何时以及如何使用REST，以及它的本质。\n\n我们将介绍一些基础知识和定义，并展示一些**REST API最佳实践**。这应该为您提供了以您喜欢的任何编码语言实现REST API所需的全部知识。\n\n如果您对HTTP不太熟悉，建议您阅读我们的[HTTP系列文章](https://code-maze.com/http-series/)，或者至少阅读其中的[第1部分](https://code-maze.com/http-series-part-1/)，这样您可以更轻松地理解这些资料。\n\n因此，在这篇文章中，我们将讨论：\n\n**关于REST：**\n\n- [什么是REST？](https://code-maze.com/top-rest-api-best-practices/#whatisrest)\n- [REST是否绑定到HTTP？](https://code-maze.com/top-rest-api-best-practices/#restbound)\n- [REST和HATEOAS支持](https://code-maze.com/top-rest-api-best-practices/#hateoas)\n- [RESTful API是什么意思？](https://code-maze.com/top-rest-api-best-practices/#whatdoesitmean)\n- [REST过多又称为RESTafarian综合征](https://code-maze.com/top-rest-api-best-practices/#restafarian)\n\n**REST API最佳做法：**\n\n- [抽象与具体API](https://code-maze.com/top-rest-api-best-practices/#abstractvsconcrete)\n- [URI格式（名词，不是动词）。正确网址与错误网址示例](https://code-maze.com/top-rest-api-best-practices/#urlformat)\n- [错误处理](https://code-maze.com/top-rest-api-best-practices/#errorhandling)\n- [状态码](https://code-maze.com/top-rest-api-best-practices/#statuscodes)\n- [安全](https://code-maze.com/top-rest-api-best-practices/#security)\n- [REST API版本控制](https://code-maze.com/top-rest-api-best-practices/#versioning)\n- [文件的重要性](https://code-maze.com/top-rest-api-best-practices/#documentation)\n\n## 那么REST本质上是什么？\n\nREST（代表性状态转移）是[Roy Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)在其博士学位中创立的一种建筑风格。UC Irvine的论文“ [体系结构样式和基于网络的软件体系结构设计](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm) ”。 他与HTTP 1.1同步提出了这种观点。\n\n我们主要将REST用作**在万维网上的计算机系统之间进行通信的**一种方式。\n\n## REST是否绑定到HTTP？\n\n根据定义，似乎与Http强制绑定？其实并非如此。尽管您可以将其他一些应用程序协议与REST一起使用，但是在实现REST时，[HTTP](https://code-maze.com/http-series/)仍然是应用程序协议中无可争议的冠军。\n\n## REST和HATEOAS支持\n\n**作为应用程序状态引擎的** HATEOAS或**超媒体** 是每个可扩展且灵活的REST API的重要功能。\n\n该[HATEOAS](https://en.wikipedia.org/wiki/HATEOAS)约束建议，客户端和服务器通信完全采用了[超媒体](https://en.wikipedia.org/wiki/Hypermedia)。\n\n使用超媒体有几个优点：\n\n- 使API设计人员能够在每个响应中包括他们所能提供的一切，以正确地提供一件事以及与相关端点的超媒体链接，从而使设计脱钩\n- 帮助API更优雅地发展和成熟\n- 为用户提供更深入地探索API的方法\n\n因此很明显，HATEOAS在**设计时考虑了耐用性**。\n\nGitHub的工作方式如下： \n\n` GET https://api.github.com/users/codemazeblog`\n\n响应：  \n\n```javascript\n{\n  \"login\": \"CodeMazeBlog\",\n  \"id\": 29179238,\n  \"avatar_url\": \"https://avatars0.githubusercontent.com/u/29179238?v=4\",\n  \"gravatar_id\": \"\",\n  \"url\": \"https://api.github.com/users/CodeMazeBlog\",\n  \"html_url\": \"https://github.com/CodeMazeBlog\",\n  \"followers_url\": \"https://api.github.com/users/CodeMazeBlog/followers\",\n  \"following_url\": \"https://api.github.com/users/CodeMazeBlog/following{/other_user}\",\n  \"gists_url\": \"https://api.github.com/users/CodeMazeBlog/gists{/gist_id}\",\n  \"starred_url\": \"https://api.github.com/users/CodeMazeBlog/starred{/owner}{/repo}\",\n  \"subscriptions_url\": \"https://api.github.com/users/CodeMazeBlog/subscriptions\",\n  \"organizations_url\": \"https://api.github.com/users/CodeMazeBlog/orgs\",\n  \"repos_url\": \"https://api.github.com/users/CodeMazeBlog/repos\",\n  \"events_url\": \"https://api.github.com/users/CodeMazeBlog/events{/privacy}\",\n  \"received_events_url\": \"https://api.github.com/users/CodeMazeBlog/received_events\",\n  \"type\": \"User\",\n  \"site_admin\": false,\n  \"name\": \"Code Maze\",\n  \"company\": \"Code Maze\",\n  \"blog\": \"https://code-maze.com\",\n  \"bio\": \"A practical programmers' resource.\",\n  ...\n}\n```\n\n如您所见，除了客户端请求的关键信息之外，您还可以在响应中找到一堆相关的超媒体链接，这些链接将您带到您可以自由浏览的API的其他部分。\n\n## RESTful API是什么意思？\n\n“ RESTful”意味着一些功能：\n\n- **[客户端-服务器体系结构](https://code-maze.com/http-series-part-2)：**完整的服务由作为整个系统前端的“客户端”和作为后端的“服务器”组成\n- **无状态：**服务器不应在不同请求之间保存任何状态。会话状态完全由客户负责。按照REST定义： ***所有REST交互都是无状态的。也就是说，每个请求都包含连接器理解该请求所需的所有信息，而与之前的任何请求无关。（[Roy的论文ch.5.2.2](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)）\\***\n- **[可缓存的](https://code-maze.com/http-series-part-2/#caching)：**客户端应该能够将响应存储在缓存中以提高性能\n\n因此，RESTful API是一项遵循这些规则的服务（希望如此），并使用[HTTP方法](https://code-maze.com/the-http-reference/#requestmethods)来操纵资源集。\n\n但是为什么我们需要或使用RESTful API？\n\n因为它们为我们提供了一种简单，灵活和可扩展的方式来制作可通过Internet进行通信的分布式应用程序。\n\n## 我们可以拥有更多的REST方法吗？\n\n是的，你猜对了。是的，我们可以🙂\n\n正如[Mike Schinkel](http://mikeschinkel.com/about/)定义的那样，对于狂热地遵循REST的人们来说甚至还有一个短语 [。](http://mikeschinkel.com/about/)\n\n> RESTifarian是Roy T. Fielding在他的博士论文第五章中定义的REST软件架构风格的狂热支持者。论文在UCIrvine。你可以在rest - discussion邮件列表中找到野外的RESTifarians。但是要小心，RESTifarians在讨论休息的细节时可能是极其细致的，正如我最近在参与列表时所了解到的。🙂\n\n太多的事情都是不好的。\n\n我们需要一点**实用主义**才能做出好的应用程序和服务。了解和理解一种理论很重要，但是该理论的实现是区分不良与良好与卓越应用的区别。所以要聪明，要牢记最终用户。\n\n因此，让我们走一些使API变得“光彩”的重要点，使用户的生活变得更加轻松。\n\n## 抽象与具体API\n\n在开发软件时，我们经常使用抽象和多态来获取大多数应用程序。我们想重用尽可能多的代码。\n\n那么我们也应该这样写我们的API吗？\n\n好吧，API并非完全如此。对于REST API，**具体要比abstract好**。你能猜出为什么吗？\n\n让我向您展示一些示例：\n\n让我们看两个API版本。它是最好有有一个的API `/entities`，或者有一个API `/owners`，`/blogs`并 `/blogposts` 分别？\n\n作为开发人员，哪一个对您更具描述性？您想使用哪个API？\n\n我总是会选择第二个。\n\n## **URI格式（名词，不是动词）。正确网址与错误网址示例**\n\n这是另一种REST API最佳实践。您应该如何格式化端点？\n\n如果使用软件开发方法，您将得到如下所示的结果：\n\n```\n/getAllBlogPosts\n/updateBlogPost/12\n/deleteBlogPost/12\n/getAuthorById/3\n/deleteAuthor/3\n/updateAuthor/3\n```\n\n您明白了……会有很多端点，每个端点都在做其他事情。有一个更好的系统可以解决这些问题。\n\n将资源视为名词，将HTTP方法视为动词。如果这样做，最终将得到如下结果：\n\n`GET /blogposts` –获取所有博客文章\n\n`GET /blogposts/12` –获取ID为12的博客文章\n\n`POST /blogposts` –添加新的博客文章并返回详细信息\n\n`DELETE /blogposts/12` –删除ID为12的博客文章\n\n`GET /authors/3/blogposts` –获取ID为3的作者的所有博客文章\n\n这是创建API的更简洁，更精确的方法。对于最终用户而言，这是显而易见的，并且有一种解决方法。\n\n通过使用单数而不是复数来表示资源名称，可以使其更加简洁。那取决于你。\n\n## **错误处理**\n\nAPI构建的另一个重要方面。有几种处理错误的好方法。\n\n让我们看看顶级狗如何做到这一点：\n\n**推特：**\n\n- 请求： `GET https://api.twitter.com/1.1/account/settings.json`\n\n- 响应：状态码400\n\n  Twitter response\n\n   \n\n  ```\n  {\"errors\":[{\"code\":215,\"message\":\"Bad Authentication data.\"}]}\n  ```\n\n  \n\nTwitter为您提供状态代码和错误代码，并简要描述了所发生错误的性质。他们让您在“ [响应代码”](https://developer.twitter.com/en/docs/basics/response-codes)页面上查找代码。\n\n**脸书：**\n\n- 请求： `GET https://graph.facebook.com/me/photos`\n\n- 响应：状态码400\n\n  Facebook Response \n\n  ```\n  {  \"error\": {   \"message\": \"An active access token must be used to query information about the current user.\",   \"type\": \"OAuthException\",   \"code\": 2500,   \"fbtrace_id\": \"DzkTMkgIA7V\"  }}\n  ```\n\n  \n\nFacebook为您提供了更具描述性的错误消息。\n\n**特威里奥：**\n\n- 请求： `GET https://api.twilio.com/2010-04-01/Accounts/1234/IncomingPhoneNumbers/1234`\n\n- 响应：状态码404 \n\n  ```\n  <?xml version='1.0' encoding='UTF-8'?><TwilioResponse>  <RestException>    <Code>20404</Code>    <Message>The requested resource /2010-04-01/Accounts/1234/IncomingPhoneNumbers/1234 was not found</Message>    <MoreInfo>https://www.twilio.com/docs/errors/20404</MoreInfo>    <Status>404</Status>  </RestException></TwilioResponse>\n  ```\n\n  \n\nTwilio默认为您提供XML响应，并提供指向文档的链接，您可以在其中找到错误的详细信息。\n\n如您所见，错误处理的方法因实现而异。\n\n重要的是 **不要让REST API的用户“挂断”**，不知道发生了什么，或者漫无目的地在StackOverflow的浪费中徘徊，寻找解释。\n\n## **状态码**\n\n在设计REST API时，我们通过使用[HTTP状态代码](https://code-maze.com/the-http-reference/#statuscodes)与API用户进行通信 。状态代码很多，描述了多种可能的响应。\n\n但是，我们应该使用多少？ **我们在每种情况下都应该有严格的状态码吗？**\n\n就像生活中的许多事情一样， [KISS原则](https://en.wikipedia.org/wiki/KISS_principle) 也适用于这里。那里有70多个状态代码。你内心了解他们吗？潜在的API用户会全部了解它们，还是会再次使用Google搜索？\n\n大多数开发人员都熟悉最常见的状态代码：\n\n- `**200 OK**`\n- `**400 Bad Request**`\n- `**500 Internal Server Error**`\n\n从这三个开始，您可以涵盖REST API的大多数功能。\n\n其他常见的代码包括：\n\n- `**201 Created**`\n- `**204 No Content**`\n- `**401 Unauthorized**`\n- `**403 Forbidden**`\n- `**404 Not Found**`\n\n我们可以使用它们来帮助用户快速找出结果。如果您感觉到状态代码的描述性不如我们在“错误处理”部分中讨论的那样，则可能应该包含某种消息。再一次，我们需要务实，通过使用 **数量有限的代码** 和描述性消息来帮助用户。\n\n您可以在[此处](https://code-maze.com/the-http-reference)找到完整的HTTP状态代码列表，以及[在CodeMaze上总结的](https://code-maze.com/the-http-reference)其他有用的HTTP内容 。\n\n## **安全**\n\n关于[REST API安全的](https://blog.restcase.com/top-5-rest-api-security-guidelines/)说法不多，因为 **REST不处理安全问题**。它依赖于诸如[基本身份验证或摘要身份验证之](https://code-maze.com/http-series-part-4/)类的标准HTTP机制 。\n\n每个请求都应 **通过HTTPS进行**。\n\n有很多技巧可以提高REST API的安全性，但是由于REST的无状态性，因此在实施它们时必须谨慎。记住最后一个请求的状态超出了窗口，**应该**在 **客户端存储和验证状态。**\n\n**时间戳记和日志记录** 请求也可以有所帮助。\n\n关于这个话题还有很多要说的，但这超出了本文的范围。我们有一个不错的职位**[HTTP安全](https://code-maze.com/http-series-part-5/)** 在这里CodeMaze如果您想了解更多关于这一点。 \n\n## **REST API版本控制**\n\n您已经编写了REST API，它已经非常成功，许多人已经使用它并对此感到满意。但是，您拥有的多汁的新功能会破坏系统的其他部分。重大变化。\n\n不用担心，有解决方案！\n\n在开始制作您的API之前，我们可以通过在端点之前加上API版本来对其进行版本控制：\n`https://api.example.com/v1/authors/2/blogposts/13`\n\n这样，只要API发生重大更改，我们就可以始终增加API版本号（例如v2，v3…）。这也向用户发出信号，表明已发生了翻天覆地的变化，在使用新版本时，请务必小心。\n\n## **文件的重要性**\n\n这是不言而喻的。您可能是世界上最好的API设计人员，但是 **如果没有文档，您的API就像死了一样。**\n\n**正确的文档** 对于每个软件产品和Web服务都是**必不可少**的。\n\n我们可以通过保持一致并使用清晰和描述性的语法来帮助用户。但是，好的文档页面并没有真正的替代品。\n\n一些很好的例子：\n\nhttps://www.twilio.com/docs/api/rest/\n\nhttps://developers.facebook.com/docs/\n\nhttps://developers.google.com/maps/documentation/\n\n还有很多其他...\n\n有许多工具可以帮助您记录您的API，但是不要忘记让人参与其中，只有一个人可以正确地理解另一个人。至少现在是这样(看着你)。\n\n## 结论\n\n我们讨论了REST API构建的许多概念，并介绍了一些顶级REST API最佳实践。在一次提供这些API时，您可能会觉得有些奇怪或难以接受，但是请尝试自己创建REST API。并尝试实现一些您在这里学到的REST API最佳实践。 ","slug":"技术/最佳REST API最佳做法","published":1,"updated":"2020-05-26T11:09:57.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt7y001on4vimoy7aqzq","content":"<h1 id=\"使用REST-API-最佳实践简述\"><a href=\"#使用REST-API-最佳实践简述\" class=\"headerlink\" title=\"使用REST API 最佳实践简述\"></a>使用REST API 最佳实践简述</h1><p>Facebook，Google，Github，Netflix，Amazon和Twitter等许多巨头都拥有自己的REST（ful）API，您可以访问它们来获取甚至写入数据。</p>\n<p>但是，为什么所有都需要REST？</p>\n<p>那样好吗，为什么如此盛行？</p>\n<p>当然，这不是传达消息的唯一方法吗？</p>\n<p>REST和HTTP有什么区别？</p>\n<p>好吧，事实证明<strong>REST非常灵活，并且与</strong> Internet所基于的主要协议<strong>HTTP兼容</strong>。由于它是一种架构风格而不是标准，因此它<strong>提供了实现各种设计最佳实践的大量自由</strong>。以及听说它与语言无关？你一定觉得它很棒吧。</p>\n<p>在此博客文章中，我们的目标是尽可能清楚地解释REST，以便您可以清楚地了解何时以及如何使用REST，以及它的本质。</p>\n<p>我们将介绍一些基础知识和定义，并展示一些<strong>REST API最佳实践</strong>。这应该为您提供了以您喜欢的任何编码语言实现REST API所需的全部知识。</p>\n<p>如果您对HTTP不太熟悉，建议您阅读我们的<a href=\"https://code-maze.com/http-series/\" target=\"_blank\" rel=\"noopener\">HTTP系列文章</a>，或者至少阅读其中的<a href=\"https://code-maze.com/http-series-part-1/\" target=\"_blank\" rel=\"noopener\">第1部分</a>，这样您可以更轻松地理解这些资料。</p>\n<p>因此，在这篇文章中，我们将讨论：</p>\n<p><strong>关于REST：</strong></p>\n<ul>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#whatisrest\" target=\"_blank\" rel=\"noopener\">什么是REST？</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#restbound\" target=\"_blank\" rel=\"noopener\">REST是否绑定到HTTP？</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#hateoas\" target=\"_blank\" rel=\"noopener\">REST和HATEOAS支持</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#whatdoesitmean\" target=\"_blank\" rel=\"noopener\">RESTful API是什么意思？</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#restafarian\" target=\"_blank\" rel=\"noopener\">REST过多又称为RESTafarian综合征</a></li>\n</ul>\n<p><strong>REST API最佳做法：</strong></p>\n<ul>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#abstractvsconcrete\" target=\"_blank\" rel=\"noopener\">抽象与具体API</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#urlformat\" target=\"_blank\" rel=\"noopener\">URI格式（名词，不是动词）。正确网址与错误网址示例</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#errorhandling\" target=\"_blank\" rel=\"noopener\">错误处理</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#statuscodes\" target=\"_blank\" rel=\"noopener\">状态码</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#security\" target=\"_blank\" rel=\"noopener\">安全</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#versioning\" target=\"_blank\" rel=\"noopener\">REST API版本控制</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#documentation\" target=\"_blank\" rel=\"noopener\">文件的重要性</a></li>\n</ul>\n<h2 id=\"那么REST本质上是什么？\"><a href=\"#那么REST本质上是什么？\" class=\"headerlink\" title=\"那么REST本质上是什么？\"></a>那么REST本质上是什么？</h2><p>REST（代表性状态转移）是<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"noopener\">Roy Fielding</a>在其博士学位中创立的一种建筑风格。UC Irvine的论文“ <a href=\"https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"noopener\">体系结构样式和基于网络的软件体系结构设计</a> ”。 他与HTTP 1.1同步提出了这种观点。</p>\n<p>我们主要将REST用作<strong>在万维网上的计算机系统之间进行通信的</strong>一种方式。</p>\n<h2 id=\"REST是否绑定到HTTP？\"><a href=\"#REST是否绑定到HTTP？\" class=\"headerlink\" title=\"REST是否绑定到HTTP？\"></a>REST是否绑定到HTTP？</h2><p>根据定义，似乎与Http强制绑定？其实并非如此。尽管您可以将其他一些应用程序协议与REST一起使用，但是在实现REST时，<a href=\"https://code-maze.com/http-series/\" target=\"_blank\" rel=\"noopener\">HTTP</a>仍然是应用程序协议中无可争议的冠军。</p>\n<h2 id=\"REST和HATEOAS支持\"><a href=\"#REST和HATEOAS支持\" class=\"headerlink\" title=\"REST和HATEOAS支持\"></a>REST和HATEOAS支持</h2><p><strong>作为应用程序状态引擎的</strong> HATEOAS或<strong>超媒体</strong> 是每个可扩展且灵活的REST API的重要功能。</p>\n<p>该<a href=\"https://en.wikipedia.org/wiki/HATEOAS\" target=\"_blank\" rel=\"noopener\">HATEOAS</a>约束建议，客户端和服务器通信完全采用了<a href=\"https://en.wikipedia.org/wiki/Hypermedia\" target=\"_blank\" rel=\"noopener\">超媒体</a>。</p>\n<p>使用超媒体有几个优点：</p>\n<ul>\n<li>使API设计人员能够在每个响应中包括他们所能提供的一切，以正确地提供一件事以及与相关端点的超媒体链接，从而使设计脱钩</li>\n<li>帮助API更优雅地发展和成熟</li>\n<li>为用户提供更深入地探索API的方法</li>\n</ul>\n<p>因此很明显，HATEOAS在<strong>设计时考虑了耐用性</strong>。</p>\n<p>GitHub的工作方式如下： </p>\n<p><code>GET https://api.github.com/users/codemazeblog</code></p>\n<p>响应：  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"login\"</span>: <span class=\"string\">\"CodeMazeBlog\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"id\"</span>: <span class=\"number\">29179238</span>,</span><br><span class=\"line\">  <span class=\"string\">\"avatar_url\"</span>: <span class=\"string\">\"https://avatars0.githubusercontent.com/u/29179238?v=4\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"gravatar_id\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"html_url\"</span>: <span class=\"string\">\"https://github.com/CodeMazeBlog\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"followers_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/followers\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"following_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/following&#123;/other_user&#125;\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"gists_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/gists&#123;/gist_id&#125;\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"starred_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/starred&#123;/owner&#125;&#123;/repo&#125;\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"subscriptions_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/subscriptions\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"organizations_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/orgs\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"repos_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/repos\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"events_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/events&#123;/privacy&#125;\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"received_events_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/received_events\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"type\"</span>: <span class=\"string\">\"User\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"site_admin\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Code Maze\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"company\"</span>: <span class=\"string\">\"Code Maze\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"blog\"</span>: <span class=\"string\">\"https://code-maze.com\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"bio\"</span>: <span class=\"string\">\"A practical programmers' resource.\"</span>,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如您所见，除了客户端请求的关键信息之外，您还可以在响应中找到一堆相关的超媒体链接，这些链接将您带到您可以自由浏览的API的其他部分。</p>\n<h2 id=\"RESTful-API是什么意思？\"><a href=\"#RESTful-API是什么意思？\" class=\"headerlink\" title=\"RESTful API是什么意思？\"></a>RESTful API是什么意思？</h2><p>“ RESTful”意味着一些功能：</p>\n<ul>\n<li><strong><a href=\"https://code-maze.com/http-series-part-2\" target=\"_blank\" rel=\"noopener\">客户端-服务器体系结构</a>：</strong>完整的服务由作为整个系统前端的“客户端”和作为后端的“服务器”组成</li>\n<li><strong>无状态：</strong>服务器不应在不同请求之间保存任何状态。会话状态完全由客户负责。按照REST定义： <strong><em>所有REST交互都是无状态的。也就是说，每个请求都包含连接器理解该请求所需的所有信息，而与之前的任何请求无关。（<a href=\"https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm\" target=\"_blank\" rel=\"noopener\">Roy的论文ch.5.2.2</a>）\\</em></strong></li>\n<li><strong><a href=\"https://code-maze.com/http-series-part-2/#caching\" target=\"_blank\" rel=\"noopener\">可缓存的</a>：</strong>客户端应该能够将响应存储在缓存中以提高性能</li>\n</ul>\n<p>因此，RESTful API是一项遵循这些规则的服务（希望如此），并使用<a href=\"https://code-maze.com/the-http-reference/#requestmethods\" target=\"_blank\" rel=\"noopener\">HTTP方法</a>来操纵资源集。</p>\n<p>但是为什么我们需要或使用RESTful API？</p>\n<p>因为它们为我们提供了一种简单，灵活和可扩展的方式来制作可通过Internet进行通信的分布式应用程序。</p>\n<h2 id=\"我们可以拥有更多的REST方法吗？\"><a href=\"#我们可以拥有更多的REST方法吗？\" class=\"headerlink\" title=\"我们可以拥有更多的REST方法吗？\"></a>我们可以拥有更多的REST方法吗？</h2><p>是的，你猜对了。是的，我们可以🙂</p>\n<p>正如<a href=\"http://mikeschinkel.com/about/\" target=\"_blank\" rel=\"noopener\">Mike Schinkel</a>定义的那样，对于狂热地遵循REST的人们来说甚至还有一个短语 <a href=\"http://mikeschinkel.com/about/\" target=\"_blank\" rel=\"noopener\">。</a></p>\n<blockquote>\n<p>RESTifarian是Roy T. Fielding在他的博士论文第五章中定义的REST软件架构风格的狂热支持者。论文在UCIrvine。你可以在rest - discussion邮件列表中找到野外的RESTifarians。但是要小心，RESTifarians在讨论休息的细节时可能是极其细致的，正如我最近在参与列表时所了解到的。🙂</p>\n</blockquote>\n<p>太多的事情都是不好的。</p>\n<p>我们需要一点<strong>实用主义</strong>才能做出好的应用程序和服务。了解和理解一种理论很重要，但是该理论的实现是区分不良与良好与卓越应用的区别。所以要聪明，要牢记最终用户。</p>\n<p>因此，让我们走一些使API变得“光彩”的重要点，使用户的生活变得更加轻松。</p>\n<h2 id=\"抽象与具体API\"><a href=\"#抽象与具体API\" class=\"headerlink\" title=\"抽象与具体API\"></a>抽象与具体API</h2><p>在开发软件时，我们经常使用抽象和多态来获取大多数应用程序。我们想重用尽可能多的代码。</p>\n<p>那么我们也应该这样写我们的API吗？</p>\n<p>好吧，API并非完全如此。对于REST API，<strong>具体要比abstract好</strong>。你能猜出为什么吗？</p>\n<p>让我向您展示一些示例：</p>\n<p>让我们看两个API版本。它是最好有有一个的API <code>/entities</code>，或者有一个API <code>/owners</code>，<code>/blogs</code>并 <code>/blogposts</code> 分别？</p>\n<p>作为开发人员，哪一个对您更具描述性？您想使用哪个API？</p>\n<p>我总是会选择第二个。</p>\n<h2 id=\"URI格式（名词，不是动词）。正确网址与错误网址示例\"><a href=\"#URI格式（名词，不是动词）。正确网址与错误网址示例\" class=\"headerlink\" title=\"URI格式（名词，不是动词）。正确网址与错误网址示例\"></a><strong>URI格式（名词，不是动词）。正确网址与错误网址示例</strong></h2><p>这是另一种REST API最佳实践。您应该如何格式化端点？</p>\n<p>如果使用软件开发方法，您将得到如下所示的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/getAllBlogPosts</span><br><span class=\"line\">/updateBlogPost/12</span><br><span class=\"line\">/deleteBlogPost/12</span><br><span class=\"line\">/getAuthorById/3</span><br><span class=\"line\">/deleteAuthor/3</span><br><span class=\"line\">/updateAuthor/3</span><br></pre></td></tr></table></figure>\n\n<p>您明白了……会有很多端点，每个端点都在做其他事情。有一个更好的系统可以解决这些问题。</p>\n<p>将资源视为名词，将HTTP方法视为动词。如果这样做，最终将得到如下结果：</p>\n<p><code>GET /blogposts</code> –获取所有博客文章</p>\n<p><code>GET /blogposts/12</code> –获取ID为12的博客文章</p>\n<p><code>POST /blogposts</code> –添加新的博客文章并返回详细信息</p>\n<p><code>DELETE /blogposts/12</code> –删除ID为12的博客文章</p>\n<p><code>GET /authors/3/blogposts</code> –获取ID为3的作者的所有博客文章</p>\n<p>这是创建API的更简洁，更精确的方法。对于最终用户而言，这是显而易见的，并且有一种解决方法。</p>\n<p>通过使用单数而不是复数来表示资源名称，可以使其更加简洁。那取决于你。</p>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a><strong>错误处理</strong></h2><p>API构建的另一个重要方面。有几种处理错误的好方法。</p>\n<p>让我们看看顶级狗如何做到这一点：</p>\n<p><strong>推特：</strong></p>\n<ul>\n<li><p>请求： <code>GET https://api.twitter.com/1.1/account/settings.json</code></p>\n</li>\n<li><p>响应：状态码400</p>\n<p>Twitter response</p>\n</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;errors&quot;:[&#123;&quot;code&quot;:215,&quot;message&quot;:&quot;Bad Authentication data.&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Twitter为您提供状态代码和错误代码，并简要描述了所发生错误的性质。他们让您在“ <a href=\"https://developer.twitter.com/en/docs/basics/response-codes\" target=\"_blank\" rel=\"noopener\">响应代码”</a>页面上查找代码。</p>\n<p><strong>脸书：</strong></p>\n<ul>\n<li><p>请求： <code>GET https://graph.facebook.com/me/photos</code></p>\n</li>\n<li><p>响应：状态码400</p>\n<p>Facebook Response </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  &quot;error&quot;: &#123;   &quot;message&quot;: &quot;An active access token must be used to query information about the current user.&quot;,   &quot;type&quot;: &quot;OAuthException&quot;,   &quot;code&quot;: 2500,   &quot;fbtrace_id&quot;: &quot;DzkTMkgIA7V&quot;  &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<p>Facebook为您提供了更具描述性的错误消息。</p>\n<p><strong>特威里奥：</strong></p>\n<ul>\n<li><p>请求： <code>GET https://api.twilio.com/2010-04-01/Accounts/1234/IncomingPhoneNumbers/1234</code></p>\n</li>\n<li><p>响应：状态码404 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;&lt;TwilioResponse&gt;  &lt;RestException&gt;    &lt;Code&gt;20404&lt;/Code&gt;    &lt;Message&gt;The requested resource /2010-04-01/Accounts/1234/IncomingPhoneNumbers/1234 was not found&lt;/Message&gt;    &lt;MoreInfo&gt;https://www.twilio.com/docs/errors/20404&lt;/MoreInfo&gt;    &lt;Status&gt;404&lt;/Status&gt;  &lt;/RestException&gt;&lt;/TwilioResponse&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<p>Twilio默认为您提供XML响应，并提供指向文档的链接，您可以在其中找到错误的详细信息。</p>\n<p>如您所见，错误处理的方法因实现而异。</p>\n<p>重要的是 <strong>不要让REST API的用户“挂断”</strong>，不知道发生了什么，或者漫无目的地在StackOverflow的浪费中徘徊，寻找解释。</p>\n<h2 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a><strong>状态码</strong></h2><p>在设计REST API时，我们通过使用<a href=\"https://code-maze.com/the-http-reference/#statuscodes\" target=\"_blank\" rel=\"noopener\">HTTP状态代码</a>与API用户进行通信 。状态代码很多，描述了多种可能的响应。</p>\n<p>但是，我们应该使用多少？ <strong>我们在每种情况下都应该有严格的状态码吗？</strong></p>\n<p>就像生活中的许多事情一样， <a href=\"https://en.wikipedia.org/wiki/KISS_principle\" target=\"_blank\" rel=\"noopener\">KISS原则</a> 也适用于这里。那里有70多个状态代码。你内心了解他们吗？潜在的API用户会全部了解它们，还是会再次使用Google搜索？</p>\n<p>大多数开发人员都熟悉最常见的状态代码：</p>\n<ul>\n<li><code>**200 OK**</code></li>\n<li><code>**400 Bad Request**</code></li>\n<li><code>**500 Internal Server Error**</code></li>\n</ul>\n<p>从这三个开始，您可以涵盖REST API的大多数功能。</p>\n<p>其他常见的代码包括：</p>\n<ul>\n<li><code>**201 Created**</code></li>\n<li><code>**204 No Content**</code></li>\n<li><code>**401 Unauthorized**</code></li>\n<li><code>**403 Forbidden**</code></li>\n<li><code>**404 Not Found**</code></li>\n</ul>\n<p>我们可以使用它们来帮助用户快速找出结果。如果您感觉到状态代码的描述性不如我们在“错误处理”部分中讨论的那样，则可能应该包含某种消息。再一次，我们需要务实，通过使用 <strong>数量有限的代码</strong> 和描述性消息来帮助用户。</p>\n<p>您可以在<a href=\"https://code-maze.com/the-http-reference\" target=\"_blank\" rel=\"noopener\">此处</a>找到完整的HTTP状态代码列表，以及<a href=\"https://code-maze.com/the-http-reference\" target=\"_blank\" rel=\"noopener\">在CodeMaze上总结的</a>其他有用的HTTP内容 。</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a><strong>安全</strong></h2><p>关于<a href=\"https://blog.restcase.com/top-5-rest-api-security-guidelines/\" target=\"_blank\" rel=\"noopener\">REST API安全的</a>说法不多，因为 <strong>REST不处理安全问题</strong>。它依赖于诸如<a href=\"https://code-maze.com/http-series-part-4/\" target=\"_blank\" rel=\"noopener\">基本身份验证或摘要身份验证之</a>类的标准HTTP机制 。</p>\n<p>每个请求都应 <strong>通过HTTPS进行</strong>。</p>\n<p>有很多技巧可以提高REST API的安全性，但是由于REST的无状态性，因此在实施它们时必须谨慎。记住最后一个请求的状态超出了窗口，<strong>应该</strong>在 <strong>客户端存储和验证状态。</strong></p>\n<p><strong>时间戳记和日志记录</strong> 请求也可以有所帮助。</p>\n<p>关于这个话题还有很多要说的，但这超出了本文的范围。我们有一个不错的职位<strong><a href=\"https://code-maze.com/http-series-part-5/\" target=\"_blank\" rel=\"noopener\">HTTP安全</a></strong> 在这里CodeMaze如果您想了解更多关于这一点。 </p>\n<h2 id=\"REST-API版本控制\"><a href=\"#REST-API版本控制\" class=\"headerlink\" title=\"REST API版本控制\"></a><strong>REST API版本控制</strong></h2><p>您已经编写了REST API，它已经非常成功，许多人已经使用它并对此感到满意。但是，您拥有的多汁的新功能会破坏系统的其他部分。重大变化。</p>\n<p>不用担心，有解决方案！</p>\n<p>在开始制作您的API之前，我们可以通过在端点之前加上API版本来对其进行版本控制：<br><code>https://api.example.com/v1/authors/2/blogposts/13</code></p>\n<p>这样，只要API发生重大更改，我们就可以始终增加API版本号（例如v2，v3…）。这也向用户发出信号，表明已发生了翻天覆地的变化，在使用新版本时，请务必小心。</p>\n<h2 id=\"文件的重要性\"><a href=\"#文件的重要性\" class=\"headerlink\" title=\"文件的重要性\"></a><strong>文件的重要性</strong></h2><p>这是不言而喻的。您可能是世界上最好的API设计人员，但是 <strong>如果没有文档，您的API就像死了一样。</strong></p>\n<p><strong>正确的文档</strong> 对于每个软件产品和Web服务都是<strong>必不可少</strong>的。</p>\n<p>我们可以通过保持一致并使用清晰和描述性的语法来帮助用户。但是，好的文档页面并没有真正的替代品。</p>\n<p>一些很好的例子：</p>\n<p><a href=\"https://www.twilio.com/docs/api/rest/\" target=\"_blank\" rel=\"noopener\">https://www.twilio.com/docs/api/rest/</a></p>\n<p><a href=\"https://developers.facebook.com/docs/\" target=\"_blank\" rel=\"noopener\">https://developers.facebook.com/docs/</a></p>\n<p><a href=\"https://developers.google.com/maps/documentation/\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/maps/documentation/</a></p>\n<p>还有很多其他…</p>\n<p>有许多工具可以帮助您记录您的API，但是不要忘记让人参与其中，只有一个人可以正确地理解另一个人。至少现在是这样(看着你)。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>我们讨论了REST API构建的许多概念，并介绍了一些顶级REST API最佳实践。在一次提供这些API时，您可能会觉得有些奇怪或难以接受，但是请尝试自己创建REST API。并尝试实现一些您在这里学到的REST API最佳实践。 </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用REST-API-最佳实践简述\"><a href=\"#使用REST-API-最佳实践简述\" class=\"headerlink\" title=\"使用REST API 最佳实践简述\"></a>使用REST API 最佳实践简述</h1><p>Facebook，Google，Github，Netflix，Amazon和Twitter等许多巨头都拥有自己的REST（ful）API，您可以访问它们来获取甚至写入数据。</p>\n<p>但是，为什么所有都需要REST？</p>\n<p>那样好吗，为什么如此盛行？</p>\n<p>当然，这不是传达消息的唯一方法吗？</p>\n<p>REST和HTTP有什么区别？</p>\n<p>好吧，事实证明<strong>REST非常灵活，并且与</strong> Internet所基于的主要协议<strong>HTTP兼容</strong>。由于它是一种架构风格而不是标准，因此它<strong>提供了实现各种设计最佳实践的大量自由</strong>。以及听说它与语言无关？你一定觉得它很棒吧。</p>\n<p>在此博客文章中，我们的目标是尽可能清楚地解释REST，以便您可以清楚地了解何时以及如何使用REST，以及它的本质。</p>\n<p>我们将介绍一些基础知识和定义，并展示一些<strong>REST API最佳实践</strong>。这应该为您提供了以您喜欢的任何编码语言实现REST API所需的全部知识。</p>\n<p>如果您对HTTP不太熟悉，建议您阅读我们的<a href=\"https://code-maze.com/http-series/\" target=\"_blank\" rel=\"noopener\">HTTP系列文章</a>，或者至少阅读其中的<a href=\"https://code-maze.com/http-series-part-1/\" target=\"_blank\" rel=\"noopener\">第1部分</a>，这样您可以更轻松地理解这些资料。</p>\n<p>因此，在这篇文章中，我们将讨论：</p>\n<p><strong>关于REST：</strong></p>\n<ul>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#whatisrest\" target=\"_blank\" rel=\"noopener\">什么是REST？</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#restbound\" target=\"_blank\" rel=\"noopener\">REST是否绑定到HTTP？</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#hateoas\" target=\"_blank\" rel=\"noopener\">REST和HATEOAS支持</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#whatdoesitmean\" target=\"_blank\" rel=\"noopener\">RESTful API是什么意思？</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#restafarian\" target=\"_blank\" rel=\"noopener\">REST过多又称为RESTafarian综合征</a></li>\n</ul>\n<p><strong>REST API最佳做法：</strong></p>\n<ul>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#abstractvsconcrete\" target=\"_blank\" rel=\"noopener\">抽象与具体API</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#urlformat\" target=\"_blank\" rel=\"noopener\">URI格式（名词，不是动词）。正确网址与错误网址示例</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#errorhandling\" target=\"_blank\" rel=\"noopener\">错误处理</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#statuscodes\" target=\"_blank\" rel=\"noopener\">状态码</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#security\" target=\"_blank\" rel=\"noopener\">安全</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#versioning\" target=\"_blank\" rel=\"noopener\">REST API版本控制</a></li>\n<li><a href=\"https://code-maze.com/top-rest-api-best-practices/#documentation\" target=\"_blank\" rel=\"noopener\">文件的重要性</a></li>\n</ul>\n<h2 id=\"那么REST本质上是什么？\"><a href=\"#那么REST本质上是什么？\" class=\"headerlink\" title=\"那么REST本质上是什么？\"></a>那么REST本质上是什么？</h2><p>REST（代表性状态转移）是<a href=\"https://en.wikipedia.org/wiki/Roy_Fielding\" target=\"_blank\" rel=\"noopener\">Roy Fielding</a>在其博士学位中创立的一种建筑风格。UC Irvine的论文“ <a href=\"https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\" target=\"_blank\" rel=\"noopener\">体系结构样式和基于网络的软件体系结构设计</a> ”。 他与HTTP 1.1同步提出了这种观点。</p>\n<p>我们主要将REST用作<strong>在万维网上的计算机系统之间进行通信的</strong>一种方式。</p>\n<h2 id=\"REST是否绑定到HTTP？\"><a href=\"#REST是否绑定到HTTP？\" class=\"headerlink\" title=\"REST是否绑定到HTTP？\"></a>REST是否绑定到HTTP？</h2><p>根据定义，似乎与Http强制绑定？其实并非如此。尽管您可以将其他一些应用程序协议与REST一起使用，但是在实现REST时，<a href=\"https://code-maze.com/http-series/\" target=\"_blank\" rel=\"noopener\">HTTP</a>仍然是应用程序协议中无可争议的冠军。</p>\n<h2 id=\"REST和HATEOAS支持\"><a href=\"#REST和HATEOAS支持\" class=\"headerlink\" title=\"REST和HATEOAS支持\"></a>REST和HATEOAS支持</h2><p><strong>作为应用程序状态引擎的</strong> HATEOAS或<strong>超媒体</strong> 是每个可扩展且灵活的REST API的重要功能。</p>\n<p>该<a href=\"https://en.wikipedia.org/wiki/HATEOAS\" target=\"_blank\" rel=\"noopener\">HATEOAS</a>约束建议，客户端和服务器通信完全采用了<a href=\"https://en.wikipedia.org/wiki/Hypermedia\" target=\"_blank\" rel=\"noopener\">超媒体</a>。</p>\n<p>使用超媒体有几个优点：</p>\n<ul>\n<li>使API设计人员能够在每个响应中包括他们所能提供的一切，以正确地提供一件事以及与相关端点的超媒体链接，从而使设计脱钩</li>\n<li>帮助API更优雅地发展和成熟</li>\n<li>为用户提供更深入地探索API的方法</li>\n</ul>\n<p>因此很明显，HATEOAS在<strong>设计时考虑了耐用性</strong>。</p>\n<p>GitHub的工作方式如下： </p>\n<p><code>GET https://api.github.com/users/codemazeblog</code></p>\n<p>响应：  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"login\"</span>: <span class=\"string\">\"CodeMazeBlog\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"id\"</span>: <span class=\"number\">29179238</span>,</span><br><span class=\"line\">  <span class=\"string\">\"avatar_url\"</span>: <span class=\"string\">\"https://avatars0.githubusercontent.com/u/29179238?v=4\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"gravatar_id\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"html_url\"</span>: <span class=\"string\">\"https://github.com/CodeMazeBlog\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"followers_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/followers\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"following_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/following&#123;/other_user&#125;\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"gists_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/gists&#123;/gist_id&#125;\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"starred_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/starred&#123;/owner&#125;&#123;/repo&#125;\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"subscriptions_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/subscriptions\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"organizations_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/orgs\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"repos_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/repos\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"events_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/events&#123;/privacy&#125;\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"received_events_url\"</span>: <span class=\"string\">\"https://api.github.com/users/CodeMazeBlog/received_events\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"type\"</span>: <span class=\"string\">\"User\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"site_admin\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Code Maze\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"company\"</span>: <span class=\"string\">\"Code Maze\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"blog\"</span>: <span class=\"string\">\"https://code-maze.com\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"bio\"</span>: <span class=\"string\">\"A practical programmers' resource.\"</span>,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如您所见，除了客户端请求的关键信息之外，您还可以在响应中找到一堆相关的超媒体链接，这些链接将您带到您可以自由浏览的API的其他部分。</p>\n<h2 id=\"RESTful-API是什么意思？\"><a href=\"#RESTful-API是什么意思？\" class=\"headerlink\" title=\"RESTful API是什么意思？\"></a>RESTful API是什么意思？</h2><p>“ RESTful”意味着一些功能：</p>\n<ul>\n<li><strong><a href=\"https://code-maze.com/http-series-part-2\" target=\"_blank\" rel=\"noopener\">客户端-服务器体系结构</a>：</strong>完整的服务由作为整个系统前端的“客户端”和作为后端的“服务器”组成</li>\n<li><strong>无状态：</strong>服务器不应在不同请求之间保存任何状态。会话状态完全由客户负责。按照REST定义： <strong><em>所有REST交互都是无状态的。也就是说，每个请求都包含连接器理解该请求所需的所有信息，而与之前的任何请求无关。（<a href=\"https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm\" target=\"_blank\" rel=\"noopener\">Roy的论文ch.5.2.2</a>）\\</em></strong></li>\n<li><strong><a href=\"https://code-maze.com/http-series-part-2/#caching\" target=\"_blank\" rel=\"noopener\">可缓存的</a>：</strong>客户端应该能够将响应存储在缓存中以提高性能</li>\n</ul>\n<p>因此，RESTful API是一项遵循这些规则的服务（希望如此），并使用<a href=\"https://code-maze.com/the-http-reference/#requestmethods\" target=\"_blank\" rel=\"noopener\">HTTP方法</a>来操纵资源集。</p>\n<p>但是为什么我们需要或使用RESTful API？</p>\n<p>因为它们为我们提供了一种简单，灵活和可扩展的方式来制作可通过Internet进行通信的分布式应用程序。</p>\n<h2 id=\"我们可以拥有更多的REST方法吗？\"><a href=\"#我们可以拥有更多的REST方法吗？\" class=\"headerlink\" title=\"我们可以拥有更多的REST方法吗？\"></a>我们可以拥有更多的REST方法吗？</h2><p>是的，你猜对了。是的，我们可以🙂</p>\n<p>正如<a href=\"http://mikeschinkel.com/about/\" target=\"_blank\" rel=\"noopener\">Mike Schinkel</a>定义的那样，对于狂热地遵循REST的人们来说甚至还有一个短语 <a href=\"http://mikeschinkel.com/about/\" target=\"_blank\" rel=\"noopener\">。</a></p>\n<blockquote>\n<p>RESTifarian是Roy T. Fielding在他的博士论文第五章中定义的REST软件架构风格的狂热支持者。论文在UCIrvine。你可以在rest - discussion邮件列表中找到野外的RESTifarians。但是要小心，RESTifarians在讨论休息的细节时可能是极其细致的，正如我最近在参与列表时所了解到的。🙂</p>\n</blockquote>\n<p>太多的事情都是不好的。</p>\n<p>我们需要一点<strong>实用主义</strong>才能做出好的应用程序和服务。了解和理解一种理论很重要，但是该理论的实现是区分不良与良好与卓越应用的区别。所以要聪明，要牢记最终用户。</p>\n<p>因此，让我们走一些使API变得“光彩”的重要点，使用户的生活变得更加轻松。</p>\n<h2 id=\"抽象与具体API\"><a href=\"#抽象与具体API\" class=\"headerlink\" title=\"抽象与具体API\"></a>抽象与具体API</h2><p>在开发软件时，我们经常使用抽象和多态来获取大多数应用程序。我们想重用尽可能多的代码。</p>\n<p>那么我们也应该这样写我们的API吗？</p>\n<p>好吧，API并非完全如此。对于REST API，<strong>具体要比abstract好</strong>。你能猜出为什么吗？</p>\n<p>让我向您展示一些示例：</p>\n<p>让我们看两个API版本。它是最好有有一个的API <code>/entities</code>，或者有一个API <code>/owners</code>，<code>/blogs</code>并 <code>/blogposts</code> 分别？</p>\n<p>作为开发人员，哪一个对您更具描述性？您想使用哪个API？</p>\n<p>我总是会选择第二个。</p>\n<h2 id=\"URI格式（名词，不是动词）。正确网址与错误网址示例\"><a href=\"#URI格式（名词，不是动词）。正确网址与错误网址示例\" class=\"headerlink\" title=\"URI格式（名词，不是动词）。正确网址与错误网址示例\"></a><strong>URI格式（名词，不是动词）。正确网址与错误网址示例</strong></h2><p>这是另一种REST API最佳实践。您应该如何格式化端点？</p>\n<p>如果使用软件开发方法，您将得到如下所示的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/getAllBlogPosts</span><br><span class=\"line\">/updateBlogPost/12</span><br><span class=\"line\">/deleteBlogPost/12</span><br><span class=\"line\">/getAuthorById/3</span><br><span class=\"line\">/deleteAuthor/3</span><br><span class=\"line\">/updateAuthor/3</span><br></pre></td></tr></table></figure>\n\n<p>您明白了……会有很多端点，每个端点都在做其他事情。有一个更好的系统可以解决这些问题。</p>\n<p>将资源视为名词，将HTTP方法视为动词。如果这样做，最终将得到如下结果：</p>\n<p><code>GET /blogposts</code> –获取所有博客文章</p>\n<p><code>GET /blogposts/12</code> –获取ID为12的博客文章</p>\n<p><code>POST /blogposts</code> –添加新的博客文章并返回详细信息</p>\n<p><code>DELETE /blogposts/12</code> –删除ID为12的博客文章</p>\n<p><code>GET /authors/3/blogposts</code> –获取ID为3的作者的所有博客文章</p>\n<p>这是创建API的更简洁，更精确的方法。对于最终用户而言，这是显而易见的，并且有一种解决方法。</p>\n<p>通过使用单数而不是复数来表示资源名称，可以使其更加简洁。那取决于你。</p>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a><strong>错误处理</strong></h2><p>API构建的另一个重要方面。有几种处理错误的好方法。</p>\n<p>让我们看看顶级狗如何做到这一点：</p>\n<p><strong>推特：</strong></p>\n<ul>\n<li><p>请求： <code>GET https://api.twitter.com/1.1/account/settings.json</code></p>\n</li>\n<li><p>响应：状态码400</p>\n<p>Twitter response</p>\n</li>\n</ul>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;errors&quot;:[&#123;&quot;code&quot;:215,&quot;message&quot;:&quot;Bad Authentication data.&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Twitter为您提供状态代码和错误代码，并简要描述了所发生错误的性质。他们让您在“ <a href=\"https://developer.twitter.com/en/docs/basics/response-codes\" target=\"_blank\" rel=\"noopener\">响应代码”</a>页面上查找代码。</p>\n<p><strong>脸书：</strong></p>\n<ul>\n<li><p>请求： <code>GET https://graph.facebook.com/me/photos</code></p>\n</li>\n<li><p>响应：状态码400</p>\n<p>Facebook Response </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  &quot;error&quot;: &#123;   &quot;message&quot;: &quot;An active access token must be used to query information about the current user.&quot;,   &quot;type&quot;: &quot;OAuthException&quot;,   &quot;code&quot;: 2500,   &quot;fbtrace_id&quot;: &quot;DzkTMkgIA7V&quot;  &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<p>Facebook为您提供了更具描述性的错误消息。</p>\n<p><strong>特威里奥：</strong></p>\n<ul>\n<li><p>请求： <code>GET https://api.twilio.com/2010-04-01/Accounts/1234/IncomingPhoneNumbers/1234</code></p>\n</li>\n<li><p>响应：状态码404 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;&lt;TwilioResponse&gt;  &lt;RestException&gt;    &lt;Code&gt;20404&lt;/Code&gt;    &lt;Message&gt;The requested resource /2010-04-01/Accounts/1234/IncomingPhoneNumbers/1234 was not found&lt;/Message&gt;    &lt;MoreInfo&gt;https://www.twilio.com/docs/errors/20404&lt;/MoreInfo&gt;    &lt;Status&gt;404&lt;/Status&gt;  &lt;/RestException&gt;&lt;/TwilioResponse&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<p>Twilio默认为您提供XML响应，并提供指向文档的链接，您可以在其中找到错误的详细信息。</p>\n<p>如您所见，错误处理的方法因实现而异。</p>\n<p>重要的是 <strong>不要让REST API的用户“挂断”</strong>，不知道发生了什么，或者漫无目的地在StackOverflow的浪费中徘徊，寻找解释。</p>\n<h2 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a><strong>状态码</strong></h2><p>在设计REST API时，我们通过使用<a href=\"https://code-maze.com/the-http-reference/#statuscodes\" target=\"_blank\" rel=\"noopener\">HTTP状态代码</a>与API用户进行通信 。状态代码很多，描述了多种可能的响应。</p>\n<p>但是，我们应该使用多少？ <strong>我们在每种情况下都应该有严格的状态码吗？</strong></p>\n<p>就像生活中的许多事情一样， <a href=\"https://en.wikipedia.org/wiki/KISS_principle\" target=\"_blank\" rel=\"noopener\">KISS原则</a> 也适用于这里。那里有70多个状态代码。你内心了解他们吗？潜在的API用户会全部了解它们，还是会再次使用Google搜索？</p>\n<p>大多数开发人员都熟悉最常见的状态代码：</p>\n<ul>\n<li><code>**200 OK**</code></li>\n<li><code>**400 Bad Request**</code></li>\n<li><code>**500 Internal Server Error**</code></li>\n</ul>\n<p>从这三个开始，您可以涵盖REST API的大多数功能。</p>\n<p>其他常见的代码包括：</p>\n<ul>\n<li><code>**201 Created**</code></li>\n<li><code>**204 No Content**</code></li>\n<li><code>**401 Unauthorized**</code></li>\n<li><code>**403 Forbidden**</code></li>\n<li><code>**404 Not Found**</code></li>\n</ul>\n<p>我们可以使用它们来帮助用户快速找出结果。如果您感觉到状态代码的描述性不如我们在“错误处理”部分中讨论的那样，则可能应该包含某种消息。再一次，我们需要务实，通过使用 <strong>数量有限的代码</strong> 和描述性消息来帮助用户。</p>\n<p>您可以在<a href=\"https://code-maze.com/the-http-reference\" target=\"_blank\" rel=\"noopener\">此处</a>找到完整的HTTP状态代码列表，以及<a href=\"https://code-maze.com/the-http-reference\" target=\"_blank\" rel=\"noopener\">在CodeMaze上总结的</a>其他有用的HTTP内容 。</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a><strong>安全</strong></h2><p>关于<a href=\"https://blog.restcase.com/top-5-rest-api-security-guidelines/\" target=\"_blank\" rel=\"noopener\">REST API安全的</a>说法不多，因为 <strong>REST不处理安全问题</strong>。它依赖于诸如<a href=\"https://code-maze.com/http-series-part-4/\" target=\"_blank\" rel=\"noopener\">基本身份验证或摘要身份验证之</a>类的标准HTTP机制 。</p>\n<p>每个请求都应 <strong>通过HTTPS进行</strong>。</p>\n<p>有很多技巧可以提高REST API的安全性，但是由于REST的无状态性，因此在实施它们时必须谨慎。记住最后一个请求的状态超出了窗口，<strong>应该</strong>在 <strong>客户端存储和验证状态。</strong></p>\n<p><strong>时间戳记和日志记录</strong> 请求也可以有所帮助。</p>\n<p>关于这个话题还有很多要说的，但这超出了本文的范围。我们有一个不错的职位<strong><a href=\"https://code-maze.com/http-series-part-5/\" target=\"_blank\" rel=\"noopener\">HTTP安全</a></strong> 在这里CodeMaze如果您想了解更多关于这一点。 </p>\n<h2 id=\"REST-API版本控制\"><a href=\"#REST-API版本控制\" class=\"headerlink\" title=\"REST API版本控制\"></a><strong>REST API版本控制</strong></h2><p>您已经编写了REST API，它已经非常成功，许多人已经使用它并对此感到满意。但是，您拥有的多汁的新功能会破坏系统的其他部分。重大变化。</p>\n<p>不用担心，有解决方案！</p>\n<p>在开始制作您的API之前，我们可以通过在端点之前加上API版本来对其进行版本控制：<br><code>https://api.example.com/v1/authors/2/blogposts/13</code></p>\n<p>这样，只要API发生重大更改，我们就可以始终增加API版本号（例如v2，v3…）。这也向用户发出信号，表明已发生了翻天覆地的变化，在使用新版本时，请务必小心。</p>\n<h2 id=\"文件的重要性\"><a href=\"#文件的重要性\" class=\"headerlink\" title=\"文件的重要性\"></a><strong>文件的重要性</strong></h2><p>这是不言而喻的。您可能是世界上最好的API设计人员，但是 <strong>如果没有文档，您的API就像死了一样。</strong></p>\n<p><strong>正确的文档</strong> 对于每个软件产品和Web服务都是<strong>必不可少</strong>的。</p>\n<p>我们可以通过保持一致并使用清晰和描述性的语法来帮助用户。但是，好的文档页面并没有真正的替代品。</p>\n<p>一些很好的例子：</p>\n<p><a href=\"https://www.twilio.com/docs/api/rest/\" target=\"_blank\" rel=\"noopener\">https://www.twilio.com/docs/api/rest/</a></p>\n<p><a href=\"https://developers.facebook.com/docs/\" target=\"_blank\" rel=\"noopener\">https://developers.facebook.com/docs/</a></p>\n<p><a href=\"https://developers.google.com/maps/documentation/\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/maps/documentation/</a></p>\n<p>还有很多其他…</p>\n<p>有许多工具可以帮助您记录您的API，但是不要忘记让人参与其中，只有一个人可以正确地理解另一个人。至少现在是这样(看着你)。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>我们讨论了REST API构建的许多概念，并介绍了一些顶级REST API最佳实践。在一次提供这些API时，您可能会觉得有些奇怪或难以接受，但是请尝试自己创建REST API。并尝试实现一些您在这里学到的REST API最佳实践。 </p>\n"},{"title":"浅议gRPC的数据传输机制和WCF中的回调如何迁移到gRPC","date":"2019-12-01T10:28:00.000Z","author":"邹溪源","_content":"\n# 浅议Grpc的双向流和WCF中的回调机制\n\n## 一、引子\n\n如您所知，gRPC是目前比较常见的rpc框架，可以方便的作为服务与服务之间的通信基础设施，为构建微服务体系提供非常强有力的支持。\n\n而基于.NET Core的gRPC.NET 组件截至2019年11月30日的最新版本为2.25.0，该版本基于.netstrandard2.1进行，能够在.NET Core3.0上非常方便的实现，而且还能方便的迁移到基于.NET Core的windows桌面端开发体系。\n\n在本文中参考微软官方文档的示例，实现了一个从WCF 服务回调机制迁移到gRPC的过程，由于时间仓促，如有疏漏，还望批评指正。第一篇主要从技术层面来分析迁移流程，第二篇打算从业务和代码整洁性角度来思考这个问题。\n\n### 1.1、一些新东西：\n\n###### 1)、使用客户端工厂组件 Grpc.Net.ClientFactory ：\n\n在新版本中，可以使用  Grpc.Net.ClientFactory 支持以依赖注入的形式AddGrpcClient，将grpc客户端引入中，而无需每一次方法调用都使用 New 关键词进行创建。 这对客户端调用来说是极大的方便，毕竟随着.NET Core的普及，对于许多开发者来说，看到 New 关键词其实是很难受的啊。\n\n示例：\n\n以下代码以注册了 GreetClient ，并在发送 http 请求前，对请求头信息进行修改，添加 jwt 标识，以便发送带鉴权标识的请求。\n\n    serviceCollection.AddGrpcClient<GreeterClient>(\n        o =>\n        {\n        o.Address = new Uri(configuration[\"address\"]);\n        })\n        .AddHttpMessageHandler<JwtTokenHeader>();\n```\npublic class GreetImpl\n{\n\n    private readonly GreetClient _greetClient;\n    public GreetImpl(GreetClient greetClient)\n    {\n\n    }\n}\n```\n\nJwtTokenHeader中的代码段：\n\n```\nrequest.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", \"\");\nHttpResponseMessage response = await base.SendAsync(request, cancellationToken);\n```\n\n(以上示例代码仅供参考，不支持直接运行，且不支持.NET Framework。。) \n\n所以到此为止，我们在使用gRPC开发时，需要（能）使用的组件包括以下几种：\n\n- Grpc.AspNETCore包：这个包用于在asp.net core中提供grpc服务支持，在asp.netcore的服务端项目中以nuget安装grpc组件时，需要安装这个包。\n  - Google.Protobuf组件：Protobuf协议的实现。\n  - Grpc.AspNetCore.Server ：gRPC Asp.NET Core服务端核心库\n  - Grpc.Core.Api ：gRPC  Core API核心库\n- Grpc.Tools 包：内部封装了从proto文件生成gRPC服务端/客户端方法存根的流程。\n- Grpc.Core：gRPC核心包。\n- Grpc.Net.Client：gRPC 客户端实现核心库。\n  - Grpc.Core.Api ：gRPC  Core API核心库\n  - Grpc.Net.Common：gRPC 常用方法。\n- Grpc.Net.ClientFactory： gRPC客户端工厂方法。仅用于标准库2.1。\n\n###### 2)、其他特性：\n\n[来源]: https://github.com/grpc/grpc-dotnet/releases\n\n1. 支持  SerializationContext.GetBufferWriter 。\n2. 性能优化。 Optimize server's gRPC message serialization \n3. 验证协议降级。 Validate gRPC response protocol is not downgraded  \n4. New Grpc.AspNetCore.Server.Reflection package \n5. Log unsupported request content-type and protocol \n6. Major client performance improvement \n7. 修bug等。\n\n（ 当然，由于各种原因，未能亲测。）\n\n### 1.2、存在的缺陷\n\n- 目前的grpc的定位仅仅是一种数据传输机制，因此本身不包含负载均衡和服务管理的功能，一般会引入consul/etcd/zk等框架来实现服务治理。\n\n- 由于最新版本基于标准库2.1进行构建，因此该最新版本无法在.net fx上使用（因为.netframework最高仅支持到标准库2.0），不过只是新版本不支持，依然可以使用2.23.2的版本来实现。当然，以后也不会支持.netfx了。。\n\n## 二、gRPC通信方式\n\ngRPC提供了以下四种传输方式：\n\n查看\n\n[来源]: https://blog.csdn.net/weiwangchao_/article/details/82023191\n\n### 2.1、Simple RPC \n\n简单RPC 传输。一般的rpc方法调用，一次请求返回一个对象。适用于类似于以前的webapi请求调用的形式。\n\n```\n\trpc Hello (HelloRequest) returns (HelloReply); \n```\n\n### 2.1、Server-side streaming RPC  \n\n一种单向流，服务端流式RPC，客户端向服务端请求后，由服务端以流的形式返回多个结果。例如可以用于客户端需要从服务端获取流媒体文件。\n\n```\nrpc Subscribe (SubscribeRequest) returns (stream StockTickerUpdate);\n```\n\n### 2.3、Client-Side streaming RPC \n\n一种单向流，客户端单向流，客户端以流的形式传输多个请求，服务端返回一个响应结果。例如可以用于客户端需要向服务端推流的场景。\n\n```\nrpc Subscribe (stream SubscribeRequest) returns (StockTickerUpdate);\n```\n\n#### 2.4、 Bidirectional streaming RPC  \n\n 双向流式rpc。客户端和服务端均可以传输多个请求。例如可以用于游戏中的双向传输。\n\n```\nrpc Subscribe (stream SubscribeRequest) returns (stream StockTickerUpdate);\n```\n\n总之，看起来gRPC能够实现目前所能设想的大部分场景，因此也被视为是古老的rpc框架 wcf ( Windows Communication Foundation )的替代者，官方专门编写了一本电子书，用来给需要从 wcf 转 gRPC的开发者提供指引。\n\n具体地址为： https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/ \n\n除此之外，本人还看到了一些外网作者使用grpc 来移植 wcf的一些博客。\n\n1、 https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/ \n\n2、https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/ \n\n这两篇博客的作者在.NET Core中使用了WCF，根据作者的说法，在.NET Core2.0中还能使用，但是随着3.0的发布，他已经不再使用WCF了，而是改用了gRPC。\n\n## 三、WCF的通信方式\n\n### 3.1、简述\n\nWCF 是.NET框架中非常常用的一种组件，在.NET Framework 3.0时被引入，它整合了一些历史悠久的技术框架或通信机制，诸如 soap、remoting等。\n\n由于WCF技术体系庞大，学习路线也比较陡峭，能够驾驭的往往都是拥有多年工作经验的资深开发者，开发者们有时需针对各个阶段的内涵做深入的了解，才能开发对应的应用。\n\n由于本人使用WCF的经验尚浅（以前的项目用得少，充其量就用过Remoting），所以以下文字均来自网上现有资料的演绎，如有疏漏，敬请批评指正。\n\nWCF中，需要定义合约作为通信过程中的沟通方式。通信双方所遵循的通信方式，有合约绑定来制定；通信期间的安全性，有双方约定的安全性层级来定义。\n\n### 3.2、合约(Contract)\n\n合约（ Contract） 是WCF中最重要的基本概念，合约的使用分成两个部分，一部分是以接口形式体现的合约，一部分是基于合约派生出的实现类。\n\n合约分成四种类型：\n\n数据合约 （Data Contract） ：订定双方沟通时的数据格式。\n\n服务合约 （Service Contract） ：订定服务的定义。\n\n操作合约 （Operation Contract） ：订定服务提供的方法。在维基百科中翻译为营运合约。\n\n消息合约 （Message Contract） ：订定在通信期间改写消息内容的规范。\n\n在维基百科中，提供了一个如下的代码示例。\n\n```c#\nusing System.ServiceModel;\nnamespace Microsoft.ServiceModel.Samples\n{\n  [ServiceContract(Namespace = \"http://Microsoft.ServiceModel.Samples\")] // 服务合约\n  public interface ICalculator\n  {\n    [OperationContract] // 操作合约\n    double Add（double n1, double n2）;\n    [OperationContract] // 操作合约\n    double Subtract（double n1, double n2）;\n    [OperationContract] // 操作合约\n    double Multiply（double n1, double n2）;\n    [OperationContract] // 操作合约\n    double Divide（double n1, double n2）;\n  }\n}\n```\n\n### 3.3、协议绑定\n\nWCF支持HTTP\\TCP\\命名管道（ [Named Pipe](https://zh.wikipedia.org/w/index.php?title=Named_Pipe&action=edit&redlink=1) ）、MSMQ（ [MSMQ](https://zh.wikipedia.org/w/index.php?title=MSMQ&action=edit&redlink=1) ）、点对点TCP Peer-To-Peer TCP 等协议。其中对HTTP协议的支持分为:基本HTTP支持\\WS-HTTP支持；对TCP的协议也支NetTcpBinding\\NetPeerTcpBinding等通信方式。\n\n~~从这里可以看出，能够驾驭WCF技术的，基本上都是.NET开发领域的大牛，涉及到如此多的技术栈，实在是令人钦佩。~~\n\n由于WCF支持的协议很多，所以在进行WCF的客户端和服务端开发时，需要使用统一通信的协议，并且在编码以及格式上也要一致。\n\n维基百科提供了一个设置通信绑定的示例配置文件，当然，有时候无需通过配置文件来配置wcf的服务信息，通过代码创建也同样可行。\n\n```xml\n<configuration>\n  <system.serviceModel>\n    <!-- 接口协议 -->\n    <services>\n      <service name=\" CalculatorService\" >\n        <endpoint address=\"\" binding=\"wsHttpBinding\" bindingConfiguration=\"Binding1\"\n            contract=\"ICalculator\" />\n      </service>\n    </services>\n    <!-- 通信机制 -->\n    <bindings>\n      <wsHttpBinding>\n        <binding name=\"Binding1\">\n        </binding>\n      </wsHttpBinding>\n   </bindings>\n  </system.serviceModel>\n</configuration>\n```\n\n## 4、代码迁移\n\n### 4.1 迁移WCF的单工通信\n\n在WCF中，一般默认的契约形式为点对点的请求-响应方式。即客户端发出请求后，一直阻塞方法，指导服务端响应后，才能执行后面的代码。\n\n这种模式类似于gRPC中的简单传输机制，所以如果从WCF服务迁移到gRPC服务时，比较简单纯粹，只需根据对应的数据方法来订定我们的服务协议文件 proto 文件。 \n\n例如，大概是这样的：\n\n```c#\n[ServiceContract]\npublic interface ISimpleStockTickerCallback\n{\n    [OperationContract]\n    void HelloWorld(string msg);\n}\n```\n\n迁移到 gRpc中之后，就是这样的实现：\n\n```\nrpc Hello (HelloRequest) returns (google.protobuf.Empty);\nmessage HelloReply{\n\tstring msg=1;\n}\nmessage HelloRequest{\n\tstring msg=1; \n}\n```\n\n然后再在两端代码中实现方法即可。（由于代码过于简单，此处省略若干字）在引文3中，提供了非常完善的Wcf迁移到gRPC的代码流程，需要请自取。\n\n### 4.2 迁移WCF的双工通信\n\n#### 1、WCF中的双工通信示例\n\n在WCF中，双工（Duplex）通信很常用，在通信过程中，双方都可以向对方发送消息，使得很容易的就实现了服务端回调客户端。\n\n在这种模式下，客户端向服务端调用一个方法，然后在服务端回调客户端方法，可以理解为双方的位置发生了改变，此时的服务端变成了客户端，而客户端变成了服务端。\n\n如图所示。  \n\n- ![image-20191130140814321](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-mirgate-wcf-to-grpc/wcf-callback.png)\n\n代码如下：\n\n1. 服务端：\n\n   - 订定契约HelloCallback，用于处理回调的逻辑。\n   - 订定契约UserService 和 UserServiceImpl，并定义了一个 GetUser 方法。\n\n   ```c#\n   /// <summary>\n   /// 用于回调的Hello方法\n   /// </summary>\n   [ServiceContract]\n   public interface HelloCallback\n   {\n       [OperationContract(IsOneWay = true)]\n       void SayHelloworld(string msg);\n   }\n   /// <summary>\n   /// 用户服务,并回调客户端到HelloCallback\n   /// </summary>\n   [ServiceContract(SessionMode = SessionMode.Required, CallbackContract = typeof(HelloCallback))]\n   public interface UserService\n   {\n       [OperationContract(IsOneWay = true)]\n       void GetUser(string userName);\n   }\n   /// <summary>\n   /// 用户服务\n   /// </summary>\n   [ServiceBehavior(InstanceContextMode = InstanceContextMode.PerSession)]\n   public class UserServiceImpl : UserService\n   {\n       HelloCallback callback;\n       public void GetUser(string userName)\n       {\n           Console.Write(userName);\n           OperationContext context = OperationContext.Current;\n           callback = context.GetCallbackChannel<HelloCallback>();\n           callback.SayHelloworld($\"{userName}:hello\");\n       }\n   }\n   ```\n\n   启动服务端程序时，需要创建服务端的Host主机信息。\n\n   ```\n    private static ServiceHost StartUserService()\n    {\n        var host = new ServiceHost(typeof(UserServiceImpl));\n        var binding = new NetTcpBinding(SecurityMode.None);\n        host.AddServiceEndpoint(typeof(UserService), binding,\n        \"net.tcp://localhost:12384/userservice\");\n   \n       host.Open();\n       return host;\n   }\n   ```\n\n2. 客户端：\n\n   - 订定契约HelloCallback 和客户端的契约实现 HelloCallbackImpl 。\n\n     ```c#\n     /// <summary>\n     /// 回调Hello方法\n     /// </summary>\n     [ServiceContract]\n     public interface HelloCallback\n     {\n         [OperationContract(IsOneWay = true)]\n         void SayHelloworld(string msg);\n     }\n     public class HelloCallbackImpl : HelloCallback\n     {\n         public void SayHelloworld(string msg)\n         {\n         \tConsole.Write(msg);\n         }\n     }\n     ```\n\n     \n\n   - 订定契约UserService，用以保持和服务端的契约保持一致。\n\n     ```c#\n     /// <summary>\n     /// 用户服务\n     /// </summary>\n     [ServiceContract(CallbackContract = typeof(HelloCallback))]\n     public interface UserService\n     {\n         [OperationContract(IsOneWay = true)]\n         void GetUser(string userName);\n     }\n     ```\n\n     客户端启动时，连接到服务端。并发送GetUser方法。 \n\n```C#\nprivate static void GetUser(NetTcpBinding binding)\n        {\n            var address = new EndpointAddress(\"net.tcp://localhost:12384/userservice\");\n            var factory =\n                new DuplexChannelFactory<UserService>(typeof(HelloCallbackImpl), binding,\n                    address);\n            var context = new InstanceContext(new HelloCallbackImpl());\n            var server = factory.CreateChannel(context);\n\n            server.GetUser(\"zhangssan\");\n        }\n```\n\n实现效果如下：\n\n![image-20191130144237825](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-mirgate-wcf-to-grpc/result.png)\n\n这是一个典型的WCF双工通信的示例，在传统的.NET Framework开发中可能非常常见，但是该如何才能迁移到gRPC服务中呢？\n\n#### 2、gRPC中的代码实现\n\n- 流程说明\n\ngRPC中实现此双工通信，需要使用来自服务端的单向流来实现，但在gRPC中不能直接回调对应的方法，而是在服务端将流返回后，触发对应客户端代码中的方法来实现这个回调的流程。\n\n如图所示： \n\n![image-20191130214340416](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-mirgate-wcf-to-grpc/grpc-callback.png)\n\n- 代码实现流程：\n\n  1、定义 proto 协议文件\n\n  请求方法为getUser，并返回流。首先定义服务协议文件，命名为 userService.proto 文件。\n\n  ```c#\n  syntax = \"proto3\";\n  \n  option csharp_namespace = \"DulpexGrpcDemo\"; \n  \n  package DulpexGrpcDemo;\n  \n  service userService {\n    rpc GetUser (HelloRequest) returns (stream HelloReply);  \n    rpc GetTest (HelloRequest) returns (HelloReply);\n  }\n  message HelloReply{\n  \tstring msg=1;\n  }\n  message HelloRequest{\n  \tstring msg=1; \n  } \n  ```\n\n  2、服务端实现\n\n```c#\npublic class UserServiceImpl : userService.userServiceBase\n    {\n        public override async Task GetUser(HelloRequest request, IServerStreamWriter<HelloReply> responseStream, ServerCallContext context)\n        {\n            await DoSomeThing(request.Msg, (msg) => { responseStream.WriteAsync(new HelloReply { Msg = $\"{msg}:hello\" }); });\n\n        }\n        //处理回调逻辑\n        private async Task DoSomeThing(string msg, Action<string> action)\n        {\n            Console.WriteLine(msg);\n            action?.Invoke(msg);\n        }\n        public override Task<HelloReply> GetTest(HelloRequest request, ServerCallContext context)\n        {\n            Console.WriteLine(request.Msg);\n            return Task.FromResult(new HelloReply { Msg = $\"{request.Msg}:hello\" });\n        }\n    }\n```\n\n \t3、客户端实现（需要被调用的方法）\n\n```c#\npublic interface HelloCallback\n{\n    void SayHelloworld(string msg);\n}\npublic class HelloCallbackImpl : HelloCallback\n{\n   public void SayHelloworld(string msg)\n   {\n      Console.Write(msg);\n   }\n}\n```\n\n4、用户服务方法的实现\n\n```c#\npublic class UserServiceImpl\n {\n     private userService.userServiceClient userServiceClient;\n     private readonly HelloCallback _helloCallback;\n\n    public UserServiceImpl(userService.userServiceClient serviceClient, HelloCallback helloCallback)\n    {\n        userServiceClient = serviceClient;\n        _helloCallback = helloCallback;\n    }\n    public async Task GetUser()\n    {\n        AsyncServerStreamingCall<HelloReply> stream = userServiceClient.GetUser(new HelloRequest { Msg = \"张三\" });\n        await Helloworld(stream.ResponseStream);\n    }\n    async Task Helloworld(IAsyncStreamReader<HelloReply> stream)\n    {\n        await foreach (var update in stream.ReadAllAsync())\n        {\n            _helloCallback.SayHelloworld(update.Msg);\n        }\n    }\n}\n```\n\n5、客户端程序的入口\n\n```c#\nclass Program\n    {\n        static async Task Main(string[] args)\n        {\n            IServiceCollection servicesCollection = new ServiceCollection();\n            IConfiguration configuration = new ConfigurationBuilder()\n                        .SetBasePath(Directory.GetCurrentDirectory()).AddJsonFile(\"appsettings.json\", true, false).Build();\n\n        servicesCollection.AddGrpcClient<userService.userServiceClient>(\n           o =>\n            {\n                o.Address = new Uri(\"https://localhost:5001\");\n            });\n        servicesCollection.AddSingleton<UserServiceImpl>();\n        servicesCollection.AddSingleton<HelloCallback, HelloCallbackImpl>();\n        var userServiceImpl = servicesCollection.BuildServiceProvider().GetService<UserServiceImpl>();\n        await userServiceImpl.GetUser();\n        Console.ReadLine();\n    }\n\n}\n```\n\n当然，从这个示例中，可能会觉得有点奇怪，明明可以使用请求-响应的简单RPC模式，为什么要使用服务端的单向流来实现了？\n\n这种单向流中，客户端无需等待服务端执行方法执行完，而是由服务端完成后续流程后，再回调客户端的方法，使得流程变得简单清晰。\n\n在微软的官方文档（参考文献1）更适合介绍这个迁移过程的单向流的实现，通过实现服务端向客户端推流的形式来介绍，只是方法相对而言实现的逻辑比较多，而鄙人这个示例则剥离了与让我们理解服务端单向流流程无关的部分，使得流程看起来更简单。\n\n \n\n参考文献\n\n[1] 官方文档： https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/migrate-duplex-services \n\n[2] Jon Seeley的官方博客，如何迁移将wcf服务迁移到grpc：https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/ \n\n[3] Jon Seeley的官方博客，如何在.netcore中使用wcf：https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/ ","source":"_posts/技术/浅议Grpc的双向流和WCF中的回调机制.md","raw":"---\ntitle:  浅议gRPC的数据传输机制和WCF中的回调如何迁移到gRPC\ndate: 2019-12-1 18:28\ntags: 技术\nauthor: 邹溪源  \ncategories:\n  - 技术 \n---\n\n# 浅议Grpc的双向流和WCF中的回调机制\n\n## 一、引子\n\n如您所知，gRPC是目前比较常见的rpc框架，可以方便的作为服务与服务之间的通信基础设施，为构建微服务体系提供非常强有力的支持。\n\n而基于.NET Core的gRPC.NET 组件截至2019年11月30日的最新版本为2.25.0，该版本基于.netstrandard2.1进行，能够在.NET Core3.0上非常方便的实现，而且还能方便的迁移到基于.NET Core的windows桌面端开发体系。\n\n在本文中参考微软官方文档的示例，实现了一个从WCF 服务回调机制迁移到gRPC的过程，由于时间仓促，如有疏漏，还望批评指正。第一篇主要从技术层面来分析迁移流程，第二篇打算从业务和代码整洁性角度来思考这个问题。\n\n### 1.1、一些新东西：\n\n###### 1)、使用客户端工厂组件 Grpc.Net.ClientFactory ：\n\n在新版本中，可以使用  Grpc.Net.ClientFactory 支持以依赖注入的形式AddGrpcClient，将grpc客户端引入中，而无需每一次方法调用都使用 New 关键词进行创建。 这对客户端调用来说是极大的方便，毕竟随着.NET Core的普及，对于许多开发者来说，看到 New 关键词其实是很难受的啊。\n\n示例：\n\n以下代码以注册了 GreetClient ，并在发送 http 请求前，对请求头信息进行修改，添加 jwt 标识，以便发送带鉴权标识的请求。\n\n    serviceCollection.AddGrpcClient<GreeterClient>(\n        o =>\n        {\n        o.Address = new Uri(configuration[\"address\"]);\n        })\n        .AddHttpMessageHandler<JwtTokenHeader>();\n```\npublic class GreetImpl\n{\n\n    private readonly GreetClient _greetClient;\n    public GreetImpl(GreetClient greetClient)\n    {\n\n    }\n}\n```\n\nJwtTokenHeader中的代码段：\n\n```\nrequest.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", \"\");\nHttpResponseMessage response = await base.SendAsync(request, cancellationToken);\n```\n\n(以上示例代码仅供参考，不支持直接运行，且不支持.NET Framework。。) \n\n所以到此为止，我们在使用gRPC开发时，需要（能）使用的组件包括以下几种：\n\n- Grpc.AspNETCore包：这个包用于在asp.net core中提供grpc服务支持，在asp.netcore的服务端项目中以nuget安装grpc组件时，需要安装这个包。\n  - Google.Protobuf组件：Protobuf协议的实现。\n  - Grpc.AspNetCore.Server ：gRPC Asp.NET Core服务端核心库\n  - Grpc.Core.Api ：gRPC  Core API核心库\n- Grpc.Tools 包：内部封装了从proto文件生成gRPC服务端/客户端方法存根的流程。\n- Grpc.Core：gRPC核心包。\n- Grpc.Net.Client：gRPC 客户端实现核心库。\n  - Grpc.Core.Api ：gRPC  Core API核心库\n  - Grpc.Net.Common：gRPC 常用方法。\n- Grpc.Net.ClientFactory： gRPC客户端工厂方法。仅用于标准库2.1。\n\n###### 2)、其他特性：\n\n[来源]: https://github.com/grpc/grpc-dotnet/releases\n\n1. 支持  SerializationContext.GetBufferWriter 。\n2. 性能优化。 Optimize server's gRPC message serialization \n3. 验证协议降级。 Validate gRPC response protocol is not downgraded  \n4. New Grpc.AspNetCore.Server.Reflection package \n5. Log unsupported request content-type and protocol \n6. Major client performance improvement \n7. 修bug等。\n\n（ 当然，由于各种原因，未能亲测。）\n\n### 1.2、存在的缺陷\n\n- 目前的grpc的定位仅仅是一种数据传输机制，因此本身不包含负载均衡和服务管理的功能，一般会引入consul/etcd/zk等框架来实现服务治理。\n\n- 由于最新版本基于标准库2.1进行构建，因此该最新版本无法在.net fx上使用（因为.netframework最高仅支持到标准库2.0），不过只是新版本不支持，依然可以使用2.23.2的版本来实现。当然，以后也不会支持.netfx了。。\n\n## 二、gRPC通信方式\n\ngRPC提供了以下四种传输方式：\n\n查看\n\n[来源]: https://blog.csdn.net/weiwangchao_/article/details/82023191\n\n### 2.1、Simple RPC \n\n简单RPC 传输。一般的rpc方法调用，一次请求返回一个对象。适用于类似于以前的webapi请求调用的形式。\n\n```\n\trpc Hello (HelloRequest) returns (HelloReply); \n```\n\n### 2.1、Server-side streaming RPC  \n\n一种单向流，服务端流式RPC，客户端向服务端请求后，由服务端以流的形式返回多个结果。例如可以用于客户端需要从服务端获取流媒体文件。\n\n```\nrpc Subscribe (SubscribeRequest) returns (stream StockTickerUpdate);\n```\n\n### 2.3、Client-Side streaming RPC \n\n一种单向流，客户端单向流，客户端以流的形式传输多个请求，服务端返回一个响应结果。例如可以用于客户端需要向服务端推流的场景。\n\n```\nrpc Subscribe (stream SubscribeRequest) returns (StockTickerUpdate);\n```\n\n#### 2.4、 Bidirectional streaming RPC  \n\n 双向流式rpc。客户端和服务端均可以传输多个请求。例如可以用于游戏中的双向传输。\n\n```\nrpc Subscribe (stream SubscribeRequest) returns (stream StockTickerUpdate);\n```\n\n总之，看起来gRPC能够实现目前所能设想的大部分场景，因此也被视为是古老的rpc框架 wcf ( Windows Communication Foundation )的替代者，官方专门编写了一本电子书，用来给需要从 wcf 转 gRPC的开发者提供指引。\n\n具体地址为： https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/ \n\n除此之外，本人还看到了一些外网作者使用grpc 来移植 wcf的一些博客。\n\n1、 https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/ \n\n2、https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/ \n\n这两篇博客的作者在.NET Core中使用了WCF，根据作者的说法，在.NET Core2.0中还能使用，但是随着3.0的发布，他已经不再使用WCF了，而是改用了gRPC。\n\n## 三、WCF的通信方式\n\n### 3.1、简述\n\nWCF 是.NET框架中非常常用的一种组件，在.NET Framework 3.0时被引入，它整合了一些历史悠久的技术框架或通信机制，诸如 soap、remoting等。\n\n由于WCF技术体系庞大，学习路线也比较陡峭，能够驾驭的往往都是拥有多年工作经验的资深开发者，开发者们有时需针对各个阶段的内涵做深入的了解，才能开发对应的应用。\n\n由于本人使用WCF的经验尚浅（以前的项目用得少，充其量就用过Remoting），所以以下文字均来自网上现有资料的演绎，如有疏漏，敬请批评指正。\n\nWCF中，需要定义合约作为通信过程中的沟通方式。通信双方所遵循的通信方式，有合约绑定来制定；通信期间的安全性，有双方约定的安全性层级来定义。\n\n### 3.2、合约(Contract)\n\n合约（ Contract） 是WCF中最重要的基本概念，合约的使用分成两个部分，一部分是以接口形式体现的合约，一部分是基于合约派生出的实现类。\n\n合约分成四种类型：\n\n数据合约 （Data Contract） ：订定双方沟通时的数据格式。\n\n服务合约 （Service Contract） ：订定服务的定义。\n\n操作合约 （Operation Contract） ：订定服务提供的方法。在维基百科中翻译为营运合约。\n\n消息合约 （Message Contract） ：订定在通信期间改写消息内容的规范。\n\n在维基百科中，提供了一个如下的代码示例。\n\n```c#\nusing System.ServiceModel;\nnamespace Microsoft.ServiceModel.Samples\n{\n  [ServiceContract(Namespace = \"http://Microsoft.ServiceModel.Samples\")] // 服务合约\n  public interface ICalculator\n  {\n    [OperationContract] // 操作合约\n    double Add（double n1, double n2）;\n    [OperationContract] // 操作合约\n    double Subtract（double n1, double n2）;\n    [OperationContract] // 操作合约\n    double Multiply（double n1, double n2）;\n    [OperationContract] // 操作合约\n    double Divide（double n1, double n2）;\n  }\n}\n```\n\n### 3.3、协议绑定\n\nWCF支持HTTP\\TCP\\命名管道（ [Named Pipe](https://zh.wikipedia.org/w/index.php?title=Named_Pipe&action=edit&redlink=1) ）、MSMQ（ [MSMQ](https://zh.wikipedia.org/w/index.php?title=MSMQ&action=edit&redlink=1) ）、点对点TCP Peer-To-Peer TCP 等协议。其中对HTTP协议的支持分为:基本HTTP支持\\WS-HTTP支持；对TCP的协议也支NetTcpBinding\\NetPeerTcpBinding等通信方式。\n\n~~从这里可以看出，能够驾驭WCF技术的，基本上都是.NET开发领域的大牛，涉及到如此多的技术栈，实在是令人钦佩。~~\n\n由于WCF支持的协议很多，所以在进行WCF的客户端和服务端开发时，需要使用统一通信的协议，并且在编码以及格式上也要一致。\n\n维基百科提供了一个设置通信绑定的示例配置文件，当然，有时候无需通过配置文件来配置wcf的服务信息，通过代码创建也同样可行。\n\n```xml\n<configuration>\n  <system.serviceModel>\n    <!-- 接口协议 -->\n    <services>\n      <service name=\" CalculatorService\" >\n        <endpoint address=\"\" binding=\"wsHttpBinding\" bindingConfiguration=\"Binding1\"\n            contract=\"ICalculator\" />\n      </service>\n    </services>\n    <!-- 通信机制 -->\n    <bindings>\n      <wsHttpBinding>\n        <binding name=\"Binding1\">\n        </binding>\n      </wsHttpBinding>\n   </bindings>\n  </system.serviceModel>\n</configuration>\n```\n\n## 4、代码迁移\n\n### 4.1 迁移WCF的单工通信\n\n在WCF中，一般默认的契约形式为点对点的请求-响应方式。即客户端发出请求后，一直阻塞方法，指导服务端响应后，才能执行后面的代码。\n\n这种模式类似于gRPC中的简单传输机制，所以如果从WCF服务迁移到gRPC服务时，比较简单纯粹，只需根据对应的数据方法来订定我们的服务协议文件 proto 文件。 \n\n例如，大概是这样的：\n\n```c#\n[ServiceContract]\npublic interface ISimpleStockTickerCallback\n{\n    [OperationContract]\n    void HelloWorld(string msg);\n}\n```\n\n迁移到 gRpc中之后，就是这样的实现：\n\n```\nrpc Hello (HelloRequest) returns (google.protobuf.Empty);\nmessage HelloReply{\n\tstring msg=1;\n}\nmessage HelloRequest{\n\tstring msg=1; \n}\n```\n\n然后再在两端代码中实现方法即可。（由于代码过于简单，此处省略若干字）在引文3中，提供了非常完善的Wcf迁移到gRPC的代码流程，需要请自取。\n\n### 4.2 迁移WCF的双工通信\n\n#### 1、WCF中的双工通信示例\n\n在WCF中，双工（Duplex）通信很常用，在通信过程中，双方都可以向对方发送消息，使得很容易的就实现了服务端回调客户端。\n\n在这种模式下，客户端向服务端调用一个方法，然后在服务端回调客户端方法，可以理解为双方的位置发生了改变，此时的服务端变成了客户端，而客户端变成了服务端。\n\n如图所示。  \n\n- ![image-20191130140814321](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-mirgate-wcf-to-grpc/wcf-callback.png)\n\n代码如下：\n\n1. 服务端：\n\n   - 订定契约HelloCallback，用于处理回调的逻辑。\n   - 订定契约UserService 和 UserServiceImpl，并定义了一个 GetUser 方法。\n\n   ```c#\n   /// <summary>\n   /// 用于回调的Hello方法\n   /// </summary>\n   [ServiceContract]\n   public interface HelloCallback\n   {\n       [OperationContract(IsOneWay = true)]\n       void SayHelloworld(string msg);\n   }\n   /// <summary>\n   /// 用户服务,并回调客户端到HelloCallback\n   /// </summary>\n   [ServiceContract(SessionMode = SessionMode.Required, CallbackContract = typeof(HelloCallback))]\n   public interface UserService\n   {\n       [OperationContract(IsOneWay = true)]\n       void GetUser(string userName);\n   }\n   /// <summary>\n   /// 用户服务\n   /// </summary>\n   [ServiceBehavior(InstanceContextMode = InstanceContextMode.PerSession)]\n   public class UserServiceImpl : UserService\n   {\n       HelloCallback callback;\n       public void GetUser(string userName)\n       {\n           Console.Write(userName);\n           OperationContext context = OperationContext.Current;\n           callback = context.GetCallbackChannel<HelloCallback>();\n           callback.SayHelloworld($\"{userName}:hello\");\n       }\n   }\n   ```\n\n   启动服务端程序时，需要创建服务端的Host主机信息。\n\n   ```\n    private static ServiceHost StartUserService()\n    {\n        var host = new ServiceHost(typeof(UserServiceImpl));\n        var binding = new NetTcpBinding(SecurityMode.None);\n        host.AddServiceEndpoint(typeof(UserService), binding,\n        \"net.tcp://localhost:12384/userservice\");\n   \n       host.Open();\n       return host;\n   }\n   ```\n\n2. 客户端：\n\n   - 订定契约HelloCallback 和客户端的契约实现 HelloCallbackImpl 。\n\n     ```c#\n     /// <summary>\n     /// 回调Hello方法\n     /// </summary>\n     [ServiceContract]\n     public interface HelloCallback\n     {\n         [OperationContract(IsOneWay = true)]\n         void SayHelloworld(string msg);\n     }\n     public class HelloCallbackImpl : HelloCallback\n     {\n         public void SayHelloworld(string msg)\n         {\n         \tConsole.Write(msg);\n         }\n     }\n     ```\n\n     \n\n   - 订定契约UserService，用以保持和服务端的契约保持一致。\n\n     ```c#\n     /// <summary>\n     /// 用户服务\n     /// </summary>\n     [ServiceContract(CallbackContract = typeof(HelloCallback))]\n     public interface UserService\n     {\n         [OperationContract(IsOneWay = true)]\n         void GetUser(string userName);\n     }\n     ```\n\n     客户端启动时，连接到服务端。并发送GetUser方法。 \n\n```C#\nprivate static void GetUser(NetTcpBinding binding)\n        {\n            var address = new EndpointAddress(\"net.tcp://localhost:12384/userservice\");\n            var factory =\n                new DuplexChannelFactory<UserService>(typeof(HelloCallbackImpl), binding,\n                    address);\n            var context = new InstanceContext(new HelloCallbackImpl());\n            var server = factory.CreateChannel(context);\n\n            server.GetUser(\"zhangssan\");\n        }\n```\n\n实现效果如下：\n\n![image-20191130144237825](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-mirgate-wcf-to-grpc/result.png)\n\n这是一个典型的WCF双工通信的示例，在传统的.NET Framework开发中可能非常常见，但是该如何才能迁移到gRPC服务中呢？\n\n#### 2、gRPC中的代码实现\n\n- 流程说明\n\ngRPC中实现此双工通信，需要使用来自服务端的单向流来实现，但在gRPC中不能直接回调对应的方法，而是在服务端将流返回后，触发对应客户端代码中的方法来实现这个回调的流程。\n\n如图所示： \n\n![image-20191130214340416](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-mirgate-wcf-to-grpc/grpc-callback.png)\n\n- 代码实现流程：\n\n  1、定义 proto 协议文件\n\n  请求方法为getUser，并返回流。首先定义服务协议文件，命名为 userService.proto 文件。\n\n  ```c#\n  syntax = \"proto3\";\n  \n  option csharp_namespace = \"DulpexGrpcDemo\"; \n  \n  package DulpexGrpcDemo;\n  \n  service userService {\n    rpc GetUser (HelloRequest) returns (stream HelloReply);  \n    rpc GetTest (HelloRequest) returns (HelloReply);\n  }\n  message HelloReply{\n  \tstring msg=1;\n  }\n  message HelloRequest{\n  \tstring msg=1; \n  } \n  ```\n\n  2、服务端实现\n\n```c#\npublic class UserServiceImpl : userService.userServiceBase\n    {\n        public override async Task GetUser(HelloRequest request, IServerStreamWriter<HelloReply> responseStream, ServerCallContext context)\n        {\n            await DoSomeThing(request.Msg, (msg) => { responseStream.WriteAsync(new HelloReply { Msg = $\"{msg}:hello\" }); });\n\n        }\n        //处理回调逻辑\n        private async Task DoSomeThing(string msg, Action<string> action)\n        {\n            Console.WriteLine(msg);\n            action?.Invoke(msg);\n        }\n        public override Task<HelloReply> GetTest(HelloRequest request, ServerCallContext context)\n        {\n            Console.WriteLine(request.Msg);\n            return Task.FromResult(new HelloReply { Msg = $\"{request.Msg}:hello\" });\n        }\n    }\n```\n\n \t3、客户端实现（需要被调用的方法）\n\n```c#\npublic interface HelloCallback\n{\n    void SayHelloworld(string msg);\n}\npublic class HelloCallbackImpl : HelloCallback\n{\n   public void SayHelloworld(string msg)\n   {\n      Console.Write(msg);\n   }\n}\n```\n\n4、用户服务方法的实现\n\n```c#\npublic class UserServiceImpl\n {\n     private userService.userServiceClient userServiceClient;\n     private readonly HelloCallback _helloCallback;\n\n    public UserServiceImpl(userService.userServiceClient serviceClient, HelloCallback helloCallback)\n    {\n        userServiceClient = serviceClient;\n        _helloCallback = helloCallback;\n    }\n    public async Task GetUser()\n    {\n        AsyncServerStreamingCall<HelloReply> stream = userServiceClient.GetUser(new HelloRequest { Msg = \"张三\" });\n        await Helloworld(stream.ResponseStream);\n    }\n    async Task Helloworld(IAsyncStreamReader<HelloReply> stream)\n    {\n        await foreach (var update in stream.ReadAllAsync())\n        {\n            _helloCallback.SayHelloworld(update.Msg);\n        }\n    }\n}\n```\n\n5、客户端程序的入口\n\n```c#\nclass Program\n    {\n        static async Task Main(string[] args)\n        {\n            IServiceCollection servicesCollection = new ServiceCollection();\n            IConfiguration configuration = new ConfigurationBuilder()\n                        .SetBasePath(Directory.GetCurrentDirectory()).AddJsonFile(\"appsettings.json\", true, false).Build();\n\n        servicesCollection.AddGrpcClient<userService.userServiceClient>(\n           o =>\n            {\n                o.Address = new Uri(\"https://localhost:5001\");\n            });\n        servicesCollection.AddSingleton<UserServiceImpl>();\n        servicesCollection.AddSingleton<HelloCallback, HelloCallbackImpl>();\n        var userServiceImpl = servicesCollection.BuildServiceProvider().GetService<UserServiceImpl>();\n        await userServiceImpl.GetUser();\n        Console.ReadLine();\n    }\n\n}\n```\n\n当然，从这个示例中，可能会觉得有点奇怪，明明可以使用请求-响应的简单RPC模式，为什么要使用服务端的单向流来实现了？\n\n这种单向流中，客户端无需等待服务端执行方法执行完，而是由服务端完成后续流程后，再回调客户端的方法，使得流程变得简单清晰。\n\n在微软的官方文档（参考文献1）更适合介绍这个迁移过程的单向流的实现，通过实现服务端向客户端推流的形式来介绍，只是方法相对而言实现的逻辑比较多，而鄙人这个示例则剥离了与让我们理解服务端单向流流程无关的部分，使得流程看起来更简单。\n\n \n\n参考文献\n\n[1] 官方文档： https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/migrate-duplex-services \n\n[2] Jon Seeley的官方博客，如何迁移将wcf服务迁移到grpc：https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/ \n\n[3] Jon Seeley的官方博客，如何在.netcore中使用wcf：https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/ ","slug":"技术/浅议Grpc的双向流和WCF中的回调机制","published":1,"updated":"2019-12-09T15:06:16.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt80001rn4vi6wec6cr3","content":"<h1 id=\"浅议Grpc的双向流和WCF中的回调机制\"><a href=\"#浅议Grpc的双向流和WCF中的回调机制\" class=\"headerlink\" title=\"浅议Grpc的双向流和WCF中的回调机制\"></a>浅议Grpc的双向流和WCF中的回调机制</h1><h2 id=\"一、引子\"><a href=\"#一、引子\" class=\"headerlink\" title=\"一、引子\"></a>一、引子</h2><p>如您所知，gRPC是目前比较常见的rpc框架，可以方便的作为服务与服务之间的通信基础设施，为构建微服务体系提供非常强有力的支持。</p>\n<p>而基于.NET Core的gRPC.NET 组件截至2019年11月30日的最新版本为2.25.0，该版本基于.netstrandard2.1进行，能够在.NET Core3.0上非常方便的实现，而且还能方便的迁移到基于.NET Core的windows桌面端开发体系。</p>\n<p>在本文中参考微软官方文档的示例，实现了一个从WCF 服务回调机制迁移到gRPC的过程，由于时间仓促，如有疏漏，还望批评指正。第一篇主要从技术层面来分析迁移流程，第二篇打算从业务和代码整洁性角度来思考这个问题。</p>\n<h3 id=\"1-1、一些新东西：\"><a href=\"#1-1、一些新东西：\" class=\"headerlink\" title=\"1.1、一些新东西：\"></a>1.1、一些新东西：</h3><h6 id=\"1-、使用客户端工厂组件-Grpc-Net-ClientFactory-：\"><a href=\"#1-、使用客户端工厂组件-Grpc-Net-ClientFactory-：\" class=\"headerlink\" title=\"1)、使用客户端工厂组件 Grpc.Net.ClientFactory ：\"></a>1)、使用客户端工厂组件 Grpc.Net.ClientFactory ：</h6><p>在新版本中，可以使用  Grpc.Net.ClientFactory 支持以依赖注入的形式AddGrpcClient，将grpc客户端引入中，而无需每一次方法调用都使用 New 关键词进行创建。 这对客户端调用来说是极大的方便，毕竟随着.NET Core的普及，对于许多开发者来说，看到 New 关键词其实是很难受的啊。</p>\n<p>示例：</p>\n<p>以下代码以注册了 GreetClient ，并在发送 http 请求前，对请求头信息进行修改，添加 jwt 标识，以便发送带鉴权标识的请求。</p>\n<pre><code>serviceCollection.AddGrpcClient&lt;GreeterClient&gt;(\n    o =&gt;\n    {\n    o.Address = new Uri(configuration[&quot;address&quot;]);\n    })\n    .AddHttpMessageHandler&lt;JwtTokenHeader&gt;();</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class GreetImpl</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private readonly GreetClient _greetClient;</span><br><span class=\"line\">    public GreetImpl(GreetClient greetClient)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JwtTokenHeader中的代码段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.Headers.Authorization = new AuthenticationHeaderValue(&quot;Bearer&quot;, &quot;&quot;);</span><br><span class=\"line\">HttpResponseMessage response = await base.SendAsync(request, cancellationToken);</span><br></pre></td></tr></table></figure>\n\n<p>(以上示例代码仅供参考，不支持直接运行，且不支持.NET Framework。。) </p>\n<p>所以到此为止，我们在使用gRPC开发时，需要（能）使用的组件包括以下几种：</p>\n<ul>\n<li>Grpc.AspNETCore包：这个包用于在asp.net core中提供grpc服务支持，在asp.netcore的服务端项目中以nuget安装grpc组件时，需要安装这个包。<ul>\n<li>Google.Protobuf组件：Protobuf协议的实现。</li>\n<li>Grpc.AspNetCore.Server ：gRPC Asp.NET Core服务端核心库</li>\n<li>Grpc.Core.Api ：gRPC  Core API核心库</li>\n</ul>\n</li>\n<li>Grpc.Tools 包：内部封装了从proto文件生成gRPC服务端/客户端方法存根的流程。</li>\n<li>Grpc.Core：gRPC核心包。</li>\n<li>Grpc.Net.Client：gRPC 客户端实现核心库。<ul>\n<li>Grpc.Core.Api ：gRPC  Core API核心库</li>\n<li>Grpc.Net.Common：gRPC 常用方法。</li>\n</ul>\n</li>\n<li>Grpc.Net.ClientFactory： gRPC客户端工厂方法。仅用于标准库2.1。</li>\n</ul>\n<h6 id=\"2-、其他特性：\"><a href=\"#2-、其他特性：\" class=\"headerlink\" title=\"2)、其他特性：\"></a>2)、其他特性：</h6><ol>\n<li>支持  SerializationContext.GetBufferWriter 。</li>\n<li>性能优化。 Optimize server’s gRPC message serialization </li>\n<li>验证协议降级。 Validate gRPC response protocol is not downgraded  </li>\n<li>New Grpc.AspNetCore.Server.Reflection package </li>\n<li>Log unsupported request content-type and protocol </li>\n<li>Major client performance improvement </li>\n<li>修bug等。</li>\n</ol>\n<p>（ 当然，由于各种原因，未能亲测。）</p>\n<h3 id=\"1-2、存在的缺陷\"><a href=\"#1-2、存在的缺陷\" class=\"headerlink\" title=\"1.2、存在的缺陷\"></a>1.2、存在的缺陷</h3><ul>\n<li><p>目前的grpc的定位仅仅是一种数据传输机制，因此本身不包含负载均衡和服务管理的功能，一般会引入consul/etcd/zk等框架来实现服务治理。</p>\n</li>\n<li><p>由于最新版本基于标准库2.1进行构建，因此该最新版本无法在.net fx上使用（因为.netframework最高仅支持到标准库2.0），不过只是新版本不支持，依然可以使用2.23.2的版本来实现。当然，以后也不会支持.netfx了。。</p>\n</li>\n</ul>\n<h2 id=\"二、gRPC通信方式\"><a href=\"#二、gRPC通信方式\" class=\"headerlink\" title=\"二、gRPC通信方式\"></a>二、gRPC通信方式</h2><p>gRPC提供了以下四种传输方式：</p>\n<p>查看</p>\n<h3 id=\"2-1、Simple-RPC\"><a href=\"#2-1、Simple-RPC\" class=\"headerlink\" title=\"2.1、Simple RPC\"></a>2.1、Simple RPC</h3><p>简单RPC 传输。一般的rpc方法调用，一次请求返回一个对象。适用于类似于以前的webapi请求调用的形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpc Hello (HelloRequest) returns (HelloReply);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1、Server-side-streaming-RPC\"><a href=\"#2-1、Server-side-streaming-RPC\" class=\"headerlink\" title=\"2.1、Server-side streaming RPC\"></a>2.1、Server-side streaming RPC</h3><p>一种单向流，服务端流式RPC，客户端向服务端请求后，由服务端以流的形式返回多个结果。例如可以用于客户端需要从服务端获取流媒体文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpc Subscribe (SubscribeRequest) returns (stream StockTickerUpdate);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3、Client-Side-streaming-RPC\"><a href=\"#2-3、Client-Side-streaming-RPC\" class=\"headerlink\" title=\"2.3、Client-Side streaming RPC\"></a>2.3、Client-Side streaming RPC</h3><p>一种单向流，客户端单向流，客户端以流的形式传输多个请求，服务端返回一个响应结果。例如可以用于客户端需要向服务端推流的场景。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpc Subscribe (stream SubscribeRequest) returns (StockTickerUpdate);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4、-Bidirectional-streaming-RPC\"><a href=\"#2-4、-Bidirectional-streaming-RPC\" class=\"headerlink\" title=\"2.4、 Bidirectional streaming RPC\"></a>2.4、 Bidirectional streaming RPC</h4><p> 双向流式rpc。客户端和服务端均可以传输多个请求。例如可以用于游戏中的双向传输。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpc Subscribe (stream SubscribeRequest) returns (stream StockTickerUpdate);</span><br></pre></td></tr></table></figure>\n\n<p>总之，看起来gRPC能够实现目前所能设想的大部分场景，因此也被视为是古老的rpc框架 wcf ( Windows Communication Foundation )的替代者，官方专门编写了一本电子书，用来给需要从 wcf 转 gRPC的开发者提供指引。</p>\n<p>具体地址为： <a href=\"https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/</a> </p>\n<p>除此之外，本人还看到了一些外网作者使用grpc 来移植 wcf的一些博客。</p>\n<p>1、 <a href=\"https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/\" target=\"_blank\" rel=\"noopener\">https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/</a> </p>\n<p>2、<a href=\"https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/\" target=\"_blank\" rel=\"noopener\">https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/</a> </p>\n<p>这两篇博客的作者在.NET Core中使用了WCF，根据作者的说法，在.NET Core2.0中还能使用，但是随着3.0的发布，他已经不再使用WCF了，而是改用了gRPC。</p>\n<h2 id=\"三、WCF的通信方式\"><a href=\"#三、WCF的通信方式\" class=\"headerlink\" title=\"三、WCF的通信方式\"></a>三、WCF的通信方式</h2><h3 id=\"3-1、简述\"><a href=\"#3-1、简述\" class=\"headerlink\" title=\"3.1、简述\"></a>3.1、简述</h3><p>WCF 是.NET框架中非常常用的一种组件，在.NET Framework 3.0时被引入，它整合了一些历史悠久的技术框架或通信机制，诸如 soap、remoting等。</p>\n<p>由于WCF技术体系庞大，学习路线也比较陡峭，能够驾驭的往往都是拥有多年工作经验的资深开发者，开发者们有时需针对各个阶段的内涵做深入的了解，才能开发对应的应用。</p>\n<p>由于本人使用WCF的经验尚浅（以前的项目用得少，充其量就用过Remoting），所以以下文字均来自网上现有资料的演绎，如有疏漏，敬请批评指正。</p>\n<p>WCF中，需要定义合约作为通信过程中的沟通方式。通信双方所遵循的通信方式，有合约绑定来制定；通信期间的安全性，有双方约定的安全性层级来定义。</p>\n<h3 id=\"3-2、合约-Contract\"><a href=\"#3-2、合约-Contract\" class=\"headerlink\" title=\"3.2、合约(Contract)\"></a>3.2、合约(Contract)</h3><p>合约（ Contract） 是WCF中最重要的基本概念，合约的使用分成两个部分，一部分是以接口形式体现的合约，一部分是基于合约派生出的实现类。</p>\n<p>合约分成四种类型：</p>\n<p>数据合约 （Data Contract） ：订定双方沟通时的数据格式。</p>\n<p>服务合约 （Service Contract） ：订定服务的定义。</p>\n<p>操作合约 （Operation Contract） ：订定服务提供的方法。在维基百科中翻译为营运合约。</p>\n<p>消息合约 （Message Contract） ：订定在通信期间改写消息内容的规范。</p>\n<p>在维基百科中，提供了一个如下的代码示例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.ServiceModel;</span><br><span class=\"line\">namespace Microsoft.ServiceModel.Samples</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  [ServiceContract(Namespace = &quot;http://Microsoft.ServiceModel.Samples&quot;)] // 服务合约</span><br><span class=\"line\">  public interface ICalculator</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    [OperationContract] // 操作合约</span><br><span class=\"line\">    double Add（double n1, double n2）;</span><br><span class=\"line\">    [OperationContract] // 操作合约</span><br><span class=\"line\">    double Subtract（double n1, double n2）;</span><br><span class=\"line\">    [OperationContract] // 操作合约</span><br><span class=\"line\">    double Multiply（double n1, double n2）;</span><br><span class=\"line\">    [OperationContract] // 操作合约</span><br><span class=\"line\">    double Divide（double n1, double n2）;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3、协议绑定\"><a href=\"#3-3、协议绑定\" class=\"headerlink\" title=\"3.3、协议绑定\"></a>3.3、协议绑定</h3><p>WCF支持HTTP\\TCP\\命名管道（ <a href=\"https://zh.wikipedia.org/w/index.php?title=Named_Pipe&action=edit&redlink=1\" target=\"_blank\" rel=\"noopener\">Named Pipe</a> ）、MSMQ（ <a href=\"https://zh.wikipedia.org/w/index.php?title=MSMQ&action=edit&redlink=1\" target=\"_blank\" rel=\"noopener\">MSMQ</a> ）、点对点TCP Peer-To-Peer TCP 等协议。其中对HTTP协议的支持分为:基本HTTP支持\\WS-HTTP支持；对TCP的协议也支NetTcpBinding\\NetPeerTcpBinding等通信方式。</p>\n<p><del>从这里可以看出，能够驾驭WCF技术的，基本上都是.NET开发领域的大牛，涉及到如此多的技术栈，实在是令人钦佩。</del></p>\n<p>由于WCF支持的协议很多，所以在进行WCF的客户端和服务端开发时，需要使用统一通信的协议，并且在编码以及格式上也要一致。</p>\n<p>维基百科提供了一个设置通信绑定的示例配置文件，当然，有时候无需通过配置文件来配置wcf的服务信息，通过代码创建也同样可行。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">system.serviceModel</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 接口协议 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">services</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">service</span> <span class=\"attr\">name</span>=<span class=\"string\">\" CalculatorService\"</span> &gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">endpoint</span> <span class=\"attr\">address</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">binding</span>=<span class=\"string\">\"wsHttpBinding\"</span> <span class=\"attr\">bindingConfiguration</span>=<span class=\"string\">\"Binding1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">contract</span>=<span class=\"string\">\"ICalculator\"</span> /&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">service</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">services</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 通信机制 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bindings</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">wsHttpBinding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">binding</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Binding1\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">binding</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">wsHttpBinding</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bindings</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">system.serviceModel</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4、代码迁移\"><a href=\"#4、代码迁移\" class=\"headerlink\" title=\"4、代码迁移\"></a>4、代码迁移</h2><h3 id=\"4-1-迁移WCF的单工通信\"><a href=\"#4-1-迁移WCF的单工通信\" class=\"headerlink\" title=\"4.1 迁移WCF的单工通信\"></a>4.1 迁移WCF的单工通信</h3><p>在WCF中，一般默认的契约形式为点对点的请求-响应方式。即客户端发出请求后，一直阻塞方法，指导服务端响应后，才能执行后面的代码。</p>\n<p>这种模式类似于gRPC中的简单传输机制，所以如果从WCF服务迁移到gRPC服务时，比较简单纯粹，只需根据对应的数据方法来订定我们的服务协议文件 proto 文件。 </p>\n<p>例如，大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ServiceContract]</span><br><span class=\"line\">public interface ISimpleStockTickerCallback</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [OperationContract]</span><br><span class=\"line\">    void HelloWorld(string msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>迁移到 gRpc中之后，就是这样的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpc Hello (HelloRequest) returns (google.protobuf.Empty);</span><br><span class=\"line\">message HelloReply&#123;</span><br><span class=\"line\">\tstring msg=1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">message HelloRequest&#123;</span><br><span class=\"line\">\tstring msg=1; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后再在两端代码中实现方法即可。（由于代码过于简单，此处省略若干字）在引文3中，提供了非常完善的Wcf迁移到gRPC的代码流程，需要请自取。</p>\n<h3 id=\"4-2-迁移WCF的双工通信\"><a href=\"#4-2-迁移WCF的双工通信\" class=\"headerlink\" title=\"4.2 迁移WCF的双工通信\"></a>4.2 迁移WCF的双工通信</h3><h4 id=\"1、WCF中的双工通信示例\"><a href=\"#1、WCF中的双工通信示例\" class=\"headerlink\" title=\"1、WCF中的双工通信示例\"></a>1、WCF中的双工通信示例</h4><p>在WCF中，双工（Duplex）通信很常用，在通信过程中，双方都可以向对方发送消息，使得很容易的就实现了服务端回调客户端。</p>\n<p>在这种模式下，客户端向服务端调用一个方法，然后在服务端回调客户端方法，可以理解为双方的位置发生了改变，此时的服务端变成了客户端，而客户端变成了服务端。</p>\n<p>如图所示。  </p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-mirgate-wcf-to-grpc/wcf-callback.png\" alt=\"image-20191130140814321\"></li>\n</ul>\n<p>代码如下：</p>\n<ol>\n<li><p>服务端：</p>\n<ul>\n<li>订定契约HelloCallback，用于处理回调的逻辑。</li>\n<li>订定契约UserService 和 UserServiceImpl，并定义了一个 GetUser 方法。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 用于回调的Hello方法</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">[ServiceContract]</span><br><span class=\"line\">public interface HelloCallback</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [OperationContract(IsOneWay = true)]</span><br><span class=\"line\">    void SayHelloworld(string msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 用户服务,并回调客户端到HelloCallback</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">[ServiceContract(SessionMode = SessionMode.Required, CallbackContract = typeof(HelloCallback))]</span><br><span class=\"line\">public interface UserService</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [OperationContract(IsOneWay = true)]</span><br><span class=\"line\">    void GetUser(string userName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 用户服务</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">[ServiceBehavior(InstanceContextMode = InstanceContextMode.PerSession)]</span><br><span class=\"line\">public class UserServiceImpl : UserService</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    HelloCallback callback;</span><br><span class=\"line\">    public void GetUser(string userName)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.Write(userName);</span><br><span class=\"line\">        OperationContext context = OperationContext.Current;</span><br><span class=\"line\">        callback = context.GetCallbackChannel&lt;HelloCallback&gt;();</span><br><span class=\"line\">        callback.SayHelloworld($&quot;&#123;userName&#125;:hello&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启动服务端程序时，需要创建服务端的Host主机信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> private static ServiceHost StartUserService()</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     var host = new ServiceHost(typeof(UserServiceImpl));</span><br><span class=\"line\">     var binding = new NetTcpBinding(SecurityMode.None);</span><br><span class=\"line\">     host.AddServiceEndpoint(typeof(UserService), binding,</span><br><span class=\"line\">     &quot;net.tcp://localhost:12384/userservice&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    host.Open();</span><br><span class=\"line\">    return host;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>客户端：</p>\n<ul>\n<li><p>订定契约HelloCallback 和客户端的契约实现 HelloCallbackImpl 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 回调Hello方法</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">[ServiceContract]</span><br><span class=\"line\">public interface HelloCallback</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [OperationContract(IsOneWay = true)]</span><br><span class=\"line\">    void SayHelloworld(string msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class HelloCallbackImpl : HelloCallback</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public void SayHelloworld(string msg)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \tConsole.Write(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>订定契约UserService，用以保持和服务端的契约保持一致。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 用户服务</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">[ServiceContract(CallbackContract = typeof(HelloCallback))]</span><br><span class=\"line\">public interface UserService</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [OperationContract(IsOneWay = true)]</span><br><span class=\"line\">    void GetUser(string userName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端启动时，连接到服务端。并发送GetUser方法。 </p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void GetUser(NetTcpBinding binding)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            var address = new EndpointAddress(&quot;net.tcp://localhost:12384/userservice&quot;);</span><br><span class=\"line\">            var factory =</span><br><span class=\"line\">                new DuplexChannelFactory&lt;UserService&gt;(typeof(HelloCallbackImpl), binding,</span><br><span class=\"line\">                    address);</span><br><span class=\"line\">            var context = new InstanceContext(new HelloCallbackImpl());</span><br><span class=\"line\">            var server = factory.CreateChannel(context);</span><br><span class=\"line\"></span><br><span class=\"line\">            server.GetUser(&quot;zhangssan&quot;);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-mirgate-wcf-to-grpc/result.png\" alt=\"image-20191130144237825\"></p>\n<p>这是一个典型的WCF双工通信的示例，在传统的.NET Framework开发中可能非常常见，但是该如何才能迁移到gRPC服务中呢？</p>\n<h4 id=\"2、gRPC中的代码实现\"><a href=\"#2、gRPC中的代码实现\" class=\"headerlink\" title=\"2、gRPC中的代码实现\"></a>2、gRPC中的代码实现</h4><ul>\n<li>流程说明</li>\n</ul>\n<p>gRPC中实现此双工通信，需要使用来自服务端的单向流来实现，但在gRPC中不能直接回调对应的方法，而是在服务端将流返回后，触发对应客户端代码中的方法来实现这个回调的流程。</p>\n<p>如图所示： </p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-mirgate-wcf-to-grpc/grpc-callback.png\" alt=\"image-20191130214340416\"></p>\n<ul>\n<li><p>代码实现流程：</p>\n<p>1、定义 proto 协议文件</p>\n<p>请求方法为getUser，并返回流。首先定义服务协议文件，命名为 userService.proto 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = &quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">option csharp_namespace = &quot;DulpexGrpcDemo&quot;; </span><br><span class=\"line\"></span><br><span class=\"line\">package DulpexGrpcDemo;</span><br><span class=\"line\"></span><br><span class=\"line\">service userService &#123;</span><br><span class=\"line\">  rpc GetUser (HelloRequest) returns (stream HelloReply);  </span><br><span class=\"line\">  rpc GetTest (HelloRequest) returns (HelloReply);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">message HelloReply&#123;</span><br><span class=\"line\">\tstring msg=1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">message HelloRequest&#123;</span><br><span class=\"line\">\tstring msg=1; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、服务端实现</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class UserServiceImpl : userService.userServiceBase</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        public override async Task GetUser(HelloRequest request, IServerStreamWriter&lt;HelloReply&gt; responseStream, ServerCallContext context)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            await DoSomeThing(request.Msg, (msg) =&gt; &#123; responseStream.WriteAsync(new HelloReply &#123; Msg = $&quot;&#123;msg&#125;:hello&quot; &#125;); &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //处理回调逻辑</span><br><span class=\"line\">        private async Task DoSomeThing(string msg, Action&lt;string&gt; action)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Console.WriteLine(msg);</span><br><span class=\"line\">            action?.Invoke(msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public override Task&lt;HelloReply&gt; GetTest(HelloRequest request, ServerCallContext context)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Console.WriteLine(request.Msg);</span><br><span class=\"line\">            return Task.FromResult(new HelloReply &#123; Msg = $&quot;&#123;request.Msg&#125;:hello&quot; &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>3、客户端实现（需要被调用的方法）</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface HelloCallback</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void SayHelloworld(string msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class HelloCallbackImpl : HelloCallback</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   public void SayHelloworld(string msg)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      Console.Write(msg);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、用户服务方法的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class UserServiceImpl</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     private userService.userServiceClient userServiceClient;</span><br><span class=\"line\">     private readonly HelloCallback _helloCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    public UserServiceImpl(userService.userServiceClient serviceClient, HelloCallback helloCallback)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        userServiceClient = serviceClient;</span><br><span class=\"line\">        _helloCallback = helloCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public async Task GetUser()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AsyncServerStreamingCall&lt;HelloReply&gt; stream = userServiceClient.GetUser(new HelloRequest &#123; Msg = &quot;张三&quot; &#125;);</span><br><span class=\"line\">        await Helloworld(stream.ResponseStream);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    async Task Helloworld(IAsyncStreamReader&lt;HelloReply&gt; stream)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        await foreach (var update in stream.ReadAllAsync())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _helloCallback.SayHelloworld(update.Msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5、客户端程序的入口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Program</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        static async Task Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            IServiceCollection servicesCollection = new ServiceCollection();</span><br><span class=\"line\">            IConfiguration configuration = new ConfigurationBuilder()</span><br><span class=\"line\">                        .SetBasePath(Directory.GetCurrentDirectory()).AddJsonFile(&quot;appsettings.json&quot;, true, false).Build();</span><br><span class=\"line\"></span><br><span class=\"line\">        servicesCollection.AddGrpcClient&lt;userService.userServiceClient&gt;(</span><br><span class=\"line\">           o =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                o.Address = new Uri(&quot;https://localhost:5001&quot;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        servicesCollection.AddSingleton&lt;UserServiceImpl&gt;();</span><br><span class=\"line\">        servicesCollection.AddSingleton&lt;HelloCallback, HelloCallbackImpl&gt;();</span><br><span class=\"line\">        var userServiceImpl = servicesCollection.BuildServiceProvider().GetService&lt;UserServiceImpl&gt;();</span><br><span class=\"line\">        await userServiceImpl.GetUser();</span><br><span class=\"line\">        Console.ReadLine();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，从这个示例中，可能会觉得有点奇怪，明明可以使用请求-响应的简单RPC模式，为什么要使用服务端的单向流来实现了？</p>\n<p>这种单向流中，客户端无需等待服务端执行方法执行完，而是由服务端完成后续流程后，再回调客户端的方法，使得流程变得简单清晰。</p>\n<p>在微软的官方文档（参考文献1）更适合介绍这个迁移过程的单向流的实现，通过实现服务端向客户端推流的形式来介绍，只是方法相对而言实现的逻辑比较多，而鄙人这个示例则剥离了与让我们理解服务端单向流流程无关的部分，使得流程看起来更简单。</p>\n<p>参考文献</p>\n<p>[1] 官方文档： <a href=\"https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/migrate-duplex-services\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/migrate-duplex-services</a> </p>\n<p>[2] Jon Seeley的官方博客，如何迁移将wcf服务迁移到grpc：<a href=\"https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/\" target=\"_blank\" rel=\"noopener\">https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/</a> </p>\n<p>[3] Jon Seeley的官方博客，如何在.netcore中使用wcf：<a href=\"https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/\" target=\"_blank\" rel=\"noopener\">https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/</a> </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浅议Grpc的双向流和WCF中的回调机制\"><a href=\"#浅议Grpc的双向流和WCF中的回调机制\" class=\"headerlink\" title=\"浅议Grpc的双向流和WCF中的回调机制\"></a>浅议Grpc的双向流和WCF中的回调机制</h1><h2 id=\"一、引子\"><a href=\"#一、引子\" class=\"headerlink\" title=\"一、引子\"></a>一、引子</h2><p>如您所知，gRPC是目前比较常见的rpc框架，可以方便的作为服务与服务之间的通信基础设施，为构建微服务体系提供非常强有力的支持。</p>\n<p>而基于.NET Core的gRPC.NET 组件截至2019年11月30日的最新版本为2.25.0，该版本基于.netstrandard2.1进行，能够在.NET Core3.0上非常方便的实现，而且还能方便的迁移到基于.NET Core的windows桌面端开发体系。</p>\n<p>在本文中参考微软官方文档的示例，实现了一个从WCF 服务回调机制迁移到gRPC的过程，由于时间仓促，如有疏漏，还望批评指正。第一篇主要从技术层面来分析迁移流程，第二篇打算从业务和代码整洁性角度来思考这个问题。</p>\n<h3 id=\"1-1、一些新东西：\"><a href=\"#1-1、一些新东西：\" class=\"headerlink\" title=\"1.1、一些新东西：\"></a>1.1、一些新东西：</h3><h6 id=\"1-、使用客户端工厂组件-Grpc-Net-ClientFactory-：\"><a href=\"#1-、使用客户端工厂组件-Grpc-Net-ClientFactory-：\" class=\"headerlink\" title=\"1)、使用客户端工厂组件 Grpc.Net.ClientFactory ：\"></a>1)、使用客户端工厂组件 Grpc.Net.ClientFactory ：</h6><p>在新版本中，可以使用  Grpc.Net.ClientFactory 支持以依赖注入的形式AddGrpcClient，将grpc客户端引入中，而无需每一次方法调用都使用 New 关键词进行创建。 这对客户端调用来说是极大的方便，毕竟随着.NET Core的普及，对于许多开发者来说，看到 New 关键词其实是很难受的啊。</p>\n<p>示例：</p>\n<p>以下代码以注册了 GreetClient ，并在发送 http 请求前，对请求头信息进行修改，添加 jwt 标识，以便发送带鉴权标识的请求。</p>\n<pre><code>serviceCollection.AddGrpcClient&lt;GreeterClient&gt;(\n    o =&gt;\n    {\n    o.Address = new Uri(configuration[&quot;address&quot;]);\n    })\n    .AddHttpMessageHandler&lt;JwtTokenHeader&gt;();</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class GreetImpl</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private readonly GreetClient _greetClient;</span><br><span class=\"line\">    public GreetImpl(GreetClient greetClient)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JwtTokenHeader中的代码段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.Headers.Authorization = new AuthenticationHeaderValue(&quot;Bearer&quot;, &quot;&quot;);</span><br><span class=\"line\">HttpResponseMessage response = await base.SendAsync(request, cancellationToken);</span><br></pre></td></tr></table></figure>\n\n<p>(以上示例代码仅供参考，不支持直接运行，且不支持.NET Framework。。) </p>\n<p>所以到此为止，我们在使用gRPC开发时，需要（能）使用的组件包括以下几种：</p>\n<ul>\n<li>Grpc.AspNETCore包：这个包用于在asp.net core中提供grpc服务支持，在asp.netcore的服务端项目中以nuget安装grpc组件时，需要安装这个包。<ul>\n<li>Google.Protobuf组件：Protobuf协议的实现。</li>\n<li>Grpc.AspNetCore.Server ：gRPC Asp.NET Core服务端核心库</li>\n<li>Grpc.Core.Api ：gRPC  Core API核心库</li>\n</ul>\n</li>\n<li>Grpc.Tools 包：内部封装了从proto文件生成gRPC服务端/客户端方法存根的流程。</li>\n<li>Grpc.Core：gRPC核心包。</li>\n<li>Grpc.Net.Client：gRPC 客户端实现核心库。<ul>\n<li>Grpc.Core.Api ：gRPC  Core API核心库</li>\n<li>Grpc.Net.Common：gRPC 常用方法。</li>\n</ul>\n</li>\n<li>Grpc.Net.ClientFactory： gRPC客户端工厂方法。仅用于标准库2.1。</li>\n</ul>\n<h6 id=\"2-、其他特性：\"><a href=\"#2-、其他特性：\" class=\"headerlink\" title=\"2)、其他特性：\"></a>2)、其他特性：</h6><ol>\n<li>支持  SerializationContext.GetBufferWriter 。</li>\n<li>性能优化。 Optimize server’s gRPC message serialization </li>\n<li>验证协议降级。 Validate gRPC response protocol is not downgraded  </li>\n<li>New Grpc.AspNetCore.Server.Reflection package </li>\n<li>Log unsupported request content-type and protocol </li>\n<li>Major client performance improvement </li>\n<li>修bug等。</li>\n</ol>\n<p>（ 当然，由于各种原因，未能亲测。）</p>\n<h3 id=\"1-2、存在的缺陷\"><a href=\"#1-2、存在的缺陷\" class=\"headerlink\" title=\"1.2、存在的缺陷\"></a>1.2、存在的缺陷</h3><ul>\n<li><p>目前的grpc的定位仅仅是一种数据传输机制，因此本身不包含负载均衡和服务管理的功能，一般会引入consul/etcd/zk等框架来实现服务治理。</p>\n</li>\n<li><p>由于最新版本基于标准库2.1进行构建，因此该最新版本无法在.net fx上使用（因为.netframework最高仅支持到标准库2.0），不过只是新版本不支持，依然可以使用2.23.2的版本来实现。当然，以后也不会支持.netfx了。。</p>\n</li>\n</ul>\n<h2 id=\"二、gRPC通信方式\"><a href=\"#二、gRPC通信方式\" class=\"headerlink\" title=\"二、gRPC通信方式\"></a>二、gRPC通信方式</h2><p>gRPC提供了以下四种传输方式：</p>\n<p>查看</p>\n<h3 id=\"2-1、Simple-RPC\"><a href=\"#2-1、Simple-RPC\" class=\"headerlink\" title=\"2.1、Simple RPC\"></a>2.1、Simple RPC</h3><p>简单RPC 传输。一般的rpc方法调用，一次请求返回一个对象。适用于类似于以前的webapi请求调用的形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpc Hello (HelloRequest) returns (HelloReply);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1、Server-side-streaming-RPC\"><a href=\"#2-1、Server-side-streaming-RPC\" class=\"headerlink\" title=\"2.1、Server-side streaming RPC\"></a>2.1、Server-side streaming RPC</h3><p>一种单向流，服务端流式RPC，客户端向服务端请求后，由服务端以流的形式返回多个结果。例如可以用于客户端需要从服务端获取流媒体文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpc Subscribe (SubscribeRequest) returns (stream StockTickerUpdate);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3、Client-Side-streaming-RPC\"><a href=\"#2-3、Client-Side-streaming-RPC\" class=\"headerlink\" title=\"2.3、Client-Side streaming RPC\"></a>2.3、Client-Side streaming RPC</h3><p>一种单向流，客户端单向流，客户端以流的形式传输多个请求，服务端返回一个响应结果。例如可以用于客户端需要向服务端推流的场景。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpc Subscribe (stream SubscribeRequest) returns (StockTickerUpdate);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4、-Bidirectional-streaming-RPC\"><a href=\"#2-4、-Bidirectional-streaming-RPC\" class=\"headerlink\" title=\"2.4、 Bidirectional streaming RPC\"></a>2.4、 Bidirectional streaming RPC</h4><p> 双向流式rpc。客户端和服务端均可以传输多个请求。例如可以用于游戏中的双向传输。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpc Subscribe (stream SubscribeRequest) returns (stream StockTickerUpdate);</span><br></pre></td></tr></table></figure>\n\n<p>总之，看起来gRPC能够实现目前所能设想的大部分场景，因此也被视为是古老的rpc框架 wcf ( Windows Communication Foundation )的替代者，官方专门编写了一本电子书，用来给需要从 wcf 转 gRPC的开发者提供指引。</p>\n<p>具体地址为： <a href=\"https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/</a> </p>\n<p>除此之外，本人还看到了一些外网作者使用grpc 来移植 wcf的一些博客。</p>\n<p>1、 <a href=\"https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/\" target=\"_blank\" rel=\"noopener\">https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/</a> </p>\n<p>2、<a href=\"https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/\" target=\"_blank\" rel=\"noopener\">https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/</a> </p>\n<p>这两篇博客的作者在.NET Core中使用了WCF，根据作者的说法，在.NET Core2.0中还能使用，但是随着3.0的发布，他已经不再使用WCF了，而是改用了gRPC。</p>\n<h2 id=\"三、WCF的通信方式\"><a href=\"#三、WCF的通信方式\" class=\"headerlink\" title=\"三、WCF的通信方式\"></a>三、WCF的通信方式</h2><h3 id=\"3-1、简述\"><a href=\"#3-1、简述\" class=\"headerlink\" title=\"3.1、简述\"></a>3.1、简述</h3><p>WCF 是.NET框架中非常常用的一种组件，在.NET Framework 3.0时被引入，它整合了一些历史悠久的技术框架或通信机制，诸如 soap、remoting等。</p>\n<p>由于WCF技术体系庞大，学习路线也比较陡峭，能够驾驭的往往都是拥有多年工作经验的资深开发者，开发者们有时需针对各个阶段的内涵做深入的了解，才能开发对应的应用。</p>\n<p>由于本人使用WCF的经验尚浅（以前的项目用得少，充其量就用过Remoting），所以以下文字均来自网上现有资料的演绎，如有疏漏，敬请批评指正。</p>\n<p>WCF中，需要定义合约作为通信过程中的沟通方式。通信双方所遵循的通信方式，有合约绑定来制定；通信期间的安全性，有双方约定的安全性层级来定义。</p>\n<h3 id=\"3-2、合约-Contract\"><a href=\"#3-2、合约-Contract\" class=\"headerlink\" title=\"3.2、合约(Contract)\"></a>3.2、合约(Contract)</h3><p>合约（ Contract） 是WCF中最重要的基本概念，合约的使用分成两个部分，一部分是以接口形式体现的合约，一部分是基于合约派生出的实现类。</p>\n<p>合约分成四种类型：</p>\n<p>数据合约 （Data Contract） ：订定双方沟通时的数据格式。</p>\n<p>服务合约 （Service Contract） ：订定服务的定义。</p>\n<p>操作合约 （Operation Contract） ：订定服务提供的方法。在维基百科中翻译为营运合约。</p>\n<p>消息合约 （Message Contract） ：订定在通信期间改写消息内容的规范。</p>\n<p>在维基百科中，提供了一个如下的代码示例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.ServiceModel;</span><br><span class=\"line\">namespace Microsoft.ServiceModel.Samples</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  [ServiceContract(Namespace = &quot;http://Microsoft.ServiceModel.Samples&quot;)] // 服务合约</span><br><span class=\"line\">  public interface ICalculator</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    [OperationContract] // 操作合约</span><br><span class=\"line\">    double Add（double n1, double n2）;</span><br><span class=\"line\">    [OperationContract] // 操作合约</span><br><span class=\"line\">    double Subtract（double n1, double n2）;</span><br><span class=\"line\">    [OperationContract] // 操作合约</span><br><span class=\"line\">    double Multiply（double n1, double n2）;</span><br><span class=\"line\">    [OperationContract] // 操作合约</span><br><span class=\"line\">    double Divide（double n1, double n2）;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3、协议绑定\"><a href=\"#3-3、协议绑定\" class=\"headerlink\" title=\"3.3、协议绑定\"></a>3.3、协议绑定</h3><p>WCF支持HTTP\\TCP\\命名管道（ <a href=\"https://zh.wikipedia.org/w/index.php?title=Named_Pipe&action=edit&redlink=1\" target=\"_blank\" rel=\"noopener\">Named Pipe</a> ）、MSMQ（ <a href=\"https://zh.wikipedia.org/w/index.php?title=MSMQ&action=edit&redlink=1\" target=\"_blank\" rel=\"noopener\">MSMQ</a> ）、点对点TCP Peer-To-Peer TCP 等协议。其中对HTTP协议的支持分为:基本HTTP支持\\WS-HTTP支持；对TCP的协议也支NetTcpBinding\\NetPeerTcpBinding等通信方式。</p>\n<p><del>从这里可以看出，能够驾驭WCF技术的，基本上都是.NET开发领域的大牛，涉及到如此多的技术栈，实在是令人钦佩。</del></p>\n<p>由于WCF支持的协议很多，所以在进行WCF的客户端和服务端开发时，需要使用统一通信的协议，并且在编码以及格式上也要一致。</p>\n<p>维基百科提供了一个设置通信绑定的示例配置文件，当然，有时候无需通过配置文件来配置wcf的服务信息，通过代码创建也同样可行。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">system.serviceModel</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 接口协议 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">services</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">service</span> <span class=\"attr\">name</span>=<span class=\"string\">\" CalculatorService\"</span> &gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">endpoint</span> <span class=\"attr\">address</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">binding</span>=<span class=\"string\">\"wsHttpBinding\"</span> <span class=\"attr\">bindingConfiguration</span>=<span class=\"string\">\"Binding1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">contract</span>=<span class=\"string\">\"ICalculator\"</span> /&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">service</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">services</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 通信机制 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bindings</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">wsHttpBinding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">binding</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Binding1\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">binding</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">wsHttpBinding</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">bindings</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">system.serviceModel</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4、代码迁移\"><a href=\"#4、代码迁移\" class=\"headerlink\" title=\"4、代码迁移\"></a>4、代码迁移</h2><h3 id=\"4-1-迁移WCF的单工通信\"><a href=\"#4-1-迁移WCF的单工通信\" class=\"headerlink\" title=\"4.1 迁移WCF的单工通信\"></a>4.1 迁移WCF的单工通信</h3><p>在WCF中，一般默认的契约形式为点对点的请求-响应方式。即客户端发出请求后，一直阻塞方法，指导服务端响应后，才能执行后面的代码。</p>\n<p>这种模式类似于gRPC中的简单传输机制，所以如果从WCF服务迁移到gRPC服务时，比较简单纯粹，只需根据对应的数据方法来订定我们的服务协议文件 proto 文件。 </p>\n<p>例如，大概是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ServiceContract]</span><br><span class=\"line\">public interface ISimpleStockTickerCallback</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [OperationContract]</span><br><span class=\"line\">    void HelloWorld(string msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>迁移到 gRpc中之后，就是这样的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpc Hello (HelloRequest) returns (google.protobuf.Empty);</span><br><span class=\"line\">message HelloReply&#123;</span><br><span class=\"line\">\tstring msg=1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">message HelloRequest&#123;</span><br><span class=\"line\">\tstring msg=1; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后再在两端代码中实现方法即可。（由于代码过于简单，此处省略若干字）在引文3中，提供了非常完善的Wcf迁移到gRPC的代码流程，需要请自取。</p>\n<h3 id=\"4-2-迁移WCF的双工通信\"><a href=\"#4-2-迁移WCF的双工通信\" class=\"headerlink\" title=\"4.2 迁移WCF的双工通信\"></a>4.2 迁移WCF的双工通信</h3><h4 id=\"1、WCF中的双工通信示例\"><a href=\"#1、WCF中的双工通信示例\" class=\"headerlink\" title=\"1、WCF中的双工通信示例\"></a>1、WCF中的双工通信示例</h4><p>在WCF中，双工（Duplex）通信很常用，在通信过程中，双方都可以向对方发送消息，使得很容易的就实现了服务端回调客户端。</p>\n<p>在这种模式下，客户端向服务端调用一个方法，然后在服务端回调客户端方法，可以理解为双方的位置发生了改变，此时的服务端变成了客户端，而客户端变成了服务端。</p>\n<p>如图所示。  </p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-mirgate-wcf-to-grpc/wcf-callback.png\" alt=\"image-20191130140814321\"></li>\n</ul>\n<p>代码如下：</p>\n<ol>\n<li><p>服务端：</p>\n<ul>\n<li>订定契约HelloCallback，用于处理回调的逻辑。</li>\n<li>订定契约UserService 和 UserServiceImpl，并定义了一个 GetUser 方法。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 用于回调的Hello方法</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">[ServiceContract]</span><br><span class=\"line\">public interface HelloCallback</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [OperationContract(IsOneWay = true)]</span><br><span class=\"line\">    void SayHelloworld(string msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 用户服务,并回调客户端到HelloCallback</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">[ServiceContract(SessionMode = SessionMode.Required, CallbackContract = typeof(HelloCallback))]</span><br><span class=\"line\">public interface UserService</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [OperationContract(IsOneWay = true)]</span><br><span class=\"line\">    void GetUser(string userName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 用户服务</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">[ServiceBehavior(InstanceContextMode = InstanceContextMode.PerSession)]</span><br><span class=\"line\">public class UserServiceImpl : UserService</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    HelloCallback callback;</span><br><span class=\"line\">    public void GetUser(string userName)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.Write(userName);</span><br><span class=\"line\">        OperationContext context = OperationContext.Current;</span><br><span class=\"line\">        callback = context.GetCallbackChannel&lt;HelloCallback&gt;();</span><br><span class=\"line\">        callback.SayHelloworld($&quot;&#123;userName&#125;:hello&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启动服务端程序时，需要创建服务端的Host主机信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> private static ServiceHost StartUserService()</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     var host = new ServiceHost(typeof(UserServiceImpl));</span><br><span class=\"line\">     var binding = new NetTcpBinding(SecurityMode.None);</span><br><span class=\"line\">     host.AddServiceEndpoint(typeof(UserService), binding,</span><br><span class=\"line\">     &quot;net.tcp://localhost:12384/userservice&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    host.Open();</span><br><span class=\"line\">    return host;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>客户端：</p>\n<ul>\n<li><p>订定契约HelloCallback 和客户端的契约实现 HelloCallbackImpl 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 回调Hello方法</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">[ServiceContract]</span><br><span class=\"line\">public interface HelloCallback</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [OperationContract(IsOneWay = true)]</span><br><span class=\"line\">    void SayHelloworld(string msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class HelloCallbackImpl : HelloCallback</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public void SayHelloworld(string msg)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \tConsole.Write(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>订定契约UserService，用以保持和服务端的契约保持一致。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;summary&gt;</span><br><span class=\"line\">/// 用户服务</span><br><span class=\"line\">/// &lt;/summary&gt;</span><br><span class=\"line\">[ServiceContract(CallbackContract = typeof(HelloCallback))]</span><br><span class=\"line\">public interface UserService</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [OperationContract(IsOneWay = true)]</span><br><span class=\"line\">    void GetUser(string userName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端启动时，连接到服务端。并发送GetUser方法。 </p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void GetUser(NetTcpBinding binding)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            var address = new EndpointAddress(&quot;net.tcp://localhost:12384/userservice&quot;);</span><br><span class=\"line\">            var factory =</span><br><span class=\"line\">                new DuplexChannelFactory&lt;UserService&gt;(typeof(HelloCallbackImpl), binding,</span><br><span class=\"line\">                    address);</span><br><span class=\"line\">            var context = new InstanceContext(new HelloCallbackImpl());</span><br><span class=\"line\">            var server = factory.CreateChannel(context);</span><br><span class=\"line\"></span><br><span class=\"line\">            server.GetUser(&quot;zhangssan&quot;);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-mirgate-wcf-to-grpc/result.png\" alt=\"image-20191130144237825\"></p>\n<p>这是一个典型的WCF双工通信的示例，在传统的.NET Framework开发中可能非常常见，但是该如何才能迁移到gRPC服务中呢？</p>\n<h4 id=\"2、gRPC中的代码实现\"><a href=\"#2、gRPC中的代码实现\" class=\"headerlink\" title=\"2、gRPC中的代码实现\"></a>2、gRPC中的代码实现</h4><ul>\n<li>流程说明</li>\n</ul>\n<p>gRPC中实现此双工通信，需要使用来自服务端的单向流来实现，但在gRPC中不能直接回调对应的方法，而是在服务端将流返回后，触发对应客户端代码中的方法来实现这个回调的流程。</p>\n<p>如图所示： </p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-mirgate-wcf-to-grpc/grpc-callback.png\" alt=\"image-20191130214340416\"></p>\n<ul>\n<li><p>代码实现流程：</p>\n<p>1、定义 proto 协议文件</p>\n<p>请求方法为getUser，并返回流。首先定义服务协议文件，命名为 userService.proto 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = &quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">option csharp_namespace = &quot;DulpexGrpcDemo&quot;; </span><br><span class=\"line\"></span><br><span class=\"line\">package DulpexGrpcDemo;</span><br><span class=\"line\"></span><br><span class=\"line\">service userService &#123;</span><br><span class=\"line\">  rpc GetUser (HelloRequest) returns (stream HelloReply);  </span><br><span class=\"line\">  rpc GetTest (HelloRequest) returns (HelloReply);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">message HelloReply&#123;</span><br><span class=\"line\">\tstring msg=1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">message HelloRequest&#123;</span><br><span class=\"line\">\tstring msg=1; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、服务端实现</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class UserServiceImpl : userService.userServiceBase</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        public override async Task GetUser(HelloRequest request, IServerStreamWriter&lt;HelloReply&gt; responseStream, ServerCallContext context)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            await DoSomeThing(request.Msg, (msg) =&gt; &#123; responseStream.WriteAsync(new HelloReply &#123; Msg = $&quot;&#123;msg&#125;:hello&quot; &#125;); &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //处理回调逻辑</span><br><span class=\"line\">        private async Task DoSomeThing(string msg, Action&lt;string&gt; action)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Console.WriteLine(msg);</span><br><span class=\"line\">            action?.Invoke(msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public override Task&lt;HelloReply&gt; GetTest(HelloRequest request, ServerCallContext context)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Console.WriteLine(request.Msg);</span><br><span class=\"line\">            return Task.FromResult(new HelloReply &#123; Msg = $&quot;&#123;request.Msg&#125;:hello&quot; &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>3、客户端实现（需要被调用的方法）</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface HelloCallback</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void SayHelloworld(string msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class HelloCallbackImpl : HelloCallback</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   public void SayHelloworld(string msg)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      Console.Write(msg);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、用户服务方法的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class UserServiceImpl</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     private userService.userServiceClient userServiceClient;</span><br><span class=\"line\">     private readonly HelloCallback _helloCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    public UserServiceImpl(userService.userServiceClient serviceClient, HelloCallback helloCallback)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        userServiceClient = serviceClient;</span><br><span class=\"line\">        _helloCallback = helloCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public async Task GetUser()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AsyncServerStreamingCall&lt;HelloReply&gt; stream = userServiceClient.GetUser(new HelloRequest &#123; Msg = &quot;张三&quot; &#125;);</span><br><span class=\"line\">        await Helloworld(stream.ResponseStream);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    async Task Helloworld(IAsyncStreamReader&lt;HelloReply&gt; stream)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        await foreach (var update in stream.ReadAllAsync())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _helloCallback.SayHelloworld(update.Msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5、客户端程序的入口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Program</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        static async Task Main(string[] args)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            IServiceCollection servicesCollection = new ServiceCollection();</span><br><span class=\"line\">            IConfiguration configuration = new ConfigurationBuilder()</span><br><span class=\"line\">                        .SetBasePath(Directory.GetCurrentDirectory()).AddJsonFile(&quot;appsettings.json&quot;, true, false).Build();</span><br><span class=\"line\"></span><br><span class=\"line\">        servicesCollection.AddGrpcClient&lt;userService.userServiceClient&gt;(</span><br><span class=\"line\">           o =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                o.Address = new Uri(&quot;https://localhost:5001&quot;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        servicesCollection.AddSingleton&lt;UserServiceImpl&gt;();</span><br><span class=\"line\">        servicesCollection.AddSingleton&lt;HelloCallback, HelloCallbackImpl&gt;();</span><br><span class=\"line\">        var userServiceImpl = servicesCollection.BuildServiceProvider().GetService&lt;UserServiceImpl&gt;();</span><br><span class=\"line\">        await userServiceImpl.GetUser();</span><br><span class=\"line\">        Console.ReadLine();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，从这个示例中，可能会觉得有点奇怪，明明可以使用请求-响应的简单RPC模式，为什么要使用服务端的单向流来实现了？</p>\n<p>这种单向流中，客户端无需等待服务端执行方法执行完，而是由服务端完成后续流程后，再回调客户端的方法，使得流程变得简单清晰。</p>\n<p>在微软的官方文档（参考文献1）更适合介绍这个迁移过程的单向流的实现，通过实现服务端向客户端推流的形式来介绍，只是方法相对而言实现的逻辑比较多，而鄙人这个示例则剥离了与让我们理解服务端单向流流程无关的部分，使得流程看起来更简单。</p>\n<p>参考文献</p>\n<p>[1] 官方文档： <a href=\"https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/migrate-duplex-services\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/migrate-duplex-services</a> </p>\n<p>[2] Jon Seeley的官方博客，如何迁移将wcf服务迁移到grpc：<a href=\"https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/\" target=\"_blank\" rel=\"noopener\">https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/</a> </p>\n<p>[3] Jon Seeley的官方博客，如何在.netcore中使用wcf：<a href=\"https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/\" target=\"_blank\" rel=\"noopener\">https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/</a> </p>\n"},{"title":"甲方爸爸，大概你要的是代码生成器吧？","date":"2020-05-08T11:49:00.000Z","author":"邹溪源","_content":"# 甲方爸爸，大概你要的是代码生成器吧？\n\n# 一\n\n### 1）\n\n有一天，我的朋友Y童鞋分享了他正在做的一个内部开源项目，这个开源项目从外表上看，跟目前市场上那些代码生成器本没有特别大的区别，所以我兴趣并不大。\n\n在他给我介绍了一下具体需求之后，我才体会了他的意思，并提起了那么一丢丢兴趣。。\n\n毕竟，听起来有点“鬼扯”，为啥？因为，他居然试图依靠这个项目来生成”单元测试“。。。。\n\n他：定义好数据库表和结构，然后就生成逻辑方法和代码、以及界面，还同时把“单元测试”代码给生成了，免得程序员要花时间去思考代码逻辑之余，还要想怎么写出可测试代码。\n\n我：这样生成的代码还有灵魂么。。\n\n他：有啊，编写高可测试代码，不就是我辈中人，这些有追求的码农应该实现的目标么？\n\n我：这种模式怎么越看越像埃里克埃文斯大佬说的“Smart UI”模式啊。。\n\n他：你倒这么说，也有那么一点点像。\n\n### 2）\n\n我：当然，能够生成单元测试倒也可以。毕竟大部分单元测试看起来似乎是一模一样的。无外乎就是“ Arrange\\Act\\Assert”，AAA操作猛如虎，测试代码一把梭。\n\n他：我这个东西，生成的代码，除了看起来提高了单元测试覆盖率之外，其实，并不能提高代码的质量。\n\n我：是什么逼得你要花时间去开发这样的代码生成器呢？\n\n他：还不是被这班菜鸡开发者们产出的劣质产品闹腾的。我不是想着省测试的钱，又能提高产品的质量么？就自然而然只能靠压榨“程序员”来实现了。但是让我来对这么多人的代码进行审查，还是太难了。这不，用单元测试来操作，不就可以了？\n\n### 3）\n\n我： 你们太难了。为啥这么赶啊？\n\n他：这不是甲方爸爸要加需求，他说得倒是好：加需求也就几行代码，多简单。但是我们这边，就得忙翻天，太特么累了。\n\n我：那能不能多招几个测试？\n\n他：端到端测试，只是看起来将缺陷扼杀在摇篮而已，实际上。。隐藏在冰山下的缺陷呢。。客户就是小白鼠啊。再说，我们现在家业太小，测试有两个了，再招就请不起了。。功能是不能少的，bug是不能多的，我只能想想单元测试这种办法了。\n\n我：好吧。。我们也一样。。\n\n\n\n## 二\n\n### 1）\n\n 之前有个朋友老张介绍了一个故事，仿佛跟这个有点类似。他有幸参与了一个交通信息化的项目，这个项目的业主是国企单位，属于“体制内”的企业。\n\n在过去一波有一波的信息化发展过程中，这些体制内的企业仿佛成为了许多IT企业竞相薅羊毛的对象。为啥，国企项目多、钱也不少，关键是国企对软件质量要求不高啊。\n\n 许多企业借助国企项目，他们依托所谓“快速上线”的神器，将中华民族艰苦奋斗的精神发挥到了极致，公司能够在最短的时间内，将原本停留在脑海里的软件，快速的转化成为实现，并部署到甲方爸爸的现场环境中。\n\n至于软件的质量、软件的工程化水平，对不起，不重要？用户体验？性能？功能可用性？重要么，不重要。先快速上线回款再说。于是，这些企业获得了业绩的腾飞，老板们赚得盆满簸赢，好不自在。\n\n而且老板们还会吹：我们公司最大的优点，就是在逆境下生存的能力，能够在最短的时间消化需求，做出最符合客户需求的软件。\n\n好吧，仿佛这也是软件工程的一种方向？快速开发。。。。\n\n### 2）\n\n然后，有那么几年，市场突然间就“做烂“了。一方面，国家将投资方向重点放在了房地产领域，对信息化的投入也逐渐收紧了许多；另外一方面，企业过去匆忙上线了太多的软件系统，不同软件系统之间的对接沟通困难，操作过程缺乏连贯性，使得基层员工开始抗拒这些”看似“能够带来效率提升，却容易出现各种质量问题导致自己过去几天工作量返工的所谓”信息化“系统；另外，大家也都很清楚，效率提升其实带来的是”裁员“，首先被裁的...\n\n总之，有那么一段时间，国企对信息化是“弃若敝屣”的。\n\n## 三\n\n### 1）\n\n但，随着“互联网”和“共享出行”的兴起，又让这个概念重新热炒了起来。\n\n老张他们公司也有幸接到了一个这样的项目，公司还是一家非常大的出租车公司，拥有二十多家子公司，员工超过2万人。这个项目的目的是打通出租车和旅客的关系，借助于手机实现快速出行，同时打通企业内部信息孤岛，让总公司领导能够第一时间看到各种数据的流转情况，为建立科学决策提供依据。\n\n老张被选为这个项目的负责人。在项目启动会上，他意气风发，向业主和公司老板们保证，将带领公司团队与甲方团队一起，以饱满的姿态打响这场战役，为业主的业绩腾飞贡献自己的一份力量。\n\n然而，但项目启动后，他才深刻的明白这究竟是一个怎样的坑。\n\n### 2）\n\n首先是业主关系，由于业主是一家涉及大几万员工和二十几家子公司的大型集团公司，需要梳理的业务表单非常复杂，业务流程和体系，远比甲方爸爸预想的要复杂得多。\n\n其次是开发周期短，不知从何时起，国企对于软件系统的印象就是“简单、容易、很快就能实现”，仿佛一个需求只要说出来，这般不要命的程序员们就能很快的实现功能。当老张跟他们提到需求太多，根本做不完时，甲方爸爸甚至说：怎么可能有做不出来的软件系统，是不是你能力不行？\n\n再次是外部系统多，由于不同的子公司往往采购了不同的系统，要统一对接到一个系统 。\n\n还有就是涉及的技术点多，需要在许多领域进行专门的技术攻关，由于公司暂时缺乏相关资源，使得开发过程屡屡收到阻塞。\n\n### 2）\n\n经过长达几个月的需求调研，老张编写了一份超过一千页纸的需求规格说明书，并获得了业主的批准，但项目正式开始时，他却只获得了短短半年的开发周期。此时，他手上能够调动的开发者资源，才不过10余人。\n\n为了干完这个项目，他和项目团队的成员不得不牺牲周末和假期，辛苦坚持了半年，才把项目功能都开发完，但在项目实施环节时，由于子公司与总公司的意见不统一，根本用不起来。\n\n最终，项目崩盘，公司倒闭，甲方将近一年的投入近乎白费。老张和项目团队也白白辛苦了大半年，还得去劳动仲裁，找老板讨薪。\n\n回顾这段时光时，老张说了一段话：\n\n“企业信息服务化的项目，看起来合同工价很高，其实都是坑啊。有的业主，根本不懂什么叫“合适的软件”。\n\n在互联网如此发展的今天，这些业主，要的还是“快速开发”。但凡想到什么就往里面加，程序员不猝死太难了。许多需求今天提，明天就要，但是用了一次呢这些功能就不用了，我根本不知道这些软件，干出来有什么意义。\n\n千万别跟业主提敏捷，他们会在你的每个迭代中塞根本干不完的工作量；也不要提拥抱变化，他们变起脸来，自己都怕。”\n\n## 四\n\n仔细想想，许多传统企业领导想转型到互联网，不就是这样么，恨不能一天就把项目干完，干完项目就“升官发财”，至于项目能不能用，谁知道呢。。\n\n也许，他们要的并不是软件，而是一种“代码生成器”。嗯，输入“甲方爸爸的一万种需求”，输出“一个功能齐全、包容万物、自由变化的软件”。。\n\n作为有追求的码农们，我们能像Robert大叔在《代码整洁之道-程序员的自我修养》一书中写的方法：选择“拒绝”么。\n\n额。。生存要紧。。偶尔吐吐槽，饭还是得恰啊。\n\n\n\n\n\n\n\n","source":"_posts/技术/甲方爸爸，大概你要的是代码生成器吧？.md","raw":"---\ntitle:  甲方爸爸，大概你要的是代码生成器吧？\ndate: 2020-5-08 19:49\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n# 甲方爸爸，大概你要的是代码生成器吧？\n\n# 一\n\n### 1）\n\n有一天，我的朋友Y童鞋分享了他正在做的一个内部开源项目，这个开源项目从外表上看，跟目前市场上那些代码生成器本没有特别大的区别，所以我兴趣并不大。\n\n在他给我介绍了一下具体需求之后，我才体会了他的意思，并提起了那么一丢丢兴趣。。\n\n毕竟，听起来有点“鬼扯”，为啥？因为，他居然试图依靠这个项目来生成”单元测试“。。。。\n\n他：定义好数据库表和结构，然后就生成逻辑方法和代码、以及界面，还同时把“单元测试”代码给生成了，免得程序员要花时间去思考代码逻辑之余，还要想怎么写出可测试代码。\n\n我：这样生成的代码还有灵魂么。。\n\n他：有啊，编写高可测试代码，不就是我辈中人，这些有追求的码农应该实现的目标么？\n\n我：这种模式怎么越看越像埃里克埃文斯大佬说的“Smart UI”模式啊。。\n\n他：你倒这么说，也有那么一点点像。\n\n### 2）\n\n我：当然，能够生成单元测试倒也可以。毕竟大部分单元测试看起来似乎是一模一样的。无外乎就是“ Arrange\\Act\\Assert”，AAA操作猛如虎，测试代码一把梭。\n\n他：我这个东西，生成的代码，除了看起来提高了单元测试覆盖率之外，其实，并不能提高代码的质量。\n\n我：是什么逼得你要花时间去开发这样的代码生成器呢？\n\n他：还不是被这班菜鸡开发者们产出的劣质产品闹腾的。我不是想着省测试的钱，又能提高产品的质量么？就自然而然只能靠压榨“程序员”来实现了。但是让我来对这么多人的代码进行审查，还是太难了。这不，用单元测试来操作，不就可以了？\n\n### 3）\n\n我： 你们太难了。为啥这么赶啊？\n\n他：这不是甲方爸爸要加需求，他说得倒是好：加需求也就几行代码，多简单。但是我们这边，就得忙翻天，太特么累了。\n\n我：那能不能多招几个测试？\n\n他：端到端测试，只是看起来将缺陷扼杀在摇篮而已，实际上。。隐藏在冰山下的缺陷呢。。客户就是小白鼠啊。再说，我们现在家业太小，测试有两个了，再招就请不起了。。功能是不能少的，bug是不能多的，我只能想想单元测试这种办法了。\n\n我：好吧。。我们也一样。。\n\n\n\n## 二\n\n### 1）\n\n 之前有个朋友老张介绍了一个故事，仿佛跟这个有点类似。他有幸参与了一个交通信息化的项目，这个项目的业主是国企单位，属于“体制内”的企业。\n\n在过去一波有一波的信息化发展过程中，这些体制内的企业仿佛成为了许多IT企业竞相薅羊毛的对象。为啥，国企项目多、钱也不少，关键是国企对软件质量要求不高啊。\n\n 许多企业借助国企项目，他们依托所谓“快速上线”的神器，将中华民族艰苦奋斗的精神发挥到了极致，公司能够在最短的时间内，将原本停留在脑海里的软件，快速的转化成为实现，并部署到甲方爸爸的现场环境中。\n\n至于软件的质量、软件的工程化水平，对不起，不重要？用户体验？性能？功能可用性？重要么，不重要。先快速上线回款再说。于是，这些企业获得了业绩的腾飞，老板们赚得盆满簸赢，好不自在。\n\n而且老板们还会吹：我们公司最大的优点，就是在逆境下生存的能力，能够在最短的时间消化需求，做出最符合客户需求的软件。\n\n好吧，仿佛这也是软件工程的一种方向？快速开发。。。。\n\n### 2）\n\n然后，有那么几年，市场突然间就“做烂“了。一方面，国家将投资方向重点放在了房地产领域，对信息化的投入也逐渐收紧了许多；另外一方面，企业过去匆忙上线了太多的软件系统，不同软件系统之间的对接沟通困难，操作过程缺乏连贯性，使得基层员工开始抗拒这些”看似“能够带来效率提升，却容易出现各种质量问题导致自己过去几天工作量返工的所谓”信息化“系统；另外，大家也都很清楚，效率提升其实带来的是”裁员“，首先被裁的...\n\n总之，有那么一段时间，国企对信息化是“弃若敝屣”的。\n\n## 三\n\n### 1）\n\n但，随着“互联网”和“共享出行”的兴起，又让这个概念重新热炒了起来。\n\n老张他们公司也有幸接到了一个这样的项目，公司还是一家非常大的出租车公司，拥有二十多家子公司，员工超过2万人。这个项目的目的是打通出租车和旅客的关系，借助于手机实现快速出行，同时打通企业内部信息孤岛，让总公司领导能够第一时间看到各种数据的流转情况，为建立科学决策提供依据。\n\n老张被选为这个项目的负责人。在项目启动会上，他意气风发，向业主和公司老板们保证，将带领公司团队与甲方团队一起，以饱满的姿态打响这场战役，为业主的业绩腾飞贡献自己的一份力量。\n\n然而，但项目启动后，他才深刻的明白这究竟是一个怎样的坑。\n\n### 2）\n\n首先是业主关系，由于业主是一家涉及大几万员工和二十几家子公司的大型集团公司，需要梳理的业务表单非常复杂，业务流程和体系，远比甲方爸爸预想的要复杂得多。\n\n其次是开发周期短，不知从何时起，国企对于软件系统的印象就是“简单、容易、很快就能实现”，仿佛一个需求只要说出来，这般不要命的程序员们就能很快的实现功能。当老张跟他们提到需求太多，根本做不完时，甲方爸爸甚至说：怎么可能有做不出来的软件系统，是不是你能力不行？\n\n再次是外部系统多，由于不同的子公司往往采购了不同的系统，要统一对接到一个系统 。\n\n还有就是涉及的技术点多，需要在许多领域进行专门的技术攻关，由于公司暂时缺乏相关资源，使得开发过程屡屡收到阻塞。\n\n### 2）\n\n经过长达几个月的需求调研，老张编写了一份超过一千页纸的需求规格说明书，并获得了业主的批准，但项目正式开始时，他却只获得了短短半年的开发周期。此时，他手上能够调动的开发者资源，才不过10余人。\n\n为了干完这个项目，他和项目团队的成员不得不牺牲周末和假期，辛苦坚持了半年，才把项目功能都开发完，但在项目实施环节时，由于子公司与总公司的意见不统一，根本用不起来。\n\n最终，项目崩盘，公司倒闭，甲方将近一年的投入近乎白费。老张和项目团队也白白辛苦了大半年，还得去劳动仲裁，找老板讨薪。\n\n回顾这段时光时，老张说了一段话：\n\n“企业信息服务化的项目，看起来合同工价很高，其实都是坑啊。有的业主，根本不懂什么叫“合适的软件”。\n\n在互联网如此发展的今天，这些业主，要的还是“快速开发”。但凡想到什么就往里面加，程序员不猝死太难了。许多需求今天提，明天就要，但是用了一次呢这些功能就不用了，我根本不知道这些软件，干出来有什么意义。\n\n千万别跟业主提敏捷，他们会在你的每个迭代中塞根本干不完的工作量；也不要提拥抱变化，他们变起脸来，自己都怕。”\n\n## 四\n\n仔细想想，许多传统企业领导想转型到互联网，不就是这样么，恨不能一天就把项目干完，干完项目就“升官发财”，至于项目能不能用，谁知道呢。。\n\n也许，他们要的并不是软件，而是一种“代码生成器”。嗯，输入“甲方爸爸的一万种需求”，输出“一个功能齐全、包容万物、自由变化的软件”。。\n\n作为有追求的码农们，我们能像Robert大叔在《代码整洁之道-程序员的自我修养》一书中写的方法：选择“拒绝”么。\n\n额。。生存要紧。。偶尔吐吐槽，饭还是得恰啊。\n\n\n\n\n\n\n\n","slug":"技术/甲方爸爸，大概你要的是代码生成器吧？","published":1,"updated":"2020-05-08T11:47:04.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt82001un4vil60alhw9","content":"<h1 id=\"甲方爸爸，大概你要的是代码生成器吧？\"><a href=\"#甲方爸爸，大概你要的是代码生成器吧？\" class=\"headerlink\" title=\"甲方爸爸，大概你要的是代码生成器吧？\"></a>甲方爸爸，大概你要的是代码生成器吧？</h1><h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><h3 id=\"1）\"><a href=\"#1）\" class=\"headerlink\" title=\"1）\"></a>1）</h3><p>有一天，我的朋友Y童鞋分享了他正在做的一个内部开源项目，这个开源项目从外表上看，跟目前市场上那些代码生成器本没有特别大的区别，所以我兴趣并不大。</p>\n<p>在他给我介绍了一下具体需求之后，我才体会了他的意思，并提起了那么一丢丢兴趣。。</p>\n<p>毕竟，听起来有点“鬼扯”，为啥？因为，他居然试图依靠这个项目来生成”单元测试“。。。。</p>\n<p>他：定义好数据库表和结构，然后就生成逻辑方法和代码、以及界面，还同时把“单元测试”代码给生成了，免得程序员要花时间去思考代码逻辑之余，还要想怎么写出可测试代码。</p>\n<p>我：这样生成的代码还有灵魂么。。</p>\n<p>他：有啊，编写高可测试代码，不就是我辈中人，这些有追求的码农应该实现的目标么？</p>\n<p>我：这种模式怎么越看越像埃里克埃文斯大佬说的“Smart UI”模式啊。。</p>\n<p>他：你倒这么说，也有那么一点点像。</p>\n<h3 id=\"2）\"><a href=\"#2）\" class=\"headerlink\" title=\"2）\"></a>2）</h3><p>我：当然，能够生成单元测试倒也可以。毕竟大部分单元测试看起来似乎是一模一样的。无外乎就是“ Arrange\\Act\\Assert”，AAA操作猛如虎，测试代码一把梭。</p>\n<p>他：我这个东西，生成的代码，除了看起来提高了单元测试覆盖率之外，其实，并不能提高代码的质量。</p>\n<p>我：是什么逼得你要花时间去开发这样的代码生成器呢？</p>\n<p>他：还不是被这班菜鸡开发者们产出的劣质产品闹腾的。我不是想着省测试的钱，又能提高产品的质量么？就自然而然只能靠压榨“程序员”来实现了。但是让我来对这么多人的代码进行审查，还是太难了。这不，用单元测试来操作，不就可以了？</p>\n<h3 id=\"3）\"><a href=\"#3）\" class=\"headerlink\" title=\"3）\"></a>3）</h3><p>我： 你们太难了。为啥这么赶啊？</p>\n<p>他：这不是甲方爸爸要加需求，他说得倒是好：加需求也就几行代码，多简单。但是我们这边，就得忙翻天，太特么累了。</p>\n<p>我：那能不能多招几个测试？</p>\n<p>他：端到端测试，只是看起来将缺陷扼杀在摇篮而已，实际上。。隐藏在冰山下的缺陷呢。。客户就是小白鼠啊。再说，我们现在家业太小，测试有两个了，再招就请不起了。。功能是不能少的，bug是不能多的，我只能想想单元测试这种办法了。</p>\n<p>我：好吧。。我们也一样。。</p>\n<h2 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h2><h3 id=\"1）-1\"><a href=\"#1）-1\" class=\"headerlink\" title=\"1）\"></a>1）</h3><p> 之前有个朋友老张介绍了一个故事，仿佛跟这个有点类似。他有幸参与了一个交通信息化的项目，这个项目的业主是国企单位，属于“体制内”的企业。</p>\n<p>在过去一波有一波的信息化发展过程中，这些体制内的企业仿佛成为了许多IT企业竞相薅羊毛的对象。为啥，国企项目多、钱也不少，关键是国企对软件质量要求不高啊。</p>\n<p> 许多企业借助国企项目，他们依托所谓“快速上线”的神器，将中华民族艰苦奋斗的精神发挥到了极致，公司能够在最短的时间内，将原本停留在脑海里的软件，快速的转化成为实现，并部署到甲方爸爸的现场环境中。</p>\n<p>至于软件的质量、软件的工程化水平，对不起，不重要？用户体验？性能？功能可用性？重要么，不重要。先快速上线回款再说。于是，这些企业获得了业绩的腾飞，老板们赚得盆满簸赢，好不自在。</p>\n<p>而且老板们还会吹：我们公司最大的优点，就是在逆境下生存的能力，能够在最短的时间消化需求，做出最符合客户需求的软件。</p>\n<p>好吧，仿佛这也是软件工程的一种方向？快速开发。。。。</p>\n<h3 id=\"2）-1\"><a href=\"#2）-1\" class=\"headerlink\" title=\"2）\"></a>2）</h3><p>然后，有那么几年，市场突然间就“做烂“了。一方面，国家将投资方向重点放在了房地产领域，对信息化的投入也逐渐收紧了许多；另外一方面，企业过去匆忙上线了太多的软件系统，不同软件系统之间的对接沟通困难，操作过程缺乏连贯性，使得基层员工开始抗拒这些”看似“能够带来效率提升，却容易出现各种质量问题导致自己过去几天工作量返工的所谓”信息化“系统；另外，大家也都很清楚，效率提升其实带来的是”裁员“，首先被裁的…</p>\n<p>总之，有那么一段时间，国企对信息化是“弃若敝屣”的。</p>\n<h2 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h2><h3 id=\"1）-2\"><a href=\"#1）-2\" class=\"headerlink\" title=\"1）\"></a>1）</h3><p>但，随着“互联网”和“共享出行”的兴起，又让这个概念重新热炒了起来。</p>\n<p>老张他们公司也有幸接到了一个这样的项目，公司还是一家非常大的出租车公司，拥有二十多家子公司，员工超过2万人。这个项目的目的是打通出租车和旅客的关系，借助于手机实现快速出行，同时打通企业内部信息孤岛，让总公司领导能够第一时间看到各种数据的流转情况，为建立科学决策提供依据。</p>\n<p>老张被选为这个项目的负责人。在项目启动会上，他意气风发，向业主和公司老板们保证，将带领公司团队与甲方团队一起，以饱满的姿态打响这场战役，为业主的业绩腾飞贡献自己的一份力量。</p>\n<p>然而，但项目启动后，他才深刻的明白这究竟是一个怎样的坑。</p>\n<h3 id=\"2）-2\"><a href=\"#2）-2\" class=\"headerlink\" title=\"2）\"></a>2）</h3><p>首先是业主关系，由于业主是一家涉及大几万员工和二十几家子公司的大型集团公司，需要梳理的业务表单非常复杂，业务流程和体系，远比甲方爸爸预想的要复杂得多。</p>\n<p>其次是开发周期短，不知从何时起，国企对于软件系统的印象就是“简单、容易、很快就能实现”，仿佛一个需求只要说出来，这般不要命的程序员们就能很快的实现功能。当老张跟他们提到需求太多，根本做不完时，甲方爸爸甚至说：怎么可能有做不出来的软件系统，是不是你能力不行？</p>\n<p>再次是外部系统多，由于不同的子公司往往采购了不同的系统，要统一对接到一个系统 。</p>\n<p>还有就是涉及的技术点多，需要在许多领域进行专门的技术攻关，由于公司暂时缺乏相关资源，使得开发过程屡屡收到阻塞。</p>\n<h3 id=\"2）-3\"><a href=\"#2）-3\" class=\"headerlink\" title=\"2）\"></a>2）</h3><p>经过长达几个月的需求调研，老张编写了一份超过一千页纸的需求规格说明书，并获得了业主的批准，但项目正式开始时，他却只获得了短短半年的开发周期。此时，他手上能够调动的开发者资源，才不过10余人。</p>\n<p>为了干完这个项目，他和项目团队的成员不得不牺牲周末和假期，辛苦坚持了半年，才把项目功能都开发完，但在项目实施环节时，由于子公司与总公司的意见不统一，根本用不起来。</p>\n<p>最终，项目崩盘，公司倒闭，甲方将近一年的投入近乎白费。老张和项目团队也白白辛苦了大半年，还得去劳动仲裁，找老板讨薪。</p>\n<p>回顾这段时光时，老张说了一段话：</p>\n<p>“企业信息服务化的项目，看起来合同工价很高，其实都是坑啊。有的业主，根本不懂什么叫“合适的软件”。</p>\n<p>在互联网如此发展的今天，这些业主，要的还是“快速开发”。但凡想到什么就往里面加，程序员不猝死太难了。许多需求今天提，明天就要，但是用了一次呢这些功能就不用了，我根本不知道这些软件，干出来有什么意义。</p>\n<p>千万别跟业主提敏捷，他们会在你的每个迭代中塞根本干不完的工作量；也不要提拥抱变化，他们变起脸来，自己都怕。”</p>\n<h2 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h2><p>仔细想想，许多传统企业领导想转型到互联网，不就是这样么，恨不能一天就把项目干完，干完项目就“升官发财”，至于项目能不能用，谁知道呢。。</p>\n<p>也许，他们要的并不是软件，而是一种“代码生成器”。嗯，输入“甲方爸爸的一万种需求”，输出“一个功能齐全、包容万物、自由变化的软件”。。</p>\n<p>作为有追求的码农们，我们能像Robert大叔在《代码整洁之道-程序员的自我修养》一书中写的方法：选择“拒绝”么。</p>\n<p>额。。生存要紧。。偶尔吐吐槽，饭还是得恰啊。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"甲方爸爸，大概你要的是代码生成器吧？\"><a href=\"#甲方爸爸，大概你要的是代码生成器吧？\" class=\"headerlink\" title=\"甲方爸爸，大概你要的是代码生成器吧？\"></a>甲方爸爸，大概你要的是代码生成器吧？</h1><h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><h3 id=\"1）\"><a href=\"#1）\" class=\"headerlink\" title=\"1）\"></a>1）</h3><p>有一天，我的朋友Y童鞋分享了他正在做的一个内部开源项目，这个开源项目从外表上看，跟目前市场上那些代码生成器本没有特别大的区别，所以我兴趣并不大。</p>\n<p>在他给我介绍了一下具体需求之后，我才体会了他的意思，并提起了那么一丢丢兴趣。。</p>\n<p>毕竟，听起来有点“鬼扯”，为啥？因为，他居然试图依靠这个项目来生成”单元测试“。。。。</p>\n<p>他：定义好数据库表和结构，然后就生成逻辑方法和代码、以及界面，还同时把“单元测试”代码给生成了，免得程序员要花时间去思考代码逻辑之余，还要想怎么写出可测试代码。</p>\n<p>我：这样生成的代码还有灵魂么。。</p>\n<p>他：有啊，编写高可测试代码，不就是我辈中人，这些有追求的码农应该实现的目标么？</p>\n<p>我：这种模式怎么越看越像埃里克埃文斯大佬说的“Smart UI”模式啊。。</p>\n<p>他：你倒这么说，也有那么一点点像。</p>\n<h3 id=\"2）\"><a href=\"#2）\" class=\"headerlink\" title=\"2）\"></a>2）</h3><p>我：当然，能够生成单元测试倒也可以。毕竟大部分单元测试看起来似乎是一模一样的。无外乎就是“ Arrange\\Act\\Assert”，AAA操作猛如虎，测试代码一把梭。</p>\n<p>他：我这个东西，生成的代码，除了看起来提高了单元测试覆盖率之外，其实，并不能提高代码的质量。</p>\n<p>我：是什么逼得你要花时间去开发这样的代码生成器呢？</p>\n<p>他：还不是被这班菜鸡开发者们产出的劣质产品闹腾的。我不是想着省测试的钱，又能提高产品的质量么？就自然而然只能靠压榨“程序员”来实现了。但是让我来对这么多人的代码进行审查，还是太难了。这不，用单元测试来操作，不就可以了？</p>\n<h3 id=\"3）\"><a href=\"#3）\" class=\"headerlink\" title=\"3）\"></a>3）</h3><p>我： 你们太难了。为啥这么赶啊？</p>\n<p>他：这不是甲方爸爸要加需求，他说得倒是好：加需求也就几行代码，多简单。但是我们这边，就得忙翻天，太特么累了。</p>\n<p>我：那能不能多招几个测试？</p>\n<p>他：端到端测试，只是看起来将缺陷扼杀在摇篮而已，实际上。。隐藏在冰山下的缺陷呢。。客户就是小白鼠啊。再说，我们现在家业太小，测试有两个了，再招就请不起了。。功能是不能少的，bug是不能多的，我只能想想单元测试这种办法了。</p>\n<p>我：好吧。。我们也一样。。</p>\n<h2 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h2><h3 id=\"1）-1\"><a href=\"#1）-1\" class=\"headerlink\" title=\"1）\"></a>1）</h3><p> 之前有个朋友老张介绍了一个故事，仿佛跟这个有点类似。他有幸参与了一个交通信息化的项目，这个项目的业主是国企单位，属于“体制内”的企业。</p>\n<p>在过去一波有一波的信息化发展过程中，这些体制内的企业仿佛成为了许多IT企业竞相薅羊毛的对象。为啥，国企项目多、钱也不少，关键是国企对软件质量要求不高啊。</p>\n<p> 许多企业借助国企项目，他们依托所谓“快速上线”的神器，将中华民族艰苦奋斗的精神发挥到了极致，公司能够在最短的时间内，将原本停留在脑海里的软件，快速的转化成为实现，并部署到甲方爸爸的现场环境中。</p>\n<p>至于软件的质量、软件的工程化水平，对不起，不重要？用户体验？性能？功能可用性？重要么，不重要。先快速上线回款再说。于是，这些企业获得了业绩的腾飞，老板们赚得盆满簸赢，好不自在。</p>\n<p>而且老板们还会吹：我们公司最大的优点，就是在逆境下生存的能力，能够在最短的时间消化需求，做出最符合客户需求的软件。</p>\n<p>好吧，仿佛这也是软件工程的一种方向？快速开发。。。。</p>\n<h3 id=\"2）-1\"><a href=\"#2）-1\" class=\"headerlink\" title=\"2）\"></a>2）</h3><p>然后，有那么几年，市场突然间就“做烂“了。一方面，国家将投资方向重点放在了房地产领域，对信息化的投入也逐渐收紧了许多；另外一方面，企业过去匆忙上线了太多的软件系统，不同软件系统之间的对接沟通困难，操作过程缺乏连贯性，使得基层员工开始抗拒这些”看似“能够带来效率提升，却容易出现各种质量问题导致自己过去几天工作量返工的所谓”信息化“系统；另外，大家也都很清楚，效率提升其实带来的是”裁员“，首先被裁的…</p>\n<p>总之，有那么一段时间，国企对信息化是“弃若敝屣”的。</p>\n<h2 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h2><h3 id=\"1）-2\"><a href=\"#1）-2\" class=\"headerlink\" title=\"1）\"></a>1）</h3><p>但，随着“互联网”和“共享出行”的兴起，又让这个概念重新热炒了起来。</p>\n<p>老张他们公司也有幸接到了一个这样的项目，公司还是一家非常大的出租车公司，拥有二十多家子公司，员工超过2万人。这个项目的目的是打通出租车和旅客的关系，借助于手机实现快速出行，同时打通企业内部信息孤岛，让总公司领导能够第一时间看到各种数据的流转情况，为建立科学决策提供依据。</p>\n<p>老张被选为这个项目的负责人。在项目启动会上，他意气风发，向业主和公司老板们保证，将带领公司团队与甲方团队一起，以饱满的姿态打响这场战役，为业主的业绩腾飞贡献自己的一份力量。</p>\n<p>然而，但项目启动后，他才深刻的明白这究竟是一个怎样的坑。</p>\n<h3 id=\"2）-2\"><a href=\"#2）-2\" class=\"headerlink\" title=\"2）\"></a>2）</h3><p>首先是业主关系，由于业主是一家涉及大几万员工和二十几家子公司的大型集团公司，需要梳理的业务表单非常复杂，业务流程和体系，远比甲方爸爸预想的要复杂得多。</p>\n<p>其次是开发周期短，不知从何时起，国企对于软件系统的印象就是“简单、容易、很快就能实现”，仿佛一个需求只要说出来，这般不要命的程序员们就能很快的实现功能。当老张跟他们提到需求太多，根本做不完时，甲方爸爸甚至说：怎么可能有做不出来的软件系统，是不是你能力不行？</p>\n<p>再次是外部系统多，由于不同的子公司往往采购了不同的系统，要统一对接到一个系统 。</p>\n<p>还有就是涉及的技术点多，需要在许多领域进行专门的技术攻关，由于公司暂时缺乏相关资源，使得开发过程屡屡收到阻塞。</p>\n<h3 id=\"2）-3\"><a href=\"#2）-3\" class=\"headerlink\" title=\"2）\"></a>2）</h3><p>经过长达几个月的需求调研，老张编写了一份超过一千页纸的需求规格说明书，并获得了业主的批准，但项目正式开始时，他却只获得了短短半年的开发周期。此时，他手上能够调动的开发者资源，才不过10余人。</p>\n<p>为了干完这个项目，他和项目团队的成员不得不牺牲周末和假期，辛苦坚持了半年，才把项目功能都开发完，但在项目实施环节时，由于子公司与总公司的意见不统一，根本用不起来。</p>\n<p>最终，项目崩盘，公司倒闭，甲方将近一年的投入近乎白费。老张和项目团队也白白辛苦了大半年，还得去劳动仲裁，找老板讨薪。</p>\n<p>回顾这段时光时，老张说了一段话：</p>\n<p>“企业信息服务化的项目，看起来合同工价很高，其实都是坑啊。有的业主，根本不懂什么叫“合适的软件”。</p>\n<p>在互联网如此发展的今天，这些业主，要的还是“快速开发”。但凡想到什么就往里面加，程序员不猝死太难了。许多需求今天提，明天就要，但是用了一次呢这些功能就不用了，我根本不知道这些软件，干出来有什么意义。</p>\n<p>千万别跟业主提敏捷，他们会在你的每个迭代中塞根本干不完的工作量；也不要提拥抱变化，他们变起脸来，自己都怕。”</p>\n<h2 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h2><p>仔细想想，许多传统企业领导想转型到互联网，不就是这样么，恨不能一天就把项目干完，干完项目就“升官发财”，至于项目能不能用，谁知道呢。。</p>\n<p>也许，他们要的并不是软件，而是一种“代码生成器”。嗯，输入“甲方爸爸的一万种需求”，输出“一个功能齐全、包容万物、自由变化的软件”。。</p>\n<p>作为有追求的码农们，我们能像Robert大叔在《代码整洁之道-程序员的自我修养》一书中写的方法：选择“拒绝”么。</p>\n<p>额。。生存要紧。。偶尔吐吐槽，饭还是得恰啊。</p>\n"},{"title":"在.NET  Core/Framework中使用依赖注入框架","date":"2019-12-01T08:28:00.000Z","author":"邹溪源","_content":"\n# 在.NET  Core/Framework中使用依赖注入框架\n\n## 综述\n\n在传统的.NET Framework中通常会使用 new 关键词和静态对象或静态方法作为对象创建的形式，但是由于这两种方式存在以下缺陷：\n\n##### 使用New的方式创建对象的缺陷：\n\n1、使用New的方式创建的对象，需要在由GC在不同的位置分别管理生命周期。\n2、如果在不同的方法中需要创建相同的对象，往往需要用很多个new来进行管理。\n3、当一个对象有多个子类时，创建的过程更加麻烦。\n\n#### 使用静态变量的缺陷。\n\n1、静态变量的内存空间是应用程序启动时创建、并在程序消亡时统一释放。\n2、在高并发场景下，静态变量容易被不同的线程频繁读写，从而成为系统的主要性能瓶颈。\n\n## 为啥要使用依赖注入\n\n在.NET Core或.NET FX中目前已经倾向于使用依赖注入框架来对对象的创建过程进行统一管理，这样的好处：\n1、封装了对象的创建过程，可以实现对象创建过程和内存管理过程的一致性，\n2、如果一个对象有多个实现，也容易使用依赖注入对象对其进行拆分。\n3、提供统一的对象生命周期管理。\n\n## 依赖注入的生命周期\n\n目前在.NET Core（.NET FX也有）中提供了3种依赖注入的生命周期，分别是：\n1、单例的生命周期SingleTon。每次从同根容器中（同根 IServiceProvider）获取的时候都是同一个实例，类似于静态变量。主要用来存储系统中需要保持唯一一份的对象\n2、瞬时的生命周期Transient。每次从容器 （IServiceProvider）中获取的时候都是一个新的实例，可以用于 控制台程序。\n3、作用域的生命周期Scoped。每次从同一个容器中获取的实例是相同的。往往用于ASP.NET Core 网站。\n使用依赖注入的方式实现对象的创建虽然会给程序带来一点不便利，但是容易实现程序的耦合度降低，更有利于程序未来的横向扩展，也逐渐成为ASP.NET开发（不仅仅是.NET Core）的的一种最佳实践。\n\n## 依赖注入的使用\n\n目前.NET中的依赖注入组件是基于.NET Strandard（标准库）进行开发的无其他依赖项的组件，能够被基于标准库的各种.NET技术方案所实现。\n主要分为两个步骤，\n1：初始化时，将对象注册到依赖注入组件中；例如：\n\n```C#\n serviceCollection.AddScoped<DBContext>();\n```\n\n2：对象使用时，从依赖注入组件中取出对象。\n\n```C#\nvar dbContext = MyServiceProvider.GetService<DBContext>(); \n```\n\n从依赖注入组件中取出对象的过程，往往会伴随着对象创建的过程，即在依赖注入框架内部，封装了原来与 New 一致的流程。\n\n如果一个对象如果需要引用的对象已经被注册到依赖注入组件中，则无需使用 GetService 方法从依赖注入组件中取出对象，依赖注入框架在创建对象时，也会连带着将其他与之相关的对象一起创建。\n\n### 示例\n\n例如：\n1、在示例代码中，设置 DBContext 为 Scoped \n\n```C#\nserviceCollection.AddScoped<DBContext>();\n```\n\n```C#\n static ServiceProvider MyServiceProvider;\n        static void Main(string[] args)\n        {\n            IServiceCollection serviceCollection = new ServiceCollection();\n            serviceCollection.UseDBContext();\n            serviceCollection.UseDBService();\n            serviceCollection.UseAppService();\n            MyServiceProvider = serviceCollection.BuildServiceProvider();\n            var dbContext = MyServiceProvider.GetService<DBContext>();\n            dbContext.DBConfig = \"127.0.0.1\";\n            TestSingleTon();\n            TestTransient();\n            Console.ReadKey();\n        }\n        static void TestSingleTon()\n        {\n            for (int i = 0; i < 5; i++)\n            {\n                var task = new Task(() =>\n                { \n                    var dbService = MyServiceProvider.GetService<UserDbService>();\n                    Console.WriteLine(dbService.GetDBConfig());\n                    Console.WriteLine(\"设置用户名为张三\");\n                    dbService.UserName = \"张三\" + i;\n                });\n                task.Wait(100);\n                task.Start();\n            }\n        }\n        static void TestTransient()\n        {\n\n            for (int i = 0; i < 5; i++)\n            {\n                var task = new Task(() =>\n                {\n                    var userAppService = MyServiceProvider.GetService<UserAppService>();\n                    Console.WriteLine($\"获取数据库中的用户名:{userAppService.GetDBUserName()}\");\n                });\n                task.Wait(200);\n                task.Start();\n            }\n        }\n```\n\n那么在创建 UserDbService 对象时，依赖注入框架会自动创建dbContext对象，并将其注入到 UserDbService中。\n\n```C#\npublic UserDbService(DBContext dBContext)\n```\n\n这样就封装了原来的\n\n```C#\n IUserDBService dbService=new UserDBService(new DBContext()); \n```\n\n的代码过程，弥补了调用者需要与UserDBService 高度耦合的缺陷。\n\n## 值得注意的是：\n\n1、在.NET Core（.NET Framework) 控制台中，需要手动创建对象IServiceCollection，并创建一个静态的 ServiceProvider 对象，由这个对象来实现对象的加载。\n2、在.NET Core 网站项目中，由WebHost管理的生命周期，会创建一个统一的 IServiceCollection和 ServiceProvider 对象，无需再单独创建这个ServiceProvider. \n \n\n## 示例代码\n\n在示例代码中，提供了一个DIExtension的静态类，并定义了三个注册对象的方法。\n\n```C#\npublic static IServiceCollection UseDBContext(this IServiceCollection serviceCollection)\n        {\n            serviceCollection.AddScoped<DBContext>();\n            return serviceCollection;\n        }\n        public static IServiceCollection UseDBService(this IServiceCollection serviceCollection)\n        {\n            serviceCollection.AddSingleton<UserDbService>();\n            return serviceCollection;\n        }\n        public static IServiceCollection UseAppService(this IServiceCollection serviceCollection)\n        {\n            serviceCollection.AddTransient<UserAppService>();\n            return serviceCollection;\n        }\n```","source":"_posts/技术/简述介绍.NET Core中的依赖注入方法.md","raw":"---\ntitle:  在.NET  Core/Framework中使用依赖注入框架\ndate: 2019-12-1 16:28\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n\n# 在.NET  Core/Framework中使用依赖注入框架\n\n## 综述\n\n在传统的.NET Framework中通常会使用 new 关键词和静态对象或静态方法作为对象创建的形式，但是由于这两种方式存在以下缺陷：\n\n##### 使用New的方式创建对象的缺陷：\n\n1、使用New的方式创建的对象，需要在由GC在不同的位置分别管理生命周期。\n2、如果在不同的方法中需要创建相同的对象，往往需要用很多个new来进行管理。\n3、当一个对象有多个子类时，创建的过程更加麻烦。\n\n#### 使用静态变量的缺陷。\n\n1、静态变量的内存空间是应用程序启动时创建、并在程序消亡时统一释放。\n2、在高并发场景下，静态变量容易被不同的线程频繁读写，从而成为系统的主要性能瓶颈。\n\n## 为啥要使用依赖注入\n\n在.NET Core或.NET FX中目前已经倾向于使用依赖注入框架来对对象的创建过程进行统一管理，这样的好处：\n1、封装了对象的创建过程，可以实现对象创建过程和内存管理过程的一致性，\n2、如果一个对象有多个实现，也容易使用依赖注入对象对其进行拆分。\n3、提供统一的对象生命周期管理。\n\n## 依赖注入的生命周期\n\n目前在.NET Core（.NET FX也有）中提供了3种依赖注入的生命周期，分别是：\n1、单例的生命周期SingleTon。每次从同根容器中（同根 IServiceProvider）获取的时候都是同一个实例，类似于静态变量。主要用来存储系统中需要保持唯一一份的对象\n2、瞬时的生命周期Transient。每次从容器 （IServiceProvider）中获取的时候都是一个新的实例，可以用于 控制台程序。\n3、作用域的生命周期Scoped。每次从同一个容器中获取的实例是相同的。往往用于ASP.NET Core 网站。\n使用依赖注入的方式实现对象的创建虽然会给程序带来一点不便利，但是容易实现程序的耦合度降低，更有利于程序未来的横向扩展，也逐渐成为ASP.NET开发（不仅仅是.NET Core）的的一种最佳实践。\n\n## 依赖注入的使用\n\n目前.NET中的依赖注入组件是基于.NET Strandard（标准库）进行开发的无其他依赖项的组件，能够被基于标准库的各种.NET技术方案所实现。\n主要分为两个步骤，\n1：初始化时，将对象注册到依赖注入组件中；例如：\n\n```C#\n serviceCollection.AddScoped<DBContext>();\n```\n\n2：对象使用时，从依赖注入组件中取出对象。\n\n```C#\nvar dbContext = MyServiceProvider.GetService<DBContext>(); \n```\n\n从依赖注入组件中取出对象的过程，往往会伴随着对象创建的过程，即在依赖注入框架内部，封装了原来与 New 一致的流程。\n\n如果一个对象如果需要引用的对象已经被注册到依赖注入组件中，则无需使用 GetService 方法从依赖注入组件中取出对象，依赖注入框架在创建对象时，也会连带着将其他与之相关的对象一起创建。\n\n### 示例\n\n例如：\n1、在示例代码中，设置 DBContext 为 Scoped \n\n```C#\nserviceCollection.AddScoped<DBContext>();\n```\n\n```C#\n static ServiceProvider MyServiceProvider;\n        static void Main(string[] args)\n        {\n            IServiceCollection serviceCollection = new ServiceCollection();\n            serviceCollection.UseDBContext();\n            serviceCollection.UseDBService();\n            serviceCollection.UseAppService();\n            MyServiceProvider = serviceCollection.BuildServiceProvider();\n            var dbContext = MyServiceProvider.GetService<DBContext>();\n            dbContext.DBConfig = \"127.0.0.1\";\n            TestSingleTon();\n            TestTransient();\n            Console.ReadKey();\n        }\n        static void TestSingleTon()\n        {\n            for (int i = 0; i < 5; i++)\n            {\n                var task = new Task(() =>\n                { \n                    var dbService = MyServiceProvider.GetService<UserDbService>();\n                    Console.WriteLine(dbService.GetDBConfig());\n                    Console.WriteLine(\"设置用户名为张三\");\n                    dbService.UserName = \"张三\" + i;\n                });\n                task.Wait(100);\n                task.Start();\n            }\n        }\n        static void TestTransient()\n        {\n\n            for (int i = 0; i < 5; i++)\n            {\n                var task = new Task(() =>\n                {\n                    var userAppService = MyServiceProvider.GetService<UserAppService>();\n                    Console.WriteLine($\"获取数据库中的用户名:{userAppService.GetDBUserName()}\");\n                });\n                task.Wait(200);\n                task.Start();\n            }\n        }\n```\n\n那么在创建 UserDbService 对象时，依赖注入框架会自动创建dbContext对象，并将其注入到 UserDbService中。\n\n```C#\npublic UserDbService(DBContext dBContext)\n```\n\n这样就封装了原来的\n\n```C#\n IUserDBService dbService=new UserDBService(new DBContext()); \n```\n\n的代码过程，弥补了调用者需要与UserDBService 高度耦合的缺陷。\n\n## 值得注意的是：\n\n1、在.NET Core（.NET Framework) 控制台中，需要手动创建对象IServiceCollection，并创建一个静态的 ServiceProvider 对象，由这个对象来实现对象的加载。\n2、在.NET Core 网站项目中，由WebHost管理的生命周期，会创建一个统一的 IServiceCollection和 ServiceProvider 对象，无需再单独创建这个ServiceProvider. \n \n\n## 示例代码\n\n在示例代码中，提供了一个DIExtension的静态类，并定义了三个注册对象的方法。\n\n```C#\npublic static IServiceCollection UseDBContext(this IServiceCollection serviceCollection)\n        {\n            serviceCollection.AddScoped<DBContext>();\n            return serviceCollection;\n        }\n        public static IServiceCollection UseDBService(this IServiceCollection serviceCollection)\n        {\n            serviceCollection.AddSingleton<UserDbService>();\n            return serviceCollection;\n        }\n        public static IServiceCollection UseAppService(this IServiceCollection serviceCollection)\n        {\n            serviceCollection.AddTransient<UserAppService>();\n            return serviceCollection;\n        }\n```","slug":"技术/简述介绍.NET Core中的依赖注入方法","published":1,"updated":"2019-12-09T15:06:32.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt85001xn4vijsp5hrys","content":"<h1 id=\"在-NET-Core-Framework中使用依赖注入框架\"><a href=\"#在-NET-Core-Framework中使用依赖注入框架\" class=\"headerlink\" title=\"在.NET  Core/Framework中使用依赖注入框架\"></a>在.NET  Core/Framework中使用依赖注入框架</h1><h2 id=\"综述\"><a href=\"#综述\" class=\"headerlink\" title=\"综述\"></a>综述</h2><p>在传统的.NET Framework中通常会使用 new 关键词和静态对象或静态方法作为对象创建的形式，但是由于这两种方式存在以下缺陷：</p>\n<h5 id=\"使用New的方式创建对象的缺陷：\"><a href=\"#使用New的方式创建对象的缺陷：\" class=\"headerlink\" title=\"使用New的方式创建对象的缺陷：\"></a>使用New的方式创建对象的缺陷：</h5><p>1、使用New的方式创建的对象，需要在由GC在不同的位置分别管理生命周期。<br>2、如果在不同的方法中需要创建相同的对象，往往需要用很多个new来进行管理。<br>3、当一个对象有多个子类时，创建的过程更加麻烦。</p>\n<h4 id=\"使用静态变量的缺陷。\"><a href=\"#使用静态变量的缺陷。\" class=\"headerlink\" title=\"使用静态变量的缺陷。\"></a>使用静态变量的缺陷。</h4><p>1、静态变量的内存空间是应用程序启动时创建、并在程序消亡时统一释放。<br>2、在高并发场景下，静态变量容易被不同的线程频繁读写，从而成为系统的主要性能瓶颈。</p>\n<h2 id=\"为啥要使用依赖注入\"><a href=\"#为啥要使用依赖注入\" class=\"headerlink\" title=\"为啥要使用依赖注入\"></a>为啥要使用依赖注入</h2><p>在.NET Core或.NET FX中目前已经倾向于使用依赖注入框架来对对象的创建过程进行统一管理，这样的好处：<br>1、封装了对象的创建过程，可以实现对象创建过程和内存管理过程的一致性，<br>2、如果一个对象有多个实现，也容易使用依赖注入对象对其进行拆分。<br>3、提供统一的对象生命周期管理。</p>\n<h2 id=\"依赖注入的生命周期\"><a href=\"#依赖注入的生命周期\" class=\"headerlink\" title=\"依赖注入的生命周期\"></a>依赖注入的生命周期</h2><p>目前在.NET Core（.NET FX也有）中提供了3种依赖注入的生命周期，分别是：<br>1、单例的生命周期SingleTon。每次从同根容器中（同根 IServiceProvider）获取的时候都是同一个实例，类似于静态变量。主要用来存储系统中需要保持唯一一份的对象<br>2、瞬时的生命周期Transient。每次从容器 （IServiceProvider）中获取的时候都是一个新的实例，可以用于 控制台程序。<br>3、作用域的生命周期Scoped。每次从同一个容器中获取的实例是相同的。往往用于ASP.NET Core 网站。<br>使用依赖注入的方式实现对象的创建虽然会给程序带来一点不便利，但是容易实现程序的耦合度降低，更有利于程序未来的横向扩展，也逐渐成为ASP.NET开发（不仅仅是.NET Core）的的一种最佳实践。</p>\n<h2 id=\"依赖注入的使用\"><a href=\"#依赖注入的使用\" class=\"headerlink\" title=\"依赖注入的使用\"></a>依赖注入的使用</h2><p>目前.NET中的依赖注入组件是基于.NET Strandard（标准库）进行开发的无其他依赖项的组件，能够被基于标准库的各种.NET技术方案所实现。<br>主要分为两个步骤，<br>1：初始化时，将对象注册到依赖注入组件中；例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">serviceCollection.AddScoped&lt;DBContext&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>2：对象使用时，从依赖注入组件中取出对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dbContext = MyServiceProvider.GetService&lt;DBContext&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>从依赖注入组件中取出对象的过程，往往会伴随着对象创建的过程，即在依赖注入框架内部，封装了原来与 New 一致的流程。</p>\n<p>如果一个对象如果需要引用的对象已经被注册到依赖注入组件中，则无需使用 GetService 方法从依赖注入组件中取出对象，依赖注入框架在创建对象时，也会连带着将其他与之相关的对象一起创建。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>例如：<br>1、在示例代码中，设置 DBContext 为 Scoped </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">serviceCollection.AddScoped&lt;DBContext&gt;();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static ServiceProvider MyServiceProvider;</span><br><span class=\"line\">       static void Main(string[] args)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           IServiceCollection serviceCollection = new ServiceCollection();</span><br><span class=\"line\">           serviceCollection.UseDBContext();</span><br><span class=\"line\">           serviceCollection.UseDBService();</span><br><span class=\"line\">           serviceCollection.UseAppService();</span><br><span class=\"line\">           MyServiceProvider = serviceCollection.BuildServiceProvider();</span><br><span class=\"line\">           var dbContext = MyServiceProvider.GetService&lt;DBContext&gt;();</span><br><span class=\"line\">           dbContext.DBConfig = &quot;127.0.0.1&quot;;</span><br><span class=\"line\">           TestSingleTon();</span><br><span class=\"line\">           TestTransient();</span><br><span class=\"line\">           Console.ReadKey();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       static void TestSingleTon()</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           for (int i = 0; i &lt; 5; i++)</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               var task = new Task(() =&gt;</span><br><span class=\"line\">               &#123; </span><br><span class=\"line\">                   var dbService = MyServiceProvider.GetService&lt;UserDbService&gt;();</span><br><span class=\"line\">                   Console.WriteLine(dbService.GetDBConfig());</span><br><span class=\"line\">                   Console.WriteLine(&quot;设置用户名为张三&quot;);</span><br><span class=\"line\">                   dbService.UserName = &quot;张三&quot; + i;</span><br><span class=\"line\">               &#125;);</span><br><span class=\"line\">               task.Wait(100);</span><br><span class=\"line\">               task.Start();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       static void TestTransient()</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           for (int i = 0; i &lt; 5; i++)</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               var task = new Task(() =&gt;</span><br><span class=\"line\">               &#123;</span><br><span class=\"line\">                   var userAppService = MyServiceProvider.GetService&lt;UserAppService&gt;();</span><br><span class=\"line\">                   Console.WriteLine($&quot;获取数据库中的用户名:&#123;userAppService.GetDBUserName()&#125;&quot;);</span><br><span class=\"line\">               &#125;);</span><br><span class=\"line\">               task.Wait(200);</span><br><span class=\"line\">               task.Start();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么在创建 UserDbService 对象时，依赖注入框架会自动创建dbContext对象，并将其注入到 UserDbService中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public UserDbService(DBContext dBContext)</span><br></pre></td></tr></table></figure>\n\n<p>这样就封装了原来的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IUserDBService dbService=new UserDBService(new DBContext());</span><br></pre></td></tr></table></figure>\n\n<p>的代码过程，弥补了调用者需要与UserDBService 高度耦合的缺陷。</p>\n<h2 id=\"值得注意的是：\"><a href=\"#值得注意的是：\" class=\"headerlink\" title=\"值得注意的是：\"></a>值得注意的是：</h2><p>1、在.NET Core（.NET Framework) 控制台中，需要手动创建对象IServiceCollection，并创建一个静态的 ServiceProvider 对象，由这个对象来实现对象的加载。<br>2、在.NET Core 网站项目中，由WebHost管理的生命周期，会创建一个统一的 IServiceCollection和 ServiceProvider 对象，无需再单独创建这个ServiceProvider. </p>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><p>在示例代码中，提供了一个DIExtension的静态类，并定义了三个注册对象的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static IServiceCollection UseDBContext(this IServiceCollection serviceCollection)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            serviceCollection.AddScoped&lt;DBContext&gt;();</span><br><span class=\"line\">            return serviceCollection;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static IServiceCollection UseDBService(this IServiceCollection serviceCollection)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            serviceCollection.AddSingleton&lt;UserDbService&gt;();</span><br><span class=\"line\">            return serviceCollection;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static IServiceCollection UseAppService(this IServiceCollection serviceCollection)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            serviceCollection.AddTransient&lt;UserAppService&gt;();</span><br><span class=\"line\">            return serviceCollection;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"在-NET-Core-Framework中使用依赖注入框架\"><a href=\"#在-NET-Core-Framework中使用依赖注入框架\" class=\"headerlink\" title=\"在.NET  Core/Framework中使用依赖注入框架\"></a>在.NET  Core/Framework中使用依赖注入框架</h1><h2 id=\"综述\"><a href=\"#综述\" class=\"headerlink\" title=\"综述\"></a>综述</h2><p>在传统的.NET Framework中通常会使用 new 关键词和静态对象或静态方法作为对象创建的形式，但是由于这两种方式存在以下缺陷：</p>\n<h5 id=\"使用New的方式创建对象的缺陷：\"><a href=\"#使用New的方式创建对象的缺陷：\" class=\"headerlink\" title=\"使用New的方式创建对象的缺陷：\"></a>使用New的方式创建对象的缺陷：</h5><p>1、使用New的方式创建的对象，需要在由GC在不同的位置分别管理生命周期。<br>2、如果在不同的方法中需要创建相同的对象，往往需要用很多个new来进行管理。<br>3、当一个对象有多个子类时，创建的过程更加麻烦。</p>\n<h4 id=\"使用静态变量的缺陷。\"><a href=\"#使用静态变量的缺陷。\" class=\"headerlink\" title=\"使用静态变量的缺陷。\"></a>使用静态变量的缺陷。</h4><p>1、静态变量的内存空间是应用程序启动时创建、并在程序消亡时统一释放。<br>2、在高并发场景下，静态变量容易被不同的线程频繁读写，从而成为系统的主要性能瓶颈。</p>\n<h2 id=\"为啥要使用依赖注入\"><a href=\"#为啥要使用依赖注入\" class=\"headerlink\" title=\"为啥要使用依赖注入\"></a>为啥要使用依赖注入</h2><p>在.NET Core或.NET FX中目前已经倾向于使用依赖注入框架来对对象的创建过程进行统一管理，这样的好处：<br>1、封装了对象的创建过程，可以实现对象创建过程和内存管理过程的一致性，<br>2、如果一个对象有多个实现，也容易使用依赖注入对象对其进行拆分。<br>3、提供统一的对象生命周期管理。</p>\n<h2 id=\"依赖注入的生命周期\"><a href=\"#依赖注入的生命周期\" class=\"headerlink\" title=\"依赖注入的生命周期\"></a>依赖注入的生命周期</h2><p>目前在.NET Core（.NET FX也有）中提供了3种依赖注入的生命周期，分别是：<br>1、单例的生命周期SingleTon。每次从同根容器中（同根 IServiceProvider）获取的时候都是同一个实例，类似于静态变量。主要用来存储系统中需要保持唯一一份的对象<br>2、瞬时的生命周期Transient。每次从容器 （IServiceProvider）中获取的时候都是一个新的实例，可以用于 控制台程序。<br>3、作用域的生命周期Scoped。每次从同一个容器中获取的实例是相同的。往往用于ASP.NET Core 网站。<br>使用依赖注入的方式实现对象的创建虽然会给程序带来一点不便利，但是容易实现程序的耦合度降低，更有利于程序未来的横向扩展，也逐渐成为ASP.NET开发（不仅仅是.NET Core）的的一种最佳实践。</p>\n<h2 id=\"依赖注入的使用\"><a href=\"#依赖注入的使用\" class=\"headerlink\" title=\"依赖注入的使用\"></a>依赖注入的使用</h2><p>目前.NET中的依赖注入组件是基于.NET Strandard（标准库）进行开发的无其他依赖项的组件，能够被基于标准库的各种.NET技术方案所实现。<br>主要分为两个步骤，<br>1：初始化时，将对象注册到依赖注入组件中；例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">serviceCollection.AddScoped&lt;DBContext&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>2：对象使用时，从依赖注入组件中取出对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dbContext = MyServiceProvider.GetService&lt;DBContext&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>从依赖注入组件中取出对象的过程，往往会伴随着对象创建的过程，即在依赖注入框架内部，封装了原来与 New 一致的流程。</p>\n<p>如果一个对象如果需要引用的对象已经被注册到依赖注入组件中，则无需使用 GetService 方法从依赖注入组件中取出对象，依赖注入框架在创建对象时，也会连带着将其他与之相关的对象一起创建。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>例如：<br>1、在示例代码中，设置 DBContext 为 Scoped </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">serviceCollection.AddScoped&lt;DBContext&gt;();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static ServiceProvider MyServiceProvider;</span><br><span class=\"line\">       static void Main(string[] args)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           IServiceCollection serviceCollection = new ServiceCollection();</span><br><span class=\"line\">           serviceCollection.UseDBContext();</span><br><span class=\"line\">           serviceCollection.UseDBService();</span><br><span class=\"line\">           serviceCollection.UseAppService();</span><br><span class=\"line\">           MyServiceProvider = serviceCollection.BuildServiceProvider();</span><br><span class=\"line\">           var dbContext = MyServiceProvider.GetService&lt;DBContext&gt;();</span><br><span class=\"line\">           dbContext.DBConfig = &quot;127.0.0.1&quot;;</span><br><span class=\"line\">           TestSingleTon();</span><br><span class=\"line\">           TestTransient();</span><br><span class=\"line\">           Console.ReadKey();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       static void TestSingleTon()</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           for (int i = 0; i &lt; 5; i++)</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               var task = new Task(() =&gt;</span><br><span class=\"line\">               &#123; </span><br><span class=\"line\">                   var dbService = MyServiceProvider.GetService&lt;UserDbService&gt;();</span><br><span class=\"line\">                   Console.WriteLine(dbService.GetDBConfig());</span><br><span class=\"line\">                   Console.WriteLine(&quot;设置用户名为张三&quot;);</span><br><span class=\"line\">                   dbService.UserName = &quot;张三&quot; + i;</span><br><span class=\"line\">               &#125;);</span><br><span class=\"line\">               task.Wait(100);</span><br><span class=\"line\">               task.Start();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       static void TestTransient()</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           for (int i = 0; i &lt; 5; i++)</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               var task = new Task(() =&gt;</span><br><span class=\"line\">               &#123;</span><br><span class=\"line\">                   var userAppService = MyServiceProvider.GetService&lt;UserAppService&gt;();</span><br><span class=\"line\">                   Console.WriteLine($&quot;获取数据库中的用户名:&#123;userAppService.GetDBUserName()&#125;&quot;);</span><br><span class=\"line\">               &#125;);</span><br><span class=\"line\">               task.Wait(200);</span><br><span class=\"line\">               task.Start();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么在创建 UserDbService 对象时，依赖注入框架会自动创建dbContext对象，并将其注入到 UserDbService中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public UserDbService(DBContext dBContext)</span><br></pre></td></tr></table></figure>\n\n<p>这样就封装了原来的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IUserDBService dbService=new UserDBService(new DBContext());</span><br></pre></td></tr></table></figure>\n\n<p>的代码过程，弥补了调用者需要与UserDBService 高度耦合的缺陷。</p>\n<h2 id=\"值得注意的是：\"><a href=\"#值得注意的是：\" class=\"headerlink\" title=\"值得注意的是：\"></a>值得注意的是：</h2><p>1、在.NET Core（.NET Framework) 控制台中，需要手动创建对象IServiceCollection，并创建一个静态的 ServiceProvider 对象，由这个对象来实现对象的加载。<br>2、在.NET Core 网站项目中，由WebHost管理的生命周期，会创建一个统一的 IServiceCollection和 ServiceProvider 对象，无需再单独创建这个ServiceProvider. </p>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><p>在示例代码中，提供了一个DIExtension的静态类，并定义了三个注册对象的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static IServiceCollection UseDBContext(this IServiceCollection serviceCollection)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            serviceCollection.AddScoped&lt;DBContext&gt;();</span><br><span class=\"line\">            return serviceCollection;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static IServiceCollection UseDBService(this IServiceCollection serviceCollection)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            serviceCollection.AddSingleton&lt;UserDbService&gt;();</span><br><span class=\"line\">            return serviceCollection;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public static IServiceCollection UseAppService(this IServiceCollection serviceCollection)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            serviceCollection.AddTransient&lt;UserAppService&gt;();</span><br><span class=\"line\">            return serviceCollection;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>"},{"title":"那些与EF有关的错误认知","date":"2020-05-15T11:07:00.000Z","author":"邹溪源","_content":"# 前言\n\n这是一个对话性的讨论，它讨论了一个严重的问题趋势，我发现在由初级团队到架构师团队的各种规模的组织中，EntityFramework的利用率都很高。这不是一个如何做的问题,这也不适合新手。如果有什么能激发您的想法，或者您对我提到的事情感到好奇，那么Google是您的朋友。这也是我的第一篇博客文章。欢迎批评。\n\n# 历史和功能介绍（按版本）\n\n首先，让我们简单回顾一下EF随时间推移推出的功能。这绝不是详尽无遗的，当然也不会通过对主要版本的更新列出所有内容。它只是提醒了迄今为止EF的故事。\n\n##### EF / EF 3.5\n\n· DB First\n\n##### EF 4.0\n\n· Lazy Loading\n\n· Migrations\n\n· POCOs\n\n##### EF 5\n\n· Enums\n\n· Spatial\n\n##### EF 6\n\n· Async\n\n· Interception\n\n· Logging\n\n· NuGet Installation\n\n· Recovery\n\n##### EF 7 / Core\n\n· Code First Only\n\n· In-Memory Support\n\n· Limited Batching\n\n· Nonrelational Support\n\n看到这种零散的发布以及Microsoft在开发领域的普遍声誉，Entity Framework有了一个不好的惊喜，并不是因为它为我将要解决的问题找借口而已。根据您正在使用的次要版本，功能似乎随机出现。因此，即使安装了相同的主要版本，您仍会习惯某些东西，转到另一个环境，提出声明并在其现有框架上进行尝试，即使它没有安装，您也仍然会“告诉您”的样子有助于进一步加深已经确立的地位。\n\n基本上，EF的典型故事如下：\n\n高级人士：“让我们使用EF和仓储模式！”\n\n其他开发人员：“ Idk，还没听说过好消息。”\n\n高级：“不，太好了！看到这个例子吗？”\n\n开发人员：“嗯，好的。”\n\n起初，它的工作原理在可接受的范围内。然而，随着它的增长，迟缓开始出现，人们开始抱怨。由于我们行业中偿还技术债务的状况非常糟糕，或者由于完全拒绝首先查看仓储模式中的技术债务，因此，据称聪明的人的整个部门都袖手旁观，只是得出结论，`”EF是垃圾\"`，并不是说他们的使用是垃圾。\n\n我在这里要说明的是后者，并向您展示如何避免该陷阱。\n\n# EF使Sql查询过程得以抽象\n\n在我职业生涯的早期，我开始直接通过ADO使用经典的ASP和SQL Server。我在一个非常小的网络部门工作，因此我经常不得不亲自进入数据库来创建表和执行任务。在一系列复制/粘贴部署，生产测试等过程中，我很快熟悉了SQL Server的所有技巧。“那这个呢？*不会，该产品页面仍然无法加载。*那个怎么样？！*不，仍然无法加载。*来吧...这个？*成功！*通过几乎在黑暗中绊倒，我对索引，视图，复制，安全权限等等非常了解，当时甚至还没读完高中。\n\n使用结构化的环境输入我的前几个地方，然后使用Entity Framework时让我非常脸红。它完全没有我习惯的任何选择。因此，我跳上船，但是没多久就开始抱怨。如果您有金鱼的记忆，让我重申我习惯于随意调整所有杠杆。遇到问题时，我会进行调查。通常，我发现诸如索引利用率之类的关键组件被完全忽略了。当我提出这些问题时，我被告知EF因不知道如何利用它们而感到过失，而我们是在这里处理业务问题，而不是由Microsoft来为他们做。老实说，我基本上还是一个初级开发人员。我有什么理由不同意呢?\n\n## 仓储模式存在的问题\n\n点击访问[仓储模式](http://bfy.tw/3pSK)。仓储模式的问题有两个方面。存储库模式的问题有两个方面。首先，它要求您预先声明如何绑定应用程序与数据库进行交互。即使您构建了这些超级复杂的方法，这些方法允许您传入表达式、字典或异常动态，并且您很有创造力，但是您所做的只是制造了一个维护噩梦。\n\n“但是调用者可以定义他们所需要的！” 不，他们不能。当然，他们可以指向实体并通常定义要选择的数据的形状，但是他们无法确定字段选择之类的内容。他们没有办法说他们需要以一种友好的方式预先加载数据或延迟数据。他们不能在一次实例化中说他们也需要来自这里或那里的数据，但在下一次实例化中，他们只需要找到目标实体，除非神圣的存储库允许他们这样做。相反，您会得到这些全有或全无的决策，这些决策将您的应用程序链接在一起，我们想知道为什么它会很快降级。我真的希望你的水晶球比我的好。\n\n其次，即使是微软自己的例子也没有使用某些实习生可能编写的适当接口。因此，我说，每个人都做错了。关于EF的常识是使用存储库模式，由于存储库模式本身的文档和示例不正确，所以没有人会让EF做它被设计用来做的事情，因为知识的来源受到了毒害。面对这种情况，我听到很多人抱怨说MVC教程的例子直接使用了DbContext，抱怨说它不够稳定，也不是说几乎没有人做得很稳定，但这是另一篇博客文章。(大多数软件直接跳转到ID，忽略了其他的。)\n\n## 让数据库成为数据库\n\n由于SQL Server是EF中最常用的支持数据存储，因此它不是一个干净的软件。太乱了 ，它具有大量场景的功能。如果您想让您的应用程序实际使用您所支付的巨额许可费用的一小部分，请停止将SQL约束到EF驱动的地狱荒原，而这些荒地比SELECT *还要好。然后，我们喜欢抱怨事情进展缓慢。\n\n如果您不让EF在正确的情况下利用功能，则可能无法意识到平台的潜力。必须浪费数十亿美元的许可和开发成本，即使在应用程序以截然不同的方式增长时，使用的独特功能也只会使SQL Server的单位利用率下降。这是一种直觉，但是看到我在大型和小型公司中看到的愚蠢的朴素仓储实现，很难在这里看到我是完全错误的。这对我们自己，我们的雇主和彼此都是有害的。\n\n实体框架仍然逐步锁定在基础数据存储的工作方式上。在SQL Server中，这意味着联接性能，视图和索引利用率，存储过程调用等。这就像将乳胶手套称为手的抽象。它不是，EF也不是它所依赖的存储机制的抽象。相反，它是一组通用的API，它们使我们能够以统一的方式访问数据。由于我刚才所说的原因（我们不能以任何方式否认或减轻基础实现的行为），这不是一个抽象。因此，我们必须在代码中考虑显式或隐式破坏抽象的那些行为。如果要假装它是抽象，我们唯一能做的就是把头埋在沙子里，然后在事情变得笨拙时继续continue吟。\n\n最近，我遇到了—架构师—几乎对让数据库定义视图和将EF指向视图而不是表的建议感到敬畏，您知道，这让dba能够真正完成他们的工作，并使数据库能够在不破坏应用程序代码的情况下进行更改。这并不是什么难事，但问题是普遍存在的，所以大多数人在他们太熟悉的环境中都看不到过去。那么，我们该怎么做呢?\n\n# 使用IQueryable而不是IEnumerable\n\n正确使用Entity Framework的第一步是打破与IEnumerable的依赖关系。当谈论断开连接的商店时，这是很糟糕的。IEnumerable唯一给出的就是延迟执行。如果这是您想要脱离ORM的唯一功能，那么您就不需要ORM。IEnumerable隐瞒使用数据存储的原因在于，它们一劳永逸地固定在它们的表示中。即使应用程序增长，即使仓储中添加了新方法，返回IEnumerable的旧实现也对它们所处的新世界都是盲目，聋哑和愚蠢的。您实际上是在强迫代码与数据布局和期望一起使用。就像几年前首次实施时一样。这是开发人员的错，但应归咎于EF。\n\n但是，IQueryable可以变形并更改为其给定的上下文。即使传递和添加了子句，它也可以评估实例，例如各个调用的需求。如果DbContext已经获取了数据，但它仍可以从高速缓存中检索实体，然后才能以非常快的速度进行重复调用，从而使热路径更加凉爽。更重要的是，它还提供了一些功能，例如，如果基础提供程序支持的话，让我们流数据；无需实例化List对象以使其对堆更友好地加载数据；检查基础类型，以便我们可以在复杂的工作流程中做出明智的决定；访问基础上下文, 等等。\n\n这些都是使您的代码真正了解正在发生的事情而不会破坏抽象障碍的所有功能，因为EF不是抽象。顺便说一句，抽象应该是使用EF的组件，而不是EF本身。我在程序员进行的许多讨论中表达了自己的见解，这些讨论表达了一些需求，但是我们以“抽象”的名义对许多解决方案solutions之以鼻，随之而来的是我们高兴地扭曲自己的箍，这样我们就可以继续存在固体。\n\n# 习惯匿名类型\n\n我听说过的关于EF的最大的抱怨也许就是它检索了多少该死的数据。谁定义实体？EF？没有！你做到了 从本质上讲，您不必多怪，因为每个表的实体似乎是所有人都可以看到的。尽管如此，无论实体有多大，我们都无需受到阻碍。将匿名类型传递给EF查询将导致EF仅选择您定义的字段。可以将数十列的“无法重构”的怪物表分解为实际需要的3或4个字段。一次选择整个实体并假装无能为力的迷恋只能描述为一种大众歇斯底里的形式，我们大声疾呼，“我看不到你！”\n\n# 使用正确的工具完成工作\n\n您知道所有带有封面上各种工具的Microsoft Press书籍吗？您知道，除了某些人只是选择随机图像之外，还有一个原因。大多数工具不仅是螺丝起子或刨刀。有一些真正的奇怪应用没有明显的应用，但是可以肯定的是，它们有自己的目标，并且擅长于此。“正确的工具”的口号经常重复出现，但是我们并没有真正停下来思考工作，更不用说工具了。以下是EF的一些功能。\n\n### 自.Net 2.0以来出现的SqlBulkCopy\n\n另一个与EF数据量密切相关的大型抱怨是，EF检索到它据称无法处理大量数据的方式。我喜欢开发人员的双重性。我想让您知道，结合下面讨论的AsStreaming，反应性扩展和SqlBulkCopy，我可以在一分钟内检索，转换和推送数百万条记录，而不会费力地创建一个完全基于任何工作负载的完全基于代码的ETL解决方案从较小的记录到中等大小的记录（例如5–100亿条记录），并且仍然具有良好的性能。如果您需要更多，则有更多专用工具。但是，不要说Entity Framework无法处理大量数据。 *您的代码无法处理大量数据。*EF很好。\n\n可悲的是，自2005年以来我们就拥有SqlBulkCopy，但我们却假装工具箱中有这个大漏洞。问题已经解决。重新发明轮子的理由为零。你猜怎么了？它也支持流！\n\n### AsTracking与AsNoTracking\n\n我觉得自己的成绩很差。关于EF的另一个大抱怨是它的数据缓存。您几乎总是可以告诉DbContext摆脱缓存的实体。不过，最近，我们获得了将其设置为Entity Framework Core中默认策略的能力。相反，我们可以选择要跟踪的内容，而不是不需要的内容。我很高兴地承认一个烦恼，即您仍然需要分离实体。\n\n### 流式传输\n\n实体框架中的查询通常在返回之前缓冲所有结果。流技术解决了这一问题，并立即让您开始处理数据进入应用程序的过程。您既可以更快地开始工作，又可以使服务器对内存更友好。\n\n### 特殊雪花\n\n在开发人员中，我看到了一个令人不安的趋势。缺乏探索和发明的欲望。我们想要开箱即用的解决方案，在不了解细节的情况下“可行”。即使代码不是魔术，我们仍然相信看不见的魔术。\n\n我采用的一般方法不是构建这些固定的仓储，而是构建扩展，使我们的应用程序以我们需要它们的独特方式运行。是否希望在运行时间较长的过程中缓存数据的好处，但又不能在给定操作之外继续存在呢？对于我来说，这听起来像是DbContext的完美扩展方法，该方法可以获取一些实体，对其进行处理以获得缓存的好处，然后在返回之前清除缓存。另一种扩展方法是在操作完成后分离所有那些实体的方法。\n\n# 不要害怕\n\n我在这里谈论DbContext是因为有很多人对待它。它被视为一件大，笨重，笨拙的事情，如果您不小心的话，它们会偷走您的孩子。我们花了很长的时间才能使DbContext的存在只为少数几个组件所知。这将我们的实现进一步扼杀到仓储中。由于我们*必须*遍历仓储以获取任何类型的数据，因此我们需要在发生更改时定期违反“开放/关闭”原则，或者被迫接受仓储指示的决策膨胀的折衷，并且在使用时要格外小心我们打电话给它。\n\n释放DbContext。如果模块需要数据，请不要自欺欺人，说DbContext还不是依赖项。我可以向您保证，如果您对它的可访问性感到满意，并消除“人们犯错了怎么办？！”的神秘主义。它实际上将使我们整体上变得更好。如果某人可以提交顽皮的代码，并且至少使它经过一次未经测试的生产，则您实际上就没有发布控制或质量检查。诸如隐藏DbContext之类的策略是您组织中已经流血的伤口上的权宜之计，无助于真正缓解实际问题。\n\n# 别再找借口\n\n我们程序员必须停止像解决我们所遇到的问题的解决方案那样行动，或者必须使用node.js和dapper的正确组合来区分它们，这并不是说它们没有合法用途，而是经常被他们当作替罪羊实体框架是一种很好的工具，可以用来做某事。我们十年来拥有的工具已经足以满足我们的大多数需求。一次又一次的错误决定最终导致错误的决定，使我们陷入困境。使您的工具适应自如。尝试新事物。可以肯定的是，我们只能怪自己。","source":"_posts/技术/那些与EF有关的错误认知.md","raw":"---\ntitle: 那些与EF有关的错误认知\ndate: 2020-5-15 19:07\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n# 前言\n\n这是一个对话性的讨论，它讨论了一个严重的问题趋势，我发现在由初级团队到架构师团队的各种规模的组织中，EntityFramework的利用率都很高。这不是一个如何做的问题,这也不适合新手。如果有什么能激发您的想法，或者您对我提到的事情感到好奇，那么Google是您的朋友。这也是我的第一篇博客文章。欢迎批评。\n\n# 历史和功能介绍（按版本）\n\n首先，让我们简单回顾一下EF随时间推移推出的功能。这绝不是详尽无遗的，当然也不会通过对主要版本的更新列出所有内容。它只是提醒了迄今为止EF的故事。\n\n##### EF / EF 3.5\n\n· DB First\n\n##### EF 4.0\n\n· Lazy Loading\n\n· Migrations\n\n· POCOs\n\n##### EF 5\n\n· Enums\n\n· Spatial\n\n##### EF 6\n\n· Async\n\n· Interception\n\n· Logging\n\n· NuGet Installation\n\n· Recovery\n\n##### EF 7 / Core\n\n· Code First Only\n\n· In-Memory Support\n\n· Limited Batching\n\n· Nonrelational Support\n\n看到这种零散的发布以及Microsoft在开发领域的普遍声誉，Entity Framework有了一个不好的惊喜，并不是因为它为我将要解决的问题找借口而已。根据您正在使用的次要版本，功能似乎随机出现。因此，即使安装了相同的主要版本，您仍会习惯某些东西，转到另一个环境，提出声明并在其现有框架上进行尝试，即使它没有安装，您也仍然会“告诉您”的样子有助于进一步加深已经确立的地位。\n\n基本上，EF的典型故事如下：\n\n高级人士：“让我们使用EF和仓储模式！”\n\n其他开发人员：“ Idk，还没听说过好消息。”\n\n高级：“不，太好了！看到这个例子吗？”\n\n开发人员：“嗯，好的。”\n\n起初，它的工作原理在可接受的范围内。然而，随着它的增长，迟缓开始出现，人们开始抱怨。由于我们行业中偿还技术债务的状况非常糟糕，或者由于完全拒绝首先查看仓储模式中的技术债务，因此，据称聪明的人的整个部门都袖手旁观，只是得出结论，`”EF是垃圾\"`，并不是说他们的使用是垃圾。\n\n我在这里要说明的是后者，并向您展示如何避免该陷阱。\n\n# EF使Sql查询过程得以抽象\n\n在我职业生涯的早期，我开始直接通过ADO使用经典的ASP和SQL Server。我在一个非常小的网络部门工作，因此我经常不得不亲自进入数据库来创建表和执行任务。在一系列复制/粘贴部署，生产测试等过程中，我很快熟悉了SQL Server的所有技巧。“那这个呢？*不会，该产品页面仍然无法加载。*那个怎么样？！*不，仍然无法加载。*来吧...这个？*成功！*通过几乎在黑暗中绊倒，我对索引，视图，复制，安全权限等等非常了解，当时甚至还没读完高中。\n\n使用结构化的环境输入我的前几个地方，然后使用Entity Framework时让我非常脸红。它完全没有我习惯的任何选择。因此，我跳上船，但是没多久就开始抱怨。如果您有金鱼的记忆，让我重申我习惯于随意调整所有杠杆。遇到问题时，我会进行调查。通常，我发现诸如索引利用率之类的关键组件被完全忽略了。当我提出这些问题时，我被告知EF因不知道如何利用它们而感到过失，而我们是在这里处理业务问题，而不是由Microsoft来为他们做。老实说，我基本上还是一个初级开发人员。我有什么理由不同意呢?\n\n## 仓储模式存在的问题\n\n点击访问[仓储模式](http://bfy.tw/3pSK)。仓储模式的问题有两个方面。存储库模式的问题有两个方面。首先，它要求您预先声明如何绑定应用程序与数据库进行交互。即使您构建了这些超级复杂的方法，这些方法允许您传入表达式、字典或异常动态，并且您很有创造力，但是您所做的只是制造了一个维护噩梦。\n\n“但是调用者可以定义他们所需要的！” 不，他们不能。当然，他们可以指向实体并通常定义要选择的数据的形状，但是他们无法确定字段选择之类的内容。他们没有办法说他们需要以一种友好的方式预先加载数据或延迟数据。他们不能在一次实例化中说他们也需要来自这里或那里的数据，但在下一次实例化中，他们只需要找到目标实体，除非神圣的存储库允许他们这样做。相反，您会得到这些全有或全无的决策，这些决策将您的应用程序链接在一起，我们想知道为什么它会很快降级。我真的希望你的水晶球比我的好。\n\n其次，即使是微软自己的例子也没有使用某些实习生可能编写的适当接口。因此，我说，每个人都做错了。关于EF的常识是使用存储库模式，由于存储库模式本身的文档和示例不正确，所以没有人会让EF做它被设计用来做的事情，因为知识的来源受到了毒害。面对这种情况，我听到很多人抱怨说MVC教程的例子直接使用了DbContext，抱怨说它不够稳定，也不是说几乎没有人做得很稳定，但这是另一篇博客文章。(大多数软件直接跳转到ID，忽略了其他的。)\n\n## 让数据库成为数据库\n\n由于SQL Server是EF中最常用的支持数据存储，因此它不是一个干净的软件。太乱了 ，它具有大量场景的功能。如果您想让您的应用程序实际使用您所支付的巨额许可费用的一小部分，请停止将SQL约束到EF驱动的地狱荒原，而这些荒地比SELECT *还要好。然后，我们喜欢抱怨事情进展缓慢。\n\n如果您不让EF在正确的情况下利用功能，则可能无法意识到平台的潜力。必须浪费数十亿美元的许可和开发成本，即使在应用程序以截然不同的方式增长时，使用的独特功能也只会使SQL Server的单位利用率下降。这是一种直觉，但是看到我在大型和小型公司中看到的愚蠢的朴素仓储实现，很难在这里看到我是完全错误的。这对我们自己，我们的雇主和彼此都是有害的。\n\n实体框架仍然逐步锁定在基础数据存储的工作方式上。在SQL Server中，这意味着联接性能，视图和索引利用率，存储过程调用等。这就像将乳胶手套称为手的抽象。它不是，EF也不是它所依赖的存储机制的抽象。相反，它是一组通用的API，它们使我们能够以统一的方式访问数据。由于我刚才所说的原因（我们不能以任何方式否认或减轻基础实现的行为），这不是一个抽象。因此，我们必须在代码中考虑显式或隐式破坏抽象的那些行为。如果要假装它是抽象，我们唯一能做的就是把头埋在沙子里，然后在事情变得笨拙时继续continue吟。\n\n最近，我遇到了—架构师—几乎对让数据库定义视图和将EF指向视图而不是表的建议感到敬畏，您知道，这让dba能够真正完成他们的工作，并使数据库能够在不破坏应用程序代码的情况下进行更改。这并不是什么难事，但问题是普遍存在的，所以大多数人在他们太熟悉的环境中都看不到过去。那么，我们该怎么做呢?\n\n# 使用IQueryable而不是IEnumerable\n\n正确使用Entity Framework的第一步是打破与IEnumerable的依赖关系。当谈论断开连接的商店时，这是很糟糕的。IEnumerable唯一给出的就是延迟执行。如果这是您想要脱离ORM的唯一功能，那么您就不需要ORM。IEnumerable隐瞒使用数据存储的原因在于，它们一劳永逸地固定在它们的表示中。即使应用程序增长，即使仓储中添加了新方法，返回IEnumerable的旧实现也对它们所处的新世界都是盲目，聋哑和愚蠢的。您实际上是在强迫代码与数据布局和期望一起使用。就像几年前首次实施时一样。这是开发人员的错，但应归咎于EF。\n\n但是，IQueryable可以变形并更改为其给定的上下文。即使传递和添加了子句，它也可以评估实例，例如各个调用的需求。如果DbContext已经获取了数据，但它仍可以从高速缓存中检索实体，然后才能以非常快的速度进行重复调用，从而使热路径更加凉爽。更重要的是，它还提供了一些功能，例如，如果基础提供程序支持的话，让我们流数据；无需实例化List对象以使其对堆更友好地加载数据；检查基础类型，以便我们可以在复杂的工作流程中做出明智的决定；访问基础上下文, 等等。\n\n这些都是使您的代码真正了解正在发生的事情而不会破坏抽象障碍的所有功能，因为EF不是抽象。顺便说一句，抽象应该是使用EF的组件，而不是EF本身。我在程序员进行的许多讨论中表达了自己的见解，这些讨论表达了一些需求，但是我们以“抽象”的名义对许多解决方案solutions之以鼻，随之而来的是我们高兴地扭曲自己的箍，这样我们就可以继续存在固体。\n\n# 习惯匿名类型\n\n我听说过的关于EF的最大的抱怨也许就是它检索了多少该死的数据。谁定义实体？EF？没有！你做到了 从本质上讲，您不必多怪，因为每个表的实体似乎是所有人都可以看到的。尽管如此，无论实体有多大，我们都无需受到阻碍。将匿名类型传递给EF查询将导致EF仅选择您定义的字段。可以将数十列的“无法重构”的怪物表分解为实际需要的3或4个字段。一次选择整个实体并假装无能为力的迷恋只能描述为一种大众歇斯底里的形式，我们大声疾呼，“我看不到你！”\n\n# 使用正确的工具完成工作\n\n您知道所有带有封面上各种工具的Microsoft Press书籍吗？您知道，除了某些人只是选择随机图像之外，还有一个原因。大多数工具不仅是螺丝起子或刨刀。有一些真正的奇怪应用没有明显的应用，但是可以肯定的是，它们有自己的目标，并且擅长于此。“正确的工具”的口号经常重复出现，但是我们并没有真正停下来思考工作，更不用说工具了。以下是EF的一些功能。\n\n### 自.Net 2.0以来出现的SqlBulkCopy\n\n另一个与EF数据量密切相关的大型抱怨是，EF检索到它据称无法处理大量数据的方式。我喜欢开发人员的双重性。我想让您知道，结合下面讨论的AsStreaming，反应性扩展和SqlBulkCopy，我可以在一分钟内检索，转换和推送数百万条记录，而不会费力地创建一个完全基于任何工作负载的完全基于代码的ETL解决方案从较小的记录到中等大小的记录（例如5–100亿条记录），并且仍然具有良好的性能。如果您需要更多，则有更多专用工具。但是，不要说Entity Framework无法处理大量数据。 *您的代码无法处理大量数据。*EF很好。\n\n可悲的是，自2005年以来我们就拥有SqlBulkCopy，但我们却假装工具箱中有这个大漏洞。问题已经解决。重新发明轮子的理由为零。你猜怎么了？它也支持流！\n\n### AsTracking与AsNoTracking\n\n我觉得自己的成绩很差。关于EF的另一个大抱怨是它的数据缓存。您几乎总是可以告诉DbContext摆脱缓存的实体。不过，最近，我们获得了将其设置为Entity Framework Core中默认策略的能力。相反，我们可以选择要跟踪的内容，而不是不需要的内容。我很高兴地承认一个烦恼，即您仍然需要分离实体。\n\n### 流式传输\n\n实体框架中的查询通常在返回之前缓冲所有结果。流技术解决了这一问题，并立即让您开始处理数据进入应用程序的过程。您既可以更快地开始工作，又可以使服务器对内存更友好。\n\n### 特殊雪花\n\n在开发人员中，我看到了一个令人不安的趋势。缺乏探索和发明的欲望。我们想要开箱即用的解决方案，在不了解细节的情况下“可行”。即使代码不是魔术，我们仍然相信看不见的魔术。\n\n我采用的一般方法不是构建这些固定的仓储，而是构建扩展，使我们的应用程序以我们需要它们的独特方式运行。是否希望在运行时间较长的过程中缓存数据的好处，但又不能在给定操作之外继续存在呢？对于我来说，这听起来像是DbContext的完美扩展方法，该方法可以获取一些实体，对其进行处理以获得缓存的好处，然后在返回之前清除缓存。另一种扩展方法是在操作完成后分离所有那些实体的方法。\n\n# 不要害怕\n\n我在这里谈论DbContext是因为有很多人对待它。它被视为一件大，笨重，笨拙的事情，如果您不小心的话，它们会偷走您的孩子。我们花了很长的时间才能使DbContext的存在只为少数几个组件所知。这将我们的实现进一步扼杀到仓储中。由于我们*必须*遍历仓储以获取任何类型的数据，因此我们需要在发生更改时定期违反“开放/关闭”原则，或者被迫接受仓储指示的决策膨胀的折衷，并且在使用时要格外小心我们打电话给它。\n\n释放DbContext。如果模块需要数据，请不要自欺欺人，说DbContext还不是依赖项。我可以向您保证，如果您对它的可访问性感到满意，并消除“人们犯错了怎么办？！”的神秘主义。它实际上将使我们整体上变得更好。如果某人可以提交顽皮的代码，并且至少使它经过一次未经测试的生产，则您实际上就没有发布控制或质量检查。诸如隐藏DbContext之类的策略是您组织中已经流血的伤口上的权宜之计，无助于真正缓解实际问题。\n\n# 别再找借口\n\n我们程序员必须停止像解决我们所遇到的问题的解决方案那样行动，或者必须使用node.js和dapper的正确组合来区分它们，这并不是说它们没有合法用途，而是经常被他们当作替罪羊实体框架是一种很好的工具，可以用来做某事。我们十年来拥有的工具已经足以满足我们的大多数需求。一次又一次的错误决定最终导致错误的决定，使我们陷入困境。使您的工具适应自如。尝试新事物。可以肯定的是，我们只能怪自己。","slug":"技术/那些与EF有关的错误认知","published":1,"updated":"2020-05-26T11:09:15.512Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt870020n4vi4kpmz80v","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>这是一个对话性的讨论，它讨论了一个严重的问题趋势，我发现在由初级团队到架构师团队的各种规模的组织中，EntityFramework的利用率都很高。这不是一个如何做的问题,这也不适合新手。如果有什么能激发您的想法，或者您对我提到的事情感到好奇，那么Google是您的朋友。这也是我的第一篇博客文章。欢迎批评。</p>\n<h1 id=\"历史和功能介绍（按版本）\"><a href=\"#历史和功能介绍（按版本）\" class=\"headerlink\" title=\"历史和功能介绍（按版本）\"></a>历史和功能介绍（按版本）</h1><p>首先，让我们简单回顾一下EF随时间推移推出的功能。这绝不是详尽无遗的，当然也不会通过对主要版本的更新列出所有内容。它只是提醒了迄今为止EF的故事。</p>\n<h5 id=\"EF-EF-3-5\"><a href=\"#EF-EF-3-5\" class=\"headerlink\" title=\"EF / EF 3.5\"></a>EF / EF 3.5</h5><p>· DB First</p>\n<h5 id=\"EF-4-0\"><a href=\"#EF-4-0\" class=\"headerlink\" title=\"EF 4.0\"></a>EF 4.0</h5><p>· Lazy Loading</p>\n<p>· Migrations</p>\n<p>· POCOs</p>\n<h5 id=\"EF-5\"><a href=\"#EF-5\" class=\"headerlink\" title=\"EF 5\"></a>EF 5</h5><p>· Enums</p>\n<p>· Spatial</p>\n<h5 id=\"EF-6\"><a href=\"#EF-6\" class=\"headerlink\" title=\"EF 6\"></a>EF 6</h5><p>· Async</p>\n<p>· Interception</p>\n<p>· Logging</p>\n<p>· NuGet Installation</p>\n<p>· Recovery</p>\n<h5 id=\"EF-7-Core\"><a href=\"#EF-7-Core\" class=\"headerlink\" title=\"EF 7 / Core\"></a>EF 7 / Core</h5><p>· Code First Only</p>\n<p>· In-Memory Support</p>\n<p>· Limited Batching</p>\n<p>· Nonrelational Support</p>\n<p>看到这种零散的发布以及Microsoft在开发领域的普遍声誉，Entity Framework有了一个不好的惊喜，并不是因为它为我将要解决的问题找借口而已。根据您正在使用的次要版本，功能似乎随机出现。因此，即使安装了相同的主要版本，您仍会习惯某些东西，转到另一个环境，提出声明并在其现有框架上进行尝试，即使它没有安装，您也仍然会“告诉您”的样子有助于进一步加深已经确立的地位。</p>\n<p>基本上，EF的典型故事如下：</p>\n<p>高级人士：“让我们使用EF和仓储模式！”</p>\n<p>其他开发人员：“ Idk，还没听说过好消息。”</p>\n<p>高级：“不，太好了！看到这个例子吗？”</p>\n<p>开发人员：“嗯，好的。”</p>\n<p>起初，它的工作原理在可接受的范围内。然而，随着它的增长，迟缓开始出现，人们开始抱怨。由于我们行业中偿还技术债务的状况非常糟糕，或者由于完全拒绝首先查看仓储模式中的技术债务，因此，据称聪明的人的整个部门都袖手旁观，只是得出结论，<code>”EF是垃圾&quot;</code>，并不是说他们的使用是垃圾。</p>\n<p>我在这里要说明的是后者，并向您展示如何避免该陷阱。</p>\n<h1 id=\"EF使Sql查询过程得以抽象\"><a href=\"#EF使Sql查询过程得以抽象\" class=\"headerlink\" title=\"EF使Sql查询过程得以抽象\"></a>EF使Sql查询过程得以抽象</h1><p>在我职业生涯的早期，我开始直接通过ADO使用经典的ASP和SQL Server。我在一个非常小的网络部门工作，因此我经常不得不亲自进入数据库来创建表和执行任务。在一系列复制/粘贴部署，生产测试等过程中，我很快熟悉了SQL Server的所有技巧。“那这个呢？<em>不会，该产品页面仍然无法加载。</em>那个怎么样？！<em>不，仍然无法加载。</em>来吧…这个？<em>成功！</em>通过几乎在黑暗中绊倒，我对索引，视图，复制，安全权限等等非常了解，当时甚至还没读完高中。</p>\n<p>使用结构化的环境输入我的前几个地方，然后使用Entity Framework时让我非常脸红。它完全没有我习惯的任何选择。因此，我跳上船，但是没多久就开始抱怨。如果您有金鱼的记忆，让我重申我习惯于随意调整所有杠杆。遇到问题时，我会进行调查。通常，我发现诸如索引利用率之类的关键组件被完全忽略了。当我提出这些问题时，我被告知EF因不知道如何利用它们而感到过失，而我们是在这里处理业务问题，而不是由Microsoft来为他们做。老实说，我基本上还是一个初级开发人员。我有什么理由不同意呢?</p>\n<h2 id=\"仓储模式存在的问题\"><a href=\"#仓储模式存在的问题\" class=\"headerlink\" title=\"仓储模式存在的问题\"></a>仓储模式存在的问题</h2><p>点击访问<a href=\"http://bfy.tw/3pSK\" target=\"_blank\" rel=\"noopener\">仓储模式</a>。仓储模式的问题有两个方面。存储库模式的问题有两个方面。首先，它要求您预先声明如何绑定应用程序与数据库进行交互。即使您构建了这些超级复杂的方法，这些方法允许您传入表达式、字典或异常动态，并且您很有创造力，但是您所做的只是制造了一个维护噩梦。</p>\n<p>“但是调用者可以定义他们所需要的！” 不，他们不能。当然，他们可以指向实体并通常定义要选择的数据的形状，但是他们无法确定字段选择之类的内容。他们没有办法说他们需要以一种友好的方式预先加载数据或延迟数据。他们不能在一次实例化中说他们也需要来自这里或那里的数据，但在下一次实例化中，他们只需要找到目标实体，除非神圣的存储库允许他们这样做。相反，您会得到这些全有或全无的决策，这些决策将您的应用程序链接在一起，我们想知道为什么它会很快降级。我真的希望你的水晶球比我的好。</p>\n<p>其次，即使是微软自己的例子也没有使用某些实习生可能编写的适当接口。因此，我说，每个人都做错了。关于EF的常识是使用存储库模式，由于存储库模式本身的文档和示例不正确，所以没有人会让EF做它被设计用来做的事情，因为知识的来源受到了毒害。面对这种情况，我听到很多人抱怨说MVC教程的例子直接使用了DbContext，抱怨说它不够稳定，也不是说几乎没有人做得很稳定，但这是另一篇博客文章。(大多数软件直接跳转到ID，忽略了其他的。)</p>\n<h2 id=\"让数据库成为数据库\"><a href=\"#让数据库成为数据库\" class=\"headerlink\" title=\"让数据库成为数据库\"></a>让数据库成为数据库</h2><p>由于SQL Server是EF中最常用的支持数据存储，因此它不是一个干净的软件。太乱了 ，它具有大量场景的功能。如果您想让您的应用程序实际使用您所支付的巨额许可费用的一小部分，请停止将SQL约束到EF驱动的地狱荒原，而这些荒地比SELECT *还要好。然后，我们喜欢抱怨事情进展缓慢。</p>\n<p>如果您不让EF在正确的情况下利用功能，则可能无法意识到平台的潜力。必须浪费数十亿美元的许可和开发成本，即使在应用程序以截然不同的方式增长时，使用的独特功能也只会使SQL Server的单位利用率下降。这是一种直觉，但是看到我在大型和小型公司中看到的愚蠢的朴素仓储实现，很难在这里看到我是完全错误的。这对我们自己，我们的雇主和彼此都是有害的。</p>\n<p>实体框架仍然逐步锁定在基础数据存储的工作方式上。在SQL Server中，这意味着联接性能，视图和索引利用率，存储过程调用等。这就像将乳胶手套称为手的抽象。它不是，EF也不是它所依赖的存储机制的抽象。相反，它是一组通用的API，它们使我们能够以统一的方式访问数据。由于我刚才所说的原因（我们不能以任何方式否认或减轻基础实现的行为），这不是一个抽象。因此，我们必须在代码中考虑显式或隐式破坏抽象的那些行为。如果要假装它是抽象，我们唯一能做的就是把头埋在沙子里，然后在事情变得笨拙时继续continue吟。</p>\n<p>最近，我遇到了—架构师—几乎对让数据库定义视图和将EF指向视图而不是表的建议感到敬畏，您知道，这让dba能够真正完成他们的工作，并使数据库能够在不破坏应用程序代码的情况下进行更改。这并不是什么难事，但问题是普遍存在的，所以大多数人在他们太熟悉的环境中都看不到过去。那么，我们该怎么做呢?</p>\n<h1 id=\"使用IQueryable而不是IEnumerable\"><a href=\"#使用IQueryable而不是IEnumerable\" class=\"headerlink\" title=\"使用IQueryable而不是IEnumerable\"></a>使用IQueryable而不是IEnumerable</h1><p>正确使用Entity Framework的第一步是打破与IEnumerable的依赖关系。当谈论断开连接的商店时，这是很糟糕的。IEnumerable唯一给出的就是延迟执行。如果这是您想要脱离ORM的唯一功能，那么您就不需要ORM。IEnumerable隐瞒使用数据存储的原因在于，它们一劳永逸地固定在它们的表示中。即使应用程序增长，即使仓储中添加了新方法，返回IEnumerable的旧实现也对它们所处的新世界都是盲目，聋哑和愚蠢的。您实际上是在强迫代码与数据布局和期望一起使用。就像几年前首次实施时一样。这是开发人员的错，但应归咎于EF。</p>\n<p>但是，IQueryable可以变形并更改为其给定的上下文。即使传递和添加了子句，它也可以评估实例，例如各个调用的需求。如果DbContext已经获取了数据，但它仍可以从高速缓存中检索实体，然后才能以非常快的速度进行重复调用，从而使热路径更加凉爽。更重要的是，它还提供了一些功能，例如，如果基础提供程序支持的话，让我们流数据；无需实例化List对象以使其对堆更友好地加载数据；检查基础类型，以便我们可以在复杂的工作流程中做出明智的决定；访问基础上下文, 等等。</p>\n<p>这些都是使您的代码真正了解正在发生的事情而不会破坏抽象障碍的所有功能，因为EF不是抽象。顺便说一句，抽象应该是使用EF的组件，而不是EF本身。我在程序员进行的许多讨论中表达了自己的见解，这些讨论表达了一些需求，但是我们以“抽象”的名义对许多解决方案solutions之以鼻，随之而来的是我们高兴地扭曲自己的箍，这样我们就可以继续存在固体。</p>\n<h1 id=\"习惯匿名类型\"><a href=\"#习惯匿名类型\" class=\"headerlink\" title=\"习惯匿名类型\"></a>习惯匿名类型</h1><p>我听说过的关于EF的最大的抱怨也许就是它检索了多少该死的数据。谁定义实体？EF？没有！你做到了 从本质上讲，您不必多怪，因为每个表的实体似乎是所有人都可以看到的。尽管如此，无论实体有多大，我们都无需受到阻碍。将匿名类型传递给EF查询将导致EF仅选择您定义的字段。可以将数十列的“无法重构”的怪物表分解为实际需要的3或4个字段。一次选择整个实体并假装无能为力的迷恋只能描述为一种大众歇斯底里的形式，我们大声疾呼，“我看不到你！”</p>\n<h1 id=\"使用正确的工具完成工作\"><a href=\"#使用正确的工具完成工作\" class=\"headerlink\" title=\"使用正确的工具完成工作\"></a>使用正确的工具完成工作</h1><p>您知道所有带有封面上各种工具的Microsoft Press书籍吗？您知道，除了某些人只是选择随机图像之外，还有一个原因。大多数工具不仅是螺丝起子或刨刀。有一些真正的奇怪应用没有明显的应用，但是可以肯定的是，它们有自己的目标，并且擅长于此。“正确的工具”的口号经常重复出现，但是我们并没有真正停下来思考工作，更不用说工具了。以下是EF的一些功能。</p>\n<h3 id=\"自-Net-2-0以来出现的SqlBulkCopy\"><a href=\"#自-Net-2-0以来出现的SqlBulkCopy\" class=\"headerlink\" title=\"自.Net 2.0以来出现的SqlBulkCopy\"></a>自.Net 2.0以来出现的SqlBulkCopy</h3><p>另一个与EF数据量密切相关的大型抱怨是，EF检索到它据称无法处理大量数据的方式。我喜欢开发人员的双重性。我想让您知道，结合下面讨论的AsStreaming，反应性扩展和SqlBulkCopy，我可以在一分钟内检索，转换和推送数百万条记录，而不会费力地创建一个完全基于任何工作负载的完全基于代码的ETL解决方案从较小的记录到中等大小的记录（例如5–100亿条记录），并且仍然具有良好的性能。如果您需要更多，则有更多专用工具。但是，不要说Entity Framework无法处理大量数据。 <em>您的代码无法处理大量数据。</em>EF很好。</p>\n<p>可悲的是，自2005年以来我们就拥有SqlBulkCopy，但我们却假装工具箱中有这个大漏洞。问题已经解决。重新发明轮子的理由为零。你猜怎么了？它也支持流！</p>\n<h3 id=\"AsTracking与AsNoTracking\"><a href=\"#AsTracking与AsNoTracking\" class=\"headerlink\" title=\"AsTracking与AsNoTracking\"></a>AsTracking与AsNoTracking</h3><p>我觉得自己的成绩很差。关于EF的另一个大抱怨是它的数据缓存。您几乎总是可以告诉DbContext摆脱缓存的实体。不过，最近，我们获得了将其设置为Entity Framework Core中默认策略的能力。相反，我们可以选择要跟踪的内容，而不是不需要的内容。我很高兴地承认一个烦恼，即您仍然需要分离实体。</p>\n<h3 id=\"流式传输\"><a href=\"#流式传输\" class=\"headerlink\" title=\"流式传输\"></a>流式传输</h3><p>实体框架中的查询通常在返回之前缓冲所有结果。流技术解决了这一问题，并立即让您开始处理数据进入应用程序的过程。您既可以更快地开始工作，又可以使服务器对内存更友好。</p>\n<h3 id=\"特殊雪花\"><a href=\"#特殊雪花\" class=\"headerlink\" title=\"特殊雪花\"></a>特殊雪花</h3><p>在开发人员中，我看到了一个令人不安的趋势。缺乏探索和发明的欲望。我们想要开箱即用的解决方案，在不了解细节的情况下“可行”。即使代码不是魔术，我们仍然相信看不见的魔术。</p>\n<p>我采用的一般方法不是构建这些固定的仓储，而是构建扩展，使我们的应用程序以我们需要它们的独特方式运行。是否希望在运行时间较长的过程中缓存数据的好处，但又不能在给定操作之外继续存在呢？对于我来说，这听起来像是DbContext的完美扩展方法，该方法可以获取一些实体，对其进行处理以获得缓存的好处，然后在返回之前清除缓存。另一种扩展方法是在操作完成后分离所有那些实体的方法。</p>\n<h1 id=\"不要害怕\"><a href=\"#不要害怕\" class=\"headerlink\" title=\"不要害怕\"></a>不要害怕</h1><p>我在这里谈论DbContext是因为有很多人对待它。它被视为一件大，笨重，笨拙的事情，如果您不小心的话，它们会偷走您的孩子。我们花了很长的时间才能使DbContext的存在只为少数几个组件所知。这将我们的实现进一步扼杀到仓储中。由于我们<em>必须</em>遍历仓储以获取任何类型的数据，因此我们需要在发生更改时定期违反“开放/关闭”原则，或者被迫接受仓储指示的决策膨胀的折衷，并且在使用时要格外小心我们打电话给它。</p>\n<p>释放DbContext。如果模块需要数据，请不要自欺欺人，说DbContext还不是依赖项。我可以向您保证，如果您对它的可访问性感到满意，并消除“人们犯错了怎么办？！”的神秘主义。它实际上将使我们整体上变得更好。如果某人可以提交顽皮的代码，并且至少使它经过一次未经测试的生产，则您实际上就没有发布控制或质量检查。诸如隐藏DbContext之类的策略是您组织中已经流血的伤口上的权宜之计，无助于真正缓解实际问题。</p>\n<h1 id=\"别再找借口\"><a href=\"#别再找借口\" class=\"headerlink\" title=\"别再找借口\"></a>别再找借口</h1><p>我们程序员必须停止像解决我们所遇到的问题的解决方案那样行动，或者必须使用node.js和dapper的正确组合来区分它们，这并不是说它们没有合法用途，而是经常被他们当作替罪羊实体框架是一种很好的工具，可以用来做某事。我们十年来拥有的工具已经足以满足我们的大多数需求。一次又一次的错误决定最终导致错误的决定，使我们陷入困境。使您的工具适应自如。尝试新事物。可以肯定的是，我们只能怪自己。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>这是一个对话性的讨论，它讨论了一个严重的问题趋势，我发现在由初级团队到架构师团队的各种规模的组织中，EntityFramework的利用率都很高。这不是一个如何做的问题,这也不适合新手。如果有什么能激发您的想法，或者您对我提到的事情感到好奇，那么Google是您的朋友。这也是我的第一篇博客文章。欢迎批评。</p>\n<h1 id=\"历史和功能介绍（按版本）\"><a href=\"#历史和功能介绍（按版本）\" class=\"headerlink\" title=\"历史和功能介绍（按版本）\"></a>历史和功能介绍（按版本）</h1><p>首先，让我们简单回顾一下EF随时间推移推出的功能。这绝不是详尽无遗的，当然也不会通过对主要版本的更新列出所有内容。它只是提醒了迄今为止EF的故事。</p>\n<h5 id=\"EF-EF-3-5\"><a href=\"#EF-EF-3-5\" class=\"headerlink\" title=\"EF / EF 3.5\"></a>EF / EF 3.5</h5><p>· DB First</p>\n<h5 id=\"EF-4-0\"><a href=\"#EF-4-0\" class=\"headerlink\" title=\"EF 4.0\"></a>EF 4.0</h5><p>· Lazy Loading</p>\n<p>· Migrations</p>\n<p>· POCOs</p>\n<h5 id=\"EF-5\"><a href=\"#EF-5\" class=\"headerlink\" title=\"EF 5\"></a>EF 5</h5><p>· Enums</p>\n<p>· Spatial</p>\n<h5 id=\"EF-6\"><a href=\"#EF-6\" class=\"headerlink\" title=\"EF 6\"></a>EF 6</h5><p>· Async</p>\n<p>· Interception</p>\n<p>· Logging</p>\n<p>· NuGet Installation</p>\n<p>· Recovery</p>\n<h5 id=\"EF-7-Core\"><a href=\"#EF-7-Core\" class=\"headerlink\" title=\"EF 7 / Core\"></a>EF 7 / Core</h5><p>· Code First Only</p>\n<p>· In-Memory Support</p>\n<p>· Limited Batching</p>\n<p>· Nonrelational Support</p>\n<p>看到这种零散的发布以及Microsoft在开发领域的普遍声誉，Entity Framework有了一个不好的惊喜，并不是因为它为我将要解决的问题找借口而已。根据您正在使用的次要版本，功能似乎随机出现。因此，即使安装了相同的主要版本，您仍会习惯某些东西，转到另一个环境，提出声明并在其现有框架上进行尝试，即使它没有安装，您也仍然会“告诉您”的样子有助于进一步加深已经确立的地位。</p>\n<p>基本上，EF的典型故事如下：</p>\n<p>高级人士：“让我们使用EF和仓储模式！”</p>\n<p>其他开发人员：“ Idk，还没听说过好消息。”</p>\n<p>高级：“不，太好了！看到这个例子吗？”</p>\n<p>开发人员：“嗯，好的。”</p>\n<p>起初，它的工作原理在可接受的范围内。然而，随着它的增长，迟缓开始出现，人们开始抱怨。由于我们行业中偿还技术债务的状况非常糟糕，或者由于完全拒绝首先查看仓储模式中的技术债务，因此，据称聪明的人的整个部门都袖手旁观，只是得出结论，<code>”EF是垃圾&quot;</code>，并不是说他们的使用是垃圾。</p>\n<p>我在这里要说明的是后者，并向您展示如何避免该陷阱。</p>\n<h1 id=\"EF使Sql查询过程得以抽象\"><a href=\"#EF使Sql查询过程得以抽象\" class=\"headerlink\" title=\"EF使Sql查询过程得以抽象\"></a>EF使Sql查询过程得以抽象</h1><p>在我职业生涯的早期，我开始直接通过ADO使用经典的ASP和SQL Server。我在一个非常小的网络部门工作，因此我经常不得不亲自进入数据库来创建表和执行任务。在一系列复制/粘贴部署，生产测试等过程中，我很快熟悉了SQL Server的所有技巧。“那这个呢？<em>不会，该产品页面仍然无法加载。</em>那个怎么样？！<em>不，仍然无法加载。</em>来吧…这个？<em>成功！</em>通过几乎在黑暗中绊倒，我对索引，视图，复制，安全权限等等非常了解，当时甚至还没读完高中。</p>\n<p>使用结构化的环境输入我的前几个地方，然后使用Entity Framework时让我非常脸红。它完全没有我习惯的任何选择。因此，我跳上船，但是没多久就开始抱怨。如果您有金鱼的记忆，让我重申我习惯于随意调整所有杠杆。遇到问题时，我会进行调查。通常，我发现诸如索引利用率之类的关键组件被完全忽略了。当我提出这些问题时，我被告知EF因不知道如何利用它们而感到过失，而我们是在这里处理业务问题，而不是由Microsoft来为他们做。老实说，我基本上还是一个初级开发人员。我有什么理由不同意呢?</p>\n<h2 id=\"仓储模式存在的问题\"><a href=\"#仓储模式存在的问题\" class=\"headerlink\" title=\"仓储模式存在的问题\"></a>仓储模式存在的问题</h2><p>点击访问<a href=\"http://bfy.tw/3pSK\" target=\"_blank\" rel=\"noopener\">仓储模式</a>。仓储模式的问题有两个方面。存储库模式的问题有两个方面。首先，它要求您预先声明如何绑定应用程序与数据库进行交互。即使您构建了这些超级复杂的方法，这些方法允许您传入表达式、字典或异常动态，并且您很有创造力，但是您所做的只是制造了一个维护噩梦。</p>\n<p>“但是调用者可以定义他们所需要的！” 不，他们不能。当然，他们可以指向实体并通常定义要选择的数据的形状，但是他们无法确定字段选择之类的内容。他们没有办法说他们需要以一种友好的方式预先加载数据或延迟数据。他们不能在一次实例化中说他们也需要来自这里或那里的数据，但在下一次实例化中，他们只需要找到目标实体，除非神圣的存储库允许他们这样做。相反，您会得到这些全有或全无的决策，这些决策将您的应用程序链接在一起，我们想知道为什么它会很快降级。我真的希望你的水晶球比我的好。</p>\n<p>其次，即使是微软自己的例子也没有使用某些实习生可能编写的适当接口。因此，我说，每个人都做错了。关于EF的常识是使用存储库模式，由于存储库模式本身的文档和示例不正确，所以没有人会让EF做它被设计用来做的事情，因为知识的来源受到了毒害。面对这种情况，我听到很多人抱怨说MVC教程的例子直接使用了DbContext，抱怨说它不够稳定，也不是说几乎没有人做得很稳定，但这是另一篇博客文章。(大多数软件直接跳转到ID，忽略了其他的。)</p>\n<h2 id=\"让数据库成为数据库\"><a href=\"#让数据库成为数据库\" class=\"headerlink\" title=\"让数据库成为数据库\"></a>让数据库成为数据库</h2><p>由于SQL Server是EF中最常用的支持数据存储，因此它不是一个干净的软件。太乱了 ，它具有大量场景的功能。如果您想让您的应用程序实际使用您所支付的巨额许可费用的一小部分，请停止将SQL约束到EF驱动的地狱荒原，而这些荒地比SELECT *还要好。然后，我们喜欢抱怨事情进展缓慢。</p>\n<p>如果您不让EF在正确的情况下利用功能，则可能无法意识到平台的潜力。必须浪费数十亿美元的许可和开发成本，即使在应用程序以截然不同的方式增长时，使用的独特功能也只会使SQL Server的单位利用率下降。这是一种直觉，但是看到我在大型和小型公司中看到的愚蠢的朴素仓储实现，很难在这里看到我是完全错误的。这对我们自己，我们的雇主和彼此都是有害的。</p>\n<p>实体框架仍然逐步锁定在基础数据存储的工作方式上。在SQL Server中，这意味着联接性能，视图和索引利用率，存储过程调用等。这就像将乳胶手套称为手的抽象。它不是，EF也不是它所依赖的存储机制的抽象。相反，它是一组通用的API，它们使我们能够以统一的方式访问数据。由于我刚才所说的原因（我们不能以任何方式否认或减轻基础实现的行为），这不是一个抽象。因此，我们必须在代码中考虑显式或隐式破坏抽象的那些行为。如果要假装它是抽象，我们唯一能做的就是把头埋在沙子里，然后在事情变得笨拙时继续continue吟。</p>\n<p>最近，我遇到了—架构师—几乎对让数据库定义视图和将EF指向视图而不是表的建议感到敬畏，您知道，这让dba能够真正完成他们的工作，并使数据库能够在不破坏应用程序代码的情况下进行更改。这并不是什么难事，但问题是普遍存在的，所以大多数人在他们太熟悉的环境中都看不到过去。那么，我们该怎么做呢?</p>\n<h1 id=\"使用IQueryable而不是IEnumerable\"><a href=\"#使用IQueryable而不是IEnumerable\" class=\"headerlink\" title=\"使用IQueryable而不是IEnumerable\"></a>使用IQueryable而不是IEnumerable</h1><p>正确使用Entity Framework的第一步是打破与IEnumerable的依赖关系。当谈论断开连接的商店时，这是很糟糕的。IEnumerable唯一给出的就是延迟执行。如果这是您想要脱离ORM的唯一功能，那么您就不需要ORM。IEnumerable隐瞒使用数据存储的原因在于，它们一劳永逸地固定在它们的表示中。即使应用程序增长，即使仓储中添加了新方法，返回IEnumerable的旧实现也对它们所处的新世界都是盲目，聋哑和愚蠢的。您实际上是在强迫代码与数据布局和期望一起使用。就像几年前首次实施时一样。这是开发人员的错，但应归咎于EF。</p>\n<p>但是，IQueryable可以变形并更改为其给定的上下文。即使传递和添加了子句，它也可以评估实例，例如各个调用的需求。如果DbContext已经获取了数据，但它仍可以从高速缓存中检索实体，然后才能以非常快的速度进行重复调用，从而使热路径更加凉爽。更重要的是，它还提供了一些功能，例如，如果基础提供程序支持的话，让我们流数据；无需实例化List对象以使其对堆更友好地加载数据；检查基础类型，以便我们可以在复杂的工作流程中做出明智的决定；访问基础上下文, 等等。</p>\n<p>这些都是使您的代码真正了解正在发生的事情而不会破坏抽象障碍的所有功能，因为EF不是抽象。顺便说一句，抽象应该是使用EF的组件，而不是EF本身。我在程序员进行的许多讨论中表达了自己的见解，这些讨论表达了一些需求，但是我们以“抽象”的名义对许多解决方案solutions之以鼻，随之而来的是我们高兴地扭曲自己的箍，这样我们就可以继续存在固体。</p>\n<h1 id=\"习惯匿名类型\"><a href=\"#习惯匿名类型\" class=\"headerlink\" title=\"习惯匿名类型\"></a>习惯匿名类型</h1><p>我听说过的关于EF的最大的抱怨也许就是它检索了多少该死的数据。谁定义实体？EF？没有！你做到了 从本质上讲，您不必多怪，因为每个表的实体似乎是所有人都可以看到的。尽管如此，无论实体有多大，我们都无需受到阻碍。将匿名类型传递给EF查询将导致EF仅选择您定义的字段。可以将数十列的“无法重构”的怪物表分解为实际需要的3或4个字段。一次选择整个实体并假装无能为力的迷恋只能描述为一种大众歇斯底里的形式，我们大声疾呼，“我看不到你！”</p>\n<h1 id=\"使用正确的工具完成工作\"><a href=\"#使用正确的工具完成工作\" class=\"headerlink\" title=\"使用正确的工具完成工作\"></a>使用正确的工具完成工作</h1><p>您知道所有带有封面上各种工具的Microsoft Press书籍吗？您知道，除了某些人只是选择随机图像之外，还有一个原因。大多数工具不仅是螺丝起子或刨刀。有一些真正的奇怪应用没有明显的应用，但是可以肯定的是，它们有自己的目标，并且擅长于此。“正确的工具”的口号经常重复出现，但是我们并没有真正停下来思考工作，更不用说工具了。以下是EF的一些功能。</p>\n<h3 id=\"自-Net-2-0以来出现的SqlBulkCopy\"><a href=\"#自-Net-2-0以来出现的SqlBulkCopy\" class=\"headerlink\" title=\"自.Net 2.0以来出现的SqlBulkCopy\"></a>自.Net 2.0以来出现的SqlBulkCopy</h3><p>另一个与EF数据量密切相关的大型抱怨是，EF检索到它据称无法处理大量数据的方式。我喜欢开发人员的双重性。我想让您知道，结合下面讨论的AsStreaming，反应性扩展和SqlBulkCopy，我可以在一分钟内检索，转换和推送数百万条记录，而不会费力地创建一个完全基于任何工作负载的完全基于代码的ETL解决方案从较小的记录到中等大小的记录（例如5–100亿条记录），并且仍然具有良好的性能。如果您需要更多，则有更多专用工具。但是，不要说Entity Framework无法处理大量数据。 <em>您的代码无法处理大量数据。</em>EF很好。</p>\n<p>可悲的是，自2005年以来我们就拥有SqlBulkCopy，但我们却假装工具箱中有这个大漏洞。问题已经解决。重新发明轮子的理由为零。你猜怎么了？它也支持流！</p>\n<h3 id=\"AsTracking与AsNoTracking\"><a href=\"#AsTracking与AsNoTracking\" class=\"headerlink\" title=\"AsTracking与AsNoTracking\"></a>AsTracking与AsNoTracking</h3><p>我觉得自己的成绩很差。关于EF的另一个大抱怨是它的数据缓存。您几乎总是可以告诉DbContext摆脱缓存的实体。不过，最近，我们获得了将其设置为Entity Framework Core中默认策略的能力。相反，我们可以选择要跟踪的内容，而不是不需要的内容。我很高兴地承认一个烦恼，即您仍然需要分离实体。</p>\n<h3 id=\"流式传输\"><a href=\"#流式传输\" class=\"headerlink\" title=\"流式传输\"></a>流式传输</h3><p>实体框架中的查询通常在返回之前缓冲所有结果。流技术解决了这一问题，并立即让您开始处理数据进入应用程序的过程。您既可以更快地开始工作，又可以使服务器对内存更友好。</p>\n<h3 id=\"特殊雪花\"><a href=\"#特殊雪花\" class=\"headerlink\" title=\"特殊雪花\"></a>特殊雪花</h3><p>在开发人员中，我看到了一个令人不安的趋势。缺乏探索和发明的欲望。我们想要开箱即用的解决方案，在不了解细节的情况下“可行”。即使代码不是魔术，我们仍然相信看不见的魔术。</p>\n<p>我采用的一般方法不是构建这些固定的仓储，而是构建扩展，使我们的应用程序以我们需要它们的独特方式运行。是否希望在运行时间较长的过程中缓存数据的好处，但又不能在给定操作之外继续存在呢？对于我来说，这听起来像是DbContext的完美扩展方法，该方法可以获取一些实体，对其进行处理以获得缓存的好处，然后在返回之前清除缓存。另一种扩展方法是在操作完成后分离所有那些实体的方法。</p>\n<h1 id=\"不要害怕\"><a href=\"#不要害怕\" class=\"headerlink\" title=\"不要害怕\"></a>不要害怕</h1><p>我在这里谈论DbContext是因为有很多人对待它。它被视为一件大，笨重，笨拙的事情，如果您不小心的话，它们会偷走您的孩子。我们花了很长的时间才能使DbContext的存在只为少数几个组件所知。这将我们的实现进一步扼杀到仓储中。由于我们<em>必须</em>遍历仓储以获取任何类型的数据，因此我们需要在发生更改时定期违反“开放/关闭”原则，或者被迫接受仓储指示的决策膨胀的折衷，并且在使用时要格外小心我们打电话给它。</p>\n<p>释放DbContext。如果模块需要数据，请不要自欺欺人，说DbContext还不是依赖项。我可以向您保证，如果您对它的可访问性感到满意，并消除“人们犯错了怎么办？！”的神秘主义。它实际上将使我们整体上变得更好。如果某人可以提交顽皮的代码，并且至少使它经过一次未经测试的生产，则您实际上就没有发布控制或质量检查。诸如隐藏DbContext之类的策略是您组织中已经流血的伤口上的权宜之计，无助于真正缓解实际问题。</p>\n<h1 id=\"别再找借口\"><a href=\"#别再找借口\" class=\"headerlink\" title=\"别再找借口\"></a>别再找借口</h1><p>我们程序员必须停止像解决我们所遇到的问题的解决方案那样行动，或者必须使用node.js和dapper的正确组合来区分它们，这并不是说它们没有合法用途，而是经常被他们当作替罪羊实体框架是一种很好的工具，可以用来做某事。我们十年来拥有的工具已经足以满足我们的大多数需求。一次又一次的错误决定最终导致错误的决定，使我们陷入困境。使您的工具适应自如。尝试新事物。可以肯定的是，我们只能怪自己。</p>\n"},{"title":"深圳敢为软件技术长沙研发中心招聘.NET工程师（前后端）","date":"2019-10-28T08:58:00.000Z","author":"邹溪源","_content":"\n深圳敢为软件技术长沙研发中心招聘.NET工程师\n\n招聘岗位1：.net初级研发工程师\n\n任职资格：\n\n1、大专及以上学历，计算机或其他相关专业；\n\n2、1年以上相关工作经验，能够进行独立设计与开发工作；\n\n3、熟悉C#/Java语言编程，了解Asp.NET、ASP.NET Core架构开发；\n\n4、熟练掌握SQL SERVER、Mysql数据库进行开发；熟练掌握WEB开发相关 HTML、JavaScript、DIV+CSS、AJAX、JQuery 或者熟悉Vue，Angular等前端开发或了解WPF、U3D、WebGL开发；\n\n5、具有良好的基础知识和优良的编程风格和习惯，并有软件工程概念；有独立项目经验优先； \n\n6、有冲劲，肯学习，想往物联网、智能家居等新技术方向发展。\n待遇5-7k\n\n \n\n招聘岗位2：.net中级研发工程师\n\n任职资格：\n\n1、全日制本科及以上学历，计算机或其他相关专业；\n\n2、3年左右相关工作经验，能够进行独立设计与开发工作；\n\n3、熟悉C#/Java语言编程，熟悉Asp.NET、ASP.NET Core架构开发；\n\n4、 熟练掌握SQL SERVER、Mysql数据库进行开发；熟练掌握WEB开发相关 HTML、JavaScript、DIV+CSS、AJAX、JQuery 或者熟悉Vue，Angular等前端开发或熟悉WPF、U3D、WebGL开发；\n\n5、具有良好的基础知识和优良的编程风格和习惯，并有软件工程概念；有独立负责项目的经验； \n\n6、有冲劲，肯学习，想往物联网等新技术方向发展。\n\n岗位职责：\n\n1、按项目计划完成系统分析、设计、编码和内部测试；\n\n2、能够在架构师的帮助下独立完成项目需求调研、分析、设计；\n\n3、及时跟进及反馈工作情况，并根据实际情况提出改进建议；\n\n4、进行文档编写以及用户培训等工作。\n待遇7-13k\n\n\n招聘岗位3：.net高级研发工程师\n\n任职资格：\n\n1、全日制本科及以上学历，计算机或其他相关专业；\n\n2、5年左右相关工作经验，能够进行独立设计与开发工作；\n\n3、熟悉C#/Java语言编程，熟悉ASP.NET、Asp.NET Core架构开发；\n\n4、熟练掌握SQL SERVER、Mysql数据库进行开发；熟练掌握WEB开发相关 HTML、JavaScript、DIV+CSS、AJAX、JQuery 或者熟悉Vue，Angular等前端开发或熟悉WPF、U3D、WebGL开发；\n\n5、具有良好的基础知识和优良的编程风格和习惯，并有软件工程概念；有独立负责项目的经验；\n\n6、熟悉Three.js、对U3D,IOT，WPF有经验或.NET Core 容器化和基于Kubernetes 的云原生应用开发经验优先；\n\n7、有冲劲，肯学习，想往物联网等新技术方向发展。\n\n\n岗位职责：\n\n1、按项目计划完成系统分析、设计、编码和内部测试；\n\n2、能够独立完成项目需求调研、分析、设计；\n\n3、及时跟进及反馈工作情况，并根据实际情况提出改进建议；\n\n4、进行文档编写以及用户培训等工作。 \n待遇10-18k\n\n联系人：18973108440 。（溪源）\n地址：梅溪湖金茂悦31楼，猪八戒众创空间","source":"_posts/管理/JobChance.md","raw":"---\ntitle:  深圳敢为软件技术长沙研发中心招聘.NET工程师（前后端）\ndate: 2019-10-28 16:58\ntags: 管理\nauthor: 邹溪源\ncategories:\n  - 管理\n---\n\n深圳敢为软件技术长沙研发中心招聘.NET工程师\n\n招聘岗位1：.net初级研发工程师\n\n任职资格：\n\n1、大专及以上学历，计算机或其他相关专业；\n\n2、1年以上相关工作经验，能够进行独立设计与开发工作；\n\n3、熟悉C#/Java语言编程，了解Asp.NET、ASP.NET Core架构开发；\n\n4、熟练掌握SQL SERVER、Mysql数据库进行开发；熟练掌握WEB开发相关 HTML、JavaScript、DIV+CSS、AJAX、JQuery 或者熟悉Vue，Angular等前端开发或了解WPF、U3D、WebGL开发；\n\n5、具有良好的基础知识和优良的编程风格和习惯，并有软件工程概念；有独立项目经验优先； \n\n6、有冲劲，肯学习，想往物联网、智能家居等新技术方向发展。\n待遇5-7k\n\n \n\n招聘岗位2：.net中级研发工程师\n\n任职资格：\n\n1、全日制本科及以上学历，计算机或其他相关专业；\n\n2、3年左右相关工作经验，能够进行独立设计与开发工作；\n\n3、熟悉C#/Java语言编程，熟悉Asp.NET、ASP.NET Core架构开发；\n\n4、 熟练掌握SQL SERVER、Mysql数据库进行开发；熟练掌握WEB开发相关 HTML、JavaScript、DIV+CSS、AJAX、JQuery 或者熟悉Vue，Angular等前端开发或熟悉WPF、U3D、WebGL开发；\n\n5、具有良好的基础知识和优良的编程风格和习惯，并有软件工程概念；有独立负责项目的经验； \n\n6、有冲劲，肯学习，想往物联网等新技术方向发展。\n\n岗位职责：\n\n1、按项目计划完成系统分析、设计、编码和内部测试；\n\n2、能够在架构师的帮助下独立完成项目需求调研、分析、设计；\n\n3、及时跟进及反馈工作情况，并根据实际情况提出改进建议；\n\n4、进行文档编写以及用户培训等工作。\n待遇7-13k\n\n\n招聘岗位3：.net高级研发工程师\n\n任职资格：\n\n1、全日制本科及以上学历，计算机或其他相关专业；\n\n2、5年左右相关工作经验，能够进行独立设计与开发工作；\n\n3、熟悉C#/Java语言编程，熟悉ASP.NET、Asp.NET Core架构开发；\n\n4、熟练掌握SQL SERVER、Mysql数据库进行开发；熟练掌握WEB开发相关 HTML、JavaScript、DIV+CSS、AJAX、JQuery 或者熟悉Vue，Angular等前端开发或熟悉WPF、U3D、WebGL开发；\n\n5、具有良好的基础知识和优良的编程风格和习惯，并有软件工程概念；有独立负责项目的经验；\n\n6、熟悉Three.js、对U3D,IOT，WPF有经验或.NET Core 容器化和基于Kubernetes 的云原生应用开发经验优先；\n\n7、有冲劲，肯学习，想往物联网等新技术方向发展。\n\n\n岗位职责：\n\n1、按项目计划完成系统分析、设计、编码和内部测试；\n\n2、能够独立完成项目需求调研、分析、设计；\n\n3、及时跟进及反馈工作情况，并根据实际情况提出改进建议；\n\n4、进行文档编写以及用户培训等工作。 \n待遇10-18k\n\n联系人：18973108440 。（溪源）\n地址：梅溪湖金茂悦31楼，猪八戒众创空间","slug":"管理/JobChance","published":1,"updated":"2019-10-28T08:58:41.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt890023n4vihclf3fxu","content":"<p>深圳敢为软件技术长沙研发中心招聘.NET工程师</p>\n<p>招聘岗位1：.net初级研发工程师</p>\n<p>任职资格：</p>\n<p>1、大专及以上学历，计算机或其他相关专业；</p>\n<p>2、1年以上相关工作经验，能够进行独立设计与开发工作；</p>\n<p>3、熟悉C#/Java语言编程，了解Asp.NET、ASP.NET Core架构开发；</p>\n<p>4、熟练掌握SQL SERVER、Mysql数据库进行开发；熟练掌握WEB开发相关 HTML、JavaScript、DIV+CSS、AJAX、JQuery 或者熟悉Vue，Angular等前端开发或了解WPF、U3D、WebGL开发；</p>\n<p>5、具有良好的基础知识和优良的编程风格和习惯，并有软件工程概念；有独立项目经验优先； </p>\n<p>6、有冲劲，肯学习，想往物联网、智能家居等新技术方向发展。<br>待遇5-7k</p>\n<p>招聘岗位2：.net中级研发工程师</p>\n<p>任职资格：</p>\n<p>1、全日制本科及以上学历，计算机或其他相关专业；</p>\n<p>2、3年左右相关工作经验，能够进行独立设计与开发工作；</p>\n<p>3、熟悉C#/Java语言编程，熟悉Asp.NET、ASP.NET Core架构开发；</p>\n<p>4、 熟练掌握SQL SERVER、Mysql数据库进行开发；熟练掌握WEB开发相关 HTML、JavaScript、DIV+CSS、AJAX、JQuery 或者熟悉Vue，Angular等前端开发或熟悉WPF、U3D、WebGL开发；</p>\n<p>5、具有良好的基础知识和优良的编程风格和习惯，并有软件工程概念；有独立负责项目的经验； </p>\n<p>6、有冲劲，肯学习，想往物联网等新技术方向发展。</p>\n<p>岗位职责：</p>\n<p>1、按项目计划完成系统分析、设计、编码和内部测试；</p>\n<p>2、能够在架构师的帮助下独立完成项目需求调研、分析、设计；</p>\n<p>3、及时跟进及反馈工作情况，并根据实际情况提出改进建议；</p>\n<p>4、进行文档编写以及用户培训等工作。<br>待遇7-13k</p>\n<p>招聘岗位3：.net高级研发工程师</p>\n<p>任职资格：</p>\n<p>1、全日制本科及以上学历，计算机或其他相关专业；</p>\n<p>2、5年左右相关工作经验，能够进行独立设计与开发工作；</p>\n<p>3、熟悉C#/Java语言编程，熟悉ASP.NET、Asp.NET Core架构开发；</p>\n<p>4、熟练掌握SQL SERVER、Mysql数据库进行开发；熟练掌握WEB开发相关 HTML、JavaScript、DIV+CSS、AJAX、JQuery 或者熟悉Vue，Angular等前端开发或熟悉WPF、U3D、WebGL开发；</p>\n<p>5、具有良好的基础知识和优良的编程风格和习惯，并有软件工程概念；有独立负责项目的经验；</p>\n<p>6、熟悉Three.js、对U3D,IOT，WPF有经验或.NET Core 容器化和基于Kubernetes 的云原生应用开发经验优先；</p>\n<p>7、有冲劲，肯学习，想往物联网等新技术方向发展。</p>\n<p>岗位职责：</p>\n<p>1、按项目计划完成系统分析、设计、编码和内部测试；</p>\n<p>2、能够独立完成项目需求调研、分析、设计；</p>\n<p>3、及时跟进及反馈工作情况，并根据实际情况提出改进建议；</p>\n<p>4、进行文档编写以及用户培训等工作。<br>待遇10-18k</p>\n<p>联系人：18973108440 。（溪源）<br>地址：梅溪湖金茂悦31楼，猪八戒众创空间</p>\n","site":{"data":{}},"excerpt":"","more":"<p>深圳敢为软件技术长沙研发中心招聘.NET工程师</p>\n<p>招聘岗位1：.net初级研发工程师</p>\n<p>任职资格：</p>\n<p>1、大专及以上学历，计算机或其他相关专业；</p>\n<p>2、1年以上相关工作经验，能够进行独立设计与开发工作；</p>\n<p>3、熟悉C#/Java语言编程，了解Asp.NET、ASP.NET Core架构开发；</p>\n<p>4、熟练掌握SQL SERVER、Mysql数据库进行开发；熟练掌握WEB开发相关 HTML、JavaScript、DIV+CSS、AJAX、JQuery 或者熟悉Vue，Angular等前端开发或了解WPF、U3D、WebGL开发；</p>\n<p>5、具有良好的基础知识和优良的编程风格和习惯，并有软件工程概念；有独立项目经验优先； </p>\n<p>6、有冲劲，肯学习，想往物联网、智能家居等新技术方向发展。<br>待遇5-7k</p>\n<p>招聘岗位2：.net中级研发工程师</p>\n<p>任职资格：</p>\n<p>1、全日制本科及以上学历，计算机或其他相关专业；</p>\n<p>2、3年左右相关工作经验，能够进行独立设计与开发工作；</p>\n<p>3、熟悉C#/Java语言编程，熟悉Asp.NET、ASP.NET Core架构开发；</p>\n<p>4、 熟练掌握SQL SERVER、Mysql数据库进行开发；熟练掌握WEB开发相关 HTML、JavaScript、DIV+CSS、AJAX、JQuery 或者熟悉Vue，Angular等前端开发或熟悉WPF、U3D、WebGL开发；</p>\n<p>5、具有良好的基础知识和优良的编程风格和习惯，并有软件工程概念；有独立负责项目的经验； </p>\n<p>6、有冲劲，肯学习，想往物联网等新技术方向发展。</p>\n<p>岗位职责：</p>\n<p>1、按项目计划完成系统分析、设计、编码和内部测试；</p>\n<p>2、能够在架构师的帮助下独立完成项目需求调研、分析、设计；</p>\n<p>3、及时跟进及反馈工作情况，并根据实际情况提出改进建议；</p>\n<p>4、进行文档编写以及用户培训等工作。<br>待遇7-13k</p>\n<p>招聘岗位3：.net高级研发工程师</p>\n<p>任职资格：</p>\n<p>1、全日制本科及以上学历，计算机或其他相关专业；</p>\n<p>2、5年左右相关工作经验，能够进行独立设计与开发工作；</p>\n<p>3、熟悉C#/Java语言编程，熟悉ASP.NET、Asp.NET Core架构开发；</p>\n<p>4、熟练掌握SQL SERVER、Mysql数据库进行开发；熟练掌握WEB开发相关 HTML、JavaScript、DIV+CSS、AJAX、JQuery 或者熟悉Vue，Angular等前端开发或熟悉WPF、U3D、WebGL开发；</p>\n<p>5、具有良好的基础知识和优良的编程风格和习惯，并有软件工程概念；有独立负责项目的经验；</p>\n<p>6、熟悉Three.js、对U3D,IOT，WPF有经验或.NET Core 容器化和基于Kubernetes 的云原生应用开发经验优先；</p>\n<p>7、有冲劲，肯学习，想往物联网等新技术方向发展。</p>\n<p>岗位职责：</p>\n<p>1、按项目计划完成系统分析、设计、编码和内部测试；</p>\n<p>2、能够独立完成项目需求调研、分析、设计；</p>\n<p>3、及时跟进及反馈工作情况，并根据实际情况提出改进建议；</p>\n<p>4、进行文档编写以及用户培训等工作。<br>待遇10-18k</p>\n<p>联系人：18973108440 。（溪源）<br>地址：梅溪湖金茂悦31楼，猪八戒众创空间</p>\n"},{"title":"怎样的项目，才能称为“成功项目”？","date":"2019-10-09T08:28:00.000Z","author":"邹溪源","_content":"\n\n\n* 引子\n\n这个故事讲的是一家拥有百年历史的制造业大厂的信息化转型过程中的波折。这家企业拥有超过三万名员工，它是某行业的领先品牌，但是在信息化程度上却非常古老。\n有许多人说，国企的项目都是坑，相当一部分项目都是为了骗经费而忽悠人的，换一拨管理层，基本上就得换一拨项目，油水全被领导捞走了。我很遗憾，没能经历这些事情。这个项目实打实都是做出来给基层用的项目，也确实获得了各方较高的满意度。\n以中台为政治正确的互联网开发者们会说，这个项目从商业层面和技术上来说似乎毫无价值，首先它不是互联网产品，其次它没什么技术含量，什么大数据，云计算，容器，微服务，无服务，它都不需要，这甚至有点像我们身边许多人十年前就做过的项目，技术上平淡无奇，看起来毫无挑战。\n显然并非如此，每个项目存在都有价值。作为过程中的亲历者，我希望通过总结这个项目过程中存在的不足，引起思考和引发讨论。尤其是随着时代的进步，像这样信息化转型的传统制造业企业，或许越来越罕见，这样的项目看起来非常独特，但也是软件项目中的一个典型，对于未来从事行业互联网开发的软件从业人员来说，也许能带来一些思考。\n* 背景\n\n2015年开始，制造业企业开始流行起一种新的趋势：工业4.0，在这个大背景下，国内则提出了中国制造2025的计划，旨在通过几年努力，实现中国制造业的智能化水平在上一个台阶。\n该大型国企作为该某领域的领先品牌，其生产的产品远销国内外，也是军民融合的典型代表，但是在过去的发展过程中，由于产品本身比较特殊，许多关键步骤仍然是采用手工完成，无法完全实现自动化替代，包括检验管理体系也同样建立在一大堆纸质表单的基础上完成。集团管理层看到了中国制造2025带来的巨大机遇，也想奋斗一波，但要做的事情实在是太多了。\n康威定律说，一个组织的软件架构设计，实际上是组织管理形式的体现。在9012年的今天，为了维持这样一套以纸质表单为核心的检验管理体系，需要维持庞大的管理体系，带来了巨大的管理成本，对于组织来说本身成为了一种巨大的负担。更何况这种管理形式，问题实在是太多了。\n1，需要花费大量的时间和精力来维持现有组织，哪怕是非关键岗位的离职，都可能影响一些流程的开展。（纸质资料的交接，其实跟口口相传没什么区别）。\n2，过程资料存储困难，为了存储资料，更是需要专门安排档案室和档案保管员，一旦出现产品质量问题，需要进行问题追溯时，要从档案中检索问题要花许多时间。\n3，一旦发生灾害或事故，例如火灾洪灾，就意味着过程资料将成为废纸，产品的关键过程信息将无法寻觅。\n在互联网技术飞速发展、实体经济受到巨大冲击的今天，原有管理模式，过于臃肿，已经无法适应组织发展的需要。行业越来越不景气，企业的管理成本居高不下，负担越来越重，每年裁员裁了许多人，却没能从管理效能上带来多大的提高，因此提升企业的信息化管理水平其实势在必行。\n但是如果要实现一步到位，直接构建基于工业4.0的智能制造新体系，在这个行业都不太现实，毕竟许多产品都是属于定制生产、小批次制造，部署全套自动化制造生产线成本非常高，事实上新生产线也在建设，但是一直没有投产，老的生产线也得维持好，这样才能持续创造价值。做好眼前能做的，实现检验管理的信息化（无纸化），然后再逐步实现制造业的智能化，只有实现了这一小步，才有未来的无限可能。\n* 立项\n\n之前提到中国制造2025的大背景，还有一个小背景。企业内部企业的中高层普遍都是八十年代末毕业拥有更高学历的管理层，不乏清北的高才生。他们那些大学同学正是这一波大时代的受益者之一，有许多同学都借助于企业的腾飞实现了个人价值，但是留在这家国企的高管们，却看着企业越来越差，也想有所作为，却感觉一个拳头打在了棉花上，他们的压力很大。\n然而，大家都清楚，传统国企的体质僵化，很多时候看起来两个字所谓“变革”，实际上却有点像个美梦而已，就拿“信息化”系统建设来说吧，信息化对于国企来说并非第一次提起，许多国企的老员工，乃至管理层其实已经经历了过去十年信息化失败之苦，许多信息化系统在领导们的支持下，看似搞得轰轰烈烈，热热闹闹，但是最终都难逃被抛弃的下场，而每个信息化项目的失败，都会让好几位负责对应信息管理工作的牵头人背锅，并最终从公司离开。\n在IT从业人员看来或许很简单的信息化建设，从来没那么顺顺利利，极有可能会由于基层的抗拒最终失败，并给信息化建设的参与者带来职业生涯上的污点。\n于是在国企把信息化提上议程之后，获得了两种不同的声音。很戏剧性的，不懂信息化的业务部门是信息化的支持者，他们说这个事情一定要搞，砸锅卖铁都要上，再难也要上。另外一种负责信息化工作的信息中心的负责人对信息化的态度很明显，要我支持，没问题，我可以把网络做好，但是要我参与软件的研发过程，恕我无能为力。\n因此最终牵头组织这个过程资料信息化的，是平时对这一块需求最大的检验管理部门。在他们的推动下，项目正式提上了议程。\n这是个涉及面非常广泛的项目集，包括了三个项目，分别是面向民用领域单一事业部的A项目，面向融合领域的B项目，以及面向整个集团全方向的C项目。事实上集团曾经购买过现成的产品，但是都没能用起来，所以这个项目集最终是以定制开发的形式承包出来。\n* A项目\n\nA项目作为最先立项的项目，万事开头难，承受了巨大的压力，许多人在等着看一出好戏。\nA项目的负责人W部长今年三十八岁，在此之前他一直是从事检验管理出身，对产品检验有自己明确的要求，他奠定了整个项目的基调。没有设定特别宏大的目标，不是做一个通用的大系统，就做一个简单实用的系统，能够给基层带来方便，为管理层带来便利就够了。\n项目的早期，承建单位曾经试图引入新技术和更加友好的用户体验，但是w部长却不这么认为，他说在这样的老国企，没必要用新技术，一切以满足可用性为目标，操作越简单越好。于是最终承建方设计了一个基于cs的数据采集系统和基于bs的管理系统。不仅功能尽可能的简单，而且连流程都能省就省，尽量让参与者减少学习成本。\n这个设计简单实用的系统，恰好满足了敏捷项目所要达到的构建简单项目、实现快速迭代小步快走的管理目标。驻场开发期间，及时发现问题和解决问题，让软件得到了非常充分应用，获得了甲方的高度评价。\n而且如果说早期项目的应用的推进需要靠组织的强势推动，到了后期就令人欣慰了，由于这个系统无需特别复杂的操作流程就能完成资料的录入，提交和汇总，基层岗位的工作人员只要会用计算机、简单培训就能迅速上手，无形中为项目的快速铺开奠定了良好的基础。而且承建方与甲方的基层人员之间沟通融洽，有问题及时反馈，及时处理，为项目推进带来了非常不错的效果。\n在项目运转正常一年之后，主导项目工作的部长调任了，新接手的负责人是曾经不太看好这个系统的车间主任，他也被基层工作人员带动，成为了这个项目的拥趸。 \n* B项目\n\n借着A项目成功的东风，马上启动了B项目。\n前面提到了，B项目是面向融合产业的，因此对这个项目的要求也相对而言更高。\n当这个项目完成立项后，B项目建设方的组织架构也发生了比较大的变更，首先是之前推动A项目的集团公司大领导由于工龄届满，已经退休，而集团的整个管理层都相继发生了变化，包括推动项目立项的一位高级工程师也从公司离职，意味着项目早期干系人已经完全换了。\n组织架构调整其实是为了给年轻人机会。调整后，B项目负责整个项目的，都是87后的年轻人。\n这群年轻人们，相对于A项目的负责人来说，对信息化有了更加深入的认识。事实上而言，A项目建设，其实不过是一个类似于协同办公的一个模块，他们认为这个项目没什么技术含量，甚至有点low。他们经常出去考察学习，对用户体验和功能应用都有很多想法，他们渴望真正打造一个能够真正打造一个符合企业未来发展目标的信息化一体化平台。\n这些想法再跟现有政策、以及组织架构混合在一起发酵，最终变成了一个无比巨大的项目，用专业术语来说，就是一个“大泥球”系统。\n在项目立项之初，合同上原始需求其实只有19个条目，而且为了让这些内容容易落地，前期的推动者甚至尽可能的减少流程的复杂度，但是等合同签订后、组织结构调整完，新的干系人们在原合同的基础上，对范围进行了大幅修改。最终等需求调研落地，变成的是一个基本上涵盖了公司大部分审批事项、涉及几十个流程，涉及全公司数百人、超过十几个小系统的大项目。\n为了完成这个项目，双方投入了最少20个人，超过十人的研发团队驻场开发了超过半年时间，也没折腾出几个让甲方满意的东西。建设单位现场条件恶劣、涉及流程复杂、涉及特殊的管理机制，要开发的功能点特别多，不断的完善，不断的修改，整个项目研发前前后后折腾了至少一年时间之后，才通过直接负责人的认可，但是给领导汇报时，却根本不可用，得推翻重做。\n项目到今年项目依然没有上线，这离合同交付日期已经超过两年了，显然可以称之为“失败项目”了。 \n承建方虽然早期意识到了项目风险，但是建设方过于强势，无法拒绝；建设方贪多求快，忽略了组织本身的复杂性、低估了软件研发的工作量以及软件实施的难度，最终双方都竹篮打水一场空。\n* C项目\n\nC项目是在B项目完成了到一半时启动的新项目，其目标是将A项目成功的经验，推广到全集团。（不包括B项目的事业部）。\nC项目的实施异常顺利，合同期一年，实际上只花了8个月就把项目做完了。\n* 总结\n\n当我年轻时曾经向其他拥有丰富经验的项目经理请教什么样的项目才是成功项目时，他们说：\n>“刚刚好”：刚刚好满足客户的需求，就是一个不错的项目。\n\n一个充满智慧的回答。不过“刚刚好”其实很难把握这个度，我觉得一定是功能简单、实用即可。\n在这个故事中，那个最简单实用，几乎没有什么技术含量的项目在组织中获得了很大的成功，而一开始就打算做成全流程信息化的系统，最终却一败涂地。\n这恰好就像我们经常见到的项目，简单纯粹的产品才能最先站稳脚跟、获得不错的用户反响，那些一味画饼的PPT项目，都是忽悠人，几乎没几个成功了。\n除此之外，每一个软件行业从业者，越爱钻研技术，越容易陷入技术的迷思，总以为靠技术能改变世界，仿佛一个项目没用上什么新技术就容易就无法体现出自己的价值来。然而一个组织的技术体系，必须依托组织的实际组织架构而存在。再优秀超前的技术，脱离了土壤都是空中楼阁，永远没有最优秀的技术，能真正为组织带来价值的技术，才是最合适的技术。\n\n","source":"_posts/管理/怎样的项目才能称为“成功项目”？.md","raw":"\n---\ntitle:  怎样的项目，才能称为“成功项目”？\ndate: 2019-10-09 16:28\ntags: 管理\nauthor: 邹溪源\ncategories:\n  - 管理\n---\n\n\n\n* 引子\n\n这个故事讲的是一家拥有百年历史的制造业大厂的信息化转型过程中的波折。这家企业拥有超过三万名员工，它是某行业的领先品牌，但是在信息化程度上却非常古老。\n有许多人说，国企的项目都是坑，相当一部分项目都是为了骗经费而忽悠人的，换一拨管理层，基本上就得换一拨项目，油水全被领导捞走了。我很遗憾，没能经历这些事情。这个项目实打实都是做出来给基层用的项目，也确实获得了各方较高的满意度。\n以中台为政治正确的互联网开发者们会说，这个项目从商业层面和技术上来说似乎毫无价值，首先它不是互联网产品，其次它没什么技术含量，什么大数据，云计算，容器，微服务，无服务，它都不需要，这甚至有点像我们身边许多人十年前就做过的项目，技术上平淡无奇，看起来毫无挑战。\n显然并非如此，每个项目存在都有价值。作为过程中的亲历者，我希望通过总结这个项目过程中存在的不足，引起思考和引发讨论。尤其是随着时代的进步，像这样信息化转型的传统制造业企业，或许越来越罕见，这样的项目看起来非常独特，但也是软件项目中的一个典型，对于未来从事行业互联网开发的软件从业人员来说，也许能带来一些思考。\n* 背景\n\n2015年开始，制造业企业开始流行起一种新的趋势：工业4.0，在这个大背景下，国内则提出了中国制造2025的计划，旨在通过几年努力，实现中国制造业的智能化水平在上一个台阶。\n该大型国企作为该某领域的领先品牌，其生产的产品远销国内外，也是军民融合的典型代表，但是在过去的发展过程中，由于产品本身比较特殊，许多关键步骤仍然是采用手工完成，无法完全实现自动化替代，包括检验管理体系也同样建立在一大堆纸质表单的基础上完成。集团管理层看到了中国制造2025带来的巨大机遇，也想奋斗一波，但要做的事情实在是太多了。\n康威定律说，一个组织的软件架构设计，实际上是组织管理形式的体现。在9012年的今天，为了维持这样一套以纸质表单为核心的检验管理体系，需要维持庞大的管理体系，带来了巨大的管理成本，对于组织来说本身成为了一种巨大的负担。更何况这种管理形式，问题实在是太多了。\n1，需要花费大量的时间和精力来维持现有组织，哪怕是非关键岗位的离职，都可能影响一些流程的开展。（纸质资料的交接，其实跟口口相传没什么区别）。\n2，过程资料存储困难，为了存储资料，更是需要专门安排档案室和档案保管员，一旦出现产品质量问题，需要进行问题追溯时，要从档案中检索问题要花许多时间。\n3，一旦发生灾害或事故，例如火灾洪灾，就意味着过程资料将成为废纸，产品的关键过程信息将无法寻觅。\n在互联网技术飞速发展、实体经济受到巨大冲击的今天，原有管理模式，过于臃肿，已经无法适应组织发展的需要。行业越来越不景气，企业的管理成本居高不下，负担越来越重，每年裁员裁了许多人，却没能从管理效能上带来多大的提高，因此提升企业的信息化管理水平其实势在必行。\n但是如果要实现一步到位，直接构建基于工业4.0的智能制造新体系，在这个行业都不太现实，毕竟许多产品都是属于定制生产、小批次制造，部署全套自动化制造生产线成本非常高，事实上新生产线也在建设，但是一直没有投产，老的生产线也得维持好，这样才能持续创造价值。做好眼前能做的，实现检验管理的信息化（无纸化），然后再逐步实现制造业的智能化，只有实现了这一小步，才有未来的无限可能。\n* 立项\n\n之前提到中国制造2025的大背景，还有一个小背景。企业内部企业的中高层普遍都是八十年代末毕业拥有更高学历的管理层，不乏清北的高才生。他们那些大学同学正是这一波大时代的受益者之一，有许多同学都借助于企业的腾飞实现了个人价值，但是留在这家国企的高管们，却看着企业越来越差，也想有所作为，却感觉一个拳头打在了棉花上，他们的压力很大。\n然而，大家都清楚，传统国企的体质僵化，很多时候看起来两个字所谓“变革”，实际上却有点像个美梦而已，就拿“信息化”系统建设来说吧，信息化对于国企来说并非第一次提起，许多国企的老员工，乃至管理层其实已经经历了过去十年信息化失败之苦，许多信息化系统在领导们的支持下，看似搞得轰轰烈烈，热热闹闹，但是最终都难逃被抛弃的下场，而每个信息化项目的失败，都会让好几位负责对应信息管理工作的牵头人背锅，并最终从公司离开。\n在IT从业人员看来或许很简单的信息化建设，从来没那么顺顺利利，极有可能会由于基层的抗拒最终失败，并给信息化建设的参与者带来职业生涯上的污点。\n于是在国企把信息化提上议程之后，获得了两种不同的声音。很戏剧性的，不懂信息化的业务部门是信息化的支持者，他们说这个事情一定要搞，砸锅卖铁都要上，再难也要上。另外一种负责信息化工作的信息中心的负责人对信息化的态度很明显，要我支持，没问题，我可以把网络做好，但是要我参与软件的研发过程，恕我无能为力。\n因此最终牵头组织这个过程资料信息化的，是平时对这一块需求最大的检验管理部门。在他们的推动下，项目正式提上了议程。\n这是个涉及面非常广泛的项目集，包括了三个项目，分别是面向民用领域单一事业部的A项目，面向融合领域的B项目，以及面向整个集团全方向的C项目。事实上集团曾经购买过现成的产品，但是都没能用起来，所以这个项目集最终是以定制开发的形式承包出来。\n* A项目\n\nA项目作为最先立项的项目，万事开头难，承受了巨大的压力，许多人在等着看一出好戏。\nA项目的负责人W部长今年三十八岁，在此之前他一直是从事检验管理出身，对产品检验有自己明确的要求，他奠定了整个项目的基调。没有设定特别宏大的目标，不是做一个通用的大系统，就做一个简单实用的系统，能够给基层带来方便，为管理层带来便利就够了。\n项目的早期，承建单位曾经试图引入新技术和更加友好的用户体验，但是w部长却不这么认为，他说在这样的老国企，没必要用新技术，一切以满足可用性为目标，操作越简单越好。于是最终承建方设计了一个基于cs的数据采集系统和基于bs的管理系统。不仅功能尽可能的简单，而且连流程都能省就省，尽量让参与者减少学习成本。\n这个设计简单实用的系统，恰好满足了敏捷项目所要达到的构建简单项目、实现快速迭代小步快走的管理目标。驻场开发期间，及时发现问题和解决问题，让软件得到了非常充分应用，获得了甲方的高度评价。\n而且如果说早期项目的应用的推进需要靠组织的强势推动，到了后期就令人欣慰了，由于这个系统无需特别复杂的操作流程就能完成资料的录入，提交和汇总，基层岗位的工作人员只要会用计算机、简单培训就能迅速上手，无形中为项目的快速铺开奠定了良好的基础。而且承建方与甲方的基层人员之间沟通融洽，有问题及时反馈，及时处理，为项目推进带来了非常不错的效果。\n在项目运转正常一年之后，主导项目工作的部长调任了，新接手的负责人是曾经不太看好这个系统的车间主任，他也被基层工作人员带动，成为了这个项目的拥趸。 \n* B项目\n\n借着A项目成功的东风，马上启动了B项目。\n前面提到了，B项目是面向融合产业的，因此对这个项目的要求也相对而言更高。\n当这个项目完成立项后，B项目建设方的组织架构也发生了比较大的变更，首先是之前推动A项目的集团公司大领导由于工龄届满，已经退休，而集团的整个管理层都相继发生了变化，包括推动项目立项的一位高级工程师也从公司离职，意味着项目早期干系人已经完全换了。\n组织架构调整其实是为了给年轻人机会。调整后，B项目负责整个项目的，都是87后的年轻人。\n这群年轻人们，相对于A项目的负责人来说，对信息化有了更加深入的认识。事实上而言，A项目建设，其实不过是一个类似于协同办公的一个模块，他们认为这个项目没什么技术含量，甚至有点low。他们经常出去考察学习，对用户体验和功能应用都有很多想法，他们渴望真正打造一个能够真正打造一个符合企业未来发展目标的信息化一体化平台。\n这些想法再跟现有政策、以及组织架构混合在一起发酵，最终变成了一个无比巨大的项目，用专业术语来说，就是一个“大泥球”系统。\n在项目立项之初，合同上原始需求其实只有19个条目，而且为了让这些内容容易落地，前期的推动者甚至尽可能的减少流程的复杂度，但是等合同签订后、组织结构调整完，新的干系人们在原合同的基础上，对范围进行了大幅修改。最终等需求调研落地，变成的是一个基本上涵盖了公司大部分审批事项、涉及几十个流程，涉及全公司数百人、超过十几个小系统的大项目。\n为了完成这个项目，双方投入了最少20个人，超过十人的研发团队驻场开发了超过半年时间，也没折腾出几个让甲方满意的东西。建设单位现场条件恶劣、涉及流程复杂、涉及特殊的管理机制，要开发的功能点特别多，不断的完善，不断的修改，整个项目研发前前后后折腾了至少一年时间之后，才通过直接负责人的认可，但是给领导汇报时，却根本不可用，得推翻重做。\n项目到今年项目依然没有上线，这离合同交付日期已经超过两年了，显然可以称之为“失败项目”了。 \n承建方虽然早期意识到了项目风险，但是建设方过于强势，无法拒绝；建设方贪多求快，忽略了组织本身的复杂性、低估了软件研发的工作量以及软件实施的难度，最终双方都竹篮打水一场空。\n* C项目\n\nC项目是在B项目完成了到一半时启动的新项目，其目标是将A项目成功的经验，推广到全集团。（不包括B项目的事业部）。\nC项目的实施异常顺利，合同期一年，实际上只花了8个月就把项目做完了。\n* 总结\n\n当我年轻时曾经向其他拥有丰富经验的项目经理请教什么样的项目才是成功项目时，他们说：\n>“刚刚好”：刚刚好满足客户的需求，就是一个不错的项目。\n\n一个充满智慧的回答。不过“刚刚好”其实很难把握这个度，我觉得一定是功能简单、实用即可。\n在这个故事中，那个最简单实用，几乎没有什么技术含量的项目在组织中获得了很大的成功，而一开始就打算做成全流程信息化的系统，最终却一败涂地。\n这恰好就像我们经常见到的项目，简单纯粹的产品才能最先站稳脚跟、获得不错的用户反响，那些一味画饼的PPT项目，都是忽悠人，几乎没几个成功了。\n除此之外，每一个软件行业从业者，越爱钻研技术，越容易陷入技术的迷思，总以为靠技术能改变世界，仿佛一个项目没用上什么新技术就容易就无法体现出自己的价值来。然而一个组织的技术体系，必须依托组织的实际组织架构而存在。再优秀超前的技术，脱离了土壤都是空中楼阁，永远没有最优秀的技术，能真正为组织带来价值的技术，才是最合适的技术。\n\n","slug":"管理/怎样的项目才能称为“成功项目”？","published":1,"updated":"2019-10-09T10:57:20.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt8b0026n4vi7roghgxn","content":"<ul>\n<li>引子</li>\n</ul>\n<p>这个故事讲的是一家拥有百年历史的制造业大厂的信息化转型过程中的波折。这家企业拥有超过三万名员工，它是某行业的领先品牌，但是在信息化程度上却非常古老。<br>有许多人说，国企的项目都是坑，相当一部分项目都是为了骗经费而忽悠人的，换一拨管理层，基本上就得换一拨项目，油水全被领导捞走了。我很遗憾，没能经历这些事情。这个项目实打实都是做出来给基层用的项目，也确实获得了各方较高的满意度。<br>以中台为政治正确的互联网开发者们会说，这个项目从商业层面和技术上来说似乎毫无价值，首先它不是互联网产品，其次它没什么技术含量，什么大数据，云计算，容器，微服务，无服务，它都不需要，这甚至有点像我们身边许多人十年前就做过的项目，技术上平淡无奇，看起来毫无挑战。<br>显然并非如此，每个项目存在都有价值。作为过程中的亲历者，我希望通过总结这个项目过程中存在的不足，引起思考和引发讨论。尤其是随着时代的进步，像这样信息化转型的传统制造业企业，或许越来越罕见，这样的项目看起来非常独特，但也是软件项目中的一个典型，对于未来从事行业互联网开发的软件从业人员来说，也许能带来一些思考。</p>\n<ul>\n<li>背景</li>\n</ul>\n<p>2015年开始，制造业企业开始流行起一种新的趋势：工业4.0，在这个大背景下，国内则提出了中国制造2025的计划，旨在通过几年努力，实现中国制造业的智能化水平在上一个台阶。<br>该大型国企作为该某领域的领先品牌，其生产的产品远销国内外，也是军民融合的典型代表，但是在过去的发展过程中，由于产品本身比较特殊，许多关键步骤仍然是采用手工完成，无法完全实现自动化替代，包括检验管理体系也同样建立在一大堆纸质表单的基础上完成。集团管理层看到了中国制造2025带来的巨大机遇，也想奋斗一波，但要做的事情实在是太多了。<br>康威定律说，一个组织的软件架构设计，实际上是组织管理形式的体现。在9012年的今天，为了维持这样一套以纸质表单为核心的检验管理体系，需要维持庞大的管理体系，带来了巨大的管理成本，对于组织来说本身成为了一种巨大的负担。更何况这种管理形式，问题实在是太多了。<br>1，需要花费大量的时间和精力来维持现有组织，哪怕是非关键岗位的离职，都可能影响一些流程的开展。（纸质资料的交接，其实跟口口相传没什么区别）。<br>2，过程资料存储困难，为了存储资料，更是需要专门安排档案室和档案保管员，一旦出现产品质量问题，需要进行问题追溯时，要从档案中检索问题要花许多时间。<br>3，一旦发生灾害或事故，例如火灾洪灾，就意味着过程资料将成为废纸，产品的关键过程信息将无法寻觅。<br>在互联网技术飞速发展、实体经济受到巨大冲击的今天，原有管理模式，过于臃肿，已经无法适应组织发展的需要。行业越来越不景气，企业的管理成本居高不下，负担越来越重，每年裁员裁了许多人，却没能从管理效能上带来多大的提高，因此提升企业的信息化管理水平其实势在必行。<br>但是如果要实现一步到位，直接构建基于工业4.0的智能制造新体系，在这个行业都不太现实，毕竟许多产品都是属于定制生产、小批次制造，部署全套自动化制造生产线成本非常高，事实上新生产线也在建设，但是一直没有投产，老的生产线也得维持好，这样才能持续创造价值。做好眼前能做的，实现检验管理的信息化（无纸化），然后再逐步实现制造业的智能化，只有实现了这一小步，才有未来的无限可能。</p>\n<ul>\n<li>立项</li>\n</ul>\n<p>之前提到中国制造2025的大背景，还有一个小背景。企业内部企业的中高层普遍都是八十年代末毕业拥有更高学历的管理层，不乏清北的高才生。他们那些大学同学正是这一波大时代的受益者之一，有许多同学都借助于企业的腾飞实现了个人价值，但是留在这家国企的高管们，却看着企业越来越差，也想有所作为，却感觉一个拳头打在了棉花上，他们的压力很大。<br>然而，大家都清楚，传统国企的体质僵化，很多时候看起来两个字所谓“变革”，实际上却有点像个美梦而已，就拿“信息化”系统建设来说吧，信息化对于国企来说并非第一次提起，许多国企的老员工，乃至管理层其实已经经历了过去十年信息化失败之苦，许多信息化系统在领导们的支持下，看似搞得轰轰烈烈，热热闹闹，但是最终都难逃被抛弃的下场，而每个信息化项目的失败，都会让好几位负责对应信息管理工作的牵头人背锅，并最终从公司离开。<br>在IT从业人员看来或许很简单的信息化建设，从来没那么顺顺利利，极有可能会由于基层的抗拒最终失败，并给信息化建设的参与者带来职业生涯上的污点。<br>于是在国企把信息化提上议程之后，获得了两种不同的声音。很戏剧性的，不懂信息化的业务部门是信息化的支持者，他们说这个事情一定要搞，砸锅卖铁都要上，再难也要上。另外一种负责信息化工作的信息中心的负责人对信息化的态度很明显，要我支持，没问题，我可以把网络做好，但是要我参与软件的研发过程，恕我无能为力。<br>因此最终牵头组织这个过程资料信息化的，是平时对这一块需求最大的检验管理部门。在他们的推动下，项目正式提上了议程。<br>这是个涉及面非常广泛的项目集，包括了三个项目，分别是面向民用领域单一事业部的A项目，面向融合领域的B项目，以及面向整个集团全方向的C项目。事实上集团曾经购买过现成的产品，但是都没能用起来，所以这个项目集最终是以定制开发的形式承包出来。</p>\n<ul>\n<li>A项目</li>\n</ul>\n<p>A项目作为最先立项的项目，万事开头难，承受了巨大的压力，许多人在等着看一出好戏。<br>A项目的负责人W部长今年三十八岁，在此之前他一直是从事检验管理出身，对产品检验有自己明确的要求，他奠定了整个项目的基调。没有设定特别宏大的目标，不是做一个通用的大系统，就做一个简单实用的系统，能够给基层带来方便，为管理层带来便利就够了。<br>项目的早期，承建单位曾经试图引入新技术和更加友好的用户体验，但是w部长却不这么认为，他说在这样的老国企，没必要用新技术，一切以满足可用性为目标，操作越简单越好。于是最终承建方设计了一个基于cs的数据采集系统和基于bs的管理系统。不仅功能尽可能的简单，而且连流程都能省就省，尽量让参与者减少学习成本。<br>这个设计简单实用的系统，恰好满足了敏捷项目所要达到的构建简单项目、实现快速迭代小步快走的管理目标。驻场开发期间，及时发现问题和解决问题，让软件得到了非常充分应用，获得了甲方的高度评价。<br>而且如果说早期项目的应用的推进需要靠组织的强势推动，到了后期就令人欣慰了，由于这个系统无需特别复杂的操作流程就能完成资料的录入，提交和汇总，基层岗位的工作人员只要会用计算机、简单培训就能迅速上手，无形中为项目的快速铺开奠定了良好的基础。而且承建方与甲方的基层人员之间沟通融洽，有问题及时反馈，及时处理，为项目推进带来了非常不错的效果。<br>在项目运转正常一年之后，主导项目工作的部长调任了，新接手的负责人是曾经不太看好这个系统的车间主任，他也被基层工作人员带动，成为了这个项目的拥趸。 </p>\n<ul>\n<li>B项目</li>\n</ul>\n<p>借着A项目成功的东风，马上启动了B项目。<br>前面提到了，B项目是面向融合产业的，因此对这个项目的要求也相对而言更高。<br>当这个项目完成立项后，B项目建设方的组织架构也发生了比较大的变更，首先是之前推动A项目的集团公司大领导由于工龄届满，已经退休，而集团的整个管理层都相继发生了变化，包括推动项目立项的一位高级工程师也从公司离职，意味着项目早期干系人已经完全换了。<br>组织架构调整其实是为了给年轻人机会。调整后，B项目负责整个项目的，都是87后的年轻人。<br>这群年轻人们，相对于A项目的负责人来说，对信息化有了更加深入的认识。事实上而言，A项目建设，其实不过是一个类似于协同办公的一个模块，他们认为这个项目没什么技术含量，甚至有点low。他们经常出去考察学习，对用户体验和功能应用都有很多想法，他们渴望真正打造一个能够真正打造一个符合企业未来发展目标的信息化一体化平台。<br>这些想法再跟现有政策、以及组织架构混合在一起发酵，最终变成了一个无比巨大的项目，用专业术语来说，就是一个“大泥球”系统。<br>在项目立项之初，合同上原始需求其实只有19个条目，而且为了让这些内容容易落地，前期的推动者甚至尽可能的减少流程的复杂度，但是等合同签订后、组织结构调整完，新的干系人们在原合同的基础上，对范围进行了大幅修改。最终等需求调研落地，变成的是一个基本上涵盖了公司大部分审批事项、涉及几十个流程，涉及全公司数百人、超过十几个小系统的大项目。<br>为了完成这个项目，双方投入了最少20个人，超过十人的研发团队驻场开发了超过半年时间，也没折腾出几个让甲方满意的东西。建设单位现场条件恶劣、涉及流程复杂、涉及特殊的管理机制，要开发的功能点特别多，不断的完善，不断的修改，整个项目研发前前后后折腾了至少一年时间之后，才通过直接负责人的认可，但是给领导汇报时，却根本不可用，得推翻重做。<br>项目到今年项目依然没有上线，这离合同交付日期已经超过两年了，显然可以称之为“失败项目”了。<br>承建方虽然早期意识到了项目风险，但是建设方过于强势，无法拒绝；建设方贪多求快，忽略了组织本身的复杂性、低估了软件研发的工作量以及软件实施的难度，最终双方都竹篮打水一场空。</p>\n<ul>\n<li>C项目</li>\n</ul>\n<p>C项目是在B项目完成了到一半时启动的新项目，其目标是将A项目成功的经验，推广到全集团。（不包括B项目的事业部）。<br>C项目的实施异常顺利，合同期一年，实际上只花了8个月就把项目做完了。</p>\n<ul>\n<li>总结</li>\n</ul>\n<p>当我年轻时曾经向其他拥有丰富经验的项目经理请教什么样的项目才是成功项目时，他们说：</p>\n<blockquote>\n<p>“刚刚好”：刚刚好满足客户的需求，就是一个不错的项目。</p>\n</blockquote>\n<p>一个充满智慧的回答。不过“刚刚好”其实很难把握这个度，我觉得一定是功能简单、实用即可。<br>在这个故事中，那个最简单实用，几乎没有什么技术含量的项目在组织中获得了很大的成功，而一开始就打算做成全流程信息化的系统，最终却一败涂地。<br>这恰好就像我们经常见到的项目，简单纯粹的产品才能最先站稳脚跟、获得不错的用户反响，那些一味画饼的PPT项目，都是忽悠人，几乎没几个成功了。<br>除此之外，每一个软件行业从业者，越爱钻研技术，越容易陷入技术的迷思，总以为靠技术能改变世界，仿佛一个项目没用上什么新技术就容易就无法体现出自己的价值来。然而一个组织的技术体系，必须依托组织的实际组织架构而存在。再优秀超前的技术，脱离了土壤都是空中楼阁，永远没有最优秀的技术，能真正为组织带来价值的技术，才是最合适的技术。</p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>引子</li>\n</ul>\n<p>这个故事讲的是一家拥有百年历史的制造业大厂的信息化转型过程中的波折。这家企业拥有超过三万名员工，它是某行业的领先品牌，但是在信息化程度上却非常古老。<br>有许多人说，国企的项目都是坑，相当一部分项目都是为了骗经费而忽悠人的，换一拨管理层，基本上就得换一拨项目，油水全被领导捞走了。我很遗憾，没能经历这些事情。这个项目实打实都是做出来给基层用的项目，也确实获得了各方较高的满意度。<br>以中台为政治正确的互联网开发者们会说，这个项目从商业层面和技术上来说似乎毫无价值，首先它不是互联网产品，其次它没什么技术含量，什么大数据，云计算，容器，微服务，无服务，它都不需要，这甚至有点像我们身边许多人十年前就做过的项目，技术上平淡无奇，看起来毫无挑战。<br>显然并非如此，每个项目存在都有价值。作为过程中的亲历者，我希望通过总结这个项目过程中存在的不足，引起思考和引发讨论。尤其是随着时代的进步，像这样信息化转型的传统制造业企业，或许越来越罕见，这样的项目看起来非常独特，但也是软件项目中的一个典型，对于未来从事行业互联网开发的软件从业人员来说，也许能带来一些思考。</p>\n<ul>\n<li>背景</li>\n</ul>\n<p>2015年开始，制造业企业开始流行起一种新的趋势：工业4.0，在这个大背景下，国内则提出了中国制造2025的计划，旨在通过几年努力，实现中国制造业的智能化水平在上一个台阶。<br>该大型国企作为该某领域的领先品牌，其生产的产品远销国内外，也是军民融合的典型代表，但是在过去的发展过程中，由于产品本身比较特殊，许多关键步骤仍然是采用手工完成，无法完全实现自动化替代，包括检验管理体系也同样建立在一大堆纸质表单的基础上完成。集团管理层看到了中国制造2025带来的巨大机遇，也想奋斗一波，但要做的事情实在是太多了。<br>康威定律说，一个组织的软件架构设计，实际上是组织管理形式的体现。在9012年的今天，为了维持这样一套以纸质表单为核心的检验管理体系，需要维持庞大的管理体系，带来了巨大的管理成本，对于组织来说本身成为了一种巨大的负担。更何况这种管理形式，问题实在是太多了。<br>1，需要花费大量的时间和精力来维持现有组织，哪怕是非关键岗位的离职，都可能影响一些流程的开展。（纸质资料的交接，其实跟口口相传没什么区别）。<br>2，过程资料存储困难，为了存储资料，更是需要专门安排档案室和档案保管员，一旦出现产品质量问题，需要进行问题追溯时，要从档案中检索问题要花许多时间。<br>3，一旦发生灾害或事故，例如火灾洪灾，就意味着过程资料将成为废纸，产品的关键过程信息将无法寻觅。<br>在互联网技术飞速发展、实体经济受到巨大冲击的今天，原有管理模式，过于臃肿，已经无法适应组织发展的需要。行业越来越不景气，企业的管理成本居高不下，负担越来越重，每年裁员裁了许多人，却没能从管理效能上带来多大的提高，因此提升企业的信息化管理水平其实势在必行。<br>但是如果要实现一步到位，直接构建基于工业4.0的智能制造新体系，在这个行业都不太现实，毕竟许多产品都是属于定制生产、小批次制造，部署全套自动化制造生产线成本非常高，事实上新生产线也在建设，但是一直没有投产，老的生产线也得维持好，这样才能持续创造价值。做好眼前能做的，实现检验管理的信息化（无纸化），然后再逐步实现制造业的智能化，只有实现了这一小步，才有未来的无限可能。</p>\n<ul>\n<li>立项</li>\n</ul>\n<p>之前提到中国制造2025的大背景，还有一个小背景。企业内部企业的中高层普遍都是八十年代末毕业拥有更高学历的管理层，不乏清北的高才生。他们那些大学同学正是这一波大时代的受益者之一，有许多同学都借助于企业的腾飞实现了个人价值，但是留在这家国企的高管们，却看着企业越来越差，也想有所作为，却感觉一个拳头打在了棉花上，他们的压力很大。<br>然而，大家都清楚，传统国企的体质僵化，很多时候看起来两个字所谓“变革”，实际上却有点像个美梦而已，就拿“信息化”系统建设来说吧，信息化对于国企来说并非第一次提起，许多国企的老员工，乃至管理层其实已经经历了过去十年信息化失败之苦，许多信息化系统在领导们的支持下，看似搞得轰轰烈烈，热热闹闹，但是最终都难逃被抛弃的下场，而每个信息化项目的失败，都会让好几位负责对应信息管理工作的牵头人背锅，并最终从公司离开。<br>在IT从业人员看来或许很简单的信息化建设，从来没那么顺顺利利，极有可能会由于基层的抗拒最终失败，并给信息化建设的参与者带来职业生涯上的污点。<br>于是在国企把信息化提上议程之后，获得了两种不同的声音。很戏剧性的，不懂信息化的业务部门是信息化的支持者，他们说这个事情一定要搞，砸锅卖铁都要上，再难也要上。另外一种负责信息化工作的信息中心的负责人对信息化的态度很明显，要我支持，没问题，我可以把网络做好，但是要我参与软件的研发过程，恕我无能为力。<br>因此最终牵头组织这个过程资料信息化的，是平时对这一块需求最大的检验管理部门。在他们的推动下，项目正式提上了议程。<br>这是个涉及面非常广泛的项目集，包括了三个项目，分别是面向民用领域单一事业部的A项目，面向融合领域的B项目，以及面向整个集团全方向的C项目。事实上集团曾经购买过现成的产品，但是都没能用起来，所以这个项目集最终是以定制开发的形式承包出来。</p>\n<ul>\n<li>A项目</li>\n</ul>\n<p>A项目作为最先立项的项目，万事开头难，承受了巨大的压力，许多人在等着看一出好戏。<br>A项目的负责人W部长今年三十八岁，在此之前他一直是从事检验管理出身，对产品检验有自己明确的要求，他奠定了整个项目的基调。没有设定特别宏大的目标，不是做一个通用的大系统，就做一个简单实用的系统，能够给基层带来方便，为管理层带来便利就够了。<br>项目的早期，承建单位曾经试图引入新技术和更加友好的用户体验，但是w部长却不这么认为，他说在这样的老国企，没必要用新技术，一切以满足可用性为目标，操作越简单越好。于是最终承建方设计了一个基于cs的数据采集系统和基于bs的管理系统。不仅功能尽可能的简单，而且连流程都能省就省，尽量让参与者减少学习成本。<br>这个设计简单实用的系统，恰好满足了敏捷项目所要达到的构建简单项目、实现快速迭代小步快走的管理目标。驻场开发期间，及时发现问题和解决问题，让软件得到了非常充分应用，获得了甲方的高度评价。<br>而且如果说早期项目的应用的推进需要靠组织的强势推动，到了后期就令人欣慰了，由于这个系统无需特别复杂的操作流程就能完成资料的录入，提交和汇总，基层岗位的工作人员只要会用计算机、简单培训就能迅速上手，无形中为项目的快速铺开奠定了良好的基础。而且承建方与甲方的基层人员之间沟通融洽，有问题及时反馈，及时处理，为项目推进带来了非常不错的效果。<br>在项目运转正常一年之后，主导项目工作的部长调任了，新接手的负责人是曾经不太看好这个系统的车间主任，他也被基层工作人员带动，成为了这个项目的拥趸。 </p>\n<ul>\n<li>B项目</li>\n</ul>\n<p>借着A项目成功的东风，马上启动了B项目。<br>前面提到了，B项目是面向融合产业的，因此对这个项目的要求也相对而言更高。<br>当这个项目完成立项后，B项目建设方的组织架构也发生了比较大的变更，首先是之前推动A项目的集团公司大领导由于工龄届满，已经退休，而集团的整个管理层都相继发生了变化，包括推动项目立项的一位高级工程师也从公司离职，意味着项目早期干系人已经完全换了。<br>组织架构调整其实是为了给年轻人机会。调整后，B项目负责整个项目的，都是87后的年轻人。<br>这群年轻人们，相对于A项目的负责人来说，对信息化有了更加深入的认识。事实上而言，A项目建设，其实不过是一个类似于协同办公的一个模块，他们认为这个项目没什么技术含量，甚至有点low。他们经常出去考察学习，对用户体验和功能应用都有很多想法，他们渴望真正打造一个能够真正打造一个符合企业未来发展目标的信息化一体化平台。<br>这些想法再跟现有政策、以及组织架构混合在一起发酵，最终变成了一个无比巨大的项目，用专业术语来说，就是一个“大泥球”系统。<br>在项目立项之初，合同上原始需求其实只有19个条目，而且为了让这些内容容易落地，前期的推动者甚至尽可能的减少流程的复杂度，但是等合同签订后、组织结构调整完，新的干系人们在原合同的基础上，对范围进行了大幅修改。最终等需求调研落地，变成的是一个基本上涵盖了公司大部分审批事项、涉及几十个流程，涉及全公司数百人、超过十几个小系统的大项目。<br>为了完成这个项目，双方投入了最少20个人，超过十人的研发团队驻场开发了超过半年时间，也没折腾出几个让甲方满意的东西。建设单位现场条件恶劣、涉及流程复杂、涉及特殊的管理机制，要开发的功能点特别多，不断的完善，不断的修改，整个项目研发前前后后折腾了至少一年时间之后，才通过直接负责人的认可，但是给领导汇报时，却根本不可用，得推翻重做。<br>项目到今年项目依然没有上线，这离合同交付日期已经超过两年了，显然可以称之为“失败项目”了。<br>承建方虽然早期意识到了项目风险，但是建设方过于强势，无法拒绝；建设方贪多求快，忽略了组织本身的复杂性、低估了软件研发的工作量以及软件实施的难度，最终双方都竹篮打水一场空。</p>\n<ul>\n<li>C项目</li>\n</ul>\n<p>C项目是在B项目完成了到一半时启动的新项目，其目标是将A项目成功的经验，推广到全集团。（不包括B项目的事业部）。<br>C项目的实施异常顺利，合同期一年，实际上只花了8个月就把项目做完了。</p>\n<ul>\n<li>总结</li>\n</ul>\n<p>当我年轻时曾经向其他拥有丰富经验的项目经理请教什么样的项目才是成功项目时，他们说：</p>\n<blockquote>\n<p>“刚刚好”：刚刚好满足客户的需求，就是一个不错的项目。</p>\n</blockquote>\n<p>一个充满智慧的回答。不过“刚刚好”其实很难把握这个度，我觉得一定是功能简单、实用即可。<br>在这个故事中，那个最简单实用，几乎没有什么技术含量的项目在组织中获得了很大的成功，而一开始就打算做成全流程信息化的系统，最终却一败涂地。<br>这恰好就像我们经常见到的项目，简单纯粹的产品才能最先站稳脚跟、获得不错的用户反响，那些一味画饼的PPT项目，都是忽悠人，几乎没几个成功了。<br>除此之外，每一个软件行业从业者，越爱钻研技术，越容易陷入技术的迷思，总以为靠技术能改变世界，仿佛一个项目没用上什么新技术就容易就无法体现出自己的价值来。然而一个组织的技术体系，必须依托组织的实际组织架构而存在。再优秀超前的技术，脱离了土壤都是空中楼阁，永远没有最优秀的技术，能真正为组织带来价值的技术，才是最合适的技术。</p>\n"},{"title":"我是如何完成一个短期项目的？","date":"2020-05-26T14:28:00.000Z","author":"邹溪源","_content":"1. 项目启动\n\n4月中旬，接到指示，需要于5月10日完成一个紧急任务，这个项目是为一位核心客户打造一套具备公众号，后台和大屏显示系统相关的完整系统，而此时，我们的团队构建还并没有完成，意味着我们需要实现的将是一个超出现有团队实际能力的项目。\n\n当然，团队能力本身衡量就是一件并不容易的事情。如同从海绵中挤水分，也许从表面上看没什么内容，但挤一挤总能挤出许多精华来，尤其是在职场中成长，总必须经历一番考验，把自己的潜力逼出来，才能真正成长。\n\n当然，我依然根据实际情况进行了一番风险评估，主要包括一下几个方面：\n\n1，团队资源匮乏，尤其是缺乏有经验的开发者\n\n2，大华摄像头以前没对接过，存在技术的不确定性。\n\n3，团队没搞过公众号开发。\n\n4，时间太紧，质量可能是个问题，有可能影响公司商誉。等会，\n\n显然，风险评估是项目启动前必须做好的关键。尤其是这个项目，承载着相关方的许多目标，包括是我们团队的第一个正式项目，无论是老板也好，公司同事也好，甚至加入团队的成员们也好，其实都想知道我们这个团队到底行不行，能不能承受足够的压力。\n\n显然，团队成员们都需要通过这个项目证明自己的能力，进而证明团队的能力。\n\n# 二 技术选型\n在完成项目启动会后，我们跟客户进行了一番沟通，明确了项目团队中大家关心的问题，并开始着手技术选型，框架，业务分析，代码实现。\n\n在进行技术选型中，我基于公司长期积累的角度，选择了.netcore+vue.js的组合型技术栈，框架使用了abp作为我们的开发框架。\n\n虽然在实际过程中，有人提出了abp开发框架提供了一系列重量级的组件，对我们这样的团队来说可能会扩大技术风险，平白增加项目的时间。但实际过程中，该选型并没有造成想象中那么严重的问题。主要原因大概有以下几点：\n\n1，abp无论如何依然是.net技术栈中最受欢迎，公认设计最优雅的面向领域驱动设计的框架。哪怕我们不用领域驱动的思想，也不影响我们使用abp的轮子。它的轮子确实太灵活方便了，运用妥当定然能给我们带来不少好处。\n\n2，即使我已经从事了十年开发，却依然觉得要设计一套权限认证系统远比想象中的复杂。\n\n事实上这是一个普遍认可的观点，看起来权限认证几个表就能搞定这个问题，其实并非如此。例如abp的权限认证包括了如下复杂的逻辑结构。\n\n![图片](https://images.smcdn.cn/AJeFAPstbzMWiy3R/IMG_1783.JPG!thumbnail)\n在介绍领域驱动设计的一本书《Microsoft.Net企业级应用架构设计》这本书中，作者也表达了同样的观点：\n\n即使已经写了多本asp.net的书，创建基于角色的UI基础设施以及相关的成员系统耗费比预期更多的功夫。\n\n事实上，对于我们这样的项目，关键不是选什么框架，而是选一种能够满足当前需求，又能在未来给公司带来积累的框架和技术体系，而abp和abpvnext恰好如此。小项目可以用abp，大项目则可以考虑后者。或者都可以采用后者。\n\n# 三，项目过程控制\n当这个项目拿到时，我们面临短期看似无法完成的较多量需求，难免会存在选择困难证。究竟是做A，还是选B，还是做一个成年人应该选的，两者都选？\n\n显然，我们的精力有限，只能有所取舍。\n\n在现代软件工程中，瀑布模型，快速原型开发模型，增量/迭代型模型都是我们在项目选型过程最基础的选择。如果采用瀑布模型，显然不符合我们的实际情况，因为没有足够的资源，不太可能花时间写文档；快速原型也同样如此，花时间做一个完整的demo，那也不太可行，尤其是甲方已经确定了原型之后，已经具备开发实例功能的前提。\n\n在这个模块优先级选择之中，我个人认为，虽然B端系统这个部分需求很多，优先把它搞定，能够让我们集中精力解决其他问题，但对用户来说，是否真的如此？\n\n业务价值的评估是我们进行功能优先级评定的第一要素。如同一个价值滑条，同时摆在一个刻度上，永远只有一个功能。\n\n于是，我们将公众号，大屏作为第一迭代。并安排足够的资源优先完成此模块。当然，资源其实依然并不足够，但大家都知道，资源不足才是项目最普遍的现象，在现有资源范围充分利用，才是成立项目组的目的。\n\n我们引入了持续集成的概念，要求把更早的交付当作核心目的。为了实现这个目标，我们采取了如下措施：\n\n1. 收集需求，以低保真原型图指导软件开发，除个别页面要求美观外，其他页面以满足可用性为准\n\n2. 前后端设计模拟数据，前端就可以开始联调了。\n\n3. 划分迭代周期，确定发布节奏。\n\n4. UI先行开发，同步后端开始设计接口和模拟数据的格式，用后端不用直接与前端联调，而是使用测试驱动先行的方式开发后台逻辑。 \n\n# 四，总结\n当然在实际操作过程中，我们并没有采用测试驱动开发的红绿重构开发实践，这使得我们没有足够的保障措施来确保代码质量，而且由于项目团队普遍经验不足，也意味着我们在未来的演进过程中，将面临许多严重问题。\n\n在这个项目中，我们采用了合理的迭代划分；让售前，设计驻场确保需求的澄清；采用了开发分支和功能分支分离的模式是我个人认为值得复用的经验。\n\n由于时间缘故，在下一篇文章中，再讨论一下这个问题。\n\n# \n\n","source":"_posts/管理/我是如何完成一个短期项目的？.md","raw":"---\ntitle: 我是如何完成一个短期项目的？\ndate: 2020-5-26 22:28\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n1. 项目启动\n\n4月中旬，接到指示，需要于5月10日完成一个紧急任务，这个项目是为一位核心客户打造一套具备公众号，后台和大屏显示系统相关的完整系统，而此时，我们的团队构建还并没有完成，意味着我们需要实现的将是一个超出现有团队实际能力的项目。\n\n当然，团队能力本身衡量就是一件并不容易的事情。如同从海绵中挤水分，也许从表面上看没什么内容，但挤一挤总能挤出许多精华来，尤其是在职场中成长，总必须经历一番考验，把自己的潜力逼出来，才能真正成长。\n\n当然，我依然根据实际情况进行了一番风险评估，主要包括一下几个方面：\n\n1，团队资源匮乏，尤其是缺乏有经验的开发者\n\n2，大华摄像头以前没对接过，存在技术的不确定性。\n\n3，团队没搞过公众号开发。\n\n4，时间太紧，质量可能是个问题，有可能影响公司商誉。等会，\n\n显然，风险评估是项目启动前必须做好的关键。尤其是这个项目，承载着相关方的许多目标，包括是我们团队的第一个正式项目，无论是老板也好，公司同事也好，甚至加入团队的成员们也好，其实都想知道我们这个团队到底行不行，能不能承受足够的压力。\n\n显然，团队成员们都需要通过这个项目证明自己的能力，进而证明团队的能力。\n\n# 二 技术选型\n在完成项目启动会后，我们跟客户进行了一番沟通，明确了项目团队中大家关心的问题，并开始着手技术选型，框架，业务分析，代码实现。\n\n在进行技术选型中，我基于公司长期积累的角度，选择了.netcore+vue.js的组合型技术栈，框架使用了abp作为我们的开发框架。\n\n虽然在实际过程中，有人提出了abp开发框架提供了一系列重量级的组件，对我们这样的团队来说可能会扩大技术风险，平白增加项目的时间。但实际过程中，该选型并没有造成想象中那么严重的问题。主要原因大概有以下几点：\n\n1，abp无论如何依然是.net技术栈中最受欢迎，公认设计最优雅的面向领域驱动设计的框架。哪怕我们不用领域驱动的思想，也不影响我们使用abp的轮子。它的轮子确实太灵活方便了，运用妥当定然能给我们带来不少好处。\n\n2，即使我已经从事了十年开发，却依然觉得要设计一套权限认证系统远比想象中的复杂。\n\n事实上这是一个普遍认可的观点，看起来权限认证几个表就能搞定这个问题，其实并非如此。例如abp的权限认证包括了如下复杂的逻辑结构。\n\n![图片](https://images.smcdn.cn/AJeFAPstbzMWiy3R/IMG_1783.JPG!thumbnail)\n在介绍领域驱动设计的一本书《Microsoft.Net企业级应用架构设计》这本书中，作者也表达了同样的观点：\n\n即使已经写了多本asp.net的书，创建基于角色的UI基础设施以及相关的成员系统耗费比预期更多的功夫。\n\n事实上，对于我们这样的项目，关键不是选什么框架，而是选一种能够满足当前需求，又能在未来给公司带来积累的框架和技术体系，而abp和abpvnext恰好如此。小项目可以用abp，大项目则可以考虑后者。或者都可以采用后者。\n\n# 三，项目过程控制\n当这个项目拿到时，我们面临短期看似无法完成的较多量需求，难免会存在选择困难证。究竟是做A，还是选B，还是做一个成年人应该选的，两者都选？\n\n显然，我们的精力有限，只能有所取舍。\n\n在现代软件工程中，瀑布模型，快速原型开发模型，增量/迭代型模型都是我们在项目选型过程最基础的选择。如果采用瀑布模型，显然不符合我们的实际情况，因为没有足够的资源，不太可能花时间写文档；快速原型也同样如此，花时间做一个完整的demo，那也不太可行，尤其是甲方已经确定了原型之后，已经具备开发实例功能的前提。\n\n在这个模块优先级选择之中，我个人认为，虽然B端系统这个部分需求很多，优先把它搞定，能够让我们集中精力解决其他问题，但对用户来说，是否真的如此？\n\n业务价值的评估是我们进行功能优先级评定的第一要素。如同一个价值滑条，同时摆在一个刻度上，永远只有一个功能。\n\n于是，我们将公众号，大屏作为第一迭代。并安排足够的资源优先完成此模块。当然，资源其实依然并不足够，但大家都知道，资源不足才是项目最普遍的现象，在现有资源范围充分利用，才是成立项目组的目的。\n\n我们引入了持续集成的概念，要求把更早的交付当作核心目的。为了实现这个目标，我们采取了如下措施：\n\n1. 收集需求，以低保真原型图指导软件开发，除个别页面要求美观外，其他页面以满足可用性为准\n\n2. 前后端设计模拟数据，前端就可以开始联调了。\n\n3. 划分迭代周期，确定发布节奏。\n\n4. UI先行开发，同步后端开始设计接口和模拟数据的格式，用后端不用直接与前端联调，而是使用测试驱动先行的方式开发后台逻辑。 \n\n# 四，总结\n当然在实际操作过程中，我们并没有采用测试驱动开发的红绿重构开发实践，这使得我们没有足够的保障措施来确保代码质量，而且由于项目团队普遍经验不足，也意味着我们在未来的演进过程中，将面临许多严重问题。\n\n在这个项目中，我们采用了合理的迭代划分；让售前，设计驻场确保需求的澄清；采用了开发分支和功能分支分离的模式是我个人认为值得复用的经验。\n\n由于时间缘故，在下一篇文章中，再讨论一下这个问题。\n\n# \n\n","slug":"管理/我是如何完成一个短期项目的？","published":1,"updated":"2020-05-26T11:35:39.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt8c002an4vi770hnra7","content":"<ol>\n<li>项目启动</li>\n</ol>\n<p>4月中旬，接到指示，需要于5月10日完成一个紧急任务，这个项目是为一位核心客户打造一套具备公众号，后台和大屏显示系统相关的完整系统，而此时，我们的团队构建还并没有完成，意味着我们需要实现的将是一个超出现有团队实际能力的项目。</p>\n<p>当然，团队能力本身衡量就是一件并不容易的事情。如同从海绵中挤水分，也许从表面上看没什么内容，但挤一挤总能挤出许多精华来，尤其是在职场中成长，总必须经历一番考验，把自己的潜力逼出来，才能真正成长。</p>\n<p>当然，我依然根据实际情况进行了一番风险评估，主要包括一下几个方面：</p>\n<p>1，团队资源匮乏，尤其是缺乏有经验的开发者</p>\n<p>2，大华摄像头以前没对接过，存在技术的不确定性。</p>\n<p>3，团队没搞过公众号开发。</p>\n<p>4，时间太紧，质量可能是个问题，有可能影响公司商誉。等会，</p>\n<p>显然，风险评估是项目启动前必须做好的关键。尤其是这个项目，承载着相关方的许多目标，包括是我们团队的第一个正式项目，无论是老板也好，公司同事也好，甚至加入团队的成员们也好，其实都想知道我们这个团队到底行不行，能不能承受足够的压力。</p>\n<p>显然，团队成员们都需要通过这个项目证明自己的能力，进而证明团队的能力。</p>\n<h1 id=\"二-技术选型\"><a href=\"#二-技术选型\" class=\"headerlink\" title=\"二 技术选型\"></a>二 技术选型</h1><p>在完成项目启动会后，我们跟客户进行了一番沟通，明确了项目团队中大家关心的问题，并开始着手技术选型，框架，业务分析，代码实现。</p>\n<p>在进行技术选型中，我基于公司长期积累的角度，选择了.netcore+vue.js的组合型技术栈，框架使用了abp作为我们的开发框架。</p>\n<p>虽然在实际过程中，有人提出了abp开发框架提供了一系列重量级的组件，对我们这样的团队来说可能会扩大技术风险，平白增加项目的时间。但实际过程中，该选型并没有造成想象中那么严重的问题。主要原因大概有以下几点：</p>\n<p>1，abp无论如何依然是.net技术栈中最受欢迎，公认设计最优雅的面向领域驱动设计的框架。哪怕我们不用领域驱动的思想，也不影响我们使用abp的轮子。它的轮子确实太灵活方便了，运用妥当定然能给我们带来不少好处。</p>\n<p>2，即使我已经从事了十年开发，却依然觉得要设计一套权限认证系统远比想象中的复杂。</p>\n<p>事实上这是一个普遍认可的观点，看起来权限认证几个表就能搞定这个问题，其实并非如此。例如abp的权限认证包括了如下复杂的逻辑结构。</p>\n<p><img src=\"https://images.smcdn.cn/AJeFAPstbzMWiy3R/IMG_1783.JPG!thumbnail\" alt=\"图片\"><br>在介绍领域驱动设计的一本书《Microsoft.Net企业级应用架构设计》这本书中，作者也表达了同样的观点：</p>\n<p>即使已经写了多本asp.net的书，创建基于角色的UI基础设施以及相关的成员系统耗费比预期更多的功夫。</p>\n<p>事实上，对于我们这样的项目，关键不是选什么框架，而是选一种能够满足当前需求，又能在未来给公司带来积累的框架和技术体系，而abp和abpvnext恰好如此。小项目可以用abp，大项目则可以考虑后者。或者都可以采用后者。</p>\n<h1 id=\"三，项目过程控制\"><a href=\"#三，项目过程控制\" class=\"headerlink\" title=\"三，项目过程控制\"></a>三，项目过程控制</h1><p>当这个项目拿到时，我们面临短期看似无法完成的较多量需求，难免会存在选择困难证。究竟是做A，还是选B，还是做一个成年人应该选的，两者都选？</p>\n<p>显然，我们的精力有限，只能有所取舍。</p>\n<p>在现代软件工程中，瀑布模型，快速原型开发模型，增量/迭代型模型都是我们在项目选型过程最基础的选择。如果采用瀑布模型，显然不符合我们的实际情况，因为没有足够的资源，不太可能花时间写文档；快速原型也同样如此，花时间做一个完整的demo，那也不太可行，尤其是甲方已经确定了原型之后，已经具备开发实例功能的前提。</p>\n<p>在这个模块优先级选择之中，我个人认为，虽然B端系统这个部分需求很多，优先把它搞定，能够让我们集中精力解决其他问题，但对用户来说，是否真的如此？</p>\n<p>业务价值的评估是我们进行功能优先级评定的第一要素。如同一个价值滑条，同时摆在一个刻度上，永远只有一个功能。</p>\n<p>于是，我们将公众号，大屏作为第一迭代。并安排足够的资源优先完成此模块。当然，资源其实依然并不足够，但大家都知道，资源不足才是项目最普遍的现象，在现有资源范围充分利用，才是成立项目组的目的。</p>\n<p>我们引入了持续集成的概念，要求把更早的交付当作核心目的。为了实现这个目标，我们采取了如下措施：</p>\n<ol>\n<li><p>收集需求，以低保真原型图指导软件开发，除个别页面要求美观外，其他页面以满足可用性为准</p>\n</li>\n<li><p>前后端设计模拟数据，前端就可以开始联调了。</p>\n</li>\n<li><p>划分迭代周期，确定发布节奏。</p>\n</li>\n<li><p>UI先行开发，同步后端开始设计接口和模拟数据的格式，用后端不用直接与前端联调，而是使用测试驱动先行的方式开发后台逻辑。 </p>\n</li>\n</ol>\n<h1 id=\"四，总结\"><a href=\"#四，总结\" class=\"headerlink\" title=\"四，总结\"></a>四，总结</h1><p>当然在实际操作过程中，我们并没有采用测试驱动开发的红绿重构开发实践，这使得我们没有足够的保障措施来确保代码质量，而且由于项目团队普遍经验不足，也意味着我们在未来的演进过程中，将面临许多严重问题。</p>\n<p>在这个项目中，我们采用了合理的迭代划分；让售前，设计驻场确保需求的澄清；采用了开发分支和功能分支分离的模式是我个人认为值得复用的经验。</p>\n<p>由于时间缘故，在下一篇文章中，再讨论一下这个问题。</p>\n<h1 id><a href=\"#\" class=\"headerlink\" title></a></h1>","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>项目启动</li>\n</ol>\n<p>4月中旬，接到指示，需要于5月10日完成一个紧急任务，这个项目是为一位核心客户打造一套具备公众号，后台和大屏显示系统相关的完整系统，而此时，我们的团队构建还并没有完成，意味着我们需要实现的将是一个超出现有团队实际能力的项目。</p>\n<p>当然，团队能力本身衡量就是一件并不容易的事情。如同从海绵中挤水分，也许从表面上看没什么内容，但挤一挤总能挤出许多精华来，尤其是在职场中成长，总必须经历一番考验，把自己的潜力逼出来，才能真正成长。</p>\n<p>当然，我依然根据实际情况进行了一番风险评估，主要包括一下几个方面：</p>\n<p>1，团队资源匮乏，尤其是缺乏有经验的开发者</p>\n<p>2，大华摄像头以前没对接过，存在技术的不确定性。</p>\n<p>3，团队没搞过公众号开发。</p>\n<p>4，时间太紧，质量可能是个问题，有可能影响公司商誉。等会，</p>\n<p>显然，风险评估是项目启动前必须做好的关键。尤其是这个项目，承载着相关方的许多目标，包括是我们团队的第一个正式项目，无论是老板也好，公司同事也好，甚至加入团队的成员们也好，其实都想知道我们这个团队到底行不行，能不能承受足够的压力。</p>\n<p>显然，团队成员们都需要通过这个项目证明自己的能力，进而证明团队的能力。</p>\n<h1 id=\"二-技术选型\"><a href=\"#二-技术选型\" class=\"headerlink\" title=\"二 技术选型\"></a>二 技术选型</h1><p>在完成项目启动会后，我们跟客户进行了一番沟通，明确了项目团队中大家关心的问题，并开始着手技术选型，框架，业务分析，代码实现。</p>\n<p>在进行技术选型中，我基于公司长期积累的角度，选择了.netcore+vue.js的组合型技术栈，框架使用了abp作为我们的开发框架。</p>\n<p>虽然在实际过程中，有人提出了abp开发框架提供了一系列重量级的组件，对我们这样的团队来说可能会扩大技术风险，平白增加项目的时间。但实际过程中，该选型并没有造成想象中那么严重的问题。主要原因大概有以下几点：</p>\n<p>1，abp无论如何依然是.net技术栈中最受欢迎，公认设计最优雅的面向领域驱动设计的框架。哪怕我们不用领域驱动的思想，也不影响我们使用abp的轮子。它的轮子确实太灵活方便了，运用妥当定然能给我们带来不少好处。</p>\n<p>2，即使我已经从事了十年开发，却依然觉得要设计一套权限认证系统远比想象中的复杂。</p>\n<p>事实上这是一个普遍认可的观点，看起来权限认证几个表就能搞定这个问题，其实并非如此。例如abp的权限认证包括了如下复杂的逻辑结构。</p>\n<p><img src=\"https://images.smcdn.cn/AJeFAPstbzMWiy3R/IMG_1783.JPG!thumbnail\" alt=\"图片\"><br>在介绍领域驱动设计的一本书《Microsoft.Net企业级应用架构设计》这本书中，作者也表达了同样的观点：</p>\n<p>即使已经写了多本asp.net的书，创建基于角色的UI基础设施以及相关的成员系统耗费比预期更多的功夫。</p>\n<p>事实上，对于我们这样的项目，关键不是选什么框架，而是选一种能够满足当前需求，又能在未来给公司带来积累的框架和技术体系，而abp和abpvnext恰好如此。小项目可以用abp，大项目则可以考虑后者。或者都可以采用后者。</p>\n<h1 id=\"三，项目过程控制\"><a href=\"#三，项目过程控制\" class=\"headerlink\" title=\"三，项目过程控制\"></a>三，项目过程控制</h1><p>当这个项目拿到时，我们面临短期看似无法完成的较多量需求，难免会存在选择困难证。究竟是做A，还是选B，还是做一个成年人应该选的，两者都选？</p>\n<p>显然，我们的精力有限，只能有所取舍。</p>\n<p>在现代软件工程中，瀑布模型，快速原型开发模型，增量/迭代型模型都是我们在项目选型过程最基础的选择。如果采用瀑布模型，显然不符合我们的实际情况，因为没有足够的资源，不太可能花时间写文档；快速原型也同样如此，花时间做一个完整的demo，那也不太可行，尤其是甲方已经确定了原型之后，已经具备开发实例功能的前提。</p>\n<p>在这个模块优先级选择之中，我个人认为，虽然B端系统这个部分需求很多，优先把它搞定，能够让我们集中精力解决其他问题，但对用户来说，是否真的如此？</p>\n<p>业务价值的评估是我们进行功能优先级评定的第一要素。如同一个价值滑条，同时摆在一个刻度上，永远只有一个功能。</p>\n<p>于是，我们将公众号，大屏作为第一迭代。并安排足够的资源优先完成此模块。当然，资源其实依然并不足够，但大家都知道，资源不足才是项目最普遍的现象，在现有资源范围充分利用，才是成立项目组的目的。</p>\n<p>我们引入了持续集成的概念，要求把更早的交付当作核心目的。为了实现这个目标，我们采取了如下措施：</p>\n<ol>\n<li><p>收集需求，以低保真原型图指导软件开发，除个别页面要求美观外，其他页面以满足可用性为准</p>\n</li>\n<li><p>前后端设计模拟数据，前端就可以开始联调了。</p>\n</li>\n<li><p>划分迭代周期，确定发布节奏。</p>\n</li>\n<li><p>UI先行开发，同步后端开始设计接口和模拟数据的格式，用后端不用直接与前端联调，而是使用测试驱动先行的方式开发后台逻辑。 </p>\n</li>\n</ol>\n<h1 id=\"四，总结\"><a href=\"#四，总结\" class=\"headerlink\" title=\"四，总结\"></a>四，总结</h1><p>当然在实际操作过程中，我们并没有采用测试驱动开发的红绿重构开发实践，这使得我们没有足够的保障措施来确保代码质量，而且由于项目团队普遍经验不足，也意味着我们在未来的演进过程中，将面临许多严重问题。</p>\n<p>在这个项目中，我们采用了合理的迭代划分；让售前，设计驻场确保需求的澄清；采用了开发分支和功能分支分离的模式是我个人认为值得复用的经验。</p>\n<p>由于时间缘故，在下一篇文章中，再讨论一下这个问题。</p>\n<h1 id><a href=\"#\" class=\"headerlink\" title></a></h1>"},{"title":"项目失控过程全纪录","date":"2019-10-09T08:28:00.000Z","author":"邹溪源","_content":"\n\n# 题外话\n在此之前，笔者主要从事传统IT企业的研发技术管理工作，对项目管理虽然有一定的经验，但纯粹摸石子过河，没有系统的学习过项目管理理论，也很容易犯下技术人员对项目管理的一系列毛病。\n之前带的项目一般都是非产品型项目，功能一般以实现为主，对细节没有太多要求。项目一般采用瀑布模型，项目之初一般会制定一个非常详细的研发计划，涵盖需求分析、设计、研发、测试、验收的全过程。由于用户验收测试往往需要花大量时间，因此会输出一份沉甸甸的需求说明书，然后让客户签字，并在验收阶段，在现场维持长时间的驻场开发，以便实时跟进需求的变化。曾经创造了带领10人研发团队、连续3个月，每天维持12个小时以上工时的工作记录。（堪称土劳模）\n这是第一次参与互联网项目的开发，有明确的迭代周期和需求计划，但是由于各种原因，却逐渐走向失控，过程中究竟发生了什么原因？\n# 失控全过程\n话不多说，直接进入正题。\n我将尽量以第三人称视角记录一个失控的项目，但事实上我实际是项目负责人，所以难免有失偏颇。\n这是B公司一个面向特定行业的虚拟建站平台产品，虽然市面上建站产品非常多，但由于B公司在该行业颇有地位，能够获得一些比较实用的数据，这些数据是目标用户群体非常渴求的宝贵资源，因此如果将这些数据做成可视化组件然后打造这样的精准型建站产品，显然具有独特性的优势，能够为目标用户带来便利。\n产品于2月底开始启动会，由研发部门内部碰头后，直接开始启动项目。（该公司管理比较扁平化，产品、研发、测试、设计分属技术部四个不同的团队）。\n由于是互联网产品，因此往往会选择竞品。竞品为为3个比较热门的互联网建站平台，其目标是要满足这些建站平台的特性，包含一个功能强大、效果优雅、流程简单的设计器；实现自动化建站部署等。在项目初期仅明确了总功能点的约40%，初步估计需要完成大大小小的页面15个，设计数据库20几个表。\n（最终做出的页面数量虽然没增加，但是前端的逻辑也非常复杂、后端逻辑也有点复杂，数据库有45个表，大小接口将近80个）\n技术总监指示：采用敏捷开发模式。总工期为8周，按2周一迭代。项目启动时，共有后端开发者3人，前端1人、产品1人、设计1人，测试1人。由本人担任总体负责人和后端开发者。\n这个配比本身不太合理的项目，显然8周时间不可能完成，但领导没有进一步的时间计划，只能基于现有资源制定为期八周的先启阶段，其目标是搭建符合流程的最小可行版本(MVP)。由于大部分功能都在前端，但是实际上仅配了一位前端，而且这位前端是公司的前端负责人，每天仅能花不到40%的时间投入到项目研发过程中。后端则可以开始根据现有需求进行数据库、接口的设计。\n这个MVP版本包含网站定义、网站编辑、网站设计器和发布流程、目前需求范围内的接口功能开发，工期为8周。\n项目组还需另外招聘3位前端开发者。\n到五月底最终完成整个MVP功能开发花了十周时间。因为前端部分的工作量大于预估，仅设计器就花了6周。5月完成简单的演示，基本符合主体流程。\n![图片](https://uploader.shimo.im/f/yIOYm0fpLIklIBJc.png!thumbnail)\n此时项目需求已经明确了60%，技术总监认为7月底可以完成功能的开发。\n于是从5月开始，到7月底，共有10周时间，开始进入倒排期。庆幸项目组成员已经配齐，至少是有人可以用。但在需求池里面的需求非常多，所以大家得加班。于是集体开始进入加班状态。\n项目很给力，动作交互和逻辑非常多，许多样式和动作都需要前端开发，几乎没有任何可以复用的经验，由于设计器本身是赶工期赶出来的，功能不完善，而且还有很多组件功能需要开发，最终于7月20几号左右完成主体功能的开发，但是有较多量的bug，推迟到8月6日才能交付测试，然后还剩余的40%功能点。\n![图片](https://uploader.shimo.im/f/Y3mAl1Mo3FYvknDn.png!thumbnail)\n由于项目已经严重滞后，上线目标定在9月中旬，又是一轮加班，坚持到8月底。\n需求勉强控制住了，但是bug却越来越多，已经远远不可能在9月交付了。\n![图片](https://uploader.shimo.im/f/yoJJ7UMPLkcLtE80.png!thumbnail)\n一句话总结：开始时，没人，赶时间；后来人来了，但是任务多，赶时间；最后，任务多，bug多，也赶时间。 程序员们的996,就是这么产生的。\n# 项目结局\n进入9月，公司高层对项目提出了新的要求，项目需求将进一步增加。\n由于负面情绪的影响、以及对在这家公司的发展前途迷茫、无法忍受高强度的工作、转Java等原因，本人提出离职；\n而担任前端开发工作的核心开发者也同样因为待遇问题、发展前途、技术路线不匹配等原因提出离职。\n项目彻底失控。\n\n# 问题分析\n1. 未能及时的向上级汇报可能存在的风险，未能考虑补偿资源等问题。未能实时的进行问题的跟进，汇报和沟通，直到最终问题无法弥补而爆发。\n2. 项目管理过程中过程数据不完善，无法形成有效的经验教训知识库，容易造成组织过程资产的流失。\n3. 这个项目前期需求范围虽然比较明确，但是技术细节多，人员不足，设定工期内明显完不成。\n4. 项目团队属于重新组建的团队，都是入司未满一年的新员工，且还有一半是在项目期间组建的新员工，彼此缺乏磨合。\n5. 项目任务优先级不明确，对MVP的粒度划分也不合理。（因为设计器功能很复杂，花费了大量的时间去开发）前期的功能粒度划分不合理，测试无法第一时间介入，问题积累到后期爆发。 \n6. 功能逻辑复杂，细节颇多。拍脑袋式的工时估算和计划不适合此类项目。\n7. 异地沟通本身存在时延，影响了项目执行效果。\n8. 由于为了完成不可能完成的任务，项目组成员被迫赶工期，为了盲目应对需求变化而投机取巧，难免会改出新问题。\n9. 公司内部对代码质量和工期提出了新要求，延迟这么凶的项目显然不会获得高绩效；除此之外，内部政策变动，要求实施9116的工作制度，加上提出了封闭项目等政策，让内部消极情绪开始占上风。\n10. 本身存在一些技术问题。\n# 结论\n使用好项目管理工具有利于知识的传承和积累，对项目管理过程来说尤为重要，这个项目虽然使用了Jira作为项目管理工具，设定了迭代目标和周期，但是未能妥善使用，依然是用excel进行项目管理，措施不科学，也无法直观的观察项目进程。\n互联网产品致力于为用户提高更高的用户体验，因此需要花更长的时间和精力进行UI级的打磨、开发者也同样需要花更大的时间来完成对应的开发任务，作为项目经理要学会做好上下沟通，遇到问题应该给出自己的专业意见，有问题应该尽早向领导汇报风险，积极的反馈意见，哪怕收不到积极的响应，也能起到提前预防的作用。 \n进度和计划固然是很重要的，但是要认识到人才是企业的核心竞争力，一支对产品精益求职的产品设计团队、一支每天愿意花10小时耐心写代码、努力提高研发产出的软件工程师团队是互联网产品成功的核心关键。\n一味的压缩工时来完成产品的研发不现实，在时间、进度、质量之间，必须找到一个中间点，这就要求做好客户的预期管理。\n\n\n","source":"_posts/管理/项目失控全记录.md","raw":"---\ntitle:  项目失控过程全纪录\ndate: 2019-10-09 16:28\ntags: 管理\nauthor: 邹溪源\ncategories:\n  - 管理\n---\n\n\n# 题外话\n在此之前，笔者主要从事传统IT企业的研发技术管理工作，对项目管理虽然有一定的经验，但纯粹摸石子过河，没有系统的学习过项目管理理论，也很容易犯下技术人员对项目管理的一系列毛病。\n之前带的项目一般都是非产品型项目，功能一般以实现为主，对细节没有太多要求。项目一般采用瀑布模型，项目之初一般会制定一个非常详细的研发计划，涵盖需求分析、设计、研发、测试、验收的全过程。由于用户验收测试往往需要花大量时间，因此会输出一份沉甸甸的需求说明书，然后让客户签字，并在验收阶段，在现场维持长时间的驻场开发，以便实时跟进需求的变化。曾经创造了带领10人研发团队、连续3个月，每天维持12个小时以上工时的工作记录。（堪称土劳模）\n这是第一次参与互联网项目的开发，有明确的迭代周期和需求计划，但是由于各种原因，却逐渐走向失控，过程中究竟发生了什么原因？\n# 失控全过程\n话不多说，直接进入正题。\n我将尽量以第三人称视角记录一个失控的项目，但事实上我实际是项目负责人，所以难免有失偏颇。\n这是B公司一个面向特定行业的虚拟建站平台产品，虽然市面上建站产品非常多，但由于B公司在该行业颇有地位，能够获得一些比较实用的数据，这些数据是目标用户群体非常渴求的宝贵资源，因此如果将这些数据做成可视化组件然后打造这样的精准型建站产品，显然具有独特性的优势，能够为目标用户带来便利。\n产品于2月底开始启动会，由研发部门内部碰头后，直接开始启动项目。（该公司管理比较扁平化，产品、研发、测试、设计分属技术部四个不同的团队）。\n由于是互联网产品，因此往往会选择竞品。竞品为为3个比较热门的互联网建站平台，其目标是要满足这些建站平台的特性，包含一个功能强大、效果优雅、流程简单的设计器；实现自动化建站部署等。在项目初期仅明确了总功能点的约40%，初步估计需要完成大大小小的页面15个，设计数据库20几个表。\n（最终做出的页面数量虽然没增加，但是前端的逻辑也非常复杂、后端逻辑也有点复杂，数据库有45个表，大小接口将近80个）\n技术总监指示：采用敏捷开发模式。总工期为8周，按2周一迭代。项目启动时，共有后端开发者3人，前端1人、产品1人、设计1人，测试1人。由本人担任总体负责人和后端开发者。\n这个配比本身不太合理的项目，显然8周时间不可能完成，但领导没有进一步的时间计划，只能基于现有资源制定为期八周的先启阶段，其目标是搭建符合流程的最小可行版本(MVP)。由于大部分功能都在前端，但是实际上仅配了一位前端，而且这位前端是公司的前端负责人，每天仅能花不到40%的时间投入到项目研发过程中。后端则可以开始根据现有需求进行数据库、接口的设计。\n这个MVP版本包含网站定义、网站编辑、网站设计器和发布流程、目前需求范围内的接口功能开发，工期为8周。\n项目组还需另外招聘3位前端开发者。\n到五月底最终完成整个MVP功能开发花了十周时间。因为前端部分的工作量大于预估，仅设计器就花了6周。5月完成简单的演示，基本符合主体流程。\n![图片](https://uploader.shimo.im/f/yIOYm0fpLIklIBJc.png!thumbnail)\n此时项目需求已经明确了60%，技术总监认为7月底可以完成功能的开发。\n于是从5月开始，到7月底，共有10周时间，开始进入倒排期。庆幸项目组成员已经配齐，至少是有人可以用。但在需求池里面的需求非常多，所以大家得加班。于是集体开始进入加班状态。\n项目很给力，动作交互和逻辑非常多，许多样式和动作都需要前端开发，几乎没有任何可以复用的经验，由于设计器本身是赶工期赶出来的，功能不完善，而且还有很多组件功能需要开发，最终于7月20几号左右完成主体功能的开发，但是有较多量的bug，推迟到8月6日才能交付测试，然后还剩余的40%功能点。\n![图片](https://uploader.shimo.im/f/Y3mAl1Mo3FYvknDn.png!thumbnail)\n由于项目已经严重滞后，上线目标定在9月中旬，又是一轮加班，坚持到8月底。\n需求勉强控制住了，但是bug却越来越多，已经远远不可能在9月交付了。\n![图片](https://uploader.shimo.im/f/yoJJ7UMPLkcLtE80.png!thumbnail)\n一句话总结：开始时，没人，赶时间；后来人来了，但是任务多，赶时间；最后，任务多，bug多，也赶时间。 程序员们的996,就是这么产生的。\n# 项目结局\n进入9月，公司高层对项目提出了新的要求，项目需求将进一步增加。\n由于负面情绪的影响、以及对在这家公司的发展前途迷茫、无法忍受高强度的工作、转Java等原因，本人提出离职；\n而担任前端开发工作的核心开发者也同样因为待遇问题、发展前途、技术路线不匹配等原因提出离职。\n项目彻底失控。\n\n# 问题分析\n1. 未能及时的向上级汇报可能存在的风险，未能考虑补偿资源等问题。未能实时的进行问题的跟进，汇报和沟通，直到最终问题无法弥补而爆发。\n2. 项目管理过程中过程数据不完善，无法形成有效的经验教训知识库，容易造成组织过程资产的流失。\n3. 这个项目前期需求范围虽然比较明确，但是技术细节多，人员不足，设定工期内明显完不成。\n4. 项目团队属于重新组建的团队，都是入司未满一年的新员工，且还有一半是在项目期间组建的新员工，彼此缺乏磨合。\n5. 项目任务优先级不明确，对MVP的粒度划分也不合理。（因为设计器功能很复杂，花费了大量的时间去开发）前期的功能粒度划分不合理，测试无法第一时间介入，问题积累到后期爆发。 \n6. 功能逻辑复杂，细节颇多。拍脑袋式的工时估算和计划不适合此类项目。\n7. 异地沟通本身存在时延，影响了项目执行效果。\n8. 由于为了完成不可能完成的任务，项目组成员被迫赶工期，为了盲目应对需求变化而投机取巧，难免会改出新问题。\n9. 公司内部对代码质量和工期提出了新要求，延迟这么凶的项目显然不会获得高绩效；除此之外，内部政策变动，要求实施9116的工作制度，加上提出了封闭项目等政策，让内部消极情绪开始占上风。\n10. 本身存在一些技术问题。\n# 结论\n使用好项目管理工具有利于知识的传承和积累，对项目管理过程来说尤为重要，这个项目虽然使用了Jira作为项目管理工具，设定了迭代目标和周期，但是未能妥善使用，依然是用excel进行项目管理，措施不科学，也无法直观的观察项目进程。\n互联网产品致力于为用户提高更高的用户体验，因此需要花更长的时间和精力进行UI级的打磨、开发者也同样需要花更大的时间来完成对应的开发任务，作为项目经理要学会做好上下沟通，遇到问题应该给出自己的专业意见，有问题应该尽早向领导汇报风险，积极的反馈意见，哪怕收不到积极的响应，也能起到提前预防的作用。 \n进度和计划固然是很重要的，但是要认识到人才是企业的核心竞争力，一支对产品精益求职的产品设计团队、一支每天愿意花10小时耐心写代码、努力提高研发产出的软件工程师团队是互联网产品成功的核心关键。\n一味的压缩工时来完成产品的研发不现实，在时间、进度、质量之间，必须找到一个中间点，这就要求做好客户的预期管理。\n\n\n","slug":"管理/项目失控全记录","published":1,"updated":"2019-10-09T10:49:19.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt8d002cn4vixwx7zerk","content":"<h1 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h1><p>在此之前，笔者主要从事传统IT企业的研发技术管理工作，对项目管理虽然有一定的经验，但纯粹摸石子过河，没有系统的学习过项目管理理论，也很容易犯下技术人员对项目管理的一系列毛病。<br>之前带的项目一般都是非产品型项目，功能一般以实现为主，对细节没有太多要求。项目一般采用瀑布模型，项目之初一般会制定一个非常详细的研发计划，涵盖需求分析、设计、研发、测试、验收的全过程。由于用户验收测试往往需要花大量时间，因此会输出一份沉甸甸的需求说明书，然后让客户签字，并在验收阶段，在现场维持长时间的驻场开发，以便实时跟进需求的变化。曾经创造了带领10人研发团队、连续3个月，每天维持12个小时以上工时的工作记录。（堪称土劳模）<br>这是第一次参与互联网项目的开发，有明确的迭代周期和需求计划，但是由于各种原因，却逐渐走向失控，过程中究竟发生了什么原因？</p>\n<h1 id=\"失控全过程\"><a href=\"#失控全过程\" class=\"headerlink\" title=\"失控全过程\"></a>失控全过程</h1><p>话不多说，直接进入正题。<br>我将尽量以第三人称视角记录一个失控的项目，但事实上我实际是项目负责人，所以难免有失偏颇。<br>这是B公司一个面向特定行业的虚拟建站平台产品，虽然市面上建站产品非常多，但由于B公司在该行业颇有地位，能够获得一些比较实用的数据，这些数据是目标用户群体非常渴求的宝贵资源，因此如果将这些数据做成可视化组件然后打造这样的精准型建站产品，显然具有独特性的优势，能够为目标用户带来便利。<br>产品于2月底开始启动会，由研发部门内部碰头后，直接开始启动项目。（该公司管理比较扁平化，产品、研发、测试、设计分属技术部四个不同的团队）。<br>由于是互联网产品，因此往往会选择竞品。竞品为为3个比较热门的互联网建站平台，其目标是要满足这些建站平台的特性，包含一个功能强大、效果优雅、流程简单的设计器；实现自动化建站部署等。在项目初期仅明确了总功能点的约40%，初步估计需要完成大大小小的页面15个，设计数据库20几个表。<br>（最终做出的页面数量虽然没增加，但是前端的逻辑也非常复杂、后端逻辑也有点复杂，数据库有45个表，大小接口将近80个）<br>技术总监指示：采用敏捷开发模式。总工期为8周，按2周一迭代。项目启动时，共有后端开发者3人，前端1人、产品1人、设计1人，测试1人。由本人担任总体负责人和后端开发者。<br>这个配比本身不太合理的项目，显然8周时间不可能完成，但领导没有进一步的时间计划，只能基于现有资源制定为期八周的先启阶段，其目标是搭建符合流程的最小可行版本(MVP)。由于大部分功能都在前端，但是实际上仅配了一位前端，而且这位前端是公司的前端负责人，每天仅能花不到40%的时间投入到项目研发过程中。后端则可以开始根据现有需求进行数据库、接口的设计。<br>这个MVP版本包含网站定义、网站编辑、网站设计器和发布流程、目前需求范围内的接口功能开发，工期为8周。<br>项目组还需另外招聘3位前端开发者。<br>到五月底最终完成整个MVP功能开发花了十周时间。因为前端部分的工作量大于预估，仅设计器就花了6周。5月完成简单的演示，基本符合主体流程。<br><img src=\"https://uploader.shimo.im/f/yIOYm0fpLIklIBJc.png!thumbnail\" alt=\"图片\"><br>此时项目需求已经明确了60%，技术总监认为7月底可以完成功能的开发。<br>于是从5月开始，到7月底，共有10周时间，开始进入倒排期。庆幸项目组成员已经配齐，至少是有人可以用。但在需求池里面的需求非常多，所以大家得加班。于是集体开始进入加班状态。<br>项目很给力，动作交互和逻辑非常多，许多样式和动作都需要前端开发，几乎没有任何可以复用的经验，由于设计器本身是赶工期赶出来的，功能不完善，而且还有很多组件功能需要开发，最终于7月20几号左右完成主体功能的开发，但是有较多量的bug，推迟到8月6日才能交付测试，然后还剩余的40%功能点。<br><img src=\"https://uploader.shimo.im/f/Y3mAl1Mo3FYvknDn.png!thumbnail\" alt=\"图片\"><br>由于项目已经严重滞后，上线目标定在9月中旬，又是一轮加班，坚持到8月底。<br>需求勉强控制住了，但是bug却越来越多，已经远远不可能在9月交付了。<br><img src=\"https://uploader.shimo.im/f/yoJJ7UMPLkcLtE80.png!thumbnail\" alt=\"图片\"><br>一句话总结：开始时，没人，赶时间；后来人来了，但是任务多，赶时间；最后，任务多，bug多，也赶时间。 程序员们的996,就是这么产生的。</p>\n<h1 id=\"项目结局\"><a href=\"#项目结局\" class=\"headerlink\" title=\"项目结局\"></a>项目结局</h1><p>进入9月，公司高层对项目提出了新的要求，项目需求将进一步增加。<br>由于负面情绪的影响、以及对在这家公司的发展前途迷茫、无法忍受高强度的工作、转Java等原因，本人提出离职；<br>而担任前端开发工作的核心开发者也同样因为待遇问题、发展前途、技术路线不匹配等原因提出离职。<br>项目彻底失控。</p>\n<h1 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h1><ol>\n<li>未能及时的向上级汇报可能存在的风险，未能考虑补偿资源等问题。未能实时的进行问题的跟进，汇报和沟通，直到最终问题无法弥补而爆发。</li>\n<li>项目管理过程中过程数据不完善，无法形成有效的经验教训知识库，容易造成组织过程资产的流失。</li>\n<li>这个项目前期需求范围虽然比较明确，但是技术细节多，人员不足，设定工期内明显完不成。</li>\n<li>项目团队属于重新组建的团队，都是入司未满一年的新员工，且还有一半是在项目期间组建的新员工，彼此缺乏磨合。</li>\n<li>项目任务优先级不明确，对MVP的粒度划分也不合理。（因为设计器功能很复杂，花费了大量的时间去开发）前期的功能粒度划分不合理，测试无法第一时间介入，问题积累到后期爆发。 </li>\n<li>功能逻辑复杂，细节颇多。拍脑袋式的工时估算和计划不适合此类项目。</li>\n<li>异地沟通本身存在时延，影响了项目执行效果。</li>\n<li>由于为了完成不可能完成的任务，项目组成员被迫赶工期，为了盲目应对需求变化而投机取巧，难免会改出新问题。</li>\n<li>公司内部对代码质量和工期提出了新要求，延迟这么凶的项目显然不会获得高绩效；除此之外，内部政策变动，要求实施9116的工作制度，加上提出了封闭项目等政策，让内部消极情绪开始占上风。</li>\n<li>本身存在一些技术问题。<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1>使用好项目管理工具有利于知识的传承和积累，对项目管理过程来说尤为重要，这个项目虽然使用了Jira作为项目管理工具，设定了迭代目标和周期，但是未能妥善使用，依然是用excel进行项目管理，措施不科学，也无法直观的观察项目进程。<br>互联网产品致力于为用户提高更高的用户体验，因此需要花更长的时间和精力进行UI级的打磨、开发者也同样需要花更大的时间来完成对应的开发任务，作为项目经理要学会做好上下沟通，遇到问题应该给出自己的专业意见，有问题应该尽早向领导汇报风险，积极的反馈意见，哪怕收不到积极的响应，也能起到提前预防的作用。<br>进度和计划固然是很重要的，但是要认识到人才是企业的核心竞争力，一支对产品精益求职的产品设计团队、一支每天愿意花10小时耐心写代码、努力提高研发产出的软件工程师团队是互联网产品成功的核心关键。<br>一味的压缩工时来完成产品的研发不现实，在时间、进度、质量之间，必须找到一个中间点，这就要求做好客户的预期管理。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h1><p>在此之前，笔者主要从事传统IT企业的研发技术管理工作，对项目管理虽然有一定的经验，但纯粹摸石子过河，没有系统的学习过项目管理理论，也很容易犯下技术人员对项目管理的一系列毛病。<br>之前带的项目一般都是非产品型项目，功能一般以实现为主，对细节没有太多要求。项目一般采用瀑布模型，项目之初一般会制定一个非常详细的研发计划，涵盖需求分析、设计、研发、测试、验收的全过程。由于用户验收测试往往需要花大量时间，因此会输出一份沉甸甸的需求说明书，然后让客户签字，并在验收阶段，在现场维持长时间的驻场开发，以便实时跟进需求的变化。曾经创造了带领10人研发团队、连续3个月，每天维持12个小时以上工时的工作记录。（堪称土劳模）<br>这是第一次参与互联网项目的开发，有明确的迭代周期和需求计划，但是由于各种原因，却逐渐走向失控，过程中究竟发生了什么原因？</p>\n<h1 id=\"失控全过程\"><a href=\"#失控全过程\" class=\"headerlink\" title=\"失控全过程\"></a>失控全过程</h1><p>话不多说，直接进入正题。<br>我将尽量以第三人称视角记录一个失控的项目，但事实上我实际是项目负责人，所以难免有失偏颇。<br>这是B公司一个面向特定行业的虚拟建站平台产品，虽然市面上建站产品非常多，但由于B公司在该行业颇有地位，能够获得一些比较实用的数据，这些数据是目标用户群体非常渴求的宝贵资源，因此如果将这些数据做成可视化组件然后打造这样的精准型建站产品，显然具有独特性的优势，能够为目标用户带来便利。<br>产品于2月底开始启动会，由研发部门内部碰头后，直接开始启动项目。（该公司管理比较扁平化，产品、研发、测试、设计分属技术部四个不同的团队）。<br>由于是互联网产品，因此往往会选择竞品。竞品为为3个比较热门的互联网建站平台，其目标是要满足这些建站平台的特性，包含一个功能强大、效果优雅、流程简单的设计器；实现自动化建站部署等。在项目初期仅明确了总功能点的约40%，初步估计需要完成大大小小的页面15个，设计数据库20几个表。<br>（最终做出的页面数量虽然没增加，但是前端的逻辑也非常复杂、后端逻辑也有点复杂，数据库有45个表，大小接口将近80个）<br>技术总监指示：采用敏捷开发模式。总工期为8周，按2周一迭代。项目启动时，共有后端开发者3人，前端1人、产品1人、设计1人，测试1人。由本人担任总体负责人和后端开发者。<br>这个配比本身不太合理的项目，显然8周时间不可能完成，但领导没有进一步的时间计划，只能基于现有资源制定为期八周的先启阶段，其目标是搭建符合流程的最小可行版本(MVP)。由于大部分功能都在前端，但是实际上仅配了一位前端，而且这位前端是公司的前端负责人，每天仅能花不到40%的时间投入到项目研发过程中。后端则可以开始根据现有需求进行数据库、接口的设计。<br>这个MVP版本包含网站定义、网站编辑、网站设计器和发布流程、目前需求范围内的接口功能开发，工期为8周。<br>项目组还需另外招聘3位前端开发者。<br>到五月底最终完成整个MVP功能开发花了十周时间。因为前端部分的工作量大于预估，仅设计器就花了6周。5月完成简单的演示，基本符合主体流程。<br><img src=\"https://uploader.shimo.im/f/yIOYm0fpLIklIBJc.png!thumbnail\" alt=\"图片\"><br>此时项目需求已经明确了60%，技术总监认为7月底可以完成功能的开发。<br>于是从5月开始，到7月底，共有10周时间，开始进入倒排期。庆幸项目组成员已经配齐，至少是有人可以用。但在需求池里面的需求非常多，所以大家得加班。于是集体开始进入加班状态。<br>项目很给力，动作交互和逻辑非常多，许多样式和动作都需要前端开发，几乎没有任何可以复用的经验，由于设计器本身是赶工期赶出来的，功能不完善，而且还有很多组件功能需要开发，最终于7月20几号左右完成主体功能的开发，但是有较多量的bug，推迟到8月6日才能交付测试，然后还剩余的40%功能点。<br><img src=\"https://uploader.shimo.im/f/Y3mAl1Mo3FYvknDn.png!thumbnail\" alt=\"图片\"><br>由于项目已经严重滞后，上线目标定在9月中旬，又是一轮加班，坚持到8月底。<br>需求勉强控制住了，但是bug却越来越多，已经远远不可能在9月交付了。<br><img src=\"https://uploader.shimo.im/f/yoJJ7UMPLkcLtE80.png!thumbnail\" alt=\"图片\"><br>一句话总结：开始时，没人，赶时间；后来人来了，但是任务多，赶时间；最后，任务多，bug多，也赶时间。 程序员们的996,就是这么产生的。</p>\n<h1 id=\"项目结局\"><a href=\"#项目结局\" class=\"headerlink\" title=\"项目结局\"></a>项目结局</h1><p>进入9月，公司高层对项目提出了新的要求，项目需求将进一步增加。<br>由于负面情绪的影响、以及对在这家公司的发展前途迷茫、无法忍受高强度的工作、转Java等原因，本人提出离职；<br>而担任前端开发工作的核心开发者也同样因为待遇问题、发展前途、技术路线不匹配等原因提出离职。<br>项目彻底失控。</p>\n<h1 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h1><ol>\n<li>未能及时的向上级汇报可能存在的风险，未能考虑补偿资源等问题。未能实时的进行问题的跟进，汇报和沟通，直到最终问题无法弥补而爆发。</li>\n<li>项目管理过程中过程数据不完善，无法形成有效的经验教训知识库，容易造成组织过程资产的流失。</li>\n<li>这个项目前期需求范围虽然比较明确，但是技术细节多，人员不足，设定工期内明显完不成。</li>\n<li>项目团队属于重新组建的团队，都是入司未满一年的新员工，且还有一半是在项目期间组建的新员工，彼此缺乏磨合。</li>\n<li>项目任务优先级不明确，对MVP的粒度划分也不合理。（因为设计器功能很复杂，花费了大量的时间去开发）前期的功能粒度划分不合理，测试无法第一时间介入，问题积累到后期爆发。 </li>\n<li>功能逻辑复杂，细节颇多。拍脑袋式的工时估算和计划不适合此类项目。</li>\n<li>异地沟通本身存在时延，影响了项目执行效果。</li>\n<li>由于为了完成不可能完成的任务，项目组成员被迫赶工期，为了盲目应对需求变化而投机取巧，难免会改出新问题。</li>\n<li>公司内部对代码质量和工期提出了新要求，延迟这么凶的项目显然不会获得高绩效；除此之外，内部政策变动，要求实施9116的工作制度，加上提出了封闭项目等政策，让内部消极情绪开始占上风。</li>\n<li>本身存在一些技术问题。<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1>使用好项目管理工具有利于知识的传承和积累，对项目管理过程来说尤为重要，这个项目虽然使用了Jira作为项目管理工具，设定了迭代目标和周期，但是未能妥善使用，依然是用excel进行项目管理，措施不科学，也无法直观的观察项目进程。<br>互联网产品致力于为用户提高更高的用户体验，因此需要花更长的时间和精力进行UI级的打磨、开发者也同样需要花更大的时间来完成对应的开发任务，作为项目经理要学会做好上下沟通，遇到问题应该给出自己的专业意见，有问题应该尽早向领导汇报风险，积极的反馈意见，哪怕收不到积极的响应，也能起到提前预防的作用。<br>进度和计划固然是很重要的，但是要认识到人才是企业的核心竞争力，一支对产品精益求职的产品设计团队、一支每天愿意花10小时耐心写代码、努力提高研发产出的软件工程师团队是互联网产品成功的核心关键。<br>一味的压缩工时来完成产品的研发不现实，在时间、进度、质量之间，必须找到一个中间点，这就要求做好客户的预期管理。</li>\n</ol>\n"},{"title":"《实例化需求》读书笔记","date":"2019-10-09T08:28:00.000Z","author":"邹溪源","_content":"\n# **背景**\n一直以来我都是从事软件研发、兼顾项目管理工作，在项目开发中，总是会遇到一些各种各样的问题，我也曾试图在项目中推动过类似于敏捷这样的项目管理方法，但是最终却收效不大。随着我工作经验的逐渐累积，发现不同的项目、不管是敏捷还是非敏捷、不管是如何失败的，其中对于用户需求的把控都是一个非常关键的因素。\n>**用户需求，就是笼子里的狮子，你不放出来，受伤的是狮子，你放出来，受伤的是你自己。**\n\n在项目过程中，我们倾向于输出一份沉甸甸的需求文档，但是这份需求文档等项目做完了，往往会过时而用处不大。由于无穷次变更或开发者们对于需求的理解层次不同，设计业务领域的项目经理，显然不可能对软件的实现部分进行全方位的掌控，对于一些比较大的项目，掌握全局就已经很不错了，更不用说代码了，然而一切业务都凝聚在代码中，这些代码是如何实现用户需求的？\n----**取决于开发者的经验，科学表明，一切靠经验来实现传承的知识体系，都是魔法。**\n# 概述\n前段时间，我听张逸老师《领域驱动设计实践》课程中了解到《实例化需求》这本书，于是下单购买了，期待能获得一些启迪。\n《实例化需求》是一本介绍软件工程方法论的书，这本书没有源代码、也没有特定工具的使用说明。在这本书中，他收集了来自现实世界、真实的团队以及切实的经验，同时也引入了一些建议，他希望通过这本书能够帮助大家使用这些组织过程或模式去建立活文档系统，从而提高软件项目的可控性。\n在传统的项目开发中，尚且可以要求每个产品持续很长的时间，例如，一般都是以月为单位，甚至以年为单位。但是在互联网开发中，交付时间往往被压缩到一周为单位、甚至以天为单位，所以大量的前期软件设计和详细的需求分析环节将不复存在，而且传统的手工测试也耗时漫长，也被更加科学的自动化测试所替代。在这样的背景下，文档随时会过时，因此使用Axure原型软件设计高保真的UI交互原型是普遍的选择，如果有需求变更，就对原型进行修改，然后再通过原型推动功能的变更。\n在作者的官方网站上，他认为《实例化需求》是一组过程模式，可以协助软件产品的变更，确保有效地交付正确的产品。 这里所说的正确产品，指的是该软件能满足客户或企业用户提出的商业需求，或者能达成预定的商业目标；同时它要具备一定的灵活性，未来能以相对平稳的投入接受后续改进。\n作者认为，要有效的构建正确的产品，传统的软件开发实践首先需要满足一下几点：\n1、保证所有项目干系人和交付团队的成员都对需要交付哪些东西有一致的理解。\n2、有准确的需求说明，这样交付团队才避免有模棱两可和功能缺失造成的无谓返工。\n3、有用来衡量某项工作是否完成的客观标准。\n4、具有指导软件团队或团队结构变更的文档。\n而基于Axure进行设计再推动职能团队完成功能开发的模式，看似满足了上述目标，避免了过度的需求文档造成的浪费、也能够很好的解释用户需求，但是却更关注于用户交互过程、无法涉及面子之下的里子、返工和功能维护让需求的验证过程变得越来越不可控，终输出的软件产品，顶多只能算一个花里胡哨的绣花枕头而已。\n由于软件产品每周都要交付，作者认为，比较合理的解决方案应该带来如下好处：\n1、避免过度说明需求从而产生浪费，避免花时间在开发前会发生改变的细节上。\n2、有一种可靠的文档，可以解释系统的行为，据此我们可以很容易的修改系统行为。\n3、可以有效地检查系统行为与需求说明的描述是否一致。\n4、以最小的维护成本维护文档的相关性和可靠性。\n5、适合短迭代和基于流的过程，这样能为即将开展的工作提供技术足够的信息。 \n这也是实例化说明渴望达到的目的，作者对许多企业进行了访谈，总结了实例化需求的应用案例，他认为通过引入实例化需求可以达到以下收益。。\n1、更有效的实施变更。作者将其中的最重要的经验称为活文档（living documentation）的广泛应用是有长期受益的。这本书广泛涵盖了这一部分的内容。文中如是说\n>**“活文档是系统功能的一个信息源，它与程序代码一样可靠，但易于使用和理解。它能帮助团队共同分析变更所带来的影响并讨论潜在的方案。团队还可以为新的需求扩展已有的文档，长此以往，可以使得需求说明和实施变更更有效。”**\n\n2、更高的产品质量。由于预期明确，验证变得更有效率。\n3、更少的返工。由于需求写作更好，使团队确保对预期达成共识。\n4、同一项目不同角色的活动协调得更好。改善写作形成定期的交付流程。\n# 关键过程模式\n作者总结了在实施实例化需求中的一些关键过程模式：\n1、从目标中获取范围。许多软件在开始之前，期望由客户、产品负责人、商业用户来确定工作的范围，而商业用户明确他们的需求之后，软件交付团队就依次实现，但是由于用户不是专业的软件设计师，因此他提出的需求，固然是他所要求的，但并非是他真正需要的。所以关键模式就是从目标中获取需求，用户专注于传达所需功能希望达到的目的和期望由此带来的价值，而交付团队则致力于提出解决方案。\n2、协作需求。不依赖于个人去收集正确的需求，而是与商业用户一起协作指定解决方案，这可以让我们充分利用团队的知识和经验，还创造了需求的集体所有制，让每个人都能参与到交付过程中。\n3、举例说明。在编程语言实现过程中，成功的团队不会等待需求被精准表述，而是举例说明需求。用一些额外的实例用于说明边界情况，或重点标识出系统中某些特别有问题的地方，这样可以清楚功能分歧和不一致的地方，避免由误解或解释不到位导致的返工。\n4、提炼需求。关键实例必须精简才有用，通过移除多余信息并为开发和测试过程创建一个具体、精确的上下文。软件的目标是该做什么，而不是该怎么做。\n5、自动化验证时，不改变需求说明。\n6、频繁验证。通过频繁验证，团队可以快速发现系统与需求说明之间的任何差别。团队成员可以更好的与用户交流，并决定如何处理。他们可以不断地同步系统和可执行的需求说明。\n7、演化成活文档系统。活文档系统告诉系统可以做什么，并与代码一起确切可靠，但具有更好的可读性。 \n# 问题思考\n\n这本书与其他介绍软件理论的书籍一样，知识量比较稠密，阅读过程中花费了不少时间，如豆瓣上有网友说的：\n>**读一本书，如果能给你带来一点感悟，那就赚回书钱了。如果带给你两三点感悟，花费的时间也就值了。如果带给你五六点，甚至七八点，那就可以为作者捐款以示感谢了。****。**\n\n这本书也是大概如此，书的重点其实是引入行为驱动开发（BDD），并让需求变得可执行的过程，让这套方法论实践起来大概需要花费更长的时间，但是也可以成为软件设计者们思考的一个方向。\n个人认为，引入Cucumber这样的自动化测试工具，使用行为驱动设计的方法进行软件需求的描述编写活文档、然后再将其引入到测试过程中，或许有点难，但是也可以尝试使用这样的分析方法来设计我们的需求。\n尤其是当需求不明确的时候，如果使用原型分析法或其他描述方法来定义需求，往往可能不够具体，则可以考虑使用图表或实际例子来描述，并创造性的给角色取一些花名，可以让需求的描述过程变得更加的生动。\n\n---\n1、《[https://www.infoq.cn/article/specification-by-example-book/](https://www.infoq.cn/article/specification-by-example-book/)》《实例化需求》采访与书评。\n\n\n","source":"_posts/读书/《实例化需求》读书笔记.md","raw":"---\ntitle:  《实例化需求》读书笔记\ndate: 2019-10-09 16:28\ntags: 读书\nauthor: 邹溪源\ncategories:\n  - 读书\n---\n\n# **背景**\n一直以来我都是从事软件研发、兼顾项目管理工作，在项目开发中，总是会遇到一些各种各样的问题，我也曾试图在项目中推动过类似于敏捷这样的项目管理方法，但是最终却收效不大。随着我工作经验的逐渐累积，发现不同的项目、不管是敏捷还是非敏捷、不管是如何失败的，其中对于用户需求的把控都是一个非常关键的因素。\n>**用户需求，就是笼子里的狮子，你不放出来，受伤的是狮子，你放出来，受伤的是你自己。**\n\n在项目过程中，我们倾向于输出一份沉甸甸的需求文档，但是这份需求文档等项目做完了，往往会过时而用处不大。由于无穷次变更或开发者们对于需求的理解层次不同，设计业务领域的项目经理，显然不可能对软件的实现部分进行全方位的掌控，对于一些比较大的项目，掌握全局就已经很不错了，更不用说代码了，然而一切业务都凝聚在代码中，这些代码是如何实现用户需求的？\n----**取决于开发者的经验，科学表明，一切靠经验来实现传承的知识体系，都是魔法。**\n# 概述\n前段时间，我听张逸老师《领域驱动设计实践》课程中了解到《实例化需求》这本书，于是下单购买了，期待能获得一些启迪。\n《实例化需求》是一本介绍软件工程方法论的书，这本书没有源代码、也没有特定工具的使用说明。在这本书中，他收集了来自现实世界、真实的团队以及切实的经验，同时也引入了一些建议，他希望通过这本书能够帮助大家使用这些组织过程或模式去建立活文档系统，从而提高软件项目的可控性。\n在传统的项目开发中，尚且可以要求每个产品持续很长的时间，例如，一般都是以月为单位，甚至以年为单位。但是在互联网开发中，交付时间往往被压缩到一周为单位、甚至以天为单位，所以大量的前期软件设计和详细的需求分析环节将不复存在，而且传统的手工测试也耗时漫长，也被更加科学的自动化测试所替代。在这样的背景下，文档随时会过时，因此使用Axure原型软件设计高保真的UI交互原型是普遍的选择，如果有需求变更，就对原型进行修改，然后再通过原型推动功能的变更。\n在作者的官方网站上，他认为《实例化需求》是一组过程模式，可以协助软件产品的变更，确保有效地交付正确的产品。 这里所说的正确产品，指的是该软件能满足客户或企业用户提出的商业需求，或者能达成预定的商业目标；同时它要具备一定的灵活性，未来能以相对平稳的投入接受后续改进。\n作者认为，要有效的构建正确的产品，传统的软件开发实践首先需要满足一下几点：\n1、保证所有项目干系人和交付团队的成员都对需要交付哪些东西有一致的理解。\n2、有准确的需求说明，这样交付团队才避免有模棱两可和功能缺失造成的无谓返工。\n3、有用来衡量某项工作是否完成的客观标准。\n4、具有指导软件团队或团队结构变更的文档。\n而基于Axure进行设计再推动职能团队完成功能开发的模式，看似满足了上述目标，避免了过度的需求文档造成的浪费、也能够很好的解释用户需求，但是却更关注于用户交互过程、无法涉及面子之下的里子、返工和功能维护让需求的验证过程变得越来越不可控，终输出的软件产品，顶多只能算一个花里胡哨的绣花枕头而已。\n由于软件产品每周都要交付，作者认为，比较合理的解决方案应该带来如下好处：\n1、避免过度说明需求从而产生浪费，避免花时间在开发前会发生改变的细节上。\n2、有一种可靠的文档，可以解释系统的行为，据此我们可以很容易的修改系统行为。\n3、可以有效地检查系统行为与需求说明的描述是否一致。\n4、以最小的维护成本维护文档的相关性和可靠性。\n5、适合短迭代和基于流的过程，这样能为即将开展的工作提供技术足够的信息。 \n这也是实例化说明渴望达到的目的，作者对许多企业进行了访谈，总结了实例化需求的应用案例，他认为通过引入实例化需求可以达到以下收益。。\n1、更有效的实施变更。作者将其中的最重要的经验称为活文档（living documentation）的广泛应用是有长期受益的。这本书广泛涵盖了这一部分的内容。文中如是说\n>**“活文档是系统功能的一个信息源，它与程序代码一样可靠，但易于使用和理解。它能帮助团队共同分析变更所带来的影响并讨论潜在的方案。团队还可以为新的需求扩展已有的文档，长此以往，可以使得需求说明和实施变更更有效。”**\n\n2、更高的产品质量。由于预期明确，验证变得更有效率。\n3、更少的返工。由于需求写作更好，使团队确保对预期达成共识。\n4、同一项目不同角色的活动协调得更好。改善写作形成定期的交付流程。\n# 关键过程模式\n作者总结了在实施实例化需求中的一些关键过程模式：\n1、从目标中获取范围。许多软件在开始之前，期望由客户、产品负责人、商业用户来确定工作的范围，而商业用户明确他们的需求之后，软件交付团队就依次实现，但是由于用户不是专业的软件设计师，因此他提出的需求，固然是他所要求的，但并非是他真正需要的。所以关键模式就是从目标中获取需求，用户专注于传达所需功能希望达到的目的和期望由此带来的价值，而交付团队则致力于提出解决方案。\n2、协作需求。不依赖于个人去收集正确的需求，而是与商业用户一起协作指定解决方案，这可以让我们充分利用团队的知识和经验，还创造了需求的集体所有制，让每个人都能参与到交付过程中。\n3、举例说明。在编程语言实现过程中，成功的团队不会等待需求被精准表述，而是举例说明需求。用一些额外的实例用于说明边界情况，或重点标识出系统中某些特别有问题的地方，这样可以清楚功能分歧和不一致的地方，避免由误解或解释不到位导致的返工。\n4、提炼需求。关键实例必须精简才有用，通过移除多余信息并为开发和测试过程创建一个具体、精确的上下文。软件的目标是该做什么，而不是该怎么做。\n5、自动化验证时，不改变需求说明。\n6、频繁验证。通过频繁验证，团队可以快速发现系统与需求说明之间的任何差别。团队成员可以更好的与用户交流，并决定如何处理。他们可以不断地同步系统和可执行的需求说明。\n7、演化成活文档系统。活文档系统告诉系统可以做什么，并与代码一起确切可靠，但具有更好的可读性。 \n# 问题思考\n\n这本书与其他介绍软件理论的书籍一样，知识量比较稠密，阅读过程中花费了不少时间，如豆瓣上有网友说的：\n>**读一本书，如果能给你带来一点感悟，那就赚回书钱了。如果带给你两三点感悟，花费的时间也就值了。如果带给你五六点，甚至七八点，那就可以为作者捐款以示感谢了。****。**\n\n这本书也是大概如此，书的重点其实是引入行为驱动开发（BDD），并让需求变得可执行的过程，让这套方法论实践起来大概需要花费更长的时间，但是也可以成为软件设计者们思考的一个方向。\n个人认为，引入Cucumber这样的自动化测试工具，使用行为驱动设计的方法进行软件需求的描述编写活文档、然后再将其引入到测试过程中，或许有点难，但是也可以尝试使用这样的分析方法来设计我们的需求。\n尤其是当需求不明确的时候，如果使用原型分析法或其他描述方法来定义需求，往往可能不够具体，则可以考虑使用图表或实际例子来描述，并创造性的给角色取一些花名，可以让需求的描述过程变得更加的生动。\n\n---\n1、《[https://www.infoq.cn/article/specification-by-example-book/](https://www.infoq.cn/article/specification-by-example-book/)》《实例化需求》采访与书评。\n\n\n","slug":"读书/《实例化需求》读书笔记","published":1,"updated":"2019-10-09T11:08:01.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt8f002fn4vi3vzeit6m","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a><strong>背景</strong></h1><p>一直以来我都是从事软件研发、兼顾项目管理工作，在项目开发中，总是会遇到一些各种各样的问题，我也曾试图在项目中推动过类似于敏捷这样的项目管理方法，但是最终却收效不大。随着我工作经验的逐渐累积，发现不同的项目、不管是敏捷还是非敏捷、不管是如何失败的，其中对于用户需求的把控都是一个非常关键的因素。</p>\n<blockquote>\n<p><strong>用户需求，就是笼子里的狮子，你不放出来，受伤的是狮子，你放出来，受伤的是你自己。</strong></p>\n</blockquote>\n<p>在项目过程中，我们倾向于输出一份沉甸甸的需求文档，但是这份需求文档等项目做完了，往往会过时而用处不大。由于无穷次变更或开发者们对于需求的理解层次不同，设计业务领域的项目经理，显然不可能对软件的实现部分进行全方位的掌控，对于一些比较大的项目，掌握全局就已经很不错了，更不用说代码了，然而一切业务都凝聚在代码中，这些代码是如何实现用户需求的？<br>—-<strong>取决于开发者的经验，科学表明，一切靠经验来实现传承的知识体系，都是魔法。</strong></p>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>前段时间，我听张逸老师《领域驱动设计实践》课程中了解到《实例化需求》这本书，于是下单购买了，期待能获得一些启迪。<br>《实例化需求》是一本介绍软件工程方法论的书，这本书没有源代码、也没有特定工具的使用说明。在这本书中，他收集了来自现实世界、真实的团队以及切实的经验，同时也引入了一些建议，他希望通过这本书能够帮助大家使用这些组织过程或模式去建立活文档系统，从而提高软件项目的可控性。<br>在传统的项目开发中，尚且可以要求每个产品持续很长的时间，例如，一般都是以月为单位，甚至以年为单位。但是在互联网开发中，交付时间往往被压缩到一周为单位、甚至以天为单位，所以大量的前期软件设计和详细的需求分析环节将不复存在，而且传统的手工测试也耗时漫长，也被更加科学的自动化测试所替代。在这样的背景下，文档随时会过时，因此使用Axure原型软件设计高保真的UI交互原型是普遍的选择，如果有需求变更，就对原型进行修改，然后再通过原型推动功能的变更。<br>在作者的官方网站上，他认为《实例化需求》是一组过程模式，可以协助软件产品的变更，确保有效地交付正确的产品。 这里所说的正确产品，指的是该软件能满足客户或企业用户提出的商业需求，或者能达成预定的商业目标；同时它要具备一定的灵活性，未来能以相对平稳的投入接受后续改进。<br>作者认为，要有效的构建正确的产品，传统的软件开发实践首先需要满足一下几点：<br>1、保证所有项目干系人和交付团队的成员都对需要交付哪些东西有一致的理解。<br>2、有准确的需求说明，这样交付团队才避免有模棱两可和功能缺失造成的无谓返工。<br>3、有用来衡量某项工作是否完成的客观标准。<br>4、具有指导软件团队或团队结构变更的文档。<br>而基于Axure进行设计再推动职能团队完成功能开发的模式，看似满足了上述目标，避免了过度的需求文档造成的浪费、也能够很好的解释用户需求，但是却更关注于用户交互过程、无法涉及面子之下的里子、返工和功能维护让需求的验证过程变得越来越不可控，终输出的软件产品，顶多只能算一个花里胡哨的绣花枕头而已。<br>由于软件产品每周都要交付，作者认为，比较合理的解决方案应该带来如下好处：<br>1、避免过度说明需求从而产生浪费，避免花时间在开发前会发生改变的细节上。<br>2、有一种可靠的文档，可以解释系统的行为，据此我们可以很容易的修改系统行为。<br>3、可以有效地检查系统行为与需求说明的描述是否一致。<br>4、以最小的维护成本维护文档的相关性和可靠性。<br>5、适合短迭代和基于流的过程，这样能为即将开展的工作提供技术足够的信息。<br>这也是实例化说明渴望达到的目的，作者对许多企业进行了访谈，总结了实例化需求的应用案例，他认为通过引入实例化需求可以达到以下收益。。<br>1、更有效的实施变更。作者将其中的最重要的经验称为活文档（living documentation）的广泛应用是有长期受益的。这本书广泛涵盖了这一部分的内容。文中如是说</p>\n<blockquote>\n<p><strong>“活文档是系统功能的一个信息源，它与程序代码一样可靠，但易于使用和理解。它能帮助团队共同分析变更所带来的影响并讨论潜在的方案。团队还可以为新的需求扩展已有的文档，长此以往，可以使得需求说明和实施变更更有效。”</strong></p>\n</blockquote>\n<p>2、更高的产品质量。由于预期明确，验证变得更有效率。<br>3、更少的返工。由于需求写作更好，使团队确保对预期达成共识。<br>4、同一项目不同角色的活动协调得更好。改善写作形成定期的交付流程。</p>\n<h1 id=\"关键过程模式\"><a href=\"#关键过程模式\" class=\"headerlink\" title=\"关键过程模式\"></a>关键过程模式</h1><p>作者总结了在实施实例化需求中的一些关键过程模式：<br>1、从目标中获取范围。许多软件在开始之前，期望由客户、产品负责人、商业用户来确定工作的范围，而商业用户明确他们的需求之后，软件交付团队就依次实现，但是由于用户不是专业的软件设计师，因此他提出的需求，固然是他所要求的，但并非是他真正需要的。所以关键模式就是从目标中获取需求，用户专注于传达所需功能希望达到的目的和期望由此带来的价值，而交付团队则致力于提出解决方案。<br>2、协作需求。不依赖于个人去收集正确的需求，而是与商业用户一起协作指定解决方案，这可以让我们充分利用团队的知识和经验，还创造了需求的集体所有制，让每个人都能参与到交付过程中。<br>3、举例说明。在编程语言实现过程中，成功的团队不会等待需求被精准表述，而是举例说明需求。用一些额外的实例用于说明边界情况，或重点标识出系统中某些特别有问题的地方，这样可以清楚功能分歧和不一致的地方，避免由误解或解释不到位导致的返工。<br>4、提炼需求。关键实例必须精简才有用，通过移除多余信息并为开发和测试过程创建一个具体、精确的上下文。软件的目标是该做什么，而不是该怎么做。<br>5、自动化验证时，不改变需求说明。<br>6、频繁验证。通过频繁验证，团队可以快速发现系统与需求说明之间的任何差别。团队成员可以更好的与用户交流，并决定如何处理。他们可以不断地同步系统和可执行的需求说明。<br>7、演化成活文档系统。活文档系统告诉系统可以做什么，并与代码一起确切可靠，但具有更好的可读性。 </p>\n<h1 id=\"问题思考\"><a href=\"#问题思考\" class=\"headerlink\" title=\"问题思考\"></a>问题思考</h1><p>这本书与其他介绍软件理论的书籍一样，知识量比较稠密，阅读过程中花费了不少时间，如豆瓣上有网友说的：</p>\n<blockquote>\n<p><strong>读一本书，如果能给你带来一点感悟，那就赚回书钱了。如果带给你两三点感悟，花费的时间也就值了。如果带给你五六点，甚至七八点，那就可以为作者捐款以示感谢了。**</strong>。**</p>\n</blockquote>\n<p>这本书也是大概如此，书的重点其实是引入行为驱动开发（BDD），并让需求变得可执行的过程，让这套方法论实践起来大概需要花费更长的时间，但是也可以成为软件设计者们思考的一个方向。<br>个人认为，引入Cucumber这样的自动化测试工具，使用行为驱动设计的方法进行软件需求的描述编写活文档、然后再将其引入到测试过程中，或许有点难，但是也可以尝试使用这样的分析方法来设计我们的需求。<br>尤其是当需求不明确的时候，如果使用原型分析法或其他描述方法来定义需求，往往可能不够具体，则可以考虑使用图表或实际例子来描述，并创造性的给角色取一些花名，可以让需求的描述过程变得更加的生动。</p>\n<hr>\n<p>1、《<a href=\"https://www.infoq.cn/article/specification-by-example-book/\" target=\"_blank\" rel=\"noopener\">https://www.infoq.cn/article/specification-by-example-book/</a>》《实例化需求》采访与书评。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a><strong>背景</strong></h1><p>一直以来我都是从事软件研发、兼顾项目管理工作，在项目开发中，总是会遇到一些各种各样的问题，我也曾试图在项目中推动过类似于敏捷这样的项目管理方法，但是最终却收效不大。随着我工作经验的逐渐累积，发现不同的项目、不管是敏捷还是非敏捷、不管是如何失败的，其中对于用户需求的把控都是一个非常关键的因素。</p>\n<blockquote>\n<p><strong>用户需求，就是笼子里的狮子，你不放出来，受伤的是狮子，你放出来，受伤的是你自己。</strong></p>\n</blockquote>\n<p>在项目过程中，我们倾向于输出一份沉甸甸的需求文档，但是这份需求文档等项目做完了，往往会过时而用处不大。由于无穷次变更或开发者们对于需求的理解层次不同，设计业务领域的项目经理，显然不可能对软件的实现部分进行全方位的掌控，对于一些比较大的项目，掌握全局就已经很不错了，更不用说代码了，然而一切业务都凝聚在代码中，这些代码是如何实现用户需求的？<br>—-<strong>取决于开发者的经验，科学表明，一切靠经验来实现传承的知识体系，都是魔法。</strong></p>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>前段时间，我听张逸老师《领域驱动设计实践》课程中了解到《实例化需求》这本书，于是下单购买了，期待能获得一些启迪。<br>《实例化需求》是一本介绍软件工程方法论的书，这本书没有源代码、也没有特定工具的使用说明。在这本书中，他收集了来自现实世界、真实的团队以及切实的经验，同时也引入了一些建议，他希望通过这本书能够帮助大家使用这些组织过程或模式去建立活文档系统，从而提高软件项目的可控性。<br>在传统的项目开发中，尚且可以要求每个产品持续很长的时间，例如，一般都是以月为单位，甚至以年为单位。但是在互联网开发中，交付时间往往被压缩到一周为单位、甚至以天为单位，所以大量的前期软件设计和详细的需求分析环节将不复存在，而且传统的手工测试也耗时漫长，也被更加科学的自动化测试所替代。在这样的背景下，文档随时会过时，因此使用Axure原型软件设计高保真的UI交互原型是普遍的选择，如果有需求变更，就对原型进行修改，然后再通过原型推动功能的变更。<br>在作者的官方网站上，他认为《实例化需求》是一组过程模式，可以协助软件产品的变更，确保有效地交付正确的产品。 这里所说的正确产品，指的是该软件能满足客户或企业用户提出的商业需求，或者能达成预定的商业目标；同时它要具备一定的灵活性，未来能以相对平稳的投入接受后续改进。<br>作者认为，要有效的构建正确的产品，传统的软件开发实践首先需要满足一下几点：<br>1、保证所有项目干系人和交付团队的成员都对需要交付哪些东西有一致的理解。<br>2、有准确的需求说明，这样交付团队才避免有模棱两可和功能缺失造成的无谓返工。<br>3、有用来衡量某项工作是否完成的客观标准。<br>4、具有指导软件团队或团队结构变更的文档。<br>而基于Axure进行设计再推动职能团队完成功能开发的模式，看似满足了上述目标，避免了过度的需求文档造成的浪费、也能够很好的解释用户需求，但是却更关注于用户交互过程、无法涉及面子之下的里子、返工和功能维护让需求的验证过程变得越来越不可控，终输出的软件产品，顶多只能算一个花里胡哨的绣花枕头而已。<br>由于软件产品每周都要交付，作者认为，比较合理的解决方案应该带来如下好处：<br>1、避免过度说明需求从而产生浪费，避免花时间在开发前会发生改变的细节上。<br>2、有一种可靠的文档，可以解释系统的行为，据此我们可以很容易的修改系统行为。<br>3、可以有效地检查系统行为与需求说明的描述是否一致。<br>4、以最小的维护成本维护文档的相关性和可靠性。<br>5、适合短迭代和基于流的过程，这样能为即将开展的工作提供技术足够的信息。<br>这也是实例化说明渴望达到的目的，作者对许多企业进行了访谈，总结了实例化需求的应用案例，他认为通过引入实例化需求可以达到以下收益。。<br>1、更有效的实施变更。作者将其中的最重要的经验称为活文档（living documentation）的广泛应用是有长期受益的。这本书广泛涵盖了这一部分的内容。文中如是说</p>\n<blockquote>\n<p><strong>“活文档是系统功能的一个信息源，它与程序代码一样可靠，但易于使用和理解。它能帮助团队共同分析变更所带来的影响并讨论潜在的方案。团队还可以为新的需求扩展已有的文档，长此以往，可以使得需求说明和实施变更更有效。”</strong></p>\n</blockquote>\n<p>2、更高的产品质量。由于预期明确，验证变得更有效率。<br>3、更少的返工。由于需求写作更好，使团队确保对预期达成共识。<br>4、同一项目不同角色的活动协调得更好。改善写作形成定期的交付流程。</p>\n<h1 id=\"关键过程模式\"><a href=\"#关键过程模式\" class=\"headerlink\" title=\"关键过程模式\"></a>关键过程模式</h1><p>作者总结了在实施实例化需求中的一些关键过程模式：<br>1、从目标中获取范围。许多软件在开始之前，期望由客户、产品负责人、商业用户来确定工作的范围，而商业用户明确他们的需求之后，软件交付团队就依次实现，但是由于用户不是专业的软件设计师，因此他提出的需求，固然是他所要求的，但并非是他真正需要的。所以关键模式就是从目标中获取需求，用户专注于传达所需功能希望达到的目的和期望由此带来的价值，而交付团队则致力于提出解决方案。<br>2、协作需求。不依赖于个人去收集正确的需求，而是与商业用户一起协作指定解决方案，这可以让我们充分利用团队的知识和经验，还创造了需求的集体所有制，让每个人都能参与到交付过程中。<br>3、举例说明。在编程语言实现过程中，成功的团队不会等待需求被精准表述，而是举例说明需求。用一些额外的实例用于说明边界情况，或重点标识出系统中某些特别有问题的地方，这样可以清楚功能分歧和不一致的地方，避免由误解或解释不到位导致的返工。<br>4、提炼需求。关键实例必须精简才有用，通过移除多余信息并为开发和测试过程创建一个具体、精确的上下文。软件的目标是该做什么，而不是该怎么做。<br>5、自动化验证时，不改变需求说明。<br>6、频繁验证。通过频繁验证，团队可以快速发现系统与需求说明之间的任何差别。团队成员可以更好的与用户交流，并决定如何处理。他们可以不断地同步系统和可执行的需求说明。<br>7、演化成活文档系统。活文档系统告诉系统可以做什么，并与代码一起确切可靠，但具有更好的可读性。 </p>\n<h1 id=\"问题思考\"><a href=\"#问题思考\" class=\"headerlink\" title=\"问题思考\"></a>问题思考</h1><p>这本书与其他介绍软件理论的书籍一样，知识量比较稠密，阅读过程中花费了不少时间，如豆瓣上有网友说的：</p>\n<blockquote>\n<p><strong>读一本书，如果能给你带来一点感悟，那就赚回书钱了。如果带给你两三点感悟，花费的时间也就值了。如果带给你五六点，甚至七八点，那就可以为作者捐款以示感谢了。**</strong>。**</p>\n</blockquote>\n<p>这本书也是大概如此，书的重点其实是引入行为驱动开发（BDD），并让需求变得可执行的过程，让这套方法论实践起来大概需要花费更长的时间，但是也可以成为软件设计者们思考的一个方向。<br>个人认为，引入Cucumber这样的自动化测试工具，使用行为驱动设计的方法进行软件需求的描述编写活文档、然后再将其引入到测试过程中，或许有点难，但是也可以尝试使用这样的分析方法来设计我们的需求。<br>尤其是当需求不明确的时候，如果使用原型分析法或其他描述方法来定义需求，往往可能不够具体，则可以考虑使用图表或实际例子来描述，并创造性的给角色取一些花名，可以让需求的描述过程变得更加的生动。</p>\n<hr>\n<p>1、《<a href=\"https://www.infoq.cn/article/specification-by-example-book/\" target=\"_blank\" rel=\"noopener\">https://www.infoq.cn/article/specification-by-example-book/</a>》《实例化需求》采访与书评。</p>\n"},{"title":"《猎豹行动·硝烟中的敏捷转型之旅》读书笔记","date":"2019-10-09T08:28:00.000Z","author":"邹溪源","_content":"\n# 简介\n在9012年的今天，已经很少有人没有听过敏捷了。但敏捷真能解决这样的问题么？毫无疑问不太现实。毕竟中国式敏捷的笑话，也不是第一天出现在世人面前。许多公司都曾经实践过敏捷，却最终由于各种原因无法执行下去，水土不服是这些西方管理思想在国内最常见的问题。 \n而刘华老师也是在这样的背景下编写了这本书《猎豹行动·硝烟中的敏捷转型之旅》，这本书的出版在敏捷社区掀起了一番波澜。与其他介绍敏捷方法的书长篇阔论的介绍方法论不同，这本书以一个小说体的形式介绍了一个金融公司盛远金融的敏捷转型之旅，这一个个的小故事，既有受挫、又有成长，最终在这家企业中完成了转型，实现了劳动生产力的解放和软件研发实力的腾飞。\n这家企业是如何做的？让我们跟着作者的笔触一步步走进这一幕幕吧。  \n# 角色介绍\n作者引入了几个角色，分别是来自咨询公司的思域咨询公司的咨询顾问王章、曾经在某电商企业担任过管理层的盛远CTO思文、技术经理李俊、资深PMO关杰、项目总监张丽等主要角色。  \n* 王章：敏捷顾问，有丰富的敏捷实施经验，对新思维、新方法狂热。\n* 思文：公司敏捷的推动者，执行能力强，面对困难从不抱怨。\n* 李俊：IT部门经理，严谨、沉着，对新思维、新方法保持谨慎。\n* 关杰：部门利益捍卫者，对敏捷保持怀疑态度。\n* 张丽：敏锐、务实，思维严密。  \n\n李俊是一位经验丰富的技术管理者，对项目管理拥有丰富的经验。他总是善于制作严密的计划，并能做到很好的把控。在过去的职业生涯中， 他在客户和业务部门的口碑非常好，他一诺千金，总是能做到按时交付。但是在这背后，却是压榨得最为凶残。团队的流动性也非常大。他是一位瀑布模型的践行者，虽然听过敏捷的概念，但是却认为敏捷是在为不做计划和不写文档找借口。他认为项目成功的关键靠的是强大和严密的计划能力、项目跟进能力和沟通能力，并努力实现客户的承诺。在此之前，他也经历过组织变革，但是这些变革往往雷声大雨点小、要么与实际严重不符，最终并没有带来什么实际的好处。\n而作为敏捷顾问的王章，作为盛远金融敏捷转型的实践者，也充分得到了组织授权，感受到了思文对于敏捷的热忱，渴望在这家公司创造一番事业。事实上敏捷很容易获得基层的认可，不仅仅是因为敏捷不写文档，而是敏捷倡导组织间的相互信任、自治以及通过技术手段例如自动化测试来取代繁文缛节的文档。他很快就根据公司的实际情况建立了具体的启动方案，包括全面扫盲、体察民情、教育客户的三大步骤，并获得了思文的认可。  \n# 问题剖析\n随后，王章给全体IT同事进行了一次全面的培训，从以下四个角度介绍了敏捷转型的具体过程。\n* 从传统模式的问题（剖析瀑布模型的适应局限以及给业务部门和IT部门带来的痛点）、\n* 转向敏捷（什么是敏捷？它与瀑布模型最大的区别在哪里？具体方法和价值观是怎样的？）、\n* 实施敏捷的好处（包括对业务部门和IT部门的好处）、\n* 如何开始（具体的行动）\n\n在培训过程种，他也与大家一起总结了各部门的痛点，而在项目做的过程，根据业务部门的需求，虽然会给出估算和计划，但是在项目开始时，却只有预算和目标交付时间是确定的，很多因素都存在不确定性，包括：范围和具体需求、可能的需求变更、人员不可控、估算的准确性、对现有系统的影响、环境搭建等。  \n这些正是瀑布式模型带来的典型特点，事实上瀑布模型非常适合确定性非常高的项目，而这样的项目几乎是凤毛麟角。面对软件开发过程中的不确定性，需要采取措施管理和适应，真正实现“正确的做事”“做正确”的事。  \n随后的培训中，王章介绍了敏捷的价值观和方法论，获得了非常不错的反馈，大家都对实践敏捷的过程充满了期待。\n# 万事开头难\n作为一家金融科技的公司，对信息安全有着近乎洁癖的追求，因此工具的选型尤为重要，是选择商业软件，还是选择开源软件，往往都需要经历一番波澜。几经周折之后，选择了比较常用的敏捷管理工具，例如JIRA、Confluence、Github、Nexus、Jenkins、SonarQube、Ansible等工具。并建立了一套完整的DevOPS流程。\n随后开始挑选第一个实践项目，【信鸽】。这是一个计划工期为8个月的项目，但是由于公司项目的典型特点，需要由PMO进行需求调研和业务分析，等来到李俊的项目研发团队手中，已经只剩下六个月的时间。而李俊这边由于项目的特殊性，已经腾不出额外的资源，最终只能招聘到一位临时软件工程师，事实上这时已经只剩下不到五个月的时间。\n但是这个项目依然没办法按照敏捷的流程拆分迭代周期，主要是由于项目的需求文档由许多个条目组成，每个条目就是一个功能，但是仅仅按照功能进行拆分，几乎无法独立开发、测试和上线交付事实上拆分出来的东西，单个部署都没有业务价值。而且前期采用瀑布模型进行需求、设计而后面的开发、采用敏捷，最后的测试采用瀑布模型，显然这样的效益确实有限。\n最终这个项目只能采用瀑布模型继续开发。需求文档的完成和签署花了三个月，然后在花一个月涉及外部文档，两个月开发、一个月完成测试，一个月用户验收测试，然后上线，正好赶上8个月的时间。\n然而现实是残酷的，最终项目延期三个月结束。\n# 越挫越勇\n虽然经历了一轮挫折，但是却并未让年轻的咨询师就此放弃，他想起了曾经学习了解过的极限编程，同时又引入了kanban的精益软件管理的工具，然后将其引入到项目中。然后让李俊的项目团队采用看板的来跟进新功能需求的研发和流程的日常优化。\n而随着日常流程优化这种常规功能的研发的逐渐开展，也让团队成员对于敏捷有了更深刻的认识，在新项目开发过程中，李俊的研发团队将Scrum引入其中，完成了一次原本看起来不可拆分、不可妥协的功能开发，并获得了公司高管的认可。\n在后面的项目研发过程中，又经历了几次不同的挑战，但是也让敏捷的产品研发过程逐渐在公司生根发芽，逐渐发展状态，最终成为公司的常态管理形式。\n\n# 总结\n成功的项目千篇一律，失败的项目各有不同。\n无论是互联网公司还是传统的软件公司，为了创造独特的产品、服务或成果而发起各种不同的形式的项目是行业的普遍选择。\n如果说项目的成功与否，取决于组织的管理形式本身，实际上也取决于项目经理对项目的掌控力。优秀的项目经理不仅具备的优秀的专业技能、行业知识和软实力，让他能够灵活的驾驭各种不同类型的项目还能游刃有余，而普通型项目经理却往往耗费了大量资源，最终还会让项目陷入一座又一座的泥坑不可自拔。\n对于软件研发型项目经理来说，选择合适的开发模型，似乎是首要考虑的问题。当然，毫无疑问，最为深入人心的项目开发流程，莫过于瀑布式模型。这是一种种增量式开发模式，历经从计划=》需求分析=》软件设计=》软件编码=》软件测试=》软件部署=》软件验收的各个环节。各个环节间既相互依赖，又可能相互迭代。\n![图片](https://uploader.shimo.im/f/g9X4CZONnHE1Lukk.png!thumbnail)\n一环套一环，很更容易就陷入死循环的怪圈。例如，我们很容易就想到瀑布模型存在的以下缺点：\n1. 项目前期耗费大量的时间进行需求调研、编写了一大堆写完就过期的文档。\n2. 软件交付时，大量层出不穷的bug和需求变更。\n3. 客户对软件更改和研发的脑力支出并不认同等。\n\n我也经常听到项目经理们的吐槽。尤其从医疗行业的项目经理那里听到了最多的吐槽。在过去若干年的发展过程中，医疗信息化领域的发展特别快。但是由于医疗卫生行业涉及的领域太广，所以让标准化产品的研发过程变得非常困难，现在依然有许多医院的信息化系统都是以定制开发为主。而这些实施定制化开发软件的公司，承受的巨大压力常人难以想象。不同的院系、不同的医生对需求的不同理解或者各种需求上的变化，总是让开发者来回倒腾而无可自拔。上次就听说长沙某大型HIS企业的技术总监，为了给客户填坑，直接倒在了医院的办公室中，还好处理得当，不然还不知道会带来什么后果。\n除了HIS领域外，制造业甲方爸爸也擅长给乙方掘墓。他们的技能是甩锅。由于流程众多、涉及的人数广，所以要确认需求是一件非常困难的事情。这种情况下，除了绞尽脑汁应付其中，根本没有更好的办法。关键是他们中许多人还被免费软件的迷魂药给迷晕了头脑，总是认为软件开发不过是简单的码格子，肆意的扩大需求范围、更改需求，开发出大量华而不实的功能，让程序员们费力不讨好。 \n这些项目也是采用瀑布式开发模型的典型，试图通过前期严密的需求调研、功能设计和验收流程让客户尽可能少的变更需求，实际上却很难真正做到完全可控。所以项目很难避免不延迟，最终给公司带来了不小的负担。\n在这样的背景之下，似乎敏捷是一缕曙光。\n但究竟该怎么实施。这本书给出了一点参考。\n","source":"_posts/读书/《猎豹行动·硝烟中的敏捷转型之旅》有感.md","raw":"---\ntitle: 《猎豹行动·硝烟中的敏捷转型之旅》读书笔记\ndate: 2019-10-09 16:28\ntags: 读书\nauthor: 邹溪源\ncategories:\n  - 读书\n---\n\n# 简介\n在9012年的今天，已经很少有人没有听过敏捷了。但敏捷真能解决这样的问题么？毫无疑问不太现实。毕竟中国式敏捷的笑话，也不是第一天出现在世人面前。许多公司都曾经实践过敏捷，却最终由于各种原因无法执行下去，水土不服是这些西方管理思想在国内最常见的问题。 \n而刘华老师也是在这样的背景下编写了这本书《猎豹行动·硝烟中的敏捷转型之旅》，这本书的出版在敏捷社区掀起了一番波澜。与其他介绍敏捷方法的书长篇阔论的介绍方法论不同，这本书以一个小说体的形式介绍了一个金融公司盛远金融的敏捷转型之旅，这一个个的小故事，既有受挫、又有成长，最终在这家企业中完成了转型，实现了劳动生产力的解放和软件研发实力的腾飞。\n这家企业是如何做的？让我们跟着作者的笔触一步步走进这一幕幕吧。  \n# 角色介绍\n作者引入了几个角色，分别是来自咨询公司的思域咨询公司的咨询顾问王章、曾经在某电商企业担任过管理层的盛远CTO思文、技术经理李俊、资深PMO关杰、项目总监张丽等主要角色。  \n* 王章：敏捷顾问，有丰富的敏捷实施经验，对新思维、新方法狂热。\n* 思文：公司敏捷的推动者，执行能力强，面对困难从不抱怨。\n* 李俊：IT部门经理，严谨、沉着，对新思维、新方法保持谨慎。\n* 关杰：部门利益捍卫者，对敏捷保持怀疑态度。\n* 张丽：敏锐、务实，思维严密。  \n\n李俊是一位经验丰富的技术管理者，对项目管理拥有丰富的经验。他总是善于制作严密的计划，并能做到很好的把控。在过去的职业生涯中， 他在客户和业务部门的口碑非常好，他一诺千金，总是能做到按时交付。但是在这背后，却是压榨得最为凶残。团队的流动性也非常大。他是一位瀑布模型的践行者，虽然听过敏捷的概念，但是却认为敏捷是在为不做计划和不写文档找借口。他认为项目成功的关键靠的是强大和严密的计划能力、项目跟进能力和沟通能力，并努力实现客户的承诺。在此之前，他也经历过组织变革，但是这些变革往往雷声大雨点小、要么与实际严重不符，最终并没有带来什么实际的好处。\n而作为敏捷顾问的王章，作为盛远金融敏捷转型的实践者，也充分得到了组织授权，感受到了思文对于敏捷的热忱，渴望在这家公司创造一番事业。事实上敏捷很容易获得基层的认可，不仅仅是因为敏捷不写文档，而是敏捷倡导组织间的相互信任、自治以及通过技术手段例如自动化测试来取代繁文缛节的文档。他很快就根据公司的实际情况建立了具体的启动方案，包括全面扫盲、体察民情、教育客户的三大步骤，并获得了思文的认可。  \n# 问题剖析\n随后，王章给全体IT同事进行了一次全面的培训，从以下四个角度介绍了敏捷转型的具体过程。\n* 从传统模式的问题（剖析瀑布模型的适应局限以及给业务部门和IT部门带来的痛点）、\n* 转向敏捷（什么是敏捷？它与瀑布模型最大的区别在哪里？具体方法和价值观是怎样的？）、\n* 实施敏捷的好处（包括对业务部门和IT部门的好处）、\n* 如何开始（具体的行动）\n\n在培训过程种，他也与大家一起总结了各部门的痛点，而在项目做的过程，根据业务部门的需求，虽然会给出估算和计划，但是在项目开始时，却只有预算和目标交付时间是确定的，很多因素都存在不确定性，包括：范围和具体需求、可能的需求变更、人员不可控、估算的准确性、对现有系统的影响、环境搭建等。  \n这些正是瀑布式模型带来的典型特点，事实上瀑布模型非常适合确定性非常高的项目，而这样的项目几乎是凤毛麟角。面对软件开发过程中的不确定性，需要采取措施管理和适应，真正实现“正确的做事”“做正确”的事。  \n随后的培训中，王章介绍了敏捷的价值观和方法论，获得了非常不错的反馈，大家都对实践敏捷的过程充满了期待。\n# 万事开头难\n作为一家金融科技的公司，对信息安全有着近乎洁癖的追求，因此工具的选型尤为重要，是选择商业软件，还是选择开源软件，往往都需要经历一番波澜。几经周折之后，选择了比较常用的敏捷管理工具，例如JIRA、Confluence、Github、Nexus、Jenkins、SonarQube、Ansible等工具。并建立了一套完整的DevOPS流程。\n随后开始挑选第一个实践项目，【信鸽】。这是一个计划工期为8个月的项目，但是由于公司项目的典型特点，需要由PMO进行需求调研和业务分析，等来到李俊的项目研发团队手中，已经只剩下六个月的时间。而李俊这边由于项目的特殊性，已经腾不出额外的资源，最终只能招聘到一位临时软件工程师，事实上这时已经只剩下不到五个月的时间。\n但是这个项目依然没办法按照敏捷的流程拆分迭代周期，主要是由于项目的需求文档由许多个条目组成，每个条目就是一个功能，但是仅仅按照功能进行拆分，几乎无法独立开发、测试和上线交付事实上拆分出来的东西，单个部署都没有业务价值。而且前期采用瀑布模型进行需求、设计而后面的开发、采用敏捷，最后的测试采用瀑布模型，显然这样的效益确实有限。\n最终这个项目只能采用瀑布模型继续开发。需求文档的完成和签署花了三个月，然后在花一个月涉及外部文档，两个月开发、一个月完成测试，一个月用户验收测试，然后上线，正好赶上8个月的时间。\n然而现实是残酷的，最终项目延期三个月结束。\n# 越挫越勇\n虽然经历了一轮挫折，但是却并未让年轻的咨询师就此放弃，他想起了曾经学习了解过的极限编程，同时又引入了kanban的精益软件管理的工具，然后将其引入到项目中。然后让李俊的项目团队采用看板的来跟进新功能需求的研发和流程的日常优化。\n而随着日常流程优化这种常规功能的研发的逐渐开展，也让团队成员对于敏捷有了更深刻的认识，在新项目开发过程中，李俊的研发团队将Scrum引入其中，完成了一次原本看起来不可拆分、不可妥协的功能开发，并获得了公司高管的认可。\n在后面的项目研发过程中，又经历了几次不同的挑战，但是也让敏捷的产品研发过程逐渐在公司生根发芽，逐渐发展状态，最终成为公司的常态管理形式。\n\n# 总结\n成功的项目千篇一律，失败的项目各有不同。\n无论是互联网公司还是传统的软件公司，为了创造独特的产品、服务或成果而发起各种不同的形式的项目是行业的普遍选择。\n如果说项目的成功与否，取决于组织的管理形式本身，实际上也取决于项目经理对项目的掌控力。优秀的项目经理不仅具备的优秀的专业技能、行业知识和软实力，让他能够灵活的驾驭各种不同类型的项目还能游刃有余，而普通型项目经理却往往耗费了大量资源，最终还会让项目陷入一座又一座的泥坑不可自拔。\n对于软件研发型项目经理来说，选择合适的开发模型，似乎是首要考虑的问题。当然，毫无疑问，最为深入人心的项目开发流程，莫过于瀑布式模型。这是一种种增量式开发模式，历经从计划=》需求分析=》软件设计=》软件编码=》软件测试=》软件部署=》软件验收的各个环节。各个环节间既相互依赖，又可能相互迭代。\n![图片](https://uploader.shimo.im/f/g9X4CZONnHE1Lukk.png!thumbnail)\n一环套一环，很更容易就陷入死循环的怪圈。例如，我们很容易就想到瀑布模型存在的以下缺点：\n1. 项目前期耗费大量的时间进行需求调研、编写了一大堆写完就过期的文档。\n2. 软件交付时，大量层出不穷的bug和需求变更。\n3. 客户对软件更改和研发的脑力支出并不认同等。\n\n我也经常听到项目经理们的吐槽。尤其从医疗行业的项目经理那里听到了最多的吐槽。在过去若干年的发展过程中，医疗信息化领域的发展特别快。但是由于医疗卫生行业涉及的领域太广，所以让标准化产品的研发过程变得非常困难，现在依然有许多医院的信息化系统都是以定制开发为主。而这些实施定制化开发软件的公司，承受的巨大压力常人难以想象。不同的院系、不同的医生对需求的不同理解或者各种需求上的变化，总是让开发者来回倒腾而无可自拔。上次就听说长沙某大型HIS企业的技术总监，为了给客户填坑，直接倒在了医院的办公室中，还好处理得当，不然还不知道会带来什么后果。\n除了HIS领域外，制造业甲方爸爸也擅长给乙方掘墓。他们的技能是甩锅。由于流程众多、涉及的人数广，所以要确认需求是一件非常困难的事情。这种情况下，除了绞尽脑汁应付其中，根本没有更好的办法。关键是他们中许多人还被免费软件的迷魂药给迷晕了头脑，总是认为软件开发不过是简单的码格子，肆意的扩大需求范围、更改需求，开发出大量华而不实的功能，让程序员们费力不讨好。 \n这些项目也是采用瀑布式开发模型的典型，试图通过前期严密的需求调研、功能设计和验收流程让客户尽可能少的变更需求，实际上却很难真正做到完全可控。所以项目很难避免不延迟，最终给公司带来了不小的负担。\n在这样的背景之下，似乎敏捷是一缕曙光。\n但究竟该怎么实施。这本书给出了一点参考。\n","slug":"读书/《猎豹行动·硝烟中的敏捷转型之旅》有感","published":1,"updated":"2019-10-09T10:47:18.369Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt8h002jn4vimt4y59hd","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>在9012年的今天，已经很少有人没有听过敏捷了。但敏捷真能解决这样的问题么？毫无疑问不太现实。毕竟中国式敏捷的笑话，也不是第一天出现在世人面前。许多公司都曾经实践过敏捷，却最终由于各种原因无法执行下去，水土不服是这些西方管理思想在国内最常见的问题。<br>而刘华老师也是在这样的背景下编写了这本书《猎豹行动·硝烟中的敏捷转型之旅》，这本书的出版在敏捷社区掀起了一番波澜。与其他介绍敏捷方法的书长篇阔论的介绍方法论不同，这本书以一个小说体的形式介绍了一个金融公司盛远金融的敏捷转型之旅，这一个个的小故事，既有受挫、又有成长，最终在这家企业中完成了转型，实现了劳动生产力的解放和软件研发实力的腾飞。<br>这家企业是如何做的？让我们跟着作者的笔触一步步走进这一幕幕吧。  </p>\n<h1 id=\"角色介绍\"><a href=\"#角色介绍\" class=\"headerlink\" title=\"角色介绍\"></a>角色介绍</h1><p>作者引入了几个角色，分别是来自咨询公司的思域咨询公司的咨询顾问王章、曾经在某电商企业担任过管理层的盛远CTO思文、技术经理李俊、资深PMO关杰、项目总监张丽等主要角色。  </p>\n<ul>\n<li>王章：敏捷顾问，有丰富的敏捷实施经验，对新思维、新方法狂热。</li>\n<li>思文：公司敏捷的推动者，执行能力强，面对困难从不抱怨。</li>\n<li>李俊：IT部门经理，严谨、沉着，对新思维、新方法保持谨慎。</li>\n<li>关杰：部门利益捍卫者，对敏捷保持怀疑态度。</li>\n<li>张丽：敏锐、务实，思维严密。  </li>\n</ul>\n<p>李俊是一位经验丰富的技术管理者，对项目管理拥有丰富的经验。他总是善于制作严密的计划，并能做到很好的把控。在过去的职业生涯中， 他在客户和业务部门的口碑非常好，他一诺千金，总是能做到按时交付。但是在这背后，却是压榨得最为凶残。团队的流动性也非常大。他是一位瀑布模型的践行者，虽然听过敏捷的概念，但是却认为敏捷是在为不做计划和不写文档找借口。他认为项目成功的关键靠的是强大和严密的计划能力、项目跟进能力和沟通能力，并努力实现客户的承诺。在此之前，他也经历过组织变革，但是这些变革往往雷声大雨点小、要么与实际严重不符，最终并没有带来什么实际的好处。<br>而作为敏捷顾问的王章，作为盛远金融敏捷转型的实践者，也充分得到了组织授权，感受到了思文对于敏捷的热忱，渴望在这家公司创造一番事业。事实上敏捷很容易获得基层的认可，不仅仅是因为敏捷不写文档，而是敏捷倡导组织间的相互信任、自治以及通过技术手段例如自动化测试来取代繁文缛节的文档。他很快就根据公司的实际情况建立了具体的启动方案，包括全面扫盲、体察民情、教育客户的三大步骤，并获得了思文的认可。  </p>\n<h1 id=\"问题剖析\"><a href=\"#问题剖析\" class=\"headerlink\" title=\"问题剖析\"></a>问题剖析</h1><p>随后，王章给全体IT同事进行了一次全面的培训，从以下四个角度介绍了敏捷转型的具体过程。</p>\n<ul>\n<li>从传统模式的问题（剖析瀑布模型的适应局限以及给业务部门和IT部门带来的痛点）、</li>\n<li>转向敏捷（什么是敏捷？它与瀑布模型最大的区别在哪里？具体方法和价值观是怎样的？）、</li>\n<li>实施敏捷的好处（包括对业务部门和IT部门的好处）、</li>\n<li>如何开始（具体的行动）</li>\n</ul>\n<p>在培训过程种，他也与大家一起总结了各部门的痛点，而在项目做的过程，根据业务部门的需求，虽然会给出估算和计划，但是在项目开始时，却只有预算和目标交付时间是确定的，很多因素都存在不确定性，包括：范围和具体需求、可能的需求变更、人员不可控、估算的准确性、对现有系统的影响、环境搭建等。<br>这些正是瀑布式模型带来的典型特点，事实上瀑布模型非常适合确定性非常高的项目，而这样的项目几乎是凤毛麟角。面对软件开发过程中的不确定性，需要采取措施管理和适应，真正实现“正确的做事”“做正确”的事。<br>随后的培训中，王章介绍了敏捷的价值观和方法论，获得了非常不错的反馈，大家都对实践敏捷的过程充满了期待。</p>\n<h1 id=\"万事开头难\"><a href=\"#万事开头难\" class=\"headerlink\" title=\"万事开头难\"></a>万事开头难</h1><p>作为一家金融科技的公司，对信息安全有着近乎洁癖的追求，因此工具的选型尤为重要，是选择商业软件，还是选择开源软件，往往都需要经历一番波澜。几经周折之后，选择了比较常用的敏捷管理工具，例如JIRA、Confluence、Github、Nexus、Jenkins、SonarQube、Ansible等工具。并建立了一套完整的DevOPS流程。<br>随后开始挑选第一个实践项目，【信鸽】。这是一个计划工期为8个月的项目，但是由于公司项目的典型特点，需要由PMO进行需求调研和业务分析，等来到李俊的项目研发团队手中，已经只剩下六个月的时间。而李俊这边由于项目的特殊性，已经腾不出额外的资源，最终只能招聘到一位临时软件工程师，事实上这时已经只剩下不到五个月的时间。<br>但是这个项目依然没办法按照敏捷的流程拆分迭代周期，主要是由于项目的需求文档由许多个条目组成，每个条目就是一个功能，但是仅仅按照功能进行拆分，几乎无法独立开发、测试和上线交付事实上拆分出来的东西，单个部署都没有业务价值。而且前期采用瀑布模型进行需求、设计而后面的开发、采用敏捷，最后的测试采用瀑布模型，显然这样的效益确实有限。<br>最终这个项目只能采用瀑布模型继续开发。需求文档的完成和签署花了三个月，然后在花一个月涉及外部文档，两个月开发、一个月完成测试，一个月用户验收测试，然后上线，正好赶上8个月的时间。<br>然而现实是残酷的，最终项目延期三个月结束。</p>\n<h1 id=\"越挫越勇\"><a href=\"#越挫越勇\" class=\"headerlink\" title=\"越挫越勇\"></a>越挫越勇</h1><p>虽然经历了一轮挫折，但是却并未让年轻的咨询师就此放弃，他想起了曾经学习了解过的极限编程，同时又引入了kanban的精益软件管理的工具，然后将其引入到项目中。然后让李俊的项目团队采用看板的来跟进新功能需求的研发和流程的日常优化。<br>而随着日常流程优化这种常规功能的研发的逐渐开展，也让团队成员对于敏捷有了更深刻的认识，在新项目开发过程中，李俊的研发团队将Scrum引入其中，完成了一次原本看起来不可拆分、不可妥协的功能开发，并获得了公司高管的认可。<br>在后面的项目研发过程中，又经历了几次不同的挑战，但是也让敏捷的产品研发过程逐渐在公司生根发芽，逐渐发展状态，最终成为公司的常态管理形式。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>成功的项目千篇一律，失败的项目各有不同。<br>无论是互联网公司还是传统的软件公司，为了创造独特的产品、服务或成果而发起各种不同的形式的项目是行业的普遍选择。<br>如果说项目的成功与否，取决于组织的管理形式本身，实际上也取决于项目经理对项目的掌控力。优秀的项目经理不仅具备的优秀的专业技能、行业知识和软实力，让他能够灵活的驾驭各种不同类型的项目还能游刃有余，而普通型项目经理却往往耗费了大量资源，最终还会让项目陷入一座又一座的泥坑不可自拔。<br>对于软件研发型项目经理来说，选择合适的开发模型，似乎是首要考虑的问题。当然，毫无疑问，最为深入人心的项目开发流程，莫过于瀑布式模型。这是一种种增量式开发模式，历经从计划=》需求分析=》软件设计=》软件编码=》软件测试=》软件部署=》软件验收的各个环节。各个环节间既相互依赖，又可能相互迭代。<br><img src=\"https://uploader.shimo.im/f/g9X4CZONnHE1Lukk.png!thumbnail\" alt=\"图片\"><br>一环套一环，很更容易就陷入死循环的怪圈。例如，我们很容易就想到瀑布模型存在的以下缺点：</p>\n<ol>\n<li>项目前期耗费大量的时间进行需求调研、编写了一大堆写完就过期的文档。</li>\n<li>软件交付时，大量层出不穷的bug和需求变更。</li>\n<li>客户对软件更改和研发的脑力支出并不认同等。</li>\n</ol>\n<p>我也经常听到项目经理们的吐槽。尤其从医疗行业的项目经理那里听到了最多的吐槽。在过去若干年的发展过程中，医疗信息化领域的发展特别快。但是由于医疗卫生行业涉及的领域太广，所以让标准化产品的研发过程变得非常困难，现在依然有许多医院的信息化系统都是以定制开发为主。而这些实施定制化开发软件的公司，承受的巨大压力常人难以想象。不同的院系、不同的医生对需求的不同理解或者各种需求上的变化，总是让开发者来回倒腾而无可自拔。上次就听说长沙某大型HIS企业的技术总监，为了给客户填坑，直接倒在了医院的办公室中，还好处理得当，不然还不知道会带来什么后果。<br>除了HIS领域外，制造业甲方爸爸也擅长给乙方掘墓。他们的技能是甩锅。由于流程众多、涉及的人数广，所以要确认需求是一件非常困难的事情。这种情况下，除了绞尽脑汁应付其中，根本没有更好的办法。关键是他们中许多人还被免费软件的迷魂药给迷晕了头脑，总是认为软件开发不过是简单的码格子，肆意的扩大需求范围、更改需求，开发出大量华而不实的功能，让程序员们费力不讨好。<br>这些项目也是采用瀑布式开发模型的典型，试图通过前期严密的需求调研、功能设计和验收流程让客户尽可能少的变更需求，实际上却很难真正做到完全可控。所以项目很难避免不延迟，最终给公司带来了不小的负担。<br>在这样的背景之下，似乎敏捷是一缕曙光。<br>但究竟该怎么实施。这本书给出了一点参考。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>在9012年的今天，已经很少有人没有听过敏捷了。但敏捷真能解决这样的问题么？毫无疑问不太现实。毕竟中国式敏捷的笑话，也不是第一天出现在世人面前。许多公司都曾经实践过敏捷，却最终由于各种原因无法执行下去，水土不服是这些西方管理思想在国内最常见的问题。<br>而刘华老师也是在这样的背景下编写了这本书《猎豹行动·硝烟中的敏捷转型之旅》，这本书的出版在敏捷社区掀起了一番波澜。与其他介绍敏捷方法的书长篇阔论的介绍方法论不同，这本书以一个小说体的形式介绍了一个金融公司盛远金融的敏捷转型之旅，这一个个的小故事，既有受挫、又有成长，最终在这家企业中完成了转型，实现了劳动生产力的解放和软件研发实力的腾飞。<br>这家企业是如何做的？让我们跟着作者的笔触一步步走进这一幕幕吧。  </p>\n<h1 id=\"角色介绍\"><a href=\"#角色介绍\" class=\"headerlink\" title=\"角色介绍\"></a>角色介绍</h1><p>作者引入了几个角色，分别是来自咨询公司的思域咨询公司的咨询顾问王章、曾经在某电商企业担任过管理层的盛远CTO思文、技术经理李俊、资深PMO关杰、项目总监张丽等主要角色。  </p>\n<ul>\n<li>王章：敏捷顾问，有丰富的敏捷实施经验，对新思维、新方法狂热。</li>\n<li>思文：公司敏捷的推动者，执行能力强，面对困难从不抱怨。</li>\n<li>李俊：IT部门经理，严谨、沉着，对新思维、新方法保持谨慎。</li>\n<li>关杰：部门利益捍卫者，对敏捷保持怀疑态度。</li>\n<li>张丽：敏锐、务实，思维严密。  </li>\n</ul>\n<p>李俊是一位经验丰富的技术管理者，对项目管理拥有丰富的经验。他总是善于制作严密的计划，并能做到很好的把控。在过去的职业生涯中， 他在客户和业务部门的口碑非常好，他一诺千金，总是能做到按时交付。但是在这背后，却是压榨得最为凶残。团队的流动性也非常大。他是一位瀑布模型的践行者，虽然听过敏捷的概念，但是却认为敏捷是在为不做计划和不写文档找借口。他认为项目成功的关键靠的是强大和严密的计划能力、项目跟进能力和沟通能力，并努力实现客户的承诺。在此之前，他也经历过组织变革，但是这些变革往往雷声大雨点小、要么与实际严重不符，最终并没有带来什么实际的好处。<br>而作为敏捷顾问的王章，作为盛远金融敏捷转型的实践者，也充分得到了组织授权，感受到了思文对于敏捷的热忱，渴望在这家公司创造一番事业。事实上敏捷很容易获得基层的认可，不仅仅是因为敏捷不写文档，而是敏捷倡导组织间的相互信任、自治以及通过技术手段例如自动化测试来取代繁文缛节的文档。他很快就根据公司的实际情况建立了具体的启动方案，包括全面扫盲、体察民情、教育客户的三大步骤，并获得了思文的认可。  </p>\n<h1 id=\"问题剖析\"><a href=\"#问题剖析\" class=\"headerlink\" title=\"问题剖析\"></a>问题剖析</h1><p>随后，王章给全体IT同事进行了一次全面的培训，从以下四个角度介绍了敏捷转型的具体过程。</p>\n<ul>\n<li>从传统模式的问题（剖析瀑布模型的适应局限以及给业务部门和IT部门带来的痛点）、</li>\n<li>转向敏捷（什么是敏捷？它与瀑布模型最大的区别在哪里？具体方法和价值观是怎样的？）、</li>\n<li>实施敏捷的好处（包括对业务部门和IT部门的好处）、</li>\n<li>如何开始（具体的行动）</li>\n</ul>\n<p>在培训过程种，他也与大家一起总结了各部门的痛点，而在项目做的过程，根据业务部门的需求，虽然会给出估算和计划，但是在项目开始时，却只有预算和目标交付时间是确定的，很多因素都存在不确定性，包括：范围和具体需求、可能的需求变更、人员不可控、估算的准确性、对现有系统的影响、环境搭建等。<br>这些正是瀑布式模型带来的典型特点，事实上瀑布模型非常适合确定性非常高的项目，而这样的项目几乎是凤毛麟角。面对软件开发过程中的不确定性，需要采取措施管理和适应，真正实现“正确的做事”“做正确”的事。<br>随后的培训中，王章介绍了敏捷的价值观和方法论，获得了非常不错的反馈，大家都对实践敏捷的过程充满了期待。</p>\n<h1 id=\"万事开头难\"><a href=\"#万事开头难\" class=\"headerlink\" title=\"万事开头难\"></a>万事开头难</h1><p>作为一家金融科技的公司，对信息安全有着近乎洁癖的追求，因此工具的选型尤为重要，是选择商业软件，还是选择开源软件，往往都需要经历一番波澜。几经周折之后，选择了比较常用的敏捷管理工具，例如JIRA、Confluence、Github、Nexus、Jenkins、SonarQube、Ansible等工具。并建立了一套完整的DevOPS流程。<br>随后开始挑选第一个实践项目，【信鸽】。这是一个计划工期为8个月的项目，但是由于公司项目的典型特点，需要由PMO进行需求调研和业务分析，等来到李俊的项目研发团队手中，已经只剩下六个月的时间。而李俊这边由于项目的特殊性，已经腾不出额外的资源，最终只能招聘到一位临时软件工程师，事实上这时已经只剩下不到五个月的时间。<br>但是这个项目依然没办法按照敏捷的流程拆分迭代周期，主要是由于项目的需求文档由许多个条目组成，每个条目就是一个功能，但是仅仅按照功能进行拆分，几乎无法独立开发、测试和上线交付事实上拆分出来的东西，单个部署都没有业务价值。而且前期采用瀑布模型进行需求、设计而后面的开发、采用敏捷，最后的测试采用瀑布模型，显然这样的效益确实有限。<br>最终这个项目只能采用瀑布模型继续开发。需求文档的完成和签署花了三个月，然后在花一个月涉及外部文档，两个月开发、一个月完成测试，一个月用户验收测试，然后上线，正好赶上8个月的时间。<br>然而现实是残酷的，最终项目延期三个月结束。</p>\n<h1 id=\"越挫越勇\"><a href=\"#越挫越勇\" class=\"headerlink\" title=\"越挫越勇\"></a>越挫越勇</h1><p>虽然经历了一轮挫折，但是却并未让年轻的咨询师就此放弃，他想起了曾经学习了解过的极限编程，同时又引入了kanban的精益软件管理的工具，然后将其引入到项目中。然后让李俊的项目团队采用看板的来跟进新功能需求的研发和流程的日常优化。<br>而随着日常流程优化这种常规功能的研发的逐渐开展，也让团队成员对于敏捷有了更深刻的认识，在新项目开发过程中，李俊的研发团队将Scrum引入其中，完成了一次原本看起来不可拆分、不可妥协的功能开发，并获得了公司高管的认可。<br>在后面的项目研发过程中，又经历了几次不同的挑战，但是也让敏捷的产品研发过程逐渐在公司生根发芽，逐渐发展状态，最终成为公司的常态管理形式。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>成功的项目千篇一律，失败的项目各有不同。<br>无论是互联网公司还是传统的软件公司，为了创造独特的产品、服务或成果而发起各种不同的形式的项目是行业的普遍选择。<br>如果说项目的成功与否，取决于组织的管理形式本身，实际上也取决于项目经理对项目的掌控力。优秀的项目经理不仅具备的优秀的专业技能、行业知识和软实力，让他能够灵活的驾驭各种不同类型的项目还能游刃有余，而普通型项目经理却往往耗费了大量资源，最终还会让项目陷入一座又一座的泥坑不可自拔。<br>对于软件研发型项目经理来说，选择合适的开发模型，似乎是首要考虑的问题。当然，毫无疑问，最为深入人心的项目开发流程，莫过于瀑布式模型。这是一种种增量式开发模式，历经从计划=》需求分析=》软件设计=》软件编码=》软件测试=》软件部署=》软件验收的各个环节。各个环节间既相互依赖，又可能相互迭代。<br><img src=\"https://uploader.shimo.im/f/g9X4CZONnHE1Lukk.png!thumbnail\" alt=\"图片\"><br>一环套一环，很更容易就陷入死循环的怪圈。例如，我们很容易就想到瀑布模型存在的以下缺点：</p>\n<ol>\n<li>项目前期耗费大量的时间进行需求调研、编写了一大堆写完就过期的文档。</li>\n<li>软件交付时，大量层出不穷的bug和需求变更。</li>\n<li>客户对软件更改和研发的脑力支出并不认同等。</li>\n</ol>\n<p>我也经常听到项目经理们的吐槽。尤其从医疗行业的项目经理那里听到了最多的吐槽。在过去若干年的发展过程中，医疗信息化领域的发展特别快。但是由于医疗卫生行业涉及的领域太广，所以让标准化产品的研发过程变得非常困难，现在依然有许多医院的信息化系统都是以定制开发为主。而这些实施定制化开发软件的公司，承受的巨大压力常人难以想象。不同的院系、不同的医生对需求的不同理解或者各种需求上的变化，总是让开发者来回倒腾而无可自拔。上次就听说长沙某大型HIS企业的技术总监，为了给客户填坑，直接倒在了医院的办公室中，还好处理得当，不然还不知道会带来什么后果。<br>除了HIS领域外，制造业甲方爸爸也擅长给乙方掘墓。他们的技能是甩锅。由于流程众多、涉及的人数广，所以要确认需求是一件非常困难的事情。这种情况下，除了绞尽脑汁应付其中，根本没有更好的办法。关键是他们中许多人还被免费软件的迷魂药给迷晕了头脑，总是认为软件开发不过是简单的码格子，肆意的扩大需求范围、更改需求，开发出大量华而不实的功能，让程序员们费力不讨好。<br>这些项目也是采用瀑布式开发模型的典型，试图通过前期严密的需求调研、功能设计和验收流程让客户尽可能少的变更需求，实际上却很难真正做到完全可控。所以项目很难避免不延迟，最终给公司带来了不小的负担。<br>在这样的背景之下，似乎敏捷是一缕曙光。<br>但究竟该怎么实施。这本书给出了一点参考。</p>\n"},{"title":"《程序员的三门课》读书随想","date":"2019-12-15T13:28:00.000Z","author":"邹溪源","_content":"\n# 一  回顾我的职场体会\n我的职场生涯开始于十年前，一直在中小企业发展，未曾有幸到沿海那些高速发展的互联网公司工作，也就错过了互联网的大时代。\n\n但这不影响我的正常工作生活，事实上无论你身在何处，或在哪家公司，以各种title生存，我们都是在属于自己的职场道路上奋力拼搏，为了实现自己的人生梦想，我们需要付出的代价和努力，或许并不亚于我们的父辈。\n\n我们的父辈大部分都生于50后，60后，70后，成长于七零年代，八零年代，九零年代。他们的时代，是举国体制逐渐退潮，市场经济开始唱主角的时代，他们往往没那么多的学问，有时候得靠自己的勇气和双手才能改变自己的命运。而我们的时代，更多的得依靠自己的学问和知识领域来直面社会发展。互联网的大时代，汹涌澎湃如斯，浪花卷卷，看似卑微的小人物，同样也能在时代扮演不平凡的角色。\n\n事实上过去十年正是中国互联网产业飞速发展最为波澜壮阔的十年，哪怕从世界层面来说，也同样如此。中国的互联网本身就比美国晚了将近十年，但是凭借过去的十年，我们取得的飞速发展让我们得以跟美国看起来不相上下。\n\n当然，大时代的发展看似与我们大多数人关系不大，我们只是时代的见证者和受益人，而还有一些人，他们都积极的参与到其中，并为这个时代的发展起到了看似简单但也至关重要的作用。\n\n# 二 价值或没价值，其实不用争执\n我一贯认为围绕价值的争执毫无意义，毕竟每个人的评判标准截然不同，但不同的人大概目标是一致的，追求创造属于自己的价值，实现自己的梦想。当然，在时代的裹挟之下，大多数人都难以真正拥有自己的梦想。往往都是在本能的驱使下，选择工作，家庭，按部就班的工作，陪伴家庭逐渐的向未来前进。\n\n但这不影响我们可以设想一下我们应该拥有的一些共识，例如使命，价值观和文化。我觉得这三者是非常重要的东西，使命驱使我们前进，价值观促使我们拥有自己的原则，而文化是我们过去受到的家庭教育，学校教育和社会教育在灵魂上的投影。这些东西某种意义来说决定了我们的货币价值。\n\n为了提高货币价值，我们往往都得超越自我，去做一些在现在知识层面下难以实现的东西。\n\n一个人的知识领域，往往是知道得越多，越会感觉到自己的欠缺，在刚开始的时候或许是一个小圆圈，但是随着逐渐的学习，这个圆圈也越来越大。\n\n未知越多，潜力越大。每个人都是独一无二的个体，并在自己的舞台上努力表演，我们虽然难免需要妥协于生活，但是我们其实并不必莫名其妙的取悦于任何人。\n\n而社会中的每个个体都看似不一样，但往往也能够互相协作，互相支撑，每个人都有自己的职业分工，但总有工作交集的存在。这就意味着看似不一样的生活或工作，总能找到一些值得复用和思考的知识领域，这就需要我们放开心胸与其他人交流，从而使自己的精神更加饱满。\n\n# 三 写书和读书，是一种灵魂对话\n而写博客，写书或读书大概是最好的一种方式，作者把自己的成长故事和所思所感记下来，再借助书这种载体输出，既实现了自己知识的沉淀，又能将自己的知识领域向外播撒；\n\n读者可以花并不高的代价购买到来自于作者一手的知识分享，又能在书中寻找自己的存在，达到与作者的共鸣，这样的学习一定会让人获益非浅。\n\n在软件研发领域的许多知识，不像我们受到的教育一般，有些东西是有明显的对错之分的，像程序员成长，架构思维或管理模式，无论是哪种方式，总能实现我们的目标。\n\n我们中的大部分人的成长都大体一样，来源于某份工作或多份工作的自我学习，而不是靠真正的书本或教育，在社会中学习，大概如此。但是这样的东西难免有失节奏，不够系统，甚至要走特别多的弯路，吃很多亏。\n\n有时候我们会想知道，哪里可以获得系统的学习方法呢？\n\n# 四 这本书值得读的点\n一本《程序员的三门课》，或许能够给你带来思考。\n\n这本书没有试图像那些能够给我们带来直接收入的【21天学会xx技术】的书一样，能够迅速让我们迅速的学会新技术，他甚至有点像啰嗦的前辈一样，说了一些让人摸不着边际的东西。\n\n事实上书的作者恰好是亲历了互联网大时代的一波人，有阿里巴巴的技术大佬右军老师，李伟山老师，还有彭首长老师和刘朋老师，也有年轻如张洪亮的青年才俊，他们都致力于学习和为企业创造价值，他们事实上也颇有成就。他们都经历了职场的历练，无论是996甚至007，他们都是第一批冲杀在前线的斗士。他们不仅做事雷厉风行，他们更是喜欢思考人生的意义。\n\n他们都并非像这篇文章一样喜欢说啰嗦的话，他们把自己过去若干年的思考汇集在这本书中，目标是渴望给读者带来真正的收获。\n\n当你刚参加工作时，需要快速入门的书给你带来顿悟，但一旦稍微稳定下来，一定得站在更高的视角来规划一下自己的未来。编程技术，你可以快速的提升，而掌握这本书中的某些部分，你将有希望看破迷雾，不至于在职场面前过于迷茫。这些从工作中出发，提取自技术、思维模式和管理方法不同层面的知识，每一种都很有思考的意义。\n\n当然，看完这本书你甚至需要看更多的书，因为这本书他虽然凝淬了许多书的精华，但也是来源于本书作者对于知识的提炼，或许与原作者的原意稍有差别。在读完这本书之后，你或许将拥有一把去开启更多知识领域的钥匙。\n\n一本经典，往往能让你产生无尽思考；而一本好书，则会让你看破一些道理，甚至会觉得，原来这些其实就是这么回事啊。\n\n越是看起来简单的道理，越是需要花心思去揣摩才能体会。就像许多看似简单的技术实现，没有亲身经历的，都是“二手知识”。网上有许多的学习资料，尤其是当我们打开某些信息流app时，其实那是你的“信息茧房”，每天阅读这些内容，你会以为技术的获得是多么的轻易，但只有手把手写过一波，才能真正获得价值。而阿里巴巴和众多互联网公司们，花了十年时间做了那么多东西，一定是走了弯路，踩了许多坑才最终获得了最佳实践，而这些在这本书里都有所介绍。\n\n例如，如果你想在组织中建设一套质量管理体系，书中花了不少章节介绍了代码审查的方式和工具，以及代码审查清单的五个大方向和十六个小方向，这些能够从代码层面建立第一道防线；接着可以从架构体系做好第二层防线，例如分析架构质量的问题来源和解决策略，以及实现流程。这些几乎都是拿来就能应用的良好策略。\n\n对于程序员的快速成长，作者们都深有体会，例如积极主动的应对困难，以空杯的形态去看待学习，以及别怕犯错，这些都是良好的习惯，尤其要掌握学习方法，打破舒适区和终身成长，能够让我们更快的成长。\n\n如果初涉管理，作者们也介绍了他们的许多感受，包括做好准备，抓住机会，构建领导力，和高效的时间管理。尤其是时间管理，为什么同样都是996，作者们却不仅把代码写得很完美，还能有时间写那么多博客呢。团队培养，看起来简单却不简单，书里面也提到了许多措施。\n\n# 五 总结\n一本好书，能够给你带来一点思考，就已经足够了，如果让你获得了超过一点思考，那就是赚大了。\n\n冷静的阅读一下，你会有不一样的收获。这些都是你自己的收获，更是属于你自己的无穷财富。\n\n\n\n","source":"_posts/读书/《程序员的三门课》读书笔记.md","raw":"---\ntitle:  《程序员的三门课》读书随想\ndate: 2019-12-15 21:28\ntags: 读书\nauthor: 邹溪源\ncategories:\n  - 读书\n---\n\n# 一  回顾我的职场体会\n我的职场生涯开始于十年前，一直在中小企业发展，未曾有幸到沿海那些高速发展的互联网公司工作，也就错过了互联网的大时代。\n\n但这不影响我的正常工作生活，事实上无论你身在何处，或在哪家公司，以各种title生存，我们都是在属于自己的职场道路上奋力拼搏，为了实现自己的人生梦想，我们需要付出的代价和努力，或许并不亚于我们的父辈。\n\n我们的父辈大部分都生于50后，60后，70后，成长于七零年代，八零年代，九零年代。他们的时代，是举国体制逐渐退潮，市场经济开始唱主角的时代，他们往往没那么多的学问，有时候得靠自己的勇气和双手才能改变自己的命运。而我们的时代，更多的得依靠自己的学问和知识领域来直面社会发展。互联网的大时代，汹涌澎湃如斯，浪花卷卷，看似卑微的小人物，同样也能在时代扮演不平凡的角色。\n\n事实上过去十年正是中国互联网产业飞速发展最为波澜壮阔的十年，哪怕从世界层面来说，也同样如此。中国的互联网本身就比美国晚了将近十年，但是凭借过去的十年，我们取得的飞速发展让我们得以跟美国看起来不相上下。\n\n当然，大时代的发展看似与我们大多数人关系不大，我们只是时代的见证者和受益人，而还有一些人，他们都积极的参与到其中，并为这个时代的发展起到了看似简单但也至关重要的作用。\n\n# 二 价值或没价值，其实不用争执\n我一贯认为围绕价值的争执毫无意义，毕竟每个人的评判标准截然不同，但不同的人大概目标是一致的，追求创造属于自己的价值，实现自己的梦想。当然，在时代的裹挟之下，大多数人都难以真正拥有自己的梦想。往往都是在本能的驱使下，选择工作，家庭，按部就班的工作，陪伴家庭逐渐的向未来前进。\n\n但这不影响我们可以设想一下我们应该拥有的一些共识，例如使命，价值观和文化。我觉得这三者是非常重要的东西，使命驱使我们前进，价值观促使我们拥有自己的原则，而文化是我们过去受到的家庭教育，学校教育和社会教育在灵魂上的投影。这些东西某种意义来说决定了我们的货币价值。\n\n为了提高货币价值，我们往往都得超越自我，去做一些在现在知识层面下难以实现的东西。\n\n一个人的知识领域，往往是知道得越多，越会感觉到自己的欠缺，在刚开始的时候或许是一个小圆圈，但是随着逐渐的学习，这个圆圈也越来越大。\n\n未知越多，潜力越大。每个人都是独一无二的个体，并在自己的舞台上努力表演，我们虽然难免需要妥协于生活，但是我们其实并不必莫名其妙的取悦于任何人。\n\n而社会中的每个个体都看似不一样，但往往也能够互相协作，互相支撑，每个人都有自己的职业分工，但总有工作交集的存在。这就意味着看似不一样的生活或工作，总能找到一些值得复用和思考的知识领域，这就需要我们放开心胸与其他人交流，从而使自己的精神更加饱满。\n\n# 三 写书和读书，是一种灵魂对话\n而写博客，写书或读书大概是最好的一种方式，作者把自己的成长故事和所思所感记下来，再借助书这种载体输出，既实现了自己知识的沉淀，又能将自己的知识领域向外播撒；\n\n读者可以花并不高的代价购买到来自于作者一手的知识分享，又能在书中寻找自己的存在，达到与作者的共鸣，这样的学习一定会让人获益非浅。\n\n在软件研发领域的许多知识，不像我们受到的教育一般，有些东西是有明显的对错之分的，像程序员成长，架构思维或管理模式，无论是哪种方式，总能实现我们的目标。\n\n我们中的大部分人的成长都大体一样，来源于某份工作或多份工作的自我学习，而不是靠真正的书本或教育，在社会中学习，大概如此。但是这样的东西难免有失节奏，不够系统，甚至要走特别多的弯路，吃很多亏。\n\n有时候我们会想知道，哪里可以获得系统的学习方法呢？\n\n# 四 这本书值得读的点\n一本《程序员的三门课》，或许能够给你带来思考。\n\n这本书没有试图像那些能够给我们带来直接收入的【21天学会xx技术】的书一样，能够迅速让我们迅速的学会新技术，他甚至有点像啰嗦的前辈一样，说了一些让人摸不着边际的东西。\n\n事实上书的作者恰好是亲历了互联网大时代的一波人，有阿里巴巴的技术大佬右军老师，李伟山老师，还有彭首长老师和刘朋老师，也有年轻如张洪亮的青年才俊，他们都致力于学习和为企业创造价值，他们事实上也颇有成就。他们都经历了职场的历练，无论是996甚至007，他们都是第一批冲杀在前线的斗士。他们不仅做事雷厉风行，他们更是喜欢思考人生的意义。\n\n他们都并非像这篇文章一样喜欢说啰嗦的话，他们把自己过去若干年的思考汇集在这本书中，目标是渴望给读者带来真正的收获。\n\n当你刚参加工作时，需要快速入门的书给你带来顿悟，但一旦稍微稳定下来，一定得站在更高的视角来规划一下自己的未来。编程技术，你可以快速的提升，而掌握这本书中的某些部分，你将有希望看破迷雾，不至于在职场面前过于迷茫。这些从工作中出发，提取自技术、思维模式和管理方法不同层面的知识，每一种都很有思考的意义。\n\n当然，看完这本书你甚至需要看更多的书，因为这本书他虽然凝淬了许多书的精华，但也是来源于本书作者对于知识的提炼，或许与原作者的原意稍有差别。在读完这本书之后，你或许将拥有一把去开启更多知识领域的钥匙。\n\n一本经典，往往能让你产生无尽思考；而一本好书，则会让你看破一些道理，甚至会觉得，原来这些其实就是这么回事啊。\n\n越是看起来简单的道理，越是需要花心思去揣摩才能体会。就像许多看似简单的技术实现，没有亲身经历的，都是“二手知识”。网上有许多的学习资料，尤其是当我们打开某些信息流app时，其实那是你的“信息茧房”，每天阅读这些内容，你会以为技术的获得是多么的轻易，但只有手把手写过一波，才能真正获得价值。而阿里巴巴和众多互联网公司们，花了十年时间做了那么多东西，一定是走了弯路，踩了许多坑才最终获得了最佳实践，而这些在这本书里都有所介绍。\n\n例如，如果你想在组织中建设一套质量管理体系，书中花了不少章节介绍了代码审查的方式和工具，以及代码审查清单的五个大方向和十六个小方向，这些能够从代码层面建立第一道防线；接着可以从架构体系做好第二层防线，例如分析架构质量的问题来源和解决策略，以及实现流程。这些几乎都是拿来就能应用的良好策略。\n\n对于程序员的快速成长，作者们都深有体会，例如积极主动的应对困难，以空杯的形态去看待学习，以及别怕犯错，这些都是良好的习惯，尤其要掌握学习方法，打破舒适区和终身成长，能够让我们更快的成长。\n\n如果初涉管理，作者们也介绍了他们的许多感受，包括做好准备，抓住机会，构建领导力，和高效的时间管理。尤其是时间管理，为什么同样都是996，作者们却不仅把代码写得很完美，还能有时间写那么多博客呢。团队培养，看起来简单却不简单，书里面也提到了许多措施。\n\n# 五 总结\n一本好书，能够给你带来一点思考，就已经足够了，如果让你获得了超过一点思考，那就是赚大了。\n\n冷静的阅读一下，你会有不一样的收获。这些都是你自己的收获，更是属于你自己的无穷财富。\n\n\n\n","slug":"读书/《程序员的三门课》读书笔记","published":1,"updated":"2019-12-18T00:33:40.529Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt8i002mn4vidsbwtzmc","content":"<h1 id=\"一-回顾我的职场体会\"><a href=\"#一-回顾我的职场体会\" class=\"headerlink\" title=\"一  回顾我的职场体会\"></a>一  回顾我的职场体会</h1><p>我的职场生涯开始于十年前，一直在中小企业发展，未曾有幸到沿海那些高速发展的互联网公司工作，也就错过了互联网的大时代。</p>\n<p>但这不影响我的正常工作生活，事实上无论你身在何处，或在哪家公司，以各种title生存，我们都是在属于自己的职场道路上奋力拼搏，为了实现自己的人生梦想，我们需要付出的代价和努力，或许并不亚于我们的父辈。</p>\n<p>我们的父辈大部分都生于50后，60后，70后，成长于七零年代，八零年代，九零年代。他们的时代，是举国体制逐渐退潮，市场经济开始唱主角的时代，他们往往没那么多的学问，有时候得靠自己的勇气和双手才能改变自己的命运。而我们的时代，更多的得依靠自己的学问和知识领域来直面社会发展。互联网的大时代，汹涌澎湃如斯，浪花卷卷，看似卑微的小人物，同样也能在时代扮演不平凡的角色。</p>\n<p>事实上过去十年正是中国互联网产业飞速发展最为波澜壮阔的十年，哪怕从世界层面来说，也同样如此。中国的互联网本身就比美国晚了将近十年，但是凭借过去的十年，我们取得的飞速发展让我们得以跟美国看起来不相上下。</p>\n<p>当然，大时代的发展看似与我们大多数人关系不大，我们只是时代的见证者和受益人，而还有一些人，他们都积极的参与到其中，并为这个时代的发展起到了看似简单但也至关重要的作用。</p>\n<h1 id=\"二-价值或没价值，其实不用争执\"><a href=\"#二-价值或没价值，其实不用争执\" class=\"headerlink\" title=\"二 价值或没价值，其实不用争执\"></a>二 价值或没价值，其实不用争执</h1><p>我一贯认为围绕价值的争执毫无意义，毕竟每个人的评判标准截然不同，但不同的人大概目标是一致的，追求创造属于自己的价值，实现自己的梦想。当然，在时代的裹挟之下，大多数人都难以真正拥有自己的梦想。往往都是在本能的驱使下，选择工作，家庭，按部就班的工作，陪伴家庭逐渐的向未来前进。</p>\n<p>但这不影响我们可以设想一下我们应该拥有的一些共识，例如使命，价值观和文化。我觉得这三者是非常重要的东西，使命驱使我们前进，价值观促使我们拥有自己的原则，而文化是我们过去受到的家庭教育，学校教育和社会教育在灵魂上的投影。这些东西某种意义来说决定了我们的货币价值。</p>\n<p>为了提高货币价值，我们往往都得超越自我，去做一些在现在知识层面下难以实现的东西。</p>\n<p>一个人的知识领域，往往是知道得越多，越会感觉到自己的欠缺，在刚开始的时候或许是一个小圆圈，但是随着逐渐的学习，这个圆圈也越来越大。</p>\n<p>未知越多，潜力越大。每个人都是独一无二的个体，并在自己的舞台上努力表演，我们虽然难免需要妥协于生活，但是我们其实并不必莫名其妙的取悦于任何人。</p>\n<p>而社会中的每个个体都看似不一样，但往往也能够互相协作，互相支撑，每个人都有自己的职业分工，但总有工作交集的存在。这就意味着看似不一样的生活或工作，总能找到一些值得复用和思考的知识领域，这就需要我们放开心胸与其他人交流，从而使自己的精神更加饱满。</p>\n<h1 id=\"三-写书和读书，是一种灵魂对话\"><a href=\"#三-写书和读书，是一种灵魂对话\" class=\"headerlink\" title=\"三 写书和读书，是一种灵魂对话\"></a>三 写书和读书，是一种灵魂对话</h1><p>而写博客，写书或读书大概是最好的一种方式，作者把自己的成长故事和所思所感记下来，再借助书这种载体输出，既实现了自己知识的沉淀，又能将自己的知识领域向外播撒；</p>\n<p>读者可以花并不高的代价购买到来自于作者一手的知识分享，又能在书中寻找自己的存在，达到与作者的共鸣，这样的学习一定会让人获益非浅。</p>\n<p>在软件研发领域的许多知识，不像我们受到的教育一般，有些东西是有明显的对错之分的，像程序员成长，架构思维或管理模式，无论是哪种方式，总能实现我们的目标。</p>\n<p>我们中的大部分人的成长都大体一样，来源于某份工作或多份工作的自我学习，而不是靠真正的书本或教育，在社会中学习，大概如此。但是这样的东西难免有失节奏，不够系统，甚至要走特别多的弯路，吃很多亏。</p>\n<p>有时候我们会想知道，哪里可以获得系统的学习方法呢？</p>\n<h1 id=\"四-这本书值得读的点\"><a href=\"#四-这本书值得读的点\" class=\"headerlink\" title=\"四 这本书值得读的点\"></a>四 这本书值得读的点</h1><p>一本《程序员的三门课》，或许能够给你带来思考。</p>\n<p>这本书没有试图像那些能够给我们带来直接收入的【21天学会xx技术】的书一样，能够迅速让我们迅速的学会新技术，他甚至有点像啰嗦的前辈一样，说了一些让人摸不着边际的东西。</p>\n<p>事实上书的作者恰好是亲历了互联网大时代的一波人，有阿里巴巴的技术大佬右军老师，李伟山老师，还有彭首长老师和刘朋老师，也有年轻如张洪亮的青年才俊，他们都致力于学习和为企业创造价值，他们事实上也颇有成就。他们都经历了职场的历练，无论是996甚至007，他们都是第一批冲杀在前线的斗士。他们不仅做事雷厉风行，他们更是喜欢思考人生的意义。</p>\n<p>他们都并非像这篇文章一样喜欢说啰嗦的话，他们把自己过去若干年的思考汇集在这本书中，目标是渴望给读者带来真正的收获。</p>\n<p>当你刚参加工作时，需要快速入门的书给你带来顿悟，但一旦稍微稳定下来，一定得站在更高的视角来规划一下自己的未来。编程技术，你可以快速的提升，而掌握这本书中的某些部分，你将有希望看破迷雾，不至于在职场面前过于迷茫。这些从工作中出发，提取自技术、思维模式和管理方法不同层面的知识，每一种都很有思考的意义。</p>\n<p>当然，看完这本书你甚至需要看更多的书，因为这本书他虽然凝淬了许多书的精华，但也是来源于本书作者对于知识的提炼，或许与原作者的原意稍有差别。在读完这本书之后，你或许将拥有一把去开启更多知识领域的钥匙。</p>\n<p>一本经典，往往能让你产生无尽思考；而一本好书，则会让你看破一些道理，甚至会觉得，原来这些其实就是这么回事啊。</p>\n<p>越是看起来简单的道理，越是需要花心思去揣摩才能体会。就像许多看似简单的技术实现，没有亲身经历的，都是“二手知识”。网上有许多的学习资料，尤其是当我们打开某些信息流app时，其实那是你的“信息茧房”，每天阅读这些内容，你会以为技术的获得是多么的轻易，但只有手把手写过一波，才能真正获得价值。而阿里巴巴和众多互联网公司们，花了十年时间做了那么多东西，一定是走了弯路，踩了许多坑才最终获得了最佳实践，而这些在这本书里都有所介绍。</p>\n<p>例如，如果你想在组织中建设一套质量管理体系，书中花了不少章节介绍了代码审查的方式和工具，以及代码审查清单的五个大方向和十六个小方向，这些能够从代码层面建立第一道防线；接着可以从架构体系做好第二层防线，例如分析架构质量的问题来源和解决策略，以及实现流程。这些几乎都是拿来就能应用的良好策略。</p>\n<p>对于程序员的快速成长，作者们都深有体会，例如积极主动的应对困难，以空杯的形态去看待学习，以及别怕犯错，这些都是良好的习惯，尤其要掌握学习方法，打破舒适区和终身成长，能够让我们更快的成长。</p>\n<p>如果初涉管理，作者们也介绍了他们的许多感受，包括做好准备，抓住机会，构建领导力，和高效的时间管理。尤其是时间管理，为什么同样都是996，作者们却不仅把代码写得很完美，还能有时间写那么多博客呢。团队培养，看起来简单却不简单，书里面也提到了许多措施。</p>\n<h1 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h1><p>一本好书，能够给你带来一点思考，就已经足够了，如果让你获得了超过一点思考，那就是赚大了。</p>\n<p>冷静的阅读一下，你会有不一样的收获。这些都是你自己的收获，更是属于你自己的无穷财富。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一-回顾我的职场体会\"><a href=\"#一-回顾我的职场体会\" class=\"headerlink\" title=\"一  回顾我的职场体会\"></a>一  回顾我的职场体会</h1><p>我的职场生涯开始于十年前，一直在中小企业发展，未曾有幸到沿海那些高速发展的互联网公司工作，也就错过了互联网的大时代。</p>\n<p>但这不影响我的正常工作生活，事实上无论你身在何处，或在哪家公司，以各种title生存，我们都是在属于自己的职场道路上奋力拼搏，为了实现自己的人生梦想，我们需要付出的代价和努力，或许并不亚于我们的父辈。</p>\n<p>我们的父辈大部分都生于50后，60后，70后，成长于七零年代，八零年代，九零年代。他们的时代，是举国体制逐渐退潮，市场经济开始唱主角的时代，他们往往没那么多的学问，有时候得靠自己的勇气和双手才能改变自己的命运。而我们的时代，更多的得依靠自己的学问和知识领域来直面社会发展。互联网的大时代，汹涌澎湃如斯，浪花卷卷，看似卑微的小人物，同样也能在时代扮演不平凡的角色。</p>\n<p>事实上过去十年正是中国互联网产业飞速发展最为波澜壮阔的十年，哪怕从世界层面来说，也同样如此。中国的互联网本身就比美国晚了将近十年，但是凭借过去的十年，我们取得的飞速发展让我们得以跟美国看起来不相上下。</p>\n<p>当然，大时代的发展看似与我们大多数人关系不大，我们只是时代的见证者和受益人，而还有一些人，他们都积极的参与到其中，并为这个时代的发展起到了看似简单但也至关重要的作用。</p>\n<h1 id=\"二-价值或没价值，其实不用争执\"><a href=\"#二-价值或没价值，其实不用争执\" class=\"headerlink\" title=\"二 价值或没价值，其实不用争执\"></a>二 价值或没价值，其实不用争执</h1><p>我一贯认为围绕价值的争执毫无意义，毕竟每个人的评判标准截然不同，但不同的人大概目标是一致的，追求创造属于自己的价值，实现自己的梦想。当然，在时代的裹挟之下，大多数人都难以真正拥有自己的梦想。往往都是在本能的驱使下，选择工作，家庭，按部就班的工作，陪伴家庭逐渐的向未来前进。</p>\n<p>但这不影响我们可以设想一下我们应该拥有的一些共识，例如使命，价值观和文化。我觉得这三者是非常重要的东西，使命驱使我们前进，价值观促使我们拥有自己的原则，而文化是我们过去受到的家庭教育，学校教育和社会教育在灵魂上的投影。这些东西某种意义来说决定了我们的货币价值。</p>\n<p>为了提高货币价值，我们往往都得超越自我，去做一些在现在知识层面下难以实现的东西。</p>\n<p>一个人的知识领域，往往是知道得越多，越会感觉到自己的欠缺，在刚开始的时候或许是一个小圆圈，但是随着逐渐的学习，这个圆圈也越来越大。</p>\n<p>未知越多，潜力越大。每个人都是独一无二的个体，并在自己的舞台上努力表演，我们虽然难免需要妥协于生活，但是我们其实并不必莫名其妙的取悦于任何人。</p>\n<p>而社会中的每个个体都看似不一样，但往往也能够互相协作，互相支撑，每个人都有自己的职业分工，但总有工作交集的存在。这就意味着看似不一样的生活或工作，总能找到一些值得复用和思考的知识领域，这就需要我们放开心胸与其他人交流，从而使自己的精神更加饱满。</p>\n<h1 id=\"三-写书和读书，是一种灵魂对话\"><a href=\"#三-写书和读书，是一种灵魂对话\" class=\"headerlink\" title=\"三 写书和读书，是一种灵魂对话\"></a>三 写书和读书，是一种灵魂对话</h1><p>而写博客，写书或读书大概是最好的一种方式，作者把自己的成长故事和所思所感记下来，再借助书这种载体输出，既实现了自己知识的沉淀，又能将自己的知识领域向外播撒；</p>\n<p>读者可以花并不高的代价购买到来自于作者一手的知识分享，又能在书中寻找自己的存在，达到与作者的共鸣，这样的学习一定会让人获益非浅。</p>\n<p>在软件研发领域的许多知识，不像我们受到的教育一般，有些东西是有明显的对错之分的，像程序员成长，架构思维或管理模式，无论是哪种方式，总能实现我们的目标。</p>\n<p>我们中的大部分人的成长都大体一样，来源于某份工作或多份工作的自我学习，而不是靠真正的书本或教育，在社会中学习，大概如此。但是这样的东西难免有失节奏，不够系统，甚至要走特别多的弯路，吃很多亏。</p>\n<p>有时候我们会想知道，哪里可以获得系统的学习方法呢？</p>\n<h1 id=\"四-这本书值得读的点\"><a href=\"#四-这本书值得读的点\" class=\"headerlink\" title=\"四 这本书值得读的点\"></a>四 这本书值得读的点</h1><p>一本《程序员的三门课》，或许能够给你带来思考。</p>\n<p>这本书没有试图像那些能够给我们带来直接收入的【21天学会xx技术】的书一样，能够迅速让我们迅速的学会新技术，他甚至有点像啰嗦的前辈一样，说了一些让人摸不着边际的东西。</p>\n<p>事实上书的作者恰好是亲历了互联网大时代的一波人，有阿里巴巴的技术大佬右军老师，李伟山老师，还有彭首长老师和刘朋老师，也有年轻如张洪亮的青年才俊，他们都致力于学习和为企业创造价值，他们事实上也颇有成就。他们都经历了职场的历练，无论是996甚至007，他们都是第一批冲杀在前线的斗士。他们不仅做事雷厉风行，他们更是喜欢思考人生的意义。</p>\n<p>他们都并非像这篇文章一样喜欢说啰嗦的话，他们把自己过去若干年的思考汇集在这本书中，目标是渴望给读者带来真正的收获。</p>\n<p>当你刚参加工作时，需要快速入门的书给你带来顿悟，但一旦稍微稳定下来，一定得站在更高的视角来规划一下自己的未来。编程技术，你可以快速的提升，而掌握这本书中的某些部分，你将有希望看破迷雾，不至于在职场面前过于迷茫。这些从工作中出发，提取自技术、思维模式和管理方法不同层面的知识，每一种都很有思考的意义。</p>\n<p>当然，看完这本书你甚至需要看更多的书，因为这本书他虽然凝淬了许多书的精华，但也是来源于本书作者对于知识的提炼，或许与原作者的原意稍有差别。在读完这本书之后，你或许将拥有一把去开启更多知识领域的钥匙。</p>\n<p>一本经典，往往能让你产生无尽思考；而一本好书，则会让你看破一些道理，甚至会觉得，原来这些其实就是这么回事啊。</p>\n<p>越是看起来简单的道理，越是需要花心思去揣摩才能体会。就像许多看似简单的技术实现，没有亲身经历的，都是“二手知识”。网上有许多的学习资料，尤其是当我们打开某些信息流app时，其实那是你的“信息茧房”，每天阅读这些内容，你会以为技术的获得是多么的轻易，但只有手把手写过一波，才能真正获得价值。而阿里巴巴和众多互联网公司们，花了十年时间做了那么多东西，一定是走了弯路，踩了许多坑才最终获得了最佳实践，而这些在这本书里都有所介绍。</p>\n<p>例如，如果你想在组织中建设一套质量管理体系，书中花了不少章节介绍了代码审查的方式和工具，以及代码审查清单的五个大方向和十六个小方向，这些能够从代码层面建立第一道防线；接着可以从架构体系做好第二层防线，例如分析架构质量的问题来源和解决策略，以及实现流程。这些几乎都是拿来就能应用的良好策略。</p>\n<p>对于程序员的快速成长，作者们都深有体会，例如积极主动的应对困难，以空杯的形态去看待学习，以及别怕犯错，这些都是良好的习惯，尤其要掌握学习方法，打破舒适区和终身成长，能够让我们更快的成长。</p>\n<p>如果初涉管理，作者们也介绍了他们的许多感受，包括做好准备，抓住机会，构建领导力，和高效的时间管理。尤其是时间管理，为什么同样都是996，作者们却不仅把代码写得很完美，还能有时间写那么多博客呢。团队培养，看起来简单却不简单，书里面也提到了许多措施。</p>\n<h1 id=\"五-总结\"><a href=\"#五-总结\" class=\"headerlink\" title=\"五 总结\"></a>五 总结</h1><p>一本好书，能够给你带来一点思考，就已经足够了，如果让你获得了超过一点思考，那就是赚大了。</p>\n<p>冷静的阅读一下，你会有不一样的收获。这些都是你自己的收获，更是属于你自己的无穷财富。</p>\n"},{"title":"从必然中看到了必然么","date":"2020-01-09T13:28:00.000Z","author":"邹溪源","_content":"\n《必然》是来自凯文凯利的书，我看到的是2016年的第一版中译本，从2019年12月28日开始看，到2020年1月4日看完，耗时一周左右，这也是2020年看完的第一本书，而我的计划是今年要阅读50本书，下一本还是凯文凯利的一本老书，《失控》。\n\n# 一\n我还记得若干年前，美团和大众点评合并，滴滴和快的合并，中国互联网电商的几大品牌阿里巴巴、京东、当当网、唯品会等都相继在美股或港股上市，这些互联网巨头的崛起一度让我以为，中国互联网经济已经到了饱和期，几乎再也不会出现新的大型平台型公司了。显然，我产生的错觉，恰似从《浪潮之巅》中所看到的那样，在二十世纪九十年代末期互联网泡沫破灭的前夜的美国，也同样是这样看似互联网蛋糕都被瓜分完毕，新加入的玩家在巨头下苟延残喘，短期内看不到希望的那个时代。\n\n毋庸置疑，大家会嘲讽我的短视，曾经电商们几分天下，也有拼多多逆势崛起，凭借微信平台，在社交电商领域挤成了一个行业前三；手机市场曾经被苹果、HTC、诺基亚、三星、中华酷联们占据了主要市场，但是随着小米、华为荣耀们居然还能笑到今天，甚至日子越过越红火，而昔日的中兴、联想、金立们，早就成为明日黄花；汽车市场，有特斯拉和蔚来们在搅局；就连航空航天市场，SpaceX已经开始成为主角，而中国的民营航天市场，也大概到了市场化的十字路口。\n\n这些企业是科技的象征，对于年轻的我们来说，其实已经看不清科技发展的方向了，甚至于，我们每个人所深深经历的这个时代，早已经以想象不到的速度，在一点一点的发生改变，我们已经很难用现有的智慧来预测未来的发展，那是因为基于现有知识体系，我们总是只能看到的一片平衡。\n\n而那些大智慧者眼里，看到的是一片混沌市场，是无穷机会。\n\n# 二\n>凯文凯利说：今天，我们生活中的每一项显著变化的核心都是某种科技。科技是人类的催化剂，万物不息，万物不知，万物未竟。这场永无止境的变迁是现代社会的枢轴。。。。在过去两百年里，我们最伟大的发明恰恰是科学流程其自身，而非某个特定的工具或玩意儿。。。。永无休止的变化是一切人类的命运，我们正在从一个静态的名词世界，前往一个流动的动词世界。\n\n我们今天的所有一切，其实都处于不断变化之中。\n\n传统国有企业们为何会逐渐的迷失方向，是仅仅由于体制政策的限制，让他们忽略了基础科学技术的积累，而最终被新来着们降维打击，然后逐渐走向衰微么？传统媒体们，是如何在新媒体之下，一点点的把过去的红利给消耗完毕，以至于走上了今天的下坡路？传统交通运输公司们，是如何在以滴滴为代表的互联网租车新模式下，不仅失去了机会，甚至连人心都失去呢？是一股怎样的力量在指引着时代的前进，该如何做才能顺应时代的发展？仅仅只是互联网的速度提升，和摩尔定律带来的硬件效率提升么？无从得知。\n\n遽然想去，如果我们今天所处的一切，回归到20年前、三十年前、甚至一百年前，大概就像王莽要重新回归到孔子的《论语》所述的一片仁政时代一般，不仅无法适应，而且还会被时空之子干掉吧。历史的车辙滚滚向前，没有任何东西可以阻挡，我们只需想到，我们今天所有的以前，其实是过去三十年飞速发展的科技所带来的巨大成就；同样如此，在未来三十年，可以真正主导生活的重要科技还没发明出来。我们将一次又一次地成为全力避免掉队的菜鸟，永无休止，无一例外。\n\n# 三\n新兴技术在席卷全球，这股快速发展的力量，将、且正在经过一系列潜移默化的步骤持续稳定的改变着我们的文化、我们的思维方式、我们的价值观、我们的存在。它将经历这些步骤：形成、知化、流动、屏读、使用、共享、过滤、重混、互动、追踪、提问以及开始。\n\n形成 Becoming:科技的未来并非乌托邦，也不是反乌托邦，而是“进托邦“，进托邦并非目的，而是一个变化的过程，是一种进程。它是一种”形成“，它是一种变化方式不断变化的进程。我们所瞄准的未来，是当下就能看见，”形成“这种进程的产物。我们将亲眼见证眼下的一切将会成为未来的变化。包括互联网，从禁止将互联网”大范围用于私有实物和个人事务”，到今天，再到2050年。或许正如凯文凯利所说，没有哪一天会比今天更适合创造，没有那一个时代，会比当前、当下、此时此刻更有机遇，更加开放。\n\n知化 Cognifying:人工智能毋庸置疑，将代替我们的工作。\n\n流动 Flowing：数字经济无处不在，时刻都在流动。\n\n屏读Screening：无处皆屏幕。屏幕将是未来生活。\n\n使用 Accessing:从减物质化、到按需使用的即时性、到去中心化、到平台协同、到云端。未来我们或许不能拥有任何事物，但是我们能使用更多东西。\n\n共享Sharing:从分享到合作、再到协作、再到集体主义，我们的成功、我们的失败、我们的情绪、都将“共享”。\n\n过滤 Filtering：当今时代制造的信息、产品已经远超我们所能消费的，我们需要创造一种新的方式来过滤信息和个性化定制，以凸显我们的差异。\n\n重混 Remixing：我们从海量信息中，重混出属于自己的价值。\n\n互动 Interacting：从虚拟现实、到谷歌眼睛，互动的程序在提升，并将继续提升。未来的技术发展很大程度将取决于新兴互动方式的发掘。\n\n追踪Tracking：无处不在的追踪，将意味着更多信息的产生，而更高层次的自我追踪带来的可能性，也将使我们感到震惊。\n\n提问Questioning:提问远比回答更有力量。\n\n开始Begining：我们正在在开始的时刻。\n\n# 四\n我们将迎来的是怎样的时代，他需要我们该做哪些准备？\n\n","source":"_posts/读书/从《必然》中看到的必要.md","raw":"---\ntitle:  从必然中看到了必然么\ndate: 2020-1-9 21:28\ntags: 读书\nauthor: 邹溪源\ncategories:\n  - 读书\n---\n\n《必然》是来自凯文凯利的书，我看到的是2016年的第一版中译本，从2019年12月28日开始看，到2020年1月4日看完，耗时一周左右，这也是2020年看完的第一本书，而我的计划是今年要阅读50本书，下一本还是凯文凯利的一本老书，《失控》。\n\n# 一\n我还记得若干年前，美团和大众点评合并，滴滴和快的合并，中国互联网电商的几大品牌阿里巴巴、京东、当当网、唯品会等都相继在美股或港股上市，这些互联网巨头的崛起一度让我以为，中国互联网经济已经到了饱和期，几乎再也不会出现新的大型平台型公司了。显然，我产生的错觉，恰似从《浪潮之巅》中所看到的那样，在二十世纪九十年代末期互联网泡沫破灭的前夜的美国，也同样是这样看似互联网蛋糕都被瓜分完毕，新加入的玩家在巨头下苟延残喘，短期内看不到希望的那个时代。\n\n毋庸置疑，大家会嘲讽我的短视，曾经电商们几分天下，也有拼多多逆势崛起，凭借微信平台，在社交电商领域挤成了一个行业前三；手机市场曾经被苹果、HTC、诺基亚、三星、中华酷联们占据了主要市场，但是随着小米、华为荣耀们居然还能笑到今天，甚至日子越过越红火，而昔日的中兴、联想、金立们，早就成为明日黄花；汽车市场，有特斯拉和蔚来们在搅局；就连航空航天市场，SpaceX已经开始成为主角，而中国的民营航天市场，也大概到了市场化的十字路口。\n\n这些企业是科技的象征，对于年轻的我们来说，其实已经看不清科技发展的方向了，甚至于，我们每个人所深深经历的这个时代，早已经以想象不到的速度，在一点一点的发生改变，我们已经很难用现有的智慧来预测未来的发展，那是因为基于现有知识体系，我们总是只能看到的一片平衡。\n\n而那些大智慧者眼里，看到的是一片混沌市场，是无穷机会。\n\n# 二\n>凯文凯利说：今天，我们生活中的每一项显著变化的核心都是某种科技。科技是人类的催化剂，万物不息，万物不知，万物未竟。这场永无止境的变迁是现代社会的枢轴。。。。在过去两百年里，我们最伟大的发明恰恰是科学流程其自身，而非某个特定的工具或玩意儿。。。。永无休止的变化是一切人类的命运，我们正在从一个静态的名词世界，前往一个流动的动词世界。\n\n我们今天的所有一切，其实都处于不断变化之中。\n\n传统国有企业们为何会逐渐的迷失方向，是仅仅由于体制政策的限制，让他们忽略了基础科学技术的积累，而最终被新来着们降维打击，然后逐渐走向衰微么？传统媒体们，是如何在新媒体之下，一点点的把过去的红利给消耗完毕，以至于走上了今天的下坡路？传统交通运输公司们，是如何在以滴滴为代表的互联网租车新模式下，不仅失去了机会，甚至连人心都失去呢？是一股怎样的力量在指引着时代的前进，该如何做才能顺应时代的发展？仅仅只是互联网的速度提升，和摩尔定律带来的硬件效率提升么？无从得知。\n\n遽然想去，如果我们今天所处的一切，回归到20年前、三十年前、甚至一百年前，大概就像王莽要重新回归到孔子的《论语》所述的一片仁政时代一般，不仅无法适应，而且还会被时空之子干掉吧。历史的车辙滚滚向前，没有任何东西可以阻挡，我们只需想到，我们今天所有的以前，其实是过去三十年飞速发展的科技所带来的巨大成就；同样如此，在未来三十年，可以真正主导生活的重要科技还没发明出来。我们将一次又一次地成为全力避免掉队的菜鸟，永无休止，无一例外。\n\n# 三\n新兴技术在席卷全球，这股快速发展的力量，将、且正在经过一系列潜移默化的步骤持续稳定的改变着我们的文化、我们的思维方式、我们的价值观、我们的存在。它将经历这些步骤：形成、知化、流动、屏读、使用、共享、过滤、重混、互动、追踪、提问以及开始。\n\n形成 Becoming:科技的未来并非乌托邦，也不是反乌托邦，而是“进托邦“，进托邦并非目的，而是一个变化的过程，是一种进程。它是一种”形成“，它是一种变化方式不断变化的进程。我们所瞄准的未来，是当下就能看见，”形成“这种进程的产物。我们将亲眼见证眼下的一切将会成为未来的变化。包括互联网，从禁止将互联网”大范围用于私有实物和个人事务”，到今天，再到2050年。或许正如凯文凯利所说，没有哪一天会比今天更适合创造，没有那一个时代，会比当前、当下、此时此刻更有机遇，更加开放。\n\n知化 Cognifying:人工智能毋庸置疑，将代替我们的工作。\n\n流动 Flowing：数字经济无处不在，时刻都在流动。\n\n屏读Screening：无处皆屏幕。屏幕将是未来生活。\n\n使用 Accessing:从减物质化、到按需使用的即时性、到去中心化、到平台协同、到云端。未来我们或许不能拥有任何事物，但是我们能使用更多东西。\n\n共享Sharing:从分享到合作、再到协作、再到集体主义，我们的成功、我们的失败、我们的情绪、都将“共享”。\n\n过滤 Filtering：当今时代制造的信息、产品已经远超我们所能消费的，我们需要创造一种新的方式来过滤信息和个性化定制，以凸显我们的差异。\n\n重混 Remixing：我们从海量信息中，重混出属于自己的价值。\n\n互动 Interacting：从虚拟现实、到谷歌眼睛，互动的程序在提升，并将继续提升。未来的技术发展很大程度将取决于新兴互动方式的发掘。\n\n追踪Tracking：无处不在的追踪，将意味着更多信息的产生，而更高层次的自我追踪带来的可能性，也将使我们感到震惊。\n\n提问Questioning:提问远比回答更有力量。\n\n开始Begining：我们正在在开始的时刻。\n\n# 四\n我们将迎来的是怎样的时代，他需要我们该做哪些准备？\n\n","slug":"读书/从《必然》中看到的必要","published":1,"updated":"2020-01-09T14:38:13.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt8k002qn4visg55xb9q","content":"<p>《必然》是来自凯文凯利的书，我看到的是2016年的第一版中译本，从2019年12月28日开始看，到2020年1月4日看完，耗时一周左右，这也是2020年看完的第一本书，而我的计划是今年要阅读50本书，下一本还是凯文凯利的一本老书，《失控》。</p>\n<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>我还记得若干年前，美团和大众点评合并，滴滴和快的合并，中国互联网电商的几大品牌阿里巴巴、京东、当当网、唯品会等都相继在美股或港股上市，这些互联网巨头的崛起一度让我以为，中国互联网经济已经到了饱和期，几乎再也不会出现新的大型平台型公司了。显然，我产生的错觉，恰似从《浪潮之巅》中所看到的那样，在二十世纪九十年代末期互联网泡沫破灭的前夜的美国，也同样是这样看似互联网蛋糕都被瓜分完毕，新加入的玩家在巨头下苟延残喘，短期内看不到希望的那个时代。</p>\n<p>毋庸置疑，大家会嘲讽我的短视，曾经电商们几分天下，也有拼多多逆势崛起，凭借微信平台，在社交电商领域挤成了一个行业前三；手机市场曾经被苹果、HTC、诺基亚、三星、中华酷联们占据了主要市场，但是随着小米、华为荣耀们居然还能笑到今天，甚至日子越过越红火，而昔日的中兴、联想、金立们，早就成为明日黄花；汽车市场，有特斯拉和蔚来们在搅局；就连航空航天市场，SpaceX已经开始成为主角，而中国的民营航天市场，也大概到了市场化的十字路口。</p>\n<p>这些企业是科技的象征，对于年轻的我们来说，其实已经看不清科技发展的方向了，甚至于，我们每个人所深深经历的这个时代，早已经以想象不到的速度，在一点一点的发生改变，我们已经很难用现有的智慧来预测未来的发展，那是因为基于现有知识体系，我们总是只能看到的一片平衡。</p>\n<p>而那些大智慧者眼里，看到的是一片混沌市场，是无穷机会。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><blockquote>\n<p>凯文凯利说：今天，我们生活中的每一项显著变化的核心都是某种科技。科技是人类的催化剂，万物不息，万物不知，万物未竟。这场永无止境的变迁是现代社会的枢轴。。。。在过去两百年里，我们最伟大的发明恰恰是科学流程其自身，而非某个特定的工具或玩意儿。。。。永无休止的变化是一切人类的命运，我们正在从一个静态的名词世界，前往一个流动的动词世界。</p>\n</blockquote>\n<p>我们今天的所有一切，其实都处于不断变化之中。</p>\n<p>传统国有企业们为何会逐渐的迷失方向，是仅仅由于体制政策的限制，让他们忽略了基础科学技术的积累，而最终被新来着们降维打击，然后逐渐走向衰微么？传统媒体们，是如何在新媒体之下，一点点的把过去的红利给消耗完毕，以至于走上了今天的下坡路？传统交通运输公司们，是如何在以滴滴为代表的互联网租车新模式下，不仅失去了机会，甚至连人心都失去呢？是一股怎样的力量在指引着时代的前进，该如何做才能顺应时代的发展？仅仅只是互联网的速度提升，和摩尔定律带来的硬件效率提升么？无从得知。</p>\n<p>遽然想去，如果我们今天所处的一切，回归到20年前、三十年前、甚至一百年前，大概就像王莽要重新回归到孔子的《论语》所述的一片仁政时代一般，不仅无法适应，而且还会被时空之子干掉吧。历史的车辙滚滚向前，没有任何东西可以阻挡，我们只需想到，我们今天所有的以前，其实是过去三十年飞速发展的科技所带来的巨大成就；同样如此，在未来三十年，可以真正主导生活的重要科技还没发明出来。我们将一次又一次地成为全力避免掉队的菜鸟，永无休止，无一例外。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>新兴技术在席卷全球，这股快速发展的力量，将、且正在经过一系列潜移默化的步骤持续稳定的改变着我们的文化、我们的思维方式、我们的价值观、我们的存在。它将经历这些步骤：形成、知化、流动、屏读、使用、共享、过滤、重混、互动、追踪、提问以及开始。</p>\n<p>形成 Becoming:科技的未来并非乌托邦，也不是反乌托邦，而是“进托邦“，进托邦并非目的，而是一个变化的过程，是一种进程。它是一种”形成“，它是一种变化方式不断变化的进程。我们所瞄准的未来，是当下就能看见，”形成“这种进程的产物。我们将亲眼见证眼下的一切将会成为未来的变化。包括互联网，从禁止将互联网”大范围用于私有实物和个人事务”，到今天，再到2050年。或许正如凯文凯利所说，没有哪一天会比今天更适合创造，没有那一个时代，会比当前、当下、此时此刻更有机遇，更加开放。</p>\n<p>知化 Cognifying:人工智能毋庸置疑，将代替我们的工作。</p>\n<p>流动 Flowing：数字经济无处不在，时刻都在流动。</p>\n<p>屏读Screening：无处皆屏幕。屏幕将是未来生活。</p>\n<p>使用 Accessing:从减物质化、到按需使用的即时性、到去中心化、到平台协同、到云端。未来我们或许不能拥有任何事物，但是我们能使用更多东西。</p>\n<p>共享Sharing:从分享到合作、再到协作、再到集体主义，我们的成功、我们的失败、我们的情绪、都将“共享”。</p>\n<p>过滤 Filtering：当今时代制造的信息、产品已经远超我们所能消费的，我们需要创造一种新的方式来过滤信息和个性化定制，以凸显我们的差异。</p>\n<p>重混 Remixing：我们从海量信息中，重混出属于自己的价值。</p>\n<p>互动 Interacting：从虚拟现实、到谷歌眼睛，互动的程序在提升，并将继续提升。未来的技术发展很大程度将取决于新兴互动方式的发掘。</p>\n<p>追踪Tracking：无处不在的追踪，将意味着更多信息的产生，而更高层次的自我追踪带来的可能性，也将使我们感到震惊。</p>\n<p>提问Questioning:提问远比回答更有力量。</p>\n<p>开始Begining：我们正在在开始的时刻。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>我们将迎来的是怎样的时代，他需要我们该做哪些准备？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>《必然》是来自凯文凯利的书，我看到的是2016年的第一版中译本，从2019年12月28日开始看，到2020年1月4日看完，耗时一周左右，这也是2020年看完的第一本书，而我的计划是今年要阅读50本书，下一本还是凯文凯利的一本老书，《失控》。</p>\n<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>我还记得若干年前，美团和大众点评合并，滴滴和快的合并，中国互联网电商的几大品牌阿里巴巴、京东、当当网、唯品会等都相继在美股或港股上市，这些互联网巨头的崛起一度让我以为，中国互联网经济已经到了饱和期，几乎再也不会出现新的大型平台型公司了。显然，我产生的错觉，恰似从《浪潮之巅》中所看到的那样，在二十世纪九十年代末期互联网泡沫破灭的前夜的美国，也同样是这样看似互联网蛋糕都被瓜分完毕，新加入的玩家在巨头下苟延残喘，短期内看不到希望的那个时代。</p>\n<p>毋庸置疑，大家会嘲讽我的短视，曾经电商们几分天下，也有拼多多逆势崛起，凭借微信平台，在社交电商领域挤成了一个行业前三；手机市场曾经被苹果、HTC、诺基亚、三星、中华酷联们占据了主要市场，但是随着小米、华为荣耀们居然还能笑到今天，甚至日子越过越红火，而昔日的中兴、联想、金立们，早就成为明日黄花；汽车市场，有特斯拉和蔚来们在搅局；就连航空航天市场，SpaceX已经开始成为主角，而中国的民营航天市场，也大概到了市场化的十字路口。</p>\n<p>这些企业是科技的象征，对于年轻的我们来说，其实已经看不清科技发展的方向了，甚至于，我们每个人所深深经历的这个时代，早已经以想象不到的速度，在一点一点的发生改变，我们已经很难用现有的智慧来预测未来的发展，那是因为基于现有知识体系，我们总是只能看到的一片平衡。</p>\n<p>而那些大智慧者眼里，看到的是一片混沌市场，是无穷机会。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><blockquote>\n<p>凯文凯利说：今天，我们生活中的每一项显著变化的核心都是某种科技。科技是人类的催化剂，万物不息，万物不知，万物未竟。这场永无止境的变迁是现代社会的枢轴。。。。在过去两百年里，我们最伟大的发明恰恰是科学流程其自身，而非某个特定的工具或玩意儿。。。。永无休止的变化是一切人类的命运，我们正在从一个静态的名词世界，前往一个流动的动词世界。</p>\n</blockquote>\n<p>我们今天的所有一切，其实都处于不断变化之中。</p>\n<p>传统国有企业们为何会逐渐的迷失方向，是仅仅由于体制政策的限制，让他们忽略了基础科学技术的积累，而最终被新来着们降维打击，然后逐渐走向衰微么？传统媒体们，是如何在新媒体之下，一点点的把过去的红利给消耗完毕，以至于走上了今天的下坡路？传统交通运输公司们，是如何在以滴滴为代表的互联网租车新模式下，不仅失去了机会，甚至连人心都失去呢？是一股怎样的力量在指引着时代的前进，该如何做才能顺应时代的发展？仅仅只是互联网的速度提升，和摩尔定律带来的硬件效率提升么？无从得知。</p>\n<p>遽然想去，如果我们今天所处的一切，回归到20年前、三十年前、甚至一百年前，大概就像王莽要重新回归到孔子的《论语》所述的一片仁政时代一般，不仅无法适应，而且还会被时空之子干掉吧。历史的车辙滚滚向前，没有任何东西可以阻挡，我们只需想到，我们今天所有的以前，其实是过去三十年飞速发展的科技所带来的巨大成就；同样如此，在未来三十年，可以真正主导生活的重要科技还没发明出来。我们将一次又一次地成为全力避免掉队的菜鸟，永无休止，无一例外。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>新兴技术在席卷全球，这股快速发展的力量，将、且正在经过一系列潜移默化的步骤持续稳定的改变着我们的文化、我们的思维方式、我们的价值观、我们的存在。它将经历这些步骤：形成、知化、流动、屏读、使用、共享、过滤、重混、互动、追踪、提问以及开始。</p>\n<p>形成 Becoming:科技的未来并非乌托邦，也不是反乌托邦，而是“进托邦“，进托邦并非目的，而是一个变化的过程，是一种进程。它是一种”形成“，它是一种变化方式不断变化的进程。我们所瞄准的未来，是当下就能看见，”形成“这种进程的产物。我们将亲眼见证眼下的一切将会成为未来的变化。包括互联网，从禁止将互联网”大范围用于私有实物和个人事务”，到今天，再到2050年。或许正如凯文凯利所说，没有哪一天会比今天更适合创造，没有那一个时代，会比当前、当下、此时此刻更有机遇，更加开放。</p>\n<p>知化 Cognifying:人工智能毋庸置疑，将代替我们的工作。</p>\n<p>流动 Flowing：数字经济无处不在，时刻都在流动。</p>\n<p>屏读Screening：无处皆屏幕。屏幕将是未来生活。</p>\n<p>使用 Accessing:从减物质化、到按需使用的即时性、到去中心化、到平台协同、到云端。未来我们或许不能拥有任何事物，但是我们能使用更多东西。</p>\n<p>共享Sharing:从分享到合作、再到协作、再到集体主义，我们的成功、我们的失败、我们的情绪、都将“共享”。</p>\n<p>过滤 Filtering：当今时代制造的信息、产品已经远超我们所能消费的，我们需要创造一种新的方式来过滤信息和个性化定制，以凸显我们的差异。</p>\n<p>重混 Remixing：我们从海量信息中，重混出属于自己的价值。</p>\n<p>互动 Interacting：从虚拟现实、到谷歌眼睛，互动的程序在提升，并将继续提升。未来的技术发展很大程度将取决于新兴互动方式的发掘。</p>\n<p>追踪Tracking：无处不在的追踪，将意味着更多信息的产生，而更高层次的自我追踪带来的可能性，也将使我们感到震惊。</p>\n<p>提问Questioning:提问远比回答更有力量。</p>\n<p>开始Begining：我们正在在开始的时刻。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>我们将迎来的是怎样的时代，他需要我们该做哪些准备？</p>\n"},{"title":"2019.NET Conf China（中国.NET开发者峰会），.NET技术之崛起，已势不可挡","date":"2019-11-12T00:08:00.000Z","author":"邹溪源","_content":"\n\n# 一、微软走向开放与.NET Core的诞生\n当今时代，气象更新，技术飞速发展。\n\n当今时代，开发者大概是最优秀的群体。每一位开发者，无不奋勇向前，努力追寻时代的步伐，以大无畏的精神迎接挑战，紧跟大时代成就企业发展的宏伟蓝图的同时，也在实现自己的个人梦想。\n\n微软，无疑便是最善于应对时代变化的英雄，从比尔盖茨选择从哈佛大学创业开始，历经四十年时间，经过了三个变革的时期。每个时代都以其独特的方式深深地鼓舞人心，哪怕历经千辛万苦，哪怕一度前途充满阴霾，也能实现自我价值的刷新，并重回巅峰。\n\n当代的微软，已经从一家技术驱动型公司，变革为一家文化驱动型公司，在纳德拉的领导下，云战略，开放，分享，自我刷新的企业文化精神已经让人们深深的意识到，那个沉睡的巨象一旦觉醒，该有着多么大的魄力和影响力。\n\n大环境已经在悄然改变，在隔壁Java走下坡路时，这边的.NET，也迎来了新的发展机遇。微软不再靠自己一家企业来控制这种优秀的技术，而是成立了一个.NET基金会，他扮演着技术公司于开发者之间的窗口，旨在加强和扩大以.NET技术为核心的技术生态系统。并随着.NET技术交给了社区由基金会来管理，基于.NET的开源生态已经如星火燎然之势蓬勃开展起来。到目前为止该基金会的参与者已经包括谷歌，红帽等知名互联网公司，这么多优秀的企业都参与其中。众人拾柴火焰高，有了这么多企业的积极参与，.NET技术生态已经迎来了前所未有的战略机遇期。\n\n2019年的9月份，在2019年的.NET Conf上已经发布了.NET技术体系下、面向开源和跨平台的技术组件.NET Core3.0，该技术包含了一系列组件和新特性，能够让无论是Web开发者，还是ML.NET开发者，或者是游戏开发者都能直接感受到.NET Core跨平台技术的魅力和价值。\n\n# 二、开发者峰会的诞生\n2019年对于广大.NET开发者来说算是不平凡的一年。在这一年里，在微软云技术社区的支持下、在.NET社区领袖张善友老师、衣明志老师、叶伟民老师、陈作老师、潘淳老师等行业翘楚的摇旗呐喊之下，各地的.NET技术社区（微软.NET俱乐部）如雨后春笋般蓬勃开展起来。\n\n首先是胶东开发者部落的诞生、广州微软.NET俱乐部的复活。\n\n接着是苏州微软.NET俱乐部的诞生。\n\n随后是长沙.NET技术社区、沈阳、东莞、厦门、北京等地区.NET社区的诞生 。\n\n以及随后各地都相继成立了主题为.NET技术或互联网技术的各类线上或线下的技术交流组织，可以说无论你目前身处祖国的哪一个角落，总是能在最近的地域找到一个活跃的技术社区，通过社区能够跟当地的技术大佬们进行充满高质量的技术交流，这对于每一位开发者来说都是非常难能可贵的体验。\n\n除了这些.NET技术社区外，还有数十位.NET开发者们自发运营起主打.NET方向的技术公众号来，通过这些公众号，能够让开发者从全方位多维度了解和学习面向互联网大时代的.NET技术，能够让爱学习的开发者们的技术每时每刻都做好积累。\n\n而且在.NET开发者的主阵地，博客园每天发表的新内容中，与.NET技术相关的话题也越来越多；而且越来越多的优秀的.NET技术书籍也已经付梓，并被出版社相继出版，成为畅销书，还有许多开发者们都相继把他们的写的新书交给了出版社，预计在明年年初将迎来一波.NET技术类书籍的小高潮。\n\n这些都是.NET开发者们迎来的良好机遇，借着行业互联网的逐渐深化、以及.NET技术的进一步推广、技术社区的繁荣昌盛、.NET学习资源的源源不绝，相信开发者们一定能借此良机成就个人的美好梦想。\n\n在这样的大背景之下，为了让.NET开发者们能够更加直观的感受到.NET技术的强大魅力，微软云（Azure)、.NET技术社区的行业翘楚、企业代表、活跃在.NET技术圈的优秀开发者们、以及各地.NET技术社区们，打算干一件大事，这就是本次2019年的.NET Conf，中国.NET 开发者峰会。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/dHeSY1m1vxU7M0xT.png)\n\n有别于一般都是由大型企业组织、或者甚至有微软包办的其他类型技术峰会，这次峰会完全来自.NET技术圈开发者们的无偿付出，我们可以看到，张善友老师经常在他的公众号里发布与Conf有关的资讯，而这些文章的撰写都是来源于社区；我们也可以看到许多精美的海报，这些也是来源于开发者，甚至也许就是我们身边的某位不知名的开发者。还有在活动现场的许多志愿者、主持人，这些都是对.NET 技术充满大爱的优秀开发者；尤其是那些为大家带来精彩内容的老师们，他们有时候为了PPT上的每一页内容，需要花费大量的业余时间；除了这些之外，我们还能看到许多细节，如那些设计精美的PPT、那些设计精良的文化衫、甚至还有那些小巧玲珑的贴纸图案、海报，无一不是来源于社区志愿者的精心奉献。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/aKGIP2ffgY0sBy14.png)\n\n这么多开发者、志愿者、老师们的专注认真、精心设计、严密组织， 从宣传、活动安排、布置、会场组织的每一个细节出发，我们看到的，正是一个充满生机和活力、专业的技术社区，这样的社区，让我们对.NET技术充满了激情，也让我们对未来充满了无限期待。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/c4p8aTPXKyUlWWP5.png)\n\n# 三、精彩纷呈的内容\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/FTy19dQR6V0gtjvx.png)\n\n这次.NET Conf的主题是《开源，共享，创新》，既可以称为社区的主题，也可以拥抱新时代的.net开发者们的共同心声。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/KrzXe1O3egUWHHhN.png)\n\n开源：随着.Net技术推出的新版技术框架.net core已经发布3.0版本，开源社区建设正如同雨后春笋一般蓬勃发展。\n\n共享：.net开发者们，不再选择敝帚自珍，而是以更加开放的心态参与到社区建设之中，共享知识，也是在分享财富。\n\n创新：开发者们拥有的最优秀的品质，在时代的浪潮下，唯有不断刷新，创新，才能始终如一的创造价值。\n\n而围绕主题出发的各种主题也同样贴合了行业发展的大趋势，许多.NET开发者虽然目前从事的领域也许是某些行业应用的开发，但是都说想了解新兴技术是如何运用到其中的，那么这次盛会给了大家机会。在本次峰会上，不仅有开发者职业发展规划的内容，也有.NET Core新的特性介绍，更有许多新兴技术，例如人工智能、实时计算、混沌工程、服务网格、RPA等新潮技术，还有PowerBI、Unity Bot、 ABP等备受期待的传统技术，能够各个让对技术充满兴趣的开发者都能学到自己想学的东西。\n\n我们可以跟随.NET Core项目负责人Scott Hunter一起，看看在.NET Core3.0中，哪些新的特性能够获得怎样的好处。\n\n也可以跟着来自澳大利亚的微软MVPJustin Yoo一起，听听他讲的故事，看看他的职业发展；\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/fXT5Sm9hcmYlKN7X.png)\n\n还可以跟着来自校宝在线的肖伟宇老师一起，看看如何在.NET Core中将检测组件集成到高可用的.NET Core微服务中。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/xolfXf9N2Ngt0ZEw.png)\n\n我们还可以听卢建辉老师谈谈ML.NET 和SciSharp项目以及TensorFlow.NET项目，而这个TensorFlow.NET项目尤其值得大家关注，因为他的主要开发团队，许多成员都是我们身边的、来自中国内地的.NET开发者们，这个项目不仅仅是中国.NET开发者们的小圈子自嗨，更是成为微软人工智能框架ML.NET的基础平台框架，通过这款框架，能够让全世界范围内超过六百二十万.NET开发者们无需转语音，便可畅想人工智能的美妙。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/kWU0c7E8ZgIetK76.png)\n\n而刘腾飞Jesse这位英俊帅气不凡的开发者，也把他们公司踩坑K8s的全过程搬上讲台，用血和汗的教训告诉大家，其实.NET Core什么都能干好，而且不比隔壁家的技术差。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/lsRndjg1IV02vuRj.png)\n\n本次大会与某些大厂组织的自称科技未来的技术峰会、喜欢吹假大空技术不同，这次大会完全是面向开发者的毫无套路的技术大会，内容都是来源于身边那些热衷于技术的开发者们平时工作的点滴积累。\n\n例如，我们可以看到博客园常年排名第一的蒋金楠大大，从多个角度出发，向开发者介绍在过去、现在，如何使用.NET/.NET Core的技术实现跨平台应用的开发；\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/tVCggMaeuy4Otn49.png)\n\n以及来自特来电的周国庆老师，把特来电如何构建一个覆盖全国二十万个充电站的过程讲述给大家听，混沌工程，从未离大家如此贴近。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/U8orKf4948oFTT06.png)\n\n除此之外，还有目前在日本从事聚合支付的桂素伟老师也分享了他们使用.NET Core+K8s的开发实践过程，让开发者能够更加深入的了解.NET技术是如何更好的融入到云原生之中。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/sCLVEiNw2fsVvXTC.png)\n\n还有来自中通快递的黄国石老师，把中通基于.NET技术构建实时计算框架的过程也搬上舞台，让大家看到了这双十一一亿订单背后，.NET技术也做出了如此巨大的贡献。 \n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/jjRmo0c3OuEIBzIO.png)\n\n还有来自刘钰老师分享的PowerBI，如何无需编程就能掌握大数据分析的技能，只要使用PowerBI，谁都可以办到。![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/r8YuyEEQ2bQJengS.png)\n\n除了一对多式的讲座，活动还提供了面对面的workshop讲座，在张善友老师、陈计节老师、刘腾飞老师等几位老师花了半天时间向参加工作坊的开发者们介绍如何在azure云中使用k8s的全过程，让大家在互动中学习，产生了非常不错的效果。\n\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/hlroKh2ssdEyvdyY.png)\n\n# 四、结语\n从11月8日的.NET 之夜，到11月9日，11月10日的.NET Conf，我在上海呆了不足三天，有幸作为观众参与到这场活动之中，让我获益匪浅。我不仅仅学到了许多在现有工作经历中无法获取的机会，认识了许多在原来圈子中无法认识的优秀开发者，更让我深刻明白，自身离他们的巨大差距，这将激励我进一步努力。\n\n时光流逝如白驹，短暂而稍纵即逝，如同黄浦江，时而平静流淌，时而泛起波澜，正如我们所亲历的这个时代。\n\n人类从未有过如此般壮阔的变革。无时无刻不在变革，是因为历史的车轮滚滚向，历史眷顾的是坚定者、奋斗者、搏击者。\n\n我相信，我们每个人都将迎来同样更加壮阔的明天，因为我们正赶上了行业互联网大发展的时代、以及.NET发展的大时代。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/vsXjGb1qoVguk6Ik.png)\n\n","source":"_posts/随笔/2019.NET Conf，.NET技术之崛起，已势不可挡.md","raw":"---\ntitle:  2019.NET Conf China（中国.NET开发者峰会），.NET技术之崛起，已势不可挡\ndate: 2019-11-12 8:08\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n\n\n# 一、微软走向开放与.NET Core的诞生\n当今时代，气象更新，技术飞速发展。\n\n当今时代，开发者大概是最优秀的群体。每一位开发者，无不奋勇向前，努力追寻时代的步伐，以大无畏的精神迎接挑战，紧跟大时代成就企业发展的宏伟蓝图的同时，也在实现自己的个人梦想。\n\n微软，无疑便是最善于应对时代变化的英雄，从比尔盖茨选择从哈佛大学创业开始，历经四十年时间，经过了三个变革的时期。每个时代都以其独特的方式深深地鼓舞人心，哪怕历经千辛万苦，哪怕一度前途充满阴霾，也能实现自我价值的刷新，并重回巅峰。\n\n当代的微软，已经从一家技术驱动型公司，变革为一家文化驱动型公司，在纳德拉的领导下，云战略，开放，分享，自我刷新的企业文化精神已经让人们深深的意识到，那个沉睡的巨象一旦觉醒，该有着多么大的魄力和影响力。\n\n大环境已经在悄然改变，在隔壁Java走下坡路时，这边的.NET，也迎来了新的发展机遇。微软不再靠自己一家企业来控制这种优秀的技术，而是成立了一个.NET基金会，他扮演着技术公司于开发者之间的窗口，旨在加强和扩大以.NET技术为核心的技术生态系统。并随着.NET技术交给了社区由基金会来管理，基于.NET的开源生态已经如星火燎然之势蓬勃开展起来。到目前为止该基金会的参与者已经包括谷歌，红帽等知名互联网公司，这么多优秀的企业都参与其中。众人拾柴火焰高，有了这么多企业的积极参与，.NET技术生态已经迎来了前所未有的战略机遇期。\n\n2019年的9月份，在2019年的.NET Conf上已经发布了.NET技术体系下、面向开源和跨平台的技术组件.NET Core3.0，该技术包含了一系列组件和新特性，能够让无论是Web开发者，还是ML.NET开发者，或者是游戏开发者都能直接感受到.NET Core跨平台技术的魅力和价值。\n\n# 二、开发者峰会的诞生\n2019年对于广大.NET开发者来说算是不平凡的一年。在这一年里，在微软云技术社区的支持下、在.NET社区领袖张善友老师、衣明志老师、叶伟民老师、陈作老师、潘淳老师等行业翘楚的摇旗呐喊之下，各地的.NET技术社区（微软.NET俱乐部）如雨后春笋般蓬勃开展起来。\n\n首先是胶东开发者部落的诞生、广州微软.NET俱乐部的复活。\n\n接着是苏州微软.NET俱乐部的诞生。\n\n随后是长沙.NET技术社区、沈阳、东莞、厦门、北京等地区.NET社区的诞生 。\n\n以及随后各地都相继成立了主题为.NET技术或互联网技术的各类线上或线下的技术交流组织，可以说无论你目前身处祖国的哪一个角落，总是能在最近的地域找到一个活跃的技术社区，通过社区能够跟当地的技术大佬们进行充满高质量的技术交流，这对于每一位开发者来说都是非常难能可贵的体验。\n\n除了这些.NET技术社区外，还有数十位.NET开发者们自发运营起主打.NET方向的技术公众号来，通过这些公众号，能够让开发者从全方位多维度了解和学习面向互联网大时代的.NET技术，能够让爱学习的开发者们的技术每时每刻都做好积累。\n\n而且在.NET开发者的主阵地，博客园每天发表的新内容中，与.NET技术相关的话题也越来越多；而且越来越多的优秀的.NET技术书籍也已经付梓，并被出版社相继出版，成为畅销书，还有许多开发者们都相继把他们的写的新书交给了出版社，预计在明年年初将迎来一波.NET技术类书籍的小高潮。\n\n这些都是.NET开发者们迎来的良好机遇，借着行业互联网的逐渐深化、以及.NET技术的进一步推广、技术社区的繁荣昌盛、.NET学习资源的源源不绝，相信开发者们一定能借此良机成就个人的美好梦想。\n\n在这样的大背景之下，为了让.NET开发者们能够更加直观的感受到.NET技术的强大魅力，微软云（Azure)、.NET技术社区的行业翘楚、企业代表、活跃在.NET技术圈的优秀开发者们、以及各地.NET技术社区们，打算干一件大事，这就是本次2019年的.NET Conf，中国.NET 开发者峰会。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/dHeSY1m1vxU7M0xT.png)\n\n有别于一般都是由大型企业组织、或者甚至有微软包办的其他类型技术峰会，这次峰会完全来自.NET技术圈开发者们的无偿付出，我们可以看到，张善友老师经常在他的公众号里发布与Conf有关的资讯，而这些文章的撰写都是来源于社区；我们也可以看到许多精美的海报，这些也是来源于开发者，甚至也许就是我们身边的某位不知名的开发者。还有在活动现场的许多志愿者、主持人，这些都是对.NET 技术充满大爱的优秀开发者；尤其是那些为大家带来精彩内容的老师们，他们有时候为了PPT上的每一页内容，需要花费大量的业余时间；除了这些之外，我们还能看到许多细节，如那些设计精美的PPT、那些设计精良的文化衫、甚至还有那些小巧玲珑的贴纸图案、海报，无一不是来源于社区志愿者的精心奉献。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/aKGIP2ffgY0sBy14.png)\n\n这么多开发者、志愿者、老师们的专注认真、精心设计、严密组织， 从宣传、活动安排、布置、会场组织的每一个细节出发，我们看到的，正是一个充满生机和活力、专业的技术社区，这样的社区，让我们对.NET技术充满了激情，也让我们对未来充满了无限期待。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/c4p8aTPXKyUlWWP5.png)\n\n# 三、精彩纷呈的内容\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/FTy19dQR6V0gtjvx.png)\n\n这次.NET Conf的主题是《开源，共享，创新》，既可以称为社区的主题，也可以拥抱新时代的.net开发者们的共同心声。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/KrzXe1O3egUWHHhN.png)\n\n开源：随着.Net技术推出的新版技术框架.net core已经发布3.0版本，开源社区建设正如同雨后春笋一般蓬勃发展。\n\n共享：.net开发者们，不再选择敝帚自珍，而是以更加开放的心态参与到社区建设之中，共享知识，也是在分享财富。\n\n创新：开发者们拥有的最优秀的品质，在时代的浪潮下，唯有不断刷新，创新，才能始终如一的创造价值。\n\n而围绕主题出发的各种主题也同样贴合了行业发展的大趋势，许多.NET开发者虽然目前从事的领域也许是某些行业应用的开发，但是都说想了解新兴技术是如何运用到其中的，那么这次盛会给了大家机会。在本次峰会上，不仅有开发者职业发展规划的内容，也有.NET Core新的特性介绍，更有许多新兴技术，例如人工智能、实时计算、混沌工程、服务网格、RPA等新潮技术，还有PowerBI、Unity Bot、 ABP等备受期待的传统技术，能够各个让对技术充满兴趣的开发者都能学到自己想学的东西。\n\n我们可以跟随.NET Core项目负责人Scott Hunter一起，看看在.NET Core3.0中，哪些新的特性能够获得怎样的好处。\n\n也可以跟着来自澳大利亚的微软MVPJustin Yoo一起，听听他讲的故事，看看他的职业发展；\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/fXT5Sm9hcmYlKN7X.png)\n\n还可以跟着来自校宝在线的肖伟宇老师一起，看看如何在.NET Core中将检测组件集成到高可用的.NET Core微服务中。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/xolfXf9N2Ngt0ZEw.png)\n\n我们还可以听卢建辉老师谈谈ML.NET 和SciSharp项目以及TensorFlow.NET项目，而这个TensorFlow.NET项目尤其值得大家关注，因为他的主要开发团队，许多成员都是我们身边的、来自中国内地的.NET开发者们，这个项目不仅仅是中国.NET开发者们的小圈子自嗨，更是成为微软人工智能框架ML.NET的基础平台框架，通过这款框架，能够让全世界范围内超过六百二十万.NET开发者们无需转语音，便可畅想人工智能的美妙。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/kWU0c7E8ZgIetK76.png)\n\n而刘腾飞Jesse这位英俊帅气不凡的开发者，也把他们公司踩坑K8s的全过程搬上讲台，用血和汗的教训告诉大家，其实.NET Core什么都能干好，而且不比隔壁家的技术差。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/lsRndjg1IV02vuRj.png)\n\n本次大会与某些大厂组织的自称科技未来的技术峰会、喜欢吹假大空技术不同，这次大会完全是面向开发者的毫无套路的技术大会，内容都是来源于身边那些热衷于技术的开发者们平时工作的点滴积累。\n\n例如，我们可以看到博客园常年排名第一的蒋金楠大大，从多个角度出发，向开发者介绍在过去、现在，如何使用.NET/.NET Core的技术实现跨平台应用的开发；\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/tVCggMaeuy4Otn49.png)\n\n以及来自特来电的周国庆老师，把特来电如何构建一个覆盖全国二十万个充电站的过程讲述给大家听，混沌工程，从未离大家如此贴近。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/U8orKf4948oFTT06.png)\n\n除此之外，还有目前在日本从事聚合支付的桂素伟老师也分享了他们使用.NET Core+K8s的开发实践过程，让开发者能够更加深入的了解.NET技术是如何更好的融入到云原生之中。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/sCLVEiNw2fsVvXTC.png)\n\n还有来自中通快递的黄国石老师，把中通基于.NET技术构建实时计算框架的过程也搬上舞台，让大家看到了这双十一一亿订单背后，.NET技术也做出了如此巨大的贡献。 \n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/jjRmo0c3OuEIBzIO.png)\n\n还有来自刘钰老师分享的PowerBI，如何无需编程就能掌握大数据分析的技能，只要使用PowerBI，谁都可以办到。![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/r8YuyEEQ2bQJengS.png)\n\n除了一对多式的讲座，活动还提供了面对面的workshop讲座，在张善友老师、陈计节老师、刘腾飞老师等几位老师花了半天时间向参加工作坊的开发者们介绍如何在azure云中使用k8s的全过程，让大家在互动中学习，产生了非常不错的效果。\n\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/hlroKh2ssdEyvdyY.png)\n\n# 四、结语\n从11月8日的.NET 之夜，到11月9日，11月10日的.NET Conf，我在上海呆了不足三天，有幸作为观众参与到这场活动之中，让我获益匪浅。我不仅仅学到了许多在现有工作经历中无法获取的机会，认识了许多在原来圈子中无法认识的优秀开发者，更让我深刻明白，自身离他们的巨大差距，这将激励我进一步努力。\n\n时光流逝如白驹，短暂而稍纵即逝，如同黄浦江，时而平静流淌，时而泛起波澜，正如我们所亲历的这个时代。\n\n人类从未有过如此般壮阔的变革。无时无刻不在变革，是因为历史的车轮滚滚向，历史眷顾的是坚定者、奋斗者、搏击者。\n\n我相信，我们每个人都将迎来同样更加壮阔的明天，因为我们正赶上了行业互联网大发展的时代、以及.NET发展的大时代。\n\n![图片](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/vsXjGb1qoVguk6Ik.png)\n\n","slug":"随笔/2019.NET Conf，.NET技术之崛起，已势不可挡","published":1,"updated":"2019-11-12T00:09:56.416Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt8l002sn4viokemlbiu","content":"<h1 id=\"一、微软走向开放与-NET-Core的诞生\"><a href=\"#一、微软走向开放与-NET-Core的诞生\" class=\"headerlink\" title=\"一、微软走向开放与.NET Core的诞生\"></a>一、微软走向开放与.NET Core的诞生</h1><p>当今时代，气象更新，技术飞速发展。</p>\n<p>当今时代，开发者大概是最优秀的群体。每一位开发者，无不奋勇向前，努力追寻时代的步伐，以大无畏的精神迎接挑战，紧跟大时代成就企业发展的宏伟蓝图的同时，也在实现自己的个人梦想。</p>\n<p>微软，无疑便是最善于应对时代变化的英雄，从比尔盖茨选择从哈佛大学创业开始，历经四十年时间，经过了三个变革的时期。每个时代都以其独特的方式深深地鼓舞人心，哪怕历经千辛万苦，哪怕一度前途充满阴霾，也能实现自我价值的刷新，并重回巅峰。</p>\n<p>当代的微软，已经从一家技术驱动型公司，变革为一家文化驱动型公司，在纳德拉的领导下，云战略，开放，分享，自我刷新的企业文化精神已经让人们深深的意识到，那个沉睡的巨象一旦觉醒，该有着多么大的魄力和影响力。</p>\n<p>大环境已经在悄然改变，在隔壁Java走下坡路时，这边的.NET，也迎来了新的发展机遇。微软不再靠自己一家企业来控制这种优秀的技术，而是成立了一个.NET基金会，他扮演着技术公司于开发者之间的窗口，旨在加强和扩大以.NET技术为核心的技术生态系统。并随着.NET技术交给了社区由基金会来管理，基于.NET的开源生态已经如星火燎然之势蓬勃开展起来。到目前为止该基金会的参与者已经包括谷歌，红帽等知名互联网公司，这么多优秀的企业都参与其中。众人拾柴火焰高，有了这么多企业的积极参与，.NET技术生态已经迎来了前所未有的战略机遇期。</p>\n<p>2019年的9月份，在2019年的.NET Conf上已经发布了.NET技术体系下、面向开源和跨平台的技术组件.NET Core3.0，该技术包含了一系列组件和新特性，能够让无论是Web开发者，还是ML.NET开发者，或者是游戏开发者都能直接感受到.NET Core跨平台技术的魅力和价值。</p>\n<h1 id=\"二、开发者峰会的诞生\"><a href=\"#二、开发者峰会的诞生\" class=\"headerlink\" title=\"二、开发者峰会的诞生\"></a>二、开发者峰会的诞生</h1><p>2019年对于广大.NET开发者来说算是不平凡的一年。在这一年里，在微软云技术社区的支持下、在.NET社区领袖张善友老师、衣明志老师、叶伟民老师、陈作老师、潘淳老师等行业翘楚的摇旗呐喊之下，各地的.NET技术社区（微软.NET俱乐部）如雨后春笋般蓬勃开展起来。</p>\n<p>首先是胶东开发者部落的诞生、广州微软.NET俱乐部的复活。</p>\n<p>接着是苏州微软.NET俱乐部的诞生。</p>\n<p>随后是长沙.NET技术社区、沈阳、东莞、厦门、北京等地区.NET社区的诞生 。</p>\n<p>以及随后各地都相继成立了主题为.NET技术或互联网技术的各类线上或线下的技术交流组织，可以说无论你目前身处祖国的哪一个角落，总是能在最近的地域找到一个活跃的技术社区，通过社区能够跟当地的技术大佬们进行充满高质量的技术交流，这对于每一位开发者来说都是非常难能可贵的体验。</p>\n<p>除了这些.NET技术社区外，还有数十位.NET开发者们自发运营起主打.NET方向的技术公众号来，通过这些公众号，能够让开发者从全方位多维度了解和学习面向互联网大时代的.NET技术，能够让爱学习的开发者们的技术每时每刻都做好积累。</p>\n<p>而且在.NET开发者的主阵地，博客园每天发表的新内容中，与.NET技术相关的话题也越来越多；而且越来越多的优秀的.NET技术书籍也已经付梓，并被出版社相继出版，成为畅销书，还有许多开发者们都相继把他们的写的新书交给了出版社，预计在明年年初将迎来一波.NET技术类书籍的小高潮。</p>\n<p>这些都是.NET开发者们迎来的良好机遇，借着行业互联网的逐渐深化、以及.NET技术的进一步推广、技术社区的繁荣昌盛、.NET学习资源的源源不绝，相信开发者们一定能借此良机成就个人的美好梦想。</p>\n<p>在这样的大背景之下，为了让.NET开发者们能够更加直观的感受到.NET技术的强大魅力，微软云（Azure)、.NET技术社区的行业翘楚、企业代表、活跃在.NET技术圈的优秀开发者们、以及各地.NET技术社区们，打算干一件大事，这就是本次2019年的.NET Conf，中国.NET 开发者峰会。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/dHeSY1m1vxU7M0xT.png\" alt=\"图片\"></p>\n<p>有别于一般都是由大型企业组织、或者甚至有微软包办的其他类型技术峰会，这次峰会完全来自.NET技术圈开发者们的无偿付出，我们可以看到，张善友老师经常在他的公众号里发布与Conf有关的资讯，而这些文章的撰写都是来源于社区；我们也可以看到许多精美的海报，这些也是来源于开发者，甚至也许就是我们身边的某位不知名的开发者。还有在活动现场的许多志愿者、主持人，这些都是对.NET 技术充满大爱的优秀开发者；尤其是那些为大家带来精彩内容的老师们，他们有时候为了PPT上的每一页内容，需要花费大量的业余时间；除了这些之外，我们还能看到许多细节，如那些设计精美的PPT、那些设计精良的文化衫、甚至还有那些小巧玲珑的贴纸图案、海报，无一不是来源于社区志愿者的精心奉献。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/aKGIP2ffgY0sBy14.png\" alt=\"图片\"></p>\n<p>这么多开发者、志愿者、老师们的专注认真、精心设计、严密组织， 从宣传、活动安排、布置、会场组织的每一个细节出发，我们看到的，正是一个充满生机和活力、专业的技术社区，这样的社区，让我们对.NET技术充满了激情，也让我们对未来充满了无限期待。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/c4p8aTPXKyUlWWP5.png\" alt=\"图片\"></p>\n<h1 id=\"三、精彩纷呈的内容\"><a href=\"#三、精彩纷呈的内容\" class=\"headerlink\" title=\"三、精彩纷呈的内容\"></a>三、精彩纷呈的内容</h1><p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/FTy19dQR6V0gtjvx.png\" alt=\"图片\"></p>\n<p>这次.NET Conf的主题是《开源，共享，创新》，既可以称为社区的主题，也可以拥抱新时代的.net开发者们的共同心声。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/KrzXe1O3egUWHHhN.png\" alt=\"图片\"></p>\n<p>开源：随着.Net技术推出的新版技术框架.net core已经发布3.0版本，开源社区建设正如同雨后春笋一般蓬勃发展。</p>\n<p>共享：.net开发者们，不再选择敝帚自珍，而是以更加开放的心态参与到社区建设之中，共享知识，也是在分享财富。</p>\n<p>创新：开发者们拥有的最优秀的品质，在时代的浪潮下，唯有不断刷新，创新，才能始终如一的创造价值。</p>\n<p>而围绕主题出发的各种主题也同样贴合了行业发展的大趋势，许多.NET开发者虽然目前从事的领域也许是某些行业应用的开发，但是都说想了解新兴技术是如何运用到其中的，那么这次盛会给了大家机会。在本次峰会上，不仅有开发者职业发展规划的内容，也有.NET Core新的特性介绍，更有许多新兴技术，例如人工智能、实时计算、混沌工程、服务网格、RPA等新潮技术，还有PowerBI、Unity Bot、 ABP等备受期待的传统技术，能够各个让对技术充满兴趣的开发者都能学到自己想学的东西。</p>\n<p>我们可以跟随.NET Core项目负责人Scott Hunter一起，看看在.NET Core3.0中，哪些新的特性能够获得怎样的好处。</p>\n<p>也可以跟着来自澳大利亚的微软MVPJustin Yoo一起，听听他讲的故事，看看他的职业发展；</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/fXT5Sm9hcmYlKN7X.png\" alt=\"图片\"></p>\n<p>还可以跟着来自校宝在线的肖伟宇老师一起，看看如何在.NET Core中将检测组件集成到高可用的.NET Core微服务中。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/xolfXf9N2Ngt0ZEw.png\" alt=\"图片\"></p>\n<p>我们还可以听卢建辉老师谈谈ML.NET 和SciSharp项目以及TensorFlow.NET项目，而这个TensorFlow.NET项目尤其值得大家关注，因为他的主要开发团队，许多成员都是我们身边的、来自中国内地的.NET开发者们，这个项目不仅仅是中国.NET开发者们的小圈子自嗨，更是成为微软人工智能框架ML.NET的基础平台框架，通过这款框架，能够让全世界范围内超过六百二十万.NET开发者们无需转语音，便可畅想人工智能的美妙。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/kWU0c7E8ZgIetK76.png\" alt=\"图片\"></p>\n<p>而刘腾飞Jesse这位英俊帅气不凡的开发者，也把他们公司踩坑K8s的全过程搬上讲台，用血和汗的教训告诉大家，其实.NET Core什么都能干好，而且不比隔壁家的技术差。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/lsRndjg1IV02vuRj.png\" alt=\"图片\"></p>\n<p>本次大会与某些大厂组织的自称科技未来的技术峰会、喜欢吹假大空技术不同，这次大会完全是面向开发者的毫无套路的技术大会，内容都是来源于身边那些热衷于技术的开发者们平时工作的点滴积累。</p>\n<p>例如，我们可以看到博客园常年排名第一的蒋金楠大大，从多个角度出发，向开发者介绍在过去、现在，如何使用.NET/.NET Core的技术实现跨平台应用的开发；</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/tVCggMaeuy4Otn49.png\" alt=\"图片\"></p>\n<p>以及来自特来电的周国庆老师，把特来电如何构建一个覆盖全国二十万个充电站的过程讲述给大家听，混沌工程，从未离大家如此贴近。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/U8orKf4948oFTT06.png\" alt=\"图片\"></p>\n<p>除此之外，还有目前在日本从事聚合支付的桂素伟老师也分享了他们使用.NET Core+K8s的开发实践过程，让开发者能够更加深入的了解.NET技术是如何更好的融入到云原生之中。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/sCLVEiNw2fsVvXTC.png\" alt=\"图片\"></p>\n<p>还有来自中通快递的黄国石老师，把中通基于.NET技术构建实时计算框架的过程也搬上舞台，让大家看到了这双十一一亿订单背后，.NET技术也做出了如此巨大的贡献。 </p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/jjRmo0c3OuEIBzIO.png\" alt=\"图片\"></p>\n<p>还有来自刘钰老师分享的PowerBI，如何无需编程就能掌握大数据分析的技能，只要使用PowerBI，谁都可以办到。<img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/r8YuyEEQ2bQJengS.png\" alt=\"图片\"></p>\n<p>除了一对多式的讲座，活动还提供了面对面的workshop讲座，在张善友老师、陈计节老师、刘腾飞老师等几位老师花了半天时间向参加工作坊的开发者们介绍如何在azure云中使用k8s的全过程，让大家在互动中学习，产生了非常不错的效果。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/hlroKh2ssdEyvdyY.png\" alt=\"图片\"></p>\n<h1 id=\"四、结语\"><a href=\"#四、结语\" class=\"headerlink\" title=\"四、结语\"></a>四、结语</h1><p>从11月8日的.NET 之夜，到11月9日，11月10日的.NET Conf，我在上海呆了不足三天，有幸作为观众参与到这场活动之中，让我获益匪浅。我不仅仅学到了许多在现有工作经历中无法获取的机会，认识了许多在原来圈子中无法认识的优秀开发者，更让我深刻明白，自身离他们的巨大差距，这将激励我进一步努力。</p>\n<p>时光流逝如白驹，短暂而稍纵即逝，如同黄浦江，时而平静流淌，时而泛起波澜，正如我们所亲历的这个时代。</p>\n<p>人类从未有过如此般壮阔的变革。无时无刻不在变革，是因为历史的车轮滚滚向，历史眷顾的是坚定者、奋斗者、搏击者。</p>\n<p>我相信，我们每个人都将迎来同样更加壮阔的明天，因为我们正赶上了行业互联网大发展的时代、以及.NET发展的大时代。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/vsXjGb1qoVguk6Ik.png\" alt=\"图片\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、微软走向开放与-NET-Core的诞生\"><a href=\"#一、微软走向开放与-NET-Core的诞生\" class=\"headerlink\" title=\"一、微软走向开放与.NET Core的诞生\"></a>一、微软走向开放与.NET Core的诞生</h1><p>当今时代，气象更新，技术飞速发展。</p>\n<p>当今时代，开发者大概是最优秀的群体。每一位开发者，无不奋勇向前，努力追寻时代的步伐，以大无畏的精神迎接挑战，紧跟大时代成就企业发展的宏伟蓝图的同时，也在实现自己的个人梦想。</p>\n<p>微软，无疑便是最善于应对时代变化的英雄，从比尔盖茨选择从哈佛大学创业开始，历经四十年时间，经过了三个变革的时期。每个时代都以其独特的方式深深地鼓舞人心，哪怕历经千辛万苦，哪怕一度前途充满阴霾，也能实现自我价值的刷新，并重回巅峰。</p>\n<p>当代的微软，已经从一家技术驱动型公司，变革为一家文化驱动型公司，在纳德拉的领导下，云战略，开放，分享，自我刷新的企业文化精神已经让人们深深的意识到，那个沉睡的巨象一旦觉醒，该有着多么大的魄力和影响力。</p>\n<p>大环境已经在悄然改变，在隔壁Java走下坡路时，这边的.NET，也迎来了新的发展机遇。微软不再靠自己一家企业来控制这种优秀的技术，而是成立了一个.NET基金会，他扮演着技术公司于开发者之间的窗口，旨在加强和扩大以.NET技术为核心的技术生态系统。并随着.NET技术交给了社区由基金会来管理，基于.NET的开源生态已经如星火燎然之势蓬勃开展起来。到目前为止该基金会的参与者已经包括谷歌，红帽等知名互联网公司，这么多优秀的企业都参与其中。众人拾柴火焰高，有了这么多企业的积极参与，.NET技术生态已经迎来了前所未有的战略机遇期。</p>\n<p>2019年的9月份，在2019年的.NET Conf上已经发布了.NET技术体系下、面向开源和跨平台的技术组件.NET Core3.0，该技术包含了一系列组件和新特性，能够让无论是Web开发者，还是ML.NET开发者，或者是游戏开发者都能直接感受到.NET Core跨平台技术的魅力和价值。</p>\n<h1 id=\"二、开发者峰会的诞生\"><a href=\"#二、开发者峰会的诞生\" class=\"headerlink\" title=\"二、开发者峰会的诞生\"></a>二、开发者峰会的诞生</h1><p>2019年对于广大.NET开发者来说算是不平凡的一年。在这一年里，在微软云技术社区的支持下、在.NET社区领袖张善友老师、衣明志老师、叶伟民老师、陈作老师、潘淳老师等行业翘楚的摇旗呐喊之下，各地的.NET技术社区（微软.NET俱乐部）如雨后春笋般蓬勃开展起来。</p>\n<p>首先是胶东开发者部落的诞生、广州微软.NET俱乐部的复活。</p>\n<p>接着是苏州微软.NET俱乐部的诞生。</p>\n<p>随后是长沙.NET技术社区、沈阳、东莞、厦门、北京等地区.NET社区的诞生 。</p>\n<p>以及随后各地都相继成立了主题为.NET技术或互联网技术的各类线上或线下的技术交流组织，可以说无论你目前身处祖国的哪一个角落，总是能在最近的地域找到一个活跃的技术社区，通过社区能够跟当地的技术大佬们进行充满高质量的技术交流，这对于每一位开发者来说都是非常难能可贵的体验。</p>\n<p>除了这些.NET技术社区外，还有数十位.NET开发者们自发运营起主打.NET方向的技术公众号来，通过这些公众号，能够让开发者从全方位多维度了解和学习面向互联网大时代的.NET技术，能够让爱学习的开发者们的技术每时每刻都做好积累。</p>\n<p>而且在.NET开发者的主阵地，博客园每天发表的新内容中，与.NET技术相关的话题也越来越多；而且越来越多的优秀的.NET技术书籍也已经付梓，并被出版社相继出版，成为畅销书，还有许多开发者们都相继把他们的写的新书交给了出版社，预计在明年年初将迎来一波.NET技术类书籍的小高潮。</p>\n<p>这些都是.NET开发者们迎来的良好机遇，借着行业互联网的逐渐深化、以及.NET技术的进一步推广、技术社区的繁荣昌盛、.NET学习资源的源源不绝，相信开发者们一定能借此良机成就个人的美好梦想。</p>\n<p>在这样的大背景之下，为了让.NET开发者们能够更加直观的感受到.NET技术的强大魅力，微软云（Azure)、.NET技术社区的行业翘楚、企业代表、活跃在.NET技术圈的优秀开发者们、以及各地.NET技术社区们，打算干一件大事，这就是本次2019年的.NET Conf，中国.NET 开发者峰会。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/dHeSY1m1vxU7M0xT.png\" alt=\"图片\"></p>\n<p>有别于一般都是由大型企业组织、或者甚至有微软包办的其他类型技术峰会，这次峰会完全来自.NET技术圈开发者们的无偿付出，我们可以看到，张善友老师经常在他的公众号里发布与Conf有关的资讯，而这些文章的撰写都是来源于社区；我们也可以看到许多精美的海报，这些也是来源于开发者，甚至也许就是我们身边的某位不知名的开发者。还有在活动现场的许多志愿者、主持人，这些都是对.NET 技术充满大爱的优秀开发者；尤其是那些为大家带来精彩内容的老师们，他们有时候为了PPT上的每一页内容，需要花费大量的业余时间；除了这些之外，我们还能看到许多细节，如那些设计精美的PPT、那些设计精良的文化衫、甚至还有那些小巧玲珑的贴纸图案、海报，无一不是来源于社区志愿者的精心奉献。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/aKGIP2ffgY0sBy14.png\" alt=\"图片\"></p>\n<p>这么多开发者、志愿者、老师们的专注认真、精心设计、严密组织， 从宣传、活动安排、布置、会场组织的每一个细节出发，我们看到的，正是一个充满生机和活力、专业的技术社区，这样的社区，让我们对.NET技术充满了激情，也让我们对未来充满了无限期待。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/c4p8aTPXKyUlWWP5.png\" alt=\"图片\"></p>\n<h1 id=\"三、精彩纷呈的内容\"><a href=\"#三、精彩纷呈的内容\" class=\"headerlink\" title=\"三、精彩纷呈的内容\"></a>三、精彩纷呈的内容</h1><p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/FTy19dQR6V0gtjvx.png\" alt=\"图片\"></p>\n<p>这次.NET Conf的主题是《开源，共享，创新》，既可以称为社区的主题，也可以拥抱新时代的.net开发者们的共同心声。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/KrzXe1O3egUWHHhN.png\" alt=\"图片\"></p>\n<p>开源：随着.Net技术推出的新版技术框架.net core已经发布3.0版本，开源社区建设正如同雨后春笋一般蓬勃发展。</p>\n<p>共享：.net开发者们，不再选择敝帚自珍，而是以更加开放的心态参与到社区建设之中，共享知识，也是在分享财富。</p>\n<p>创新：开发者们拥有的最优秀的品质，在时代的浪潮下，唯有不断刷新，创新，才能始终如一的创造价值。</p>\n<p>而围绕主题出发的各种主题也同样贴合了行业发展的大趋势，许多.NET开发者虽然目前从事的领域也许是某些行业应用的开发，但是都说想了解新兴技术是如何运用到其中的，那么这次盛会给了大家机会。在本次峰会上，不仅有开发者职业发展规划的内容，也有.NET Core新的特性介绍，更有许多新兴技术，例如人工智能、实时计算、混沌工程、服务网格、RPA等新潮技术，还有PowerBI、Unity Bot、 ABP等备受期待的传统技术，能够各个让对技术充满兴趣的开发者都能学到自己想学的东西。</p>\n<p>我们可以跟随.NET Core项目负责人Scott Hunter一起，看看在.NET Core3.0中，哪些新的特性能够获得怎样的好处。</p>\n<p>也可以跟着来自澳大利亚的微软MVPJustin Yoo一起，听听他讲的故事，看看他的职业发展；</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/fXT5Sm9hcmYlKN7X.png\" alt=\"图片\"></p>\n<p>还可以跟着来自校宝在线的肖伟宇老师一起，看看如何在.NET Core中将检测组件集成到高可用的.NET Core微服务中。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/xolfXf9N2Ngt0ZEw.png\" alt=\"图片\"></p>\n<p>我们还可以听卢建辉老师谈谈ML.NET 和SciSharp项目以及TensorFlow.NET项目，而这个TensorFlow.NET项目尤其值得大家关注，因为他的主要开发团队，许多成员都是我们身边的、来自中国内地的.NET开发者们，这个项目不仅仅是中国.NET开发者们的小圈子自嗨，更是成为微软人工智能框架ML.NET的基础平台框架，通过这款框架，能够让全世界范围内超过六百二十万.NET开发者们无需转语音，便可畅想人工智能的美妙。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/kWU0c7E8ZgIetK76.png\" alt=\"图片\"></p>\n<p>而刘腾飞Jesse这位英俊帅气不凡的开发者，也把他们公司踩坑K8s的全过程搬上讲台，用血和汗的教训告诉大家，其实.NET Core什么都能干好，而且不比隔壁家的技术差。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/lsRndjg1IV02vuRj.png\" alt=\"图片\"></p>\n<p>本次大会与某些大厂组织的自称科技未来的技术峰会、喜欢吹假大空技术不同，这次大会完全是面向开发者的毫无套路的技术大会，内容都是来源于身边那些热衷于技术的开发者们平时工作的点滴积累。</p>\n<p>例如，我们可以看到博客园常年排名第一的蒋金楠大大，从多个角度出发，向开发者介绍在过去、现在，如何使用.NET/.NET Core的技术实现跨平台应用的开发；</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/tVCggMaeuy4Otn49.png\" alt=\"图片\"></p>\n<p>以及来自特来电的周国庆老师，把特来电如何构建一个覆盖全国二十万个充电站的过程讲述给大家听，混沌工程，从未离大家如此贴近。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/U8orKf4948oFTT06.png\" alt=\"图片\"></p>\n<p>除此之外，还有目前在日本从事聚合支付的桂素伟老师也分享了他们使用.NET Core+K8s的开发实践过程，让开发者能够更加深入的了解.NET技术是如何更好的融入到云原生之中。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/sCLVEiNw2fsVvXTC.png\" alt=\"图片\"></p>\n<p>还有来自中通快递的黄国石老师，把中通基于.NET技术构建实时计算框架的过程也搬上舞台，让大家看到了这双十一一亿订单背后，.NET技术也做出了如此巨大的贡献。 </p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/jjRmo0c3OuEIBzIO.png\" alt=\"图片\"></p>\n<p>还有来自刘钰老师分享的PowerBI，如何无需编程就能掌握大数据分析的技能，只要使用PowerBI，谁都可以办到。<img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/r8YuyEEQ2bQJengS.png\" alt=\"图片\"></p>\n<p>除了一对多式的讲座，活动还提供了面对面的workshop讲座，在张善友老师、陈计节老师、刘腾飞老师等几位老师花了半天时间向参加工作坊的开发者们介绍如何在azure云中使用k8s的全过程，让大家在互动中学习，产生了非常不错的效果。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/hlroKh2ssdEyvdyY.png\" alt=\"图片\"></p>\n<h1 id=\"四、结语\"><a href=\"#四、结语\" class=\"headerlink\" title=\"四、结语\"></a>四、结语</h1><p>从11月8日的.NET 之夜，到11月9日，11月10日的.NET Conf，我在上海呆了不足三天，有幸作为观众参与到这场活动之中，让我获益匪浅。我不仅仅学到了许多在现有工作经历中无法获取的机会，认识了许多在原来圈子中无法认识的优秀开发者，更让我深刻明白，自身离他们的巨大差距，这将激励我进一步努力。</p>\n<p>时光流逝如白驹，短暂而稍纵即逝，如同黄浦江，时而平静流淌，时而泛起波澜，正如我们所亲历的这个时代。</p>\n<p>人类从未有过如此般壮阔的变革。无时无刻不在变革，是因为历史的车轮滚滚向，历史眷顾的是坚定者、奋斗者、搏击者。</p>\n<p>我相信，我们每个人都将迎来同样更加壮阔的明天，因为我们正赶上了行业互联网大发展的时代、以及.NET发展的大时代。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/netconf2019/vsXjGb1qoVguk6Ik.png\" alt=\"图片\"></p>\n"},{"title":"2019年年终总结，静候时光与一步一个脚印","date":"2020-01-03T01:10:00.000Z","author":"邹溪源","_content":"不知不觉，一晃年关将近，即将翻开2019，进入新的一页。\n\n这周已经在朋友圈看到了来自公众号《恰同学少年》《Edi.Wang》和《吃草的罗汉》几位老师写下的年终总结，他们的年终总结让我感想颇多，对自己的2019年也感想颇深，对2020年也充满期待，是时候对过去一年的一些感悟做一个简单的总结了。\n\n# 关于“云程序员”\n在2[018年的年终总结](https://www.cnblogs.com/xiyuanMore/p/10171587.html)中，与其说是一个总结，不如说是写了一堆漂亮话，其实真正落地的flag太少，而且总结不够彻底，没有起到总结经验，反思教训的意义。\n\n总体上来说，我应该做个对技术充满热情和追求的开发者，而在去年的年终总结大概也只表达了一个意思，不要做云程序员，不要做云程序员，不要做云程序员。\n\n而2019年，我的目标就是回归本质，不做云程序员，从现在来看，至少从思维模式上，已经发生了很大的变化，至少“我觉得xxx技术也不过如此”“我以为xxx技术不过是xxx”这样的主观评判的口气已经不会在说了。\n\n之所以成为“云程序员”，大概是来源于过去若干年有意无意的习惯使然。\n\n有时候得承认，越是中小公司，越容易培养所谓通才，因为公司的发展尚处于摸石头过河的阶段，往往需要在纷繁复杂的混沌乱局中寻找一切可以生存的机会，这也意味着中小企业对开发者的要求几乎都是招之能来，来之能战，战之能胜的通才。中小企业也并没有太多职业生涯规划或培训指导的工作安排，所以工程师的成长往往需要靠自己的方式。\n\n大部分所谓成长，其实是在憋工龄，在一个又一个圈子中绕来绕去。你会用到许多东西，实际上你无法学到真正属于自己的技能。有时候会贪图掌握更多知识，尤其是新技术，于是就开始走在了云程序员的路上。似乎许多中小企业出来的开发者更喜欢自称为全栈工程师，并自称自己什么都会，有的甚至会因此而对那些真正从事技术领域的专业开发者带有偏见，以为他们是死脑筋，其实往往是井底之蛙的个人之见。\n\n专业公司的培养形式是以提高效率为目标的工业化培养形式，对专才的要求也越来越高。IT是一个复杂程度丝毫不亚于其他产业的系统工程，它涉及的领域和技术非常多，几乎每一个方面都值得人花一辈子去认真探究。事实上只有优秀的公司才有可能培养出专才，而且才有这样的土壤，能够让一些开发者能够把时间花在某些专业领域持续学习和研究，然后让知识产生价值。\n\n规模越大、越优秀的公司越容易对开发者产生吸引力，除了其待遇问题外，往往是因为这些公司专业化程度更高，也意味着你更容易快速成长，因为专注于一个领域显然比无法专注于一个领域更能带来更快的成长。从软件研发岗位来说，当你在某些技术方向上的深度上到一定程度，再来扩充广度时，也更容易吸收到有用的东西。当然，现在互联网公司也逐渐开始往通才发展，因为掌握全局思维的开发者更容易做出产品，但是互联网公司和中小企业的通才区别依然比较大。互联网公司需要的是具备互联网思维，能够把自己一块小天地处理完美，还能兼顾其他人工作的可复用型T字型人才，而小企业要的大概是一字型人才。\n\n尤其对于长沙这座小城市而言，更难以发现专注于某些领域的开发者，或许与企业规模和职业定位有一定的关系，其实哪怕优秀如BAT或华为，也或许无法找到太多某些领域的专业开发者，除了公司的客观因素，与开发者们的主观选择也有关系。当然，不管在大公司或小公司，这不能妨碍我们成为专业开发者，只是意味着如果我们要成为某些领域的大牛，得花更多的时间和精力来经营自己的领域。\n\n 当然，专业/不专业，云程序员/非云程序员或许本身不重要，毕竟对于大部分开发者来说，选择IT知识混口饭吃。而对于有追求的开发者来说，更应该长期的职业发展全局均衡，而不要仅仅关注眼前的利益。尤其在目前这个时代，你的每一段职场，其实不仅仅在为金钱工作，而是为你的简历工作。如何从你的职场中积累对未来发展有价值的东西，才是核心关键的因素。不论你在哪家公司，总会有许多让你收获颇多的东西。常怀感恩之心，用心去发现价值，总能让你成为正能量的传播者。这样的你，既是公司最宝贵的财富，也同时会让你成为人群中的闪光点。 \n\n# 关于软件研发技能\n如前文所说，软件领域是一个非常复杂的系统工程，每一个专业领域都值得人花一辈子去努力钻研，但是对于大部分开发者来说其实无需如此，往往只需花几年时间，就能快速吸取到IT软件发展的精髓，并成长为公司的核心人员。\n\n当你成长起来之后，或许会以为框架就是技术的王道；也会以为软件就是工具+框架的结合，而忽略了更具有普遍意义的基础技能和算法能力；在抽象化思维上，在过程式思维这条路上越走越远，也极大的局限了开发者的成长；你会以为只有底层代码才是代码，业务代码或增删改查就不是代码；你会以为写文档、写PPT的人都是吹牛逼的。这些都是开发者的怪毛病\n\n软件研发技能确实是一个值得仔细探究的核心领域，哪怕简单到一句需求的描述，也需要用系统性思维来思考这个问题。\n\n回顾过去，我总是在想，我真的懂得做项目么，真的懂得如何做好一个软件么？我做的项目是否还有进一步可以提高的空间？如何优雅的收集客户需求，如何优雅的打造完美的产品？如何优雅的做好一个项目？如何让每一个项目都成为标杆项目？如何从失败中吸取经验教训。好吧，我有点啰嗦。\n\n做一个软件真的并非想象中那么简单，需要将行业思维与IT思维更加完美的融合，既要从更高的战略层面思考问题，又要从代码的微观层面思考问题，有思考有设计、有碰撞有火花，这恰好是软件工程最大的魅力所在。\n\n# 关于读书\n2019年看了大概20-30本书，并写了超过15篇书评。包括以下书籍，我认为这些书籍给我带来的无穷收获，远超这些书本身的货币价值。\n\n《领域驱动设计-软件系统核心复杂性应对之道》：这本书来自埃文斯-埃里克的书，是一本经典的领域驱动设计的书，在2018年8月我开始认真阅读其中的每个文字，并让我对领域驱动有了更深层次的理解；今年我还通过GitChat购买了张逸老师的领域驱动设计的课程，张逸老师不愧为领域驱动设计方面的专家，他用自己的经验解释了领域驱动设计，让我对这本书、以及相关知识都有了系统而全面的了解，同时还通过这一个课程了解了更多的知识领域，对健全我的知识体系产生了巨大的作用。\n\n《中台》：来自阿里巴巴钟春老师的中台，这本书介绍了阿里巴巴中台建设的历程，这本书造出了一个独特的中国概念，也刷新了我的知识观，虽然短期来看我所经历的企业都没有中台的打算，但能够让我具备全局性思维来思考IT体系建设的问题。\n\n《小团队、大架构》：来自张清辉老师，这本书介绍了携程的.NET技术架构转型过程，让我对.NET架构的演进方向有了明确的认识。当然这本书过多的介绍轮子，许多读者或许不喜欢，如果跟《微服务架构模式》一起交替的看，一定会产生不错的效果。\n\n 《构建之法》：来自邹欣老师，这本书介绍了软件工程师的成长和微软的IT管理模式，让我能够静下来思考当下自己的发展方向。作为一个拥有十年工作经验的开发者，已经陷入了一个以自我为中心的乖蹇，而周筠老师对我的悉心教导，也让我非常感动，我也要持续努力，坚定自己的发展方向，努力做一个脚踏实地的开发者。\n\n《浪潮之巅》共两卷：这是吴军老师的作品，吴军老师的质朴清新，不刻意使用过多的辞藻铺垫的写作风格让我获益匪浅，同时讲述的一个个故事又是如此的引人入胜。从故事中，我们看到了一群充满梦想的年轻人们，他们在互联网的浪潮之下做出的选择，是如何一点一点的改变了世界。\n\n《实例化需求》：这是一本介绍BDD模式的书，介绍了行为驱动开发这种模式，让我获得了新的知识。当然短期内用不起来，但多学一点总不会吃亏。 \n\n除此之外还有：《代码整洁之道》、《重构-改善既有代码的艺术2》、《持续交付2.0》、《PMBook》（好吧，考了12月的pmp，把pmbook看了四遍）、《程序员的三门课》、《Http/2基础教程》、《混乱：如何成为失控时代的掌控者》、《我的世界观》、《算法图解》、《未来简史》、《刷新》、《修炼之道》、《猎豹行动》、《单元测试的艺术》和刚刚读完的《华为方法论》。\n\n这20几本书都是不同方向的书，与能够读完50本书或更多的优秀前辈们相比确实还存在一点差距，当然这些书有精读有略读，甚至有的其实是牛嚼牡丹，值得以后细细品味。\n\n有的书着实发人深省带来了许多启迪，有的书则让我的知识体系进一步全面，不过从书到知识到技能，还需要进一步实践、修炼和理解，不然依然是走在云程序员的路上。 \n\n# 关于社区\n 2019年比较大的成绩，拉了一个技术社区应该算是一个；从2月的酝酿，到4月的落地，花了不少的精力，而且这些都是利用业余时间完成的，连筹款都是靠社区大佬、微软、腾讯运加以及社区朋友们的大力支持。也把公众号从80开始，做到了目前的5000+，这些也算是小收获吧，不过没什么骄傲的，毕竟那么多人都是从零开始，做到万粉大号。\n\n从某种意义上来说，社区似乎离大家都比较远。有时候会感觉试图打造社区来凝聚开发者，其实是一厢情愿。技术社区，或许只会给那些拥有开放性基因的企业和开发者带来好处，并有望助力企业的进一步腾飞。尤其在长沙，究竟有几家企业拥有开放的技术心态？这是个问题。长沙的技术氛围着实令人窒息。\n\n我们总是渴望打造一个优秀开发者社区。其实优秀开发者本身是一个不好衡量的问题，毕竟成为前百分之二十已经是优秀者，而张一鸣口中的那百分之一的精英，本身就并非一朝一夕所能炼成。\n\n最终还是落在产出上，你助力企业腾飞、或者你做出了优秀的产品、或者你能够具备自己的系统性思维，并能写出一辆本书；优秀有太多种了，每一种都来之不易。\n\n一个所谓社区，如果没有形成长期有价值的积累，没能打造优秀的平台，最终走向消亡反而会是“众望所归”。如何让社区避免成为水群、如何发掘更多优秀开发者，形成精英小圈子，我想说每个人都得继续努力，最起码不能成为一个菜市场，否则这样的圈子，其实毫无价值。\n\n有时候会发现，每个群都是那么几个固定的人，沉迷于群其实根本不能带来个人成长，真正的成长还是得静下来自己认真学习。\n\n要成为优秀开发者，有时候三天打鱼，两天晒网的刻意憋一点大招，表面上看能带来一点好气象，但是过了那个热度就被客观条件或主观条件抛弃。技术这东西真得坚持个三五年，才真的能够成长起来。有的人，看到这个火，就追逐这个，看到那个热门就赶潮流搞那个，一边写着代码，一边想着明年是不是该转行，这样的学习方式如何能够提高自己？\n\n从这一点上来看，我只想说我已经在努力朝着好的方向进步，但是还远远不够，与那些已经坚持优秀习惯五年、十年之久的开发者相比，我需要做的远远不止眼前这一点点。\n\n# 关于2020年的计划\n有时候不太想列过于宏大的计划，因为往往计划会变成插红旗，然后在自己的背上插满了红旗，变成了一个京剧里面的大英雄。这样的计划或许毫无意义。\n\n所以还是得认真思考，踏踏实实的做几个能够落地的计划：\n\n  * 1、勿忘初衷，踏实前进：不吹水，不装逼。做一位优秀的专业开发者，在专业方向上持续形成系统性思维。\n  * 2、减法和加法：\n    * 有感于今年随着参与了社区活动，加的群也越来越多了，2020年得在这一点上多做减法。\n    * 有时候追逐于信息的热度，其实大部分都与我毫无关系。为何关注这些东西？还是八卦性思维的束缚，这一点也有做减法。\n    * 而知识体系的厚度上则需要做加法，多看书，多思考。朋友圈做加法，并非多交更多的朋友，而是都跟优秀的朋友交流沟通，吸取他们的优点，转化成自己的优点。\n  * 3、写满一百篇博客，看五十本书。\n  * 4、也得学Edsion周同学锻炼身体了。\n  * 5、努力践行积极乐观向上的团队文化、努力培养一支有战斗力的学习型团队。\n\n超过30岁的开发者总是会焦虑于自己的职业发展，不知道自己的未来该如何选择，那大概是由于想得太多，做得太少。\n\n行走在IT这条路，成长太快反而不是好事，只有脚踏实地，一步一个脚印，才能真正无所畏惧。 “易定者无感，易感者无定。”，谋划好未来，并经营自己的当下，才有美好未来。\n\n","source":"_posts/随笔/2019年年终总结，静候时光与一步一个脚印.md","raw":"---\ntitle:  2019年年终总结，静候时光与一步一个脚印\ndate: 2020-01-03 9:10\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n不知不觉，一晃年关将近，即将翻开2019，进入新的一页。\n\n这周已经在朋友圈看到了来自公众号《恰同学少年》《Edi.Wang》和《吃草的罗汉》几位老师写下的年终总结，他们的年终总结让我感想颇多，对自己的2019年也感想颇深，对2020年也充满期待，是时候对过去一年的一些感悟做一个简单的总结了。\n\n# 关于“云程序员”\n在2[018年的年终总结](https://www.cnblogs.com/xiyuanMore/p/10171587.html)中，与其说是一个总结，不如说是写了一堆漂亮话，其实真正落地的flag太少，而且总结不够彻底，没有起到总结经验，反思教训的意义。\n\n总体上来说，我应该做个对技术充满热情和追求的开发者，而在去年的年终总结大概也只表达了一个意思，不要做云程序员，不要做云程序员，不要做云程序员。\n\n而2019年，我的目标就是回归本质，不做云程序员，从现在来看，至少从思维模式上，已经发生了很大的变化，至少“我觉得xxx技术也不过如此”“我以为xxx技术不过是xxx”这样的主观评判的口气已经不会在说了。\n\n之所以成为“云程序员”，大概是来源于过去若干年有意无意的习惯使然。\n\n有时候得承认，越是中小公司，越容易培养所谓通才，因为公司的发展尚处于摸石头过河的阶段，往往需要在纷繁复杂的混沌乱局中寻找一切可以生存的机会，这也意味着中小企业对开发者的要求几乎都是招之能来，来之能战，战之能胜的通才。中小企业也并没有太多职业生涯规划或培训指导的工作安排，所以工程师的成长往往需要靠自己的方式。\n\n大部分所谓成长，其实是在憋工龄，在一个又一个圈子中绕来绕去。你会用到许多东西，实际上你无法学到真正属于自己的技能。有时候会贪图掌握更多知识，尤其是新技术，于是就开始走在了云程序员的路上。似乎许多中小企业出来的开发者更喜欢自称为全栈工程师，并自称自己什么都会，有的甚至会因此而对那些真正从事技术领域的专业开发者带有偏见，以为他们是死脑筋，其实往往是井底之蛙的个人之见。\n\n专业公司的培养形式是以提高效率为目标的工业化培养形式，对专才的要求也越来越高。IT是一个复杂程度丝毫不亚于其他产业的系统工程，它涉及的领域和技术非常多，几乎每一个方面都值得人花一辈子去认真探究。事实上只有优秀的公司才有可能培养出专才，而且才有这样的土壤，能够让一些开发者能够把时间花在某些专业领域持续学习和研究，然后让知识产生价值。\n\n规模越大、越优秀的公司越容易对开发者产生吸引力，除了其待遇问题外，往往是因为这些公司专业化程度更高，也意味着你更容易快速成长，因为专注于一个领域显然比无法专注于一个领域更能带来更快的成长。从软件研发岗位来说，当你在某些技术方向上的深度上到一定程度，再来扩充广度时，也更容易吸收到有用的东西。当然，现在互联网公司也逐渐开始往通才发展，因为掌握全局思维的开发者更容易做出产品，但是互联网公司和中小企业的通才区别依然比较大。互联网公司需要的是具备互联网思维，能够把自己一块小天地处理完美，还能兼顾其他人工作的可复用型T字型人才，而小企业要的大概是一字型人才。\n\n尤其对于长沙这座小城市而言，更难以发现专注于某些领域的开发者，或许与企业规模和职业定位有一定的关系，其实哪怕优秀如BAT或华为，也或许无法找到太多某些领域的专业开发者，除了公司的客观因素，与开发者们的主观选择也有关系。当然，不管在大公司或小公司，这不能妨碍我们成为专业开发者，只是意味着如果我们要成为某些领域的大牛，得花更多的时间和精力来经营自己的领域。\n\n 当然，专业/不专业，云程序员/非云程序员或许本身不重要，毕竟对于大部分开发者来说，选择IT知识混口饭吃。而对于有追求的开发者来说，更应该长期的职业发展全局均衡，而不要仅仅关注眼前的利益。尤其在目前这个时代，你的每一段职场，其实不仅仅在为金钱工作，而是为你的简历工作。如何从你的职场中积累对未来发展有价值的东西，才是核心关键的因素。不论你在哪家公司，总会有许多让你收获颇多的东西。常怀感恩之心，用心去发现价值，总能让你成为正能量的传播者。这样的你，既是公司最宝贵的财富，也同时会让你成为人群中的闪光点。 \n\n# 关于软件研发技能\n如前文所说，软件领域是一个非常复杂的系统工程，每一个专业领域都值得人花一辈子去努力钻研，但是对于大部分开发者来说其实无需如此，往往只需花几年时间，就能快速吸取到IT软件发展的精髓，并成长为公司的核心人员。\n\n当你成长起来之后，或许会以为框架就是技术的王道；也会以为软件就是工具+框架的结合，而忽略了更具有普遍意义的基础技能和算法能力；在抽象化思维上，在过程式思维这条路上越走越远，也极大的局限了开发者的成长；你会以为只有底层代码才是代码，业务代码或增删改查就不是代码；你会以为写文档、写PPT的人都是吹牛逼的。这些都是开发者的怪毛病\n\n软件研发技能确实是一个值得仔细探究的核心领域，哪怕简单到一句需求的描述，也需要用系统性思维来思考这个问题。\n\n回顾过去，我总是在想，我真的懂得做项目么，真的懂得如何做好一个软件么？我做的项目是否还有进一步可以提高的空间？如何优雅的收集客户需求，如何优雅的打造完美的产品？如何优雅的做好一个项目？如何让每一个项目都成为标杆项目？如何从失败中吸取经验教训。好吧，我有点啰嗦。\n\n做一个软件真的并非想象中那么简单，需要将行业思维与IT思维更加完美的融合，既要从更高的战略层面思考问题，又要从代码的微观层面思考问题，有思考有设计、有碰撞有火花，这恰好是软件工程最大的魅力所在。\n\n# 关于读书\n2019年看了大概20-30本书，并写了超过15篇书评。包括以下书籍，我认为这些书籍给我带来的无穷收获，远超这些书本身的货币价值。\n\n《领域驱动设计-软件系统核心复杂性应对之道》：这本书来自埃文斯-埃里克的书，是一本经典的领域驱动设计的书，在2018年8月我开始认真阅读其中的每个文字，并让我对领域驱动有了更深层次的理解；今年我还通过GitChat购买了张逸老师的领域驱动设计的课程，张逸老师不愧为领域驱动设计方面的专家，他用自己的经验解释了领域驱动设计，让我对这本书、以及相关知识都有了系统而全面的了解，同时还通过这一个课程了解了更多的知识领域，对健全我的知识体系产生了巨大的作用。\n\n《中台》：来自阿里巴巴钟春老师的中台，这本书介绍了阿里巴巴中台建设的历程，这本书造出了一个独特的中国概念，也刷新了我的知识观，虽然短期来看我所经历的企业都没有中台的打算，但能够让我具备全局性思维来思考IT体系建设的问题。\n\n《小团队、大架构》：来自张清辉老师，这本书介绍了携程的.NET技术架构转型过程，让我对.NET架构的演进方向有了明确的认识。当然这本书过多的介绍轮子，许多读者或许不喜欢，如果跟《微服务架构模式》一起交替的看，一定会产生不错的效果。\n\n 《构建之法》：来自邹欣老师，这本书介绍了软件工程师的成长和微软的IT管理模式，让我能够静下来思考当下自己的发展方向。作为一个拥有十年工作经验的开发者，已经陷入了一个以自我为中心的乖蹇，而周筠老师对我的悉心教导，也让我非常感动，我也要持续努力，坚定自己的发展方向，努力做一个脚踏实地的开发者。\n\n《浪潮之巅》共两卷：这是吴军老师的作品，吴军老师的质朴清新，不刻意使用过多的辞藻铺垫的写作风格让我获益匪浅，同时讲述的一个个故事又是如此的引人入胜。从故事中，我们看到了一群充满梦想的年轻人们，他们在互联网的浪潮之下做出的选择，是如何一点一点的改变了世界。\n\n《实例化需求》：这是一本介绍BDD模式的书，介绍了行为驱动开发这种模式，让我获得了新的知识。当然短期内用不起来，但多学一点总不会吃亏。 \n\n除此之外还有：《代码整洁之道》、《重构-改善既有代码的艺术2》、《持续交付2.0》、《PMBook》（好吧，考了12月的pmp，把pmbook看了四遍）、《程序员的三门课》、《Http/2基础教程》、《混乱：如何成为失控时代的掌控者》、《我的世界观》、《算法图解》、《未来简史》、《刷新》、《修炼之道》、《猎豹行动》、《单元测试的艺术》和刚刚读完的《华为方法论》。\n\n这20几本书都是不同方向的书，与能够读完50本书或更多的优秀前辈们相比确实还存在一点差距，当然这些书有精读有略读，甚至有的其实是牛嚼牡丹，值得以后细细品味。\n\n有的书着实发人深省带来了许多启迪，有的书则让我的知识体系进一步全面，不过从书到知识到技能，还需要进一步实践、修炼和理解，不然依然是走在云程序员的路上。 \n\n# 关于社区\n 2019年比较大的成绩，拉了一个技术社区应该算是一个；从2月的酝酿，到4月的落地，花了不少的精力，而且这些都是利用业余时间完成的，连筹款都是靠社区大佬、微软、腾讯运加以及社区朋友们的大力支持。也把公众号从80开始，做到了目前的5000+，这些也算是小收获吧，不过没什么骄傲的，毕竟那么多人都是从零开始，做到万粉大号。\n\n从某种意义上来说，社区似乎离大家都比较远。有时候会感觉试图打造社区来凝聚开发者，其实是一厢情愿。技术社区，或许只会给那些拥有开放性基因的企业和开发者带来好处，并有望助力企业的进一步腾飞。尤其在长沙，究竟有几家企业拥有开放的技术心态？这是个问题。长沙的技术氛围着实令人窒息。\n\n我们总是渴望打造一个优秀开发者社区。其实优秀开发者本身是一个不好衡量的问题，毕竟成为前百分之二十已经是优秀者，而张一鸣口中的那百分之一的精英，本身就并非一朝一夕所能炼成。\n\n最终还是落在产出上，你助力企业腾飞、或者你做出了优秀的产品、或者你能够具备自己的系统性思维，并能写出一辆本书；优秀有太多种了，每一种都来之不易。\n\n一个所谓社区，如果没有形成长期有价值的积累，没能打造优秀的平台，最终走向消亡反而会是“众望所归”。如何让社区避免成为水群、如何发掘更多优秀开发者，形成精英小圈子，我想说每个人都得继续努力，最起码不能成为一个菜市场，否则这样的圈子，其实毫无价值。\n\n有时候会发现，每个群都是那么几个固定的人，沉迷于群其实根本不能带来个人成长，真正的成长还是得静下来自己认真学习。\n\n要成为优秀开发者，有时候三天打鱼，两天晒网的刻意憋一点大招，表面上看能带来一点好气象，但是过了那个热度就被客观条件或主观条件抛弃。技术这东西真得坚持个三五年，才真的能够成长起来。有的人，看到这个火，就追逐这个，看到那个热门就赶潮流搞那个，一边写着代码，一边想着明年是不是该转行，这样的学习方式如何能够提高自己？\n\n从这一点上来看，我只想说我已经在努力朝着好的方向进步，但是还远远不够，与那些已经坚持优秀习惯五年、十年之久的开发者相比，我需要做的远远不止眼前这一点点。\n\n# 关于2020年的计划\n有时候不太想列过于宏大的计划，因为往往计划会变成插红旗，然后在自己的背上插满了红旗，变成了一个京剧里面的大英雄。这样的计划或许毫无意义。\n\n所以还是得认真思考，踏踏实实的做几个能够落地的计划：\n\n  * 1、勿忘初衷，踏实前进：不吹水，不装逼。做一位优秀的专业开发者，在专业方向上持续形成系统性思维。\n  * 2、减法和加法：\n    * 有感于今年随着参与了社区活动，加的群也越来越多了，2020年得在这一点上多做减法。\n    * 有时候追逐于信息的热度，其实大部分都与我毫无关系。为何关注这些东西？还是八卦性思维的束缚，这一点也有做减法。\n    * 而知识体系的厚度上则需要做加法，多看书，多思考。朋友圈做加法，并非多交更多的朋友，而是都跟优秀的朋友交流沟通，吸取他们的优点，转化成自己的优点。\n  * 3、写满一百篇博客，看五十本书。\n  * 4、也得学Edsion周同学锻炼身体了。\n  * 5、努力践行积极乐观向上的团队文化、努力培养一支有战斗力的学习型团队。\n\n超过30岁的开发者总是会焦虑于自己的职业发展，不知道自己的未来该如何选择，那大概是由于想得太多，做得太少。\n\n行走在IT这条路，成长太快反而不是好事，只有脚踏实地，一步一个脚印，才能真正无所畏惧。 “易定者无感，易感者无定。”，谋划好未来，并经营自己的当下，才有美好未来。\n\n","slug":"随笔/2019年年终总结，静候时光与一步一个脚印","published":1,"updated":"2020-01-03T00:54:07.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt8n002wn4vigpj5m9mw","content":"<p>不知不觉，一晃年关将近，即将翻开2019，进入新的一页。</p>\n<p>这周已经在朋友圈看到了来自公众号《恰同学少年》《Edi.Wang》和《吃草的罗汉》几位老师写下的年终总结，他们的年终总结让我感想颇多，对自己的2019年也感想颇深，对2020年也充满期待，是时候对过去一年的一些感悟做一个简单的总结了。</p>\n<h1 id=\"关于“云程序员”\"><a href=\"#关于“云程序员”\" class=\"headerlink\" title=\"关于“云程序员”\"></a>关于“云程序员”</h1><p>在2<a href=\"https://www.cnblogs.com/xiyuanMore/p/10171587.html\" target=\"_blank\" rel=\"noopener\">018年的年终总结</a>中，与其说是一个总结，不如说是写了一堆漂亮话，其实真正落地的flag太少，而且总结不够彻底，没有起到总结经验，反思教训的意义。</p>\n<p>总体上来说，我应该做个对技术充满热情和追求的开发者，而在去年的年终总结大概也只表达了一个意思，不要做云程序员，不要做云程序员，不要做云程序员。</p>\n<p>而2019年，我的目标就是回归本质，不做云程序员，从现在来看，至少从思维模式上，已经发生了很大的变化，至少“我觉得xxx技术也不过如此”“我以为xxx技术不过是xxx”这样的主观评判的口气已经不会在说了。</p>\n<p>之所以成为“云程序员”，大概是来源于过去若干年有意无意的习惯使然。</p>\n<p>有时候得承认，越是中小公司，越容易培养所谓通才，因为公司的发展尚处于摸石头过河的阶段，往往需要在纷繁复杂的混沌乱局中寻找一切可以生存的机会，这也意味着中小企业对开发者的要求几乎都是招之能来，来之能战，战之能胜的通才。中小企业也并没有太多职业生涯规划或培训指导的工作安排，所以工程师的成长往往需要靠自己的方式。</p>\n<p>大部分所谓成长，其实是在憋工龄，在一个又一个圈子中绕来绕去。你会用到许多东西，实际上你无法学到真正属于自己的技能。有时候会贪图掌握更多知识，尤其是新技术，于是就开始走在了云程序员的路上。似乎许多中小企业出来的开发者更喜欢自称为全栈工程师，并自称自己什么都会，有的甚至会因此而对那些真正从事技术领域的专业开发者带有偏见，以为他们是死脑筋，其实往往是井底之蛙的个人之见。</p>\n<p>专业公司的培养形式是以提高效率为目标的工业化培养形式，对专才的要求也越来越高。IT是一个复杂程度丝毫不亚于其他产业的系统工程，它涉及的领域和技术非常多，几乎每一个方面都值得人花一辈子去认真探究。事实上只有优秀的公司才有可能培养出专才，而且才有这样的土壤，能够让一些开发者能够把时间花在某些专业领域持续学习和研究，然后让知识产生价值。</p>\n<p>规模越大、越优秀的公司越容易对开发者产生吸引力，除了其待遇问题外，往往是因为这些公司专业化程度更高，也意味着你更容易快速成长，因为专注于一个领域显然比无法专注于一个领域更能带来更快的成长。从软件研发岗位来说，当你在某些技术方向上的深度上到一定程度，再来扩充广度时，也更容易吸收到有用的东西。当然，现在互联网公司也逐渐开始往通才发展，因为掌握全局思维的开发者更容易做出产品，但是互联网公司和中小企业的通才区别依然比较大。互联网公司需要的是具备互联网思维，能够把自己一块小天地处理完美，还能兼顾其他人工作的可复用型T字型人才，而小企业要的大概是一字型人才。</p>\n<p>尤其对于长沙这座小城市而言，更难以发现专注于某些领域的开发者，或许与企业规模和职业定位有一定的关系，其实哪怕优秀如BAT或华为，也或许无法找到太多某些领域的专业开发者，除了公司的客观因素，与开发者们的主观选择也有关系。当然，不管在大公司或小公司，这不能妨碍我们成为专业开发者，只是意味着如果我们要成为某些领域的大牛，得花更多的时间和精力来经营自己的领域。</p>\n<p> 当然，专业/不专业，云程序员/非云程序员或许本身不重要，毕竟对于大部分开发者来说，选择IT知识混口饭吃。而对于有追求的开发者来说，更应该长期的职业发展全局均衡，而不要仅仅关注眼前的利益。尤其在目前这个时代，你的每一段职场，其实不仅仅在为金钱工作，而是为你的简历工作。如何从你的职场中积累对未来发展有价值的东西，才是核心关键的因素。不论你在哪家公司，总会有许多让你收获颇多的东西。常怀感恩之心，用心去发现价值，总能让你成为正能量的传播者。这样的你，既是公司最宝贵的财富，也同时会让你成为人群中的闪光点。 </p>\n<h1 id=\"关于软件研发技能\"><a href=\"#关于软件研发技能\" class=\"headerlink\" title=\"关于软件研发技能\"></a>关于软件研发技能</h1><p>如前文所说，软件领域是一个非常复杂的系统工程，每一个专业领域都值得人花一辈子去努力钻研，但是对于大部分开发者来说其实无需如此，往往只需花几年时间，就能快速吸取到IT软件发展的精髓，并成长为公司的核心人员。</p>\n<p>当你成长起来之后，或许会以为框架就是技术的王道；也会以为软件就是工具+框架的结合，而忽略了更具有普遍意义的基础技能和算法能力；在抽象化思维上，在过程式思维这条路上越走越远，也极大的局限了开发者的成长；你会以为只有底层代码才是代码，业务代码或增删改查就不是代码；你会以为写文档、写PPT的人都是吹牛逼的。这些都是开发者的怪毛病</p>\n<p>软件研发技能确实是一个值得仔细探究的核心领域，哪怕简单到一句需求的描述，也需要用系统性思维来思考这个问题。</p>\n<p>回顾过去，我总是在想，我真的懂得做项目么，真的懂得如何做好一个软件么？我做的项目是否还有进一步可以提高的空间？如何优雅的收集客户需求，如何优雅的打造完美的产品？如何优雅的做好一个项目？如何让每一个项目都成为标杆项目？如何从失败中吸取经验教训。好吧，我有点啰嗦。</p>\n<p>做一个软件真的并非想象中那么简单，需要将行业思维与IT思维更加完美的融合，既要从更高的战略层面思考问题，又要从代码的微观层面思考问题，有思考有设计、有碰撞有火花，这恰好是软件工程最大的魅力所在。</p>\n<h1 id=\"关于读书\"><a href=\"#关于读书\" class=\"headerlink\" title=\"关于读书\"></a>关于读书</h1><p>2019年看了大概20-30本书，并写了超过15篇书评。包括以下书籍，我认为这些书籍给我带来的无穷收获，远超这些书本身的货币价值。</p>\n<p>《领域驱动设计-软件系统核心复杂性应对之道》：这本书来自埃文斯-埃里克的书，是一本经典的领域驱动设计的书，在2018年8月我开始认真阅读其中的每个文字，并让我对领域驱动有了更深层次的理解；今年我还通过GitChat购买了张逸老师的领域驱动设计的课程，张逸老师不愧为领域驱动设计方面的专家，他用自己的经验解释了领域驱动设计，让我对这本书、以及相关知识都有了系统而全面的了解，同时还通过这一个课程了解了更多的知识领域，对健全我的知识体系产生了巨大的作用。</p>\n<p>《中台》：来自阿里巴巴钟春老师的中台，这本书介绍了阿里巴巴中台建设的历程，这本书造出了一个独特的中国概念，也刷新了我的知识观，虽然短期来看我所经历的企业都没有中台的打算，但能够让我具备全局性思维来思考IT体系建设的问题。</p>\n<p>《小团队、大架构》：来自张清辉老师，这本书介绍了携程的.NET技术架构转型过程，让我对.NET架构的演进方向有了明确的认识。当然这本书过多的介绍轮子，许多读者或许不喜欢，如果跟《微服务架构模式》一起交替的看，一定会产生不错的效果。</p>\n<p> 《构建之法》：来自邹欣老师，这本书介绍了软件工程师的成长和微软的IT管理模式，让我能够静下来思考当下自己的发展方向。作为一个拥有十年工作经验的开发者，已经陷入了一个以自我为中心的乖蹇，而周筠老师对我的悉心教导，也让我非常感动，我也要持续努力，坚定自己的发展方向，努力做一个脚踏实地的开发者。</p>\n<p>《浪潮之巅》共两卷：这是吴军老师的作品，吴军老师的质朴清新，不刻意使用过多的辞藻铺垫的写作风格让我获益匪浅，同时讲述的一个个故事又是如此的引人入胜。从故事中，我们看到了一群充满梦想的年轻人们，他们在互联网的浪潮之下做出的选择，是如何一点一点的改变了世界。</p>\n<p>《实例化需求》：这是一本介绍BDD模式的书，介绍了行为驱动开发这种模式，让我获得了新的知识。当然短期内用不起来，但多学一点总不会吃亏。 </p>\n<p>除此之外还有：《代码整洁之道》、《重构-改善既有代码的艺术2》、《持续交付2.0》、《PMBook》（好吧，考了12月的pmp，把pmbook看了四遍）、《程序员的三门课》、《Http/2基础教程》、《混乱：如何成为失控时代的掌控者》、《我的世界观》、《算法图解》、《未来简史》、《刷新》、《修炼之道》、《猎豹行动》、《单元测试的艺术》和刚刚读完的《华为方法论》。</p>\n<p>这20几本书都是不同方向的书，与能够读完50本书或更多的优秀前辈们相比确实还存在一点差距，当然这些书有精读有略读，甚至有的其实是牛嚼牡丹，值得以后细细品味。</p>\n<p>有的书着实发人深省带来了许多启迪，有的书则让我的知识体系进一步全面，不过从书到知识到技能，还需要进一步实践、修炼和理解，不然依然是走在云程序员的路上。 </p>\n<h1 id=\"关于社区\"><a href=\"#关于社区\" class=\"headerlink\" title=\"关于社区\"></a>关于社区</h1><p> 2019年比较大的成绩，拉了一个技术社区应该算是一个；从2月的酝酿，到4月的落地，花了不少的精力，而且这些都是利用业余时间完成的，连筹款都是靠社区大佬、微软、腾讯运加以及社区朋友们的大力支持。也把公众号从80开始，做到了目前的5000+，这些也算是小收获吧，不过没什么骄傲的，毕竟那么多人都是从零开始，做到万粉大号。</p>\n<p>从某种意义上来说，社区似乎离大家都比较远。有时候会感觉试图打造社区来凝聚开发者，其实是一厢情愿。技术社区，或许只会给那些拥有开放性基因的企业和开发者带来好处，并有望助力企业的进一步腾飞。尤其在长沙，究竟有几家企业拥有开放的技术心态？这是个问题。长沙的技术氛围着实令人窒息。</p>\n<p>我们总是渴望打造一个优秀开发者社区。其实优秀开发者本身是一个不好衡量的问题，毕竟成为前百分之二十已经是优秀者，而张一鸣口中的那百分之一的精英，本身就并非一朝一夕所能炼成。</p>\n<p>最终还是落在产出上，你助力企业腾飞、或者你做出了优秀的产品、或者你能够具备自己的系统性思维，并能写出一辆本书；优秀有太多种了，每一种都来之不易。</p>\n<p>一个所谓社区，如果没有形成长期有价值的积累，没能打造优秀的平台，最终走向消亡反而会是“众望所归”。如何让社区避免成为水群、如何发掘更多优秀开发者，形成精英小圈子，我想说每个人都得继续努力，最起码不能成为一个菜市场，否则这样的圈子，其实毫无价值。</p>\n<p>有时候会发现，每个群都是那么几个固定的人，沉迷于群其实根本不能带来个人成长，真正的成长还是得静下来自己认真学习。</p>\n<p>要成为优秀开发者，有时候三天打鱼，两天晒网的刻意憋一点大招，表面上看能带来一点好气象，但是过了那个热度就被客观条件或主观条件抛弃。技术这东西真得坚持个三五年，才真的能够成长起来。有的人，看到这个火，就追逐这个，看到那个热门就赶潮流搞那个，一边写着代码，一边想着明年是不是该转行，这样的学习方式如何能够提高自己？</p>\n<p>从这一点上来看，我只想说我已经在努力朝着好的方向进步，但是还远远不够，与那些已经坚持优秀习惯五年、十年之久的开发者相比，我需要做的远远不止眼前这一点点。</p>\n<h1 id=\"关于2020年的计划\"><a href=\"#关于2020年的计划\" class=\"headerlink\" title=\"关于2020年的计划\"></a>关于2020年的计划</h1><p>有时候不太想列过于宏大的计划，因为往往计划会变成插红旗，然后在自己的背上插满了红旗，变成了一个京剧里面的大英雄。这样的计划或许毫无意义。</p>\n<p>所以还是得认真思考，踏踏实实的做几个能够落地的计划：</p>\n<ul>\n<li>1、勿忘初衷，踏实前进：不吹水，不装逼。做一位优秀的专业开发者，在专业方向上持续形成系统性思维。</li>\n<li>2、减法和加法：<ul>\n<li>有感于今年随着参与了社区活动，加的群也越来越多了，2020年得在这一点上多做减法。</li>\n<li>有时候追逐于信息的热度，其实大部分都与我毫无关系。为何关注这些东西？还是八卦性思维的束缚，这一点也有做减法。</li>\n<li>而知识体系的厚度上则需要做加法，多看书，多思考。朋友圈做加法，并非多交更多的朋友，而是都跟优秀的朋友交流沟通，吸取他们的优点，转化成自己的优点。</li>\n</ul>\n</li>\n<li>3、写满一百篇博客，看五十本书。</li>\n<li>4、也得学Edsion周同学锻炼身体了。</li>\n<li>5、努力践行积极乐观向上的团队文化、努力培养一支有战斗力的学习型团队。</li>\n</ul>\n<p>超过30岁的开发者总是会焦虑于自己的职业发展，不知道自己的未来该如何选择，那大概是由于想得太多，做得太少。</p>\n<p>行走在IT这条路，成长太快反而不是好事，只有脚踏实地，一步一个脚印，才能真正无所畏惧。 “易定者无感，易感者无定。”，谋划好未来，并经营自己的当下，才有美好未来。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>不知不觉，一晃年关将近，即将翻开2019，进入新的一页。</p>\n<p>这周已经在朋友圈看到了来自公众号《恰同学少年》《Edi.Wang》和《吃草的罗汉》几位老师写下的年终总结，他们的年终总结让我感想颇多，对自己的2019年也感想颇深，对2020年也充满期待，是时候对过去一年的一些感悟做一个简单的总结了。</p>\n<h1 id=\"关于“云程序员”\"><a href=\"#关于“云程序员”\" class=\"headerlink\" title=\"关于“云程序员”\"></a>关于“云程序员”</h1><p>在2<a href=\"https://www.cnblogs.com/xiyuanMore/p/10171587.html\" target=\"_blank\" rel=\"noopener\">018年的年终总结</a>中，与其说是一个总结，不如说是写了一堆漂亮话，其实真正落地的flag太少，而且总结不够彻底，没有起到总结经验，反思教训的意义。</p>\n<p>总体上来说，我应该做个对技术充满热情和追求的开发者，而在去年的年终总结大概也只表达了一个意思，不要做云程序员，不要做云程序员，不要做云程序员。</p>\n<p>而2019年，我的目标就是回归本质，不做云程序员，从现在来看，至少从思维模式上，已经发生了很大的变化，至少“我觉得xxx技术也不过如此”“我以为xxx技术不过是xxx”这样的主观评判的口气已经不会在说了。</p>\n<p>之所以成为“云程序员”，大概是来源于过去若干年有意无意的习惯使然。</p>\n<p>有时候得承认，越是中小公司，越容易培养所谓通才，因为公司的发展尚处于摸石头过河的阶段，往往需要在纷繁复杂的混沌乱局中寻找一切可以生存的机会，这也意味着中小企业对开发者的要求几乎都是招之能来，来之能战，战之能胜的通才。中小企业也并没有太多职业生涯规划或培训指导的工作安排，所以工程师的成长往往需要靠自己的方式。</p>\n<p>大部分所谓成长，其实是在憋工龄，在一个又一个圈子中绕来绕去。你会用到许多东西，实际上你无法学到真正属于自己的技能。有时候会贪图掌握更多知识，尤其是新技术，于是就开始走在了云程序员的路上。似乎许多中小企业出来的开发者更喜欢自称为全栈工程师，并自称自己什么都会，有的甚至会因此而对那些真正从事技术领域的专业开发者带有偏见，以为他们是死脑筋，其实往往是井底之蛙的个人之见。</p>\n<p>专业公司的培养形式是以提高效率为目标的工业化培养形式，对专才的要求也越来越高。IT是一个复杂程度丝毫不亚于其他产业的系统工程，它涉及的领域和技术非常多，几乎每一个方面都值得人花一辈子去认真探究。事实上只有优秀的公司才有可能培养出专才，而且才有这样的土壤，能够让一些开发者能够把时间花在某些专业领域持续学习和研究，然后让知识产生价值。</p>\n<p>规模越大、越优秀的公司越容易对开发者产生吸引力，除了其待遇问题外，往往是因为这些公司专业化程度更高，也意味着你更容易快速成长，因为专注于一个领域显然比无法专注于一个领域更能带来更快的成长。从软件研发岗位来说，当你在某些技术方向上的深度上到一定程度，再来扩充广度时，也更容易吸收到有用的东西。当然，现在互联网公司也逐渐开始往通才发展，因为掌握全局思维的开发者更容易做出产品，但是互联网公司和中小企业的通才区别依然比较大。互联网公司需要的是具备互联网思维，能够把自己一块小天地处理完美，还能兼顾其他人工作的可复用型T字型人才，而小企业要的大概是一字型人才。</p>\n<p>尤其对于长沙这座小城市而言，更难以发现专注于某些领域的开发者，或许与企业规模和职业定位有一定的关系，其实哪怕优秀如BAT或华为，也或许无法找到太多某些领域的专业开发者，除了公司的客观因素，与开发者们的主观选择也有关系。当然，不管在大公司或小公司，这不能妨碍我们成为专业开发者，只是意味着如果我们要成为某些领域的大牛，得花更多的时间和精力来经营自己的领域。</p>\n<p> 当然，专业/不专业，云程序员/非云程序员或许本身不重要，毕竟对于大部分开发者来说，选择IT知识混口饭吃。而对于有追求的开发者来说，更应该长期的职业发展全局均衡，而不要仅仅关注眼前的利益。尤其在目前这个时代，你的每一段职场，其实不仅仅在为金钱工作，而是为你的简历工作。如何从你的职场中积累对未来发展有价值的东西，才是核心关键的因素。不论你在哪家公司，总会有许多让你收获颇多的东西。常怀感恩之心，用心去发现价值，总能让你成为正能量的传播者。这样的你，既是公司最宝贵的财富，也同时会让你成为人群中的闪光点。 </p>\n<h1 id=\"关于软件研发技能\"><a href=\"#关于软件研发技能\" class=\"headerlink\" title=\"关于软件研发技能\"></a>关于软件研发技能</h1><p>如前文所说，软件领域是一个非常复杂的系统工程，每一个专业领域都值得人花一辈子去努力钻研，但是对于大部分开发者来说其实无需如此，往往只需花几年时间，就能快速吸取到IT软件发展的精髓，并成长为公司的核心人员。</p>\n<p>当你成长起来之后，或许会以为框架就是技术的王道；也会以为软件就是工具+框架的结合，而忽略了更具有普遍意义的基础技能和算法能力；在抽象化思维上，在过程式思维这条路上越走越远，也极大的局限了开发者的成长；你会以为只有底层代码才是代码，业务代码或增删改查就不是代码；你会以为写文档、写PPT的人都是吹牛逼的。这些都是开发者的怪毛病</p>\n<p>软件研发技能确实是一个值得仔细探究的核心领域，哪怕简单到一句需求的描述，也需要用系统性思维来思考这个问题。</p>\n<p>回顾过去，我总是在想，我真的懂得做项目么，真的懂得如何做好一个软件么？我做的项目是否还有进一步可以提高的空间？如何优雅的收集客户需求，如何优雅的打造完美的产品？如何优雅的做好一个项目？如何让每一个项目都成为标杆项目？如何从失败中吸取经验教训。好吧，我有点啰嗦。</p>\n<p>做一个软件真的并非想象中那么简单，需要将行业思维与IT思维更加完美的融合，既要从更高的战略层面思考问题，又要从代码的微观层面思考问题，有思考有设计、有碰撞有火花，这恰好是软件工程最大的魅力所在。</p>\n<h1 id=\"关于读书\"><a href=\"#关于读书\" class=\"headerlink\" title=\"关于读书\"></a>关于读书</h1><p>2019年看了大概20-30本书，并写了超过15篇书评。包括以下书籍，我认为这些书籍给我带来的无穷收获，远超这些书本身的货币价值。</p>\n<p>《领域驱动设计-软件系统核心复杂性应对之道》：这本书来自埃文斯-埃里克的书，是一本经典的领域驱动设计的书，在2018年8月我开始认真阅读其中的每个文字，并让我对领域驱动有了更深层次的理解；今年我还通过GitChat购买了张逸老师的领域驱动设计的课程，张逸老师不愧为领域驱动设计方面的专家，他用自己的经验解释了领域驱动设计，让我对这本书、以及相关知识都有了系统而全面的了解，同时还通过这一个课程了解了更多的知识领域，对健全我的知识体系产生了巨大的作用。</p>\n<p>《中台》：来自阿里巴巴钟春老师的中台，这本书介绍了阿里巴巴中台建设的历程，这本书造出了一个独特的中国概念，也刷新了我的知识观，虽然短期来看我所经历的企业都没有中台的打算，但能够让我具备全局性思维来思考IT体系建设的问题。</p>\n<p>《小团队、大架构》：来自张清辉老师，这本书介绍了携程的.NET技术架构转型过程，让我对.NET架构的演进方向有了明确的认识。当然这本书过多的介绍轮子，许多读者或许不喜欢，如果跟《微服务架构模式》一起交替的看，一定会产生不错的效果。</p>\n<p> 《构建之法》：来自邹欣老师，这本书介绍了软件工程师的成长和微软的IT管理模式，让我能够静下来思考当下自己的发展方向。作为一个拥有十年工作经验的开发者，已经陷入了一个以自我为中心的乖蹇，而周筠老师对我的悉心教导，也让我非常感动，我也要持续努力，坚定自己的发展方向，努力做一个脚踏实地的开发者。</p>\n<p>《浪潮之巅》共两卷：这是吴军老师的作品，吴军老师的质朴清新，不刻意使用过多的辞藻铺垫的写作风格让我获益匪浅，同时讲述的一个个故事又是如此的引人入胜。从故事中，我们看到了一群充满梦想的年轻人们，他们在互联网的浪潮之下做出的选择，是如何一点一点的改变了世界。</p>\n<p>《实例化需求》：这是一本介绍BDD模式的书，介绍了行为驱动开发这种模式，让我获得了新的知识。当然短期内用不起来，但多学一点总不会吃亏。 </p>\n<p>除此之外还有：《代码整洁之道》、《重构-改善既有代码的艺术2》、《持续交付2.0》、《PMBook》（好吧，考了12月的pmp，把pmbook看了四遍）、《程序员的三门课》、《Http/2基础教程》、《混乱：如何成为失控时代的掌控者》、《我的世界观》、《算法图解》、《未来简史》、《刷新》、《修炼之道》、《猎豹行动》、《单元测试的艺术》和刚刚读完的《华为方法论》。</p>\n<p>这20几本书都是不同方向的书，与能够读完50本书或更多的优秀前辈们相比确实还存在一点差距，当然这些书有精读有略读，甚至有的其实是牛嚼牡丹，值得以后细细品味。</p>\n<p>有的书着实发人深省带来了许多启迪，有的书则让我的知识体系进一步全面，不过从书到知识到技能，还需要进一步实践、修炼和理解，不然依然是走在云程序员的路上。 </p>\n<h1 id=\"关于社区\"><a href=\"#关于社区\" class=\"headerlink\" title=\"关于社区\"></a>关于社区</h1><p> 2019年比较大的成绩，拉了一个技术社区应该算是一个；从2月的酝酿，到4月的落地，花了不少的精力，而且这些都是利用业余时间完成的，连筹款都是靠社区大佬、微软、腾讯运加以及社区朋友们的大力支持。也把公众号从80开始，做到了目前的5000+，这些也算是小收获吧，不过没什么骄傲的，毕竟那么多人都是从零开始，做到万粉大号。</p>\n<p>从某种意义上来说，社区似乎离大家都比较远。有时候会感觉试图打造社区来凝聚开发者，其实是一厢情愿。技术社区，或许只会给那些拥有开放性基因的企业和开发者带来好处，并有望助力企业的进一步腾飞。尤其在长沙，究竟有几家企业拥有开放的技术心态？这是个问题。长沙的技术氛围着实令人窒息。</p>\n<p>我们总是渴望打造一个优秀开发者社区。其实优秀开发者本身是一个不好衡量的问题，毕竟成为前百分之二十已经是优秀者，而张一鸣口中的那百分之一的精英，本身就并非一朝一夕所能炼成。</p>\n<p>最终还是落在产出上，你助力企业腾飞、或者你做出了优秀的产品、或者你能够具备自己的系统性思维，并能写出一辆本书；优秀有太多种了，每一种都来之不易。</p>\n<p>一个所谓社区，如果没有形成长期有价值的积累，没能打造优秀的平台，最终走向消亡反而会是“众望所归”。如何让社区避免成为水群、如何发掘更多优秀开发者，形成精英小圈子，我想说每个人都得继续努力，最起码不能成为一个菜市场，否则这样的圈子，其实毫无价值。</p>\n<p>有时候会发现，每个群都是那么几个固定的人，沉迷于群其实根本不能带来个人成长，真正的成长还是得静下来自己认真学习。</p>\n<p>要成为优秀开发者，有时候三天打鱼，两天晒网的刻意憋一点大招，表面上看能带来一点好气象，但是过了那个热度就被客观条件或主观条件抛弃。技术这东西真得坚持个三五年，才真的能够成长起来。有的人，看到这个火，就追逐这个，看到那个热门就赶潮流搞那个，一边写着代码，一边想着明年是不是该转行，这样的学习方式如何能够提高自己？</p>\n<p>从这一点上来看，我只想说我已经在努力朝着好的方向进步，但是还远远不够，与那些已经坚持优秀习惯五年、十年之久的开发者相比，我需要做的远远不止眼前这一点点。</p>\n<h1 id=\"关于2020年的计划\"><a href=\"#关于2020年的计划\" class=\"headerlink\" title=\"关于2020年的计划\"></a>关于2020年的计划</h1><p>有时候不太想列过于宏大的计划，因为往往计划会变成插红旗，然后在自己的背上插满了红旗，变成了一个京剧里面的大英雄。这样的计划或许毫无意义。</p>\n<p>所以还是得认真思考，踏踏实实的做几个能够落地的计划：</p>\n<ul>\n<li>1、勿忘初衷，踏实前进：不吹水，不装逼。做一位优秀的专业开发者，在专业方向上持续形成系统性思维。</li>\n<li>2、减法和加法：<ul>\n<li>有感于今年随着参与了社区活动，加的群也越来越多了，2020年得在这一点上多做减法。</li>\n<li>有时候追逐于信息的热度，其实大部分都与我毫无关系。为何关注这些东西？还是八卦性思维的束缚，这一点也有做减法。</li>\n<li>而知识体系的厚度上则需要做加法，多看书，多思考。朋友圈做加法，并非多交更多的朋友，而是都跟优秀的朋友交流沟通，吸取他们的优点，转化成自己的优点。</li>\n</ul>\n</li>\n<li>3、写满一百篇博客，看五十本书。</li>\n<li>4、也得学Edsion周同学锻炼身体了。</li>\n<li>5、努力践行积极乐观向上的团队文化、努力培养一支有战斗力的学习型团队。</li>\n</ul>\n<p>超过30岁的开发者总是会焦虑于自己的职业发展，不知道自己的未来该如何选择，那大概是由于想得太多，做得太少。</p>\n<p>行走在IT这条路，成长太快反而不是好事，只有脚踏实地，一步一个脚印，才能真正无所畏惧。 “易定者无感，易感者无定。”，谋划好未来，并经营自己的当下，才有美好未来。</p>\n"},{"title":"2019.Net Conf，我们的共同期待","date":"2019-11-04T00:08:00.000Z","author":"邹溪源","_content":"\n\n\n## （一）回顾一个小社区红过的五分钟\n不知不觉，距离中国.net社区组织的.net conf只有不到一周的时间，还记得年初在叶伟民老师，潘淳老师和张善友老师的号召下，我们长沙的十几位开发者自发组织起来，拉了一个技术社区，并在腾讯云加社区、微软Azure云技术社区的大力支持，在华邦互联、百师通教育、校管家、心莱科技、长沙冉星信息、深圳纵网长沙分公司、北大青鸟海纳学院等优秀企业的赞助下，在四月组织了一次技术大会，上午场邀请到了张善友老师、梁桐铭老师和汪鹏老师，下午场邀请到了腾讯云的胡李伟老师和卓伟老师，一天的分享安排的满满当当，在小城长沙的.net技术圈掀起了一波小浪潮。\n\n不过大概我们几个996程序员们和几位创业者们的业余时间着实有点匮乏，许下了不少宏伟蓝图，转眼间就把自己的flag吞掉，让组织者之一我感觉到颇为尴尬。一个优秀的社区，一定得持续的把活动拉起来，让更多优秀开发者能够在这里传递更多正能量，让技术的星星之火点燃，推向更加广阔的人群。只有更多的人参与进来，社区之水能够源远流长的持续不断的流下去，才能真正获得长效的发展。\n\n不过显然，虽然企业和开发者都对一个积极优秀的社区充满兴趣，但是却缺少真正能够站出来积极拉动社区的开发者，由于社区初成立、大部分参与者都只是以看热闹的态度，这也让那些对原本充满热情的早期参与者的热情熄灭，很快就偃旗息鼓，然后社区就看起来名存实亡了。\n\n无论是作为组织者的我们，或者是做为观众的开发者们，对社区期许过高。总是高估了自己的计划能力，组织者们太想更早的出成绩、有时候又心态不纯，想借此机会获得一些虚名，但是一旦遇到挫折就会浇灭火苗，然后曾经的豪言壮语都将成为泡影。而作为参与者，确实苦于没有社区这样一个集体，于是总想着更早的看到成绩，然后发现这个社区其实有点名不副实之后，就失去兴趣了。\n\n无论作为组织者，还是参与者都是或许一样的三分钟热度。在技术这条路上，追求三天打鱼、两天晒网、恨不能一口吃成大胖子的心态数见不鲜。每个人都能在这个波澜壮阔的大时代成为网红，但只有少数人真正能成为明星，大部分人都将在红完他那五分钟后，瞬间谢幕。\n\n也就像许多年轻的开发者们总是能很快的成长，在技术的甘泉中以飞快的速度汲取到足够的养分，但是却只有区区百分之五的掌握了优秀学习方法的、最优秀、能够一步一个脚印的开发者最终能够一直长期的走下去。他们既有长远规划、也有短期计划，不过分在乎眼前得失、不汲汲于名利、不戚戚于自我，他们的每一天都在坚持，让他们靠自己的努力创造了不菲的业绩。\n\n## （二）大环境下、市场选择和人生际遇\n有人说，大环境不好，再努力都是徒劳。对于.NET开发者来说，9012年的今天，大环境似乎没那么好了。在过去十年，正是互联网产业大爆发、中国经济飞速增长的十年。\n\n在这十年的前五年里，执掌微软的Steve Ballmeerr犯了许多错误，首先是错过了移动互联网的爆发，失去了手机阵地、买了诺基亚，然后却将其埋葬。错过了从软件到硬件转型的大时代，他自称为最大的遗憾。\n\n其次在云端战略中，失去了先机，在阿里云开始大规模铺云端战略时，微软和中国互联网三巨头中的两家，百度和腾讯一样，并没有在第一时间看到企业级市场对于云的巨大需求，还好后期继任者纳德拉及时按下了刷新键，才得以转型成功。毕竟是一家有着四十多年历史的公司，基因决定了企业的思维模式，能够实现自我变革，确实是一家伟大的企业。\n\n而对于广大.NET开发者来说，则错过了跟随中国互联网发展的最佳时期，由于.NET技术与微软windows平台的深度绑定、windows平台本身较高的授权费用，让对互联网基础平台需求非常旺盛、而对成本效益最为在意的互联网公司最终纷纷抛弃了.NET平台，转移到了开源和授权费用相对较低的Linux平台，并开始逐步使用Java、Go、Python等作为主力开发语言。\n\n说来也有点遗憾，在20世纪末时，微软也曾是Java主要推动者的Sun公司最大的竞争对手，C#之父Anders Hejlsberg，在他的职业生涯的早期，开发出了Delphi，是大杀器；而职业生涯的中期，基于开源的Java开发出的J#和在Windows上使用的虚拟机，甚至比Sun公司自己开发的虚拟机都好用，最终让Sun不得不通过法律手段来寻求庇佑。然后Anders Hejlsberg大神将主要精力投入到.NET和C#这种优秀的语言中，并大杀四方，获得了非常广泛的用户。\n\n然而，三十年河东，三十年河西。本世纪前几年Windows平台的火爆，确实有力的推动了中国信息产业的繁荣昌盛和发展、微软甚至被称为互联网的黄埔军校，号称撑起了中国互联网的半边天，许多大型互联网公司的CTO或高管（包括阿里云的王坚博士），都是从微软出来的。但是由于后来微软自身的战略原因和中国互联网产业的独特性，让Windows开始失宠，而.NET技术开始走向下滑。以至于今日，许多培训机构也不再开设这门技术。\n\n有人说：大环境不好，所以开发者找工作都很困难。但是也得承认，在环境下的个人，其实不过是此起彼伏翻转、甚至被拍打在沙滩上的浮萍，被人生裹挟着，难免会失去目标，当然也得承认，适应环境的能力非常重要。就像许多开发者都转型到其他语言，这就是在环境下的自然选择，这或许会让大家会有点遗憾。不过我觉得，逐利是人性自然的需求，能够在一门语言上一直走下去固然重要，但是选择变化也无可厚非。毕竟真正掌握了像.NET这种优秀的技术、以及C#这门优秀的语言，不仅在windows下能够做出优秀的产品，也同样能够驾驭包括像Java这样优秀的技术。我们都是程序员，而不仅仅是某个专门领域的程序员，始终抱有开放的心态，能够让我们的职场更加顺畅、也让我们的人生更加圆满。\n\n## （三）优秀开发者们的持续守候\n而一个人的成长，其实与某种语言本身无关、取决于对待技术的认真态度、和孜孜不倦的求索精神。就像我们对社区充满了殷切期待，却不能指望他一天就成为巨人，这需要一次又一次的设计、测试、调试和优化、甚至还需要进行大规模的重构，才足以成为更加完美的软件。这需要许多人一起努力，有共同的目标和执着的信念，每个人或许是不同的角色、职位、岗位、或技能特色，但是大家的心在一起，这就是一个完整的生态。\n\n我还记得我刚刚参加工作的2009年，恰好是Java最低迷的一个时期，优秀的技术先锋Sun公司被迫以白菜价被Oracle收购，一度让.NET带来了机遇。（这也是我选择.NET的一个大环境原因）。时至今日，这门技术我已经用了十年，虽然技术不好，但是我很庆幸见到了几位对技术执着追求的优秀开发者。对于他们，我们或许认识，或许不认识，或许他们出名、也或许他们低调，但是他们都是我们值得学习的优秀榜样。\n\n当博客园的创始人dudu把博客园搭起来时，他为了实现个人技术理想使用了.NET技术来构建博客站、而且这个小站是在扬州这样一个小城市成立的，当时的类似的轻博客竞争对手也很多，所以许多人都不看好他。但是十五年的成长，博客园已经成为许多程序员的心灵港湾，在这里各种不同技术的开发者在这里交流，打造了一个和谐宁静的技术圣地。\n\n有一个或许有人熟悉的论坛，叫做苏飞论坛，是一个历史悠久的小论坛，站长苏飞不仅是一位老程序员、目前也是一位创业者，他的论坛非常活跃，技术氛围浓烈，许多开发者在这里获得了大量有用的知识，包括我就是获益者之一。\n\n从CSkin开始，到DSkin，小红帽和乔克斯他们几位开发者，他们基于.NET构建了一套完整的界面库、效果优美，性能优异，打造了一个不错的小圈子。\n\n张善友老师运营.NET社区、公众号和博客，虽然同期有数十位开发者与他一起开始经营公众号，但是他一直坚持下来，目前公众号已经拥有数万粉丝，堪称.NET领域的KOL。\n\n苏盛巍老师把他的全部精力都投入到基于微信的SDK开发过程中，到目前已经拥有数十万用户基于这套SDK组件，开发出大量优秀的应用，极大的促进了微信应用市场的繁荣。  \n\n刘怡、谢炀、刘浩杨、何镇汐、娄宇等五位老师，他们不仅自己学习技术，还积极分享技术，组成一个社区，邀请了许多优秀开发者一起来贡献更加优秀的.NET Core技术，让中国的.NET Core开源社区越发的强大。\n\n这些都是我恰好认识并曾经熟悉的优秀开发者，而在我们身边还有更多知名或不知名的优秀开发者，他们用他们的实际行动，一点点的点亮了黑暗时代，并迎来了新的黎明-----脱离Windows平台、开源的.NET Core技术。\n\n时至今日.NET Core已经发布了3.0的版本，惠及数十万开发者。\n\n## （四）生态、社区、你我共同见证\n使用.NET、.NET Core技术的开发者，这就是一个完整的生态。\n\n而.NET Core技术，将成为我们的武器，带领我们开启新的征程。曾经.NET技术的发展只能依靠微软，而今，要依靠的不仅仅是微软、更是真正的社区力量，更好的生态、将在我们的手中塑造。 互联网的大时代，或许一波波浪潮将不再滚滚，但是产业互联网的大势已经即将拉开，这是我们的.NET开发者们的主场。\n\n云原生、多平台、以及开放、创新的.NET 新时代，已经到来。\n\n2019年11月9日，我们在上海等你，不见不散。这是一次完全有社区力量倾力打造的技术盛会，组织者们力求完美，只为给你献上一道力求优秀的技术盛宴，数十位.NET圈子的技术大牛，他们无偿付出，就是想让大家知道，.NET 技术什么都能干，什么都能干得最好。\n\n我们期待大家一起来关注，也请大家相信，.NET社区，从来不是一个人在战斗，齐心协力，生态将更加美好。 ","source":"_posts/随笔/2019.Net Conf，我们的共同期待.md","raw":"---\ntitle:  2019.Net Conf，我们的共同期待\ndate: 2019-11-04 08:08\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n\n\n\n## （一）回顾一个小社区红过的五分钟\n不知不觉，距离中国.net社区组织的.net conf只有不到一周的时间，还记得年初在叶伟民老师，潘淳老师和张善友老师的号召下，我们长沙的十几位开发者自发组织起来，拉了一个技术社区，并在腾讯云加社区、微软Azure云技术社区的大力支持，在华邦互联、百师通教育、校管家、心莱科技、长沙冉星信息、深圳纵网长沙分公司、北大青鸟海纳学院等优秀企业的赞助下，在四月组织了一次技术大会，上午场邀请到了张善友老师、梁桐铭老师和汪鹏老师，下午场邀请到了腾讯云的胡李伟老师和卓伟老师，一天的分享安排的满满当当，在小城长沙的.net技术圈掀起了一波小浪潮。\n\n不过大概我们几个996程序员们和几位创业者们的业余时间着实有点匮乏，许下了不少宏伟蓝图，转眼间就把自己的flag吞掉，让组织者之一我感觉到颇为尴尬。一个优秀的社区，一定得持续的把活动拉起来，让更多优秀开发者能够在这里传递更多正能量，让技术的星星之火点燃，推向更加广阔的人群。只有更多的人参与进来，社区之水能够源远流长的持续不断的流下去，才能真正获得长效的发展。\n\n不过显然，虽然企业和开发者都对一个积极优秀的社区充满兴趣，但是却缺少真正能够站出来积极拉动社区的开发者，由于社区初成立、大部分参与者都只是以看热闹的态度，这也让那些对原本充满热情的早期参与者的热情熄灭，很快就偃旗息鼓，然后社区就看起来名存实亡了。\n\n无论是作为组织者的我们，或者是做为观众的开发者们，对社区期许过高。总是高估了自己的计划能力，组织者们太想更早的出成绩、有时候又心态不纯，想借此机会获得一些虚名，但是一旦遇到挫折就会浇灭火苗，然后曾经的豪言壮语都将成为泡影。而作为参与者，确实苦于没有社区这样一个集体，于是总想着更早的看到成绩，然后发现这个社区其实有点名不副实之后，就失去兴趣了。\n\n无论作为组织者，还是参与者都是或许一样的三分钟热度。在技术这条路上，追求三天打鱼、两天晒网、恨不能一口吃成大胖子的心态数见不鲜。每个人都能在这个波澜壮阔的大时代成为网红，但只有少数人真正能成为明星，大部分人都将在红完他那五分钟后，瞬间谢幕。\n\n也就像许多年轻的开发者们总是能很快的成长，在技术的甘泉中以飞快的速度汲取到足够的养分，但是却只有区区百分之五的掌握了优秀学习方法的、最优秀、能够一步一个脚印的开发者最终能够一直长期的走下去。他们既有长远规划、也有短期计划，不过分在乎眼前得失、不汲汲于名利、不戚戚于自我，他们的每一天都在坚持，让他们靠自己的努力创造了不菲的业绩。\n\n## （二）大环境下、市场选择和人生际遇\n有人说，大环境不好，再努力都是徒劳。对于.NET开发者来说，9012年的今天，大环境似乎没那么好了。在过去十年，正是互联网产业大爆发、中国经济飞速增长的十年。\n\n在这十年的前五年里，执掌微软的Steve Ballmeerr犯了许多错误，首先是错过了移动互联网的爆发，失去了手机阵地、买了诺基亚，然后却将其埋葬。错过了从软件到硬件转型的大时代，他自称为最大的遗憾。\n\n其次在云端战略中，失去了先机，在阿里云开始大规模铺云端战略时，微软和中国互联网三巨头中的两家，百度和腾讯一样，并没有在第一时间看到企业级市场对于云的巨大需求，还好后期继任者纳德拉及时按下了刷新键，才得以转型成功。毕竟是一家有着四十多年历史的公司，基因决定了企业的思维模式，能够实现自我变革，确实是一家伟大的企业。\n\n而对于广大.NET开发者来说，则错过了跟随中国互联网发展的最佳时期，由于.NET技术与微软windows平台的深度绑定、windows平台本身较高的授权费用，让对互联网基础平台需求非常旺盛、而对成本效益最为在意的互联网公司最终纷纷抛弃了.NET平台，转移到了开源和授权费用相对较低的Linux平台，并开始逐步使用Java、Go、Python等作为主力开发语言。\n\n说来也有点遗憾，在20世纪末时，微软也曾是Java主要推动者的Sun公司最大的竞争对手，C#之父Anders Hejlsberg，在他的职业生涯的早期，开发出了Delphi，是大杀器；而职业生涯的中期，基于开源的Java开发出的J#和在Windows上使用的虚拟机，甚至比Sun公司自己开发的虚拟机都好用，最终让Sun不得不通过法律手段来寻求庇佑。然后Anders Hejlsberg大神将主要精力投入到.NET和C#这种优秀的语言中，并大杀四方，获得了非常广泛的用户。\n\n然而，三十年河东，三十年河西。本世纪前几年Windows平台的火爆，确实有力的推动了中国信息产业的繁荣昌盛和发展、微软甚至被称为互联网的黄埔军校，号称撑起了中国互联网的半边天，许多大型互联网公司的CTO或高管（包括阿里云的王坚博士），都是从微软出来的。但是由于后来微软自身的战略原因和中国互联网产业的独特性，让Windows开始失宠，而.NET技术开始走向下滑。以至于今日，许多培训机构也不再开设这门技术。\n\n有人说：大环境不好，所以开发者找工作都很困难。但是也得承认，在环境下的个人，其实不过是此起彼伏翻转、甚至被拍打在沙滩上的浮萍，被人生裹挟着，难免会失去目标，当然也得承认，适应环境的能力非常重要。就像许多开发者都转型到其他语言，这就是在环境下的自然选择，这或许会让大家会有点遗憾。不过我觉得，逐利是人性自然的需求，能够在一门语言上一直走下去固然重要，但是选择变化也无可厚非。毕竟真正掌握了像.NET这种优秀的技术、以及C#这门优秀的语言，不仅在windows下能够做出优秀的产品，也同样能够驾驭包括像Java这样优秀的技术。我们都是程序员，而不仅仅是某个专门领域的程序员，始终抱有开放的心态，能够让我们的职场更加顺畅、也让我们的人生更加圆满。\n\n## （三）优秀开发者们的持续守候\n而一个人的成长，其实与某种语言本身无关、取决于对待技术的认真态度、和孜孜不倦的求索精神。就像我们对社区充满了殷切期待，却不能指望他一天就成为巨人，这需要一次又一次的设计、测试、调试和优化、甚至还需要进行大规模的重构，才足以成为更加完美的软件。这需要许多人一起努力，有共同的目标和执着的信念，每个人或许是不同的角色、职位、岗位、或技能特色，但是大家的心在一起，这就是一个完整的生态。\n\n我还记得我刚刚参加工作的2009年，恰好是Java最低迷的一个时期，优秀的技术先锋Sun公司被迫以白菜价被Oracle收购，一度让.NET带来了机遇。（这也是我选择.NET的一个大环境原因）。时至今日，这门技术我已经用了十年，虽然技术不好，但是我很庆幸见到了几位对技术执着追求的优秀开发者。对于他们，我们或许认识，或许不认识，或许他们出名、也或许他们低调，但是他们都是我们值得学习的优秀榜样。\n\n当博客园的创始人dudu把博客园搭起来时，他为了实现个人技术理想使用了.NET技术来构建博客站、而且这个小站是在扬州这样一个小城市成立的，当时的类似的轻博客竞争对手也很多，所以许多人都不看好他。但是十五年的成长，博客园已经成为许多程序员的心灵港湾，在这里各种不同技术的开发者在这里交流，打造了一个和谐宁静的技术圣地。\n\n有一个或许有人熟悉的论坛，叫做苏飞论坛，是一个历史悠久的小论坛，站长苏飞不仅是一位老程序员、目前也是一位创业者，他的论坛非常活跃，技术氛围浓烈，许多开发者在这里获得了大量有用的知识，包括我就是获益者之一。\n\n从CSkin开始，到DSkin，小红帽和乔克斯他们几位开发者，他们基于.NET构建了一套完整的界面库、效果优美，性能优异，打造了一个不错的小圈子。\n\n张善友老师运营.NET社区、公众号和博客，虽然同期有数十位开发者与他一起开始经营公众号，但是他一直坚持下来，目前公众号已经拥有数万粉丝，堪称.NET领域的KOL。\n\n苏盛巍老师把他的全部精力都投入到基于微信的SDK开发过程中，到目前已经拥有数十万用户基于这套SDK组件，开发出大量优秀的应用，极大的促进了微信应用市场的繁荣。  \n\n刘怡、谢炀、刘浩杨、何镇汐、娄宇等五位老师，他们不仅自己学习技术，还积极分享技术，组成一个社区，邀请了许多优秀开发者一起来贡献更加优秀的.NET Core技术，让中国的.NET Core开源社区越发的强大。\n\n这些都是我恰好认识并曾经熟悉的优秀开发者，而在我们身边还有更多知名或不知名的优秀开发者，他们用他们的实际行动，一点点的点亮了黑暗时代，并迎来了新的黎明-----脱离Windows平台、开源的.NET Core技术。\n\n时至今日.NET Core已经发布了3.0的版本，惠及数十万开发者。\n\n## （四）生态、社区、你我共同见证\n使用.NET、.NET Core技术的开发者，这就是一个完整的生态。\n\n而.NET Core技术，将成为我们的武器，带领我们开启新的征程。曾经.NET技术的发展只能依靠微软，而今，要依靠的不仅仅是微软、更是真正的社区力量，更好的生态、将在我们的手中塑造。 互联网的大时代，或许一波波浪潮将不再滚滚，但是产业互联网的大势已经即将拉开，这是我们的.NET开发者们的主场。\n\n云原生、多平台、以及开放、创新的.NET 新时代，已经到来。\n\n2019年11月9日，我们在上海等你，不见不散。这是一次完全有社区力量倾力打造的技术盛会，组织者们力求完美，只为给你献上一道力求优秀的技术盛宴，数十位.NET圈子的技术大牛，他们无偿付出，就是想让大家知道，.NET 技术什么都能干，什么都能干得最好。\n\n我们期待大家一起来关注，也请大家相信，.NET社区，从来不是一个人在战斗，齐心协力，生态将更加美好。 ","slug":"随笔/2019.Net Conf，我们的共同期待","published":1,"updated":"2019-11-04T00:08:50.999Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt8s002zn4vikupeohmx","content":"<h2 id=\"（一）回顾一个小社区红过的五分钟\"><a href=\"#（一）回顾一个小社区红过的五分钟\" class=\"headerlink\" title=\"（一）回顾一个小社区红过的五分钟\"></a>（一）回顾一个小社区红过的五分钟</h2><p>不知不觉，距离中国.net社区组织的.net conf只有不到一周的时间，还记得年初在叶伟民老师，潘淳老师和张善友老师的号召下，我们长沙的十几位开发者自发组织起来，拉了一个技术社区，并在腾讯云加社区、微软Azure云技术社区的大力支持，在华邦互联、百师通教育、校管家、心莱科技、长沙冉星信息、深圳纵网长沙分公司、北大青鸟海纳学院等优秀企业的赞助下，在四月组织了一次技术大会，上午场邀请到了张善友老师、梁桐铭老师和汪鹏老师，下午场邀请到了腾讯云的胡李伟老师和卓伟老师，一天的分享安排的满满当当，在小城长沙的.net技术圈掀起了一波小浪潮。</p>\n<p>不过大概我们几个996程序员们和几位创业者们的业余时间着实有点匮乏，许下了不少宏伟蓝图，转眼间就把自己的flag吞掉，让组织者之一我感觉到颇为尴尬。一个优秀的社区，一定得持续的把活动拉起来，让更多优秀开发者能够在这里传递更多正能量，让技术的星星之火点燃，推向更加广阔的人群。只有更多的人参与进来，社区之水能够源远流长的持续不断的流下去，才能真正获得长效的发展。</p>\n<p>不过显然，虽然企业和开发者都对一个积极优秀的社区充满兴趣，但是却缺少真正能够站出来积极拉动社区的开发者，由于社区初成立、大部分参与者都只是以看热闹的态度，这也让那些对原本充满热情的早期参与者的热情熄灭，很快就偃旗息鼓，然后社区就看起来名存实亡了。</p>\n<p>无论是作为组织者的我们，或者是做为观众的开发者们，对社区期许过高。总是高估了自己的计划能力，组织者们太想更早的出成绩、有时候又心态不纯，想借此机会获得一些虚名，但是一旦遇到挫折就会浇灭火苗，然后曾经的豪言壮语都将成为泡影。而作为参与者，确实苦于没有社区这样一个集体，于是总想着更早的看到成绩，然后发现这个社区其实有点名不副实之后，就失去兴趣了。</p>\n<p>无论作为组织者，还是参与者都是或许一样的三分钟热度。在技术这条路上，追求三天打鱼、两天晒网、恨不能一口吃成大胖子的心态数见不鲜。每个人都能在这个波澜壮阔的大时代成为网红，但只有少数人真正能成为明星，大部分人都将在红完他那五分钟后，瞬间谢幕。</p>\n<p>也就像许多年轻的开发者们总是能很快的成长，在技术的甘泉中以飞快的速度汲取到足够的养分，但是却只有区区百分之五的掌握了优秀学习方法的、最优秀、能够一步一个脚印的开发者最终能够一直长期的走下去。他们既有长远规划、也有短期计划，不过分在乎眼前得失、不汲汲于名利、不戚戚于自我，他们的每一天都在坚持，让他们靠自己的努力创造了不菲的业绩。</p>\n<h2 id=\"（二）大环境下、市场选择和人生际遇\"><a href=\"#（二）大环境下、市场选择和人生际遇\" class=\"headerlink\" title=\"（二）大环境下、市场选择和人生际遇\"></a>（二）大环境下、市场选择和人生际遇</h2><p>有人说，大环境不好，再努力都是徒劳。对于.NET开发者来说，9012年的今天，大环境似乎没那么好了。在过去十年，正是互联网产业大爆发、中国经济飞速增长的十年。</p>\n<p>在这十年的前五年里，执掌微软的Steve Ballmeerr犯了许多错误，首先是错过了移动互联网的爆发，失去了手机阵地、买了诺基亚，然后却将其埋葬。错过了从软件到硬件转型的大时代，他自称为最大的遗憾。</p>\n<p>其次在云端战略中，失去了先机，在阿里云开始大规模铺云端战略时，微软和中国互联网三巨头中的两家，百度和腾讯一样，并没有在第一时间看到企业级市场对于云的巨大需求，还好后期继任者纳德拉及时按下了刷新键，才得以转型成功。毕竟是一家有着四十多年历史的公司，基因决定了企业的思维模式，能够实现自我变革，确实是一家伟大的企业。</p>\n<p>而对于广大.NET开发者来说，则错过了跟随中国互联网发展的最佳时期，由于.NET技术与微软windows平台的深度绑定、windows平台本身较高的授权费用，让对互联网基础平台需求非常旺盛、而对成本效益最为在意的互联网公司最终纷纷抛弃了.NET平台，转移到了开源和授权费用相对较低的Linux平台，并开始逐步使用Java、Go、Python等作为主力开发语言。</p>\n<p>说来也有点遗憾，在20世纪末时，微软也曾是Java主要推动者的Sun公司最大的竞争对手，C#之父Anders Hejlsberg，在他的职业生涯的早期，开发出了Delphi，是大杀器；而职业生涯的中期，基于开源的Java开发出的J#和在Windows上使用的虚拟机，甚至比Sun公司自己开发的虚拟机都好用，最终让Sun不得不通过法律手段来寻求庇佑。然后Anders Hejlsberg大神将主要精力投入到.NET和C#这种优秀的语言中，并大杀四方，获得了非常广泛的用户。</p>\n<p>然而，三十年河东，三十年河西。本世纪前几年Windows平台的火爆，确实有力的推动了中国信息产业的繁荣昌盛和发展、微软甚至被称为互联网的黄埔军校，号称撑起了中国互联网的半边天，许多大型互联网公司的CTO或高管（包括阿里云的王坚博士），都是从微软出来的。但是由于后来微软自身的战略原因和中国互联网产业的独特性，让Windows开始失宠，而.NET技术开始走向下滑。以至于今日，许多培训机构也不再开设这门技术。</p>\n<p>有人说：大环境不好，所以开发者找工作都很困难。但是也得承认，在环境下的个人，其实不过是此起彼伏翻转、甚至被拍打在沙滩上的浮萍，被人生裹挟着，难免会失去目标，当然也得承认，适应环境的能力非常重要。就像许多开发者都转型到其他语言，这就是在环境下的自然选择，这或许会让大家会有点遗憾。不过我觉得，逐利是人性自然的需求，能够在一门语言上一直走下去固然重要，但是选择变化也无可厚非。毕竟真正掌握了像.NET这种优秀的技术、以及C#这门优秀的语言，不仅在windows下能够做出优秀的产品，也同样能够驾驭包括像Java这样优秀的技术。我们都是程序员，而不仅仅是某个专门领域的程序员，始终抱有开放的心态，能够让我们的职场更加顺畅、也让我们的人生更加圆满。</p>\n<h2 id=\"（三）优秀开发者们的持续守候\"><a href=\"#（三）优秀开发者们的持续守候\" class=\"headerlink\" title=\"（三）优秀开发者们的持续守候\"></a>（三）优秀开发者们的持续守候</h2><p>而一个人的成长，其实与某种语言本身无关、取决于对待技术的认真态度、和孜孜不倦的求索精神。就像我们对社区充满了殷切期待，却不能指望他一天就成为巨人，这需要一次又一次的设计、测试、调试和优化、甚至还需要进行大规模的重构，才足以成为更加完美的软件。这需要许多人一起努力，有共同的目标和执着的信念，每个人或许是不同的角色、职位、岗位、或技能特色，但是大家的心在一起，这就是一个完整的生态。</p>\n<p>我还记得我刚刚参加工作的2009年，恰好是Java最低迷的一个时期，优秀的技术先锋Sun公司被迫以白菜价被Oracle收购，一度让.NET带来了机遇。（这也是我选择.NET的一个大环境原因）。时至今日，这门技术我已经用了十年，虽然技术不好，但是我很庆幸见到了几位对技术执着追求的优秀开发者。对于他们，我们或许认识，或许不认识，或许他们出名、也或许他们低调，但是他们都是我们值得学习的优秀榜样。</p>\n<p>当博客园的创始人dudu把博客园搭起来时，他为了实现个人技术理想使用了.NET技术来构建博客站、而且这个小站是在扬州这样一个小城市成立的，当时的类似的轻博客竞争对手也很多，所以许多人都不看好他。但是十五年的成长，博客园已经成为许多程序员的心灵港湾，在这里各种不同技术的开发者在这里交流，打造了一个和谐宁静的技术圣地。</p>\n<p>有一个或许有人熟悉的论坛，叫做苏飞论坛，是一个历史悠久的小论坛，站长苏飞不仅是一位老程序员、目前也是一位创业者，他的论坛非常活跃，技术氛围浓烈，许多开发者在这里获得了大量有用的知识，包括我就是获益者之一。</p>\n<p>从CSkin开始，到DSkin，小红帽和乔克斯他们几位开发者，他们基于.NET构建了一套完整的界面库、效果优美，性能优异，打造了一个不错的小圈子。</p>\n<p>张善友老师运营.NET社区、公众号和博客，虽然同期有数十位开发者与他一起开始经营公众号，但是他一直坚持下来，目前公众号已经拥有数万粉丝，堪称.NET领域的KOL。</p>\n<p>苏盛巍老师把他的全部精力都投入到基于微信的SDK开发过程中，到目前已经拥有数十万用户基于这套SDK组件，开发出大量优秀的应用，极大的促进了微信应用市场的繁荣。  </p>\n<p>刘怡、谢炀、刘浩杨、何镇汐、娄宇等五位老师，他们不仅自己学习技术，还积极分享技术，组成一个社区，邀请了许多优秀开发者一起来贡献更加优秀的.NET Core技术，让中国的.NET Core开源社区越发的强大。</p>\n<p>这些都是我恰好认识并曾经熟悉的优秀开发者，而在我们身边还有更多知名或不知名的优秀开发者，他们用他们的实际行动，一点点的点亮了黑暗时代，并迎来了新的黎明—–脱离Windows平台、开源的.NET Core技术。</p>\n<p>时至今日.NET Core已经发布了3.0的版本，惠及数十万开发者。</p>\n<h2 id=\"（四）生态、社区、你我共同见证\"><a href=\"#（四）生态、社区、你我共同见证\" class=\"headerlink\" title=\"（四）生态、社区、你我共同见证\"></a>（四）生态、社区、你我共同见证</h2><p>使用.NET、.NET Core技术的开发者，这就是一个完整的生态。</p>\n<p>而.NET Core技术，将成为我们的武器，带领我们开启新的征程。曾经.NET技术的发展只能依靠微软，而今，要依靠的不仅仅是微软、更是真正的社区力量，更好的生态、将在我们的手中塑造。 互联网的大时代，或许一波波浪潮将不再滚滚，但是产业互联网的大势已经即将拉开，这是我们的.NET开发者们的主场。</p>\n<p>云原生、多平台、以及开放、创新的.NET 新时代，已经到来。</p>\n<p>2019年11月9日，我们在上海等你，不见不散。这是一次完全有社区力量倾力打造的技术盛会，组织者们力求完美，只为给你献上一道力求优秀的技术盛宴，数十位.NET圈子的技术大牛，他们无偿付出，就是想让大家知道，.NET 技术什么都能干，什么都能干得最好。</p>\n<p>我们期待大家一起来关注，也请大家相信，.NET社区，从来不是一个人在战斗，齐心协力，生态将更加美好。 </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"（一）回顾一个小社区红过的五分钟\"><a href=\"#（一）回顾一个小社区红过的五分钟\" class=\"headerlink\" title=\"（一）回顾一个小社区红过的五分钟\"></a>（一）回顾一个小社区红过的五分钟</h2><p>不知不觉，距离中国.net社区组织的.net conf只有不到一周的时间，还记得年初在叶伟民老师，潘淳老师和张善友老师的号召下，我们长沙的十几位开发者自发组织起来，拉了一个技术社区，并在腾讯云加社区、微软Azure云技术社区的大力支持，在华邦互联、百师通教育、校管家、心莱科技、长沙冉星信息、深圳纵网长沙分公司、北大青鸟海纳学院等优秀企业的赞助下，在四月组织了一次技术大会，上午场邀请到了张善友老师、梁桐铭老师和汪鹏老师，下午场邀请到了腾讯云的胡李伟老师和卓伟老师，一天的分享安排的满满当当，在小城长沙的.net技术圈掀起了一波小浪潮。</p>\n<p>不过大概我们几个996程序员们和几位创业者们的业余时间着实有点匮乏，许下了不少宏伟蓝图，转眼间就把自己的flag吞掉，让组织者之一我感觉到颇为尴尬。一个优秀的社区，一定得持续的把活动拉起来，让更多优秀开发者能够在这里传递更多正能量，让技术的星星之火点燃，推向更加广阔的人群。只有更多的人参与进来，社区之水能够源远流长的持续不断的流下去，才能真正获得长效的发展。</p>\n<p>不过显然，虽然企业和开发者都对一个积极优秀的社区充满兴趣，但是却缺少真正能够站出来积极拉动社区的开发者，由于社区初成立、大部分参与者都只是以看热闹的态度，这也让那些对原本充满热情的早期参与者的热情熄灭，很快就偃旗息鼓，然后社区就看起来名存实亡了。</p>\n<p>无论是作为组织者的我们，或者是做为观众的开发者们，对社区期许过高。总是高估了自己的计划能力，组织者们太想更早的出成绩、有时候又心态不纯，想借此机会获得一些虚名，但是一旦遇到挫折就会浇灭火苗，然后曾经的豪言壮语都将成为泡影。而作为参与者，确实苦于没有社区这样一个集体，于是总想着更早的看到成绩，然后发现这个社区其实有点名不副实之后，就失去兴趣了。</p>\n<p>无论作为组织者，还是参与者都是或许一样的三分钟热度。在技术这条路上，追求三天打鱼、两天晒网、恨不能一口吃成大胖子的心态数见不鲜。每个人都能在这个波澜壮阔的大时代成为网红，但只有少数人真正能成为明星，大部分人都将在红完他那五分钟后，瞬间谢幕。</p>\n<p>也就像许多年轻的开发者们总是能很快的成长，在技术的甘泉中以飞快的速度汲取到足够的养分，但是却只有区区百分之五的掌握了优秀学习方法的、最优秀、能够一步一个脚印的开发者最终能够一直长期的走下去。他们既有长远规划、也有短期计划，不过分在乎眼前得失、不汲汲于名利、不戚戚于自我，他们的每一天都在坚持，让他们靠自己的努力创造了不菲的业绩。</p>\n<h2 id=\"（二）大环境下、市场选择和人生际遇\"><a href=\"#（二）大环境下、市场选择和人生际遇\" class=\"headerlink\" title=\"（二）大环境下、市场选择和人生际遇\"></a>（二）大环境下、市场选择和人生际遇</h2><p>有人说，大环境不好，再努力都是徒劳。对于.NET开发者来说，9012年的今天，大环境似乎没那么好了。在过去十年，正是互联网产业大爆发、中国经济飞速增长的十年。</p>\n<p>在这十年的前五年里，执掌微软的Steve Ballmeerr犯了许多错误，首先是错过了移动互联网的爆发，失去了手机阵地、买了诺基亚，然后却将其埋葬。错过了从软件到硬件转型的大时代，他自称为最大的遗憾。</p>\n<p>其次在云端战略中，失去了先机，在阿里云开始大规模铺云端战略时，微软和中国互联网三巨头中的两家，百度和腾讯一样，并没有在第一时间看到企业级市场对于云的巨大需求，还好后期继任者纳德拉及时按下了刷新键，才得以转型成功。毕竟是一家有着四十多年历史的公司，基因决定了企业的思维模式，能够实现自我变革，确实是一家伟大的企业。</p>\n<p>而对于广大.NET开发者来说，则错过了跟随中国互联网发展的最佳时期，由于.NET技术与微软windows平台的深度绑定、windows平台本身较高的授权费用，让对互联网基础平台需求非常旺盛、而对成本效益最为在意的互联网公司最终纷纷抛弃了.NET平台，转移到了开源和授权费用相对较低的Linux平台，并开始逐步使用Java、Go、Python等作为主力开发语言。</p>\n<p>说来也有点遗憾，在20世纪末时，微软也曾是Java主要推动者的Sun公司最大的竞争对手，C#之父Anders Hejlsberg，在他的职业生涯的早期，开发出了Delphi，是大杀器；而职业生涯的中期，基于开源的Java开发出的J#和在Windows上使用的虚拟机，甚至比Sun公司自己开发的虚拟机都好用，最终让Sun不得不通过法律手段来寻求庇佑。然后Anders Hejlsberg大神将主要精力投入到.NET和C#这种优秀的语言中，并大杀四方，获得了非常广泛的用户。</p>\n<p>然而，三十年河东，三十年河西。本世纪前几年Windows平台的火爆，确实有力的推动了中国信息产业的繁荣昌盛和发展、微软甚至被称为互联网的黄埔军校，号称撑起了中国互联网的半边天，许多大型互联网公司的CTO或高管（包括阿里云的王坚博士），都是从微软出来的。但是由于后来微软自身的战略原因和中国互联网产业的独特性，让Windows开始失宠，而.NET技术开始走向下滑。以至于今日，许多培训机构也不再开设这门技术。</p>\n<p>有人说：大环境不好，所以开发者找工作都很困难。但是也得承认，在环境下的个人，其实不过是此起彼伏翻转、甚至被拍打在沙滩上的浮萍，被人生裹挟着，难免会失去目标，当然也得承认，适应环境的能力非常重要。就像许多开发者都转型到其他语言，这就是在环境下的自然选择，这或许会让大家会有点遗憾。不过我觉得，逐利是人性自然的需求，能够在一门语言上一直走下去固然重要，但是选择变化也无可厚非。毕竟真正掌握了像.NET这种优秀的技术、以及C#这门优秀的语言，不仅在windows下能够做出优秀的产品，也同样能够驾驭包括像Java这样优秀的技术。我们都是程序员，而不仅仅是某个专门领域的程序员，始终抱有开放的心态，能够让我们的职场更加顺畅、也让我们的人生更加圆满。</p>\n<h2 id=\"（三）优秀开发者们的持续守候\"><a href=\"#（三）优秀开发者们的持续守候\" class=\"headerlink\" title=\"（三）优秀开发者们的持续守候\"></a>（三）优秀开发者们的持续守候</h2><p>而一个人的成长，其实与某种语言本身无关、取决于对待技术的认真态度、和孜孜不倦的求索精神。就像我们对社区充满了殷切期待，却不能指望他一天就成为巨人，这需要一次又一次的设计、测试、调试和优化、甚至还需要进行大规模的重构，才足以成为更加完美的软件。这需要许多人一起努力，有共同的目标和执着的信念，每个人或许是不同的角色、职位、岗位、或技能特色，但是大家的心在一起，这就是一个完整的生态。</p>\n<p>我还记得我刚刚参加工作的2009年，恰好是Java最低迷的一个时期，优秀的技术先锋Sun公司被迫以白菜价被Oracle收购，一度让.NET带来了机遇。（这也是我选择.NET的一个大环境原因）。时至今日，这门技术我已经用了十年，虽然技术不好，但是我很庆幸见到了几位对技术执着追求的优秀开发者。对于他们，我们或许认识，或许不认识，或许他们出名、也或许他们低调，但是他们都是我们值得学习的优秀榜样。</p>\n<p>当博客园的创始人dudu把博客园搭起来时，他为了实现个人技术理想使用了.NET技术来构建博客站、而且这个小站是在扬州这样一个小城市成立的，当时的类似的轻博客竞争对手也很多，所以许多人都不看好他。但是十五年的成长，博客园已经成为许多程序员的心灵港湾，在这里各种不同技术的开发者在这里交流，打造了一个和谐宁静的技术圣地。</p>\n<p>有一个或许有人熟悉的论坛，叫做苏飞论坛，是一个历史悠久的小论坛，站长苏飞不仅是一位老程序员、目前也是一位创业者，他的论坛非常活跃，技术氛围浓烈，许多开发者在这里获得了大量有用的知识，包括我就是获益者之一。</p>\n<p>从CSkin开始，到DSkin，小红帽和乔克斯他们几位开发者，他们基于.NET构建了一套完整的界面库、效果优美，性能优异，打造了一个不错的小圈子。</p>\n<p>张善友老师运营.NET社区、公众号和博客，虽然同期有数十位开发者与他一起开始经营公众号，但是他一直坚持下来，目前公众号已经拥有数万粉丝，堪称.NET领域的KOL。</p>\n<p>苏盛巍老师把他的全部精力都投入到基于微信的SDK开发过程中，到目前已经拥有数十万用户基于这套SDK组件，开发出大量优秀的应用，极大的促进了微信应用市场的繁荣。  </p>\n<p>刘怡、谢炀、刘浩杨、何镇汐、娄宇等五位老师，他们不仅自己学习技术，还积极分享技术，组成一个社区，邀请了许多优秀开发者一起来贡献更加优秀的.NET Core技术，让中国的.NET Core开源社区越发的强大。</p>\n<p>这些都是我恰好认识并曾经熟悉的优秀开发者，而在我们身边还有更多知名或不知名的优秀开发者，他们用他们的实际行动，一点点的点亮了黑暗时代，并迎来了新的黎明—–脱离Windows平台、开源的.NET Core技术。</p>\n<p>时至今日.NET Core已经发布了3.0的版本，惠及数十万开发者。</p>\n<h2 id=\"（四）生态、社区、你我共同见证\"><a href=\"#（四）生态、社区、你我共同见证\" class=\"headerlink\" title=\"（四）生态、社区、你我共同见证\"></a>（四）生态、社区、你我共同见证</h2><p>使用.NET、.NET Core技术的开发者，这就是一个完整的生态。</p>\n<p>而.NET Core技术，将成为我们的武器，带领我们开启新的征程。曾经.NET技术的发展只能依靠微软，而今，要依靠的不仅仅是微软、更是真正的社区力量，更好的生态、将在我们的手中塑造。 互联网的大时代，或许一波波浪潮将不再滚滚，但是产业互联网的大势已经即将拉开，这是我们的.NET开发者们的主场。</p>\n<p>云原生、多平台、以及开放、创新的.NET 新时代，已经到来。</p>\n<p>2019年11月9日，我们在上海等你，不见不散。这是一次完全有社区力量倾力打造的技术盛会，组织者们力求完美，只为给你献上一道力求优秀的技术盛宴，数十位.NET圈子的技术大牛，他们无偿付出，就是想让大家知道，.NET 技术什么都能干，什么都能干得最好。</p>\n<p>我们期待大家一起来关注，也请大家相信，.NET社区，从来不是一个人在战斗，齐心协力，生态将更加美好。 </p>\n"},{"title":"复盘2019年，我花了3个月时间备考PMP","date":"2019-12-09T14:28:00.000Z","author":"邹溪源","_content":"# 引子​\n\n​\t\t经过几个月的准备，终于在2019年12月7日完成了PMP的考试，并于今天查到了成绩，总结这次考试的具体情况：涉及题型虽然都没有超出大纲的范围，但是原题出现的概率似乎不高，还有一些原来未曾见过的题目，例如矩阵型组织或弱矩阵型组织等，以及造一个能够能飞三米的纸飞机，存在5%的废品，该如何处理，这样的题目让人有点摸不着头脑，还有一些原题，虽然是模拟题上的题目，但是。。我居然到了考试的时候居然忘记答案了，这有点过于尴尬。  \n\n## 为什么考PMP\n\n​\t回顾职场，我是在参加工作的第二年成为项目经理的，当时还是啥都不同的毛头小伙，就被公司指派担任一个十几万小项目的项目经理，并和两位老鸟一起共同参与项目的研发，每天都出入XX勘测设计院的大门之中，基本上都认识了这些勘测院的机关工作人员，还好这个项目本身技术并不复杂，加上有足够的资源和不急的时间需求，做出的成果也符合了甲方的需求，所以这个项目总体上处理的还算不错；\n\n​\t随后又参加了另外一个几十万的小项目，并在其中担任项目经理和技术负责人，由于有了一位资深工程师、一位资深从业者（虽然对编程技术不够了解，但是沟通能力很强）所以这个项目也能如鱼得水。\n\n​\t再后来同时带了两个项目，一个是XXX规划局的XX信息平台，一个是地下管线系统，同时带两个项目的压力确实很大，而且公司的技术水平其实并不好，这两个都是研发型项目，作为一个开发出生的我，难免很难同时兼顾两个项目，加上地下管线系统其实是有老鸟参与研发设计，而我基本上只用跟需求，而空间信息平台则是我带一些没有工作经验的新手，所以我对于管线系统也就没太放在心上，精力也就全部放在空间信息平台上，所以当项目结项时，虽然两个项目都完成了，但是差别却特别大，空间信息平台广受赞誉，为后来接下数百万的合同奠定了基础，而地下管线系统（其实合同额更高）中的老程序员们却由于被过度放权，反而疏于管理，虽然软件做出来了，但是却没能派上用场，到后来被尘封，只能成为一个经费项目。\n\n​\t再后来，公司内部组织结构发生了变更，我也进入了一个的高光时期，被选为部门的项目主管，同时兼顾多个项目，负责管理了超过20位项目团队成员，管了3个项目经理。当时的我一度以为是自己的优秀打动了领导，其实是因为公司确实是没人了，才让我临时暂代，然而我还以此为骄傲，最终什么事情都没搞好。\n\n​\t后来就从这家公司离职，开始了新的职场过程，前前后后也陆陆续续带了不少项目，有大有小，成功或失败，也或多或少有一些。总体上来评价，差强人意，虽然试图做好项目，但是却总感觉阻塞颇多，无论是人员上的，还是技术上，或者沟通上的，总觉得没有特别完美。尤其是做互联网项目时，花了许多时间去打磨产品，却依然没能做出令人眼前一亮的东西，固然与产品有一定的关系，其实也与未能管理领导的预期有更大的关系。\n\n​\t确实如此，一个成功的项目，首先要管好客户的预期，其次得做好资源的调配。真正好的项目经理，一定是那些看起来很闲的项目经理，因为他们把什么事情都能很好的规划，只是做好任务分配、任务审查、和任务总结以及汇报就够了，而像过去的我那样的渣项目经理，不仅事无巨细、连代码要管，衣食住行要管，还让大家累死累活下来也根本没赚到多少钱。\n\n​\t在IT领域，不仅软件开发有德雷福斯的能力成熟度模型，连项目经理也同样具备，同样必须经过一万小时，经过从新手到高级新手，到胜任者，精通者，到专家的蜕变，而这个过程，要么必须吃了很多亏（意味着要花费公司大量的人力物力财力来培养），要么就是能够真正自发成为专业的项目管理者。\n\n​\t事实上专业的项目管理者比开发者或许更困难，在我从业的这十年中，也遇到了个别优秀的项目经理，他们善于运用领导力的强大魄力，在项目各方间游刃有余，而更多的项目经理，都像我一样，运用程序员的沟通技巧，与各方沟通，往往会吃尽苦头。\n\n​\t技术出生的管理者，往往都具备类似的毛病：例如过度在意过程和实现；忽略沟通的力量；渴望全局掌控；缺乏领导艺术；缺乏政治敏感度；藐视人情世故等。好吧，在后来的项目过程中，我已经逐步掌握了沟通、政治敏感度和人情世故这样的法宝，并通过这种手段获得过各方的认同，但是还是或多或少在乎细节、在乎流程的完备性，反而忽略了对于客户预期的把控，最终依然造出了几个不太成果的项目。\n\n​\t一个人的成长，大概就是得经历从失败的挫折、吸取教训、逐渐成长的过程，无论是哪个岗位都大体类似。优秀的项目管理能力一定是开发者的必备基础技能，唯有灵活的掌握项目管理技能的多个方面，才能让软件项目能够高效、快速的契合各方的需求，实现组织从一种状态到另外一种状态。\n\n​\t如果说以前带的项目，基本上已经到了胜任者的层级，那么大概这种层级，其实是自封的，如何来真正证明自己具备\\胜任相关岗位呢，我觉得大概需要一个纸质证明了。这就是我打算考PMP的原因。\n\n## 为什么选择培训班\n\n​\t不过考PMP有很多种方式，而且PMP本身也不是一种特别困难的资格证，在我的身边已经有许多人考了PMP，并获得了证书，甚至有许多人拿到了5A证书，例如我参加的培训班，5A率已经超过70%了。\n\n​\t而在国内，每种证书最常见的质疑是，考这个有用么？我倒是觉得，有没有用先不管，至少学到知识的过程就一定值得花这点钱。知识的价值，也并非那些可以用直接卖多少钱来衡量，他其实是一点一滴深入你的骨肉，并最终构成你的灵魂，并且在需要体现价值的时候，一点一点的凸显出来。\n\n​\t除此之外，我也感觉虽然考试范围就是在PMBOOK这本书，而且只考前538页，但是书本上有太多内容了，每一个点都能够写出许多许多的故事出来，甚至而言，把五大过程，四十九过程组中，任意抽出一个过程组出来专精，都可以成为一个称职的专家，所以纯粹看书其实并不能提高自己对于项目管理技能的领悟力，而那些能够给我们提供培训的老师，他们往往首先是真正优秀的项目经理。其次不仅对项目管理这一本砖头书要烂熟于心，也需要能够用自己的语言把枯燥无味、干涩的知识讲出花来，这更需要本事。\n\n​\t再加上项目管理这种管理体系，其实更是一种团队技能，靠自己看书，往往找不到重点，而借助于培训机构，反而能够跟其他具有相同爱好的人一起学习，也算是一段不错的过程。\n\n​\t选择现代卓越面授班对我来说确实是个非常明智的决定，因为面授班确实是这样的好地方，大家一起讨论项目管理方面的问题，着实是一种不错的体验。\n\n## 通过培训获得的收获\n\n​\t近年来随着离软件公司越来越远，离各种行业软件越来越近，觉得自己的项目管理能力的某些方面诸如沟通表达能力和领导力有所提升，但是对于项目管理过层中的计划管理能力反而已经越来越差了。毕竟原来一直从事IT技术研发+项目管理，对于时间的计划安排，无外乎就是按照自己的经验去套、或者借助于模仿，这是初学者的典型惯例。\n\n​\t除此之外，在项目中，虽然用到了瀑布模型这种预测性生命周期来管理项目，但是又接触到许多敏捷的项目管理方法，所以技能点反而不纯粹了，总结就是，什么都懂一点，却什么都只懂一点，所以专业级项目经理是如何做项目的？这确实是一个值得仔细讨论的问题。而这也是参加培训最大的收获。\n\n​\t总结一下可以为我未来做项目提供指导的一些点：\n\n1、需求的重要-紧急矩阵：评估需求时，先把重要紧急矩阵画好，然后再来指导工作。以前难道不知道么，确实没这么系统的学习这套理论吧。\n\n2、权力-利益方格、相关方认知模型、相关方参与度评估矩阵：\n\n3、能力-欲望矩阵：有能力有欲望、有能力没欲望、没能力有欲望、没能力没欲望，你在哪个象限？值得深思。\n\n4、成本管理：老板的钱来之不易，成本管理得做好。\n\n6、三大管理学原理：彼得原理、帕金森定律和墨菲定律，大概可以好好讲一天。\n\n7、如何做好团队激励和团队建设：哪些是保健因素，哪些是激励因素，如何打造一支优秀的团队？知易行难啊。\n\n9、风险责任矩阵RBS:提前做好风险评估和责任人分配，让风险防范于未然很有必要。\n\n10、问题日志、经验教训登记册、风险登记册和营造积极分享的氛围。\n\n11、会议管理：罗伯特议事规则。开会太长确实需要规则。\n\n12、关键链法：盲目的设定项目工作包或活动其实没什么意义，倒不如先做好关键链，然后再逐步的实现里程碑，只要关键链做好了，往往也离项目做完不远了。毕竟一个项目是花有限的资源做有限的事，而不是无穷尽的盲目的投入。\n\n13、挣值分析技术：虽然挣值分析技术是一种数学评估方法，看起来有点不太精准，但是将这种技术高效的运用到项目中，也许会给项目管理带来不少便利。\n\n14、责任分解矩阵：做好工作分解和责任分解固然重要，更要给责任人指派明确的责任，而不是口头上的任命，做到有根有据，有考核指标和评价依据非常重要。\n\n15、塔克曼团队发展阶段理论：一个团队的成长早期，往往是相互独立、甚至互相提防的，只有互相磨合，经历开诚布公，才能打造成熟稳定的团队。\n\n16、TEAM团队理论：Today Everyone Achive More。没有完美的个人，只有完美的团队。团队并非一个人、而是大家彼此拿出自己最擅长的方面，共同打造一个完美的群体。\n\n17、冲突管理：团队中适度的沟通反而能够促进团队关系的更加融洽。而没有冲突的团队往往是一滩死水，有了冲突，各方才能更好的理解对方的思维模式和思考方式，进而促进团队的进一步完善。\n\n18、沟通的漏斗效应：是沟通就一定会衰减，但是如何让衰减尽可能的减小、控制在一定的范围呢。这大概需要更加重视沟通相关方的影响力。\n\n​\t当然，实际上还有更多内容，只是以上几点特别熟悉，整个PMP的考试过程确实给我带来了不少启发，我也希望以后能够逐步的把pmp中学到的一些知识应用到项目和团队管理中，并渴望能够带来效率上的提升。\n\n## 总结\n\n​\t好吧， 说那么多，我尽力了，是真的尽力了么，我完全还可以更努力啊。\n\n​\t当然，深受帕金森定律的影响，能够提前学的东西，到最后一天才学，不过庆幸自己的努力没有白费，相信一份付出，总有一份回报。\n\n \n\n\n \n","source":"_posts/随笔/PMP学习之旅回顾.md","raw":"---\ntitle: 复盘2019年，我花了3个月时间备考PMP\ndate: 2019-12-09 22:28\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n# 引子​\n\n​\t\t经过几个月的准备，终于在2019年12月7日完成了PMP的考试，并于今天查到了成绩，总结这次考试的具体情况：涉及题型虽然都没有超出大纲的范围，但是原题出现的概率似乎不高，还有一些原来未曾见过的题目，例如矩阵型组织或弱矩阵型组织等，以及造一个能够能飞三米的纸飞机，存在5%的废品，该如何处理，这样的题目让人有点摸不着头脑，还有一些原题，虽然是模拟题上的题目，但是。。我居然到了考试的时候居然忘记答案了，这有点过于尴尬。  \n\n## 为什么考PMP\n\n​\t回顾职场，我是在参加工作的第二年成为项目经理的，当时还是啥都不同的毛头小伙，就被公司指派担任一个十几万小项目的项目经理，并和两位老鸟一起共同参与项目的研发，每天都出入XX勘测设计院的大门之中，基本上都认识了这些勘测院的机关工作人员，还好这个项目本身技术并不复杂，加上有足够的资源和不急的时间需求，做出的成果也符合了甲方的需求，所以这个项目总体上处理的还算不错；\n\n​\t随后又参加了另外一个几十万的小项目，并在其中担任项目经理和技术负责人，由于有了一位资深工程师、一位资深从业者（虽然对编程技术不够了解，但是沟通能力很强）所以这个项目也能如鱼得水。\n\n​\t再后来同时带了两个项目，一个是XXX规划局的XX信息平台，一个是地下管线系统，同时带两个项目的压力确实很大，而且公司的技术水平其实并不好，这两个都是研发型项目，作为一个开发出生的我，难免很难同时兼顾两个项目，加上地下管线系统其实是有老鸟参与研发设计，而我基本上只用跟需求，而空间信息平台则是我带一些没有工作经验的新手，所以我对于管线系统也就没太放在心上，精力也就全部放在空间信息平台上，所以当项目结项时，虽然两个项目都完成了，但是差别却特别大，空间信息平台广受赞誉，为后来接下数百万的合同奠定了基础，而地下管线系统（其实合同额更高）中的老程序员们却由于被过度放权，反而疏于管理，虽然软件做出来了，但是却没能派上用场，到后来被尘封，只能成为一个经费项目。\n\n​\t再后来，公司内部组织结构发生了变更，我也进入了一个的高光时期，被选为部门的项目主管，同时兼顾多个项目，负责管理了超过20位项目团队成员，管了3个项目经理。当时的我一度以为是自己的优秀打动了领导，其实是因为公司确实是没人了，才让我临时暂代，然而我还以此为骄傲，最终什么事情都没搞好。\n\n​\t后来就从这家公司离职，开始了新的职场过程，前前后后也陆陆续续带了不少项目，有大有小，成功或失败，也或多或少有一些。总体上来评价，差强人意，虽然试图做好项目，但是却总感觉阻塞颇多，无论是人员上的，还是技术上，或者沟通上的，总觉得没有特别完美。尤其是做互联网项目时，花了许多时间去打磨产品，却依然没能做出令人眼前一亮的东西，固然与产品有一定的关系，其实也与未能管理领导的预期有更大的关系。\n\n​\t确实如此，一个成功的项目，首先要管好客户的预期，其次得做好资源的调配。真正好的项目经理，一定是那些看起来很闲的项目经理，因为他们把什么事情都能很好的规划，只是做好任务分配、任务审查、和任务总结以及汇报就够了，而像过去的我那样的渣项目经理，不仅事无巨细、连代码要管，衣食住行要管，还让大家累死累活下来也根本没赚到多少钱。\n\n​\t在IT领域，不仅软件开发有德雷福斯的能力成熟度模型，连项目经理也同样具备，同样必须经过一万小时，经过从新手到高级新手，到胜任者，精通者，到专家的蜕变，而这个过程，要么必须吃了很多亏（意味着要花费公司大量的人力物力财力来培养），要么就是能够真正自发成为专业的项目管理者。\n\n​\t事实上专业的项目管理者比开发者或许更困难，在我从业的这十年中，也遇到了个别优秀的项目经理，他们善于运用领导力的强大魄力，在项目各方间游刃有余，而更多的项目经理，都像我一样，运用程序员的沟通技巧，与各方沟通，往往会吃尽苦头。\n\n​\t技术出生的管理者，往往都具备类似的毛病：例如过度在意过程和实现；忽略沟通的力量；渴望全局掌控；缺乏领导艺术；缺乏政治敏感度；藐视人情世故等。好吧，在后来的项目过程中，我已经逐步掌握了沟通、政治敏感度和人情世故这样的法宝，并通过这种手段获得过各方的认同，但是还是或多或少在乎细节、在乎流程的完备性，反而忽略了对于客户预期的把控，最终依然造出了几个不太成果的项目。\n\n​\t一个人的成长，大概就是得经历从失败的挫折、吸取教训、逐渐成长的过程，无论是哪个岗位都大体类似。优秀的项目管理能力一定是开发者的必备基础技能，唯有灵活的掌握项目管理技能的多个方面，才能让软件项目能够高效、快速的契合各方的需求，实现组织从一种状态到另外一种状态。\n\n​\t如果说以前带的项目，基本上已经到了胜任者的层级，那么大概这种层级，其实是自封的，如何来真正证明自己具备\\胜任相关岗位呢，我觉得大概需要一个纸质证明了。这就是我打算考PMP的原因。\n\n## 为什么选择培训班\n\n​\t不过考PMP有很多种方式，而且PMP本身也不是一种特别困难的资格证，在我的身边已经有许多人考了PMP，并获得了证书，甚至有许多人拿到了5A证书，例如我参加的培训班，5A率已经超过70%了。\n\n​\t而在国内，每种证书最常见的质疑是，考这个有用么？我倒是觉得，有没有用先不管，至少学到知识的过程就一定值得花这点钱。知识的价值，也并非那些可以用直接卖多少钱来衡量，他其实是一点一滴深入你的骨肉，并最终构成你的灵魂，并且在需要体现价值的时候，一点一点的凸显出来。\n\n​\t除此之外，我也感觉虽然考试范围就是在PMBOOK这本书，而且只考前538页，但是书本上有太多内容了，每一个点都能够写出许多许多的故事出来，甚至而言，把五大过程，四十九过程组中，任意抽出一个过程组出来专精，都可以成为一个称职的专家，所以纯粹看书其实并不能提高自己对于项目管理技能的领悟力，而那些能够给我们提供培训的老师，他们往往首先是真正优秀的项目经理。其次不仅对项目管理这一本砖头书要烂熟于心，也需要能够用自己的语言把枯燥无味、干涩的知识讲出花来，这更需要本事。\n\n​\t再加上项目管理这种管理体系，其实更是一种团队技能，靠自己看书，往往找不到重点，而借助于培训机构，反而能够跟其他具有相同爱好的人一起学习，也算是一段不错的过程。\n\n​\t选择现代卓越面授班对我来说确实是个非常明智的决定，因为面授班确实是这样的好地方，大家一起讨论项目管理方面的问题，着实是一种不错的体验。\n\n## 通过培训获得的收获\n\n​\t近年来随着离软件公司越来越远，离各种行业软件越来越近，觉得自己的项目管理能力的某些方面诸如沟通表达能力和领导力有所提升，但是对于项目管理过层中的计划管理能力反而已经越来越差了。毕竟原来一直从事IT技术研发+项目管理，对于时间的计划安排，无外乎就是按照自己的经验去套、或者借助于模仿，这是初学者的典型惯例。\n\n​\t除此之外，在项目中，虽然用到了瀑布模型这种预测性生命周期来管理项目，但是又接触到许多敏捷的项目管理方法，所以技能点反而不纯粹了，总结就是，什么都懂一点，却什么都只懂一点，所以专业级项目经理是如何做项目的？这确实是一个值得仔细讨论的问题。而这也是参加培训最大的收获。\n\n​\t总结一下可以为我未来做项目提供指导的一些点：\n\n1、需求的重要-紧急矩阵：评估需求时，先把重要紧急矩阵画好，然后再来指导工作。以前难道不知道么，确实没这么系统的学习这套理论吧。\n\n2、权力-利益方格、相关方认知模型、相关方参与度评估矩阵：\n\n3、能力-欲望矩阵：有能力有欲望、有能力没欲望、没能力有欲望、没能力没欲望，你在哪个象限？值得深思。\n\n4、成本管理：老板的钱来之不易，成本管理得做好。\n\n6、三大管理学原理：彼得原理、帕金森定律和墨菲定律，大概可以好好讲一天。\n\n7、如何做好团队激励和团队建设：哪些是保健因素，哪些是激励因素，如何打造一支优秀的团队？知易行难啊。\n\n9、风险责任矩阵RBS:提前做好风险评估和责任人分配，让风险防范于未然很有必要。\n\n10、问题日志、经验教训登记册、风险登记册和营造积极分享的氛围。\n\n11、会议管理：罗伯特议事规则。开会太长确实需要规则。\n\n12、关键链法：盲目的设定项目工作包或活动其实没什么意义，倒不如先做好关键链，然后再逐步的实现里程碑，只要关键链做好了，往往也离项目做完不远了。毕竟一个项目是花有限的资源做有限的事，而不是无穷尽的盲目的投入。\n\n13、挣值分析技术：虽然挣值分析技术是一种数学评估方法，看起来有点不太精准，但是将这种技术高效的运用到项目中，也许会给项目管理带来不少便利。\n\n14、责任分解矩阵：做好工作分解和责任分解固然重要，更要给责任人指派明确的责任，而不是口头上的任命，做到有根有据，有考核指标和评价依据非常重要。\n\n15、塔克曼团队发展阶段理论：一个团队的成长早期，往往是相互独立、甚至互相提防的，只有互相磨合，经历开诚布公，才能打造成熟稳定的团队。\n\n16、TEAM团队理论：Today Everyone Achive More。没有完美的个人，只有完美的团队。团队并非一个人、而是大家彼此拿出自己最擅长的方面，共同打造一个完美的群体。\n\n17、冲突管理：团队中适度的沟通反而能够促进团队关系的更加融洽。而没有冲突的团队往往是一滩死水，有了冲突，各方才能更好的理解对方的思维模式和思考方式，进而促进团队的进一步完善。\n\n18、沟通的漏斗效应：是沟通就一定会衰减，但是如何让衰减尽可能的减小、控制在一定的范围呢。这大概需要更加重视沟通相关方的影响力。\n\n​\t当然，实际上还有更多内容，只是以上几点特别熟悉，整个PMP的考试过程确实给我带来了不少启发，我也希望以后能够逐步的把pmp中学到的一些知识应用到项目和团队管理中，并渴望能够带来效率上的提升。\n\n## 总结\n\n​\t好吧， 说那么多，我尽力了，是真的尽力了么，我完全还可以更努力啊。\n\n​\t当然，深受帕金森定律的影响，能够提前学的东西，到最后一天才学，不过庆幸自己的努力没有白费，相信一份付出，总有一份回报。\n\n \n\n\n \n","slug":"随笔/PMP学习之旅回顾","published":1,"updated":"2020-02-06T14:03:26.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt8w0033n4vi6wufclbm","content":"<h1 id=\"引子​\"><a href=\"#引子​\" class=\"headerlink\" title=\"引子​\"></a>引子​</h1><p>​        经过几个月的准备，终于在2019年12月7日完成了PMP的考试，并于今天查到了成绩，总结这次考试的具体情况：涉及题型虽然都没有超出大纲的范围，但是原题出现的概率似乎不高，还有一些原来未曾见过的题目，例如矩阵型组织或弱矩阵型组织等，以及造一个能够能飞三米的纸飞机，存在5%的废品，该如何处理，这样的题目让人有点摸不着头脑，还有一些原题，虽然是模拟题上的题目，但是。。我居然到了考试的时候居然忘记答案了，这有点过于尴尬。  </p>\n<h2 id=\"为什么考PMP\"><a href=\"#为什么考PMP\" class=\"headerlink\" title=\"为什么考PMP\"></a>为什么考PMP</h2><p>​    回顾职场，我是在参加工作的第二年成为项目经理的，当时还是啥都不同的毛头小伙，就被公司指派担任一个十几万小项目的项目经理，并和两位老鸟一起共同参与项目的研发，每天都出入XX勘测设计院的大门之中，基本上都认识了这些勘测院的机关工作人员，还好这个项目本身技术并不复杂，加上有足够的资源和不急的时间需求，做出的成果也符合了甲方的需求，所以这个项目总体上处理的还算不错；</p>\n<p>​    随后又参加了另外一个几十万的小项目，并在其中担任项目经理和技术负责人，由于有了一位资深工程师、一位资深从业者（虽然对编程技术不够了解，但是沟通能力很强）所以这个项目也能如鱼得水。</p>\n<p>​    再后来同时带了两个项目，一个是XXX规划局的XX信息平台，一个是地下管线系统，同时带两个项目的压力确实很大，而且公司的技术水平其实并不好，这两个都是研发型项目，作为一个开发出生的我，难免很难同时兼顾两个项目，加上地下管线系统其实是有老鸟参与研发设计，而我基本上只用跟需求，而空间信息平台则是我带一些没有工作经验的新手，所以我对于管线系统也就没太放在心上，精力也就全部放在空间信息平台上，所以当项目结项时，虽然两个项目都完成了，但是差别却特别大，空间信息平台广受赞誉，为后来接下数百万的合同奠定了基础，而地下管线系统（其实合同额更高）中的老程序员们却由于被过度放权，反而疏于管理，虽然软件做出来了，但是却没能派上用场，到后来被尘封，只能成为一个经费项目。</p>\n<p>​    再后来，公司内部组织结构发生了变更，我也进入了一个的高光时期，被选为部门的项目主管，同时兼顾多个项目，负责管理了超过20位项目团队成员，管了3个项目经理。当时的我一度以为是自己的优秀打动了领导，其实是因为公司确实是没人了，才让我临时暂代，然而我还以此为骄傲，最终什么事情都没搞好。</p>\n<p>​    后来就从这家公司离职，开始了新的职场过程，前前后后也陆陆续续带了不少项目，有大有小，成功或失败，也或多或少有一些。总体上来评价，差强人意，虽然试图做好项目，但是却总感觉阻塞颇多，无论是人员上的，还是技术上，或者沟通上的，总觉得没有特别完美。尤其是做互联网项目时，花了许多时间去打磨产品，却依然没能做出令人眼前一亮的东西，固然与产品有一定的关系，其实也与未能管理领导的预期有更大的关系。</p>\n<p>​    确实如此，一个成功的项目，首先要管好客户的预期，其次得做好资源的调配。真正好的项目经理，一定是那些看起来很闲的项目经理，因为他们把什么事情都能很好的规划，只是做好任务分配、任务审查、和任务总结以及汇报就够了，而像过去的我那样的渣项目经理，不仅事无巨细、连代码要管，衣食住行要管，还让大家累死累活下来也根本没赚到多少钱。</p>\n<p>​    在IT领域，不仅软件开发有德雷福斯的能力成熟度模型，连项目经理也同样具备，同样必须经过一万小时，经过从新手到高级新手，到胜任者，精通者，到专家的蜕变，而这个过程，要么必须吃了很多亏（意味着要花费公司大量的人力物力财力来培养），要么就是能够真正自发成为专业的项目管理者。</p>\n<p>​    事实上专业的项目管理者比开发者或许更困难，在我从业的这十年中，也遇到了个别优秀的项目经理，他们善于运用领导力的强大魄力，在项目各方间游刃有余，而更多的项目经理，都像我一样，运用程序员的沟通技巧，与各方沟通，往往会吃尽苦头。</p>\n<p>​    技术出生的管理者，往往都具备类似的毛病：例如过度在意过程和实现；忽略沟通的力量；渴望全局掌控；缺乏领导艺术；缺乏政治敏感度；藐视人情世故等。好吧，在后来的项目过程中，我已经逐步掌握了沟通、政治敏感度和人情世故这样的法宝，并通过这种手段获得过各方的认同，但是还是或多或少在乎细节、在乎流程的完备性，反而忽略了对于客户预期的把控，最终依然造出了几个不太成果的项目。</p>\n<p>​    一个人的成长，大概就是得经历从失败的挫折、吸取教训、逐渐成长的过程，无论是哪个岗位都大体类似。优秀的项目管理能力一定是开发者的必备基础技能，唯有灵活的掌握项目管理技能的多个方面，才能让软件项目能够高效、快速的契合各方的需求，实现组织从一种状态到另外一种状态。</p>\n<p>​    如果说以前带的项目，基本上已经到了胜任者的层级，那么大概这种层级，其实是自封的，如何来真正证明自己具备\\胜任相关岗位呢，我觉得大概需要一个纸质证明了。这就是我打算考PMP的原因。</p>\n<h2 id=\"为什么选择培训班\"><a href=\"#为什么选择培训班\" class=\"headerlink\" title=\"为什么选择培训班\"></a>为什么选择培训班</h2><p>​    不过考PMP有很多种方式，而且PMP本身也不是一种特别困难的资格证，在我的身边已经有许多人考了PMP，并获得了证书，甚至有许多人拿到了5A证书，例如我参加的培训班，5A率已经超过70%了。</p>\n<p>​    而在国内，每种证书最常见的质疑是，考这个有用么？我倒是觉得，有没有用先不管，至少学到知识的过程就一定值得花这点钱。知识的价值，也并非那些可以用直接卖多少钱来衡量，他其实是一点一滴深入你的骨肉，并最终构成你的灵魂，并且在需要体现价值的时候，一点一点的凸显出来。</p>\n<p>​    除此之外，我也感觉虽然考试范围就是在PMBOOK这本书，而且只考前538页，但是书本上有太多内容了，每一个点都能够写出许多许多的故事出来，甚至而言，把五大过程，四十九过程组中，任意抽出一个过程组出来专精，都可以成为一个称职的专家，所以纯粹看书其实并不能提高自己对于项目管理技能的领悟力，而那些能够给我们提供培训的老师，他们往往首先是真正优秀的项目经理。其次不仅对项目管理这一本砖头书要烂熟于心，也需要能够用自己的语言把枯燥无味、干涩的知识讲出花来，这更需要本事。</p>\n<p>​    再加上项目管理这种管理体系，其实更是一种团队技能，靠自己看书，往往找不到重点，而借助于培训机构，反而能够跟其他具有相同爱好的人一起学习，也算是一段不错的过程。</p>\n<p>​    选择现代卓越面授班对我来说确实是个非常明智的决定，因为面授班确实是这样的好地方，大家一起讨论项目管理方面的问题，着实是一种不错的体验。</p>\n<h2 id=\"通过培训获得的收获\"><a href=\"#通过培训获得的收获\" class=\"headerlink\" title=\"通过培训获得的收获\"></a>通过培训获得的收获</h2><p>​    近年来随着离软件公司越来越远，离各种行业软件越来越近，觉得自己的项目管理能力的某些方面诸如沟通表达能力和领导力有所提升，但是对于项目管理过层中的计划管理能力反而已经越来越差了。毕竟原来一直从事IT技术研发+项目管理，对于时间的计划安排，无外乎就是按照自己的经验去套、或者借助于模仿，这是初学者的典型惯例。</p>\n<p>​    除此之外，在项目中，虽然用到了瀑布模型这种预测性生命周期来管理项目，但是又接触到许多敏捷的项目管理方法，所以技能点反而不纯粹了，总结就是，什么都懂一点，却什么都只懂一点，所以专业级项目经理是如何做项目的？这确实是一个值得仔细讨论的问题。而这也是参加培训最大的收获。</p>\n<p>​    总结一下可以为我未来做项目提供指导的一些点：</p>\n<p>1、需求的重要-紧急矩阵：评估需求时，先把重要紧急矩阵画好，然后再来指导工作。以前难道不知道么，确实没这么系统的学习这套理论吧。</p>\n<p>2、权力-利益方格、相关方认知模型、相关方参与度评估矩阵：</p>\n<p>3、能力-欲望矩阵：有能力有欲望、有能力没欲望、没能力有欲望、没能力没欲望，你在哪个象限？值得深思。</p>\n<p>4、成本管理：老板的钱来之不易，成本管理得做好。</p>\n<p>6、三大管理学原理：彼得原理、帕金森定律和墨菲定律，大概可以好好讲一天。</p>\n<p>7、如何做好团队激励和团队建设：哪些是保健因素，哪些是激励因素，如何打造一支优秀的团队？知易行难啊。</p>\n<p>9、风险责任矩阵RBS:提前做好风险评估和责任人分配，让风险防范于未然很有必要。</p>\n<p>10、问题日志、经验教训登记册、风险登记册和营造积极分享的氛围。</p>\n<p>11、会议管理：罗伯特议事规则。开会太长确实需要规则。</p>\n<p>12、关键链法：盲目的设定项目工作包或活动其实没什么意义，倒不如先做好关键链，然后再逐步的实现里程碑，只要关键链做好了，往往也离项目做完不远了。毕竟一个项目是花有限的资源做有限的事，而不是无穷尽的盲目的投入。</p>\n<p>13、挣值分析技术：虽然挣值分析技术是一种数学评估方法，看起来有点不太精准，但是将这种技术高效的运用到项目中，也许会给项目管理带来不少便利。</p>\n<p>14、责任分解矩阵：做好工作分解和责任分解固然重要，更要给责任人指派明确的责任，而不是口头上的任命，做到有根有据，有考核指标和评价依据非常重要。</p>\n<p>15、塔克曼团队发展阶段理论：一个团队的成长早期，往往是相互独立、甚至互相提防的，只有互相磨合，经历开诚布公，才能打造成熟稳定的团队。</p>\n<p>16、TEAM团队理论：Today Everyone Achive More。没有完美的个人，只有完美的团队。团队并非一个人、而是大家彼此拿出自己最擅长的方面，共同打造一个完美的群体。</p>\n<p>17、冲突管理：团队中适度的沟通反而能够促进团队关系的更加融洽。而没有冲突的团队往往是一滩死水，有了冲突，各方才能更好的理解对方的思维模式和思考方式，进而促进团队的进一步完善。</p>\n<p>18、沟通的漏斗效应：是沟通就一定会衰减，但是如何让衰减尽可能的减小、控制在一定的范围呢。这大概需要更加重视沟通相关方的影响力。</p>\n<p>​    当然，实际上还有更多内容，只是以上几点特别熟悉，整个PMP的考试过程确实给我带来了不少启发，我也希望以后能够逐步的把pmp中学到的一些知识应用到项目和团队管理中，并渴望能够带来效率上的提升。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>​    好吧， 说那么多，我尽力了，是真的尽力了么，我完全还可以更努力啊。</p>\n<p>​    当然，深受帕金森定律的影响，能够提前学的东西，到最后一天才学，不过庆幸自己的努力没有白费，相信一份付出，总有一份回报。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引子​\"><a href=\"#引子​\" class=\"headerlink\" title=\"引子​\"></a>引子​</h1><p>​        经过几个月的准备，终于在2019年12月7日完成了PMP的考试，并于今天查到了成绩，总结这次考试的具体情况：涉及题型虽然都没有超出大纲的范围，但是原题出现的概率似乎不高，还有一些原来未曾见过的题目，例如矩阵型组织或弱矩阵型组织等，以及造一个能够能飞三米的纸飞机，存在5%的废品，该如何处理，这样的题目让人有点摸不着头脑，还有一些原题，虽然是模拟题上的题目，但是。。我居然到了考试的时候居然忘记答案了，这有点过于尴尬。  </p>\n<h2 id=\"为什么考PMP\"><a href=\"#为什么考PMP\" class=\"headerlink\" title=\"为什么考PMP\"></a>为什么考PMP</h2><p>​    回顾职场，我是在参加工作的第二年成为项目经理的，当时还是啥都不同的毛头小伙，就被公司指派担任一个十几万小项目的项目经理，并和两位老鸟一起共同参与项目的研发，每天都出入XX勘测设计院的大门之中，基本上都认识了这些勘测院的机关工作人员，还好这个项目本身技术并不复杂，加上有足够的资源和不急的时间需求，做出的成果也符合了甲方的需求，所以这个项目总体上处理的还算不错；</p>\n<p>​    随后又参加了另外一个几十万的小项目，并在其中担任项目经理和技术负责人，由于有了一位资深工程师、一位资深从业者（虽然对编程技术不够了解，但是沟通能力很强）所以这个项目也能如鱼得水。</p>\n<p>​    再后来同时带了两个项目，一个是XXX规划局的XX信息平台，一个是地下管线系统，同时带两个项目的压力确实很大，而且公司的技术水平其实并不好，这两个都是研发型项目，作为一个开发出生的我，难免很难同时兼顾两个项目，加上地下管线系统其实是有老鸟参与研发设计，而我基本上只用跟需求，而空间信息平台则是我带一些没有工作经验的新手，所以我对于管线系统也就没太放在心上，精力也就全部放在空间信息平台上，所以当项目结项时，虽然两个项目都完成了，但是差别却特别大，空间信息平台广受赞誉，为后来接下数百万的合同奠定了基础，而地下管线系统（其实合同额更高）中的老程序员们却由于被过度放权，反而疏于管理，虽然软件做出来了，但是却没能派上用场，到后来被尘封，只能成为一个经费项目。</p>\n<p>​    再后来，公司内部组织结构发生了变更，我也进入了一个的高光时期，被选为部门的项目主管，同时兼顾多个项目，负责管理了超过20位项目团队成员，管了3个项目经理。当时的我一度以为是自己的优秀打动了领导，其实是因为公司确实是没人了，才让我临时暂代，然而我还以此为骄傲，最终什么事情都没搞好。</p>\n<p>​    后来就从这家公司离职，开始了新的职场过程，前前后后也陆陆续续带了不少项目，有大有小，成功或失败，也或多或少有一些。总体上来评价，差强人意，虽然试图做好项目，但是却总感觉阻塞颇多，无论是人员上的，还是技术上，或者沟通上的，总觉得没有特别完美。尤其是做互联网项目时，花了许多时间去打磨产品，却依然没能做出令人眼前一亮的东西，固然与产品有一定的关系，其实也与未能管理领导的预期有更大的关系。</p>\n<p>​    确实如此，一个成功的项目，首先要管好客户的预期，其次得做好资源的调配。真正好的项目经理，一定是那些看起来很闲的项目经理，因为他们把什么事情都能很好的规划，只是做好任务分配、任务审查、和任务总结以及汇报就够了，而像过去的我那样的渣项目经理，不仅事无巨细、连代码要管，衣食住行要管，还让大家累死累活下来也根本没赚到多少钱。</p>\n<p>​    在IT领域，不仅软件开发有德雷福斯的能力成熟度模型，连项目经理也同样具备，同样必须经过一万小时，经过从新手到高级新手，到胜任者，精通者，到专家的蜕变，而这个过程，要么必须吃了很多亏（意味着要花费公司大量的人力物力财力来培养），要么就是能够真正自发成为专业的项目管理者。</p>\n<p>​    事实上专业的项目管理者比开发者或许更困难，在我从业的这十年中，也遇到了个别优秀的项目经理，他们善于运用领导力的强大魄力，在项目各方间游刃有余，而更多的项目经理，都像我一样，运用程序员的沟通技巧，与各方沟通，往往会吃尽苦头。</p>\n<p>​    技术出生的管理者，往往都具备类似的毛病：例如过度在意过程和实现；忽略沟通的力量；渴望全局掌控；缺乏领导艺术；缺乏政治敏感度；藐视人情世故等。好吧，在后来的项目过程中，我已经逐步掌握了沟通、政治敏感度和人情世故这样的法宝，并通过这种手段获得过各方的认同，但是还是或多或少在乎细节、在乎流程的完备性，反而忽略了对于客户预期的把控，最终依然造出了几个不太成果的项目。</p>\n<p>​    一个人的成长，大概就是得经历从失败的挫折、吸取教训、逐渐成长的过程，无论是哪个岗位都大体类似。优秀的项目管理能力一定是开发者的必备基础技能，唯有灵活的掌握项目管理技能的多个方面，才能让软件项目能够高效、快速的契合各方的需求，实现组织从一种状态到另外一种状态。</p>\n<p>​    如果说以前带的项目，基本上已经到了胜任者的层级，那么大概这种层级，其实是自封的，如何来真正证明自己具备\\胜任相关岗位呢，我觉得大概需要一个纸质证明了。这就是我打算考PMP的原因。</p>\n<h2 id=\"为什么选择培训班\"><a href=\"#为什么选择培训班\" class=\"headerlink\" title=\"为什么选择培训班\"></a>为什么选择培训班</h2><p>​    不过考PMP有很多种方式，而且PMP本身也不是一种特别困难的资格证，在我的身边已经有许多人考了PMP，并获得了证书，甚至有许多人拿到了5A证书，例如我参加的培训班，5A率已经超过70%了。</p>\n<p>​    而在国内，每种证书最常见的质疑是，考这个有用么？我倒是觉得，有没有用先不管，至少学到知识的过程就一定值得花这点钱。知识的价值，也并非那些可以用直接卖多少钱来衡量，他其实是一点一滴深入你的骨肉，并最终构成你的灵魂，并且在需要体现价值的时候，一点一点的凸显出来。</p>\n<p>​    除此之外，我也感觉虽然考试范围就是在PMBOOK这本书，而且只考前538页，但是书本上有太多内容了，每一个点都能够写出许多许多的故事出来，甚至而言，把五大过程，四十九过程组中，任意抽出一个过程组出来专精，都可以成为一个称职的专家，所以纯粹看书其实并不能提高自己对于项目管理技能的领悟力，而那些能够给我们提供培训的老师，他们往往首先是真正优秀的项目经理。其次不仅对项目管理这一本砖头书要烂熟于心，也需要能够用自己的语言把枯燥无味、干涩的知识讲出花来，这更需要本事。</p>\n<p>​    再加上项目管理这种管理体系，其实更是一种团队技能，靠自己看书，往往找不到重点，而借助于培训机构，反而能够跟其他具有相同爱好的人一起学习，也算是一段不错的过程。</p>\n<p>​    选择现代卓越面授班对我来说确实是个非常明智的决定，因为面授班确实是这样的好地方，大家一起讨论项目管理方面的问题，着实是一种不错的体验。</p>\n<h2 id=\"通过培训获得的收获\"><a href=\"#通过培训获得的收获\" class=\"headerlink\" title=\"通过培训获得的收获\"></a>通过培训获得的收获</h2><p>​    近年来随着离软件公司越来越远，离各种行业软件越来越近，觉得自己的项目管理能力的某些方面诸如沟通表达能力和领导力有所提升，但是对于项目管理过层中的计划管理能力反而已经越来越差了。毕竟原来一直从事IT技术研发+项目管理，对于时间的计划安排，无外乎就是按照自己的经验去套、或者借助于模仿，这是初学者的典型惯例。</p>\n<p>​    除此之外，在项目中，虽然用到了瀑布模型这种预测性生命周期来管理项目，但是又接触到许多敏捷的项目管理方法，所以技能点反而不纯粹了，总结就是，什么都懂一点，却什么都只懂一点，所以专业级项目经理是如何做项目的？这确实是一个值得仔细讨论的问题。而这也是参加培训最大的收获。</p>\n<p>​    总结一下可以为我未来做项目提供指导的一些点：</p>\n<p>1、需求的重要-紧急矩阵：评估需求时，先把重要紧急矩阵画好，然后再来指导工作。以前难道不知道么，确实没这么系统的学习这套理论吧。</p>\n<p>2、权力-利益方格、相关方认知模型、相关方参与度评估矩阵：</p>\n<p>3、能力-欲望矩阵：有能力有欲望、有能力没欲望、没能力有欲望、没能力没欲望，你在哪个象限？值得深思。</p>\n<p>4、成本管理：老板的钱来之不易，成本管理得做好。</p>\n<p>6、三大管理学原理：彼得原理、帕金森定律和墨菲定律，大概可以好好讲一天。</p>\n<p>7、如何做好团队激励和团队建设：哪些是保健因素，哪些是激励因素，如何打造一支优秀的团队？知易行难啊。</p>\n<p>9、风险责任矩阵RBS:提前做好风险评估和责任人分配，让风险防范于未然很有必要。</p>\n<p>10、问题日志、经验教训登记册、风险登记册和营造积极分享的氛围。</p>\n<p>11、会议管理：罗伯特议事规则。开会太长确实需要规则。</p>\n<p>12、关键链法：盲目的设定项目工作包或活动其实没什么意义，倒不如先做好关键链，然后再逐步的实现里程碑，只要关键链做好了，往往也离项目做完不远了。毕竟一个项目是花有限的资源做有限的事，而不是无穷尽的盲目的投入。</p>\n<p>13、挣值分析技术：虽然挣值分析技术是一种数学评估方法，看起来有点不太精准，但是将这种技术高效的运用到项目中，也许会给项目管理带来不少便利。</p>\n<p>14、责任分解矩阵：做好工作分解和责任分解固然重要，更要给责任人指派明确的责任，而不是口头上的任命，做到有根有据，有考核指标和评价依据非常重要。</p>\n<p>15、塔克曼团队发展阶段理论：一个团队的成长早期，往往是相互独立、甚至互相提防的，只有互相磨合，经历开诚布公，才能打造成熟稳定的团队。</p>\n<p>16、TEAM团队理论：Today Everyone Achive More。没有完美的个人，只有完美的团队。团队并非一个人、而是大家彼此拿出自己最擅长的方面，共同打造一个完美的群体。</p>\n<p>17、冲突管理：团队中适度的沟通反而能够促进团队关系的更加融洽。而没有冲突的团队往往是一滩死水，有了冲突，各方才能更好的理解对方的思维模式和思考方式，进而促进团队的进一步完善。</p>\n<p>18、沟通的漏斗效应：是沟通就一定会衰减，但是如何让衰减尽可能的减小、控制在一定的范围呢。这大概需要更加重视沟通相关方的影响力。</p>\n<p>​    当然，实际上还有更多内容，只是以上几点特别熟悉，整个PMP的考试过程确实给我带来了不少启发，我也希望以后能够逐步的把pmp中学到的一些知识应用到项目和团队管理中，并渴望能够带来效率上的提升。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>​    好吧， 说那么多，我尽力了，是真的尽力了么，我完全还可以更努力啊。</p>\n<p>​    当然，深受帕金森定律的影响，能够提前学的东西，到最后一天才学，不过庆幸自己的努力没有白费，相信一份付出，总有一份回报。</p>\n"},{"title":"一位996\\Crud开发者平凡的一天","date":"2019-10-09T08:28:00.000Z","author":"邹溪源","_content":"\n# 记一笔流水账\n今天我打算记一笔流水账，主要记录我的一天中干的事情，并思考效率低下的原因，同时分析一些可用的解决方案。\n# 清早·开始做计划\n早上六点四十，被梦想唤醒，然后看一会书，吃早餐，送娃上学。\n九点来到公司，开始一天的工作。在工作开始之前，我会花五分钟先做一个当天的计划，大概是这样的。 \n1. *~~（讲道理应该有每日站会，事实上我是xx项目的负责人，但是。。我把站会给省了，把站会取消对项目的危害非常大。后期再讨论）~~*\n2. 对xx项目的周计划进行跟进和修订。\n3. 检查昨天完成的功能，并记录和指派bug。\n4. 整理文档，对昨天完成新功能的特性进行说明。\n5. 解决属于自己名下的bug。\n6. 开始两个下一阶段需要交付的新功能，比较简单的业务接口，代码行预计不超过80行。\n\n这些任务中，除了第五项和第六项相对来说可能会耗时比较长外，其他每个单项任务基本上可以在25分钟内完成，而且也确实是按任务优先级和重要性顺序来安排的，看起来还挺合理的，总体上属于在8小时内可以完成的工作量，而且其实或许还略微有点不饱和。。。\n# 执行任务（下面是流水账，可以略过）\n于是我喝了一口水，开始完成第一项任务：对xxx项目的周计划进行跟进和修订。\n（如果是周一，以前我还会根据上周完成情况对月计划和总体计划进行适度的总结，但是。。自从来到互联网公司后，我把这个好习惯也丢掉了，好吧，是因为假装要敏捷要拥抱变化，所以把总体计划和月计划省掉了）。\n但是，当我开始处理这项事务时，计划外的第一件事情发生了。在测试环境下，客户端反映某接口出现了不该出现的问题，于是我被迫打断这项任务，花了一分钟时间，跟他对接口问题进行了检查，发现是对方参数传错了。\n嗯。问题解决。继续开始刚刚的任务。\n到哪里了？哦。。还在做计划，接着我迅速调整状态，花了几分钟就把任务完成了。\n然后开始第二项任务。\n这时，刚刚客户端又找我了，他说接口还是有问题。\n我以为又只要花一分钟，事实上这次我花了30分钟，因为确实是原来的代码逻辑中存在缺陷，需要进行代码修改、然后发布、再测试代码。\n确认这个问题已经得到解决后，还是处理之前搁置的任务。花了20分钟处理任务3。\n开始处理任务4，这项任务也相对来说比较简单，所以不到五分钟解决了。\n开始处理任务5。。。在我名下共有20个bug。。。以每个bug5分钟来衡量，我大概需要花100分钟才能解决。但是当我开始解决第一个bug时。\n又有其他人开始找我了，运营开始找我，说xxx场景下似乎出现了xxx逻辑不对。\n线上问题必须优先解决，赶紧的，仔细思考问题发生的条件、对链路服务进行跟踪和分析、查看半年前编写的代码逻辑，最终花了15分钟分析出问题，并花了10分钟将问题妥善解决。\n继续开始修复bug。在bug修复的过程中，发现是产品逻辑存在缺陷，于是跟产品对任务进行进一步明确、梳理业务、设计更加具体细化的流程。花了1小时。\n到中午12点，我上午共完成任务3项，修复了一个bug。\n下午不属于问题的高峰期，但是又发现了产品逻辑之外的一些其他问题，最终解决了15个bug。\n积压了5个bug，留到晚上来解决吧。\n当夜幕降临，我需要花2个小时来解决我剩余的bug和2个未完成的新功能开发任务。\n事实上等到晚上八点半时，我完成了剩余bug，新功能完成了一个，但此时效率已经差的不行了，没办法，硬着头皮也得完成今天的任务。\n（会不会欠下新债，显然毋庸置疑）\n晚上9点，所有任务已基本上圆满完成。\n# 总结完成情况\n总结今天完成的任务，共完成任务五项，其中修复bug20个，写了60行新代码，共耗时10小时。\n显然我的工作效率是很差的，尤其是晚上效率更差，我最佩服那些自称晚上效率很高的人，尤其还有一些人特别喜欢深夜撸码，倒上一杯小酒，借着凌晨的寂静，写着爱写的代码，他们很厉害，因为他们很会自欺欺人。\n来统计当天完成工作的工时占比：\n| 工作内容   | 时间（分钟）   | \n|:----|:----|\n| 梳理日计划   | 5   | \n| 修订周计划   | 10   | \n| 接口联调   | 31   | \n| 运营对接   | 25   | \n| 修复20个bug   | 250   | \n| 编写新功能   | 120   | \n| 日常项目沟通   | 120   | \n| 其他   | 40   | \n| 总计   | 601   | \n\n# ![图片](https://uploader.shimo.im/f/RunvG8elYn0zjxaO.png!thumbnail)\n# 问题分析\n以上流水账实际上是我们这样一家普通互联网公司的日常，当然，对我个人而言，实际上投入到运营对接中的时间相对来说是不算多的，我了解我们公司有的开发者每天需要花至少3小时与运营人员进行问题的对接，这显然会直接影响了开发者的工作效率。\n（我相信一流互联网公司一定不是这样的）\n从上图可以看出我们的日常工作安排存在以下问题：\n* 修复bug这种还技术债的任务，耗时接近47%，占了将近一半的时间。嗯，能力确实不行，能不能采取措施让债不欠这么多，这是人才三角（专业技能、行业知识、软实力）需要达到的目标。我曾经打算在功能开发中引入TDD来减少返工率，但是最终决定还是先搁置这个想法。\n* 我司项目管理的形式是虚拟团队，产品经理和测试工程师主要在深圳，而研发团队在长沙，因此，每天投入到团队沟通中的时间占比达到20%。事实上虚拟团队这种开发模式，作为目前比较新兴的项目沟通形式，已经被互联网公司广泛采用。但是虚拟团队成员间分处异地、无法面对面沟通，由于文化、工作节奏、技术等原因，容易造成比较大的沟通成本。可以采取以下措施进行优化：\n  * 1、打造高保真原型图，进一步拆解任务目标，让任务目标细分。\n  * 2、需求讨论时间前置，需求的特点是渐进明细的，应尽量将对需求的沟通在研发阶段开始前进行落实，减少对于研发阶段过程中的额外时间浪费。\n  * 3、快速冲刺阶段尽可能面对面沟通。\n  * 4、功能交付缺乏Desktop Check，意味着产品经理和测试工程师无法及时了解功能的实际开发情况，也意味着团队间对于成果的交付进度、实现方式，本身是存在疑问的，这将提高沟通成本。\n* 如果按每天工作十小时，为3小时为与运营沟通问题的解决来算，占比达30%。说明对于项目成果的交付上，依然存在不少可以优化和提升的空间。或许可以采取以下措施。\n  * FAQ文档的进一步细化。\n  * 知识共享。\n  * 项目成果移交本身需要有更加规范化的管理措施。\n\n# 结论\n以上是一位CRUD互联网996开发者的一天，看起来似乎过得很充实， 却依然需要通过加班来完成当天的任务，而且甚至长期工作时间大于10个小时，与体力劳动者本身没有太大区别。也许总是像机器一样活着，思考都成为一种负担。总以为靠蛮力可以解决，实际上输出的或许是一种无用的解决方案。这样的付出，大概会觉得毫无价值。\n然而我们必须停驻脚步，认真思考当下的价值，思考效率和意义的平衡，让我们的生活更加有意义。\n牢记准则：*“做正确的事，正确的做事”。*\n\n","source":"_posts/随笔/一位996、CRUD开发者的一天.md","raw":"---\ntitle:  一位996\\Crud开发者平凡的一天\ndate: 2019-10-09 16:28\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n\n# 记一笔流水账\n今天我打算记一笔流水账，主要记录我的一天中干的事情，并思考效率低下的原因，同时分析一些可用的解决方案。\n# 清早·开始做计划\n早上六点四十，被梦想唤醒，然后看一会书，吃早餐，送娃上学。\n九点来到公司，开始一天的工作。在工作开始之前，我会花五分钟先做一个当天的计划，大概是这样的。 \n1. *~~（讲道理应该有每日站会，事实上我是xx项目的负责人，但是。。我把站会给省了，把站会取消对项目的危害非常大。后期再讨论）~~*\n2. 对xx项目的周计划进行跟进和修订。\n3. 检查昨天完成的功能，并记录和指派bug。\n4. 整理文档，对昨天完成新功能的特性进行说明。\n5. 解决属于自己名下的bug。\n6. 开始两个下一阶段需要交付的新功能，比较简单的业务接口，代码行预计不超过80行。\n\n这些任务中，除了第五项和第六项相对来说可能会耗时比较长外，其他每个单项任务基本上可以在25分钟内完成，而且也确实是按任务优先级和重要性顺序来安排的，看起来还挺合理的，总体上属于在8小时内可以完成的工作量，而且其实或许还略微有点不饱和。。。\n# 执行任务（下面是流水账，可以略过）\n于是我喝了一口水，开始完成第一项任务：对xxx项目的周计划进行跟进和修订。\n（如果是周一，以前我还会根据上周完成情况对月计划和总体计划进行适度的总结，但是。。自从来到互联网公司后，我把这个好习惯也丢掉了，好吧，是因为假装要敏捷要拥抱变化，所以把总体计划和月计划省掉了）。\n但是，当我开始处理这项事务时，计划外的第一件事情发生了。在测试环境下，客户端反映某接口出现了不该出现的问题，于是我被迫打断这项任务，花了一分钟时间，跟他对接口问题进行了检查，发现是对方参数传错了。\n嗯。问题解决。继续开始刚刚的任务。\n到哪里了？哦。。还在做计划，接着我迅速调整状态，花了几分钟就把任务完成了。\n然后开始第二项任务。\n这时，刚刚客户端又找我了，他说接口还是有问题。\n我以为又只要花一分钟，事实上这次我花了30分钟，因为确实是原来的代码逻辑中存在缺陷，需要进行代码修改、然后发布、再测试代码。\n确认这个问题已经得到解决后，还是处理之前搁置的任务。花了20分钟处理任务3。\n开始处理任务4，这项任务也相对来说比较简单，所以不到五分钟解决了。\n开始处理任务5。。。在我名下共有20个bug。。。以每个bug5分钟来衡量，我大概需要花100分钟才能解决。但是当我开始解决第一个bug时。\n又有其他人开始找我了，运营开始找我，说xxx场景下似乎出现了xxx逻辑不对。\n线上问题必须优先解决，赶紧的，仔细思考问题发生的条件、对链路服务进行跟踪和分析、查看半年前编写的代码逻辑，最终花了15分钟分析出问题，并花了10分钟将问题妥善解决。\n继续开始修复bug。在bug修复的过程中，发现是产品逻辑存在缺陷，于是跟产品对任务进行进一步明确、梳理业务、设计更加具体细化的流程。花了1小时。\n到中午12点，我上午共完成任务3项，修复了一个bug。\n下午不属于问题的高峰期，但是又发现了产品逻辑之外的一些其他问题，最终解决了15个bug。\n积压了5个bug，留到晚上来解决吧。\n当夜幕降临，我需要花2个小时来解决我剩余的bug和2个未完成的新功能开发任务。\n事实上等到晚上八点半时，我完成了剩余bug，新功能完成了一个，但此时效率已经差的不行了，没办法，硬着头皮也得完成今天的任务。\n（会不会欠下新债，显然毋庸置疑）\n晚上9点，所有任务已基本上圆满完成。\n# 总结完成情况\n总结今天完成的任务，共完成任务五项，其中修复bug20个，写了60行新代码，共耗时10小时。\n显然我的工作效率是很差的，尤其是晚上效率更差，我最佩服那些自称晚上效率很高的人，尤其还有一些人特别喜欢深夜撸码，倒上一杯小酒，借着凌晨的寂静，写着爱写的代码，他们很厉害，因为他们很会自欺欺人。\n来统计当天完成工作的工时占比：\n| 工作内容   | 时间（分钟）   | \n|:----|:----|\n| 梳理日计划   | 5   | \n| 修订周计划   | 10   | \n| 接口联调   | 31   | \n| 运营对接   | 25   | \n| 修复20个bug   | 250   | \n| 编写新功能   | 120   | \n| 日常项目沟通   | 120   | \n| 其他   | 40   | \n| 总计   | 601   | \n\n# ![图片](https://uploader.shimo.im/f/RunvG8elYn0zjxaO.png!thumbnail)\n# 问题分析\n以上流水账实际上是我们这样一家普通互联网公司的日常，当然，对我个人而言，实际上投入到运营对接中的时间相对来说是不算多的，我了解我们公司有的开发者每天需要花至少3小时与运营人员进行问题的对接，这显然会直接影响了开发者的工作效率。\n（我相信一流互联网公司一定不是这样的）\n从上图可以看出我们的日常工作安排存在以下问题：\n* 修复bug这种还技术债的任务，耗时接近47%，占了将近一半的时间。嗯，能力确实不行，能不能采取措施让债不欠这么多，这是人才三角（专业技能、行业知识、软实力）需要达到的目标。我曾经打算在功能开发中引入TDD来减少返工率，但是最终决定还是先搁置这个想法。\n* 我司项目管理的形式是虚拟团队，产品经理和测试工程师主要在深圳，而研发团队在长沙，因此，每天投入到团队沟通中的时间占比达到20%。事实上虚拟团队这种开发模式，作为目前比较新兴的项目沟通形式，已经被互联网公司广泛采用。但是虚拟团队成员间分处异地、无法面对面沟通，由于文化、工作节奏、技术等原因，容易造成比较大的沟通成本。可以采取以下措施进行优化：\n  * 1、打造高保真原型图，进一步拆解任务目标，让任务目标细分。\n  * 2、需求讨论时间前置，需求的特点是渐进明细的，应尽量将对需求的沟通在研发阶段开始前进行落实，减少对于研发阶段过程中的额外时间浪费。\n  * 3、快速冲刺阶段尽可能面对面沟通。\n  * 4、功能交付缺乏Desktop Check，意味着产品经理和测试工程师无法及时了解功能的实际开发情况，也意味着团队间对于成果的交付进度、实现方式，本身是存在疑问的，这将提高沟通成本。\n* 如果按每天工作十小时，为3小时为与运营沟通问题的解决来算，占比达30%。说明对于项目成果的交付上，依然存在不少可以优化和提升的空间。或许可以采取以下措施。\n  * FAQ文档的进一步细化。\n  * 知识共享。\n  * 项目成果移交本身需要有更加规范化的管理措施。\n\n# 结论\n以上是一位CRUD互联网996开发者的一天，看起来似乎过得很充实， 却依然需要通过加班来完成当天的任务，而且甚至长期工作时间大于10个小时，与体力劳动者本身没有太大区别。也许总是像机器一样活着，思考都成为一种负担。总以为靠蛮力可以解决，实际上输出的或许是一种无用的解决方案。这样的付出，大概会觉得毫无价值。\n然而我们必须停驻脚步，认真思考当下的价值，思考效率和意义的平衡，让我们的生活更加有意义。\n牢记准则：*“做正确的事，正确的做事”。*\n\n","slug":"随笔/一位996、CRUD开发者的一天","published":1,"updated":"2019-10-09T10:52:29.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt8y0036n4vig5t92hzn","content":"<h1 id=\"记一笔流水账\"><a href=\"#记一笔流水账\" class=\"headerlink\" title=\"记一笔流水账\"></a>记一笔流水账</h1><p>今天我打算记一笔流水账，主要记录我的一天中干的事情，并思考效率低下的原因，同时分析一些可用的解决方案。</p>\n<h1 id=\"清早·开始做计划\"><a href=\"#清早·开始做计划\" class=\"headerlink\" title=\"清早·开始做计划\"></a>清早·开始做计划</h1><p>早上六点四十，被梦想唤醒，然后看一会书，吃早餐，送娃上学。<br>九点来到公司，开始一天的工作。在工作开始之前，我会花五分钟先做一个当天的计划，大概是这样的。 </p>\n<ol>\n<li><em><del>（讲道理应该有每日站会，事实上我是xx项目的负责人，但是。。我把站会给省了，把站会取消对项目的危害非常大。后期再讨论）</del></em></li>\n<li>对xx项目的周计划进行跟进和修订。</li>\n<li>检查昨天完成的功能，并记录和指派bug。</li>\n<li>整理文档，对昨天完成新功能的特性进行说明。</li>\n<li>解决属于自己名下的bug。</li>\n<li>开始两个下一阶段需要交付的新功能，比较简单的业务接口，代码行预计不超过80行。</li>\n</ol>\n<p>这些任务中，除了第五项和第六项相对来说可能会耗时比较长外，其他每个单项任务基本上可以在25分钟内完成，而且也确实是按任务优先级和重要性顺序来安排的，看起来还挺合理的，总体上属于在8小时内可以完成的工作量，而且其实或许还略微有点不饱和。。。</p>\n<h1 id=\"执行任务（下面是流水账，可以略过）\"><a href=\"#执行任务（下面是流水账，可以略过）\" class=\"headerlink\" title=\"执行任务（下面是流水账，可以略过）\"></a>执行任务（下面是流水账，可以略过）</h1><p>于是我喝了一口水，开始完成第一项任务：对xxx项目的周计划进行跟进和修订。<br>（如果是周一，以前我还会根据上周完成情况对月计划和总体计划进行适度的总结，但是。。自从来到互联网公司后，我把这个好习惯也丢掉了，好吧，是因为假装要敏捷要拥抱变化，所以把总体计划和月计划省掉了）。<br>但是，当我开始处理这项事务时，计划外的第一件事情发生了。在测试环境下，客户端反映某接口出现了不该出现的问题，于是我被迫打断这项任务，花了一分钟时间，跟他对接口问题进行了检查，发现是对方参数传错了。<br>嗯。问题解决。继续开始刚刚的任务。<br>到哪里了？哦。。还在做计划，接着我迅速调整状态，花了几分钟就把任务完成了。<br>然后开始第二项任务。<br>这时，刚刚客户端又找我了，他说接口还是有问题。<br>我以为又只要花一分钟，事实上这次我花了30分钟，因为确实是原来的代码逻辑中存在缺陷，需要进行代码修改、然后发布、再测试代码。<br>确认这个问题已经得到解决后，还是处理之前搁置的任务。花了20分钟处理任务3。<br>开始处理任务4，这项任务也相对来说比较简单，所以不到五分钟解决了。<br>开始处理任务5。。。在我名下共有20个bug。。。以每个bug5分钟来衡量，我大概需要花100分钟才能解决。但是当我开始解决第一个bug时。<br>又有其他人开始找我了，运营开始找我，说xxx场景下似乎出现了xxx逻辑不对。<br>线上问题必须优先解决，赶紧的，仔细思考问题发生的条件、对链路服务进行跟踪和分析、查看半年前编写的代码逻辑，最终花了15分钟分析出问题，并花了10分钟将问题妥善解决。<br>继续开始修复bug。在bug修复的过程中，发现是产品逻辑存在缺陷，于是跟产品对任务进行进一步明确、梳理业务、设计更加具体细化的流程。花了1小时。<br>到中午12点，我上午共完成任务3项，修复了一个bug。<br>下午不属于问题的高峰期，但是又发现了产品逻辑之外的一些其他问题，最终解决了15个bug。<br>积压了5个bug，留到晚上来解决吧。<br>当夜幕降临，我需要花2个小时来解决我剩余的bug和2个未完成的新功能开发任务。<br>事实上等到晚上八点半时，我完成了剩余bug，新功能完成了一个，但此时效率已经差的不行了，没办法，硬着头皮也得完成今天的任务。<br>（会不会欠下新债，显然毋庸置疑）<br>晚上9点，所有任务已基本上圆满完成。</p>\n<h1 id=\"总结完成情况\"><a href=\"#总结完成情况\" class=\"headerlink\" title=\"总结完成情况\"></a>总结完成情况</h1><p>总结今天完成的任务，共完成任务五项，其中修复bug20个，写了60行新代码，共耗时10小时。<br>显然我的工作效率是很差的，尤其是晚上效率更差，我最佩服那些自称晚上效率很高的人，尤其还有一些人特别喜欢深夜撸码，倒上一杯小酒，借着凌晨的寂静，写着爱写的代码，他们很厉害，因为他们很会自欺欺人。<br>来统计当天完成工作的工时占比：<br>| 工作内容   | 时间（分钟）   |<br>|:—-|:—-|<br>| 梳理日计划   | 5   |<br>| 修订周计划   | 10   |<br>| 接口联调   | 31   |<br>| 运营对接   | 25   |<br>| 修复20个bug   | 250   |<br>| 编写新功能   | 120   |<br>| 日常项目沟通   | 120   |<br>| 其他   | 40   |<br>| 总计   | 601   | </p>\n<h1 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"https://uploader.shimo.im/f/RunvG8elYn0zjxaO.png!thumbnail\" alt=\"图片\"></h1><h1 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h1><p>以上流水账实际上是我们这样一家普通互联网公司的日常，当然，对我个人而言，实际上投入到运营对接中的时间相对来说是不算多的，我了解我们公司有的开发者每天需要花至少3小时与运营人员进行问题的对接，这显然会直接影响了开发者的工作效率。<br>（我相信一流互联网公司一定不是这样的）<br>从上图可以看出我们的日常工作安排存在以下问题：</p>\n<ul>\n<li>修复bug这种还技术债的任务，耗时接近47%，占了将近一半的时间。嗯，能力确实不行，能不能采取措施让债不欠这么多，这是人才三角（专业技能、行业知识、软实力）需要达到的目标。我曾经打算在功能开发中引入TDD来减少返工率，但是最终决定还是先搁置这个想法。</li>\n<li>我司项目管理的形式是虚拟团队，产品经理和测试工程师主要在深圳，而研发团队在长沙，因此，每天投入到团队沟通中的时间占比达到20%。事实上虚拟团队这种开发模式，作为目前比较新兴的项目沟通形式，已经被互联网公司广泛采用。但是虚拟团队成员间分处异地、无法面对面沟通，由于文化、工作节奏、技术等原因，容易造成比较大的沟通成本。可以采取以下措施进行优化：<ul>\n<li>1、打造高保真原型图，进一步拆解任务目标，让任务目标细分。</li>\n<li>2、需求讨论时间前置，需求的特点是渐进明细的，应尽量将对需求的沟通在研发阶段开始前进行落实，减少对于研发阶段过程中的额外时间浪费。</li>\n<li>3、快速冲刺阶段尽可能面对面沟通。</li>\n<li>4、功能交付缺乏Desktop Check，意味着产品经理和测试工程师无法及时了解功能的实际开发情况，也意味着团队间对于成果的交付进度、实现方式，本身是存在疑问的，这将提高沟通成本。</li>\n</ul>\n</li>\n<li>如果按每天工作十小时，为3小时为与运营沟通问题的解决来算，占比达30%。说明对于项目成果的交付上，依然存在不少可以优化和提升的空间。或许可以采取以下措施。<ul>\n<li>FAQ文档的进一步细化。</li>\n<li>知识共享。</li>\n<li>项目成果移交本身需要有更加规范化的管理措施。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>以上是一位CRUD互联网996开发者的一天，看起来似乎过得很充实， 却依然需要通过加班来完成当天的任务，而且甚至长期工作时间大于10个小时，与体力劳动者本身没有太大区别。也许总是像机器一样活着，思考都成为一种负担。总以为靠蛮力可以解决，实际上输出的或许是一种无用的解决方案。这样的付出，大概会觉得毫无价值。<br>然而我们必须停驻脚步，认真思考当下的价值，思考效率和意义的平衡，让我们的生活更加有意义。<br>牢记准则：<em>“做正确的事，正确的做事”。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"记一笔流水账\"><a href=\"#记一笔流水账\" class=\"headerlink\" title=\"记一笔流水账\"></a>记一笔流水账</h1><p>今天我打算记一笔流水账，主要记录我的一天中干的事情，并思考效率低下的原因，同时分析一些可用的解决方案。</p>\n<h1 id=\"清早·开始做计划\"><a href=\"#清早·开始做计划\" class=\"headerlink\" title=\"清早·开始做计划\"></a>清早·开始做计划</h1><p>早上六点四十，被梦想唤醒，然后看一会书，吃早餐，送娃上学。<br>九点来到公司，开始一天的工作。在工作开始之前，我会花五分钟先做一个当天的计划，大概是这样的。 </p>\n<ol>\n<li><em><del>（讲道理应该有每日站会，事实上我是xx项目的负责人，但是。。我把站会给省了，把站会取消对项目的危害非常大。后期再讨论）</del></em></li>\n<li>对xx项目的周计划进行跟进和修订。</li>\n<li>检查昨天完成的功能，并记录和指派bug。</li>\n<li>整理文档，对昨天完成新功能的特性进行说明。</li>\n<li>解决属于自己名下的bug。</li>\n<li>开始两个下一阶段需要交付的新功能，比较简单的业务接口，代码行预计不超过80行。</li>\n</ol>\n<p>这些任务中，除了第五项和第六项相对来说可能会耗时比较长外，其他每个单项任务基本上可以在25分钟内完成，而且也确实是按任务优先级和重要性顺序来安排的，看起来还挺合理的，总体上属于在8小时内可以完成的工作量，而且其实或许还略微有点不饱和。。。</p>\n<h1 id=\"执行任务（下面是流水账，可以略过）\"><a href=\"#执行任务（下面是流水账，可以略过）\" class=\"headerlink\" title=\"执行任务（下面是流水账，可以略过）\"></a>执行任务（下面是流水账，可以略过）</h1><p>于是我喝了一口水，开始完成第一项任务：对xxx项目的周计划进行跟进和修订。<br>（如果是周一，以前我还会根据上周完成情况对月计划和总体计划进行适度的总结，但是。。自从来到互联网公司后，我把这个好习惯也丢掉了，好吧，是因为假装要敏捷要拥抱变化，所以把总体计划和月计划省掉了）。<br>但是，当我开始处理这项事务时，计划外的第一件事情发生了。在测试环境下，客户端反映某接口出现了不该出现的问题，于是我被迫打断这项任务，花了一分钟时间，跟他对接口问题进行了检查，发现是对方参数传错了。<br>嗯。问题解决。继续开始刚刚的任务。<br>到哪里了？哦。。还在做计划，接着我迅速调整状态，花了几分钟就把任务完成了。<br>然后开始第二项任务。<br>这时，刚刚客户端又找我了，他说接口还是有问题。<br>我以为又只要花一分钟，事实上这次我花了30分钟，因为确实是原来的代码逻辑中存在缺陷，需要进行代码修改、然后发布、再测试代码。<br>确认这个问题已经得到解决后，还是处理之前搁置的任务。花了20分钟处理任务3。<br>开始处理任务4，这项任务也相对来说比较简单，所以不到五分钟解决了。<br>开始处理任务5。。。在我名下共有20个bug。。。以每个bug5分钟来衡量，我大概需要花100分钟才能解决。但是当我开始解决第一个bug时。<br>又有其他人开始找我了，运营开始找我，说xxx场景下似乎出现了xxx逻辑不对。<br>线上问题必须优先解决，赶紧的，仔细思考问题发生的条件、对链路服务进行跟踪和分析、查看半年前编写的代码逻辑，最终花了15分钟分析出问题，并花了10分钟将问题妥善解决。<br>继续开始修复bug。在bug修复的过程中，发现是产品逻辑存在缺陷，于是跟产品对任务进行进一步明确、梳理业务、设计更加具体细化的流程。花了1小时。<br>到中午12点，我上午共完成任务3项，修复了一个bug。<br>下午不属于问题的高峰期，但是又发现了产品逻辑之外的一些其他问题，最终解决了15个bug。<br>积压了5个bug，留到晚上来解决吧。<br>当夜幕降临，我需要花2个小时来解决我剩余的bug和2个未完成的新功能开发任务。<br>事实上等到晚上八点半时，我完成了剩余bug，新功能完成了一个，但此时效率已经差的不行了，没办法，硬着头皮也得完成今天的任务。<br>（会不会欠下新债，显然毋庸置疑）<br>晚上9点，所有任务已基本上圆满完成。</p>\n<h1 id=\"总结完成情况\"><a href=\"#总结完成情况\" class=\"headerlink\" title=\"总结完成情况\"></a>总结完成情况</h1><p>总结今天完成的任务，共完成任务五项，其中修复bug20个，写了60行新代码，共耗时10小时。<br>显然我的工作效率是很差的，尤其是晚上效率更差，我最佩服那些自称晚上效率很高的人，尤其还有一些人特别喜欢深夜撸码，倒上一杯小酒，借着凌晨的寂静，写着爱写的代码，他们很厉害，因为他们很会自欺欺人。<br>来统计当天完成工作的工时占比：<br>| 工作内容   | 时间（分钟）   |<br>|:—-|:—-|<br>| 梳理日计划   | 5   |<br>| 修订周计划   | 10   |<br>| 接口联调   | 31   |<br>| 运营对接   | 25   |<br>| 修复20个bug   | 250   |<br>| 编写新功能   | 120   |<br>| 日常项目沟通   | 120   |<br>| 其他   | 40   |<br>| 总计   | 601   | </p>\n<h1 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"https://uploader.shimo.im/f/RunvG8elYn0zjxaO.png!thumbnail\" alt=\"图片\"></h1><h1 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h1><p>以上流水账实际上是我们这样一家普通互联网公司的日常，当然，对我个人而言，实际上投入到运营对接中的时间相对来说是不算多的，我了解我们公司有的开发者每天需要花至少3小时与运营人员进行问题的对接，这显然会直接影响了开发者的工作效率。<br>（我相信一流互联网公司一定不是这样的）<br>从上图可以看出我们的日常工作安排存在以下问题：</p>\n<ul>\n<li>修复bug这种还技术债的任务，耗时接近47%，占了将近一半的时间。嗯，能力确实不行，能不能采取措施让债不欠这么多，这是人才三角（专业技能、行业知识、软实力）需要达到的目标。我曾经打算在功能开发中引入TDD来减少返工率，但是最终决定还是先搁置这个想法。</li>\n<li>我司项目管理的形式是虚拟团队，产品经理和测试工程师主要在深圳，而研发团队在长沙，因此，每天投入到团队沟通中的时间占比达到20%。事实上虚拟团队这种开发模式，作为目前比较新兴的项目沟通形式，已经被互联网公司广泛采用。但是虚拟团队成员间分处异地、无法面对面沟通，由于文化、工作节奏、技术等原因，容易造成比较大的沟通成本。可以采取以下措施进行优化：<ul>\n<li>1、打造高保真原型图，进一步拆解任务目标，让任务目标细分。</li>\n<li>2、需求讨论时间前置，需求的特点是渐进明细的，应尽量将对需求的沟通在研发阶段开始前进行落实，减少对于研发阶段过程中的额外时间浪费。</li>\n<li>3、快速冲刺阶段尽可能面对面沟通。</li>\n<li>4、功能交付缺乏Desktop Check，意味着产品经理和测试工程师无法及时了解功能的实际开发情况，也意味着团队间对于成果的交付进度、实现方式，本身是存在疑问的，这将提高沟通成本。</li>\n</ul>\n</li>\n<li>如果按每天工作十小时，为3小时为与运营沟通问题的解决来算，占比达30%。说明对于项目成果的交付上，依然存在不少可以优化和提升的空间。或许可以采取以下措施。<ul>\n<li>FAQ文档的进一步细化。</li>\n<li>知识共享。</li>\n<li>项目成果移交本身需要有更加规范化的管理措施。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>以上是一位CRUD互联网996开发者的一天，看起来似乎过得很充实， 却依然需要通过加班来完成当天的任务，而且甚至长期工作时间大于10个小时，与体力劳动者本身没有太大区别。也许总是像机器一样活着，思考都成为一种负担。总以为靠蛮力可以解决，实际上输出的或许是一种无用的解决方案。这样的付出，大概会觉得毫无价值。<br>然而我们必须停驻脚步，认真思考当下的价值，思考效率和意义的平衡，让我们的生活更加有意义。<br>牢记准则：<em>“做正确的事，正确的做事”。</em></p>\n"},{"title":"共同创业五年，技术总监却突然就这么离职了","date":"2020-05-18T08:28:00.000Z","author":"邹溪源","_content":"\n# 一、 引子\n\n有一天，跟一位原同事老A聊起职场的一些情况，期间无意中提到了原公司的技术总监。我说这位技术总监带领公司从一家十几人的小团队，做到四百人的公司，作为同样都是开发者，而且以前也都从事过相同行业的开发，我非常钦佩他。\n\n在内地城市长沙，虽然也有一些优秀的互联网公司，但像这样短短五年，使公司从十几个人的公司发展为几百人的公司，组建起拥有200人的技术团队，其实已经算是非常不错了。\n\n在公司这五年的发展过程中，这位技术总监应该是出力非常多的一位，从引入变革，到关键产品的发布，到团队的逐渐发展，到研发流程的规范化，已经算是一位适时刷新思想，实现组织变革的典型人物了。\n\n当然，有时候公司发展得好，既是“时势造英雄”，又是“英雄造时势”。老板不能只说自己的功劳，把公司做的好，全归功于自己决策做得好、党和国家政策好，技术总监也不会自吹自擂，将不属于自己的功劳，也吹成自己的功劳。虽然这两位之间看起来似乎有点不太明显的矛盾，但总归是维持在一个平衡的程度，使得公司依然能够保持快速的发展速度，长此以往一定会成就一段佳话。\n\n这时，老A却告诉我，这位技术总监过完年就已经从公司离职了。\n\n这让我非常惊讶，干得好好的，怎么就离职了?这位技术总监和老板之间配合得还算默契，公司发展也处于“如日中天”的状态，怎么说走就走？\n\n老板换人了？怎么可能，技术总监往往是公司最关键的技术岗位，怎么可能像普通开发岗位一样想换就换的。是不是有什么特殊的原因？\n\n他说：这有什么，想走了呗。也许有哪些原因，我们也看不出来啊。\n\n好吧，其实我也并非一位喜欢职场八卦的人，无意对深层次的原因进一步挖掘，尤其是这家公司纵使在长沙看起来有一点规模，但是在《架构师社区》的读者眼里，依然并非“大厂”，不提也罢。\n\n总结来说，每个人职场都有不同的选择，在恰到好处的时候离去，无论是归于平淡，还是寻找另外一番人生际遇，或是快意恩仇，或是潇洒自如，或是相忘于江湖，都是对自己职场人生的一段总结。\n\n# 二、 技术总监，“高”处不胜寒\n\n## 1）\n\n在我刚刚参加工作时，曾经以为技术高管算是一位开发者职场奋斗的顶峰，能够成为技术高管，一定已经非常”稳定“了。\n\n当然，这种观点显然已经过时了。读者们都非常清楚，在一家成熟的公司，理论上讲，没有一个人是不可替换的，唯一的区别是替换成本的高低。尤其是那些成熟的互联网公司，连企业法人也会根据公司发展形势的变化而变化，那技术总监就更不用说了。\n\n技术总监甚至不一定属于“高管”，例如小公司，由于天花板很低，也许一位技术总监，已经算是“高管”了；但在大公司，其实很少会轻易将高管Title授予给他人，有时看上去那些所谓“总监”，其实只是头衔而已，并不能说明他的职位和话语权究竟有多高；也许得VP（技术合伙人）或CTO才能称为“高管”。\n\n不过总体来说，从白手起家的普通程序员，到成为“技术总监”，这已经算是对一位辛勤工作的开发者付出的极大肯定了。\n\n## 2）\n\n但有朝一日成为了技术总监，就真的职场无忧了么？\n\n并非如此，有一位朋友曾经分享了一个图片，那是一位40+的技术总监求职10k+技术职位的简历截图。（由于某些原因，不便分享。）\n\n这位大佬在一家国企的IT技术部门担任技术总监，在公司期间曾经主导了公司从传统媒体到新媒体的转型，为公司寻找新的利益增长点做出了不可磨灭的贡献，但是由于新媒体市场的激烈竞争，即便是依托国企和政府的良好关系和资源，这家公司依然很难在这个市场获得不错的业绩。\n\n业绩不好，技术部门自然而然也不会有多好过，事实上压力最大、首当其冲的就是技术老大，一方面是公司在新方向上的投入和产出不对等，首先就会追究技术总监的责任，另外一方面，研发团队长期承受巨大的压力，每天都加班加点，却被公司业务部门屡屡出言不逊，“花了那么多钱，结果养出来一支这样的卵蛋”？（毕竟虽然是国企吃大锅饭，但技术部门的工资，其实比业务部门要高出一倍有余），好不容易培养出来的团队，面临着严重的人员流失问题，又会让新项目的开展面临难以维系的局面。\n\n曾几何时，这位技术总监试图在团队内营造一股生机盎然的学习氛围，让大家在轻松而又愉快的氛围中共同进步，但是来自于业务部门的压力，显然让一切试图制造象牙塔的努力都变成徒劳。\n\n最终那些琳琅满目的书架、咖啡机、每日点心，被那些“大干一百天，奋斗就是生存”“年轻时不奋斗，还何时奋斗”“我的生命只有一次，我们要用他来改变世界”这样的标语替代。 \n\n（这也让许多心心念念去国企、大厂寻求稳定的人提个醒，也许你还真寻不到你梦寐以求的稳定。）\n\n## 3）\n\n他曾经跟我讲过刚去公司时，老板给他描绘的一幅幅宏伟蓝图，在刚开始业务转型时，在公司的大力支持之下，一个个他主导的项目都比他自己预想的还要轻易的完成，在同事们眼中，俨然一幅救世主一般。\n\n但是由于竞争对手过于强大，那些他带领几十号技术人员付出了许多个昼夜、熬夜加班干出来的新产品，却由于没办法获得足够的流量，最终如同一拳打到了棉花上，毫无产出。\n\n然后两年过去，他已经不再看业务部门同事的眼光了，也许莫名其妙间，感受到的是一股“嫌隙”的表情。许多业务部门的同事甚至会当着他的面说，如果把投入到互联网产品上的大几百万拿给自己做业务，肯定能带来更多客户。\n\n于是最终，这位技术总监也选择了放弃，他想回归本行，从一位纯粹的开发者干起，但大概市场已经没有他的位置了吧。\n\n毕竟，在如今的长沙，企业老板们对40岁左右的开发者，不管你履历多么华丽，所能提供的薪酬待遇，往往不超过10k。\n\n也许，他能选择的方向，是“教职”。\n\n# 三 职业发展方向之谜\n\n也许这篇文章又一次输出了“焦虑”，但并非笔者本意。\"焦虑\"大概是开发者们最普遍的情绪，尤其是最近疫情的影响，不少公司开始裁员，更是给开发者群体造成了不小的影响，职业发展再度成为大家普遍困扰的话题。\n\n在互联网上流传了三种不同的程序员发展路线图，一种是从程序员出发，然后干到专业工程师，高级工程师，架构师，技术负责人，技术总监，CTO；\n\n还有一种是从程序员出发，干到技术总监，然后开始送外卖或者送快递，或者自己开个彩票店，或者便利店，然后闲庭细步，泡上一杯茶、去钓钓鱼，细细品味这人生的慢慢悠长。\n\n当然，还有一种主流的发展路线，大概是最终走向创业，成为“万众创业”国家大计政策下的一颗螺丝钉。\n\n我们该如何选择适合自己的职场方向呢？\n\n在这篇文章中介绍了两个优秀的技术管理者，他们在自己的职场赛道上都遇到了一些困难，但也都一如既往的努力，那我们呢？\n\n其实，无论你做什么，其实都难以一帆风顺，但只要踏实坚持，总能看到希望。焦虑无助于改变现状，倒不如沉下心来，干好当下。\n\n\n\n​\t\n\n","source":"_posts/随笔/共同创业五年，技术总监却突然就这么离职了.md","raw":"---\ntitle:  共同创业五年，技术总监却突然就这么离职了\ndate: 2020-5-18 16:28\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n\n# 一、 引子\n\n有一天，跟一位原同事老A聊起职场的一些情况，期间无意中提到了原公司的技术总监。我说这位技术总监带领公司从一家十几人的小团队，做到四百人的公司，作为同样都是开发者，而且以前也都从事过相同行业的开发，我非常钦佩他。\n\n在内地城市长沙，虽然也有一些优秀的互联网公司，但像这样短短五年，使公司从十几个人的公司发展为几百人的公司，组建起拥有200人的技术团队，其实已经算是非常不错了。\n\n在公司这五年的发展过程中，这位技术总监应该是出力非常多的一位，从引入变革，到关键产品的发布，到团队的逐渐发展，到研发流程的规范化，已经算是一位适时刷新思想，实现组织变革的典型人物了。\n\n当然，有时候公司发展得好，既是“时势造英雄”，又是“英雄造时势”。老板不能只说自己的功劳，把公司做的好，全归功于自己决策做得好、党和国家政策好，技术总监也不会自吹自擂，将不属于自己的功劳，也吹成自己的功劳。虽然这两位之间看起来似乎有点不太明显的矛盾，但总归是维持在一个平衡的程度，使得公司依然能够保持快速的发展速度，长此以往一定会成就一段佳话。\n\n这时，老A却告诉我，这位技术总监过完年就已经从公司离职了。\n\n这让我非常惊讶，干得好好的，怎么就离职了?这位技术总监和老板之间配合得还算默契，公司发展也处于“如日中天”的状态，怎么说走就走？\n\n老板换人了？怎么可能，技术总监往往是公司最关键的技术岗位，怎么可能像普通开发岗位一样想换就换的。是不是有什么特殊的原因？\n\n他说：这有什么，想走了呗。也许有哪些原因，我们也看不出来啊。\n\n好吧，其实我也并非一位喜欢职场八卦的人，无意对深层次的原因进一步挖掘，尤其是这家公司纵使在长沙看起来有一点规模，但是在《架构师社区》的读者眼里，依然并非“大厂”，不提也罢。\n\n总结来说，每个人职场都有不同的选择，在恰到好处的时候离去，无论是归于平淡，还是寻找另外一番人生际遇，或是快意恩仇，或是潇洒自如，或是相忘于江湖，都是对自己职场人生的一段总结。\n\n# 二、 技术总监，“高”处不胜寒\n\n## 1）\n\n在我刚刚参加工作时，曾经以为技术高管算是一位开发者职场奋斗的顶峰，能够成为技术高管，一定已经非常”稳定“了。\n\n当然，这种观点显然已经过时了。读者们都非常清楚，在一家成熟的公司，理论上讲，没有一个人是不可替换的，唯一的区别是替换成本的高低。尤其是那些成熟的互联网公司，连企业法人也会根据公司发展形势的变化而变化，那技术总监就更不用说了。\n\n技术总监甚至不一定属于“高管”，例如小公司，由于天花板很低，也许一位技术总监，已经算是“高管”了；但在大公司，其实很少会轻易将高管Title授予给他人，有时看上去那些所谓“总监”，其实只是头衔而已，并不能说明他的职位和话语权究竟有多高；也许得VP（技术合伙人）或CTO才能称为“高管”。\n\n不过总体来说，从白手起家的普通程序员，到成为“技术总监”，这已经算是对一位辛勤工作的开发者付出的极大肯定了。\n\n## 2）\n\n但有朝一日成为了技术总监，就真的职场无忧了么？\n\n并非如此，有一位朋友曾经分享了一个图片，那是一位40+的技术总监求职10k+技术职位的简历截图。（由于某些原因，不便分享。）\n\n这位大佬在一家国企的IT技术部门担任技术总监，在公司期间曾经主导了公司从传统媒体到新媒体的转型，为公司寻找新的利益增长点做出了不可磨灭的贡献，但是由于新媒体市场的激烈竞争，即便是依托国企和政府的良好关系和资源，这家公司依然很难在这个市场获得不错的业绩。\n\n业绩不好，技术部门自然而然也不会有多好过，事实上压力最大、首当其冲的就是技术老大，一方面是公司在新方向上的投入和产出不对等，首先就会追究技术总监的责任，另外一方面，研发团队长期承受巨大的压力，每天都加班加点，却被公司业务部门屡屡出言不逊，“花了那么多钱，结果养出来一支这样的卵蛋”？（毕竟虽然是国企吃大锅饭，但技术部门的工资，其实比业务部门要高出一倍有余），好不容易培养出来的团队，面临着严重的人员流失问题，又会让新项目的开展面临难以维系的局面。\n\n曾几何时，这位技术总监试图在团队内营造一股生机盎然的学习氛围，让大家在轻松而又愉快的氛围中共同进步，但是来自于业务部门的压力，显然让一切试图制造象牙塔的努力都变成徒劳。\n\n最终那些琳琅满目的书架、咖啡机、每日点心，被那些“大干一百天，奋斗就是生存”“年轻时不奋斗，还何时奋斗”“我的生命只有一次，我们要用他来改变世界”这样的标语替代。 \n\n（这也让许多心心念念去国企、大厂寻求稳定的人提个醒，也许你还真寻不到你梦寐以求的稳定。）\n\n## 3）\n\n他曾经跟我讲过刚去公司时，老板给他描绘的一幅幅宏伟蓝图，在刚开始业务转型时，在公司的大力支持之下，一个个他主导的项目都比他自己预想的还要轻易的完成，在同事们眼中，俨然一幅救世主一般。\n\n但是由于竞争对手过于强大，那些他带领几十号技术人员付出了许多个昼夜、熬夜加班干出来的新产品，却由于没办法获得足够的流量，最终如同一拳打到了棉花上，毫无产出。\n\n然后两年过去，他已经不再看业务部门同事的眼光了，也许莫名其妙间，感受到的是一股“嫌隙”的表情。许多业务部门的同事甚至会当着他的面说，如果把投入到互联网产品上的大几百万拿给自己做业务，肯定能带来更多客户。\n\n于是最终，这位技术总监也选择了放弃，他想回归本行，从一位纯粹的开发者干起，但大概市场已经没有他的位置了吧。\n\n毕竟，在如今的长沙，企业老板们对40岁左右的开发者，不管你履历多么华丽，所能提供的薪酬待遇，往往不超过10k。\n\n也许，他能选择的方向，是“教职”。\n\n# 三 职业发展方向之谜\n\n也许这篇文章又一次输出了“焦虑”，但并非笔者本意。\"焦虑\"大概是开发者们最普遍的情绪，尤其是最近疫情的影响，不少公司开始裁员，更是给开发者群体造成了不小的影响，职业发展再度成为大家普遍困扰的话题。\n\n在互联网上流传了三种不同的程序员发展路线图，一种是从程序员出发，然后干到专业工程师，高级工程师，架构师，技术负责人，技术总监，CTO；\n\n还有一种是从程序员出发，干到技术总监，然后开始送外卖或者送快递，或者自己开个彩票店，或者便利店，然后闲庭细步，泡上一杯茶、去钓钓鱼，细细品味这人生的慢慢悠长。\n\n当然，还有一种主流的发展路线，大概是最终走向创业，成为“万众创业”国家大计政策下的一颗螺丝钉。\n\n我们该如何选择适合自己的职场方向呢？\n\n在这篇文章中介绍了两个优秀的技术管理者，他们在自己的职场赛道上都遇到了一些困难，但也都一如既往的努力，那我们呢？\n\n其实，无论你做什么，其实都难以一帆风顺，但只要踏实坚持，总能看到希望。焦虑无助于改变现状，倒不如沉下心来，干好当下。\n\n\n\n​\t\n\n","slug":"随笔/共同创业五年，技术总监却突然就这么离职了","published":1,"updated":"2020-05-26T11:11:40.641Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt900039n4vissvw0sqh","content":"<h1 id=\"一、-引子\"><a href=\"#一、-引子\" class=\"headerlink\" title=\"一、 引子\"></a>一、 引子</h1><p>有一天，跟一位原同事老A聊起职场的一些情况，期间无意中提到了原公司的技术总监。我说这位技术总监带领公司从一家十几人的小团队，做到四百人的公司，作为同样都是开发者，而且以前也都从事过相同行业的开发，我非常钦佩他。</p>\n<p>在内地城市长沙，虽然也有一些优秀的互联网公司，但像这样短短五年，使公司从十几个人的公司发展为几百人的公司，组建起拥有200人的技术团队，其实已经算是非常不错了。</p>\n<p>在公司这五年的发展过程中，这位技术总监应该是出力非常多的一位，从引入变革，到关键产品的发布，到团队的逐渐发展，到研发流程的规范化，已经算是一位适时刷新思想，实现组织变革的典型人物了。</p>\n<p>当然，有时候公司发展得好，既是“时势造英雄”，又是“英雄造时势”。老板不能只说自己的功劳，把公司做的好，全归功于自己决策做得好、党和国家政策好，技术总监也不会自吹自擂，将不属于自己的功劳，也吹成自己的功劳。虽然这两位之间看起来似乎有点不太明显的矛盾，但总归是维持在一个平衡的程度，使得公司依然能够保持快速的发展速度，长此以往一定会成就一段佳话。</p>\n<p>这时，老A却告诉我，这位技术总监过完年就已经从公司离职了。</p>\n<p>这让我非常惊讶，干得好好的，怎么就离职了?这位技术总监和老板之间配合得还算默契，公司发展也处于“如日中天”的状态，怎么说走就走？</p>\n<p>老板换人了？怎么可能，技术总监往往是公司最关键的技术岗位，怎么可能像普通开发岗位一样想换就换的。是不是有什么特殊的原因？</p>\n<p>他说：这有什么，想走了呗。也许有哪些原因，我们也看不出来啊。</p>\n<p>好吧，其实我也并非一位喜欢职场八卦的人，无意对深层次的原因进一步挖掘，尤其是这家公司纵使在长沙看起来有一点规模，但是在《架构师社区》的读者眼里，依然并非“大厂”，不提也罢。</p>\n<p>总结来说，每个人职场都有不同的选择，在恰到好处的时候离去，无论是归于平淡，还是寻找另外一番人生际遇，或是快意恩仇，或是潇洒自如，或是相忘于江湖，都是对自己职场人生的一段总结。</p>\n<h1 id=\"二、-技术总监，“高”处不胜寒\"><a href=\"#二、-技术总监，“高”处不胜寒\" class=\"headerlink\" title=\"二、 技术总监，“高”处不胜寒\"></a>二、 技术总监，“高”处不胜寒</h1><h2 id=\"1）\"><a href=\"#1）\" class=\"headerlink\" title=\"1）\"></a>1）</h2><p>在我刚刚参加工作时，曾经以为技术高管算是一位开发者职场奋斗的顶峰，能够成为技术高管，一定已经非常”稳定“了。</p>\n<p>当然，这种观点显然已经过时了。读者们都非常清楚，在一家成熟的公司，理论上讲，没有一个人是不可替换的，唯一的区别是替换成本的高低。尤其是那些成熟的互联网公司，连企业法人也会根据公司发展形势的变化而变化，那技术总监就更不用说了。</p>\n<p>技术总监甚至不一定属于“高管”，例如小公司，由于天花板很低，也许一位技术总监，已经算是“高管”了；但在大公司，其实很少会轻易将高管Title授予给他人，有时看上去那些所谓“总监”，其实只是头衔而已，并不能说明他的职位和话语权究竟有多高；也许得VP（技术合伙人）或CTO才能称为“高管”。</p>\n<p>不过总体来说，从白手起家的普通程序员，到成为“技术总监”，这已经算是对一位辛勤工作的开发者付出的极大肯定了。</p>\n<h2 id=\"2）\"><a href=\"#2）\" class=\"headerlink\" title=\"2）\"></a>2）</h2><p>但有朝一日成为了技术总监，就真的职场无忧了么？</p>\n<p>并非如此，有一位朋友曾经分享了一个图片，那是一位40+的技术总监求职10k+技术职位的简历截图。（由于某些原因，不便分享。）</p>\n<p>这位大佬在一家国企的IT技术部门担任技术总监，在公司期间曾经主导了公司从传统媒体到新媒体的转型，为公司寻找新的利益增长点做出了不可磨灭的贡献，但是由于新媒体市场的激烈竞争，即便是依托国企和政府的良好关系和资源，这家公司依然很难在这个市场获得不错的业绩。</p>\n<p>业绩不好，技术部门自然而然也不会有多好过，事实上压力最大、首当其冲的就是技术老大，一方面是公司在新方向上的投入和产出不对等，首先就会追究技术总监的责任，另外一方面，研发团队长期承受巨大的压力，每天都加班加点，却被公司业务部门屡屡出言不逊，“花了那么多钱，结果养出来一支这样的卵蛋”？（毕竟虽然是国企吃大锅饭，但技术部门的工资，其实比业务部门要高出一倍有余），好不容易培养出来的团队，面临着严重的人员流失问题，又会让新项目的开展面临难以维系的局面。</p>\n<p>曾几何时，这位技术总监试图在团队内营造一股生机盎然的学习氛围，让大家在轻松而又愉快的氛围中共同进步，但是来自于业务部门的压力，显然让一切试图制造象牙塔的努力都变成徒劳。</p>\n<p>最终那些琳琅满目的书架、咖啡机、每日点心，被那些“大干一百天，奋斗就是生存”“年轻时不奋斗，还何时奋斗”“我的生命只有一次，我们要用他来改变世界”这样的标语替代。 </p>\n<p>（这也让许多心心念念去国企、大厂寻求稳定的人提个醒，也许你还真寻不到你梦寐以求的稳定。）</p>\n<h2 id=\"3）\"><a href=\"#3）\" class=\"headerlink\" title=\"3）\"></a>3）</h2><p>他曾经跟我讲过刚去公司时，老板给他描绘的一幅幅宏伟蓝图，在刚开始业务转型时，在公司的大力支持之下，一个个他主导的项目都比他自己预想的还要轻易的完成，在同事们眼中，俨然一幅救世主一般。</p>\n<p>但是由于竞争对手过于强大，那些他带领几十号技术人员付出了许多个昼夜、熬夜加班干出来的新产品，却由于没办法获得足够的流量，最终如同一拳打到了棉花上，毫无产出。</p>\n<p>然后两年过去，他已经不再看业务部门同事的眼光了，也许莫名其妙间，感受到的是一股“嫌隙”的表情。许多业务部门的同事甚至会当着他的面说，如果把投入到互联网产品上的大几百万拿给自己做业务，肯定能带来更多客户。</p>\n<p>于是最终，这位技术总监也选择了放弃，他想回归本行，从一位纯粹的开发者干起，但大概市场已经没有他的位置了吧。</p>\n<p>毕竟，在如今的长沙，企业老板们对40岁左右的开发者，不管你履历多么华丽，所能提供的薪酬待遇，往往不超过10k。</p>\n<p>也许，他能选择的方向，是“教职”。</p>\n<h1 id=\"三-职业发展方向之谜\"><a href=\"#三-职业发展方向之谜\" class=\"headerlink\" title=\"三 职业发展方向之谜\"></a>三 职业发展方向之谜</h1><p>也许这篇文章又一次输出了“焦虑”，但并非笔者本意。”焦虑”大概是开发者们最普遍的情绪，尤其是最近疫情的影响，不少公司开始裁员，更是给开发者群体造成了不小的影响，职业发展再度成为大家普遍困扰的话题。</p>\n<p>在互联网上流传了三种不同的程序员发展路线图，一种是从程序员出发，然后干到专业工程师，高级工程师，架构师，技术负责人，技术总监，CTO；</p>\n<p>还有一种是从程序员出发，干到技术总监，然后开始送外卖或者送快递，或者自己开个彩票店，或者便利店，然后闲庭细步，泡上一杯茶、去钓钓鱼，细细品味这人生的慢慢悠长。</p>\n<p>当然，还有一种主流的发展路线，大概是最终走向创业，成为“万众创业”国家大计政策下的一颗螺丝钉。</p>\n<p>我们该如何选择适合自己的职场方向呢？</p>\n<p>在这篇文章中介绍了两个优秀的技术管理者，他们在自己的职场赛道上都遇到了一些困难，但也都一如既往的努力，那我们呢？</p>\n<p>其实，无论你做什么，其实都难以一帆风顺，但只要踏实坚持，总能看到希望。焦虑无助于改变现状，倒不如沉下心来，干好当下。</p>\n<p>​    </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、-引子\"><a href=\"#一、-引子\" class=\"headerlink\" title=\"一、 引子\"></a>一、 引子</h1><p>有一天，跟一位原同事老A聊起职场的一些情况，期间无意中提到了原公司的技术总监。我说这位技术总监带领公司从一家十几人的小团队，做到四百人的公司，作为同样都是开发者，而且以前也都从事过相同行业的开发，我非常钦佩他。</p>\n<p>在内地城市长沙，虽然也有一些优秀的互联网公司，但像这样短短五年，使公司从十几个人的公司发展为几百人的公司，组建起拥有200人的技术团队，其实已经算是非常不错了。</p>\n<p>在公司这五年的发展过程中，这位技术总监应该是出力非常多的一位，从引入变革，到关键产品的发布，到团队的逐渐发展，到研发流程的规范化，已经算是一位适时刷新思想，实现组织变革的典型人物了。</p>\n<p>当然，有时候公司发展得好，既是“时势造英雄”，又是“英雄造时势”。老板不能只说自己的功劳，把公司做的好，全归功于自己决策做得好、党和国家政策好，技术总监也不会自吹自擂，将不属于自己的功劳，也吹成自己的功劳。虽然这两位之间看起来似乎有点不太明显的矛盾，但总归是维持在一个平衡的程度，使得公司依然能够保持快速的发展速度，长此以往一定会成就一段佳话。</p>\n<p>这时，老A却告诉我，这位技术总监过完年就已经从公司离职了。</p>\n<p>这让我非常惊讶，干得好好的，怎么就离职了?这位技术总监和老板之间配合得还算默契，公司发展也处于“如日中天”的状态，怎么说走就走？</p>\n<p>老板换人了？怎么可能，技术总监往往是公司最关键的技术岗位，怎么可能像普通开发岗位一样想换就换的。是不是有什么特殊的原因？</p>\n<p>他说：这有什么，想走了呗。也许有哪些原因，我们也看不出来啊。</p>\n<p>好吧，其实我也并非一位喜欢职场八卦的人，无意对深层次的原因进一步挖掘，尤其是这家公司纵使在长沙看起来有一点规模，但是在《架构师社区》的读者眼里，依然并非“大厂”，不提也罢。</p>\n<p>总结来说，每个人职场都有不同的选择，在恰到好处的时候离去，无论是归于平淡，还是寻找另外一番人生际遇，或是快意恩仇，或是潇洒自如，或是相忘于江湖，都是对自己职场人生的一段总结。</p>\n<h1 id=\"二、-技术总监，“高”处不胜寒\"><a href=\"#二、-技术总监，“高”处不胜寒\" class=\"headerlink\" title=\"二、 技术总监，“高”处不胜寒\"></a>二、 技术总监，“高”处不胜寒</h1><h2 id=\"1）\"><a href=\"#1）\" class=\"headerlink\" title=\"1）\"></a>1）</h2><p>在我刚刚参加工作时，曾经以为技术高管算是一位开发者职场奋斗的顶峰，能够成为技术高管，一定已经非常”稳定“了。</p>\n<p>当然，这种观点显然已经过时了。读者们都非常清楚，在一家成熟的公司，理论上讲，没有一个人是不可替换的，唯一的区别是替换成本的高低。尤其是那些成熟的互联网公司，连企业法人也会根据公司发展形势的变化而变化，那技术总监就更不用说了。</p>\n<p>技术总监甚至不一定属于“高管”，例如小公司，由于天花板很低，也许一位技术总监，已经算是“高管”了；但在大公司，其实很少会轻易将高管Title授予给他人，有时看上去那些所谓“总监”，其实只是头衔而已，并不能说明他的职位和话语权究竟有多高；也许得VP（技术合伙人）或CTO才能称为“高管”。</p>\n<p>不过总体来说，从白手起家的普通程序员，到成为“技术总监”，这已经算是对一位辛勤工作的开发者付出的极大肯定了。</p>\n<h2 id=\"2）\"><a href=\"#2）\" class=\"headerlink\" title=\"2）\"></a>2）</h2><p>但有朝一日成为了技术总监，就真的职场无忧了么？</p>\n<p>并非如此，有一位朋友曾经分享了一个图片，那是一位40+的技术总监求职10k+技术职位的简历截图。（由于某些原因，不便分享。）</p>\n<p>这位大佬在一家国企的IT技术部门担任技术总监，在公司期间曾经主导了公司从传统媒体到新媒体的转型，为公司寻找新的利益增长点做出了不可磨灭的贡献，但是由于新媒体市场的激烈竞争，即便是依托国企和政府的良好关系和资源，这家公司依然很难在这个市场获得不错的业绩。</p>\n<p>业绩不好，技术部门自然而然也不会有多好过，事实上压力最大、首当其冲的就是技术老大，一方面是公司在新方向上的投入和产出不对等，首先就会追究技术总监的责任，另外一方面，研发团队长期承受巨大的压力，每天都加班加点，却被公司业务部门屡屡出言不逊，“花了那么多钱，结果养出来一支这样的卵蛋”？（毕竟虽然是国企吃大锅饭，但技术部门的工资，其实比业务部门要高出一倍有余），好不容易培养出来的团队，面临着严重的人员流失问题，又会让新项目的开展面临难以维系的局面。</p>\n<p>曾几何时，这位技术总监试图在团队内营造一股生机盎然的学习氛围，让大家在轻松而又愉快的氛围中共同进步，但是来自于业务部门的压力，显然让一切试图制造象牙塔的努力都变成徒劳。</p>\n<p>最终那些琳琅满目的书架、咖啡机、每日点心，被那些“大干一百天，奋斗就是生存”“年轻时不奋斗，还何时奋斗”“我的生命只有一次，我们要用他来改变世界”这样的标语替代。 </p>\n<p>（这也让许多心心念念去国企、大厂寻求稳定的人提个醒，也许你还真寻不到你梦寐以求的稳定。）</p>\n<h2 id=\"3）\"><a href=\"#3）\" class=\"headerlink\" title=\"3）\"></a>3）</h2><p>他曾经跟我讲过刚去公司时，老板给他描绘的一幅幅宏伟蓝图，在刚开始业务转型时，在公司的大力支持之下，一个个他主导的项目都比他自己预想的还要轻易的完成，在同事们眼中，俨然一幅救世主一般。</p>\n<p>但是由于竞争对手过于强大，那些他带领几十号技术人员付出了许多个昼夜、熬夜加班干出来的新产品，却由于没办法获得足够的流量，最终如同一拳打到了棉花上，毫无产出。</p>\n<p>然后两年过去，他已经不再看业务部门同事的眼光了，也许莫名其妙间，感受到的是一股“嫌隙”的表情。许多业务部门的同事甚至会当着他的面说，如果把投入到互联网产品上的大几百万拿给自己做业务，肯定能带来更多客户。</p>\n<p>于是最终，这位技术总监也选择了放弃，他想回归本行，从一位纯粹的开发者干起，但大概市场已经没有他的位置了吧。</p>\n<p>毕竟，在如今的长沙，企业老板们对40岁左右的开发者，不管你履历多么华丽，所能提供的薪酬待遇，往往不超过10k。</p>\n<p>也许，他能选择的方向，是“教职”。</p>\n<h1 id=\"三-职业发展方向之谜\"><a href=\"#三-职业发展方向之谜\" class=\"headerlink\" title=\"三 职业发展方向之谜\"></a>三 职业发展方向之谜</h1><p>也许这篇文章又一次输出了“焦虑”，但并非笔者本意。”焦虑”大概是开发者们最普遍的情绪，尤其是最近疫情的影响，不少公司开始裁员，更是给开发者群体造成了不小的影响，职业发展再度成为大家普遍困扰的话题。</p>\n<p>在互联网上流传了三种不同的程序员发展路线图，一种是从程序员出发，然后干到专业工程师，高级工程师，架构师，技术负责人，技术总监，CTO；</p>\n<p>还有一种是从程序员出发，干到技术总监，然后开始送外卖或者送快递，或者自己开个彩票店，或者便利店，然后闲庭细步，泡上一杯茶、去钓钓鱼，细细品味这人生的慢慢悠长。</p>\n<p>当然，还有一种主流的发展路线，大概是最终走向创业，成为“万众创业”国家大计政策下的一颗螺丝钉。</p>\n<p>我们该如何选择适合自己的职场方向呢？</p>\n<p>在这篇文章中介绍了两个优秀的技术管理者，他们在自己的职场赛道上都遇到了一些困难，但也都一如既往的努力，那我们呢？</p>\n<p>其实，无论你做什么，其实都难以一帆风顺，但只要踏实坚持，总能看到希望。焦虑无助于改变现状，倒不如沉下心来，干好当下。</p>\n<p>​    </p>\n"},{"title":"坚持一个好习惯，从现在开始","date":"2019-10-09T08:28:00.000Z","author":"邹溪源","_content":"\n\n# 引子\n这段时间以来我都在坚持写博客，但是更新得比较少，每周才能一更，不过好歹也勉勉强强也能坚持下去了。\n我们长沙.NET技术社区还组建了一个博客互勉群，不过除了个别人能经常打卡外，大部分人都是混个脸熟，凑个热闹。\n在这篇博客中，我打算分析不能坚持写博客的主客观原因，也以此作为自省，同时也期望能给读者们带来一些思考。\n\n---\n# 1、我的灵感，就像天际的浮云\n>\t人们在那里高谈阔论着天气和灵感之类的东西，而我却象首饰匠打金锁链那样精心的劳动着，把一个个小环非常合适地连接起来。 ——海涅\n\n坚持靠灵感来写博客，似乎是每个刚刚开始写博客的人的通病。灵感就像街角稍纵即逝的少女，邂逅的时光只有那么一念之间。\n一旦灵感来了，俨然一代军师附体，嗯，指点江山、激扬文字、以键盘为沙盘、以文字为千军万马、随随便便洋洋洒洒大几千字不在话下，还可以针对某个主题写好几个连续的博客，写完了之后都意犹未尽，好生痛快。\n但是，灵感这个东西，也太不靠谱了，有时候你还没来得及抓住，她就转瞬间消失的无影无踪，然后写博客就成为一件无比困难的工作，又要花时间，又要花精力，想得头昏目眩还不能敲出几个字来。\n\n---\n# 2、抓不住的时间流沙、留一点给我写博客吧\n>年难留，时易损。\n\n时间太少，确实是不能写博客的一个主要原因。写一篇博客确实需要一点点时间，从开始写到发布，怎么也需要几个小时吧。尤其是涉及到使用代码编写的算法实现的博客，这种技术博客往往耗时很长，从开始思考问题，到设计算法流程，到使用代码实现，再调试、测试，然后加到博客中，排版，大概得半天小时，如果遇到一些技术问题，可能一天就结束了。当然，每每这样精心设计的博客都会受到读者的欢迎，这些高端博客，由于其门槛比较高，往往会让许多读者受益匪浅，更是成为许多公司基础代码中非常宝贵的部分。不过这种博客其实非常少，有时逛一天园子都难得出现一次。 \n作为一个996的开发者，每天属于自己的可支配时间非常少，每天早上六点多到七点起床，然后到公司九点，晚上9点下班，回到家十点，再洗簌，到睡觉前，大概只有不到一小时的时间学习新的技能，又如何能抽出时间来写博客？ \n当然，如果不上班，难道有时间写博客了吗？并没有，周末了，带孩子玩一玩，把孩子哄睡，闲暇时再吃个鸡，呀，一拍大腿，又晚上十点半了，又没时间写博客了。每天就是这样的循环播放，每天都在做同样的事情，不停的工作。\n为了生活而拼搏、等有空的时候去学习，但是每天永远只有24个小时，不管怎么勤奋的去完成目标，却或许永远也抽不出那么一段闲暇的时间来写学习、去写博客。\n# 3、天马行空、无处放飞的年轻人的遐思\n优秀开发者们的想法，总是容易天马行空、肆意放飞，这也是年轻人们最充满朝气的一个客观表现。实际上到了写博客这个问题上，也是真实存在的。\n例如、经常时不时会冒出许多的想法，有时看了一篇不错的文章、与作者心有灵犀，有时解决了一个不错的问题，这些都会让我们有感而发，然后，嗯，赶紧记下来。但是一旦到了要写的时候，又是毫无头绪，不知从而下笔；例如担心这篇博客写了之后，太在意其他人的看法会造成某些不太好的影响，怕自己写的博客泄露了在某些方面的不足。\n于是，每一次写博客都成为开坑之旅，最终笔记中，留下了一堆只有标题、没有内容的奇怪东西。\n# 4、过分追求眼前的回报\n我也跟优秀的开发者、微软MVP汪宇杰老师交流这个问题，我问他是从什么时候开始的？他说大概是读大学时开始的，当时是从写笔记开始、后来才逐渐的开始写博客，最开始也担心博客写得不好，也同样会被人嘲讽，但是他依然不畏人言，一直坚持写，到目前已经坚持了十几年。他也运营了一个自己的公众号和网站（edi.wang），这个网站几乎每周都会.NET相关的技能，而且由于是英文撰写的，获得了来自大洋彼岸大量的阅读量。\n张善友老师也说运营社区、运营他的公众号（dotnet跨平台），他坚持了四年，同期与他一起做.NET的公众号还有许多，但是只有他坚持了最后。为了这个公众号，他每天需要花好几个小时时间去搜集素材和整理文章，而且每篇文章他都会认真阅读和记录，积累了目前的几万用户，已经成为.NET技术圈公众号名副其实的第一大号之一。 \n汪宇杰老师总结道：\n>有的开发者认为，与通过短期拼搏获得高工资相比，通过博客这种方式还是太慢了，写博客大概就像种竹子，每天要不停的浇灌，持续五年才能获得回报。\n\n---\n# 5、破解之道在哪里\n在《程序员的思维修炼》这本书介绍了德雷福斯模型这种从新手到专家的能力成长模型，描述了我们能力发生演进的原因。而如果把当写博客也当作一种能力，大概也可以把写博客这种技能分成五个层次：\n* **1、新手**：是指学习某个技能一开始的阶段，包括未入门的外行人，这个阶段往往经验很少，需要借助于网络或其他人的指导才能完成。在写博客这个技能上，大概就是能够基本的梳理出自己的思路，能够把字数凑出来，形成一篇读得通的博客。新手由于缺乏经验和表达能力，这也让他们总是过份在意其他人的看法，一旦被人质疑几句，可能就患得患失，不敢继续写下去了。\n* **2、高级新手**：有一定的经验和自我解决问题的能力，表现在写博客这个事情上，大概就是能够作用灵感这种天赐的魔法把自己的博客写出来，但是却很不稳定，有灵感就能写，没灵感憋都憋不出来。不太能控制自己的法术，文笔质量参差不齐。\n* **3、胜任者**：感觉笔者即将达到这个层次，能够有效的运用灵感，写出一些文字，也能在没有灵感时，运用自己的积累或经验，或素材把博客写出来。\n* **4、精通**：处理文字游刃有余，具有全局思维，能够从更高的战略层面思考问题和解决问题，并通过博客灵活的表现出来。\n* **5、行业专家**：凭直觉驱动，笔力雄厚，不轻易发表自己的观点，但是每每发声一定能直击问题的要害，并影响一个领域。       \n\n 许多朋友吐槽之所以不写，文笔不好也是一个重要原因，不必苛求文笔和辞藻，尤其是技术类型的博客，鲜有使用了许多修辞手法的博主，大部分博客都只是用直白的文笔流畅的表达自己的观点。\n吴军老师在《浪潮之巅》（第二版·下部）中的最后一页这样写道：\n>他要感谢他的语文老师....几乎所有的中学生，为了让文章写得漂亮，常常冥思苦想编造动人的清洁，寻找华丽的辞藻。我曾经也是这样的一个人，但是我的这位语文老师用了两年都的时间彻底改变了我的写作方法，他让我关注内容，用朴实的文风表达自己的体会。....我在美国的导师库坦普教授，他训练了我讲话和写作的逻辑性，比如怎么立论，并用论据支持论点。他是一位细节大师，要求我做到在公众场合讲话时，不多说哪怕是一句废话，也不落下任何一句关键的花。其实要想写得好，首先要说得清楚。然后再用大家喜欢的语言，把要说的话描述出来，就形成了好多作品。\n\n写博客是开发者一项非常重要的技能，作为新手的我们，也不要自怨自艾，人总是要慢慢进步才能逐渐走向理想丰满 ，不管写什么内容，请记住，一定要坚持。\n写博客也好、IT行业也好，贵在坚持。共勉之。\n\n","source":"_posts/随笔/坚持一个好习惯该有多难_.md","raw":"---\ntitle: 坚持一个好习惯，从现在开始\ndate: 2019-10-09 16:28\ntags: 读书\nauthor: 邹溪源\ncategories:\n  - 读书\n---\n\n\n# 引子\n这段时间以来我都在坚持写博客，但是更新得比较少，每周才能一更，不过好歹也勉勉强强也能坚持下去了。\n我们长沙.NET技术社区还组建了一个博客互勉群，不过除了个别人能经常打卡外，大部分人都是混个脸熟，凑个热闹。\n在这篇博客中，我打算分析不能坚持写博客的主客观原因，也以此作为自省，同时也期望能给读者们带来一些思考。\n\n---\n# 1、我的灵感，就像天际的浮云\n>\t人们在那里高谈阔论着天气和灵感之类的东西，而我却象首饰匠打金锁链那样精心的劳动着，把一个个小环非常合适地连接起来。 ——海涅\n\n坚持靠灵感来写博客，似乎是每个刚刚开始写博客的人的通病。灵感就像街角稍纵即逝的少女，邂逅的时光只有那么一念之间。\n一旦灵感来了，俨然一代军师附体，嗯，指点江山、激扬文字、以键盘为沙盘、以文字为千军万马、随随便便洋洋洒洒大几千字不在话下，还可以针对某个主题写好几个连续的博客，写完了之后都意犹未尽，好生痛快。\n但是，灵感这个东西，也太不靠谱了，有时候你还没来得及抓住，她就转瞬间消失的无影无踪，然后写博客就成为一件无比困难的工作，又要花时间，又要花精力，想得头昏目眩还不能敲出几个字来。\n\n---\n# 2、抓不住的时间流沙、留一点给我写博客吧\n>年难留，时易损。\n\n时间太少，确实是不能写博客的一个主要原因。写一篇博客确实需要一点点时间，从开始写到发布，怎么也需要几个小时吧。尤其是涉及到使用代码编写的算法实现的博客，这种技术博客往往耗时很长，从开始思考问题，到设计算法流程，到使用代码实现，再调试、测试，然后加到博客中，排版，大概得半天小时，如果遇到一些技术问题，可能一天就结束了。当然，每每这样精心设计的博客都会受到读者的欢迎，这些高端博客，由于其门槛比较高，往往会让许多读者受益匪浅，更是成为许多公司基础代码中非常宝贵的部分。不过这种博客其实非常少，有时逛一天园子都难得出现一次。 \n作为一个996的开发者，每天属于自己的可支配时间非常少，每天早上六点多到七点起床，然后到公司九点，晚上9点下班，回到家十点，再洗簌，到睡觉前，大概只有不到一小时的时间学习新的技能，又如何能抽出时间来写博客？ \n当然，如果不上班，难道有时间写博客了吗？并没有，周末了，带孩子玩一玩，把孩子哄睡，闲暇时再吃个鸡，呀，一拍大腿，又晚上十点半了，又没时间写博客了。每天就是这样的循环播放，每天都在做同样的事情，不停的工作。\n为了生活而拼搏、等有空的时候去学习，但是每天永远只有24个小时，不管怎么勤奋的去完成目标，却或许永远也抽不出那么一段闲暇的时间来写学习、去写博客。\n# 3、天马行空、无处放飞的年轻人的遐思\n优秀开发者们的想法，总是容易天马行空、肆意放飞，这也是年轻人们最充满朝气的一个客观表现。实际上到了写博客这个问题上，也是真实存在的。\n例如、经常时不时会冒出许多的想法，有时看了一篇不错的文章、与作者心有灵犀，有时解决了一个不错的问题，这些都会让我们有感而发，然后，嗯，赶紧记下来。但是一旦到了要写的时候，又是毫无头绪，不知从而下笔；例如担心这篇博客写了之后，太在意其他人的看法会造成某些不太好的影响，怕自己写的博客泄露了在某些方面的不足。\n于是，每一次写博客都成为开坑之旅，最终笔记中，留下了一堆只有标题、没有内容的奇怪东西。\n# 4、过分追求眼前的回报\n我也跟优秀的开发者、微软MVP汪宇杰老师交流这个问题，我问他是从什么时候开始的？他说大概是读大学时开始的，当时是从写笔记开始、后来才逐渐的开始写博客，最开始也担心博客写得不好，也同样会被人嘲讽，但是他依然不畏人言，一直坚持写，到目前已经坚持了十几年。他也运营了一个自己的公众号和网站（edi.wang），这个网站几乎每周都会.NET相关的技能，而且由于是英文撰写的，获得了来自大洋彼岸大量的阅读量。\n张善友老师也说运营社区、运营他的公众号（dotnet跨平台），他坚持了四年，同期与他一起做.NET的公众号还有许多，但是只有他坚持了最后。为了这个公众号，他每天需要花好几个小时时间去搜集素材和整理文章，而且每篇文章他都会认真阅读和记录，积累了目前的几万用户，已经成为.NET技术圈公众号名副其实的第一大号之一。 \n汪宇杰老师总结道：\n>有的开发者认为，与通过短期拼搏获得高工资相比，通过博客这种方式还是太慢了，写博客大概就像种竹子，每天要不停的浇灌，持续五年才能获得回报。\n\n---\n# 5、破解之道在哪里\n在《程序员的思维修炼》这本书介绍了德雷福斯模型这种从新手到专家的能力成长模型，描述了我们能力发生演进的原因。而如果把当写博客也当作一种能力，大概也可以把写博客这种技能分成五个层次：\n* **1、新手**：是指学习某个技能一开始的阶段，包括未入门的外行人，这个阶段往往经验很少，需要借助于网络或其他人的指导才能完成。在写博客这个技能上，大概就是能够基本的梳理出自己的思路，能够把字数凑出来，形成一篇读得通的博客。新手由于缺乏经验和表达能力，这也让他们总是过份在意其他人的看法，一旦被人质疑几句，可能就患得患失，不敢继续写下去了。\n* **2、高级新手**：有一定的经验和自我解决问题的能力，表现在写博客这个事情上，大概就是能够作用灵感这种天赐的魔法把自己的博客写出来，但是却很不稳定，有灵感就能写，没灵感憋都憋不出来。不太能控制自己的法术，文笔质量参差不齐。\n* **3、胜任者**：感觉笔者即将达到这个层次，能够有效的运用灵感，写出一些文字，也能在没有灵感时，运用自己的积累或经验，或素材把博客写出来。\n* **4、精通**：处理文字游刃有余，具有全局思维，能够从更高的战略层面思考问题和解决问题，并通过博客灵活的表现出来。\n* **5、行业专家**：凭直觉驱动，笔力雄厚，不轻易发表自己的观点，但是每每发声一定能直击问题的要害，并影响一个领域。       \n\n 许多朋友吐槽之所以不写，文笔不好也是一个重要原因，不必苛求文笔和辞藻，尤其是技术类型的博客，鲜有使用了许多修辞手法的博主，大部分博客都只是用直白的文笔流畅的表达自己的观点。\n吴军老师在《浪潮之巅》（第二版·下部）中的最后一页这样写道：\n>他要感谢他的语文老师....几乎所有的中学生，为了让文章写得漂亮，常常冥思苦想编造动人的清洁，寻找华丽的辞藻。我曾经也是这样的一个人，但是我的这位语文老师用了两年都的时间彻底改变了我的写作方法，他让我关注内容，用朴实的文风表达自己的体会。....我在美国的导师库坦普教授，他训练了我讲话和写作的逻辑性，比如怎么立论，并用论据支持论点。他是一位细节大师，要求我做到在公众场合讲话时，不多说哪怕是一句废话，也不落下任何一句关键的花。其实要想写得好，首先要说得清楚。然后再用大家喜欢的语言，把要说的话描述出来，就形成了好多作品。\n\n写博客是开发者一项非常重要的技能，作为新手的我们，也不要自怨自艾，人总是要慢慢进步才能逐渐走向理想丰满 ，不管写什么内容，请记住，一定要坚持。\n写博客也好、IT行业也好，贵在坚持。共勉之。\n\n","slug":"随笔/坚持一个好习惯该有多难_","published":1,"updated":"2019-10-09T10:50:25.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt91003cn4vi3nu8myt4","content":"<h1 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h1><p>这段时间以来我都在坚持写博客，但是更新得比较少，每周才能一更，不过好歹也勉勉强强也能坚持下去了。<br>我们长沙.NET技术社区还组建了一个博客互勉群，不过除了个别人能经常打卡外，大部分人都是混个脸熟，凑个热闹。<br>在这篇博客中，我打算分析不能坚持写博客的主客观原因，也以此作为自省，同时也期望能给读者们带来一些思考。</p>\n<hr>\n<h1 id=\"1、我的灵感，就像天际的浮云\"><a href=\"#1、我的灵感，就像天际的浮云\" class=\"headerlink\" title=\"1、我的灵感，就像天际的浮云\"></a>1、我的灵感，就像天际的浮云</h1><blockquote>\n<p>   人们在那里高谈阔论着天气和灵感之类的东西，而我却象首饰匠打金锁链那样精心的劳动着，把一个个小环非常合适地连接起来。 ——海涅</p>\n</blockquote>\n<p>坚持靠灵感来写博客，似乎是每个刚刚开始写博客的人的通病。灵感就像街角稍纵即逝的少女，邂逅的时光只有那么一念之间。<br>一旦灵感来了，俨然一代军师附体，嗯，指点江山、激扬文字、以键盘为沙盘、以文字为千军万马、随随便便洋洋洒洒大几千字不在话下，还可以针对某个主题写好几个连续的博客，写完了之后都意犹未尽，好生痛快。<br>但是，灵感这个东西，也太不靠谱了，有时候你还没来得及抓住，她就转瞬间消失的无影无踪，然后写博客就成为一件无比困难的工作，又要花时间，又要花精力，想得头昏目眩还不能敲出几个字来。</p>\n<hr>\n<h1 id=\"2、抓不住的时间流沙、留一点给我写博客吧\"><a href=\"#2、抓不住的时间流沙、留一点给我写博客吧\" class=\"headerlink\" title=\"2、抓不住的时间流沙、留一点给我写博客吧\"></a>2、抓不住的时间流沙、留一点给我写博客吧</h1><blockquote>\n<p>年难留，时易损。</p>\n</blockquote>\n<p>时间太少，确实是不能写博客的一个主要原因。写一篇博客确实需要一点点时间，从开始写到发布，怎么也需要几个小时吧。尤其是涉及到使用代码编写的算法实现的博客，这种技术博客往往耗时很长，从开始思考问题，到设计算法流程，到使用代码实现，再调试、测试，然后加到博客中，排版，大概得半天小时，如果遇到一些技术问题，可能一天就结束了。当然，每每这样精心设计的博客都会受到读者的欢迎，这些高端博客，由于其门槛比较高，往往会让许多读者受益匪浅，更是成为许多公司基础代码中非常宝贵的部分。不过这种博客其实非常少，有时逛一天园子都难得出现一次。<br>作为一个996的开发者，每天属于自己的可支配时间非常少，每天早上六点多到七点起床，然后到公司九点，晚上9点下班，回到家十点，再洗簌，到睡觉前，大概只有不到一小时的时间学习新的技能，又如何能抽出时间来写博客？<br>当然，如果不上班，难道有时间写博客了吗？并没有，周末了，带孩子玩一玩，把孩子哄睡，闲暇时再吃个鸡，呀，一拍大腿，又晚上十点半了，又没时间写博客了。每天就是这样的循环播放，每天都在做同样的事情，不停的工作。<br>为了生活而拼搏、等有空的时候去学习，但是每天永远只有24个小时，不管怎么勤奋的去完成目标，却或许永远也抽不出那么一段闲暇的时间来写学习、去写博客。</p>\n<h1 id=\"3、天马行空、无处放飞的年轻人的遐思\"><a href=\"#3、天马行空、无处放飞的年轻人的遐思\" class=\"headerlink\" title=\"3、天马行空、无处放飞的年轻人的遐思\"></a>3、天马行空、无处放飞的年轻人的遐思</h1><p>优秀开发者们的想法，总是容易天马行空、肆意放飞，这也是年轻人们最充满朝气的一个客观表现。实际上到了写博客这个问题上，也是真实存在的。<br>例如、经常时不时会冒出许多的想法，有时看了一篇不错的文章、与作者心有灵犀，有时解决了一个不错的问题，这些都会让我们有感而发，然后，嗯，赶紧记下来。但是一旦到了要写的时候，又是毫无头绪，不知从而下笔；例如担心这篇博客写了之后，太在意其他人的看法会造成某些不太好的影响，怕自己写的博客泄露了在某些方面的不足。<br>于是，每一次写博客都成为开坑之旅，最终笔记中，留下了一堆只有标题、没有内容的奇怪东西。</p>\n<h1 id=\"4、过分追求眼前的回报\"><a href=\"#4、过分追求眼前的回报\" class=\"headerlink\" title=\"4、过分追求眼前的回报\"></a>4、过分追求眼前的回报</h1><p>我也跟优秀的开发者、微软MVP汪宇杰老师交流这个问题，我问他是从什么时候开始的？他说大概是读大学时开始的，当时是从写笔记开始、后来才逐渐的开始写博客，最开始也担心博客写得不好，也同样会被人嘲讽，但是他依然不畏人言，一直坚持写，到目前已经坚持了十几年。他也运营了一个自己的公众号和网站（edi.wang），这个网站几乎每周都会.NET相关的技能，而且由于是英文撰写的，获得了来自大洋彼岸大量的阅读量。<br>张善友老师也说运营社区、运营他的公众号（dotnet跨平台），他坚持了四年，同期与他一起做.NET的公众号还有许多，但是只有他坚持了最后。为了这个公众号，他每天需要花好几个小时时间去搜集素材和整理文章，而且每篇文章他都会认真阅读和记录，积累了目前的几万用户，已经成为.NET技术圈公众号名副其实的第一大号之一。<br>汪宇杰老师总结道：</p>\n<blockquote>\n<p>有的开发者认为，与通过短期拼搏获得高工资相比，通过博客这种方式还是太慢了，写博客大概就像种竹子，每天要不停的浇灌，持续五年才能获得回报。</p>\n</blockquote>\n<hr>\n<h1 id=\"5、破解之道在哪里\"><a href=\"#5、破解之道在哪里\" class=\"headerlink\" title=\"5、破解之道在哪里\"></a>5、破解之道在哪里</h1><p>在《程序员的思维修炼》这本书介绍了德雷福斯模型这种从新手到专家的能力成长模型，描述了我们能力发生演进的原因。而如果把当写博客也当作一种能力，大概也可以把写博客这种技能分成五个层次：</p>\n<ul>\n<li><p><strong>1、新手</strong>：是指学习某个技能一开始的阶段，包括未入门的外行人，这个阶段往往经验很少，需要借助于网络或其他人的指导才能完成。在写博客这个技能上，大概就是能够基本的梳理出自己的思路，能够把字数凑出来，形成一篇读得通的博客。新手由于缺乏经验和表达能力，这也让他们总是过份在意其他人的看法，一旦被人质疑几句，可能就患得患失，不敢继续写下去了。</p>\n</li>\n<li><p><strong>2、高级新手</strong>：有一定的经验和自我解决问题的能力，表现在写博客这个事情上，大概就是能够作用灵感这种天赐的魔法把自己的博客写出来，但是却很不稳定，有灵感就能写，没灵感憋都憋不出来。不太能控制自己的法术，文笔质量参差不齐。</p>\n</li>\n<li><p><strong>3、胜任者</strong>：感觉笔者即将达到这个层次，能够有效的运用灵感，写出一些文字，也能在没有灵感时，运用自己的积累或经验，或素材把博客写出来。</p>\n</li>\n<li><p><strong>4、精通</strong>：处理文字游刃有余，具有全局思维，能够从更高的战略层面思考问题和解决问题，并通过博客灵活的表现出来。</p>\n</li>\n<li><p><strong>5、行业专家</strong>：凭直觉驱动，笔力雄厚，不轻易发表自己的观点，但是每每发声一定能直击问题的要害，并影响一个领域。       </p>\n<p>许多朋友吐槽之所以不写，文笔不好也是一个重要原因，不必苛求文笔和辞藻，尤其是技术类型的博客，鲜有使用了许多修辞手法的博主，大部分博客都只是用直白的文笔流畅的表达自己的观点。<br>吴军老师在《浪潮之巅》（第二版·下部）中的最后一页这样写道：</p>\n<blockquote>\n<p>他要感谢他的语文老师….几乎所有的中学生，为了让文章写得漂亮，常常冥思苦想编造动人的清洁，寻找华丽的辞藻。我曾经也是这样的一个人，但是我的这位语文老师用了两年都的时间彻底改变了我的写作方法，他让我关注内容，用朴实的文风表达自己的体会。….我在美国的导师库坦普教授，他训练了我讲话和写作的逻辑性，比如怎么立论，并用论据支持论点。他是一位细节大师，要求我做到在公众场合讲话时，不多说哪怕是一句废话，也不落下任何一句关键的花。其实要想写得好，首先要说得清楚。然后再用大家喜欢的语言，把要说的话描述出来，就形成了好多作品。</p>\n</blockquote>\n</li>\n</ul>\n<p>写博客是开发者一项非常重要的技能，作为新手的我们，也不要自怨自艾，人总是要慢慢进步才能逐渐走向理想丰满 ，不管写什么内容，请记住，一定要坚持。<br>写博客也好、IT行业也好，贵在坚持。共勉之。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h1><p>这段时间以来我都在坚持写博客，但是更新得比较少，每周才能一更，不过好歹也勉勉强强也能坚持下去了。<br>我们长沙.NET技术社区还组建了一个博客互勉群，不过除了个别人能经常打卡外，大部分人都是混个脸熟，凑个热闹。<br>在这篇博客中，我打算分析不能坚持写博客的主客观原因，也以此作为自省，同时也期望能给读者们带来一些思考。</p>\n<hr>\n<h1 id=\"1、我的灵感，就像天际的浮云\"><a href=\"#1、我的灵感，就像天际的浮云\" class=\"headerlink\" title=\"1、我的灵感，就像天际的浮云\"></a>1、我的灵感，就像天际的浮云</h1><blockquote>\n<p>   人们在那里高谈阔论着天气和灵感之类的东西，而我却象首饰匠打金锁链那样精心的劳动着，把一个个小环非常合适地连接起来。 ——海涅</p>\n</blockquote>\n<p>坚持靠灵感来写博客，似乎是每个刚刚开始写博客的人的通病。灵感就像街角稍纵即逝的少女，邂逅的时光只有那么一念之间。<br>一旦灵感来了，俨然一代军师附体，嗯，指点江山、激扬文字、以键盘为沙盘、以文字为千军万马、随随便便洋洋洒洒大几千字不在话下，还可以针对某个主题写好几个连续的博客，写完了之后都意犹未尽，好生痛快。<br>但是，灵感这个东西，也太不靠谱了，有时候你还没来得及抓住，她就转瞬间消失的无影无踪，然后写博客就成为一件无比困难的工作，又要花时间，又要花精力，想得头昏目眩还不能敲出几个字来。</p>\n<hr>\n<h1 id=\"2、抓不住的时间流沙、留一点给我写博客吧\"><a href=\"#2、抓不住的时间流沙、留一点给我写博客吧\" class=\"headerlink\" title=\"2、抓不住的时间流沙、留一点给我写博客吧\"></a>2、抓不住的时间流沙、留一点给我写博客吧</h1><blockquote>\n<p>年难留，时易损。</p>\n</blockquote>\n<p>时间太少，确实是不能写博客的一个主要原因。写一篇博客确实需要一点点时间，从开始写到发布，怎么也需要几个小时吧。尤其是涉及到使用代码编写的算法实现的博客，这种技术博客往往耗时很长，从开始思考问题，到设计算法流程，到使用代码实现，再调试、测试，然后加到博客中，排版，大概得半天小时，如果遇到一些技术问题，可能一天就结束了。当然，每每这样精心设计的博客都会受到读者的欢迎，这些高端博客，由于其门槛比较高，往往会让许多读者受益匪浅，更是成为许多公司基础代码中非常宝贵的部分。不过这种博客其实非常少，有时逛一天园子都难得出现一次。<br>作为一个996的开发者，每天属于自己的可支配时间非常少，每天早上六点多到七点起床，然后到公司九点，晚上9点下班，回到家十点，再洗簌，到睡觉前，大概只有不到一小时的时间学习新的技能，又如何能抽出时间来写博客？<br>当然，如果不上班，难道有时间写博客了吗？并没有，周末了，带孩子玩一玩，把孩子哄睡，闲暇时再吃个鸡，呀，一拍大腿，又晚上十点半了，又没时间写博客了。每天就是这样的循环播放，每天都在做同样的事情，不停的工作。<br>为了生活而拼搏、等有空的时候去学习，但是每天永远只有24个小时，不管怎么勤奋的去完成目标，却或许永远也抽不出那么一段闲暇的时间来写学习、去写博客。</p>\n<h1 id=\"3、天马行空、无处放飞的年轻人的遐思\"><a href=\"#3、天马行空、无处放飞的年轻人的遐思\" class=\"headerlink\" title=\"3、天马行空、无处放飞的年轻人的遐思\"></a>3、天马行空、无处放飞的年轻人的遐思</h1><p>优秀开发者们的想法，总是容易天马行空、肆意放飞，这也是年轻人们最充满朝气的一个客观表现。实际上到了写博客这个问题上，也是真实存在的。<br>例如、经常时不时会冒出许多的想法，有时看了一篇不错的文章、与作者心有灵犀，有时解决了一个不错的问题，这些都会让我们有感而发，然后，嗯，赶紧记下来。但是一旦到了要写的时候，又是毫无头绪，不知从而下笔；例如担心这篇博客写了之后，太在意其他人的看法会造成某些不太好的影响，怕自己写的博客泄露了在某些方面的不足。<br>于是，每一次写博客都成为开坑之旅，最终笔记中，留下了一堆只有标题、没有内容的奇怪东西。</p>\n<h1 id=\"4、过分追求眼前的回报\"><a href=\"#4、过分追求眼前的回报\" class=\"headerlink\" title=\"4、过分追求眼前的回报\"></a>4、过分追求眼前的回报</h1><p>我也跟优秀的开发者、微软MVP汪宇杰老师交流这个问题，我问他是从什么时候开始的？他说大概是读大学时开始的，当时是从写笔记开始、后来才逐渐的开始写博客，最开始也担心博客写得不好，也同样会被人嘲讽，但是他依然不畏人言，一直坚持写，到目前已经坚持了十几年。他也运营了一个自己的公众号和网站（edi.wang），这个网站几乎每周都会.NET相关的技能，而且由于是英文撰写的，获得了来自大洋彼岸大量的阅读量。<br>张善友老师也说运营社区、运营他的公众号（dotnet跨平台），他坚持了四年，同期与他一起做.NET的公众号还有许多，但是只有他坚持了最后。为了这个公众号，他每天需要花好几个小时时间去搜集素材和整理文章，而且每篇文章他都会认真阅读和记录，积累了目前的几万用户，已经成为.NET技术圈公众号名副其实的第一大号之一。<br>汪宇杰老师总结道：</p>\n<blockquote>\n<p>有的开发者认为，与通过短期拼搏获得高工资相比，通过博客这种方式还是太慢了，写博客大概就像种竹子，每天要不停的浇灌，持续五年才能获得回报。</p>\n</blockquote>\n<hr>\n<h1 id=\"5、破解之道在哪里\"><a href=\"#5、破解之道在哪里\" class=\"headerlink\" title=\"5、破解之道在哪里\"></a>5、破解之道在哪里</h1><p>在《程序员的思维修炼》这本书介绍了德雷福斯模型这种从新手到专家的能力成长模型，描述了我们能力发生演进的原因。而如果把当写博客也当作一种能力，大概也可以把写博客这种技能分成五个层次：</p>\n<ul>\n<li><p><strong>1、新手</strong>：是指学习某个技能一开始的阶段，包括未入门的外行人，这个阶段往往经验很少，需要借助于网络或其他人的指导才能完成。在写博客这个技能上，大概就是能够基本的梳理出自己的思路，能够把字数凑出来，形成一篇读得通的博客。新手由于缺乏经验和表达能力，这也让他们总是过份在意其他人的看法，一旦被人质疑几句，可能就患得患失，不敢继续写下去了。</p>\n</li>\n<li><p><strong>2、高级新手</strong>：有一定的经验和自我解决问题的能力，表现在写博客这个事情上，大概就是能够作用灵感这种天赐的魔法把自己的博客写出来，但是却很不稳定，有灵感就能写，没灵感憋都憋不出来。不太能控制自己的法术，文笔质量参差不齐。</p>\n</li>\n<li><p><strong>3、胜任者</strong>：感觉笔者即将达到这个层次，能够有效的运用灵感，写出一些文字，也能在没有灵感时，运用自己的积累或经验，或素材把博客写出来。</p>\n</li>\n<li><p><strong>4、精通</strong>：处理文字游刃有余，具有全局思维，能够从更高的战略层面思考问题和解决问题，并通过博客灵活的表现出来。</p>\n</li>\n<li><p><strong>5、行业专家</strong>：凭直觉驱动，笔力雄厚，不轻易发表自己的观点，但是每每发声一定能直击问题的要害，并影响一个领域。       </p>\n<p>许多朋友吐槽之所以不写，文笔不好也是一个重要原因，不必苛求文笔和辞藻，尤其是技术类型的博客，鲜有使用了许多修辞手法的博主，大部分博客都只是用直白的文笔流畅的表达自己的观点。<br>吴军老师在《浪潮之巅》（第二版·下部）中的最后一页这样写道：</p>\n<blockquote>\n<p>他要感谢他的语文老师….几乎所有的中学生，为了让文章写得漂亮，常常冥思苦想编造动人的清洁，寻找华丽的辞藻。我曾经也是这样的一个人，但是我的这位语文老师用了两年都的时间彻底改变了我的写作方法，他让我关注内容，用朴实的文风表达自己的体会。….我在美国的导师库坦普教授，他训练了我讲话和写作的逻辑性，比如怎么立论，并用论据支持论点。他是一位细节大师，要求我做到在公众场合讲话时，不多说哪怕是一句废话，也不落下任何一句关键的花。其实要想写得好，首先要说得清楚。然后再用大家喜欢的语言，把要说的话描述出来，就形成了好多作品。</p>\n</blockquote>\n</li>\n</ul>\n<p>写博客是开发者一项非常重要的技能，作为新手的我们，也不要自怨自艾，人总是要慢慢进步才能逐渐走向理想丰满 ，不管写什么内容，请记住，一定要坚持。<br>写博客也好、IT行业也好，贵在坚持。共勉之。</p>\n"},{"title":"如何快速融入团队并成为团队核心（一）","date":"2020-01-03T01:28:00.000Z","author":"邹溪源","_content":"# 一\n我们难免需要离开一个圈子，加入一个陌生的集体。毋庸置疑，离开熟知的圈子，走向未知的圈子难免会产生许多畏惧甚至情怯，这都是人之常情，但不同的性格驱使我们会做出不同的决定。\n\n外向者也并非时时刻刻外向，但他们习惯于把自己表现在更多陌生人面前，这使得他们总是看起来易于被人接受。\n\n而内向者总是纠结于自己可能会犯错，而失去了展示自我的机会。他们纠结于自己的小圈子，总是需要花特别长的时间才能真正融入集体。\n\n# 二\n一个人加入一个新团队，就像一滴热水突然坠入一片冰河之中。\n\n有时候总需要一场破冰行动，说不定这场破冰行动会成为撕裂冰河的关键力量，在类似于蝴蝶效应的作用之下，整个河面最终都会融化，变成一片充满活力的美好世界，那时的你往往会觉得周围的一切是如此的亲切。\n\n其实往往只需一念之间，不必寻求取悦他人，不必担心自己会不会犯错，只需单纯的选择一个恰当的时间，然后展示出自己，一切无需机遇，无需刻意安排，仅此而已。\n\n其实人群中的每个人都不见得一定是具有才艺的个体，拥有才艺的往往是那么少数。也很少有喷子或者毒舌，那些习惯于没事嘲讽别人、看不到别人优点的人，其实很难在一个圈子中留下来，往往恰好是自己融不入圈子而逐渐的疏离。\n\n在一个团队中的大部分人，都是富有包容心的。所以不用担心自己的表现会使自己的形象受损，恰好相反，有时候在展示自己的才艺时一不小心搞砸了这样看起来很没面子的事情，反而会更容易让大家把你记住，并认为你是一个非常有趣的人，而易于跟你打交道。\n\n其实加入一个新集体就是这样简单，无需矫揉造作，无需刻意讨好，是什么就是什么。\n\n你当然应该在乎你的形象，但是那是靠经常修剪自己的羽毛来完成的，而不是刻意扮演出一个多么独特的形象。真正决定你的形象的，并非这样的一瞬间，而是平时自己的一点一滴的积累和努力，并能与时俱进，保持进取。做一个专注的人，静下心来沉入到一个事情中，并努力的使自己专业，一定更容易让人重视，并也将使你得以在社会职责中扮演更加重要的责任。\n\n# 三\n笔者亲历了一位内向者到社区发起者的成长之路。\n\n他是长沙互联网社区的领袖唐胡子，他说当他才20几岁时，也是一个非常内向的人，甚至比一般的人还要内向，到29岁时，谈过好几个对象都因为过于内向而未能修成正果。\n\n直到后来由于一次偶然的机会，他决定做出改变，然后他开始积极的放开自我，以更加积极的心态去接受陌生人，不再畏惧丢脸和面子，而是抓住一切机会表现自我，有圈子就融入圈子，没圈子就创造圈子。\n\n首先借助于网络，成为网络社区的积极份子，然后把人从线上拉到线下，通过面对面沟通来加强凝聚力，使得虚拟圈子逐渐的变成稳定的大圈子，然后又不断的有新人加入，有人离去，血液不断，细水长流，源远流长。可以说以他为中心的许多圈子都被带活了，数千人为之获益。\n\n要说他做了什么了不起的事情么，也许许多人会嗤之以鼻，不就是拉人头，搞活动，自我介绍，闲聊，聊技术话题么？\n\n运营一个社群其实就是这样看似简单，但是却同样不简单，优秀的运营者总是能在一片陌生人的世界中开创出属于自己品牌的小圈子，然后借助于圈子创造出更大的价值。  \n\n# 四\n有时我们应该积极的去拥抱陌生的领域。因为我们每个人都是独立存在的个体，独立的思维方式和行为的方式决定了我们跟周围人的区别，这恰好是人与人之间相处最大的乐趣，求同存异，在别人的世界中寻找自己，并探寻属于自己的未知领域，从而使自己的知识面进一步扩展。\n\n>“你有一个苹果，我有一个苹果，我们交换一下，一人还是只有一个苹果；你有一个思想，我有一个思想，我们交换一下，一人就有两个思想。\n\n我们可以怎么做呢？\n\n1、利用一切可以利用的资源，例如从网络开始，或者从花名册开始找人交流，寻找一些能够开启话题的方面，例如姓氏或兴趣爱好、或者籍贯等这些看起来无关紧要的东西。当然，有时你挑起的话题可能对方不感兴趣，没关系，至少冰层会一点点的融化开。这次不行，还有下次。\n\n2、跟你周围的陌生人打招呼。多打招呼，对方将从你的每一次笑容中认识你。\n\n3、去试图融入他们，从聆听他们的沟通开始，坐在陌生人的周围，营造一些沟通的机会。\n\n4、抓住每一次团队建设的机会，这就是破冰的良机。优秀的企业都会有团队建设，通过团队建设，你将有希望看到在你所处的组织架构的一维世界之外的另外一层维度，这将使你对组织有更新的认识。\n\n然后你将逐渐收获特别多的朋友，关键是你掌握了在陌生环境下生存的方法，这将成为你最重要的一种财富。\n\n","source":"_posts/随笔/如何快速融入团队并成为团队核心（一）.md","raw":"---\ntitle:  如何快速融入团队并成为团队核心（一）\ndate: 2020-01-03 9:28\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n# 一\n我们难免需要离开一个圈子，加入一个陌生的集体。毋庸置疑，离开熟知的圈子，走向未知的圈子难免会产生许多畏惧甚至情怯，这都是人之常情，但不同的性格驱使我们会做出不同的决定。\n\n外向者也并非时时刻刻外向，但他们习惯于把自己表现在更多陌生人面前，这使得他们总是看起来易于被人接受。\n\n而内向者总是纠结于自己可能会犯错，而失去了展示自我的机会。他们纠结于自己的小圈子，总是需要花特别长的时间才能真正融入集体。\n\n# 二\n一个人加入一个新团队，就像一滴热水突然坠入一片冰河之中。\n\n有时候总需要一场破冰行动，说不定这场破冰行动会成为撕裂冰河的关键力量，在类似于蝴蝶效应的作用之下，整个河面最终都会融化，变成一片充满活力的美好世界，那时的你往往会觉得周围的一切是如此的亲切。\n\n其实往往只需一念之间，不必寻求取悦他人，不必担心自己会不会犯错，只需单纯的选择一个恰当的时间，然后展示出自己，一切无需机遇，无需刻意安排，仅此而已。\n\n其实人群中的每个人都不见得一定是具有才艺的个体，拥有才艺的往往是那么少数。也很少有喷子或者毒舌，那些习惯于没事嘲讽别人、看不到别人优点的人，其实很难在一个圈子中留下来，往往恰好是自己融不入圈子而逐渐的疏离。\n\n在一个团队中的大部分人，都是富有包容心的。所以不用担心自己的表现会使自己的形象受损，恰好相反，有时候在展示自己的才艺时一不小心搞砸了这样看起来很没面子的事情，反而会更容易让大家把你记住，并认为你是一个非常有趣的人，而易于跟你打交道。\n\n其实加入一个新集体就是这样简单，无需矫揉造作，无需刻意讨好，是什么就是什么。\n\n你当然应该在乎你的形象，但是那是靠经常修剪自己的羽毛来完成的，而不是刻意扮演出一个多么独特的形象。真正决定你的形象的，并非这样的一瞬间，而是平时自己的一点一滴的积累和努力，并能与时俱进，保持进取。做一个专注的人，静下心来沉入到一个事情中，并努力的使自己专业，一定更容易让人重视，并也将使你得以在社会职责中扮演更加重要的责任。\n\n# 三\n笔者亲历了一位内向者到社区发起者的成长之路。\n\n他是长沙互联网社区的领袖唐胡子，他说当他才20几岁时，也是一个非常内向的人，甚至比一般的人还要内向，到29岁时，谈过好几个对象都因为过于内向而未能修成正果。\n\n直到后来由于一次偶然的机会，他决定做出改变，然后他开始积极的放开自我，以更加积极的心态去接受陌生人，不再畏惧丢脸和面子，而是抓住一切机会表现自我，有圈子就融入圈子，没圈子就创造圈子。\n\n首先借助于网络，成为网络社区的积极份子，然后把人从线上拉到线下，通过面对面沟通来加强凝聚力，使得虚拟圈子逐渐的变成稳定的大圈子，然后又不断的有新人加入，有人离去，血液不断，细水长流，源远流长。可以说以他为中心的许多圈子都被带活了，数千人为之获益。\n\n要说他做了什么了不起的事情么，也许许多人会嗤之以鼻，不就是拉人头，搞活动，自我介绍，闲聊，聊技术话题么？\n\n运营一个社群其实就是这样看似简单，但是却同样不简单，优秀的运营者总是能在一片陌生人的世界中开创出属于自己品牌的小圈子，然后借助于圈子创造出更大的价值。  \n\n# 四\n有时我们应该积极的去拥抱陌生的领域。因为我们每个人都是独立存在的个体，独立的思维方式和行为的方式决定了我们跟周围人的区别，这恰好是人与人之间相处最大的乐趣，求同存异，在别人的世界中寻找自己，并探寻属于自己的未知领域，从而使自己的知识面进一步扩展。\n\n>“你有一个苹果，我有一个苹果，我们交换一下，一人还是只有一个苹果；你有一个思想，我有一个思想，我们交换一下，一人就有两个思想。\n\n我们可以怎么做呢？\n\n1、利用一切可以利用的资源，例如从网络开始，或者从花名册开始找人交流，寻找一些能够开启话题的方面，例如姓氏或兴趣爱好、或者籍贯等这些看起来无关紧要的东西。当然，有时你挑起的话题可能对方不感兴趣，没关系，至少冰层会一点点的融化开。这次不行，还有下次。\n\n2、跟你周围的陌生人打招呼。多打招呼，对方将从你的每一次笑容中认识你。\n\n3、去试图融入他们，从聆听他们的沟通开始，坐在陌生人的周围，营造一些沟通的机会。\n\n4、抓住每一次团队建设的机会，这就是破冰的良机。优秀的企业都会有团队建设，通过团队建设，你将有希望看到在你所处的组织架构的一维世界之外的另外一层维度，这将使你对组织有更新的认识。\n\n然后你将逐渐收获特别多的朋友，关键是你掌握了在陌生环境下生存的方法，这将成为你最重要的一种财富。\n\n","slug":"随笔/如何快速融入团队并成为团队核心（一）","published":1,"updated":"2020-01-19T00:46:36.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt92003fn4vijwxf3y6u","content":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>我们难免需要离开一个圈子，加入一个陌生的集体。毋庸置疑，离开熟知的圈子，走向未知的圈子难免会产生许多畏惧甚至情怯，这都是人之常情，但不同的性格驱使我们会做出不同的决定。</p>\n<p>外向者也并非时时刻刻外向，但他们习惯于把自己表现在更多陌生人面前，这使得他们总是看起来易于被人接受。</p>\n<p>而内向者总是纠结于自己可能会犯错，而失去了展示自我的机会。他们纠结于自己的小圈子，总是需要花特别长的时间才能真正融入集体。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>一个人加入一个新团队，就像一滴热水突然坠入一片冰河之中。</p>\n<p>有时候总需要一场破冰行动，说不定这场破冰行动会成为撕裂冰河的关键力量，在类似于蝴蝶效应的作用之下，整个河面最终都会融化，变成一片充满活力的美好世界，那时的你往往会觉得周围的一切是如此的亲切。</p>\n<p>其实往往只需一念之间，不必寻求取悦他人，不必担心自己会不会犯错，只需单纯的选择一个恰当的时间，然后展示出自己，一切无需机遇，无需刻意安排，仅此而已。</p>\n<p>其实人群中的每个人都不见得一定是具有才艺的个体，拥有才艺的往往是那么少数。也很少有喷子或者毒舌，那些习惯于没事嘲讽别人、看不到别人优点的人，其实很难在一个圈子中留下来，往往恰好是自己融不入圈子而逐渐的疏离。</p>\n<p>在一个团队中的大部分人，都是富有包容心的。所以不用担心自己的表现会使自己的形象受损，恰好相反，有时候在展示自己的才艺时一不小心搞砸了这样看起来很没面子的事情，反而会更容易让大家把你记住，并认为你是一个非常有趣的人，而易于跟你打交道。</p>\n<p>其实加入一个新集体就是这样简单，无需矫揉造作，无需刻意讨好，是什么就是什么。</p>\n<p>你当然应该在乎你的形象，但是那是靠经常修剪自己的羽毛来完成的，而不是刻意扮演出一个多么独特的形象。真正决定你的形象的，并非这样的一瞬间，而是平时自己的一点一滴的积累和努力，并能与时俱进，保持进取。做一个专注的人，静下心来沉入到一个事情中，并努力的使自己专业，一定更容易让人重视，并也将使你得以在社会职责中扮演更加重要的责任。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>笔者亲历了一位内向者到社区发起者的成长之路。</p>\n<p>他是长沙互联网社区的领袖唐胡子，他说当他才20几岁时，也是一个非常内向的人，甚至比一般的人还要内向，到29岁时，谈过好几个对象都因为过于内向而未能修成正果。</p>\n<p>直到后来由于一次偶然的机会，他决定做出改变，然后他开始积极的放开自我，以更加积极的心态去接受陌生人，不再畏惧丢脸和面子，而是抓住一切机会表现自我，有圈子就融入圈子，没圈子就创造圈子。</p>\n<p>首先借助于网络，成为网络社区的积极份子，然后把人从线上拉到线下，通过面对面沟通来加强凝聚力，使得虚拟圈子逐渐的变成稳定的大圈子，然后又不断的有新人加入，有人离去，血液不断，细水长流，源远流长。可以说以他为中心的许多圈子都被带活了，数千人为之获益。</p>\n<p>要说他做了什么了不起的事情么，也许许多人会嗤之以鼻，不就是拉人头，搞活动，自我介绍，闲聊，聊技术话题么？</p>\n<p>运营一个社群其实就是这样看似简单，但是却同样不简单，优秀的运营者总是能在一片陌生人的世界中开创出属于自己品牌的小圈子，然后借助于圈子创造出更大的价值。  </p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>有时我们应该积极的去拥抱陌生的领域。因为我们每个人都是独立存在的个体，独立的思维方式和行为的方式决定了我们跟周围人的区别，这恰好是人与人之间相处最大的乐趣，求同存异，在别人的世界中寻找自己，并探寻属于自己的未知领域，从而使自己的知识面进一步扩展。</p>\n<blockquote>\n<p>“你有一个苹果，我有一个苹果，我们交换一下，一人还是只有一个苹果；你有一个思想，我有一个思想，我们交换一下，一人就有两个思想。</p>\n</blockquote>\n<p>我们可以怎么做呢？</p>\n<p>1、利用一切可以利用的资源，例如从网络开始，或者从花名册开始找人交流，寻找一些能够开启话题的方面，例如姓氏或兴趣爱好、或者籍贯等这些看起来无关紧要的东西。当然，有时你挑起的话题可能对方不感兴趣，没关系，至少冰层会一点点的融化开。这次不行，还有下次。</p>\n<p>2、跟你周围的陌生人打招呼。多打招呼，对方将从你的每一次笑容中认识你。</p>\n<p>3、去试图融入他们，从聆听他们的沟通开始，坐在陌生人的周围，营造一些沟通的机会。</p>\n<p>4、抓住每一次团队建设的机会，这就是破冰的良机。优秀的企业都会有团队建设，通过团队建设，你将有希望看到在你所处的组织架构的一维世界之外的另外一层维度，这将使你对组织有更新的认识。</p>\n<p>然后你将逐渐收获特别多的朋友，关键是你掌握了在陌生环境下生存的方法，这将成为你最重要的一种财富。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>我们难免需要离开一个圈子，加入一个陌生的集体。毋庸置疑，离开熟知的圈子，走向未知的圈子难免会产生许多畏惧甚至情怯，这都是人之常情，但不同的性格驱使我们会做出不同的决定。</p>\n<p>外向者也并非时时刻刻外向，但他们习惯于把自己表现在更多陌生人面前，这使得他们总是看起来易于被人接受。</p>\n<p>而内向者总是纠结于自己可能会犯错，而失去了展示自我的机会。他们纠结于自己的小圈子，总是需要花特别长的时间才能真正融入集体。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>一个人加入一个新团队，就像一滴热水突然坠入一片冰河之中。</p>\n<p>有时候总需要一场破冰行动，说不定这场破冰行动会成为撕裂冰河的关键力量，在类似于蝴蝶效应的作用之下，整个河面最终都会融化，变成一片充满活力的美好世界，那时的你往往会觉得周围的一切是如此的亲切。</p>\n<p>其实往往只需一念之间，不必寻求取悦他人，不必担心自己会不会犯错，只需单纯的选择一个恰当的时间，然后展示出自己，一切无需机遇，无需刻意安排，仅此而已。</p>\n<p>其实人群中的每个人都不见得一定是具有才艺的个体，拥有才艺的往往是那么少数。也很少有喷子或者毒舌，那些习惯于没事嘲讽别人、看不到别人优点的人，其实很难在一个圈子中留下来，往往恰好是自己融不入圈子而逐渐的疏离。</p>\n<p>在一个团队中的大部分人，都是富有包容心的。所以不用担心自己的表现会使自己的形象受损，恰好相反，有时候在展示自己的才艺时一不小心搞砸了这样看起来很没面子的事情，反而会更容易让大家把你记住，并认为你是一个非常有趣的人，而易于跟你打交道。</p>\n<p>其实加入一个新集体就是这样简单，无需矫揉造作，无需刻意讨好，是什么就是什么。</p>\n<p>你当然应该在乎你的形象，但是那是靠经常修剪自己的羽毛来完成的，而不是刻意扮演出一个多么独特的形象。真正决定你的形象的，并非这样的一瞬间，而是平时自己的一点一滴的积累和努力，并能与时俱进，保持进取。做一个专注的人，静下心来沉入到一个事情中，并努力的使自己专业，一定更容易让人重视，并也将使你得以在社会职责中扮演更加重要的责任。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>笔者亲历了一位内向者到社区发起者的成长之路。</p>\n<p>他是长沙互联网社区的领袖唐胡子，他说当他才20几岁时，也是一个非常内向的人，甚至比一般的人还要内向，到29岁时，谈过好几个对象都因为过于内向而未能修成正果。</p>\n<p>直到后来由于一次偶然的机会，他决定做出改变，然后他开始积极的放开自我，以更加积极的心态去接受陌生人，不再畏惧丢脸和面子，而是抓住一切机会表现自我，有圈子就融入圈子，没圈子就创造圈子。</p>\n<p>首先借助于网络，成为网络社区的积极份子，然后把人从线上拉到线下，通过面对面沟通来加强凝聚力，使得虚拟圈子逐渐的变成稳定的大圈子，然后又不断的有新人加入，有人离去，血液不断，细水长流，源远流长。可以说以他为中心的许多圈子都被带活了，数千人为之获益。</p>\n<p>要说他做了什么了不起的事情么，也许许多人会嗤之以鼻，不就是拉人头，搞活动，自我介绍，闲聊，聊技术话题么？</p>\n<p>运营一个社群其实就是这样看似简单，但是却同样不简单，优秀的运营者总是能在一片陌生人的世界中开创出属于自己品牌的小圈子，然后借助于圈子创造出更大的价值。  </p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>有时我们应该积极的去拥抱陌生的领域。因为我们每个人都是独立存在的个体，独立的思维方式和行为的方式决定了我们跟周围人的区别，这恰好是人与人之间相处最大的乐趣，求同存异，在别人的世界中寻找自己，并探寻属于自己的未知领域，从而使自己的知识面进一步扩展。</p>\n<blockquote>\n<p>“你有一个苹果，我有一个苹果，我们交换一下，一人还是只有一个苹果；你有一个思想，我有一个思想，我们交换一下，一人就有两个思想。</p>\n</blockquote>\n<p>我们可以怎么做呢？</p>\n<p>1、利用一切可以利用的资源，例如从网络开始，或者从花名册开始找人交流，寻找一些能够开启话题的方面，例如姓氏或兴趣爱好、或者籍贯等这些看起来无关紧要的东西。当然，有时你挑起的话题可能对方不感兴趣，没关系，至少冰层会一点点的融化开。这次不行，还有下次。</p>\n<p>2、跟你周围的陌生人打招呼。多打招呼，对方将从你的每一次笑容中认识你。</p>\n<p>3、去试图融入他们，从聆听他们的沟通开始，坐在陌生人的周围，营造一些沟通的机会。</p>\n<p>4、抓住每一次团队建设的机会，这就是破冰的良机。优秀的企业都会有团队建设，通过团队建设，你将有希望看到在你所处的组织架构的一维世界之外的另外一层维度，这将使你对组织有更新的认识。</p>\n<p>然后你将逐渐收获特别多的朋友，关键是你掌握了在陌生环境下生存的方法，这将成为你最重要的一种财富。</p>\n"},{"title":"如何快速融入团队并成为团队核心(七)","date":"2020-02-17T12:22:00.000Z","author":"邹溪源","_content":"# 一、引言\n今天继续讨论一下如何提高自己的工作效率，讨论完个人精力分配，接着讨论开会的问题。开会确实是影响个人效率的关键问题，我曾经分析过，一家中小型互联网公司的中层管理者，几乎每周有八分之一到六分之一的时间是在开会中度过。\n\n中国人是如此的热衷于开会，大事开大会，小事开小会，似乎没什么是开会不能解决的问题。如果说“有人的地方就有江湖”，那么大概还有一个类似的说法可以说成“有人的地方就有会议”。\n\n开会大概本身是为了提高效率，却最终变成了一种低效的行为，这背后究竟发生了什么呢。\n\n# 二、神仙会\n我还记得曾经在一家公司工作时，那家公司老板特别喜欢做下面这件事：\n\n>每次选在上午10点多左右，以讨论需求和产品远期发展规划为由，拉上一群相关或不相关的人员，然后大家一起在会议室中，对着空气发表对未来的规划，老板开始抽他的芙蓉王，听大家互相扯淡。\n>闲时老板还允许你自己泡一杯咖啡或一杯茶，总之就是空谈；然后就这么闲聊到下午两点，然后老板一拍大腿，呀，不小小心又开了这么久的会了，走，一起吃饭去。\n>然后大家聚个餐，到下午四点。然后这个会算是正式结束了么？并没有，晚上11点，老板再给几个相关人员打电话，一起聚集到他位于湘江边两百平大宅附近的一个茶馆中，继续讨论白天的话题，一壶红茶不加七八次水，几乎也难得消停，就这么开到凌晨三四点，然后散会。（第二天早上得准点9点上班。）\n\n我的同事称其为“神仙会”。“一壶茶一包烟，快乐似神仙”。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/pexels-photo-230477.jpeg)\n\n当然，等闲的人大概是没有资格参加这些会的，能够有幸参会并能把全场通关的往往都是中层或高层管理者，毕竟开会其实也是企业文化的一部分，如果你连这点开会都不能接受，又如何能接受公司的价值观和企业文化呢。。\n\n当然，每次叫我开会，我都会选择听前15分钟，因为，有时候如果一个事情连15分钟都不能说明白，说明这个会的价值已经不太存在了，要么是双方根本不在同一个频道上，要么就是有一方根本没用心的准备与会议相关的话题。当然，有许多相对来说年长的管理者信奉会议就是企业管理的核心，总是想尽一切办法拉更多的人来开会，而且动不动就头脑风暴，这样的效率到底是高还是不高呢，大家其实内心都很清楚。\n\n# 二、为何开会？\n必须承认，有时选择开会是团队内部进行澄清事实、发现问题的非常关键的方法，有时候确实也如同第四篇说的，甚至可以称为是不同团队间进行团队建设的一种形式，不过显然在互联网时代的今天，层出不穷的各种会议往往让从业人员深受其害。\n\n例如基于敏捷项目管理的产品研发流程中，也规定了“站立会议”，“计划会”，“评审会”，“反思会”，其中站立会议说的是不超过十五分钟，要求每个人用三个问题将自己做的事情讲清楚“我做完了什么”，“遇到了什么”，“计划今天做什么问题”，但是实际操作过程中，也难免会陷入文山会海的谜团中。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/people-coffee-notes-tea.jpg)\n\n例如，某某某作为后端工程师，同时参与了3个产品的研发，如果每个产品需要开一个站立会议，那么意味着保守得准备一小时的开会时间。问题是，如何确保一个会能够在十五分钟开完，其次，究竟有几个人能够用短短几句话讲清楚自己的需求？\n\n于是有的会，原本应该是任务会的，结果开成了头脑风暴会，一群人针对某个议题讨论半天，看起来最后也形成了结论，但是这样的结论却是以消耗了四五个人两三个小时的工时为代价，如果不是通过这样开会的形式，难道就无法形成一个可用的结果么。\n\n有事没事就头脑风暴，似乎也成为互联网开发者们经常吐槽的话题。仿佛如果一群人如果不通过开头脑风暴的形式，似乎就无法收集到足够多的创意一般。当然，大概是因为平时大家手头上的工作本身也做不完，但是作为领导呢，总担心大家会闲着，所以想着法子让大家过得更加充实。通过开会的形式，让大家先把手头上的工作先暂时放一下，我们先切换到一个新的副本=》会议室。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/pexels-photo-416320.jpeg)\n\n然后针对性一个或许与当前工作无关的话题讨论一下，以便把大家脑海中的创造性思维彻底的掏空（毕竟互联网公司已经不需要创意了，要的是如何快速的借鉴（copy to our company））。\n\n当然，开会也使得我们能够放空一下~但是这样的放空最终牺牲了下班后的时间，从这一点上看开会大概约等于996，如果哪一天开了四次会，那大概这一天的白天全部荒废了。然后就花费了大量精力做的许多事情，都是在用自己的苦劳证明自己在为公司抛头颅洒热血般的拼命而已。\n\n# 三、结语\n所以在团队中如果要提高自己的工作效率，就得想办法思考如何提高团队会议效率的方法，也许这些方法无法在短期内实现自己劳动生产力的提高，但是会逐渐的形成我们自己的微习惯，并进而逐渐改变我们做事的方式。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/v2-1a58372e6725b4bf0a01d2735a534706_hd.jpg)\n\n这些方法或许可以包括以下这些策略：\n\n1、灵活的运用罗伯特议事规则：这是一个来源于大洋彼岸的开会规则，甚至于联合国或美国国会开会都是用这套规则，美国国会参议院和众议院都是大几百号议员开会，每天讨论的都是世界性大事，我想我们的开会复杂度应该不会比这个高了吧。在这套规则中，包括大概动议、复议、陈述议题、辩论、表决等许多个步骤，制定了一系列规则，例如未经动议不可讨论，主持人不能偏袒动议、强调发言完整等。（当然，大概许多人都会认为自己公司还没有复杂到需要动用罗伯特议事规则来开会的情况，但是谁知道呢。开会的时候大部分情况下的纠结，还不是不同观点持有者从自己的专业角度出发，认为某些问题值得做，不值得做，该怎么做，结果与其他人意见相左而引发的矛盾纠纷呢。。）\n\n2、不要盲目的开头脑风暴会，尽可能的先用头脑风暴调查。先针对需要讨论的产品需求提出调查，让相关方针对问题进行思考，形成一个大概的方向后，再通过会议的形式进行交流讨论，从而使得问题的思考时间尽可能的前置，避免了参会者在会议的前十五分钟还不清楚这个会是干什么的尴尬情况。\n\n3、能不开会就别开会、要开也得站着开。\n\n4、每次开会先选择一个主持人，这个主持人配备一个秒表，超时立马让有关人员结束他的表述。如果一个人连五分钟都无法把自己的问题讲清楚。。那这个人还是很厉害的，他有做老板的潜质。\n\n真爱生命，远离低效的会议，我们将逐渐积累属于自己的小成功。\n\n","source":"_posts/随笔/如何快速融入团队并成为团队核心（七）.md","raw":"---\ntitle:  如何快速融入团队并成为团队核心(七)\ndate: 2020-2-17 20:22\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n\n---\n# 一、引言\n今天继续讨论一下如何提高自己的工作效率，讨论完个人精力分配，接着讨论开会的问题。开会确实是影响个人效率的关键问题，我曾经分析过，一家中小型互联网公司的中层管理者，几乎每周有八分之一到六分之一的时间是在开会中度过。\n\n中国人是如此的热衷于开会，大事开大会，小事开小会，似乎没什么是开会不能解决的问题。如果说“有人的地方就有江湖”，那么大概还有一个类似的说法可以说成“有人的地方就有会议”。\n\n开会大概本身是为了提高效率，却最终变成了一种低效的行为，这背后究竟发生了什么呢。\n\n# 二、神仙会\n我还记得曾经在一家公司工作时，那家公司老板特别喜欢做下面这件事：\n\n>每次选在上午10点多左右，以讨论需求和产品远期发展规划为由，拉上一群相关或不相关的人员，然后大家一起在会议室中，对着空气发表对未来的规划，老板开始抽他的芙蓉王，听大家互相扯淡。\n>闲时老板还允许你自己泡一杯咖啡或一杯茶，总之就是空谈；然后就这么闲聊到下午两点，然后老板一拍大腿，呀，不小小心又开了这么久的会了，走，一起吃饭去。\n>然后大家聚个餐，到下午四点。然后这个会算是正式结束了么？并没有，晚上11点，老板再给几个相关人员打电话，一起聚集到他位于湘江边两百平大宅附近的一个茶馆中，继续讨论白天的话题，一壶红茶不加七八次水，几乎也难得消停，就这么开到凌晨三四点，然后散会。（第二天早上得准点9点上班。）\n\n我的同事称其为“神仙会”。“一壶茶一包烟，快乐似神仙”。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/pexels-photo-230477.jpeg)\n\n当然，等闲的人大概是没有资格参加这些会的，能够有幸参会并能把全场通关的往往都是中层或高层管理者，毕竟开会其实也是企业文化的一部分，如果你连这点开会都不能接受，又如何能接受公司的价值观和企业文化呢。。\n\n当然，每次叫我开会，我都会选择听前15分钟，因为，有时候如果一个事情连15分钟都不能说明白，说明这个会的价值已经不太存在了，要么是双方根本不在同一个频道上，要么就是有一方根本没用心的准备与会议相关的话题。当然，有许多相对来说年长的管理者信奉会议就是企业管理的核心，总是想尽一切办法拉更多的人来开会，而且动不动就头脑风暴，这样的效率到底是高还是不高呢，大家其实内心都很清楚。\n\n# 二、为何开会？\n必须承认，有时选择开会是团队内部进行澄清事实、发现问题的非常关键的方法，有时候确实也如同第四篇说的，甚至可以称为是不同团队间进行团队建设的一种形式，不过显然在互联网时代的今天，层出不穷的各种会议往往让从业人员深受其害。\n\n例如基于敏捷项目管理的产品研发流程中，也规定了“站立会议”，“计划会”，“评审会”，“反思会”，其中站立会议说的是不超过十五分钟，要求每个人用三个问题将自己做的事情讲清楚“我做完了什么”，“遇到了什么”，“计划今天做什么问题”，但是实际操作过程中，也难免会陷入文山会海的谜团中。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/people-coffee-notes-tea.jpg)\n\n例如，某某某作为后端工程师，同时参与了3个产品的研发，如果每个产品需要开一个站立会议，那么意味着保守得准备一小时的开会时间。问题是，如何确保一个会能够在十五分钟开完，其次，究竟有几个人能够用短短几句话讲清楚自己的需求？\n\n于是有的会，原本应该是任务会的，结果开成了头脑风暴会，一群人针对某个议题讨论半天，看起来最后也形成了结论，但是这样的结论却是以消耗了四五个人两三个小时的工时为代价，如果不是通过这样开会的形式，难道就无法形成一个可用的结果么。\n\n有事没事就头脑风暴，似乎也成为互联网开发者们经常吐槽的话题。仿佛如果一群人如果不通过开头脑风暴的形式，似乎就无法收集到足够多的创意一般。当然，大概是因为平时大家手头上的工作本身也做不完，但是作为领导呢，总担心大家会闲着，所以想着法子让大家过得更加充实。通过开会的形式，让大家先把手头上的工作先暂时放一下，我们先切换到一个新的副本=》会议室。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/pexels-photo-416320.jpeg)\n\n然后针对性一个或许与当前工作无关的话题讨论一下，以便把大家脑海中的创造性思维彻底的掏空（毕竟互联网公司已经不需要创意了，要的是如何快速的借鉴（copy to our company））。\n\n当然，开会也使得我们能够放空一下~但是这样的放空最终牺牲了下班后的时间，从这一点上看开会大概约等于996，如果哪一天开了四次会，那大概这一天的白天全部荒废了。然后就花费了大量精力做的许多事情，都是在用自己的苦劳证明自己在为公司抛头颅洒热血般的拼命而已。\n\n# 三、结语\n所以在团队中如果要提高自己的工作效率，就得想办法思考如何提高团队会议效率的方法，也许这些方法无法在短期内实现自己劳动生产力的提高，但是会逐渐的形成我们自己的微习惯，并进而逐渐改变我们做事的方式。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/v2-1a58372e6725b4bf0a01d2735a534706_hd.jpg)\n\n这些方法或许可以包括以下这些策略：\n\n1、灵活的运用罗伯特议事规则：这是一个来源于大洋彼岸的开会规则，甚至于联合国或美国国会开会都是用这套规则，美国国会参议院和众议院都是大几百号议员开会，每天讨论的都是世界性大事，我想我们的开会复杂度应该不会比这个高了吧。在这套规则中，包括大概动议、复议、陈述议题、辩论、表决等许多个步骤，制定了一系列规则，例如未经动议不可讨论，主持人不能偏袒动议、强调发言完整等。（当然，大概许多人都会认为自己公司还没有复杂到需要动用罗伯特议事规则来开会的情况，但是谁知道呢。开会的时候大部分情况下的纠结，还不是不同观点持有者从自己的专业角度出发，认为某些问题值得做，不值得做，该怎么做，结果与其他人意见相左而引发的矛盾纠纷呢。。）\n\n2、不要盲目的开头脑风暴会，尽可能的先用头脑风暴调查。先针对需要讨论的产品需求提出调查，让相关方针对问题进行思考，形成一个大概的方向后，再通过会议的形式进行交流讨论，从而使得问题的思考时间尽可能的前置，避免了参会者在会议的前十五分钟还不清楚这个会是干什么的尴尬情况。\n\n3、能不开会就别开会、要开也得站着开。\n\n4、每次开会先选择一个主持人，这个主持人配备一个秒表，超时立马让有关人员结束他的表述。如果一个人连五分钟都无法把自己的问题讲清楚。。那这个人还是很厉害的，他有做老板的潜质。\n\n真爱生命，远离低效的会议，我们将逐渐积累属于自己的小成功。\n\n","slug":"随笔/如何快速融入团队并成为团队核心（七）","published":1,"updated":"2020-02-17T12:32:15.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt94003in4vismjhpomz","content":"<h1 id=\"一、引言\"><a href=\"#一、引言\" class=\"headerlink\" title=\"一、引言\"></a>一、引言</h1><p>今天继续讨论一下如何提高自己的工作效率，讨论完个人精力分配，接着讨论开会的问题。开会确实是影响个人效率的关键问题，我曾经分析过，一家中小型互联网公司的中层管理者，几乎每周有八分之一到六分之一的时间是在开会中度过。</p>\n<p>中国人是如此的热衷于开会，大事开大会，小事开小会，似乎没什么是开会不能解决的问题。如果说“有人的地方就有江湖”，那么大概还有一个类似的说法可以说成“有人的地方就有会议”。</p>\n<p>开会大概本身是为了提高效率，却最终变成了一种低效的行为，这背后究竟发生了什么呢。</p>\n<h1 id=\"二、神仙会\"><a href=\"#二、神仙会\" class=\"headerlink\" title=\"二、神仙会\"></a>二、神仙会</h1><p>我还记得曾经在一家公司工作时，那家公司老板特别喜欢做下面这件事：</p>\n<blockquote>\n<p>每次选在上午10点多左右，以讨论需求和产品远期发展规划为由，拉上一群相关或不相关的人员，然后大家一起在会议室中，对着空气发表对未来的规划，老板开始抽他的芙蓉王，听大家互相扯淡。<br>闲时老板还允许你自己泡一杯咖啡或一杯茶，总之就是空谈；然后就这么闲聊到下午两点，然后老板一拍大腿，呀，不小小心又开了这么久的会了，走，一起吃饭去。<br>然后大家聚个餐，到下午四点。然后这个会算是正式结束了么？并没有，晚上11点，老板再给几个相关人员打电话，一起聚集到他位于湘江边两百平大宅附近的一个茶馆中，继续讨论白天的话题，一壶红茶不加七八次水，几乎也难得消停，就这么开到凌晨三四点，然后散会。（第二天早上得准点9点上班。）</p>\n</blockquote>\n<p>我的同事称其为“神仙会”。“一壶茶一包烟，快乐似神仙”。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/pexels-photo-230477.jpeg\" alt=\"图片\"></p>\n<p>当然，等闲的人大概是没有资格参加这些会的，能够有幸参会并能把全场通关的往往都是中层或高层管理者，毕竟开会其实也是企业文化的一部分，如果你连这点开会都不能接受，又如何能接受公司的价值观和企业文化呢。。</p>\n<p>当然，每次叫我开会，我都会选择听前15分钟，因为，有时候如果一个事情连15分钟都不能说明白，说明这个会的价值已经不太存在了，要么是双方根本不在同一个频道上，要么就是有一方根本没用心的准备与会议相关的话题。当然，有许多相对来说年长的管理者信奉会议就是企业管理的核心，总是想尽一切办法拉更多的人来开会，而且动不动就头脑风暴，这样的效率到底是高还是不高呢，大家其实内心都很清楚。</p>\n<h1 id=\"二、为何开会？\"><a href=\"#二、为何开会？\" class=\"headerlink\" title=\"二、为何开会？\"></a>二、为何开会？</h1><p>必须承认，有时选择开会是团队内部进行澄清事实、发现问题的非常关键的方法，有时候确实也如同第四篇说的，甚至可以称为是不同团队间进行团队建设的一种形式，不过显然在互联网时代的今天，层出不穷的各种会议往往让从业人员深受其害。</p>\n<p>例如基于敏捷项目管理的产品研发流程中，也规定了“站立会议”，“计划会”，“评审会”，“反思会”，其中站立会议说的是不超过十五分钟，要求每个人用三个问题将自己做的事情讲清楚“我做完了什么”，“遇到了什么”，“计划今天做什么问题”，但是实际操作过程中，也难免会陷入文山会海的谜团中。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/people-coffee-notes-tea.jpg\" alt=\"图片\"></p>\n<p>例如，某某某作为后端工程师，同时参与了3个产品的研发，如果每个产品需要开一个站立会议，那么意味着保守得准备一小时的开会时间。问题是，如何确保一个会能够在十五分钟开完，其次，究竟有几个人能够用短短几句话讲清楚自己的需求？</p>\n<p>于是有的会，原本应该是任务会的，结果开成了头脑风暴会，一群人针对某个议题讨论半天，看起来最后也形成了结论，但是这样的结论却是以消耗了四五个人两三个小时的工时为代价，如果不是通过这样开会的形式，难道就无法形成一个可用的结果么。</p>\n<p>有事没事就头脑风暴，似乎也成为互联网开发者们经常吐槽的话题。仿佛如果一群人如果不通过开头脑风暴的形式，似乎就无法收集到足够多的创意一般。当然，大概是因为平时大家手头上的工作本身也做不完，但是作为领导呢，总担心大家会闲着，所以想着法子让大家过得更加充实。通过开会的形式，让大家先把手头上的工作先暂时放一下，我们先切换到一个新的副本=》会议室。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/pexels-photo-416320.jpeg\" alt=\"图片\"></p>\n<p>然后针对性一个或许与当前工作无关的话题讨论一下，以便把大家脑海中的创造性思维彻底的掏空（毕竟互联网公司已经不需要创意了，要的是如何快速的借鉴（copy to our company））。</p>\n<p>当然，开会也使得我们能够放空一下~但是这样的放空最终牺牲了下班后的时间，从这一点上看开会大概约等于996，如果哪一天开了四次会，那大概这一天的白天全部荒废了。然后就花费了大量精力做的许多事情，都是在用自己的苦劳证明自己在为公司抛头颅洒热血般的拼命而已。</p>\n<h1 id=\"三、结语\"><a href=\"#三、结语\" class=\"headerlink\" title=\"三、结语\"></a>三、结语</h1><p>所以在团队中如果要提高自己的工作效率，就得想办法思考如何提高团队会议效率的方法，也许这些方法无法在短期内实现自己劳动生产力的提高，但是会逐渐的形成我们自己的微习惯，并进而逐渐改变我们做事的方式。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/v2-1a58372e6725b4bf0a01d2735a534706_hd.jpg\" alt=\"图片\"></p>\n<p>这些方法或许可以包括以下这些策略：</p>\n<p>1、灵活的运用罗伯特议事规则：这是一个来源于大洋彼岸的开会规则，甚至于联合国或美国国会开会都是用这套规则，美国国会参议院和众议院都是大几百号议员开会，每天讨论的都是世界性大事，我想我们的开会复杂度应该不会比这个高了吧。在这套规则中，包括大概动议、复议、陈述议题、辩论、表决等许多个步骤，制定了一系列规则，例如未经动议不可讨论，主持人不能偏袒动议、强调发言完整等。（当然，大概许多人都会认为自己公司还没有复杂到需要动用罗伯特议事规则来开会的情况，但是谁知道呢。开会的时候大部分情况下的纠结，还不是不同观点持有者从自己的专业角度出发，认为某些问题值得做，不值得做，该怎么做，结果与其他人意见相左而引发的矛盾纠纷呢。。）</p>\n<p>2、不要盲目的开头脑风暴会，尽可能的先用头脑风暴调查。先针对需要讨论的产品需求提出调查，让相关方针对问题进行思考，形成一个大概的方向后，再通过会议的形式进行交流讨论，从而使得问题的思考时间尽可能的前置，避免了参会者在会议的前十五分钟还不清楚这个会是干什么的尴尬情况。</p>\n<p>3、能不开会就别开会、要开也得站着开。</p>\n<p>4、每次开会先选择一个主持人，这个主持人配备一个秒表，超时立马让有关人员结束他的表述。如果一个人连五分钟都无法把自己的问题讲清楚。。那这个人还是很厉害的，他有做老板的潜质。</p>\n<p>真爱生命，远离低效的会议，我们将逐渐积累属于自己的小成功。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、引言\"><a href=\"#一、引言\" class=\"headerlink\" title=\"一、引言\"></a>一、引言</h1><p>今天继续讨论一下如何提高自己的工作效率，讨论完个人精力分配，接着讨论开会的问题。开会确实是影响个人效率的关键问题，我曾经分析过，一家中小型互联网公司的中层管理者，几乎每周有八分之一到六分之一的时间是在开会中度过。</p>\n<p>中国人是如此的热衷于开会，大事开大会，小事开小会，似乎没什么是开会不能解决的问题。如果说“有人的地方就有江湖”，那么大概还有一个类似的说法可以说成“有人的地方就有会议”。</p>\n<p>开会大概本身是为了提高效率，却最终变成了一种低效的行为，这背后究竟发生了什么呢。</p>\n<h1 id=\"二、神仙会\"><a href=\"#二、神仙会\" class=\"headerlink\" title=\"二、神仙会\"></a>二、神仙会</h1><p>我还记得曾经在一家公司工作时，那家公司老板特别喜欢做下面这件事：</p>\n<blockquote>\n<p>每次选在上午10点多左右，以讨论需求和产品远期发展规划为由，拉上一群相关或不相关的人员，然后大家一起在会议室中，对着空气发表对未来的规划，老板开始抽他的芙蓉王，听大家互相扯淡。<br>闲时老板还允许你自己泡一杯咖啡或一杯茶，总之就是空谈；然后就这么闲聊到下午两点，然后老板一拍大腿，呀，不小小心又开了这么久的会了，走，一起吃饭去。<br>然后大家聚个餐，到下午四点。然后这个会算是正式结束了么？并没有，晚上11点，老板再给几个相关人员打电话，一起聚集到他位于湘江边两百平大宅附近的一个茶馆中，继续讨论白天的话题，一壶红茶不加七八次水，几乎也难得消停，就这么开到凌晨三四点，然后散会。（第二天早上得准点9点上班。）</p>\n</blockquote>\n<p>我的同事称其为“神仙会”。“一壶茶一包烟，快乐似神仙”。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/pexels-photo-230477.jpeg\" alt=\"图片\"></p>\n<p>当然，等闲的人大概是没有资格参加这些会的，能够有幸参会并能把全场通关的往往都是中层或高层管理者，毕竟开会其实也是企业文化的一部分，如果你连这点开会都不能接受，又如何能接受公司的价值观和企业文化呢。。</p>\n<p>当然，每次叫我开会，我都会选择听前15分钟，因为，有时候如果一个事情连15分钟都不能说明白，说明这个会的价值已经不太存在了，要么是双方根本不在同一个频道上，要么就是有一方根本没用心的准备与会议相关的话题。当然，有许多相对来说年长的管理者信奉会议就是企业管理的核心，总是想尽一切办法拉更多的人来开会，而且动不动就头脑风暴，这样的效率到底是高还是不高呢，大家其实内心都很清楚。</p>\n<h1 id=\"二、为何开会？\"><a href=\"#二、为何开会？\" class=\"headerlink\" title=\"二、为何开会？\"></a>二、为何开会？</h1><p>必须承认，有时选择开会是团队内部进行澄清事实、发现问题的非常关键的方法，有时候确实也如同第四篇说的，甚至可以称为是不同团队间进行团队建设的一种形式，不过显然在互联网时代的今天，层出不穷的各种会议往往让从业人员深受其害。</p>\n<p>例如基于敏捷项目管理的产品研发流程中，也规定了“站立会议”，“计划会”，“评审会”，“反思会”，其中站立会议说的是不超过十五分钟，要求每个人用三个问题将自己做的事情讲清楚“我做完了什么”，“遇到了什么”，“计划今天做什么问题”，但是实际操作过程中，也难免会陷入文山会海的谜团中。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/people-coffee-notes-tea.jpg\" alt=\"图片\"></p>\n<p>例如，某某某作为后端工程师，同时参与了3个产品的研发，如果每个产品需要开一个站立会议，那么意味着保守得准备一小时的开会时间。问题是，如何确保一个会能够在十五分钟开完，其次，究竟有几个人能够用短短几句话讲清楚自己的需求？</p>\n<p>于是有的会，原本应该是任务会的，结果开成了头脑风暴会，一群人针对某个议题讨论半天，看起来最后也形成了结论，但是这样的结论却是以消耗了四五个人两三个小时的工时为代价，如果不是通过这样开会的形式，难道就无法形成一个可用的结果么。</p>\n<p>有事没事就头脑风暴，似乎也成为互联网开发者们经常吐槽的话题。仿佛如果一群人如果不通过开头脑风暴的形式，似乎就无法收集到足够多的创意一般。当然，大概是因为平时大家手头上的工作本身也做不完，但是作为领导呢，总担心大家会闲着，所以想着法子让大家过得更加充实。通过开会的形式，让大家先把手头上的工作先暂时放一下，我们先切换到一个新的副本=》会议室。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/pexels-photo-416320.jpeg\" alt=\"图片\"></p>\n<p>然后针对性一个或许与当前工作无关的话题讨论一下，以便把大家脑海中的创造性思维彻底的掏空（毕竟互联网公司已经不需要创意了，要的是如何快速的借鉴（copy to our company））。</p>\n<p>当然，开会也使得我们能够放空一下~但是这样的放空最终牺牲了下班后的时间，从这一点上看开会大概约等于996，如果哪一天开了四次会，那大概这一天的白天全部荒废了。然后就花费了大量精力做的许多事情，都是在用自己的苦劳证明自己在为公司抛头颅洒热血般的拼命而已。</p>\n<h1 id=\"三、结语\"><a href=\"#三、结语\" class=\"headerlink\" title=\"三、结语\"></a>三、结语</h1><p>所以在团队中如果要提高自己的工作效率，就得想办法思考如何提高团队会议效率的方法，也许这些方法无法在短期内实现自己劳动生产力的提高，但是会逐渐的形成我们自己的微习惯，并进而逐渐改变我们做事的方式。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/v2-1a58372e6725b4bf0a01d2735a534706_hd.jpg\" alt=\"图片\"></p>\n<p>这些方法或许可以包括以下这些策略：</p>\n<p>1、灵活的运用罗伯特议事规则：这是一个来源于大洋彼岸的开会规则，甚至于联合国或美国国会开会都是用这套规则，美国国会参议院和众议院都是大几百号议员开会，每天讨论的都是世界性大事，我想我们的开会复杂度应该不会比这个高了吧。在这套规则中，包括大概动议、复议、陈述议题、辩论、表决等许多个步骤，制定了一系列规则，例如未经动议不可讨论，主持人不能偏袒动议、强调发言完整等。（当然，大概许多人都会认为自己公司还没有复杂到需要动用罗伯特议事规则来开会的情况，但是谁知道呢。开会的时候大部分情况下的纠结，还不是不同观点持有者从自己的专业角度出发，认为某些问题值得做，不值得做，该怎么做，结果与其他人意见相左而引发的矛盾纠纷呢。。）</p>\n<p>2、不要盲目的开头脑风暴会，尽可能的先用头脑风暴调查。先针对需要讨论的产品需求提出调查，让相关方针对问题进行思考，形成一个大概的方向后，再通过会议的形式进行交流讨论，从而使得问题的思考时间尽可能的前置，避免了参会者在会议的前十五分钟还不清楚这个会是干什么的尴尬情况。</p>\n<p>3、能不开会就别开会、要开也得站着开。</p>\n<p>4、每次开会先选择一个主持人，这个主持人配备一个秒表，超时立马让有关人员结束他的表述。如果一个人连五分钟都无法把自己的问题讲清楚。。那这个人还是很厉害的，他有做老板的潜质。</p>\n<p>真爱生命，远离低效的会议，我们将逐渐积累属于自己的小成功。</p>\n"},{"title":"如何快速融入团队并成为团队核心(三)","date":"2020-01-19T00:48:00.000Z","author":"邹溪源","_content":"# 一  引子\n如何快速融入团队，看似是个简单的问题，其实并非如此。\n\n有时取决于你的性格、有时取决于你的机会，有时取决于企业是否拥有开放的心态或那些拥有开放心态的伙伴，还有时取决于企业的愿景、使命和价值观，以及这些因素的综合作用，同时也包括企业与你是否存在基因上的契合，或者企业文化本身，乃至企业的江湖规矩。\n\n# 二  基因\n基因是个奇妙的东西，似乎在吴军老师撰写《浪潮之巅》之前并不怎么引人注目，而随着吴军老师在书中将基因论作为企业能否顺应互联网的浪潮，并取得辉煌成就的关键因素后，就在坊间开始盛行起来。\n\n这个理论最早被美国管理大师Noel Tichy引入的概念，他把企业称为一个具有活力的生命体，来自于资本和劳动力的双螺旋结构，在创始人、机制、技术和文化等环境因素的共同激励下，促使企业以飞快的速度得以成长。\n\n基因看似是很重要的东西，但是也并非每家企业都一定被基因主导。吴军老师也提到了一些公司，从原本看起来不起眼的制造业，转型成为更加具有高附加值的创新型企业，公司管理层所具备的高瞻远瞩精神和善于创新、积极拥抱创新的态度，是企业得以长盛不衰的关键因素，他把这种称为转基因。\n\n从我们的角度来说，或许基因是个很远的东西，是对我们产生了某些看不到、客观存在的影响。\n\n例如，阿里巴巴的电商基因，使阿里巴巴人更具有应对风险和危机的意识，并透过企业管理一系列流程体现在公司的文化中。那些有幸加入过阿里巴巴的人，许多人都具有一种独特的气质，这种气质使他能够在困难面前无所畏惧，同时又能更好的适应变化的存在。大概这种气质也正是来源于阿里巴巴企业基因中最核心价值观的投影。\n\n也有人曾经有人说腾讯为何以前面向B端转型一直不太成果，大概是由于腾讯的基因都是游戏或社交基因，而除了主阵地之外的其他领域几乎都毫无建树，就连有幸邀请吴军老师加盟的腾讯地图，也未能在LBS领域获得多大的市场。不过随着腾讯云的兴起，这些局面已经有所改观，但是腾讯在智慧产业方面的布局，是否能够重现其在云端市场的效果，依然值得期待。\n\n企业基因的客观存在，或多或少会在我们的每一段职场经历产生积极或消极的影响。例如从公司获得了高层资源、人脉、解决问题的方法，这些都会对我们的未来产生商业上积极的促进作用。企业基因或多或少影响了职场基因。如果说初入职场的我们的职场基因看起来毫无特色，那么在职场中的不断挑战和历练，已经让我们的职场基因受到了大量的诱因而不断蜕变，从而形成了今天更加完美的个体。   \n\n# 三  文化\n越来越多的人重视企业文化的存在，因为企业文化如饮水、如呼吸般时刻存在，对凝聚集体，形成战斗力，一起共同思考公司的发展方向。优秀的企业文化也是企业得以长盛不衰的驱动力和灵魂。\n\n 企业文化的价值在于唤醒和激发团队的每一位成员对于企业的认同感、使命感和价值感。\n\n 基因与文化的耦合是如此紧密，以至于“基因和文化不可分离地连载一起，任何一个变化都将不可避免地迫使另一个也发生变化”。文化进化能塑造基因组，但也可以说基因对文化也存在必然的影响。\n\n创业公司或者中小公司或许都不重视企业文化的存在，因为企业认为可以依靠员工的自驱力来实现认同感和使命感，甚至也有许多人认为在创业公司谈文化是一种非常奢侈的行为，因为要刻意营造一个企业文化的氛围，往往需要从公司层面做好规划，例如采取绩效激励的策略，鼓励积极乐观正向有利于企业发展的文化，往往也会导致企业中好不容易招到的人才会逐渐流失，进而影响了创业企业的发展。\n\n但随着公司的逐渐增长，等发展到一定规模时，往往再构建一套企业文化体系，同样会带来不小的阵痛期，因为团队已经形成了一定的“江湖规矩”，如果这样的江湖规矩能够与企业文化完美的契合，或许还能平滑的过度，但是如果彼此发生了抵触，那显然会带来巨大的过度成本，有时候甚至会导致团队分崩离析。\n\n有一个经典的管理学理论“湿猴理论”是这么说的：\n\n>把A、B、C、D、E五只饿了极了的猴子关在一个笼子里，笼子上头掉着一串香蕉，正下方是一个箱子，如果猴子要拿香蕉必须爬上箱子。实验人员装了一个自动装置，若是侦测到有猴子要去爬箱子，就会有大水喷向笼子，这五只猴子马上会被淋湿。首先会有猴子想去拿香蕉，马上水喷出来，它们慌忙用手抱住头，当手离开香蕉的时候，水就立即停止喷射。每只猴子都去尝试了，都得到了同样的结果，开始不明白为什么，但后来知道只要去爬箱子拿香蕉，就会有大水喷来。於是猴子们达到一个共识：不要去拿香蕉！因为有水会喷出来！\n> 后来实验人员把其中的一只猴子换掉，换一只新猴子（称为F猴子好了）关到笼子里。这只F猴子看到香蕉，马上想要去拿，结果被其他四只旧猴子揍了一顿。因为其他四只猴子认为新猴子会害他们被水淋到，所以制止这新猴子去拿香蕉。这新猴子尝试了几次，被打的满头包，还是没有拿到香蕉，当然这五只猴子就没有被水喷到。后来实验人员再把一只旧猴子换掉，换另外一只新猴子（称为G猴子好了）关到笼子里，这支G猴子看到香蕉，当然也是马上要去拿，结果也是被其他四只猴子揍了一顿。那只F猴子打的特别用力,G猴子试了几次总是被打的很惨，只好作罢。\n> 后来慢慢的一只一只的，所有的旧猴子都换成新猴子了。大家都不敢去动那香蕉，但是他们都不知道为什么，只知道去动香蕉会被其他猴子扁。这就是“传统”的由来，这个故事被用来介绍企业文化的建立等诸多管理方面有很好的寓意。\n\n企业文化的建立，就像这个理论中所说，如果在早期采取某些措施有意无意的培养，营造更加积极乐观进取的企业文化氛围，并找对契合企业文化的人才，在发展过程中逐渐的对这些文化意识进行增强，实际上将会对企业的快速发展提供巨大的助力。\n\n# 四  江湖规矩\n“有人的地方就有江湖”。\n\nIT公司也同样如此，许多时候往往还没形成企业文化，反而会先形成江湖规矩。而江湖规矩有许多种。\n\n例如某种大哥文化，在公司发展的早期，往往会依托创始人的个人魅力招揽到一批与其情投意合的人，随着公司的发展，却并非每个人都以打造完美的公司为目标，有的早期员工难免加入公司的目的，就是为了早点占好山头，作威作福。于是公司倒是发展好了，但是大哥却成为最难啃的骨头，或是任人唯亲，或是贪污受贿，或是故意把控住某些关键命门，让全公司都必须看他的脸色行事。\n\n例如某种荤段子文化和烟文化，好吧，听某大型互联网公司朋友说的。在他们的某些部门，荤段子文化特别严重，所以加入了公司就得接受公司的规矩，从能听荤段子开始，到能讲荤段子，那就说明你已经被组织熏陶得非常到位了。除此之外，有的部门烟文化特别严重，像极了某些国企部门，依托烟文化来维系人际关系，不得不说依然是中国人获得人脉的不二法门。\n\n譬如游戏文化，鄙人曾经呆过的一家公司就以团队对战游戏Dota进行团队建设当成公司核心企业文化的一部分，于是那些对Dota这种游戏毫无兴趣、或者不愿意在公司玩RPG游戏、或者不喜欢乱糟糟的氛围的人，就很难融入团队中，直到流失。\n\n即便有了企业文化，往往依然有江湖规矩。如果把企业文化理解为宗教中形而上的思想哲学，那江湖规矩就是具体执行层面的道德约束，如果只是口头上宣讲企业文化的正面，而忽略了同样需要改革甚至破除的影响企业良性发展的“丑陋”的江湖规矩，往往体现了公司在执行层面的巨大缺失，也将为公司的发展埋下隐患。\n\n# 五  结语\n软件企业的发展，往往并非一朝一夕的爆发，更是从内功到外功的修炼之路，始于企业基因，成于企业文化，毁于江湖规矩，恰好就像一个个体的发育过程中精神修炼，那如何强身健体呢？\n\n大概还有团队建设、目标建设、和时间管理吧。接下来的三章，我们来探讨一下这三个问题。\n\n","source":"_posts/随笔/如何快速融入团队并成为团队核心（三）.md","raw":"---\ntitle:  如何快速融入团队并成为团队核心(三)\ndate: 2020-01-19 8:48\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n# 一  引子\n如何快速融入团队，看似是个简单的问题，其实并非如此。\n\n有时取决于你的性格、有时取决于你的机会，有时取决于企业是否拥有开放的心态或那些拥有开放心态的伙伴，还有时取决于企业的愿景、使命和价值观，以及这些因素的综合作用，同时也包括企业与你是否存在基因上的契合，或者企业文化本身，乃至企业的江湖规矩。\n\n# 二  基因\n基因是个奇妙的东西，似乎在吴军老师撰写《浪潮之巅》之前并不怎么引人注目，而随着吴军老师在书中将基因论作为企业能否顺应互联网的浪潮，并取得辉煌成就的关键因素后，就在坊间开始盛行起来。\n\n这个理论最早被美国管理大师Noel Tichy引入的概念，他把企业称为一个具有活力的生命体，来自于资本和劳动力的双螺旋结构，在创始人、机制、技术和文化等环境因素的共同激励下，促使企业以飞快的速度得以成长。\n\n基因看似是很重要的东西，但是也并非每家企业都一定被基因主导。吴军老师也提到了一些公司，从原本看起来不起眼的制造业，转型成为更加具有高附加值的创新型企业，公司管理层所具备的高瞻远瞩精神和善于创新、积极拥抱创新的态度，是企业得以长盛不衰的关键因素，他把这种称为转基因。\n\n从我们的角度来说，或许基因是个很远的东西，是对我们产生了某些看不到、客观存在的影响。\n\n例如，阿里巴巴的电商基因，使阿里巴巴人更具有应对风险和危机的意识，并透过企业管理一系列流程体现在公司的文化中。那些有幸加入过阿里巴巴的人，许多人都具有一种独特的气质，这种气质使他能够在困难面前无所畏惧，同时又能更好的适应变化的存在。大概这种气质也正是来源于阿里巴巴企业基因中最核心价值观的投影。\n\n也有人曾经有人说腾讯为何以前面向B端转型一直不太成果，大概是由于腾讯的基因都是游戏或社交基因，而除了主阵地之外的其他领域几乎都毫无建树，就连有幸邀请吴军老师加盟的腾讯地图，也未能在LBS领域获得多大的市场。不过随着腾讯云的兴起，这些局面已经有所改观，但是腾讯在智慧产业方面的布局，是否能够重现其在云端市场的效果，依然值得期待。\n\n企业基因的客观存在，或多或少会在我们的每一段职场经历产生积极或消极的影响。例如从公司获得了高层资源、人脉、解决问题的方法，这些都会对我们的未来产生商业上积极的促进作用。企业基因或多或少影响了职场基因。如果说初入职场的我们的职场基因看起来毫无特色，那么在职场中的不断挑战和历练，已经让我们的职场基因受到了大量的诱因而不断蜕变，从而形成了今天更加完美的个体。   \n\n# 三  文化\n越来越多的人重视企业文化的存在，因为企业文化如饮水、如呼吸般时刻存在，对凝聚集体，形成战斗力，一起共同思考公司的发展方向。优秀的企业文化也是企业得以长盛不衰的驱动力和灵魂。\n\n 企业文化的价值在于唤醒和激发团队的每一位成员对于企业的认同感、使命感和价值感。\n\n 基因与文化的耦合是如此紧密，以至于“基因和文化不可分离地连载一起，任何一个变化都将不可避免地迫使另一个也发生变化”。文化进化能塑造基因组，但也可以说基因对文化也存在必然的影响。\n\n创业公司或者中小公司或许都不重视企业文化的存在，因为企业认为可以依靠员工的自驱力来实现认同感和使命感，甚至也有许多人认为在创业公司谈文化是一种非常奢侈的行为，因为要刻意营造一个企业文化的氛围，往往需要从公司层面做好规划，例如采取绩效激励的策略，鼓励积极乐观正向有利于企业发展的文化，往往也会导致企业中好不容易招到的人才会逐渐流失，进而影响了创业企业的发展。\n\n但随着公司的逐渐增长，等发展到一定规模时，往往再构建一套企业文化体系，同样会带来不小的阵痛期，因为团队已经形成了一定的“江湖规矩”，如果这样的江湖规矩能够与企业文化完美的契合，或许还能平滑的过度，但是如果彼此发生了抵触，那显然会带来巨大的过度成本，有时候甚至会导致团队分崩离析。\n\n有一个经典的管理学理论“湿猴理论”是这么说的：\n\n>把A、B、C、D、E五只饿了极了的猴子关在一个笼子里，笼子上头掉着一串香蕉，正下方是一个箱子，如果猴子要拿香蕉必须爬上箱子。实验人员装了一个自动装置，若是侦测到有猴子要去爬箱子，就会有大水喷向笼子，这五只猴子马上会被淋湿。首先会有猴子想去拿香蕉，马上水喷出来，它们慌忙用手抱住头，当手离开香蕉的时候，水就立即停止喷射。每只猴子都去尝试了，都得到了同样的结果，开始不明白为什么，但后来知道只要去爬箱子拿香蕉，就会有大水喷来。於是猴子们达到一个共识：不要去拿香蕉！因为有水会喷出来！\n> 后来实验人员把其中的一只猴子换掉，换一只新猴子（称为F猴子好了）关到笼子里。这只F猴子看到香蕉，马上想要去拿，结果被其他四只旧猴子揍了一顿。因为其他四只猴子认为新猴子会害他们被水淋到，所以制止这新猴子去拿香蕉。这新猴子尝试了几次，被打的满头包，还是没有拿到香蕉，当然这五只猴子就没有被水喷到。后来实验人员再把一只旧猴子换掉，换另外一只新猴子（称为G猴子好了）关到笼子里，这支G猴子看到香蕉，当然也是马上要去拿，结果也是被其他四只猴子揍了一顿。那只F猴子打的特别用力,G猴子试了几次总是被打的很惨，只好作罢。\n> 后来慢慢的一只一只的，所有的旧猴子都换成新猴子了。大家都不敢去动那香蕉，但是他们都不知道为什么，只知道去动香蕉会被其他猴子扁。这就是“传统”的由来，这个故事被用来介绍企业文化的建立等诸多管理方面有很好的寓意。\n\n企业文化的建立，就像这个理论中所说，如果在早期采取某些措施有意无意的培养，营造更加积极乐观进取的企业文化氛围，并找对契合企业文化的人才，在发展过程中逐渐的对这些文化意识进行增强，实际上将会对企业的快速发展提供巨大的助力。\n\n# 四  江湖规矩\n“有人的地方就有江湖”。\n\nIT公司也同样如此，许多时候往往还没形成企业文化，反而会先形成江湖规矩。而江湖规矩有许多种。\n\n例如某种大哥文化，在公司发展的早期，往往会依托创始人的个人魅力招揽到一批与其情投意合的人，随着公司的发展，却并非每个人都以打造完美的公司为目标，有的早期员工难免加入公司的目的，就是为了早点占好山头，作威作福。于是公司倒是发展好了，但是大哥却成为最难啃的骨头，或是任人唯亲，或是贪污受贿，或是故意把控住某些关键命门，让全公司都必须看他的脸色行事。\n\n例如某种荤段子文化和烟文化，好吧，听某大型互联网公司朋友说的。在他们的某些部门，荤段子文化特别严重，所以加入了公司就得接受公司的规矩，从能听荤段子开始，到能讲荤段子，那就说明你已经被组织熏陶得非常到位了。除此之外，有的部门烟文化特别严重，像极了某些国企部门，依托烟文化来维系人际关系，不得不说依然是中国人获得人脉的不二法门。\n\n譬如游戏文化，鄙人曾经呆过的一家公司就以团队对战游戏Dota进行团队建设当成公司核心企业文化的一部分，于是那些对Dota这种游戏毫无兴趣、或者不愿意在公司玩RPG游戏、或者不喜欢乱糟糟的氛围的人，就很难融入团队中，直到流失。\n\n即便有了企业文化，往往依然有江湖规矩。如果把企业文化理解为宗教中形而上的思想哲学，那江湖规矩就是具体执行层面的道德约束，如果只是口头上宣讲企业文化的正面，而忽略了同样需要改革甚至破除的影响企业良性发展的“丑陋”的江湖规矩，往往体现了公司在执行层面的巨大缺失，也将为公司的发展埋下隐患。\n\n# 五  结语\n软件企业的发展，往往并非一朝一夕的爆发，更是从内功到外功的修炼之路，始于企业基因，成于企业文化，毁于江湖规矩，恰好就像一个个体的发育过程中精神修炼，那如何强身健体呢？\n\n大概还有团队建设、目标建设、和时间管理吧。接下来的三章，我们来探讨一下这三个问题。\n\n","slug":"随笔/如何快速融入团队并成为团队核心（三）","published":1,"updated":"2020-01-19T00:47:39.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt95003ln4vipykxzue1","content":"<h1 id=\"一-引子\"><a href=\"#一-引子\" class=\"headerlink\" title=\"一  引子\"></a>一  引子</h1><p>如何快速融入团队，看似是个简单的问题，其实并非如此。</p>\n<p>有时取决于你的性格、有时取决于你的机会，有时取决于企业是否拥有开放的心态或那些拥有开放心态的伙伴，还有时取决于企业的愿景、使命和价值观，以及这些因素的综合作用，同时也包括企业与你是否存在基因上的契合，或者企业文化本身，乃至企业的江湖规矩。</p>\n<h1 id=\"二-基因\"><a href=\"#二-基因\" class=\"headerlink\" title=\"二  基因\"></a>二  基因</h1><p>基因是个奇妙的东西，似乎在吴军老师撰写《浪潮之巅》之前并不怎么引人注目，而随着吴军老师在书中将基因论作为企业能否顺应互联网的浪潮，并取得辉煌成就的关键因素后，就在坊间开始盛行起来。</p>\n<p>这个理论最早被美国管理大师Noel Tichy引入的概念，他把企业称为一个具有活力的生命体，来自于资本和劳动力的双螺旋结构，在创始人、机制、技术和文化等环境因素的共同激励下，促使企业以飞快的速度得以成长。</p>\n<p>基因看似是很重要的东西，但是也并非每家企业都一定被基因主导。吴军老师也提到了一些公司，从原本看起来不起眼的制造业，转型成为更加具有高附加值的创新型企业，公司管理层所具备的高瞻远瞩精神和善于创新、积极拥抱创新的态度，是企业得以长盛不衰的关键因素，他把这种称为转基因。</p>\n<p>从我们的角度来说，或许基因是个很远的东西，是对我们产生了某些看不到、客观存在的影响。</p>\n<p>例如，阿里巴巴的电商基因，使阿里巴巴人更具有应对风险和危机的意识，并透过企业管理一系列流程体现在公司的文化中。那些有幸加入过阿里巴巴的人，许多人都具有一种独特的气质，这种气质使他能够在困难面前无所畏惧，同时又能更好的适应变化的存在。大概这种气质也正是来源于阿里巴巴企业基因中最核心价值观的投影。</p>\n<p>也有人曾经有人说腾讯为何以前面向B端转型一直不太成果，大概是由于腾讯的基因都是游戏或社交基因，而除了主阵地之外的其他领域几乎都毫无建树，就连有幸邀请吴军老师加盟的腾讯地图，也未能在LBS领域获得多大的市场。不过随着腾讯云的兴起，这些局面已经有所改观，但是腾讯在智慧产业方面的布局，是否能够重现其在云端市场的效果，依然值得期待。</p>\n<p>企业基因的客观存在，或多或少会在我们的每一段职场经历产生积极或消极的影响。例如从公司获得了高层资源、人脉、解决问题的方法，这些都会对我们的未来产生商业上积极的促进作用。企业基因或多或少影响了职场基因。如果说初入职场的我们的职场基因看起来毫无特色，那么在职场中的不断挑战和历练，已经让我们的职场基因受到了大量的诱因而不断蜕变，从而形成了今天更加完美的个体。   </p>\n<h1 id=\"三-文化\"><a href=\"#三-文化\" class=\"headerlink\" title=\"三  文化\"></a>三  文化</h1><p>越来越多的人重视企业文化的存在，因为企业文化如饮水、如呼吸般时刻存在，对凝聚集体，形成战斗力，一起共同思考公司的发展方向。优秀的企业文化也是企业得以长盛不衰的驱动力和灵魂。</p>\n<p> 企业文化的价值在于唤醒和激发团队的每一位成员对于企业的认同感、使命感和价值感。</p>\n<p> 基因与文化的耦合是如此紧密，以至于“基因和文化不可分离地连载一起，任何一个变化都将不可避免地迫使另一个也发生变化”。文化进化能塑造基因组，但也可以说基因对文化也存在必然的影响。</p>\n<p>创业公司或者中小公司或许都不重视企业文化的存在，因为企业认为可以依靠员工的自驱力来实现认同感和使命感，甚至也有许多人认为在创业公司谈文化是一种非常奢侈的行为，因为要刻意营造一个企业文化的氛围，往往需要从公司层面做好规划，例如采取绩效激励的策略，鼓励积极乐观正向有利于企业发展的文化，往往也会导致企业中好不容易招到的人才会逐渐流失，进而影响了创业企业的发展。</p>\n<p>但随着公司的逐渐增长，等发展到一定规模时，往往再构建一套企业文化体系，同样会带来不小的阵痛期，因为团队已经形成了一定的“江湖规矩”，如果这样的江湖规矩能够与企业文化完美的契合，或许还能平滑的过度，但是如果彼此发生了抵触，那显然会带来巨大的过度成本，有时候甚至会导致团队分崩离析。</p>\n<p>有一个经典的管理学理论“湿猴理论”是这么说的：</p>\n<blockquote>\n<p>把A、B、C、D、E五只饿了极了的猴子关在一个笼子里，笼子上头掉着一串香蕉，正下方是一个箱子，如果猴子要拿香蕉必须爬上箱子。实验人员装了一个自动装置，若是侦测到有猴子要去爬箱子，就会有大水喷向笼子，这五只猴子马上会被淋湿。首先会有猴子想去拿香蕉，马上水喷出来，它们慌忙用手抱住头，当手离开香蕉的时候，水就立即停止喷射。每只猴子都去尝试了，都得到了同样的结果，开始不明白为什么，但后来知道只要去爬箱子拿香蕉，就会有大水喷来。於是猴子们达到一个共识：不要去拿香蕉！因为有水会喷出来！<br>后来实验人员把其中的一只猴子换掉，换一只新猴子（称为F猴子好了）关到笼子里。这只F猴子看到香蕉，马上想要去拿，结果被其他四只旧猴子揍了一顿。因为其他四只猴子认为新猴子会害他们被水淋到，所以制止这新猴子去拿香蕉。这新猴子尝试了几次，被打的满头包，还是没有拿到香蕉，当然这五只猴子就没有被水喷到。后来实验人员再把一只旧猴子换掉，换另外一只新猴子（称为G猴子好了）关到笼子里，这支G猴子看到香蕉，当然也是马上要去拿，结果也是被其他四只猴子揍了一顿。那只F猴子打的特别用力,G猴子试了几次总是被打的很惨，只好作罢。<br>后来慢慢的一只一只的，所有的旧猴子都换成新猴子了。大家都不敢去动那香蕉，但是他们都不知道为什么，只知道去动香蕉会被其他猴子扁。这就是“传统”的由来，这个故事被用来介绍企业文化的建立等诸多管理方面有很好的寓意。</p>\n</blockquote>\n<p>企业文化的建立，就像这个理论中所说，如果在早期采取某些措施有意无意的培养，营造更加积极乐观进取的企业文化氛围，并找对契合企业文化的人才，在发展过程中逐渐的对这些文化意识进行增强，实际上将会对企业的快速发展提供巨大的助力。</p>\n<h1 id=\"四-江湖规矩\"><a href=\"#四-江湖规矩\" class=\"headerlink\" title=\"四  江湖规矩\"></a>四  江湖规矩</h1><p>“有人的地方就有江湖”。</p>\n<p>IT公司也同样如此，许多时候往往还没形成企业文化，反而会先形成江湖规矩。而江湖规矩有许多种。</p>\n<p>例如某种大哥文化，在公司发展的早期，往往会依托创始人的个人魅力招揽到一批与其情投意合的人，随着公司的发展，却并非每个人都以打造完美的公司为目标，有的早期员工难免加入公司的目的，就是为了早点占好山头，作威作福。于是公司倒是发展好了，但是大哥却成为最难啃的骨头，或是任人唯亲，或是贪污受贿，或是故意把控住某些关键命门，让全公司都必须看他的脸色行事。</p>\n<p>例如某种荤段子文化和烟文化，好吧，听某大型互联网公司朋友说的。在他们的某些部门，荤段子文化特别严重，所以加入了公司就得接受公司的规矩，从能听荤段子开始，到能讲荤段子，那就说明你已经被组织熏陶得非常到位了。除此之外，有的部门烟文化特别严重，像极了某些国企部门，依托烟文化来维系人际关系，不得不说依然是中国人获得人脉的不二法门。</p>\n<p>譬如游戏文化，鄙人曾经呆过的一家公司就以团队对战游戏Dota进行团队建设当成公司核心企业文化的一部分，于是那些对Dota这种游戏毫无兴趣、或者不愿意在公司玩RPG游戏、或者不喜欢乱糟糟的氛围的人，就很难融入团队中，直到流失。</p>\n<p>即便有了企业文化，往往依然有江湖规矩。如果把企业文化理解为宗教中形而上的思想哲学，那江湖规矩就是具体执行层面的道德约束，如果只是口头上宣讲企业文化的正面，而忽略了同样需要改革甚至破除的影响企业良性发展的“丑陋”的江湖规矩，往往体现了公司在执行层面的巨大缺失，也将为公司的发展埋下隐患。</p>\n<h1 id=\"五-结语\"><a href=\"#五-结语\" class=\"headerlink\" title=\"五  结语\"></a>五  结语</h1><p>软件企业的发展，往往并非一朝一夕的爆发，更是从内功到外功的修炼之路，始于企业基因，成于企业文化，毁于江湖规矩，恰好就像一个个体的发育过程中精神修炼，那如何强身健体呢？</p>\n<p>大概还有团队建设、目标建设、和时间管理吧。接下来的三章，我们来探讨一下这三个问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一-引子\"><a href=\"#一-引子\" class=\"headerlink\" title=\"一  引子\"></a>一  引子</h1><p>如何快速融入团队，看似是个简单的问题，其实并非如此。</p>\n<p>有时取决于你的性格、有时取决于你的机会，有时取决于企业是否拥有开放的心态或那些拥有开放心态的伙伴，还有时取决于企业的愿景、使命和价值观，以及这些因素的综合作用，同时也包括企业与你是否存在基因上的契合，或者企业文化本身，乃至企业的江湖规矩。</p>\n<h1 id=\"二-基因\"><a href=\"#二-基因\" class=\"headerlink\" title=\"二  基因\"></a>二  基因</h1><p>基因是个奇妙的东西，似乎在吴军老师撰写《浪潮之巅》之前并不怎么引人注目，而随着吴军老师在书中将基因论作为企业能否顺应互联网的浪潮，并取得辉煌成就的关键因素后，就在坊间开始盛行起来。</p>\n<p>这个理论最早被美国管理大师Noel Tichy引入的概念，他把企业称为一个具有活力的生命体，来自于资本和劳动力的双螺旋结构，在创始人、机制、技术和文化等环境因素的共同激励下，促使企业以飞快的速度得以成长。</p>\n<p>基因看似是很重要的东西，但是也并非每家企业都一定被基因主导。吴军老师也提到了一些公司，从原本看起来不起眼的制造业，转型成为更加具有高附加值的创新型企业，公司管理层所具备的高瞻远瞩精神和善于创新、积极拥抱创新的态度，是企业得以长盛不衰的关键因素，他把这种称为转基因。</p>\n<p>从我们的角度来说，或许基因是个很远的东西，是对我们产生了某些看不到、客观存在的影响。</p>\n<p>例如，阿里巴巴的电商基因，使阿里巴巴人更具有应对风险和危机的意识，并透过企业管理一系列流程体现在公司的文化中。那些有幸加入过阿里巴巴的人，许多人都具有一种独特的气质，这种气质使他能够在困难面前无所畏惧，同时又能更好的适应变化的存在。大概这种气质也正是来源于阿里巴巴企业基因中最核心价值观的投影。</p>\n<p>也有人曾经有人说腾讯为何以前面向B端转型一直不太成果，大概是由于腾讯的基因都是游戏或社交基因，而除了主阵地之外的其他领域几乎都毫无建树，就连有幸邀请吴军老师加盟的腾讯地图，也未能在LBS领域获得多大的市场。不过随着腾讯云的兴起，这些局面已经有所改观，但是腾讯在智慧产业方面的布局，是否能够重现其在云端市场的效果，依然值得期待。</p>\n<p>企业基因的客观存在，或多或少会在我们的每一段职场经历产生积极或消极的影响。例如从公司获得了高层资源、人脉、解决问题的方法，这些都会对我们的未来产生商业上积极的促进作用。企业基因或多或少影响了职场基因。如果说初入职场的我们的职场基因看起来毫无特色，那么在职场中的不断挑战和历练，已经让我们的职场基因受到了大量的诱因而不断蜕变，从而形成了今天更加完美的个体。   </p>\n<h1 id=\"三-文化\"><a href=\"#三-文化\" class=\"headerlink\" title=\"三  文化\"></a>三  文化</h1><p>越来越多的人重视企业文化的存在，因为企业文化如饮水、如呼吸般时刻存在，对凝聚集体，形成战斗力，一起共同思考公司的发展方向。优秀的企业文化也是企业得以长盛不衰的驱动力和灵魂。</p>\n<p> 企业文化的价值在于唤醒和激发团队的每一位成员对于企业的认同感、使命感和价值感。</p>\n<p> 基因与文化的耦合是如此紧密，以至于“基因和文化不可分离地连载一起，任何一个变化都将不可避免地迫使另一个也发生变化”。文化进化能塑造基因组，但也可以说基因对文化也存在必然的影响。</p>\n<p>创业公司或者中小公司或许都不重视企业文化的存在，因为企业认为可以依靠员工的自驱力来实现认同感和使命感，甚至也有许多人认为在创业公司谈文化是一种非常奢侈的行为，因为要刻意营造一个企业文化的氛围，往往需要从公司层面做好规划，例如采取绩效激励的策略，鼓励积极乐观正向有利于企业发展的文化，往往也会导致企业中好不容易招到的人才会逐渐流失，进而影响了创业企业的发展。</p>\n<p>但随着公司的逐渐增长，等发展到一定规模时，往往再构建一套企业文化体系，同样会带来不小的阵痛期，因为团队已经形成了一定的“江湖规矩”，如果这样的江湖规矩能够与企业文化完美的契合，或许还能平滑的过度，但是如果彼此发生了抵触，那显然会带来巨大的过度成本，有时候甚至会导致团队分崩离析。</p>\n<p>有一个经典的管理学理论“湿猴理论”是这么说的：</p>\n<blockquote>\n<p>把A、B、C、D、E五只饿了极了的猴子关在一个笼子里，笼子上头掉着一串香蕉，正下方是一个箱子，如果猴子要拿香蕉必须爬上箱子。实验人员装了一个自动装置，若是侦测到有猴子要去爬箱子，就会有大水喷向笼子，这五只猴子马上会被淋湿。首先会有猴子想去拿香蕉，马上水喷出来，它们慌忙用手抱住头，当手离开香蕉的时候，水就立即停止喷射。每只猴子都去尝试了，都得到了同样的结果，开始不明白为什么，但后来知道只要去爬箱子拿香蕉，就会有大水喷来。於是猴子们达到一个共识：不要去拿香蕉！因为有水会喷出来！<br>后来实验人员把其中的一只猴子换掉，换一只新猴子（称为F猴子好了）关到笼子里。这只F猴子看到香蕉，马上想要去拿，结果被其他四只旧猴子揍了一顿。因为其他四只猴子认为新猴子会害他们被水淋到，所以制止这新猴子去拿香蕉。这新猴子尝试了几次，被打的满头包，还是没有拿到香蕉，当然这五只猴子就没有被水喷到。后来实验人员再把一只旧猴子换掉，换另外一只新猴子（称为G猴子好了）关到笼子里，这支G猴子看到香蕉，当然也是马上要去拿，结果也是被其他四只猴子揍了一顿。那只F猴子打的特别用力,G猴子试了几次总是被打的很惨，只好作罢。<br>后来慢慢的一只一只的，所有的旧猴子都换成新猴子了。大家都不敢去动那香蕉，但是他们都不知道为什么，只知道去动香蕉会被其他猴子扁。这就是“传统”的由来，这个故事被用来介绍企业文化的建立等诸多管理方面有很好的寓意。</p>\n</blockquote>\n<p>企业文化的建立，就像这个理论中所说，如果在早期采取某些措施有意无意的培养，营造更加积极乐观进取的企业文化氛围，并找对契合企业文化的人才，在发展过程中逐渐的对这些文化意识进行增强，实际上将会对企业的快速发展提供巨大的助力。</p>\n<h1 id=\"四-江湖规矩\"><a href=\"#四-江湖规矩\" class=\"headerlink\" title=\"四  江湖规矩\"></a>四  江湖规矩</h1><p>“有人的地方就有江湖”。</p>\n<p>IT公司也同样如此，许多时候往往还没形成企业文化，反而会先形成江湖规矩。而江湖规矩有许多种。</p>\n<p>例如某种大哥文化，在公司发展的早期，往往会依托创始人的个人魅力招揽到一批与其情投意合的人，随着公司的发展，却并非每个人都以打造完美的公司为目标，有的早期员工难免加入公司的目的，就是为了早点占好山头，作威作福。于是公司倒是发展好了，但是大哥却成为最难啃的骨头，或是任人唯亲，或是贪污受贿，或是故意把控住某些关键命门，让全公司都必须看他的脸色行事。</p>\n<p>例如某种荤段子文化和烟文化，好吧，听某大型互联网公司朋友说的。在他们的某些部门，荤段子文化特别严重，所以加入了公司就得接受公司的规矩，从能听荤段子开始，到能讲荤段子，那就说明你已经被组织熏陶得非常到位了。除此之外，有的部门烟文化特别严重，像极了某些国企部门，依托烟文化来维系人际关系，不得不说依然是中国人获得人脉的不二法门。</p>\n<p>譬如游戏文化，鄙人曾经呆过的一家公司就以团队对战游戏Dota进行团队建设当成公司核心企业文化的一部分，于是那些对Dota这种游戏毫无兴趣、或者不愿意在公司玩RPG游戏、或者不喜欢乱糟糟的氛围的人，就很难融入团队中，直到流失。</p>\n<p>即便有了企业文化，往往依然有江湖规矩。如果把企业文化理解为宗教中形而上的思想哲学，那江湖规矩就是具体执行层面的道德约束，如果只是口头上宣讲企业文化的正面，而忽略了同样需要改革甚至破除的影响企业良性发展的“丑陋”的江湖规矩，往往体现了公司在执行层面的巨大缺失，也将为公司的发展埋下隐患。</p>\n<h1 id=\"五-结语\"><a href=\"#五-结语\" class=\"headerlink\" title=\"五  结语\"></a>五  结语</h1><p>软件企业的发展，往往并非一朝一夕的爆发，更是从内功到外功的修炼之路，始于企业基因，成于企业文化，毁于江湖规矩，恰好就像一个个体的发育过程中精神修炼，那如何强身健体呢？</p>\n<p>大概还有团队建设、目标建设、和时间管理吧。接下来的三章，我们来探讨一下这三个问题。</p>\n"},{"title":"如何快速融入团队并成为团队核心(九)","date":"2020-03-11T13:22:00.000Z","author":"邹溪源","_content":"不知从何时起，这个系列的文章已经偏离标题越来越远了~\n\n大概，如果要融入团队，其实或许只需做好跟周围同事的关系，几乎已经能够很好的融入了，但是如果要成为团队精英呢？我们难免得多做一些额外的努力，例如，了解价值观、试图融入企业文化，试图提高自己的工作效率，合理的支配自己的时间，尤其还有一点，就是做好目标管理。\n\n# 一、画饼吃不下\n某种意义上讲，决定我们能否成为高效开发者的核心关键是我们对于目标的管理能力，某种意义上讲，一个企业是否能够在群狼环伺的商界混得如鱼得水，中高层管理者是否能够理解和传达老板的意图和目标，基层能否理解老板的目标，并高效的执行，毋庸置疑都是至关重要的环节。\n\n当然，大部分情况我们不用直接理解老板的目标，他们只需按照领导的指示，在自己的职责范围内把事情干好，就足够优秀了。但是事实上有时候我们会更加重视流程本身，往往忽略了对于目标的理解。甚至有时候公司老板喜欢站在更高的层面，画一个很大的饼，结果到具体执行时，给执行工作的人带来的巨大困扰。\n\n“饼太大，吃不下”。一旦老板习惯于画饼，或许他自己也会陷入一个奇怪的状态，他会想，这件事情究竟是干呢，还是不干呢，嗯，我先吹出去，说不定有人会干，而且还能干出什么东西来着。但是作为中高层管理者显然更尴尬，我干了会不会犯错，犯错了会不会打板子，那我还是不干吧？一个长期画饼的老板，底下一定有一群听惯了“狼来了”谎话的中高层，他们已经习惯于对老板夸的海口无动于衷，最终导致了中高层管理者和老板之间的隔阂。\n\n# 二、信息的层层递减\n当然，大部分情况下，中高层管理者都经历离时间和战火的历练，总是能够从老板的一言一行中理解领导的需求，但是即便如此，也容易产生返工的现象。\n\n事实上，我们在工作过程中总是会遇到返工，这种情况发生的根源也同样来源于我们对于目标的误读，甚至曲解了领导对于工作的原意。返工不仅仅会浪费我们的时间，也同样会极大的打击我们对于工作的信心，甚至会让我们对于职场发展的前途产生迷茫。\n\n造成目标识别错误的原因往往是沟通因素，如信息传递漏斗所描述的：\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/9-1.png)\n\n在这个环节中，信息是层层递减的，我们能表达出我们想表达的内容的百分之八十，听众能听到我们想表达信息的百分之六十，而观众所能理解的，只有我们想表达信息的百分之四十。\n\n 除此之外，假设我们的任务来源于其他人的二手信息，那么这种层层递减的边际效应或许也将更加明显。尤其是有时候领导喜欢说话只说一半，并指望下属能够从他的几句话中揣摩出他的全部心意，那这种效果或许自然而然就会更差了。\n\n# 三、目标识别和执行\n所以我们显然不能把期望完全寄托在理解对方的沟通上，而是需要辅以其他手段使得我们能够更好的将领导的需求落实下来。\n\n1、记录：我们需要记录从领导下达的指令的内容，确保在信息传输过程中尽可能的减少误误解。\n\n2、适当的过滤和提取：从信息中，要提取与目标相关的内容，去掉与目标无关的噪声干扰，以便减轻对于目标识别的复杂程度。\n\n3、重聚：从信息中按照任务的相关性，建立必要的链接，并使得目标得以形成体系。\n\n4、反馈：尽早与领导反馈，以便确保自己的目标符合对方的意图，并根据领导的指示对目标进行修正，例如对时间节点进行细化，或者领导是不是已经有了下一步工作安排等等。\n\n我们就识别到了可以执行的具体目标，这样在进行任务执行时，也便于我们对于目标的解读。\n\n基于识别到的目标，我们可以辅以一些管理学的手段，例如运用计划、执行、检查、纠偏的PDCA工具，让我们在执行过程中不断的进行修正，以便使我们能够在任务的每个执行过程中都能建立起反馈的机制，同时有能让领导能够及时的参与其中，使得任务更加完整的符合领导的预期。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/9-2.png)\n\n# 四、结语\n随着互联网企业开始实施基于OKR的管理方法，对大家来说或多或少造成了一些影响，不过显然，建立一个更加完整的目标管理机制，对我们确实会带来一些好处，最起码的少返工就已经是一个不错的进步了。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/9-3.png)\n\n","source":"_posts/随笔/如何快速融入团队并成为团队核心（九）.md","raw":"---\ntitle:  如何快速融入团队并成为团队核心(九)\ndate: 2020-3-11 21:22\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n不知从何时起，这个系列的文章已经偏离标题越来越远了~\n\n大概，如果要融入团队，其实或许只需做好跟周围同事的关系，几乎已经能够很好的融入了，但是如果要成为团队精英呢？我们难免得多做一些额外的努力，例如，了解价值观、试图融入企业文化，试图提高自己的工作效率，合理的支配自己的时间，尤其还有一点，就是做好目标管理。\n\n# 一、画饼吃不下\n某种意义上讲，决定我们能否成为高效开发者的核心关键是我们对于目标的管理能力，某种意义上讲，一个企业是否能够在群狼环伺的商界混得如鱼得水，中高层管理者是否能够理解和传达老板的意图和目标，基层能否理解老板的目标，并高效的执行，毋庸置疑都是至关重要的环节。\n\n当然，大部分情况我们不用直接理解老板的目标，他们只需按照领导的指示，在自己的职责范围内把事情干好，就足够优秀了。但是事实上有时候我们会更加重视流程本身，往往忽略了对于目标的理解。甚至有时候公司老板喜欢站在更高的层面，画一个很大的饼，结果到具体执行时，给执行工作的人带来的巨大困扰。\n\n“饼太大，吃不下”。一旦老板习惯于画饼，或许他自己也会陷入一个奇怪的状态，他会想，这件事情究竟是干呢，还是不干呢，嗯，我先吹出去，说不定有人会干，而且还能干出什么东西来着。但是作为中高层管理者显然更尴尬，我干了会不会犯错，犯错了会不会打板子，那我还是不干吧？一个长期画饼的老板，底下一定有一群听惯了“狼来了”谎话的中高层，他们已经习惯于对老板夸的海口无动于衷，最终导致了中高层管理者和老板之间的隔阂。\n\n# 二、信息的层层递减\n当然，大部分情况下，中高层管理者都经历离时间和战火的历练，总是能够从老板的一言一行中理解领导的需求，但是即便如此，也容易产生返工的现象。\n\n事实上，我们在工作过程中总是会遇到返工，这种情况发生的根源也同样来源于我们对于目标的误读，甚至曲解了领导对于工作的原意。返工不仅仅会浪费我们的时间，也同样会极大的打击我们对于工作的信心，甚至会让我们对于职场发展的前途产生迷茫。\n\n造成目标识别错误的原因往往是沟通因素，如信息传递漏斗所描述的：\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/9-1.png)\n\n在这个环节中，信息是层层递减的，我们能表达出我们想表达的内容的百分之八十，听众能听到我们想表达信息的百分之六十，而观众所能理解的，只有我们想表达信息的百分之四十。\n\n 除此之外，假设我们的任务来源于其他人的二手信息，那么这种层层递减的边际效应或许也将更加明显。尤其是有时候领导喜欢说话只说一半，并指望下属能够从他的几句话中揣摩出他的全部心意，那这种效果或许自然而然就会更差了。\n\n# 三、目标识别和执行\n所以我们显然不能把期望完全寄托在理解对方的沟通上，而是需要辅以其他手段使得我们能够更好的将领导的需求落实下来。\n\n1、记录：我们需要记录从领导下达的指令的内容，确保在信息传输过程中尽可能的减少误误解。\n\n2、适当的过滤和提取：从信息中，要提取与目标相关的内容，去掉与目标无关的噪声干扰，以便减轻对于目标识别的复杂程度。\n\n3、重聚：从信息中按照任务的相关性，建立必要的链接，并使得目标得以形成体系。\n\n4、反馈：尽早与领导反馈，以便确保自己的目标符合对方的意图，并根据领导的指示对目标进行修正，例如对时间节点进行细化，或者领导是不是已经有了下一步工作安排等等。\n\n我们就识别到了可以执行的具体目标，这样在进行任务执行时，也便于我们对于目标的解读。\n\n基于识别到的目标，我们可以辅以一些管理学的手段，例如运用计划、执行、检查、纠偏的PDCA工具，让我们在执行过程中不断的进行修正，以便使我们能够在任务的每个执行过程中都能建立起反馈的机制，同时有能让领导能够及时的参与其中，使得任务更加完整的符合领导的预期。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/9-2.png)\n\n# 四、结语\n随着互联网企业开始实施基于OKR的管理方法，对大家来说或多或少造成了一些影响，不过显然，建立一个更加完整的目标管理机制，对我们确实会带来一些好处，最起码的少返工就已经是一个不错的进步了。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/9-3.png)\n\n","slug":"随笔/如何快速融入团队并成为团队核心（九）","published":1,"updated":"2020-03-12T00:43:53.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt97003on4vi3c32da6i","content":"<p>不知从何时起，这个系列的文章已经偏离标题越来越远了~</p>\n<p>大概，如果要融入团队，其实或许只需做好跟周围同事的关系，几乎已经能够很好的融入了，但是如果要成为团队精英呢？我们难免得多做一些额外的努力，例如，了解价值观、试图融入企业文化，试图提高自己的工作效率，合理的支配自己的时间，尤其还有一点，就是做好目标管理。</p>\n<h1 id=\"一、画饼吃不下\"><a href=\"#一、画饼吃不下\" class=\"headerlink\" title=\"一、画饼吃不下\"></a>一、画饼吃不下</h1><p>某种意义上讲，决定我们能否成为高效开发者的核心关键是我们对于目标的管理能力，某种意义上讲，一个企业是否能够在群狼环伺的商界混得如鱼得水，中高层管理者是否能够理解和传达老板的意图和目标，基层能否理解老板的目标，并高效的执行，毋庸置疑都是至关重要的环节。</p>\n<p>当然，大部分情况我们不用直接理解老板的目标，他们只需按照领导的指示，在自己的职责范围内把事情干好，就足够优秀了。但是事实上有时候我们会更加重视流程本身，往往忽略了对于目标的理解。甚至有时候公司老板喜欢站在更高的层面，画一个很大的饼，结果到具体执行时，给执行工作的人带来的巨大困扰。</p>\n<p>“饼太大，吃不下”。一旦老板习惯于画饼，或许他自己也会陷入一个奇怪的状态，他会想，这件事情究竟是干呢，还是不干呢，嗯，我先吹出去，说不定有人会干，而且还能干出什么东西来着。但是作为中高层管理者显然更尴尬，我干了会不会犯错，犯错了会不会打板子，那我还是不干吧？一个长期画饼的老板，底下一定有一群听惯了“狼来了”谎话的中高层，他们已经习惯于对老板夸的海口无动于衷，最终导致了中高层管理者和老板之间的隔阂。</p>\n<h1 id=\"二、信息的层层递减\"><a href=\"#二、信息的层层递减\" class=\"headerlink\" title=\"二、信息的层层递减\"></a>二、信息的层层递减</h1><p>当然，大部分情况下，中高层管理者都经历离时间和战火的历练，总是能够从老板的一言一行中理解领导的需求，但是即便如此，也容易产生返工的现象。</p>\n<p>事实上，我们在工作过程中总是会遇到返工，这种情况发生的根源也同样来源于我们对于目标的误读，甚至曲解了领导对于工作的原意。返工不仅仅会浪费我们的时间，也同样会极大的打击我们对于工作的信心，甚至会让我们对于职场发展的前途产生迷茫。</p>\n<p>造成目标识别错误的原因往往是沟通因素，如信息传递漏斗所描述的：</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/9-1.png\" alt=\"图片\"></p>\n<p>在这个环节中，信息是层层递减的，我们能表达出我们想表达的内容的百分之八十，听众能听到我们想表达信息的百分之六十，而观众所能理解的，只有我们想表达信息的百分之四十。</p>\n<p> 除此之外，假设我们的任务来源于其他人的二手信息，那么这种层层递减的边际效应或许也将更加明显。尤其是有时候领导喜欢说话只说一半，并指望下属能够从他的几句话中揣摩出他的全部心意，那这种效果或许自然而然就会更差了。</p>\n<h1 id=\"三、目标识别和执行\"><a href=\"#三、目标识别和执行\" class=\"headerlink\" title=\"三、目标识别和执行\"></a>三、目标识别和执行</h1><p>所以我们显然不能把期望完全寄托在理解对方的沟通上，而是需要辅以其他手段使得我们能够更好的将领导的需求落实下来。</p>\n<p>1、记录：我们需要记录从领导下达的指令的内容，确保在信息传输过程中尽可能的减少误误解。</p>\n<p>2、适当的过滤和提取：从信息中，要提取与目标相关的内容，去掉与目标无关的噪声干扰，以便减轻对于目标识别的复杂程度。</p>\n<p>3、重聚：从信息中按照任务的相关性，建立必要的链接，并使得目标得以形成体系。</p>\n<p>4、反馈：尽早与领导反馈，以便确保自己的目标符合对方的意图，并根据领导的指示对目标进行修正，例如对时间节点进行细化，或者领导是不是已经有了下一步工作安排等等。</p>\n<p>我们就识别到了可以执行的具体目标，这样在进行任务执行时，也便于我们对于目标的解读。</p>\n<p>基于识别到的目标，我们可以辅以一些管理学的手段，例如运用计划、执行、检查、纠偏的PDCA工具，让我们在执行过程中不断的进行修正，以便使我们能够在任务的每个执行过程中都能建立起反馈的机制，同时有能让领导能够及时的参与其中，使得任务更加完整的符合领导的预期。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/9-2.png\" alt=\"图片\"></p>\n<h1 id=\"四、结语\"><a href=\"#四、结语\" class=\"headerlink\" title=\"四、结语\"></a>四、结语</h1><p>随着互联网企业开始实施基于OKR的管理方法，对大家来说或多或少造成了一些影响，不过显然，建立一个更加完整的目标管理机制，对我们确实会带来一些好处，最起码的少返工就已经是一个不错的进步了。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/9-3.png\" alt=\"图片\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>不知从何时起，这个系列的文章已经偏离标题越来越远了~</p>\n<p>大概，如果要融入团队，其实或许只需做好跟周围同事的关系，几乎已经能够很好的融入了，但是如果要成为团队精英呢？我们难免得多做一些额外的努力，例如，了解价值观、试图融入企业文化，试图提高自己的工作效率，合理的支配自己的时间，尤其还有一点，就是做好目标管理。</p>\n<h1 id=\"一、画饼吃不下\"><a href=\"#一、画饼吃不下\" class=\"headerlink\" title=\"一、画饼吃不下\"></a>一、画饼吃不下</h1><p>某种意义上讲，决定我们能否成为高效开发者的核心关键是我们对于目标的管理能力，某种意义上讲，一个企业是否能够在群狼环伺的商界混得如鱼得水，中高层管理者是否能够理解和传达老板的意图和目标，基层能否理解老板的目标，并高效的执行，毋庸置疑都是至关重要的环节。</p>\n<p>当然，大部分情况我们不用直接理解老板的目标，他们只需按照领导的指示，在自己的职责范围内把事情干好，就足够优秀了。但是事实上有时候我们会更加重视流程本身，往往忽略了对于目标的理解。甚至有时候公司老板喜欢站在更高的层面，画一个很大的饼，结果到具体执行时，给执行工作的人带来的巨大困扰。</p>\n<p>“饼太大，吃不下”。一旦老板习惯于画饼，或许他自己也会陷入一个奇怪的状态，他会想，这件事情究竟是干呢，还是不干呢，嗯，我先吹出去，说不定有人会干，而且还能干出什么东西来着。但是作为中高层管理者显然更尴尬，我干了会不会犯错，犯错了会不会打板子，那我还是不干吧？一个长期画饼的老板，底下一定有一群听惯了“狼来了”谎话的中高层，他们已经习惯于对老板夸的海口无动于衷，最终导致了中高层管理者和老板之间的隔阂。</p>\n<h1 id=\"二、信息的层层递减\"><a href=\"#二、信息的层层递减\" class=\"headerlink\" title=\"二、信息的层层递减\"></a>二、信息的层层递减</h1><p>当然，大部分情况下，中高层管理者都经历离时间和战火的历练，总是能够从老板的一言一行中理解领导的需求，但是即便如此，也容易产生返工的现象。</p>\n<p>事实上，我们在工作过程中总是会遇到返工，这种情况发生的根源也同样来源于我们对于目标的误读，甚至曲解了领导对于工作的原意。返工不仅仅会浪费我们的时间，也同样会极大的打击我们对于工作的信心，甚至会让我们对于职场发展的前途产生迷茫。</p>\n<p>造成目标识别错误的原因往往是沟通因素，如信息传递漏斗所描述的：</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/9-1.png\" alt=\"图片\"></p>\n<p>在这个环节中，信息是层层递减的，我们能表达出我们想表达的内容的百分之八十，听众能听到我们想表达信息的百分之六十，而观众所能理解的，只有我们想表达信息的百分之四十。</p>\n<p> 除此之外，假设我们的任务来源于其他人的二手信息，那么这种层层递减的边际效应或许也将更加明显。尤其是有时候领导喜欢说话只说一半，并指望下属能够从他的几句话中揣摩出他的全部心意，那这种效果或许自然而然就会更差了。</p>\n<h1 id=\"三、目标识别和执行\"><a href=\"#三、目标识别和执行\" class=\"headerlink\" title=\"三、目标识别和执行\"></a>三、目标识别和执行</h1><p>所以我们显然不能把期望完全寄托在理解对方的沟通上，而是需要辅以其他手段使得我们能够更好的将领导的需求落实下来。</p>\n<p>1、记录：我们需要记录从领导下达的指令的内容，确保在信息传输过程中尽可能的减少误误解。</p>\n<p>2、适当的过滤和提取：从信息中，要提取与目标相关的内容，去掉与目标无关的噪声干扰，以便减轻对于目标识别的复杂程度。</p>\n<p>3、重聚：从信息中按照任务的相关性，建立必要的链接，并使得目标得以形成体系。</p>\n<p>4、反馈：尽早与领导反馈，以便确保自己的目标符合对方的意图，并根据领导的指示对目标进行修正，例如对时间节点进行细化，或者领导是不是已经有了下一步工作安排等等。</p>\n<p>我们就识别到了可以执行的具体目标，这样在进行任务执行时，也便于我们对于目标的解读。</p>\n<p>基于识别到的目标，我们可以辅以一些管理学的手段，例如运用计划、执行、检查、纠偏的PDCA工具，让我们在执行过程中不断的进行修正，以便使我们能够在任务的每个执行过程中都能建立起反馈的机制，同时有能让领导能够及时的参与其中，使得任务更加完整的符合领导的预期。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/9-2.png\" alt=\"图片\"></p>\n<h1 id=\"四、结语\"><a href=\"#四、结语\" class=\"headerlink\" title=\"四、结语\"></a>四、结语</h1><p>随着互联网企业开始实施基于OKR的管理方法，对大家来说或多或少造成了一些影响，不过显然，建立一个更加完整的目标管理机制，对我们确实会带来一些好处，最起码的少返工就已经是一个不错的进步了。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/9-3.png\" alt=\"图片\"></p>\n"},{"title":"如何快速融入团队并成为团队核心(二)？","date":"2020-01-19T00:42:00.000Z","author":"邹溪源","_content":"# 一\n事实上我们总是会认为那些所谓外向的人更容易融入集体，其实这是一个悖论。\n\n对于大多数人来说，其实都是一样的，当来到新集体时，总会感觉到莫名其妙的局促不安，这其中至少有50%的人内心的念头大概都有过这样的念头：\n\n>我TM到底能不能在这里干满试用期？这公司这样，我要不要把上家公司的离职报告拿回来？我该如何描述在这里的这几天工作呢？要不要写在简历上？听人说少于3个月的经历尽量不要写，那我还是不写吧。我从这里走了，还得继续找工作啊，要不要干脆在这里干下去，过了年再说吧，反正来都来了。\n\n中国人最善于安慰自己，所以一旦想到了“来都来了”这样的道理，那估计铁定一时半会是不会走了，然后就开始逐渐的被公司的体制一点点感化，最终彻底融入其中，成为公司必不可少的一部分。\n\n必须承认，当我们来到一家公司时，也是怀揣着梦想而来，并期待能在这里干一番大事业的，因此当来到公司的那么一瞬间，或许还激情澎湃，但是当遇到一些阻塞，例如要解决一些问题时，由于各方面的阻塞；有时想获得一些支持时，无人理睬，于是让我们或多或少产生了一些困扰。其实哪怕我们内心知道到每家公司往往都需要经历这样一番阶段，但实际上对于这些依然不太愿意接受，更有甚者会感觉有点迷茫，觉得这样的公司层级森严，沟通困难，迟早得倒闭。\n\n不过有时候得承认，这样的公司并不在少数，我们身边几乎每个人或许都经历过，有些人贸然来到这样的团体时，甚至会无法接受，然后突然就离开了，于是给公司的人留下了非常尴尬的印象。\n\n当然，有时候会与是否匹配相应的岗位、公司硬件条件有一定的关系，也有的时候，确实是主观上觉得无法适应这样的工作氛围，进而离开。\n\n# 二\n在生物学中有一个概念叫做“协同进化”，讲的是相互作用的物种在进化过程中互相适应的进化，例如，看似是人类选择了养猫作为宠物，有没有感觉人类也在成为家猫的宠物？毕竟野生的猫肯定没有家猫挑剔，这不既然已经成为了宠物，那还不是得作弄主人，谁让你们觉得猫可爱呢。\n\n![图片](https://uploader.shimo.im/f/hxrd4HekA603eiq2.png!thumbnail)\n\n其实加入公司的每一位开发者，看似是在适应公司的环境，难道不也是在协同进化么。我们用自己的劳动力换取了自己的那份收入，同时也在用自己的某些特征在逐渐影响周围的人，甚至有时候会对公司层面更大范围的集体意识产生了影响，而有的特别具有优秀者气质的人，也自然而然在这个过程中实现了个人能力的极大提升，并为他们未来人生发展奠定了坚实的基础。\n\n曾经见到过许多人，他们年轻时是充满了斗志、意气风发、能力和才华都非常的引人瞩目，跟我一样，也寓居小城长沙，但是这样的小城市确实很难找到优秀的企业，于是迫于无奈或者是主动选择的加入了那些一些老态龙钟的企业，在开始还感觉挺不错的，但是后来也逐渐的被企业熏陶，然后被工作强奸。还有一些人却始终充满斗志，他们用自己的某些特质感染了周围许多人，并使得公司取得了辉煌的成就，自身也获得了很大的成果。\n\n是什么让他们或是沉沦，或是进取呢。\n\n大概是那三个关键性的东西在默默的发挥着关键的作用吧。\n\n# 三\n“使命”、“愿景”、“价值观”。\n\n有时候我们不愿意相信这些东西，以为这些东西是老板用于洗脑的鬼话，甚至有时候公司还会刻意请一些外来的咨询公司来进行所谓的企业文化培训，这些总是会让大家反感。大家都是经历过思想政治课教育出来的优秀人才，别跟我整这些花里胡哨的东西，我们就想搞点实在的。![图片](https://uploader.shimo.im/f/99trMyS35RQNCvUr.png!thumbnail)\n\n但是有时候还真得承认，使命、愿景、价值观真的是让大家得以团聚，能把事情干好的必要条件啊。\n\n使命，通俗的理解就是公司正在做的事。我做的事情是否属于公司正在做的事、是否属于公司的主航道？有时候每当我们接到一个任务时，总是会产生这样或那样的疑惑。如果是符合公司使命的任务，我们干起来或许会斗志昂扬，而不属于公司使命的任务，难免会有点气氛消沉，甚至充满的负能量。\n\n愿景，就是公司想实现的目标。公司干这个事，是真的想做这件事，该不是玩票的吧？公司干这个事，想实现什么目标？我能从这个目标中获得哪些收获？愿景会让人对未来充满想象和希望，而一个人充满了希望，他就愿意为了实现目标付出更多的努力。\n\n价值观，是完成任务过程中会采取的方法论或指导原则。在《华为方法论》中提到，你可以不喝酒，但是不能喝假酒。讲的是有一个分公司的人，为了跟客户打成一片，就在餐桌上喝酒，但是他身体不好，不能喝那么多酒，所以他在酒里面掺了水，然后被人举报，公司严肃的批评了他这种行为，并指出“如果身体不好，要么就别喝酒，喝假酒就是错的”。具体而言，当我们要实现某个东西时，不同的人有不同的方法。\n\n例如要搞定某个客户，我们可以把方案做得特别炫、功能做得特别完美，我们也有人会选择采取特殊的手段（例如PY交易），这样会让那些不认同这种价值观的人反感。\n\n又例如，我们搭建了一个架构，费了很长的时间，然后突然有一个人空降过来，把所有的成绩都归功于自己的功劳，而且还升官发财，而其他人则累死累活，这样的价值观简直恶毒。如果这样的人最终留下来，也意味着所有与他价值观不符的人，要么接受他的价值观或甚至被带下水，要么选择离开。\n\n# 四\n一群拥有相同的使命、愿景和价值观的人，一起为了一个共同的目标而奋斗，其所能产生的动力往往是最大的。在2020年的今天，要把事情干好，并不取决于你的技术水平或知识领域，而是取决于公司能否聚齐这一群人。\n\n同样，当你来到一个团队时，你得衡量的并不仅仅只是团队间的沟通形式，有时候融入团队确实需要时间，但一旦你能够真正融入其中，你将获得自身难以体会的宝贵财富。\n\n下一篇，我想跟大家探讨一下，基因、企业文化、江湖规矩。\n\n","source":"_posts/随笔/如何快速融入团队并成为团队核心（二）.md","raw":"---\ntitle:  如何快速融入团队并成为团队核心(二)？\ndate: 2020-01-19 8:42\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n# 一\n事实上我们总是会认为那些所谓外向的人更容易融入集体，其实这是一个悖论。\n\n对于大多数人来说，其实都是一样的，当来到新集体时，总会感觉到莫名其妙的局促不安，这其中至少有50%的人内心的念头大概都有过这样的念头：\n\n>我TM到底能不能在这里干满试用期？这公司这样，我要不要把上家公司的离职报告拿回来？我该如何描述在这里的这几天工作呢？要不要写在简历上？听人说少于3个月的经历尽量不要写，那我还是不写吧。我从这里走了，还得继续找工作啊，要不要干脆在这里干下去，过了年再说吧，反正来都来了。\n\n中国人最善于安慰自己，所以一旦想到了“来都来了”这样的道理，那估计铁定一时半会是不会走了，然后就开始逐渐的被公司的体制一点点感化，最终彻底融入其中，成为公司必不可少的一部分。\n\n必须承认，当我们来到一家公司时，也是怀揣着梦想而来，并期待能在这里干一番大事业的，因此当来到公司的那么一瞬间，或许还激情澎湃，但是当遇到一些阻塞，例如要解决一些问题时，由于各方面的阻塞；有时想获得一些支持时，无人理睬，于是让我们或多或少产生了一些困扰。其实哪怕我们内心知道到每家公司往往都需要经历这样一番阶段，但实际上对于这些依然不太愿意接受，更有甚者会感觉有点迷茫，觉得这样的公司层级森严，沟通困难，迟早得倒闭。\n\n不过有时候得承认，这样的公司并不在少数，我们身边几乎每个人或许都经历过，有些人贸然来到这样的团体时，甚至会无法接受，然后突然就离开了，于是给公司的人留下了非常尴尬的印象。\n\n当然，有时候会与是否匹配相应的岗位、公司硬件条件有一定的关系，也有的时候，确实是主观上觉得无法适应这样的工作氛围，进而离开。\n\n# 二\n在生物学中有一个概念叫做“协同进化”，讲的是相互作用的物种在进化过程中互相适应的进化，例如，看似是人类选择了养猫作为宠物，有没有感觉人类也在成为家猫的宠物？毕竟野生的猫肯定没有家猫挑剔，这不既然已经成为了宠物，那还不是得作弄主人，谁让你们觉得猫可爱呢。\n\n![图片](https://uploader.shimo.im/f/hxrd4HekA603eiq2.png!thumbnail)\n\n其实加入公司的每一位开发者，看似是在适应公司的环境，难道不也是在协同进化么。我们用自己的劳动力换取了自己的那份收入，同时也在用自己的某些特征在逐渐影响周围的人，甚至有时候会对公司层面更大范围的集体意识产生了影响，而有的特别具有优秀者气质的人，也自然而然在这个过程中实现了个人能力的极大提升，并为他们未来人生发展奠定了坚实的基础。\n\n曾经见到过许多人，他们年轻时是充满了斗志、意气风发、能力和才华都非常的引人瞩目，跟我一样，也寓居小城长沙，但是这样的小城市确实很难找到优秀的企业，于是迫于无奈或者是主动选择的加入了那些一些老态龙钟的企业，在开始还感觉挺不错的，但是后来也逐渐的被企业熏陶，然后被工作强奸。还有一些人却始终充满斗志，他们用自己的某些特质感染了周围许多人，并使得公司取得了辉煌的成就，自身也获得了很大的成果。\n\n是什么让他们或是沉沦，或是进取呢。\n\n大概是那三个关键性的东西在默默的发挥着关键的作用吧。\n\n# 三\n“使命”、“愿景”、“价值观”。\n\n有时候我们不愿意相信这些东西，以为这些东西是老板用于洗脑的鬼话，甚至有时候公司还会刻意请一些外来的咨询公司来进行所谓的企业文化培训，这些总是会让大家反感。大家都是经历过思想政治课教育出来的优秀人才，别跟我整这些花里胡哨的东西，我们就想搞点实在的。![图片](https://uploader.shimo.im/f/99trMyS35RQNCvUr.png!thumbnail)\n\n但是有时候还真得承认，使命、愿景、价值观真的是让大家得以团聚，能把事情干好的必要条件啊。\n\n使命，通俗的理解就是公司正在做的事。我做的事情是否属于公司正在做的事、是否属于公司的主航道？有时候每当我们接到一个任务时，总是会产生这样或那样的疑惑。如果是符合公司使命的任务，我们干起来或许会斗志昂扬，而不属于公司使命的任务，难免会有点气氛消沉，甚至充满的负能量。\n\n愿景，就是公司想实现的目标。公司干这个事，是真的想做这件事，该不是玩票的吧？公司干这个事，想实现什么目标？我能从这个目标中获得哪些收获？愿景会让人对未来充满想象和希望，而一个人充满了希望，他就愿意为了实现目标付出更多的努力。\n\n价值观，是完成任务过程中会采取的方法论或指导原则。在《华为方法论》中提到，你可以不喝酒，但是不能喝假酒。讲的是有一个分公司的人，为了跟客户打成一片，就在餐桌上喝酒，但是他身体不好，不能喝那么多酒，所以他在酒里面掺了水，然后被人举报，公司严肃的批评了他这种行为，并指出“如果身体不好，要么就别喝酒，喝假酒就是错的”。具体而言，当我们要实现某个东西时，不同的人有不同的方法。\n\n例如要搞定某个客户，我们可以把方案做得特别炫、功能做得特别完美，我们也有人会选择采取特殊的手段（例如PY交易），这样会让那些不认同这种价值观的人反感。\n\n又例如，我们搭建了一个架构，费了很长的时间，然后突然有一个人空降过来，把所有的成绩都归功于自己的功劳，而且还升官发财，而其他人则累死累活，这样的价值观简直恶毒。如果这样的人最终留下来，也意味着所有与他价值观不符的人，要么接受他的价值观或甚至被带下水，要么选择离开。\n\n# 四\n一群拥有相同的使命、愿景和价值观的人，一起为了一个共同的目标而奋斗，其所能产生的动力往往是最大的。在2020年的今天，要把事情干好，并不取决于你的技术水平或知识领域，而是取决于公司能否聚齐这一群人。\n\n同样，当你来到一个团队时，你得衡量的并不仅仅只是团队间的沟通形式，有时候融入团队确实需要时间，但一旦你能够真正融入其中，你将获得自身难以体会的宝贵财富。\n\n下一篇，我想跟大家探讨一下，基因、企业文化、江湖规矩。\n\n","slug":"随笔/如何快速融入团队并成为团队核心（二）","published":1,"updated":"2020-01-19T00:42:34.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt98003rn4vipii5dnmi","content":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>事实上我们总是会认为那些所谓外向的人更容易融入集体，其实这是一个悖论。</p>\n<p>对于大多数人来说，其实都是一样的，当来到新集体时，总会感觉到莫名其妙的局促不安，这其中至少有50%的人内心的念头大概都有过这样的念头：</p>\n<blockquote>\n<p>我TM到底能不能在这里干满试用期？这公司这样，我要不要把上家公司的离职报告拿回来？我该如何描述在这里的这几天工作呢？要不要写在简历上？听人说少于3个月的经历尽量不要写，那我还是不写吧。我从这里走了，还得继续找工作啊，要不要干脆在这里干下去，过了年再说吧，反正来都来了。</p>\n</blockquote>\n<p>中国人最善于安慰自己，所以一旦想到了“来都来了”这样的道理，那估计铁定一时半会是不会走了，然后就开始逐渐的被公司的体制一点点感化，最终彻底融入其中，成为公司必不可少的一部分。</p>\n<p>必须承认，当我们来到一家公司时，也是怀揣着梦想而来，并期待能在这里干一番大事业的，因此当来到公司的那么一瞬间，或许还激情澎湃，但是当遇到一些阻塞，例如要解决一些问题时，由于各方面的阻塞；有时想获得一些支持时，无人理睬，于是让我们或多或少产生了一些困扰。其实哪怕我们内心知道到每家公司往往都需要经历这样一番阶段，但实际上对于这些依然不太愿意接受，更有甚者会感觉有点迷茫，觉得这样的公司层级森严，沟通困难，迟早得倒闭。</p>\n<p>不过有时候得承认，这样的公司并不在少数，我们身边几乎每个人或许都经历过，有些人贸然来到这样的团体时，甚至会无法接受，然后突然就离开了，于是给公司的人留下了非常尴尬的印象。</p>\n<p>当然，有时候会与是否匹配相应的岗位、公司硬件条件有一定的关系，也有的时候，确实是主观上觉得无法适应这样的工作氛围，进而离开。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>在生物学中有一个概念叫做“协同进化”，讲的是相互作用的物种在进化过程中互相适应的进化，例如，看似是人类选择了养猫作为宠物，有没有感觉人类也在成为家猫的宠物？毕竟野生的猫肯定没有家猫挑剔，这不既然已经成为了宠物，那还不是得作弄主人，谁让你们觉得猫可爱呢。</p>\n<p><img src=\"https://uploader.shimo.im/f/hxrd4HekA603eiq2.png!thumbnail\" alt=\"图片\"></p>\n<p>其实加入公司的每一位开发者，看似是在适应公司的环境，难道不也是在协同进化么。我们用自己的劳动力换取了自己的那份收入，同时也在用自己的某些特征在逐渐影响周围的人，甚至有时候会对公司层面更大范围的集体意识产生了影响，而有的特别具有优秀者气质的人，也自然而然在这个过程中实现了个人能力的极大提升，并为他们未来人生发展奠定了坚实的基础。</p>\n<p>曾经见到过许多人，他们年轻时是充满了斗志、意气风发、能力和才华都非常的引人瞩目，跟我一样，也寓居小城长沙，但是这样的小城市确实很难找到优秀的企业，于是迫于无奈或者是主动选择的加入了那些一些老态龙钟的企业，在开始还感觉挺不错的，但是后来也逐渐的被企业熏陶，然后被工作强奸。还有一些人却始终充满斗志，他们用自己的某些特质感染了周围许多人，并使得公司取得了辉煌的成就，自身也获得了很大的成果。</p>\n<p>是什么让他们或是沉沦，或是进取呢。</p>\n<p>大概是那三个关键性的东西在默默的发挥着关键的作用吧。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>“使命”、“愿景”、“价值观”。</p>\n<p>有时候我们不愿意相信这些东西，以为这些东西是老板用于洗脑的鬼话，甚至有时候公司还会刻意请一些外来的咨询公司来进行所谓的企业文化培训，这些总是会让大家反感。大家都是经历过思想政治课教育出来的优秀人才，别跟我整这些花里胡哨的东西，我们就想搞点实在的。<img src=\"https://uploader.shimo.im/f/99trMyS35RQNCvUr.png!thumbnail\" alt=\"图片\"></p>\n<p>但是有时候还真得承认，使命、愿景、价值观真的是让大家得以团聚，能把事情干好的必要条件啊。</p>\n<p>使命，通俗的理解就是公司正在做的事。我做的事情是否属于公司正在做的事、是否属于公司的主航道？有时候每当我们接到一个任务时，总是会产生这样或那样的疑惑。如果是符合公司使命的任务，我们干起来或许会斗志昂扬，而不属于公司使命的任务，难免会有点气氛消沉，甚至充满的负能量。</p>\n<p>愿景，就是公司想实现的目标。公司干这个事，是真的想做这件事，该不是玩票的吧？公司干这个事，想实现什么目标？我能从这个目标中获得哪些收获？愿景会让人对未来充满想象和希望，而一个人充满了希望，他就愿意为了实现目标付出更多的努力。</p>\n<p>价值观，是完成任务过程中会采取的方法论或指导原则。在《华为方法论》中提到，你可以不喝酒，但是不能喝假酒。讲的是有一个分公司的人，为了跟客户打成一片，就在餐桌上喝酒，但是他身体不好，不能喝那么多酒，所以他在酒里面掺了水，然后被人举报，公司严肃的批评了他这种行为，并指出“如果身体不好，要么就别喝酒，喝假酒就是错的”。具体而言，当我们要实现某个东西时，不同的人有不同的方法。</p>\n<p>例如要搞定某个客户，我们可以把方案做得特别炫、功能做得特别完美，我们也有人会选择采取特殊的手段（例如PY交易），这样会让那些不认同这种价值观的人反感。</p>\n<p>又例如，我们搭建了一个架构，费了很长的时间，然后突然有一个人空降过来，把所有的成绩都归功于自己的功劳，而且还升官发财，而其他人则累死累活，这样的价值观简直恶毒。如果这样的人最终留下来，也意味着所有与他价值观不符的人，要么接受他的价值观或甚至被带下水，要么选择离开。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>一群拥有相同的使命、愿景和价值观的人，一起为了一个共同的目标而奋斗，其所能产生的动力往往是最大的。在2020年的今天，要把事情干好，并不取决于你的技术水平或知识领域，而是取决于公司能否聚齐这一群人。</p>\n<p>同样，当你来到一个团队时，你得衡量的并不仅仅只是团队间的沟通形式，有时候融入团队确实需要时间，但一旦你能够真正融入其中，你将获得自身难以体会的宝贵财富。</p>\n<p>下一篇，我想跟大家探讨一下，基因、企业文化、江湖规矩。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>事实上我们总是会认为那些所谓外向的人更容易融入集体，其实这是一个悖论。</p>\n<p>对于大多数人来说，其实都是一样的，当来到新集体时，总会感觉到莫名其妙的局促不安，这其中至少有50%的人内心的念头大概都有过这样的念头：</p>\n<blockquote>\n<p>我TM到底能不能在这里干满试用期？这公司这样，我要不要把上家公司的离职报告拿回来？我该如何描述在这里的这几天工作呢？要不要写在简历上？听人说少于3个月的经历尽量不要写，那我还是不写吧。我从这里走了，还得继续找工作啊，要不要干脆在这里干下去，过了年再说吧，反正来都来了。</p>\n</blockquote>\n<p>中国人最善于安慰自己，所以一旦想到了“来都来了”这样的道理，那估计铁定一时半会是不会走了，然后就开始逐渐的被公司的体制一点点感化，最终彻底融入其中，成为公司必不可少的一部分。</p>\n<p>必须承认，当我们来到一家公司时，也是怀揣着梦想而来，并期待能在这里干一番大事业的，因此当来到公司的那么一瞬间，或许还激情澎湃，但是当遇到一些阻塞，例如要解决一些问题时，由于各方面的阻塞；有时想获得一些支持时，无人理睬，于是让我们或多或少产生了一些困扰。其实哪怕我们内心知道到每家公司往往都需要经历这样一番阶段，但实际上对于这些依然不太愿意接受，更有甚者会感觉有点迷茫，觉得这样的公司层级森严，沟通困难，迟早得倒闭。</p>\n<p>不过有时候得承认，这样的公司并不在少数，我们身边几乎每个人或许都经历过，有些人贸然来到这样的团体时，甚至会无法接受，然后突然就离开了，于是给公司的人留下了非常尴尬的印象。</p>\n<p>当然，有时候会与是否匹配相应的岗位、公司硬件条件有一定的关系，也有的时候，确实是主观上觉得无法适应这样的工作氛围，进而离开。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>在生物学中有一个概念叫做“协同进化”，讲的是相互作用的物种在进化过程中互相适应的进化，例如，看似是人类选择了养猫作为宠物，有没有感觉人类也在成为家猫的宠物？毕竟野生的猫肯定没有家猫挑剔，这不既然已经成为了宠物，那还不是得作弄主人，谁让你们觉得猫可爱呢。</p>\n<p><img src=\"https://uploader.shimo.im/f/hxrd4HekA603eiq2.png!thumbnail\" alt=\"图片\"></p>\n<p>其实加入公司的每一位开发者，看似是在适应公司的环境，难道不也是在协同进化么。我们用自己的劳动力换取了自己的那份收入，同时也在用自己的某些特征在逐渐影响周围的人，甚至有时候会对公司层面更大范围的集体意识产生了影响，而有的特别具有优秀者气质的人，也自然而然在这个过程中实现了个人能力的极大提升，并为他们未来人生发展奠定了坚实的基础。</p>\n<p>曾经见到过许多人，他们年轻时是充满了斗志、意气风发、能力和才华都非常的引人瞩目，跟我一样，也寓居小城长沙，但是这样的小城市确实很难找到优秀的企业，于是迫于无奈或者是主动选择的加入了那些一些老态龙钟的企业，在开始还感觉挺不错的，但是后来也逐渐的被企业熏陶，然后被工作强奸。还有一些人却始终充满斗志，他们用自己的某些特质感染了周围许多人，并使得公司取得了辉煌的成就，自身也获得了很大的成果。</p>\n<p>是什么让他们或是沉沦，或是进取呢。</p>\n<p>大概是那三个关键性的东西在默默的发挥着关键的作用吧。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>“使命”、“愿景”、“价值观”。</p>\n<p>有时候我们不愿意相信这些东西，以为这些东西是老板用于洗脑的鬼话，甚至有时候公司还会刻意请一些外来的咨询公司来进行所谓的企业文化培训，这些总是会让大家反感。大家都是经历过思想政治课教育出来的优秀人才，别跟我整这些花里胡哨的东西，我们就想搞点实在的。<img src=\"https://uploader.shimo.im/f/99trMyS35RQNCvUr.png!thumbnail\" alt=\"图片\"></p>\n<p>但是有时候还真得承认，使命、愿景、价值观真的是让大家得以团聚，能把事情干好的必要条件啊。</p>\n<p>使命，通俗的理解就是公司正在做的事。我做的事情是否属于公司正在做的事、是否属于公司的主航道？有时候每当我们接到一个任务时，总是会产生这样或那样的疑惑。如果是符合公司使命的任务，我们干起来或许会斗志昂扬，而不属于公司使命的任务，难免会有点气氛消沉，甚至充满的负能量。</p>\n<p>愿景，就是公司想实现的目标。公司干这个事，是真的想做这件事，该不是玩票的吧？公司干这个事，想实现什么目标？我能从这个目标中获得哪些收获？愿景会让人对未来充满想象和希望，而一个人充满了希望，他就愿意为了实现目标付出更多的努力。</p>\n<p>价值观，是完成任务过程中会采取的方法论或指导原则。在《华为方法论》中提到，你可以不喝酒，但是不能喝假酒。讲的是有一个分公司的人，为了跟客户打成一片，就在餐桌上喝酒，但是他身体不好，不能喝那么多酒，所以他在酒里面掺了水，然后被人举报，公司严肃的批评了他这种行为，并指出“如果身体不好，要么就别喝酒，喝假酒就是错的”。具体而言，当我们要实现某个东西时，不同的人有不同的方法。</p>\n<p>例如要搞定某个客户，我们可以把方案做得特别炫、功能做得特别完美，我们也有人会选择采取特殊的手段（例如PY交易），这样会让那些不认同这种价值观的人反感。</p>\n<p>又例如，我们搭建了一个架构，费了很长的时间，然后突然有一个人空降过来，把所有的成绩都归功于自己的功劳，而且还升官发财，而其他人则累死累活，这样的价值观简直恶毒。如果这样的人最终留下来，也意味着所有与他价值观不符的人，要么接受他的价值观或甚至被带下水，要么选择离开。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>一群拥有相同的使命、愿景和价值观的人，一起为了一个共同的目标而奋斗，其所能产生的动力往往是最大的。在2020年的今天，要把事情干好，并不取决于你的技术水平或知识领域，而是取决于公司能否聚齐这一群人。</p>\n<p>同样，当你来到一个团队时，你得衡量的并不仅仅只是团队间的沟通形式，有时候融入团队确实需要时间，但一旦你能够真正融入其中，你将获得自身难以体会的宝贵财富。</p>\n<p>下一篇，我想跟大家探讨一下，基因、企业文化、江湖规矩。</p>\n"},{"title":"如何快速融入团队并成为团队核心（五）","date":"2020-01-19T00:48:00.000Z","author":"邹溪源","_content":"# 一\n团队激励，有时候虽然被称为“胡萝卜加大棒”主义，这套做法其实和美国人在伊拉克或阿富汗搞的拉一派打一派的民族主义似乎差不多，似乎大家也不太愿意听，但是没办法，我们有时候还是得承认，这就是一个客观存在的现实问题。\n\n归根结底，其实每个人都是俗世中的人，难免逃脱不了对于物质和精神欲望的追求。\n\n不同的人在不同的阶段对于目标往往存在不同的衡量标准，有金钱的利益，也有对于声望上的追求，也有人其实看似没什么追求，其实也许也有追求，例如追求团队的认同感，追求工作和生活的平衡？追求更高层面的精神满足？追求在技术上的自我突破？\n\n# 二\n我们的语言表达方式和肢体动作都是内心实际心理或甚至动机的投影，所以作为团队管理者，虽然不能仅凭一言一行来判断一个人的心态，但是如果他做出了明显异于自身常规做法的行为时，那就或许是在给你提醒了。\n\n例如，假设你们公司有一个同事，平时特别喜欢往公司寄快递，突然有一天不寄了，全往家里寄了，那搞不好就是有什么异常的动向了。或者有一位同事平时都特别易于沟通，然后有一天突然特别容易焦躁不安，对工作的事情开始排斥心理，当你问他问题时，他特别反感，或许就需要采取必要的引导措施，给他以激励，以便让他能够更好的为公司继续奋斗。有时有个人平时热衷于跟你讨论技术问题，但是有那么几天突然腻歪了，以至于让你从他的言谈举止中明显的看出来，那也是在暗示着什么。当然，以上这些表现并非都说明对方有离职的趋势，只是说他可能需要接受一些来自于组织的激励了。\n\n每个人都存在被激励的需求，那哪些需求是对大家来说必不可少的底线？哪些是能够让团队持续保持高昂的战斗力，又能紧密的团结到以老板为核心的组织周围，既能共同进退，又能游刃有余？\n\n管理学大佬赫茨伯格对这个有个总结，并形成了一个备受争议的理论，“双因素理论”，大概能够用来总结这些东西。\n\n# 三\n在这个理论中，包含两个部分，分别是保健因素和激励性因素。\n\n保健因素是指在团队中能产生的效果能够起到“保健”的作用，保健能够从环境中消除对身心造成的伤害，虽然无法带来身心健康，但是他能起到预防疾病的作用。\n\n例如待遇问题。。很现实。有的老板说：我的钱都给足了，你还有什么不能满足的？好吧，其实钱的需求只是最基本的需求而已。他无法给人带来满意，只能使人维持在“既不是满意，又不是不满意的状态”。这种状态，大概有点像“我充满怨言，但是我忍了”。好吧。显然，这是一种危险的状态。当然，如果连金钱的基本需求都无法满足，试图靠XX主义的画饼，又如何能使团队成员获得激励？顶多就是维系了一群能够干事的绵羊，却总呼吁他们要保持狼性而已。\n\n除了金钱所涵盖的工资、福利待遇、物质工作条件外，还有公司政策、管理措施、监督、人际关系等。大概还有劳动生产工具，例如是否给开发者配备双显示器或者更好的机械键盘，这些能够极大的改善团队的保健性需求啊。。当然，如果给团队提供“马杀鸡”服务，虽然很奇葩，但是似乎能够对团队提供一定积极正面的效果？没有，只是让那些有怨言的人，多了个忍耐怨言的借口而已，以及在跟其他公司的人交流公司福利待遇时，多一个可以称赞公司的点。\n\n除此之外还有同事关系，同事关系能够给人带来激励么？大概可以，如果团队都很专业，大家干起来很轻松，确实能够带来激励，但是。。如果团队都不专业，或者虽然大家都很专业，但是天天加班，各种开会，常常因为拖工期而被迫赶工熬夜，哪怕大家平时相处的再好，也会充满怨言。\n\n激励因素是指与工作有关，能够令员工满意，激发员工以饱满的状态全付身心的投入到工作中，并把工作当做实现自己理想的因素。例如工作自身能否充满挑战？是不是过度充满挑战？ 例如工作中的认可、成就和责任感，以及技术进步等。\n\n尤其对于开发者来说，过于简单纯粹的工作并不能带来激励，就在于优秀开发者的心目中总有一种对于技术天然的追求，如果无法从现有工作中发掘到令其技术G点满意的内容，或多或少会使其逐渐离心。所以优秀的管理者乐于让团队钻研技术，并鼓励他们发现现有产品中的固有缺陷，并鼓励大家进行改进，这也能客观上起到激励的作用。Google每周允许开发者拿出20%的时间做与本职工作之外的其他技术工作，反而使得开发者能够更好的利用自己的工作时间，从而创造出了更大的价值。\n\n# 四\n发掘团队的优点与适当的激励团队同样重要，根据每个人的特点选择不同的激励措施，例如，如果拆了四套房的，就别试图给金钱激励了，也许给点荣誉证书，对方就很开心了；而经济条件相对较差的，则不然。\n\n有的技术开发者不太擅长表达自己的技术专注点，但是又都愿意分享自己的收获，并希望能从团队分享中获得激励。但作为技术管理者最大的毛病就是吝惜表达自己的赞美，总是易于忽略对方的心理感受，甚至一根筋的认为对方是和自己一样的个体，当对方表达出独特见解时，甚至也许你的评价会过于锋芒，使得其他人关注于你的情绪，而非具体内容本身，这些同样会使人产生不舒适的感觉。\n\n团队中的每个成员都是有血有肉的个体组成的乌合之众，有自己的情绪，想法，文化倾向，也有抱怨和缺点，该如何适当的发掘团队的能力，使战斗力最大化呢？\n\n战斗力的关键部分大概是目标管理和时间管理，后面我们来探讨一下这个问题。\n\n\n","source":"_posts/随笔/如何快速融入团队并成为团队核心（五）.md","raw":"---\ntitle:  如何快速融入团队并成为团队核心（五）\ndate: 2020-01-19 8:48\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n# 一\n团队激励，有时候虽然被称为“胡萝卜加大棒”主义，这套做法其实和美国人在伊拉克或阿富汗搞的拉一派打一派的民族主义似乎差不多，似乎大家也不太愿意听，但是没办法，我们有时候还是得承认，这就是一个客观存在的现实问题。\n\n归根结底，其实每个人都是俗世中的人，难免逃脱不了对于物质和精神欲望的追求。\n\n不同的人在不同的阶段对于目标往往存在不同的衡量标准，有金钱的利益，也有对于声望上的追求，也有人其实看似没什么追求，其实也许也有追求，例如追求团队的认同感，追求工作和生活的平衡？追求更高层面的精神满足？追求在技术上的自我突破？\n\n# 二\n我们的语言表达方式和肢体动作都是内心实际心理或甚至动机的投影，所以作为团队管理者，虽然不能仅凭一言一行来判断一个人的心态，但是如果他做出了明显异于自身常规做法的行为时，那就或许是在给你提醒了。\n\n例如，假设你们公司有一个同事，平时特别喜欢往公司寄快递，突然有一天不寄了，全往家里寄了，那搞不好就是有什么异常的动向了。或者有一位同事平时都特别易于沟通，然后有一天突然特别容易焦躁不安，对工作的事情开始排斥心理，当你问他问题时，他特别反感，或许就需要采取必要的引导措施，给他以激励，以便让他能够更好的为公司继续奋斗。有时有个人平时热衷于跟你讨论技术问题，但是有那么几天突然腻歪了，以至于让你从他的言谈举止中明显的看出来，那也是在暗示着什么。当然，以上这些表现并非都说明对方有离职的趋势，只是说他可能需要接受一些来自于组织的激励了。\n\n每个人都存在被激励的需求，那哪些需求是对大家来说必不可少的底线？哪些是能够让团队持续保持高昂的战斗力，又能紧密的团结到以老板为核心的组织周围，既能共同进退，又能游刃有余？\n\n管理学大佬赫茨伯格对这个有个总结，并形成了一个备受争议的理论，“双因素理论”，大概能够用来总结这些东西。\n\n# 三\n在这个理论中，包含两个部分，分别是保健因素和激励性因素。\n\n保健因素是指在团队中能产生的效果能够起到“保健”的作用，保健能够从环境中消除对身心造成的伤害，虽然无法带来身心健康，但是他能起到预防疾病的作用。\n\n例如待遇问题。。很现实。有的老板说：我的钱都给足了，你还有什么不能满足的？好吧，其实钱的需求只是最基本的需求而已。他无法给人带来满意，只能使人维持在“既不是满意，又不是不满意的状态”。这种状态，大概有点像“我充满怨言，但是我忍了”。好吧。显然，这是一种危险的状态。当然，如果连金钱的基本需求都无法满足，试图靠XX主义的画饼，又如何能使团队成员获得激励？顶多就是维系了一群能够干事的绵羊，却总呼吁他们要保持狼性而已。\n\n除了金钱所涵盖的工资、福利待遇、物质工作条件外，还有公司政策、管理措施、监督、人际关系等。大概还有劳动生产工具，例如是否给开发者配备双显示器或者更好的机械键盘，这些能够极大的改善团队的保健性需求啊。。当然，如果给团队提供“马杀鸡”服务，虽然很奇葩，但是似乎能够对团队提供一定积极正面的效果？没有，只是让那些有怨言的人，多了个忍耐怨言的借口而已，以及在跟其他公司的人交流公司福利待遇时，多一个可以称赞公司的点。\n\n除此之外还有同事关系，同事关系能够给人带来激励么？大概可以，如果团队都很专业，大家干起来很轻松，确实能够带来激励，但是。。如果团队都不专业，或者虽然大家都很专业，但是天天加班，各种开会，常常因为拖工期而被迫赶工熬夜，哪怕大家平时相处的再好，也会充满怨言。\n\n激励因素是指与工作有关，能够令员工满意，激发员工以饱满的状态全付身心的投入到工作中，并把工作当做实现自己理想的因素。例如工作自身能否充满挑战？是不是过度充满挑战？ 例如工作中的认可、成就和责任感，以及技术进步等。\n\n尤其对于开发者来说，过于简单纯粹的工作并不能带来激励，就在于优秀开发者的心目中总有一种对于技术天然的追求，如果无法从现有工作中发掘到令其技术G点满意的内容，或多或少会使其逐渐离心。所以优秀的管理者乐于让团队钻研技术，并鼓励他们发现现有产品中的固有缺陷，并鼓励大家进行改进，这也能客观上起到激励的作用。Google每周允许开发者拿出20%的时间做与本职工作之外的其他技术工作，反而使得开发者能够更好的利用自己的工作时间，从而创造出了更大的价值。\n\n# 四\n发掘团队的优点与适当的激励团队同样重要，根据每个人的特点选择不同的激励措施，例如，如果拆了四套房的，就别试图给金钱激励了，也许给点荣誉证书，对方就很开心了；而经济条件相对较差的，则不然。\n\n有的技术开发者不太擅长表达自己的技术专注点，但是又都愿意分享自己的收获，并希望能从团队分享中获得激励。但作为技术管理者最大的毛病就是吝惜表达自己的赞美，总是易于忽略对方的心理感受，甚至一根筋的认为对方是和自己一样的个体，当对方表达出独特见解时，甚至也许你的评价会过于锋芒，使得其他人关注于你的情绪，而非具体内容本身，这些同样会使人产生不舒适的感觉。\n\n团队中的每个成员都是有血有肉的个体组成的乌合之众，有自己的情绪，想法，文化倾向，也有抱怨和缺点，该如何适当的发掘团队的能力，使战斗力最大化呢？\n\n战斗力的关键部分大概是目标管理和时间管理，后面我们来探讨一下这个问题。\n\n\n","slug":"随笔/如何快速融入团队并成为团队核心（五）","published":1,"updated":"2020-01-19T00:48:11.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt9a003un4vi3m7o4s74","content":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>团队激励，有时候虽然被称为“胡萝卜加大棒”主义，这套做法其实和美国人在伊拉克或阿富汗搞的拉一派打一派的民族主义似乎差不多，似乎大家也不太愿意听，但是没办法，我们有时候还是得承认，这就是一个客观存在的现实问题。</p>\n<p>归根结底，其实每个人都是俗世中的人，难免逃脱不了对于物质和精神欲望的追求。</p>\n<p>不同的人在不同的阶段对于目标往往存在不同的衡量标准，有金钱的利益，也有对于声望上的追求，也有人其实看似没什么追求，其实也许也有追求，例如追求团队的认同感，追求工作和生活的平衡？追求更高层面的精神满足？追求在技术上的自我突破？</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>我们的语言表达方式和肢体动作都是内心实际心理或甚至动机的投影，所以作为团队管理者，虽然不能仅凭一言一行来判断一个人的心态，但是如果他做出了明显异于自身常规做法的行为时，那就或许是在给你提醒了。</p>\n<p>例如，假设你们公司有一个同事，平时特别喜欢往公司寄快递，突然有一天不寄了，全往家里寄了，那搞不好就是有什么异常的动向了。或者有一位同事平时都特别易于沟通，然后有一天突然特别容易焦躁不安，对工作的事情开始排斥心理，当你问他问题时，他特别反感，或许就需要采取必要的引导措施，给他以激励，以便让他能够更好的为公司继续奋斗。有时有个人平时热衷于跟你讨论技术问题，但是有那么几天突然腻歪了，以至于让你从他的言谈举止中明显的看出来，那也是在暗示着什么。当然，以上这些表现并非都说明对方有离职的趋势，只是说他可能需要接受一些来自于组织的激励了。</p>\n<p>每个人都存在被激励的需求，那哪些需求是对大家来说必不可少的底线？哪些是能够让团队持续保持高昂的战斗力，又能紧密的团结到以老板为核心的组织周围，既能共同进退，又能游刃有余？</p>\n<p>管理学大佬赫茨伯格对这个有个总结，并形成了一个备受争议的理论，“双因素理论”，大概能够用来总结这些东西。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>在这个理论中，包含两个部分，分别是保健因素和激励性因素。</p>\n<p>保健因素是指在团队中能产生的效果能够起到“保健”的作用，保健能够从环境中消除对身心造成的伤害，虽然无法带来身心健康，但是他能起到预防疾病的作用。</p>\n<p>例如待遇问题。。很现实。有的老板说：我的钱都给足了，你还有什么不能满足的？好吧，其实钱的需求只是最基本的需求而已。他无法给人带来满意，只能使人维持在“既不是满意，又不是不满意的状态”。这种状态，大概有点像“我充满怨言，但是我忍了”。好吧。显然，这是一种危险的状态。当然，如果连金钱的基本需求都无法满足，试图靠XX主义的画饼，又如何能使团队成员获得激励？顶多就是维系了一群能够干事的绵羊，却总呼吁他们要保持狼性而已。</p>\n<p>除了金钱所涵盖的工资、福利待遇、物质工作条件外，还有公司政策、管理措施、监督、人际关系等。大概还有劳动生产工具，例如是否给开发者配备双显示器或者更好的机械键盘，这些能够极大的改善团队的保健性需求啊。。当然，如果给团队提供“马杀鸡”服务，虽然很奇葩，但是似乎能够对团队提供一定积极正面的效果？没有，只是让那些有怨言的人，多了个忍耐怨言的借口而已，以及在跟其他公司的人交流公司福利待遇时，多一个可以称赞公司的点。</p>\n<p>除此之外还有同事关系，同事关系能够给人带来激励么？大概可以，如果团队都很专业，大家干起来很轻松，确实能够带来激励，但是。。如果团队都不专业，或者虽然大家都很专业，但是天天加班，各种开会，常常因为拖工期而被迫赶工熬夜，哪怕大家平时相处的再好，也会充满怨言。</p>\n<p>激励因素是指与工作有关，能够令员工满意，激发员工以饱满的状态全付身心的投入到工作中，并把工作当做实现自己理想的因素。例如工作自身能否充满挑战？是不是过度充满挑战？ 例如工作中的认可、成就和责任感，以及技术进步等。</p>\n<p>尤其对于开发者来说，过于简单纯粹的工作并不能带来激励，就在于优秀开发者的心目中总有一种对于技术天然的追求，如果无法从现有工作中发掘到令其技术G点满意的内容，或多或少会使其逐渐离心。所以优秀的管理者乐于让团队钻研技术，并鼓励他们发现现有产品中的固有缺陷，并鼓励大家进行改进，这也能客观上起到激励的作用。Google每周允许开发者拿出20%的时间做与本职工作之外的其他技术工作，反而使得开发者能够更好的利用自己的工作时间，从而创造出了更大的价值。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>发掘团队的优点与适当的激励团队同样重要，根据每个人的特点选择不同的激励措施，例如，如果拆了四套房的，就别试图给金钱激励了，也许给点荣誉证书，对方就很开心了；而经济条件相对较差的，则不然。</p>\n<p>有的技术开发者不太擅长表达自己的技术专注点，但是又都愿意分享自己的收获，并希望能从团队分享中获得激励。但作为技术管理者最大的毛病就是吝惜表达自己的赞美，总是易于忽略对方的心理感受，甚至一根筋的认为对方是和自己一样的个体，当对方表达出独特见解时，甚至也许你的评价会过于锋芒，使得其他人关注于你的情绪，而非具体内容本身，这些同样会使人产生不舒适的感觉。</p>\n<p>团队中的每个成员都是有血有肉的个体组成的乌合之众，有自己的情绪，想法，文化倾向，也有抱怨和缺点，该如何适当的发掘团队的能力，使战斗力最大化呢？</p>\n<p>战斗力的关键部分大概是目标管理和时间管理，后面我们来探讨一下这个问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>团队激励，有时候虽然被称为“胡萝卜加大棒”主义，这套做法其实和美国人在伊拉克或阿富汗搞的拉一派打一派的民族主义似乎差不多，似乎大家也不太愿意听，但是没办法，我们有时候还是得承认，这就是一个客观存在的现实问题。</p>\n<p>归根结底，其实每个人都是俗世中的人，难免逃脱不了对于物质和精神欲望的追求。</p>\n<p>不同的人在不同的阶段对于目标往往存在不同的衡量标准，有金钱的利益，也有对于声望上的追求，也有人其实看似没什么追求，其实也许也有追求，例如追求团队的认同感，追求工作和生活的平衡？追求更高层面的精神满足？追求在技术上的自我突破？</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>我们的语言表达方式和肢体动作都是内心实际心理或甚至动机的投影，所以作为团队管理者，虽然不能仅凭一言一行来判断一个人的心态，但是如果他做出了明显异于自身常规做法的行为时，那就或许是在给你提醒了。</p>\n<p>例如，假设你们公司有一个同事，平时特别喜欢往公司寄快递，突然有一天不寄了，全往家里寄了，那搞不好就是有什么异常的动向了。或者有一位同事平时都特别易于沟通，然后有一天突然特别容易焦躁不安，对工作的事情开始排斥心理，当你问他问题时，他特别反感，或许就需要采取必要的引导措施，给他以激励，以便让他能够更好的为公司继续奋斗。有时有个人平时热衷于跟你讨论技术问题，但是有那么几天突然腻歪了，以至于让你从他的言谈举止中明显的看出来，那也是在暗示着什么。当然，以上这些表现并非都说明对方有离职的趋势，只是说他可能需要接受一些来自于组织的激励了。</p>\n<p>每个人都存在被激励的需求，那哪些需求是对大家来说必不可少的底线？哪些是能够让团队持续保持高昂的战斗力，又能紧密的团结到以老板为核心的组织周围，既能共同进退，又能游刃有余？</p>\n<p>管理学大佬赫茨伯格对这个有个总结，并形成了一个备受争议的理论，“双因素理论”，大概能够用来总结这些东西。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>在这个理论中，包含两个部分，分别是保健因素和激励性因素。</p>\n<p>保健因素是指在团队中能产生的效果能够起到“保健”的作用，保健能够从环境中消除对身心造成的伤害，虽然无法带来身心健康，但是他能起到预防疾病的作用。</p>\n<p>例如待遇问题。。很现实。有的老板说：我的钱都给足了，你还有什么不能满足的？好吧，其实钱的需求只是最基本的需求而已。他无法给人带来满意，只能使人维持在“既不是满意，又不是不满意的状态”。这种状态，大概有点像“我充满怨言，但是我忍了”。好吧。显然，这是一种危险的状态。当然，如果连金钱的基本需求都无法满足，试图靠XX主义的画饼，又如何能使团队成员获得激励？顶多就是维系了一群能够干事的绵羊，却总呼吁他们要保持狼性而已。</p>\n<p>除了金钱所涵盖的工资、福利待遇、物质工作条件外，还有公司政策、管理措施、监督、人际关系等。大概还有劳动生产工具，例如是否给开发者配备双显示器或者更好的机械键盘，这些能够极大的改善团队的保健性需求啊。。当然，如果给团队提供“马杀鸡”服务，虽然很奇葩，但是似乎能够对团队提供一定积极正面的效果？没有，只是让那些有怨言的人，多了个忍耐怨言的借口而已，以及在跟其他公司的人交流公司福利待遇时，多一个可以称赞公司的点。</p>\n<p>除此之外还有同事关系，同事关系能够给人带来激励么？大概可以，如果团队都很专业，大家干起来很轻松，确实能够带来激励，但是。。如果团队都不专业，或者虽然大家都很专业，但是天天加班，各种开会，常常因为拖工期而被迫赶工熬夜，哪怕大家平时相处的再好，也会充满怨言。</p>\n<p>激励因素是指与工作有关，能够令员工满意，激发员工以饱满的状态全付身心的投入到工作中，并把工作当做实现自己理想的因素。例如工作自身能否充满挑战？是不是过度充满挑战？ 例如工作中的认可、成就和责任感，以及技术进步等。</p>\n<p>尤其对于开发者来说，过于简单纯粹的工作并不能带来激励，就在于优秀开发者的心目中总有一种对于技术天然的追求，如果无法从现有工作中发掘到令其技术G点满意的内容，或多或少会使其逐渐离心。所以优秀的管理者乐于让团队钻研技术，并鼓励他们发现现有产品中的固有缺陷，并鼓励大家进行改进，这也能客观上起到激励的作用。Google每周允许开发者拿出20%的时间做与本职工作之外的其他技术工作，反而使得开发者能够更好的利用自己的工作时间，从而创造出了更大的价值。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>发掘团队的优点与适当的激励团队同样重要，根据每个人的特点选择不同的激励措施，例如，如果拆了四套房的，就别试图给金钱激励了，也许给点荣誉证书，对方就很开心了；而经济条件相对较差的，则不然。</p>\n<p>有的技术开发者不太擅长表达自己的技术专注点，但是又都愿意分享自己的收获，并希望能从团队分享中获得激励。但作为技术管理者最大的毛病就是吝惜表达自己的赞美，总是易于忽略对方的心理感受，甚至一根筋的认为对方是和自己一样的个体，当对方表达出独特见解时，甚至也许你的评价会过于锋芒，使得其他人关注于你的情绪，而非具体内容本身，这些同样会使人产生不舒适的感觉。</p>\n<p>团队中的每个成员都是有血有肉的个体组成的乌合之众，有自己的情绪，想法，文化倾向，也有抱怨和缺点，该如何适当的发掘团队的能力，使战斗力最大化呢？</p>\n<p>战斗力的关键部分大概是目标管理和时间管理，后面我们来探讨一下这个问题。</p>\n"},{"title":"如何快速融入团队并成为团队核心(八)","date":"2020-03-11T13:22:00.000Z","author":"邹溪源","_content":"# 一\n感慨时间流逝，韶华易老似乎是我们与生俱来的焦虑，仿佛每当过年的时候总会感觉，呀，我这一年似乎什么都没干呀。\n\n你看，连孔子都说：逝者如斯夫，不舍昼夜。所以他老人家是不是也很焦虑。。\n\n然而我们的时间都去哪里了？\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/8-1.jpeg)\n\n尤其是作为互联网开发者的我们，其实更加明显，有时候上午9点到公司，然后随便写几行代码，就到中午了，然后再下午又调几个昨天写的bug，于是，这一天就似乎这么结束了。\n\n我也曾经列过一个清单，汇总了当天的工作分配情况，其中，修复bug占比和沟通所占的比重最多，大概表明作为开发者的我代码质量确实是个问题。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/8-2.png)      \n\n不过撇开代码质量这个因素不说，其实也反应了主观上在进行时间管控方面确实存在一些问题，这些问题也许平时看起来不明显，但是一旦我们开始进行记录，就会觉得比较明显。\n\n例如，层出不穷的产品需求沟通、缺陷跟进、日常的会议和其他工作安排，这些看起来其实是非常常见的具体的事件，原本属于开发过程中正常的沟通，但是如果缺乏有效的节制，依然会造成效率的降低。毕竟我们的大脑进行任务的切换本身也是需要时间的，有时候如果正在进行某些需要消耗脑力的工作时，一旦被打断了，或许需要花更长的时间才能弥补过来。\n\n# 二\n当然有时候我们可能会习惯于白天被人打断，而把工作拖到晚上再花时间来弥补，或许这也是程序员们不得不辛苦的选择996这种不太合理的作息制度的一个客观原因。\n\n坦率而言，时间对每个人来说都是公平的，每天24个小时分配得其实已经够合理了，但是同样的时间，不同的人却能做出不同的成绩；例如，我最近在阅读《程序员的三门课》，就深深的感觉同样是在阿里巴巴集团工作的张洪亮，从2015年加入阿里巴巴，到目前短短五年时间，我们都可以看到他的博客，几年时间写了几百篇博客，显然这些博客都来源于他日常工作中的实际场景，这也说明他不仅仅能够把代码写得很完美，也同样能够把自己的业余时间安排得非常饱满、同样的选择职场奋斗，为何他能够把时间安排得如此妥当呢。\n\n这确实是一个值得大家深思的问题。\n\n我最近开始有意识的管理自己的时间，例如我发现我的iphone中显示了一组数据：\n\n1、每天抬起手机61次。\n\n2、使用微信一小时。\n\n3、屏幕使用时长1个半小时。\n\n我观察了我一周中，最少的屏幕使用时间差不多也是一小时多一点，多的一天大概是将近两小时，这实际上是在工作时间记录的时间，当然，撇开每天在地铁上上下班（约一个半小时）的日常的手机使用情况，依然每天有将近一个小时的时间看起来似乎是不合理的支配了。\n\n我来粗略估算一下自己的时间粒度，大概是这样的：\n\n1、休息时间，每天8个小时。这个时间包含晚上休息和中午休息的时间。\n\n2、工作通勤路上的时间：1个半小时。\n\n3、每天的用餐时间：30分钟。\n\n4、每天的如厕时间，20分钟。\n\n5、工作时间：8-9小时。\n\n6、每天的阅读学习和其他时间：约两小时。\n\n没错，以上数据之和不等于24小时，说明还有一些时间损耗看起来不明显，但累积起来也同样惊人。当然实际上工作时间看起来有8-9小时，实际上真的能实现满打满算的工作这么长的时间么，这大概是个自欺欺人的问题，很惭愧的说大概在这个工作时段，有那么一段时间，或者说不短于一个半小时，或许是在各种聊天工具间来回切换。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/8-3.png)\n\n（以上数据过于真实，请大家尽管批评吧。）\n\n所以，我曾经看过，越是成功的人士，越善于合理的利用时间，例如，像王健林同志，据说已经把时间安排在15分钟这个粒度。而目前的我，大概离一个小时这个粒度都还有一点困难，所以离成功还差十万八千里也不是没有理由的。\n\n# 三\n作为一位技术从业者，是否能够合理的支配自己的时间确实是非常重要的事情，从某种意义上来说，能够每天花10个小时，或者8个小时全付身心的投入到工作中，其实已经足够完成许多任务了。\n\n个人认为，我们大概可以做以下这些工作来更好的实现自己对时间的支配：\n\n1、对自己每天的实际时间支配情况进行总结，分析时间的主要分布情况，并以清单的形式列入，以便自己有目的性的进行改善。\n\n2、难免需要一些断舍离，比如关闭某些app的推送通知，将非工作用的聊天工具，从windows桌面右下角的图标中隐藏，避免对工作造成的干扰，然后每天花一段特定的时间来处理非工作场景下的消息。\n\n3、每天早上简单的概述自己今天需要完成的工作，并预估工作所需要的时间，适当的给自己一些相对较长的时间，在这个时间段内，尽量避免外界因素的干扰。每天早上和下午工作开始一小时后的是能够利用的长块时间，而且效率也比较高，尽量将重要性工作安排在这样的时间段进行，尽量避免在这样的时间段开会，以免降低工作效率。（例如，微软有一个go dark的机制，允许在某些特殊的情况下与外界因素隔离开，踏踏实实的沉浸到写代码中）。\n\n4、合理的利用等待期。在同时需要处理多个任务时，有的任务往往由于各种条件或资源尚不具备，这会需要花不少时间来等待，如果我们将置于等待期的任务提前规划、也是一种不错的方法。\n\n在《卓有成效的管理者》这本书中，将会管理自己的时间作为一个优秀管理者开始其管理工作的第一步，只有开始学会梳理自己的时间和管理自己的时间，才能成为合适的管理者，这一点我觉得非常有道理。\n\n\n\n\n\n","source":"_posts/随笔/如何快速融入团队并成为团队核心（八）.md","raw":"---\ntitle:  如何快速融入团队并成为团队核心(八)\ndate: 2020-3-11 21:22\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n# 一\n感慨时间流逝，韶华易老似乎是我们与生俱来的焦虑，仿佛每当过年的时候总会感觉，呀，我这一年似乎什么都没干呀。\n\n你看，连孔子都说：逝者如斯夫，不舍昼夜。所以他老人家是不是也很焦虑。。\n\n然而我们的时间都去哪里了？\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/8-1.jpeg)\n\n尤其是作为互联网开发者的我们，其实更加明显，有时候上午9点到公司，然后随便写几行代码，就到中午了，然后再下午又调几个昨天写的bug，于是，这一天就似乎这么结束了。\n\n我也曾经列过一个清单，汇总了当天的工作分配情况，其中，修复bug占比和沟通所占的比重最多，大概表明作为开发者的我代码质量确实是个问题。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/8-2.png)      \n\n不过撇开代码质量这个因素不说，其实也反应了主观上在进行时间管控方面确实存在一些问题，这些问题也许平时看起来不明显，但是一旦我们开始进行记录，就会觉得比较明显。\n\n例如，层出不穷的产品需求沟通、缺陷跟进、日常的会议和其他工作安排，这些看起来其实是非常常见的具体的事件，原本属于开发过程中正常的沟通，但是如果缺乏有效的节制，依然会造成效率的降低。毕竟我们的大脑进行任务的切换本身也是需要时间的，有时候如果正在进行某些需要消耗脑力的工作时，一旦被打断了，或许需要花更长的时间才能弥补过来。\n\n# 二\n当然有时候我们可能会习惯于白天被人打断，而把工作拖到晚上再花时间来弥补，或许这也是程序员们不得不辛苦的选择996这种不太合理的作息制度的一个客观原因。\n\n坦率而言，时间对每个人来说都是公平的，每天24个小时分配得其实已经够合理了，但是同样的时间，不同的人却能做出不同的成绩；例如，我最近在阅读《程序员的三门课》，就深深的感觉同样是在阿里巴巴集团工作的张洪亮，从2015年加入阿里巴巴，到目前短短五年时间，我们都可以看到他的博客，几年时间写了几百篇博客，显然这些博客都来源于他日常工作中的实际场景，这也说明他不仅仅能够把代码写得很完美，也同样能够把自己的业余时间安排得非常饱满、同样的选择职场奋斗，为何他能够把时间安排得如此妥当呢。\n\n这确实是一个值得大家深思的问题。\n\n我最近开始有意识的管理自己的时间，例如我发现我的iphone中显示了一组数据：\n\n1、每天抬起手机61次。\n\n2、使用微信一小时。\n\n3、屏幕使用时长1个半小时。\n\n我观察了我一周中，最少的屏幕使用时间差不多也是一小时多一点，多的一天大概是将近两小时，这实际上是在工作时间记录的时间，当然，撇开每天在地铁上上下班（约一个半小时）的日常的手机使用情况，依然每天有将近一个小时的时间看起来似乎是不合理的支配了。\n\n我来粗略估算一下自己的时间粒度，大概是这样的：\n\n1、休息时间，每天8个小时。这个时间包含晚上休息和中午休息的时间。\n\n2、工作通勤路上的时间：1个半小时。\n\n3、每天的用餐时间：30分钟。\n\n4、每天的如厕时间，20分钟。\n\n5、工作时间：8-9小时。\n\n6、每天的阅读学习和其他时间：约两小时。\n\n没错，以上数据之和不等于24小时，说明还有一些时间损耗看起来不明显，但累积起来也同样惊人。当然实际上工作时间看起来有8-9小时，实际上真的能实现满打满算的工作这么长的时间么，这大概是个自欺欺人的问题，很惭愧的说大概在这个工作时段，有那么一段时间，或者说不短于一个半小时，或许是在各种聊天工具间来回切换。\n\n![图片](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/8-3.png)\n\n（以上数据过于真实，请大家尽管批评吧。）\n\n所以，我曾经看过，越是成功的人士，越善于合理的利用时间，例如，像王健林同志，据说已经把时间安排在15分钟这个粒度。而目前的我，大概离一个小时这个粒度都还有一点困难，所以离成功还差十万八千里也不是没有理由的。\n\n# 三\n作为一位技术从业者，是否能够合理的支配自己的时间确实是非常重要的事情，从某种意义上来说，能够每天花10个小时，或者8个小时全付身心的投入到工作中，其实已经足够完成许多任务了。\n\n个人认为，我们大概可以做以下这些工作来更好的实现自己对时间的支配：\n\n1、对自己每天的实际时间支配情况进行总结，分析时间的主要分布情况，并以清单的形式列入，以便自己有目的性的进行改善。\n\n2、难免需要一些断舍离，比如关闭某些app的推送通知，将非工作用的聊天工具，从windows桌面右下角的图标中隐藏，避免对工作造成的干扰，然后每天花一段特定的时间来处理非工作场景下的消息。\n\n3、每天早上简单的概述自己今天需要完成的工作，并预估工作所需要的时间，适当的给自己一些相对较长的时间，在这个时间段内，尽量避免外界因素的干扰。每天早上和下午工作开始一小时后的是能够利用的长块时间，而且效率也比较高，尽量将重要性工作安排在这样的时间段进行，尽量避免在这样的时间段开会，以免降低工作效率。（例如，微软有一个go dark的机制，允许在某些特殊的情况下与外界因素隔离开，踏踏实实的沉浸到写代码中）。\n\n4、合理的利用等待期。在同时需要处理多个任务时，有的任务往往由于各种条件或资源尚不具备，这会需要花不少时间来等待，如果我们将置于等待期的任务提前规划、也是一种不错的方法。\n\n在《卓有成效的管理者》这本书中，将会管理自己的时间作为一个优秀管理者开始其管理工作的第一步，只有开始学会梳理自己的时间和管理自己的时间，才能成为合适的管理者，这一点我觉得非常有道理。\n\n\n\n\n\n","slug":"随笔/如何快速融入团队并成为团队核心（八）","published":1,"updated":"2020-03-11T13:30:51.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt9c003xn4vi1qouvjyd","content":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>感慨时间流逝，韶华易老似乎是我们与生俱来的焦虑，仿佛每当过年的时候总会感觉，呀，我这一年似乎什么都没干呀。</p>\n<p>你看，连孔子都说：逝者如斯夫，不舍昼夜。所以他老人家是不是也很焦虑。。</p>\n<p>然而我们的时间都去哪里了？</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/8-1.jpeg\" alt=\"图片\"></p>\n<p>尤其是作为互联网开发者的我们，其实更加明显，有时候上午9点到公司，然后随便写几行代码，就到中午了，然后再下午又调几个昨天写的bug，于是，这一天就似乎这么结束了。</p>\n<p>我也曾经列过一个清单，汇总了当天的工作分配情况，其中，修复bug占比和沟通所占的比重最多，大概表明作为开发者的我代码质量确实是个问题。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/8-2.png\" alt=\"图片\">      </p>\n<p>不过撇开代码质量这个因素不说，其实也反应了主观上在进行时间管控方面确实存在一些问题，这些问题也许平时看起来不明显，但是一旦我们开始进行记录，就会觉得比较明显。</p>\n<p>例如，层出不穷的产品需求沟通、缺陷跟进、日常的会议和其他工作安排，这些看起来其实是非常常见的具体的事件，原本属于开发过程中正常的沟通，但是如果缺乏有效的节制，依然会造成效率的降低。毕竟我们的大脑进行任务的切换本身也是需要时间的，有时候如果正在进行某些需要消耗脑力的工作时，一旦被打断了，或许需要花更长的时间才能弥补过来。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>当然有时候我们可能会习惯于白天被人打断，而把工作拖到晚上再花时间来弥补，或许这也是程序员们不得不辛苦的选择996这种不太合理的作息制度的一个客观原因。</p>\n<p>坦率而言，时间对每个人来说都是公平的，每天24个小时分配得其实已经够合理了，但是同样的时间，不同的人却能做出不同的成绩；例如，我最近在阅读《程序员的三门课》，就深深的感觉同样是在阿里巴巴集团工作的张洪亮，从2015年加入阿里巴巴，到目前短短五年时间，我们都可以看到他的博客，几年时间写了几百篇博客，显然这些博客都来源于他日常工作中的实际场景，这也说明他不仅仅能够把代码写得很完美，也同样能够把自己的业余时间安排得非常饱满、同样的选择职场奋斗，为何他能够把时间安排得如此妥当呢。</p>\n<p>这确实是一个值得大家深思的问题。</p>\n<p>我最近开始有意识的管理自己的时间，例如我发现我的iphone中显示了一组数据：</p>\n<p>1、每天抬起手机61次。</p>\n<p>2、使用微信一小时。</p>\n<p>3、屏幕使用时长1个半小时。</p>\n<p>我观察了我一周中，最少的屏幕使用时间差不多也是一小时多一点，多的一天大概是将近两小时，这实际上是在工作时间记录的时间，当然，撇开每天在地铁上上下班（约一个半小时）的日常的手机使用情况，依然每天有将近一个小时的时间看起来似乎是不合理的支配了。</p>\n<p>我来粗略估算一下自己的时间粒度，大概是这样的：</p>\n<p>1、休息时间，每天8个小时。这个时间包含晚上休息和中午休息的时间。</p>\n<p>2、工作通勤路上的时间：1个半小时。</p>\n<p>3、每天的用餐时间：30分钟。</p>\n<p>4、每天的如厕时间，20分钟。</p>\n<p>5、工作时间：8-9小时。</p>\n<p>6、每天的阅读学习和其他时间：约两小时。</p>\n<p>没错，以上数据之和不等于24小时，说明还有一些时间损耗看起来不明显，但累积起来也同样惊人。当然实际上工作时间看起来有8-9小时，实际上真的能实现满打满算的工作这么长的时间么，这大概是个自欺欺人的问题，很惭愧的说大概在这个工作时段，有那么一段时间，或者说不短于一个半小时，或许是在各种聊天工具间来回切换。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/8-3.png\" alt=\"图片\"></p>\n<p>（以上数据过于真实，请大家尽管批评吧。）</p>\n<p>所以，我曾经看过，越是成功的人士，越善于合理的利用时间，例如，像王健林同志，据说已经把时间安排在15分钟这个粒度。而目前的我，大概离一个小时这个粒度都还有一点困难，所以离成功还差十万八千里也不是没有理由的。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>作为一位技术从业者，是否能够合理的支配自己的时间确实是非常重要的事情，从某种意义上来说，能够每天花10个小时，或者8个小时全付身心的投入到工作中，其实已经足够完成许多任务了。</p>\n<p>个人认为，我们大概可以做以下这些工作来更好的实现自己对时间的支配：</p>\n<p>1、对自己每天的实际时间支配情况进行总结，分析时间的主要分布情况，并以清单的形式列入，以便自己有目的性的进行改善。</p>\n<p>2、难免需要一些断舍离，比如关闭某些app的推送通知，将非工作用的聊天工具，从windows桌面右下角的图标中隐藏，避免对工作造成的干扰，然后每天花一段特定的时间来处理非工作场景下的消息。</p>\n<p>3、每天早上简单的概述自己今天需要完成的工作，并预估工作所需要的时间，适当的给自己一些相对较长的时间，在这个时间段内，尽量避免外界因素的干扰。每天早上和下午工作开始一小时后的是能够利用的长块时间，而且效率也比较高，尽量将重要性工作安排在这样的时间段进行，尽量避免在这样的时间段开会，以免降低工作效率。（例如，微软有一个go dark的机制，允许在某些特殊的情况下与外界因素隔离开，踏踏实实的沉浸到写代码中）。</p>\n<p>4、合理的利用等待期。在同时需要处理多个任务时，有的任务往往由于各种条件或资源尚不具备，这会需要花不少时间来等待，如果我们将置于等待期的任务提前规划、也是一种不错的方法。</p>\n<p>在《卓有成效的管理者》这本书中，将会管理自己的时间作为一个优秀管理者开始其管理工作的第一步，只有开始学会梳理自己的时间和管理自己的时间，才能成为合适的管理者，这一点我觉得非常有道理。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>感慨时间流逝，韶华易老似乎是我们与生俱来的焦虑，仿佛每当过年的时候总会感觉，呀，我这一年似乎什么都没干呀。</p>\n<p>你看，连孔子都说：逝者如斯夫，不舍昼夜。所以他老人家是不是也很焦虑。。</p>\n<p>然而我们的时间都去哪里了？</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/8-1.jpeg\" alt=\"图片\"></p>\n<p>尤其是作为互联网开发者的我们，其实更加明显，有时候上午9点到公司，然后随便写几行代码，就到中午了，然后再下午又调几个昨天写的bug，于是，这一天就似乎这么结束了。</p>\n<p>我也曾经列过一个清单，汇总了当天的工作分配情况，其中，修复bug占比和沟通所占的比重最多，大概表明作为开发者的我代码质量确实是个问题。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/8-2.png\" alt=\"图片\">      </p>\n<p>不过撇开代码质量这个因素不说，其实也反应了主观上在进行时间管控方面确实存在一些问题，这些问题也许平时看起来不明显，但是一旦我们开始进行记录，就会觉得比较明显。</p>\n<p>例如，层出不穷的产品需求沟通、缺陷跟进、日常的会议和其他工作安排，这些看起来其实是非常常见的具体的事件，原本属于开发过程中正常的沟通，但是如果缺乏有效的节制，依然会造成效率的降低。毕竟我们的大脑进行任务的切换本身也是需要时间的，有时候如果正在进行某些需要消耗脑力的工作时，一旦被打断了，或许需要花更长的时间才能弥补过来。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>当然有时候我们可能会习惯于白天被人打断，而把工作拖到晚上再花时间来弥补，或许这也是程序员们不得不辛苦的选择996这种不太合理的作息制度的一个客观原因。</p>\n<p>坦率而言，时间对每个人来说都是公平的，每天24个小时分配得其实已经够合理了，但是同样的时间，不同的人却能做出不同的成绩；例如，我最近在阅读《程序员的三门课》，就深深的感觉同样是在阿里巴巴集团工作的张洪亮，从2015年加入阿里巴巴，到目前短短五年时间，我们都可以看到他的博客，几年时间写了几百篇博客，显然这些博客都来源于他日常工作中的实际场景，这也说明他不仅仅能够把代码写得很完美，也同样能够把自己的业余时间安排得非常饱满、同样的选择职场奋斗，为何他能够把时间安排得如此妥当呢。</p>\n<p>这确实是一个值得大家深思的问题。</p>\n<p>我最近开始有意识的管理自己的时间，例如我发现我的iphone中显示了一组数据：</p>\n<p>1、每天抬起手机61次。</p>\n<p>2、使用微信一小时。</p>\n<p>3、屏幕使用时长1个半小时。</p>\n<p>我观察了我一周中，最少的屏幕使用时间差不多也是一小时多一点，多的一天大概是将近两小时，这实际上是在工作时间记录的时间，当然，撇开每天在地铁上上下班（约一个半小时）的日常的手机使用情况，依然每天有将近一个小时的时间看起来似乎是不合理的支配了。</p>\n<p>我来粗略估算一下自己的时间粒度，大概是这样的：</p>\n<p>1、休息时间，每天8个小时。这个时间包含晚上休息和中午休息的时间。</p>\n<p>2、工作通勤路上的时间：1个半小时。</p>\n<p>3、每天的用餐时间：30分钟。</p>\n<p>4、每天的如厕时间，20分钟。</p>\n<p>5、工作时间：8-9小时。</p>\n<p>6、每天的阅读学习和其他时间：约两小时。</p>\n<p>没错，以上数据之和不等于24小时，说明还有一些时间损耗看起来不明显，但累积起来也同样惊人。当然实际上工作时间看起来有8-9小时，实际上真的能实现满打满算的工作这么长的时间么，这大概是个自欺欺人的问题，很惭愧的说大概在这个工作时段，有那么一段时间，或者说不短于一个半小时，或许是在各种聊天工具间来回切换。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/8-3.png\" alt=\"图片\"></p>\n<p>（以上数据过于真实，请大家尽管批评吧。）</p>\n<p>所以，我曾经看过，越是成功的人士，越善于合理的利用时间，例如，像王健林同志，据说已经把时间安排在15分钟这个粒度。而目前的我，大概离一个小时这个粒度都还有一点困难，所以离成功还差十万八千里也不是没有理由的。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>作为一位技术从业者，是否能够合理的支配自己的时间确实是非常重要的事情，从某种意义上来说，能够每天花10个小时，或者8个小时全付身心的投入到工作中，其实已经足够完成许多任务了。</p>\n<p>个人认为，我们大概可以做以下这些工作来更好的实现自己对时间的支配：</p>\n<p>1、对自己每天的实际时间支配情况进行总结，分析时间的主要分布情况，并以清单的形式列入，以便自己有目的性的进行改善。</p>\n<p>2、难免需要一些断舍离，比如关闭某些app的推送通知，将非工作用的聊天工具，从windows桌面右下角的图标中隐藏，避免对工作造成的干扰，然后每天花一段特定的时间来处理非工作场景下的消息。</p>\n<p>3、每天早上简单的概述自己今天需要完成的工作，并预估工作所需要的时间，适当的给自己一些相对较长的时间，在这个时间段内，尽量避免外界因素的干扰。每天早上和下午工作开始一小时后的是能够利用的长块时间，而且效率也比较高，尽量将重要性工作安排在这样的时间段进行，尽量避免在这样的时间段开会，以免降低工作效率。（例如，微软有一个go dark的机制，允许在某些特殊的情况下与外界因素隔离开，踏踏实实的沉浸到写代码中）。</p>\n<p>4、合理的利用等待期。在同时需要处理多个任务时，有的任务往往由于各种条件或资源尚不具备，这会需要花不少时间来等待，如果我们将置于等待期的任务提前规划、也是一种不错的方法。</p>\n<p>在《卓有成效的管理者》这本书中，将会管理自己的时间作为一个优秀管理者开始其管理工作的第一步，只有开始学会梳理自己的时间和管理自己的时间，才能成为合适的管理者，这一点我觉得非常有道理。</p>\n"},{"title":"如何快速融入团队并成为团队核心(六)","date":"2020-01-19T00:49:00.000Z","author":"邹溪源","_content":"# 一\n我总是在记忆深处探访那些拥有高效率团队的一切特征，并试图从纷繁复杂的记忆尘埃中找出一些共性，庆幸我已经习惯于通过阅读和思考来解读这些内容，我得以用两个关键性的词汇来描述这些点。那就是“目标管理”和“时间管理”。\n\n目标管理：表面上看，是执行者对于来自高层战略的解读，实际上是通过团队间反馈机制的建立，让团队能够快速的理解战略，并从而在执行过程中为团队带来行之有效解决方案。并通过在一次又一次的执行中落实到位，从而使得团队的目标都能协同发展，进而确保了组织的目标得以实现的整个过程。由于目标管理内容较为丰富，我将在下一篇文章中跟大家探讨这个问题。\n\n时间管理：源自每个人对于自身工作专注度、精力、时间的精细分配，以期高效的实现自己的时间控制。我将时间管理分为“控制自己的精力”，“控制会议”，“控制自己的时间”三个层面。\n\n# 二\n毋庸置疑，在这个资讯大爆炸的时代，我们所能收到的资讯其实已经远远超出了一个人正常所能吸纳的范围。例如，如果以某某头条作为我们的收集资讯的输入，那么可以想象，我们的每天24小时都可以被无限制的占满。甚至而言，如果这样的生活真的是我们生活的全部，我们其实也会觉得自身收获充足。\n\n因为那些来自头条的内容，难免会有一些能够给我们带来价值的内容，例如一些鸡汤或时政新闻或社会动态，通过分享这些内容，我们也获得了一些属于自己的收获。例如，我们会产生这样的错觉：还好我看到了这条消息，赶紧分享出去，不然我又会被人称为“Out”了。\n\n尤其是IT领域从业者，打开头条看到的哪些有关新技术的推文，总是让我们在那么一瞬间激情澎湃，设想如果我们的每天都沉浸在这些内容之中，我们的所谓“互联网技术格局”一定会得到巨大的提升。\n\n毕竟通过头条，使得我们能够在互联网新技术的一瞬间迅速“看到”；也有人分享面试经验和面试题，于是通过头条，那些大公司的面试题，我们都能很快看过；看起来只要我们想挑战，随时都可以去。\n\n我们在阅读技术文章的过程中，同样也像看到小说一般，沿着作者的笔触一起去踩坑，一起去解决问题，甚至有时候我们看到作者采取了一些独特的做法，还会一拍大腿，说这个傻逼作者，明显有更好的方法不用，为什么要用这种二逼方法，要我，一定会用从xxx方法（从其他文章中看到的方法）。\n\n有的技术文章写得特别优美，所描述的技术故事让读者心驰神往，却只有少数人能够把这些文章当种子，在自己的心灵深处发芽，在需要的时候使用这些方法来为自己公司解决问题；还有许多人，会把故事当成段子，以为自己已经成为了行业大佬，热衷于向别人分享。\n\n# 三\n然而，那些其实不过是我们自己找的“信息茧房”而已，并一点点的消耗掉我们原本就不多的精力。所谓“资讯大爆炸”，看起来能够给我们带来收获，但是不加过滤的无脑提取，只会让我们成长为一个又一个的思想上的胖子，行动上的矮子。或者，有点像宫崎骏电影《千与千寻》中的无脸男，他一开始个性单纯，乐于与人交往，却不懂得筛选、过滤有用的知识，并最终成长为一个怪物。 \n\n显然我们都知道，时间对每个人来说都是均衡的，我们难免想充分利用今天的时间，但也往往会立下许多不切实际的flag，并被抖X和头条把所有的剩余时间全部消耗殆尽，只有那么少数几个人能够真正把握时间的重要性，并充分利用时间，将自己的精力最大化。\n\n我曾向一位老师请教请教一本销量极广的IT书籍作者的高效工作方法，她说：这位老师确实很优秀，他每天几乎有处理不完的邮件，如果他把自己的精力全部投入到处理邮件上，那几乎很难获得今天的成就。正是因为他明白自己的精力有限，他明白哪些事情最重要，因此他能用最高效的方法完成自己工作，使得他能够在一堆混乱的事务中挑出最有价值的珍珠，从而实现了工作、生活的相对平衡。  \n\n确实如此，我也曾立了许多Flag，却发现大部分都实现不了，还不如每天就认真干好几件事，一点点的积累起来才更显得弥足珍贵。\n\n尤其是在通讯技术务必发达的今天，沉迷于社交成为许多人的通病，那么多的群，每个群都显得独一无二，有时候能够在其中发表几句看起来有想法的言论，能够获得大家的一些认同，你会认为自己的精神层面获得了极大的满足。\n\n不由得想起有人对人心弱点的评价：贪婪，自大，懒惰，缺乏自信心、容易焦虑、虚荣心。沉迷于群聊或社区，着实能够让人的自信心看起来得到满足，那也恰好体现了自己在自信心上的不足，才必须借助于这些廉价的方式来填补空白。\n\n社交群、公众号、头条等提供了海量内容，恰好能够满足我们的虚荣心，让我们以为自己看到的就是自己获得的、让我们以为社交网络的朋友圈，就是自己真实的朋友圈。\n\n再过几年，自己的热度过去，会不会觉得这是个笑话？\n\n# 四\n我们应当适度的控制自己的精力，让自己尽量专注的把手头的事情干好之余，再去干其他事情，我们应当学会从海量的信息中对信息进行过滤，提取出能够融入到自己灵魂中的宝贵知识，再一点点的对这些内容进行“重混”，形成自己的知识体系。\n\n管理精力，就是管理自己的时间。只有提高精力的专注度，才能充分利用时间，才更有利于打造“全面均衡”的个体。\n\n\n","source":"_posts/随笔/如何快速融入团队并成为团队核心（六）.md","raw":"---\ntitle:  如何快速融入团队并成为团队核心(六)\ndate: 2020-01-19 8:49\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n# 一\n我总是在记忆深处探访那些拥有高效率团队的一切特征，并试图从纷繁复杂的记忆尘埃中找出一些共性，庆幸我已经习惯于通过阅读和思考来解读这些内容，我得以用两个关键性的词汇来描述这些点。那就是“目标管理”和“时间管理”。\n\n目标管理：表面上看，是执行者对于来自高层战略的解读，实际上是通过团队间反馈机制的建立，让团队能够快速的理解战略，并从而在执行过程中为团队带来行之有效解决方案。并通过在一次又一次的执行中落实到位，从而使得团队的目标都能协同发展，进而确保了组织的目标得以实现的整个过程。由于目标管理内容较为丰富，我将在下一篇文章中跟大家探讨这个问题。\n\n时间管理：源自每个人对于自身工作专注度、精力、时间的精细分配，以期高效的实现自己的时间控制。我将时间管理分为“控制自己的精力”，“控制会议”，“控制自己的时间”三个层面。\n\n# 二\n毋庸置疑，在这个资讯大爆炸的时代，我们所能收到的资讯其实已经远远超出了一个人正常所能吸纳的范围。例如，如果以某某头条作为我们的收集资讯的输入，那么可以想象，我们的每天24小时都可以被无限制的占满。甚至而言，如果这样的生活真的是我们生活的全部，我们其实也会觉得自身收获充足。\n\n因为那些来自头条的内容，难免会有一些能够给我们带来价值的内容，例如一些鸡汤或时政新闻或社会动态，通过分享这些内容，我们也获得了一些属于自己的收获。例如，我们会产生这样的错觉：还好我看到了这条消息，赶紧分享出去，不然我又会被人称为“Out”了。\n\n尤其是IT领域从业者，打开头条看到的哪些有关新技术的推文，总是让我们在那么一瞬间激情澎湃，设想如果我们的每天都沉浸在这些内容之中，我们的所谓“互联网技术格局”一定会得到巨大的提升。\n\n毕竟通过头条，使得我们能够在互联网新技术的一瞬间迅速“看到”；也有人分享面试经验和面试题，于是通过头条，那些大公司的面试题，我们都能很快看过；看起来只要我们想挑战，随时都可以去。\n\n我们在阅读技术文章的过程中，同样也像看到小说一般，沿着作者的笔触一起去踩坑，一起去解决问题，甚至有时候我们看到作者采取了一些独特的做法，还会一拍大腿，说这个傻逼作者，明显有更好的方法不用，为什么要用这种二逼方法，要我，一定会用从xxx方法（从其他文章中看到的方法）。\n\n有的技术文章写得特别优美，所描述的技术故事让读者心驰神往，却只有少数人能够把这些文章当种子，在自己的心灵深处发芽，在需要的时候使用这些方法来为自己公司解决问题；还有许多人，会把故事当成段子，以为自己已经成为了行业大佬，热衷于向别人分享。\n\n# 三\n然而，那些其实不过是我们自己找的“信息茧房”而已，并一点点的消耗掉我们原本就不多的精力。所谓“资讯大爆炸”，看起来能够给我们带来收获，但是不加过滤的无脑提取，只会让我们成长为一个又一个的思想上的胖子，行动上的矮子。或者，有点像宫崎骏电影《千与千寻》中的无脸男，他一开始个性单纯，乐于与人交往，却不懂得筛选、过滤有用的知识，并最终成长为一个怪物。 \n\n显然我们都知道，时间对每个人来说都是均衡的，我们难免想充分利用今天的时间，但也往往会立下许多不切实际的flag，并被抖X和头条把所有的剩余时间全部消耗殆尽，只有那么少数几个人能够真正把握时间的重要性，并充分利用时间，将自己的精力最大化。\n\n我曾向一位老师请教请教一本销量极广的IT书籍作者的高效工作方法，她说：这位老师确实很优秀，他每天几乎有处理不完的邮件，如果他把自己的精力全部投入到处理邮件上，那几乎很难获得今天的成就。正是因为他明白自己的精力有限，他明白哪些事情最重要，因此他能用最高效的方法完成自己工作，使得他能够在一堆混乱的事务中挑出最有价值的珍珠，从而实现了工作、生活的相对平衡。  \n\n确实如此，我也曾立了许多Flag，却发现大部分都实现不了，还不如每天就认真干好几件事，一点点的积累起来才更显得弥足珍贵。\n\n尤其是在通讯技术务必发达的今天，沉迷于社交成为许多人的通病，那么多的群，每个群都显得独一无二，有时候能够在其中发表几句看起来有想法的言论，能够获得大家的一些认同，你会认为自己的精神层面获得了极大的满足。\n\n不由得想起有人对人心弱点的评价：贪婪，自大，懒惰，缺乏自信心、容易焦虑、虚荣心。沉迷于群聊或社区，着实能够让人的自信心看起来得到满足，那也恰好体现了自己在自信心上的不足，才必须借助于这些廉价的方式来填补空白。\n\n社交群、公众号、头条等提供了海量内容，恰好能够满足我们的虚荣心，让我们以为自己看到的就是自己获得的、让我们以为社交网络的朋友圈，就是自己真实的朋友圈。\n\n再过几年，自己的热度过去，会不会觉得这是个笑话？\n\n# 四\n我们应当适度的控制自己的精力，让自己尽量专注的把手头的事情干好之余，再去干其他事情，我们应当学会从海量的信息中对信息进行过滤，提取出能够融入到自己灵魂中的宝贵知识，再一点点的对这些内容进行“重混”，形成自己的知识体系。\n\n管理精力，就是管理自己的时间。只有提高精力的专注度，才能充分利用时间，才更有利于打造“全面均衡”的个体。\n\n\n","slug":"随笔/如何快速融入团队并成为团队核心（六）","published":1,"updated":"2020-01-19T00:57:18.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt9d0040n4vim47o4ge9","content":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>我总是在记忆深处探访那些拥有高效率团队的一切特征，并试图从纷繁复杂的记忆尘埃中找出一些共性，庆幸我已经习惯于通过阅读和思考来解读这些内容，我得以用两个关键性的词汇来描述这些点。那就是“目标管理”和“时间管理”。</p>\n<p>目标管理：表面上看，是执行者对于来自高层战略的解读，实际上是通过团队间反馈机制的建立，让团队能够快速的理解战略，并从而在执行过程中为团队带来行之有效解决方案。并通过在一次又一次的执行中落实到位，从而使得团队的目标都能协同发展，进而确保了组织的目标得以实现的整个过程。由于目标管理内容较为丰富，我将在下一篇文章中跟大家探讨这个问题。</p>\n<p>时间管理：源自每个人对于自身工作专注度、精力、时间的精细分配，以期高效的实现自己的时间控制。我将时间管理分为“控制自己的精力”，“控制会议”，“控制自己的时间”三个层面。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>毋庸置疑，在这个资讯大爆炸的时代，我们所能收到的资讯其实已经远远超出了一个人正常所能吸纳的范围。例如，如果以某某头条作为我们的收集资讯的输入，那么可以想象，我们的每天24小时都可以被无限制的占满。甚至而言，如果这样的生活真的是我们生活的全部，我们其实也会觉得自身收获充足。</p>\n<p>因为那些来自头条的内容，难免会有一些能够给我们带来价值的内容，例如一些鸡汤或时政新闻或社会动态，通过分享这些内容，我们也获得了一些属于自己的收获。例如，我们会产生这样的错觉：还好我看到了这条消息，赶紧分享出去，不然我又会被人称为“Out”了。</p>\n<p>尤其是IT领域从业者，打开头条看到的哪些有关新技术的推文，总是让我们在那么一瞬间激情澎湃，设想如果我们的每天都沉浸在这些内容之中，我们的所谓“互联网技术格局”一定会得到巨大的提升。</p>\n<p>毕竟通过头条，使得我们能够在互联网新技术的一瞬间迅速“看到”；也有人分享面试经验和面试题，于是通过头条，那些大公司的面试题，我们都能很快看过；看起来只要我们想挑战，随时都可以去。</p>\n<p>我们在阅读技术文章的过程中，同样也像看到小说一般，沿着作者的笔触一起去踩坑，一起去解决问题，甚至有时候我们看到作者采取了一些独特的做法，还会一拍大腿，说这个傻逼作者，明显有更好的方法不用，为什么要用这种二逼方法，要我，一定会用从xxx方法（从其他文章中看到的方法）。</p>\n<p>有的技术文章写得特别优美，所描述的技术故事让读者心驰神往，却只有少数人能够把这些文章当种子，在自己的心灵深处发芽，在需要的时候使用这些方法来为自己公司解决问题；还有许多人，会把故事当成段子，以为自己已经成为了行业大佬，热衷于向别人分享。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>然而，那些其实不过是我们自己找的“信息茧房”而已，并一点点的消耗掉我们原本就不多的精力。所谓“资讯大爆炸”，看起来能够给我们带来收获，但是不加过滤的无脑提取，只会让我们成长为一个又一个的思想上的胖子，行动上的矮子。或者，有点像宫崎骏电影《千与千寻》中的无脸男，他一开始个性单纯，乐于与人交往，却不懂得筛选、过滤有用的知识，并最终成长为一个怪物。 </p>\n<p>显然我们都知道，时间对每个人来说都是均衡的，我们难免想充分利用今天的时间，但也往往会立下许多不切实际的flag，并被抖X和头条把所有的剩余时间全部消耗殆尽，只有那么少数几个人能够真正把握时间的重要性，并充分利用时间，将自己的精力最大化。</p>\n<p>我曾向一位老师请教请教一本销量极广的IT书籍作者的高效工作方法，她说：这位老师确实很优秀，他每天几乎有处理不完的邮件，如果他把自己的精力全部投入到处理邮件上，那几乎很难获得今天的成就。正是因为他明白自己的精力有限，他明白哪些事情最重要，因此他能用最高效的方法完成自己工作，使得他能够在一堆混乱的事务中挑出最有价值的珍珠，从而实现了工作、生活的相对平衡。  </p>\n<p>确实如此，我也曾立了许多Flag，却发现大部分都实现不了，还不如每天就认真干好几件事，一点点的积累起来才更显得弥足珍贵。</p>\n<p>尤其是在通讯技术务必发达的今天，沉迷于社交成为许多人的通病，那么多的群，每个群都显得独一无二，有时候能够在其中发表几句看起来有想法的言论，能够获得大家的一些认同，你会认为自己的精神层面获得了极大的满足。</p>\n<p>不由得想起有人对人心弱点的评价：贪婪，自大，懒惰，缺乏自信心、容易焦虑、虚荣心。沉迷于群聊或社区，着实能够让人的自信心看起来得到满足，那也恰好体现了自己在自信心上的不足，才必须借助于这些廉价的方式来填补空白。</p>\n<p>社交群、公众号、头条等提供了海量内容，恰好能够满足我们的虚荣心，让我们以为自己看到的就是自己获得的、让我们以为社交网络的朋友圈，就是自己真实的朋友圈。</p>\n<p>再过几年，自己的热度过去，会不会觉得这是个笑话？</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>我们应当适度的控制自己的精力，让自己尽量专注的把手头的事情干好之余，再去干其他事情，我们应当学会从海量的信息中对信息进行过滤，提取出能够融入到自己灵魂中的宝贵知识，再一点点的对这些内容进行“重混”，形成自己的知识体系。</p>\n<p>管理精力，就是管理自己的时间。只有提高精力的专注度，才能充分利用时间，才更有利于打造“全面均衡”的个体。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>我总是在记忆深处探访那些拥有高效率团队的一切特征，并试图从纷繁复杂的记忆尘埃中找出一些共性，庆幸我已经习惯于通过阅读和思考来解读这些内容，我得以用两个关键性的词汇来描述这些点。那就是“目标管理”和“时间管理”。</p>\n<p>目标管理：表面上看，是执行者对于来自高层战略的解读，实际上是通过团队间反馈机制的建立，让团队能够快速的理解战略，并从而在执行过程中为团队带来行之有效解决方案。并通过在一次又一次的执行中落实到位，从而使得团队的目标都能协同发展，进而确保了组织的目标得以实现的整个过程。由于目标管理内容较为丰富，我将在下一篇文章中跟大家探讨这个问题。</p>\n<p>时间管理：源自每个人对于自身工作专注度、精力、时间的精细分配，以期高效的实现自己的时间控制。我将时间管理分为“控制自己的精力”，“控制会议”，“控制自己的时间”三个层面。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>毋庸置疑，在这个资讯大爆炸的时代，我们所能收到的资讯其实已经远远超出了一个人正常所能吸纳的范围。例如，如果以某某头条作为我们的收集资讯的输入，那么可以想象，我们的每天24小时都可以被无限制的占满。甚至而言，如果这样的生活真的是我们生活的全部，我们其实也会觉得自身收获充足。</p>\n<p>因为那些来自头条的内容，难免会有一些能够给我们带来价值的内容，例如一些鸡汤或时政新闻或社会动态，通过分享这些内容，我们也获得了一些属于自己的收获。例如，我们会产生这样的错觉：还好我看到了这条消息，赶紧分享出去，不然我又会被人称为“Out”了。</p>\n<p>尤其是IT领域从业者，打开头条看到的哪些有关新技术的推文，总是让我们在那么一瞬间激情澎湃，设想如果我们的每天都沉浸在这些内容之中，我们的所谓“互联网技术格局”一定会得到巨大的提升。</p>\n<p>毕竟通过头条，使得我们能够在互联网新技术的一瞬间迅速“看到”；也有人分享面试经验和面试题，于是通过头条，那些大公司的面试题，我们都能很快看过；看起来只要我们想挑战，随时都可以去。</p>\n<p>我们在阅读技术文章的过程中，同样也像看到小说一般，沿着作者的笔触一起去踩坑，一起去解决问题，甚至有时候我们看到作者采取了一些独特的做法，还会一拍大腿，说这个傻逼作者，明显有更好的方法不用，为什么要用这种二逼方法，要我，一定会用从xxx方法（从其他文章中看到的方法）。</p>\n<p>有的技术文章写得特别优美，所描述的技术故事让读者心驰神往，却只有少数人能够把这些文章当种子，在自己的心灵深处发芽，在需要的时候使用这些方法来为自己公司解决问题；还有许多人，会把故事当成段子，以为自己已经成为了行业大佬，热衷于向别人分享。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>然而，那些其实不过是我们自己找的“信息茧房”而已，并一点点的消耗掉我们原本就不多的精力。所谓“资讯大爆炸”，看起来能够给我们带来收获，但是不加过滤的无脑提取，只会让我们成长为一个又一个的思想上的胖子，行动上的矮子。或者，有点像宫崎骏电影《千与千寻》中的无脸男，他一开始个性单纯，乐于与人交往，却不懂得筛选、过滤有用的知识，并最终成长为一个怪物。 </p>\n<p>显然我们都知道，时间对每个人来说都是均衡的，我们难免想充分利用今天的时间，但也往往会立下许多不切实际的flag，并被抖X和头条把所有的剩余时间全部消耗殆尽，只有那么少数几个人能够真正把握时间的重要性，并充分利用时间，将自己的精力最大化。</p>\n<p>我曾向一位老师请教请教一本销量极广的IT书籍作者的高效工作方法，她说：这位老师确实很优秀，他每天几乎有处理不完的邮件，如果他把自己的精力全部投入到处理邮件上，那几乎很难获得今天的成就。正是因为他明白自己的精力有限，他明白哪些事情最重要，因此他能用最高效的方法完成自己工作，使得他能够在一堆混乱的事务中挑出最有价值的珍珠，从而实现了工作、生活的相对平衡。  </p>\n<p>确实如此，我也曾立了许多Flag，却发现大部分都实现不了，还不如每天就认真干好几件事，一点点的积累起来才更显得弥足珍贵。</p>\n<p>尤其是在通讯技术务必发达的今天，沉迷于社交成为许多人的通病，那么多的群，每个群都显得独一无二，有时候能够在其中发表几句看起来有想法的言论，能够获得大家的一些认同，你会认为自己的精神层面获得了极大的满足。</p>\n<p>不由得想起有人对人心弱点的评价：贪婪，自大，懒惰，缺乏自信心、容易焦虑、虚荣心。沉迷于群聊或社区，着实能够让人的自信心看起来得到满足，那也恰好体现了自己在自信心上的不足，才必须借助于这些廉价的方式来填补空白。</p>\n<p>社交群、公众号、头条等提供了海量内容，恰好能够满足我们的虚荣心，让我们以为自己看到的就是自己获得的、让我们以为社交网络的朋友圈，就是自己真实的朋友圈。</p>\n<p>再过几年，自己的热度过去，会不会觉得这是个笑话？</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>我们应当适度的控制自己的精力，让自己尽量专注的把手头的事情干好之余，再去干其他事情，我们应当学会从海量的信息中对信息进行过滤，提取出能够融入到自己灵魂中的宝贵知识，再一点点的对这些内容进行“重混”，形成自己的知识体系。</p>\n<p>管理精力，就是管理自己的时间。只有提高精力的专注度，才能充分利用时间，才更有利于打造“全面均衡”的个体。</p>\n"},{"title":"如何快速融入团队并成为团队核心(四)","date":"2020-01-19T00:48:00.000Z","author":"邹溪源","_content":"# 一\n不知不觉这个系列已经开始第四篇的，其实我的原始意图只是思考一下如果有幸加入一个新团队，我们在思想和行动上该做哪些准备呢。不过随着内容的逐渐发散，已经衍生成为“如何从加入团队”到思考“如何让团队易于使人加入”的问题。\n\n这其实首先是个组织建设的问题，表现出来就是“使命”、“愿景”、“价值观”、“企业文化”、“企业基因”、“江湖规矩”，其次就是一个团队建设的问题。\n\n![图片](https://uploader.shimo.im/f/CwfLc7YbZzcidU6o.jpg!thumbnail)\n\n# 二\n团队建设，其实无处不在，他在每一天无时无刻都在开展，如果说企业文化建设是构建企业赖以为生的精神食粮，那么团队建设就是为了增强体魄。团队建设好不好，并非是某些部门的事、也并非领导个人的事，实际上是大家都在参与的事情。一支拥有战斗力的团队，并非仅仅惠及领导或企业，实际上也在惠及团队中参与的每个人。\n\n从某种意义上讲，团队建设的目的，并非仅仅是为了构建团队，更是为了让团队中的每个人都能在所谓“建设”中得到成长。华为致力于打造狼性的团队文化，显然不仅仅是为了商业层面的战斗力提升，而是通过让狼性的团队文化深入到团队每一个人的灵魂中，让团队中的每个人都成为值得彼此信赖的人，并最终实现了企业在商业层面的巨大成功。当然，华为人同样也有离职或跳槽的，当他们离开华为，前往其他公司时，也把从华为汲取到的宝贵财富带动了其他团队，进而促进了其他团队的进一步发展。这恰好说明，团队建设的目的，并非是为了建设一个单个团队，而是先建设好个人，其次才能建设好团队。\n\n“三人行，必有我师焉”，我们曾经一度以为，学习是从课堂中学习开始、再学习我们的长辈、学习我们的主管领导、或者学习我们的老板，其实并非如此，学习是发生在每一瞬间，是人类有别于其他生物的一种本能，我们无时无刻不在学习，而在企业中共处时，我们的学习行为也本身就是团队建设的一部分。团队中的每个人，都能成为我们值得学习的一部分，也许他们在某些点上看不出优点，但是往往在其他点上散发出灼热的光芒。\n\n每个人并非生来就是完美的人，而是经过数十年的成长，在日常生活、人际交往、职场中吸取到我们身边其他人身上的优点，然后用其他人的优点构成自己的优点和灵魂，并最终趋于个体健全。同时，我们也把自己的优点投影到其他人的世界中，也在促进其他人的成长。\n\n事实上团队不仅仅是公司的一个部门，我们的一个社区、家庭、或者一个关系融洽的小组织，其实都是一个团队。而当我们加入这一的小组织时，团队建设就已经开始了，我们的一言一行，既对别人产生了影响，而别人的一言一行，也同样对我们产生了影响。\n\n有时每个人都期待与最优秀的人为伍，总觉得那些优秀的人一定无时无刻都在散发着主角的光辉，我们只需从他们散发的光辉中，汲取那么一点点就足以使我们成为一个优秀的个体。其实往往我们应该相信，我们所加入的每个团队其实都是优秀的团队，我们自身每个人都是优秀的个体，只需采取适当的引导措施，都能创造出足够优秀的成绩。\n\n# 三\n布鲁斯·塔克曼将团队建设的过程划分为五个阶段，虽然这个理论已经诞生已经快50年了，但是迄今依然散发着蓊郁的芬芳，可以称为团队建设领域的一块丰碑。他将团队建设划分为“形成期”、“震荡期”、“稳定期”、“规范期”、“稳定期”，他认为每个阶段都是必须、不可逾越的，每个团队的组建过程往往都必须经过这五个阶段。\n\n当然，塔克曼的团队发展阶段理论主要使用于小型团队，但在本文中主要借用来形容一个团队的发展阶段，并非本文的主要内容。\n\n## 形成期\n团队初步建立，人员刚刚加入、或有新的人员加入，还需要对彼此进行认识，了解团队和组织的文化，逐步建立起团队基本的信任过程。在这个阶段人员间往往会比较独立，无法开诚布公的交流问题。团队存在焦虑心理，对团队的发展比较迷茫、甚至不稳定。\n\n## 震荡期\n初步形成了各种观念，并逐步的认识彼此，但是会存在震荡和观点上的碰撞，甚至由于某些技术性的观点会产生一定的冲突。而冲突实际上是说明团队间已经开始寻找彼此沟通的方式，并逐步的适应对方。\n\n## 规范期\n形成了团队的沟通方式和团队文化，团队成员都逐步认识自己在团队中所能承担的角色，并能够为了完成一致的目标而做出自己的努力，在这个阶段彼此间能够流畅自如的进行沟通和任务的执行，并能表现出所具有的一定的自治性。\n\n## 稳定期\n团队运作如同一个整体，彼此沟通融洽，团队能量凝聚一起，彼此间形成的团队能力能够顺利的对任务进行解读并完成目标，同时团队由于已经建立了基本的沟通规则，在一般的事务性问题上已经能够非常独立自治的解决问题。这也是一个战斗力强的团队所具有的基本形态。事实上如果在这个阶段再引入新来的成员，也将重新尽力从形成期开始的阶段。\n\n## 解散期\n又称为“休整期”，任务完成后，团队即将解散，彼此非常珍惜过去来之不易的相处时光，也难免产生失落感。一部分成员将离开团队，团队的战斗力将造成一定的影响，成员对于未来的不确定性将开始逐步占上风。\n\n# 四\n某种意义上上讲，一个团队的形成，有时候像“三个和尚挑水喝”的古老谚语，毋庸置疑，人越少越容易团结、越容易管理、也容易形成自己的团队文化，而团队规模的逐渐增长，也看似会引发这样或那样的问题。尤其是中国人的典型特点，也曾经是在个体时往往具备非常不错的单兵作战能力，但是以集体的形式，会比较难以磨合。\n\n尤其是如果奢望在一个团队中，都是一群优秀的人，其实不太现实，过于优秀的单兵能力凝聚起来，就像是三体星一样，能够维持短期的稳定，却也暗含着不稳定。\n\n![图片](https://uploader.shimo.im/f/KaSaWbSc7UY3H9PA.gif)\n\n（图片来自《DotNET骚操作》公众号，博主说等30秒钟就能看到三体星溃散的效果了。）\n\n而且有时候又渴望通过一定的控制力来维系团队的平衡，其实不见得能产生很好的效果，在一个看似稳定的组织中，引入一些强有力的措施，有时或许会产生下面的效果：\n\n![图片](https://uploader.shimo.im/f/ndnXASWWYU0llrq3.jpeg!thumbnail)\n\n即在一个稳定的平面空间中，引入了一个重量级的“太阳”，自然而然会对空间和时间产生扭曲力，从而破坏原来平等的局面。\n\n当然，有时候引入“太阳”是必要的。\n\n# 五\n团队建设者不应该奢求依托强大的“组织机器”的力量来维系组织的平衡，有时候团队建设更是应该使用“上善若水”的精神，用如水般柔和的力量为团队间营造一种积极交流、互相倾听的文化，让彼此间能够成为对方的信赖。\n\n例如2019年听闻的“滴滴”北京团队组团游野长城，结果被困的消息，大概体现了团队建设者操之过急的团队建设心态吧。\n\n而同样作为团队建设者的我曾经在组织中实践过一种这样的方法，由于我们小团队的人员来源于不同的公司，年龄也有不同，（30岁居多），所以我试图利用每天给大家倒开水泡枸杞这个小细节来建立起团队基本的沟通方式，除此之外，也建立了一系列操作手法，使得不同经验的人都能够在团队中把自己的有点表现出来，从而使得团队间易于破冰，并打造出了一个具有战斗力的小团队。\n\n团队建设不拘泥于形式，每一个细节其实都可以表现出来。每天上班的一声问候、饭局上的互相寒暄，有意无意的引导，以及适度的积极倾听，把团队的每个人都当做你的家庭成员，可以用的方法太多了。\n\n不要再动不动就选择吃饭了。。多俗气啊~\n\n","source":"_posts/随笔/如何快速融入团队并成为团队核心（四）.md","raw":"---\ntitle:  如何快速融入团队并成为团队核心(四)\ndate: 2020-01-19 8:48\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n# 一\n不知不觉这个系列已经开始第四篇的，其实我的原始意图只是思考一下如果有幸加入一个新团队，我们在思想和行动上该做哪些准备呢。不过随着内容的逐渐发散，已经衍生成为“如何从加入团队”到思考“如何让团队易于使人加入”的问题。\n\n这其实首先是个组织建设的问题，表现出来就是“使命”、“愿景”、“价值观”、“企业文化”、“企业基因”、“江湖规矩”，其次就是一个团队建设的问题。\n\n![图片](https://uploader.shimo.im/f/CwfLc7YbZzcidU6o.jpg!thumbnail)\n\n# 二\n团队建设，其实无处不在，他在每一天无时无刻都在开展，如果说企业文化建设是构建企业赖以为生的精神食粮，那么团队建设就是为了增强体魄。团队建设好不好，并非是某些部门的事、也并非领导个人的事，实际上是大家都在参与的事情。一支拥有战斗力的团队，并非仅仅惠及领导或企业，实际上也在惠及团队中参与的每个人。\n\n从某种意义上讲，团队建设的目的，并非仅仅是为了构建团队，更是为了让团队中的每个人都能在所谓“建设”中得到成长。华为致力于打造狼性的团队文化，显然不仅仅是为了商业层面的战斗力提升，而是通过让狼性的团队文化深入到团队每一个人的灵魂中，让团队中的每个人都成为值得彼此信赖的人，并最终实现了企业在商业层面的巨大成功。当然，华为人同样也有离职或跳槽的，当他们离开华为，前往其他公司时，也把从华为汲取到的宝贵财富带动了其他团队，进而促进了其他团队的进一步发展。这恰好说明，团队建设的目的，并非是为了建设一个单个团队，而是先建设好个人，其次才能建设好团队。\n\n“三人行，必有我师焉”，我们曾经一度以为，学习是从课堂中学习开始、再学习我们的长辈、学习我们的主管领导、或者学习我们的老板，其实并非如此，学习是发生在每一瞬间，是人类有别于其他生物的一种本能，我们无时无刻不在学习，而在企业中共处时，我们的学习行为也本身就是团队建设的一部分。团队中的每个人，都能成为我们值得学习的一部分，也许他们在某些点上看不出优点，但是往往在其他点上散发出灼热的光芒。\n\n每个人并非生来就是完美的人，而是经过数十年的成长，在日常生活、人际交往、职场中吸取到我们身边其他人身上的优点，然后用其他人的优点构成自己的优点和灵魂，并最终趋于个体健全。同时，我们也把自己的优点投影到其他人的世界中，也在促进其他人的成长。\n\n事实上团队不仅仅是公司的一个部门，我们的一个社区、家庭、或者一个关系融洽的小组织，其实都是一个团队。而当我们加入这一的小组织时，团队建设就已经开始了，我们的一言一行，既对别人产生了影响，而别人的一言一行，也同样对我们产生了影响。\n\n有时每个人都期待与最优秀的人为伍，总觉得那些优秀的人一定无时无刻都在散发着主角的光辉，我们只需从他们散发的光辉中，汲取那么一点点就足以使我们成为一个优秀的个体。其实往往我们应该相信，我们所加入的每个团队其实都是优秀的团队，我们自身每个人都是优秀的个体，只需采取适当的引导措施，都能创造出足够优秀的成绩。\n\n# 三\n布鲁斯·塔克曼将团队建设的过程划分为五个阶段，虽然这个理论已经诞生已经快50年了，但是迄今依然散发着蓊郁的芬芳，可以称为团队建设领域的一块丰碑。他将团队建设划分为“形成期”、“震荡期”、“稳定期”、“规范期”、“稳定期”，他认为每个阶段都是必须、不可逾越的，每个团队的组建过程往往都必须经过这五个阶段。\n\n当然，塔克曼的团队发展阶段理论主要使用于小型团队，但在本文中主要借用来形容一个团队的发展阶段，并非本文的主要内容。\n\n## 形成期\n团队初步建立，人员刚刚加入、或有新的人员加入，还需要对彼此进行认识，了解团队和组织的文化，逐步建立起团队基本的信任过程。在这个阶段人员间往往会比较独立，无法开诚布公的交流问题。团队存在焦虑心理，对团队的发展比较迷茫、甚至不稳定。\n\n## 震荡期\n初步形成了各种观念，并逐步的认识彼此，但是会存在震荡和观点上的碰撞，甚至由于某些技术性的观点会产生一定的冲突。而冲突实际上是说明团队间已经开始寻找彼此沟通的方式，并逐步的适应对方。\n\n## 规范期\n形成了团队的沟通方式和团队文化，团队成员都逐步认识自己在团队中所能承担的角色，并能够为了完成一致的目标而做出自己的努力，在这个阶段彼此间能够流畅自如的进行沟通和任务的执行，并能表现出所具有的一定的自治性。\n\n## 稳定期\n团队运作如同一个整体，彼此沟通融洽，团队能量凝聚一起，彼此间形成的团队能力能够顺利的对任务进行解读并完成目标，同时团队由于已经建立了基本的沟通规则，在一般的事务性问题上已经能够非常独立自治的解决问题。这也是一个战斗力强的团队所具有的基本形态。事实上如果在这个阶段再引入新来的成员，也将重新尽力从形成期开始的阶段。\n\n## 解散期\n又称为“休整期”，任务完成后，团队即将解散，彼此非常珍惜过去来之不易的相处时光，也难免产生失落感。一部分成员将离开团队，团队的战斗力将造成一定的影响，成员对于未来的不确定性将开始逐步占上风。\n\n# 四\n某种意义上上讲，一个团队的形成，有时候像“三个和尚挑水喝”的古老谚语，毋庸置疑，人越少越容易团结、越容易管理、也容易形成自己的团队文化，而团队规模的逐渐增长，也看似会引发这样或那样的问题。尤其是中国人的典型特点，也曾经是在个体时往往具备非常不错的单兵作战能力，但是以集体的形式，会比较难以磨合。\n\n尤其是如果奢望在一个团队中，都是一群优秀的人，其实不太现实，过于优秀的单兵能力凝聚起来，就像是三体星一样，能够维持短期的稳定，却也暗含着不稳定。\n\n![图片](https://uploader.shimo.im/f/KaSaWbSc7UY3H9PA.gif)\n\n（图片来自《DotNET骚操作》公众号，博主说等30秒钟就能看到三体星溃散的效果了。）\n\n而且有时候又渴望通过一定的控制力来维系团队的平衡，其实不见得能产生很好的效果，在一个看似稳定的组织中，引入一些强有力的措施，有时或许会产生下面的效果：\n\n![图片](https://uploader.shimo.im/f/ndnXASWWYU0llrq3.jpeg!thumbnail)\n\n即在一个稳定的平面空间中，引入了一个重量级的“太阳”，自然而然会对空间和时间产生扭曲力，从而破坏原来平等的局面。\n\n当然，有时候引入“太阳”是必要的。\n\n# 五\n团队建设者不应该奢求依托强大的“组织机器”的力量来维系组织的平衡，有时候团队建设更是应该使用“上善若水”的精神，用如水般柔和的力量为团队间营造一种积极交流、互相倾听的文化，让彼此间能够成为对方的信赖。\n\n例如2019年听闻的“滴滴”北京团队组团游野长城，结果被困的消息，大概体现了团队建设者操之过急的团队建设心态吧。\n\n而同样作为团队建设者的我曾经在组织中实践过一种这样的方法，由于我们小团队的人员来源于不同的公司，年龄也有不同，（30岁居多），所以我试图利用每天给大家倒开水泡枸杞这个小细节来建立起团队基本的沟通方式，除此之外，也建立了一系列操作手法，使得不同经验的人都能够在团队中把自己的有点表现出来，从而使得团队间易于破冰，并打造出了一个具有战斗力的小团队。\n\n团队建设不拘泥于形式，每一个细节其实都可以表现出来。每天上班的一声问候、饭局上的互相寒暄，有意无意的引导，以及适度的积极倾听，把团队的每个人都当做你的家庭成员，可以用的方法太多了。\n\n不要再动不动就选择吃饭了。。多俗气啊~\n\n","slug":"随笔/如何快速融入团队并成为团队核心（四）","published":1,"updated":"2020-01-19T00:47:52.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt9e0043n4viynnstal1","content":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>不知不觉这个系列已经开始第四篇的，其实我的原始意图只是思考一下如果有幸加入一个新团队，我们在思想和行动上该做哪些准备呢。不过随着内容的逐渐发散，已经衍生成为“如何从加入团队”到思考“如何让团队易于使人加入”的问题。</p>\n<p>这其实首先是个组织建设的问题，表现出来就是“使命”、“愿景”、“价值观”、“企业文化”、“企业基因”、“江湖规矩”，其次就是一个团队建设的问题。</p>\n<p><img src=\"https://uploader.shimo.im/f/CwfLc7YbZzcidU6o.jpg!thumbnail\" alt=\"图片\"></p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>团队建设，其实无处不在，他在每一天无时无刻都在开展，如果说企业文化建设是构建企业赖以为生的精神食粮，那么团队建设就是为了增强体魄。团队建设好不好，并非是某些部门的事、也并非领导个人的事，实际上是大家都在参与的事情。一支拥有战斗力的团队，并非仅仅惠及领导或企业，实际上也在惠及团队中参与的每个人。</p>\n<p>从某种意义上讲，团队建设的目的，并非仅仅是为了构建团队，更是为了让团队中的每个人都能在所谓“建设”中得到成长。华为致力于打造狼性的团队文化，显然不仅仅是为了商业层面的战斗力提升，而是通过让狼性的团队文化深入到团队每一个人的灵魂中，让团队中的每个人都成为值得彼此信赖的人，并最终实现了企业在商业层面的巨大成功。当然，华为人同样也有离职或跳槽的，当他们离开华为，前往其他公司时，也把从华为汲取到的宝贵财富带动了其他团队，进而促进了其他团队的进一步发展。这恰好说明，团队建设的目的，并非是为了建设一个单个团队，而是先建设好个人，其次才能建设好团队。</p>\n<p>“三人行，必有我师焉”，我们曾经一度以为，学习是从课堂中学习开始、再学习我们的长辈、学习我们的主管领导、或者学习我们的老板，其实并非如此，学习是发生在每一瞬间，是人类有别于其他生物的一种本能，我们无时无刻不在学习，而在企业中共处时，我们的学习行为也本身就是团队建设的一部分。团队中的每个人，都能成为我们值得学习的一部分，也许他们在某些点上看不出优点，但是往往在其他点上散发出灼热的光芒。</p>\n<p>每个人并非生来就是完美的人，而是经过数十年的成长，在日常生活、人际交往、职场中吸取到我们身边其他人身上的优点，然后用其他人的优点构成自己的优点和灵魂，并最终趋于个体健全。同时，我们也把自己的优点投影到其他人的世界中，也在促进其他人的成长。</p>\n<p>事实上团队不仅仅是公司的一个部门，我们的一个社区、家庭、或者一个关系融洽的小组织，其实都是一个团队。而当我们加入这一的小组织时，团队建设就已经开始了，我们的一言一行，既对别人产生了影响，而别人的一言一行，也同样对我们产生了影响。</p>\n<p>有时每个人都期待与最优秀的人为伍，总觉得那些优秀的人一定无时无刻都在散发着主角的光辉，我们只需从他们散发的光辉中，汲取那么一点点就足以使我们成为一个优秀的个体。其实往往我们应该相信，我们所加入的每个团队其实都是优秀的团队，我们自身每个人都是优秀的个体，只需采取适当的引导措施，都能创造出足够优秀的成绩。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>布鲁斯·塔克曼将团队建设的过程划分为五个阶段，虽然这个理论已经诞生已经快50年了，但是迄今依然散发着蓊郁的芬芳，可以称为团队建设领域的一块丰碑。他将团队建设划分为“形成期”、“震荡期”、“稳定期”、“规范期”、“稳定期”，他认为每个阶段都是必须、不可逾越的，每个团队的组建过程往往都必须经过这五个阶段。</p>\n<p>当然，塔克曼的团队发展阶段理论主要使用于小型团队，但在本文中主要借用来形容一个团队的发展阶段，并非本文的主要内容。</p>\n<h2 id=\"形成期\"><a href=\"#形成期\" class=\"headerlink\" title=\"形成期\"></a>形成期</h2><p>团队初步建立，人员刚刚加入、或有新的人员加入，还需要对彼此进行认识，了解团队和组织的文化，逐步建立起团队基本的信任过程。在这个阶段人员间往往会比较独立，无法开诚布公的交流问题。团队存在焦虑心理，对团队的发展比较迷茫、甚至不稳定。</p>\n<h2 id=\"震荡期\"><a href=\"#震荡期\" class=\"headerlink\" title=\"震荡期\"></a>震荡期</h2><p>初步形成了各种观念，并逐步的认识彼此，但是会存在震荡和观点上的碰撞，甚至由于某些技术性的观点会产生一定的冲突。而冲突实际上是说明团队间已经开始寻找彼此沟通的方式，并逐步的适应对方。</p>\n<h2 id=\"规范期\"><a href=\"#规范期\" class=\"headerlink\" title=\"规范期\"></a>规范期</h2><p>形成了团队的沟通方式和团队文化，团队成员都逐步认识自己在团队中所能承担的角色，并能够为了完成一致的目标而做出自己的努力，在这个阶段彼此间能够流畅自如的进行沟通和任务的执行，并能表现出所具有的一定的自治性。</p>\n<h2 id=\"稳定期\"><a href=\"#稳定期\" class=\"headerlink\" title=\"稳定期\"></a>稳定期</h2><p>团队运作如同一个整体，彼此沟通融洽，团队能量凝聚一起，彼此间形成的团队能力能够顺利的对任务进行解读并完成目标，同时团队由于已经建立了基本的沟通规则，在一般的事务性问题上已经能够非常独立自治的解决问题。这也是一个战斗力强的团队所具有的基本形态。事实上如果在这个阶段再引入新来的成员，也将重新尽力从形成期开始的阶段。</p>\n<h2 id=\"解散期\"><a href=\"#解散期\" class=\"headerlink\" title=\"解散期\"></a>解散期</h2><p>又称为“休整期”，任务完成后，团队即将解散，彼此非常珍惜过去来之不易的相处时光，也难免产生失落感。一部分成员将离开团队，团队的战斗力将造成一定的影响，成员对于未来的不确定性将开始逐步占上风。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>某种意义上上讲，一个团队的形成，有时候像“三个和尚挑水喝”的古老谚语，毋庸置疑，人越少越容易团结、越容易管理、也容易形成自己的团队文化，而团队规模的逐渐增长，也看似会引发这样或那样的问题。尤其是中国人的典型特点，也曾经是在个体时往往具备非常不错的单兵作战能力，但是以集体的形式，会比较难以磨合。</p>\n<p>尤其是如果奢望在一个团队中，都是一群优秀的人，其实不太现实，过于优秀的单兵能力凝聚起来，就像是三体星一样，能够维持短期的稳定，却也暗含着不稳定。</p>\n<p><img src=\"https://uploader.shimo.im/f/KaSaWbSc7UY3H9PA.gif\" alt=\"图片\"></p>\n<p>（图片来自《DotNET骚操作》公众号，博主说等30秒钟就能看到三体星溃散的效果了。）</p>\n<p>而且有时候又渴望通过一定的控制力来维系团队的平衡，其实不见得能产生很好的效果，在一个看似稳定的组织中，引入一些强有力的措施，有时或许会产生下面的效果：</p>\n<p><img src=\"https://uploader.shimo.im/f/ndnXASWWYU0llrq3.jpeg!thumbnail\" alt=\"图片\"></p>\n<p>即在一个稳定的平面空间中，引入了一个重量级的“太阳”，自然而然会对空间和时间产生扭曲力，从而破坏原来平等的局面。</p>\n<p>当然，有时候引入“太阳”是必要的。</p>\n<h1 id=\"五\"><a href=\"#五\" class=\"headerlink\" title=\"五\"></a>五</h1><p>团队建设者不应该奢求依托强大的“组织机器”的力量来维系组织的平衡，有时候团队建设更是应该使用“上善若水”的精神，用如水般柔和的力量为团队间营造一种积极交流、互相倾听的文化，让彼此间能够成为对方的信赖。</p>\n<p>例如2019年听闻的“滴滴”北京团队组团游野长城，结果被困的消息，大概体现了团队建设者操之过急的团队建设心态吧。</p>\n<p>而同样作为团队建设者的我曾经在组织中实践过一种这样的方法，由于我们小团队的人员来源于不同的公司，年龄也有不同，（30岁居多），所以我试图利用每天给大家倒开水泡枸杞这个小细节来建立起团队基本的沟通方式，除此之外，也建立了一系列操作手法，使得不同经验的人都能够在团队中把自己的有点表现出来，从而使得团队间易于破冰，并打造出了一个具有战斗力的小团队。</p>\n<p>团队建设不拘泥于形式，每一个细节其实都可以表现出来。每天上班的一声问候、饭局上的互相寒暄，有意无意的引导，以及适度的积极倾听，把团队的每个人都当做你的家庭成员，可以用的方法太多了。</p>\n<p>不要再动不动就选择吃饭了。。多俗气啊~</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>不知不觉这个系列已经开始第四篇的，其实我的原始意图只是思考一下如果有幸加入一个新团队，我们在思想和行动上该做哪些准备呢。不过随着内容的逐渐发散，已经衍生成为“如何从加入团队”到思考“如何让团队易于使人加入”的问题。</p>\n<p>这其实首先是个组织建设的问题，表现出来就是“使命”、“愿景”、“价值观”、“企业文化”、“企业基因”、“江湖规矩”，其次就是一个团队建设的问题。</p>\n<p><img src=\"https://uploader.shimo.im/f/CwfLc7YbZzcidU6o.jpg!thumbnail\" alt=\"图片\"></p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>团队建设，其实无处不在，他在每一天无时无刻都在开展，如果说企业文化建设是构建企业赖以为生的精神食粮，那么团队建设就是为了增强体魄。团队建设好不好，并非是某些部门的事、也并非领导个人的事，实际上是大家都在参与的事情。一支拥有战斗力的团队，并非仅仅惠及领导或企业，实际上也在惠及团队中参与的每个人。</p>\n<p>从某种意义上讲，团队建设的目的，并非仅仅是为了构建团队，更是为了让团队中的每个人都能在所谓“建设”中得到成长。华为致力于打造狼性的团队文化，显然不仅仅是为了商业层面的战斗力提升，而是通过让狼性的团队文化深入到团队每一个人的灵魂中，让团队中的每个人都成为值得彼此信赖的人，并最终实现了企业在商业层面的巨大成功。当然，华为人同样也有离职或跳槽的，当他们离开华为，前往其他公司时，也把从华为汲取到的宝贵财富带动了其他团队，进而促进了其他团队的进一步发展。这恰好说明，团队建设的目的，并非是为了建设一个单个团队，而是先建设好个人，其次才能建设好团队。</p>\n<p>“三人行，必有我师焉”，我们曾经一度以为，学习是从课堂中学习开始、再学习我们的长辈、学习我们的主管领导、或者学习我们的老板，其实并非如此，学习是发生在每一瞬间，是人类有别于其他生物的一种本能，我们无时无刻不在学习，而在企业中共处时，我们的学习行为也本身就是团队建设的一部分。团队中的每个人，都能成为我们值得学习的一部分，也许他们在某些点上看不出优点，但是往往在其他点上散发出灼热的光芒。</p>\n<p>每个人并非生来就是完美的人，而是经过数十年的成长，在日常生活、人际交往、职场中吸取到我们身边其他人身上的优点，然后用其他人的优点构成自己的优点和灵魂，并最终趋于个体健全。同时，我们也把自己的优点投影到其他人的世界中，也在促进其他人的成长。</p>\n<p>事实上团队不仅仅是公司的一个部门，我们的一个社区、家庭、或者一个关系融洽的小组织，其实都是一个团队。而当我们加入这一的小组织时，团队建设就已经开始了，我们的一言一行，既对别人产生了影响，而别人的一言一行，也同样对我们产生了影响。</p>\n<p>有时每个人都期待与最优秀的人为伍，总觉得那些优秀的人一定无时无刻都在散发着主角的光辉，我们只需从他们散发的光辉中，汲取那么一点点就足以使我们成为一个优秀的个体。其实往往我们应该相信，我们所加入的每个团队其实都是优秀的团队，我们自身每个人都是优秀的个体，只需采取适当的引导措施，都能创造出足够优秀的成绩。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>布鲁斯·塔克曼将团队建设的过程划分为五个阶段，虽然这个理论已经诞生已经快50年了，但是迄今依然散发着蓊郁的芬芳，可以称为团队建设领域的一块丰碑。他将团队建设划分为“形成期”、“震荡期”、“稳定期”、“规范期”、“稳定期”，他认为每个阶段都是必须、不可逾越的，每个团队的组建过程往往都必须经过这五个阶段。</p>\n<p>当然，塔克曼的团队发展阶段理论主要使用于小型团队，但在本文中主要借用来形容一个团队的发展阶段，并非本文的主要内容。</p>\n<h2 id=\"形成期\"><a href=\"#形成期\" class=\"headerlink\" title=\"形成期\"></a>形成期</h2><p>团队初步建立，人员刚刚加入、或有新的人员加入，还需要对彼此进行认识，了解团队和组织的文化，逐步建立起团队基本的信任过程。在这个阶段人员间往往会比较独立，无法开诚布公的交流问题。团队存在焦虑心理，对团队的发展比较迷茫、甚至不稳定。</p>\n<h2 id=\"震荡期\"><a href=\"#震荡期\" class=\"headerlink\" title=\"震荡期\"></a>震荡期</h2><p>初步形成了各种观念，并逐步的认识彼此，但是会存在震荡和观点上的碰撞，甚至由于某些技术性的观点会产生一定的冲突。而冲突实际上是说明团队间已经开始寻找彼此沟通的方式，并逐步的适应对方。</p>\n<h2 id=\"规范期\"><a href=\"#规范期\" class=\"headerlink\" title=\"规范期\"></a>规范期</h2><p>形成了团队的沟通方式和团队文化，团队成员都逐步认识自己在团队中所能承担的角色，并能够为了完成一致的目标而做出自己的努力，在这个阶段彼此间能够流畅自如的进行沟通和任务的执行，并能表现出所具有的一定的自治性。</p>\n<h2 id=\"稳定期\"><a href=\"#稳定期\" class=\"headerlink\" title=\"稳定期\"></a>稳定期</h2><p>团队运作如同一个整体，彼此沟通融洽，团队能量凝聚一起，彼此间形成的团队能力能够顺利的对任务进行解读并完成目标，同时团队由于已经建立了基本的沟通规则，在一般的事务性问题上已经能够非常独立自治的解决问题。这也是一个战斗力强的团队所具有的基本形态。事实上如果在这个阶段再引入新来的成员，也将重新尽力从形成期开始的阶段。</p>\n<h2 id=\"解散期\"><a href=\"#解散期\" class=\"headerlink\" title=\"解散期\"></a>解散期</h2><p>又称为“休整期”，任务完成后，团队即将解散，彼此非常珍惜过去来之不易的相处时光，也难免产生失落感。一部分成员将离开团队，团队的战斗力将造成一定的影响，成员对于未来的不确定性将开始逐步占上风。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>某种意义上上讲，一个团队的形成，有时候像“三个和尚挑水喝”的古老谚语，毋庸置疑，人越少越容易团结、越容易管理、也容易形成自己的团队文化，而团队规模的逐渐增长，也看似会引发这样或那样的问题。尤其是中国人的典型特点，也曾经是在个体时往往具备非常不错的单兵作战能力，但是以集体的形式，会比较难以磨合。</p>\n<p>尤其是如果奢望在一个团队中，都是一群优秀的人，其实不太现实，过于优秀的单兵能力凝聚起来，就像是三体星一样，能够维持短期的稳定，却也暗含着不稳定。</p>\n<p><img src=\"https://uploader.shimo.im/f/KaSaWbSc7UY3H9PA.gif\" alt=\"图片\"></p>\n<p>（图片来自《DotNET骚操作》公众号，博主说等30秒钟就能看到三体星溃散的效果了。）</p>\n<p>而且有时候又渴望通过一定的控制力来维系团队的平衡，其实不见得能产生很好的效果，在一个看似稳定的组织中，引入一些强有力的措施，有时或许会产生下面的效果：</p>\n<p><img src=\"https://uploader.shimo.im/f/ndnXASWWYU0llrq3.jpeg!thumbnail\" alt=\"图片\"></p>\n<p>即在一个稳定的平面空间中，引入了一个重量级的“太阳”，自然而然会对空间和时间产生扭曲力，从而破坏原来平等的局面。</p>\n<p>当然，有时候引入“太阳”是必要的。</p>\n<h1 id=\"五\"><a href=\"#五\" class=\"headerlink\" title=\"五\"></a>五</h1><p>团队建设者不应该奢求依托强大的“组织机器”的力量来维系组织的平衡，有时候团队建设更是应该使用“上善若水”的精神，用如水般柔和的力量为团队间营造一种积极交流、互相倾听的文化，让彼此间能够成为对方的信赖。</p>\n<p>例如2019年听闻的“滴滴”北京团队组团游野长城，结果被困的消息，大概体现了团队建设者操之过急的团队建设心态吧。</p>\n<p>而同样作为团队建设者的我曾经在组织中实践过一种这样的方法，由于我们小团队的人员来源于不同的公司，年龄也有不同，（30岁居多），所以我试图利用每天给大家倒开水泡枸杞这个小细节来建立起团队基本的沟通方式，除此之外，也建立了一系列操作手法，使得不同经验的人都能够在团队中把自己的有点表现出来，从而使得团队间易于破冰，并打造出了一个具有战斗力的小团队。</p>\n<p>团队建设不拘泥于形式，每一个细节其实都可以表现出来。每天上班的一声问候、饭局上的互相寒暄，有意无意的引导，以及适度的积极倾听，把团队的每个人都当做你的家庭成员，可以用的方法太多了。</p>\n<p>不要再动不动就选择吃饭了。。多俗气啊~</p>\n"},{"title":"如何看待程序媛们的职场焦虑和未来职业规划？","date":"2020-02-16T08:23:00.000Z","author":"邹溪源","_content":"# 一  引子\n昨天，有一位通过我们长沙.NET技术社区公众号【DotNET技术圈】加我的好友的姑娘问了一个关于职业规划的问题：\n\n“在你的身边有没有认识的女程序员，可以告诉一下我们她们的职业规划么？”\n\n“是你想知道么？”\n\n“是的。我最近挺迷茫的。”\n\n“我感觉你似乎有点焦虑。你参加工作多久啦？”\n\n“是的。我参加工作一年了，目前主要是从事.NET技术开发。不知道自己该干嘛，也不知道自己未来能干嘛。”\n\n。。。\n\n# 二  职场焦虑\n## 2.1 焦虑感从何而来？\n不知大家是否观察到，在博客园也好，在其他技术群也好，总是有人有意无意的透露出一些焦虑的气氛，而且这种焦虑似乎是一种传染病，有时一个人感染了，还会连带着使得其他人也受到影响。\n\n职场焦虑无处不在，如同空鼻症患者的每一次呼吸一般，无时无刻不在影响着我们的生活。有时候早上起床，都会感觉到莫名其妙的压力席卷而来，让人一天都很难打起精神来，自然而然也会对我们的工作造成不少干扰。 虽然，有时候适度的焦虑，能够让我们维持比较积极的工作态度，使得我们能够以正确的方式面临来自工作中的压力。但是当代开发者们给自己太会给自己找压力了，有时候一些很正常的文字也会让我们产生错误的心理暗示，以为是对方在向我们输出焦虑。\n\n当然，我们也得承认，许多自媒体作者确实比较喜欢通过输出焦虑的形式来获得眼球，还有一些主要面向线上教育的公众号广告，也会有意无意的释放一些让人感觉焦虑的文字，使得许多读者倍感压力山大。于是这些有意无意制造出来的焦虑感，不仅不能给我们带来任何积极的作用，反而会影响工作效率的降低，影响我们的人际交往，进而影响我们的生活质量。\n\n## 2.2 焦虑感竟无处不在？\n过度焦虑已经成为普遍性的问题，尤其是30岁左右的这种习惯意义上的资深开发者或相对而言更加年长的开发者们。他们在30岁-40岁这个年龄，看似积累了不少经验理应能够在职场承担更多的工作压力，但是由于市场的影响，使得他们的工作本身并没有想象中那么稳定。与日俱增的裁员潮，随着年龄增长逐渐降低的性价比，来自家庭的压力本身，给30岁以上的开发者带来的压力或许许多人都有深刻的体会。\n\n如果说中年开发者们的焦虑其实与来自家庭的压力有关，那为何现在这种焦虑感已经蔓延到了更广的人群，甚至包括刚刚参加工作的开发者呢？许多刚刚参加工作的开发者，他们本来应该处于对待知识充满无穷渴望的大好年龄，但是由于来自普遍人群的焦虑情绪影响，使得他们对于自己的职业发展前途充满迷茫，不知自己今天的努力是否有价值，不知自己是否能够如同身边那些“其他人”一样，能够快速的在某些城市定居，获得生活上的安定。\n\n## 2.3 该如何排挤焦虑感？\n对于职场工作中的我们来说，一旦我们沉浸在工作中，总是会易于排挤焦虑，而一旦安静下来，反而会陷入深深的焦虑之中。所以最近由于新冠肺炎蔓延给大家带来的延长假期，我想可能会给大家带来的，或许不仅仅是充足的睡眠，或许还有远胜于以往的焦虑情绪。\n\n如果你总是莫名其妙的感到焦躁不安，而这种感觉又是与职场发展有一定的关系，那大概你也是职场焦虑症的受害者。我建议你得想办法从这个困境中走出来，例如学会积极的与人沟通、学会排挤工作中压力，采用适度的学习方法使自己的生活过得充实等等，没必要使自己过度焦虑，好好的找一个能够使自己专注的事情安定下来吧。\n\n# 三 姑娘们的职业规划\n## 3.1 客观存在的职场偏见\n回到开始的那个问题，关于程序媛的职业规划问题。这确实是一个很尴尬的问题。如果说程序员们的职场下坡路，大概是从30以后开始，或者35岁以后开始，那么程序媛们则是从结婚生子开始。\n\n不管程序媛曾经是如何优秀，一旦开始成为母亲，再回到职场上，竞争力将急剧降低，哪怕是有开明的人事或管理者试图留住像你这样的优秀开发者，也总会有其他人劝他三思而后行。\n\n这样的现象在互联网行业中层出不穷，不仅仅软件工程师岗位如此，其他岗位也同样如此，例如产品经理，市场推广，设计岗位等等。大概是因为在互联网时代，许多岗位已经不再是靠技能和创造力来创造价值，而是需要依靠更长的待机时间，更强大的心理承受力，更积极的工作态度来应对，而成为母亲的开发者们，往往会将更多的精力分给自己的家庭。\n\n当然，我们得承认，大部分情况下，程序媛们无法在职场进一步发展，难道程序媛就无法适应高强度的工作？性格不适合？技术不行？\n\n其实往往都不是，仅仅只是由于一种习惯性的职场偏见，或者曾经有过某些程序媛前辈们未能平衡职场和家庭的关系，让公司受到了一点点损失，因此在这方面吃过苦的中高层管理者们，即便想招人，有时候也不敢轻易聘用程序媛。 \n\n当然这样的偏见其实已经在逐渐改善了，如果有一位程序媛能够正确的将家庭和事业的水端平，其实还是能够找到合适的工作的。而一旦行业开始正确的看待程序媛，那么真正影响我们职业规划的，其实就是程序媛们是否正确的看待自己的职业规划的问题。\n\n## 3.2 职场规划的核心\n首先是自己的兴趣，你得明确自己的内心是否真正热爱软件编程，并把他当做一份事业？软件编程这份工作确实会给我们带来比其他行业相对较高的收入水平，但是这样的收入水平实际上依然取决于你的学习态度，如果始终保持着积极的学习态度，往往会有更多的机会选择，而如果抱着拿一份工资，上一份班的心态，这样的收入实际上并不长久。\n\n不要总想着转行，许多人总是不能正确的看待自己的职场，大概是因为他们总觉得自己在这份工作上干不长久。这样的心理暗示，也直接影响了他对于工作的长期规划。许多像我这样上了年纪的开发者都有深深的感悟，那些能够在这个行业一直干下来的人，他们不一定天赋异禀或者学习能力超群，恰好相反，他们能够坐得住冷板凳，不管工资高或低，他们都能始终如一的坚持这份工作。而还有许多潜力超群的人，他们今天想干这个，明天想干那个，到头来反而一事无成。\n\n第三，努力使自己成为最专业、不可替代的人。不管在什么岗位，只要使自己更加专业，一定不会错。你是否以专业的工程师思维应对未知技术问题带来的挑战？你是否能够以高度职业化的精神投入到工作中？你是否能够以专业的态度应对客户提出的刁钻需求。从这个点上看，其实程序员和程序媛本身没有太大的区别。\n\n真正影响程序员们未来发展的，年龄固然是一个关键性因素，但是是否足够专业、专注、不可替代这样的因素大概是核心因素。\n\n# 四 反思：如果不想干了，怎么办？\n当然，退一万步讲，如果你真的想转行怎么办？好吧，我们始终得相信一点，你当前所从事的岗位并不能证明你只适合干这个，而你能干什么，实际上依然取决于你是否在刻意培养对应岗位适合的能力。\n\n例如，你觉得自己能够成为产品经理，那么可以在写代码之余，刻意提高产品经理相关的技能，例如对于产品的感知力，对于需求的判断能力，如果到时候有一个成为产品经理的机会摆在你的面前，你也一定能够顺利的将相应的工作干好。\n\n例如你对文字特别有感知，那么或许你有成为文案的天赋。\n\n当前你选择的职业本身似乎对你的未来发展来说，其实只是人生中的一个小桥段而已，哪怕今天你从事软件开发，也无法说明一生都只能成为软件开发者。事实上单份工作对于人生的影响并没有那么重要，毕竟中国这么大，只要你具有某方面的能力，总是能找到合适的工作岗位，最重要的还是能够沉下心来认真工作。\n\n无论是未来干什么，你眼下的选择依然非常重要。如果你没办法预料自己未来的发展，那不如把眼下这份工作干到极致吧，谁知道上帝会不会给你开窗又开门呢？\n\n>本文纯属个人见解，不代表本号或长沙.NET技术社区意见。部分观点受[知乎文章](https://www.zhihu.com/question/21789640)的影响。如有疏漏错误，还请批评指正。\n\n","source":"_posts/随笔/如何看待程序媛的未来职业规划.md","raw":"---\ntitle:  如何看待程序媛们的职场焦虑和未来职业规划？\ndate: 2020-02-16 16:23\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n# 一  引子\n昨天，有一位通过我们长沙.NET技术社区公众号【DotNET技术圈】加我的好友的姑娘问了一个关于职业规划的问题：\n\n“在你的身边有没有认识的女程序员，可以告诉一下我们她们的职业规划么？”\n\n“是你想知道么？”\n\n“是的。我最近挺迷茫的。”\n\n“我感觉你似乎有点焦虑。你参加工作多久啦？”\n\n“是的。我参加工作一年了，目前主要是从事.NET技术开发。不知道自己该干嘛，也不知道自己未来能干嘛。”\n\n。。。\n\n# 二  职场焦虑\n## 2.1 焦虑感从何而来？\n不知大家是否观察到，在博客园也好，在其他技术群也好，总是有人有意无意的透露出一些焦虑的气氛，而且这种焦虑似乎是一种传染病，有时一个人感染了，还会连带着使得其他人也受到影响。\n\n职场焦虑无处不在，如同空鼻症患者的每一次呼吸一般，无时无刻不在影响着我们的生活。有时候早上起床，都会感觉到莫名其妙的压力席卷而来，让人一天都很难打起精神来，自然而然也会对我们的工作造成不少干扰。 虽然，有时候适度的焦虑，能够让我们维持比较积极的工作态度，使得我们能够以正确的方式面临来自工作中的压力。但是当代开发者们给自己太会给自己找压力了，有时候一些很正常的文字也会让我们产生错误的心理暗示，以为是对方在向我们输出焦虑。\n\n当然，我们也得承认，许多自媒体作者确实比较喜欢通过输出焦虑的形式来获得眼球，还有一些主要面向线上教育的公众号广告，也会有意无意的释放一些让人感觉焦虑的文字，使得许多读者倍感压力山大。于是这些有意无意制造出来的焦虑感，不仅不能给我们带来任何积极的作用，反而会影响工作效率的降低，影响我们的人际交往，进而影响我们的生活质量。\n\n## 2.2 焦虑感竟无处不在？\n过度焦虑已经成为普遍性的问题，尤其是30岁左右的这种习惯意义上的资深开发者或相对而言更加年长的开发者们。他们在30岁-40岁这个年龄，看似积累了不少经验理应能够在职场承担更多的工作压力，但是由于市场的影响，使得他们的工作本身并没有想象中那么稳定。与日俱增的裁员潮，随着年龄增长逐渐降低的性价比，来自家庭的压力本身，给30岁以上的开发者带来的压力或许许多人都有深刻的体会。\n\n如果说中年开发者们的焦虑其实与来自家庭的压力有关，那为何现在这种焦虑感已经蔓延到了更广的人群，甚至包括刚刚参加工作的开发者呢？许多刚刚参加工作的开发者，他们本来应该处于对待知识充满无穷渴望的大好年龄，但是由于来自普遍人群的焦虑情绪影响，使得他们对于自己的职业发展前途充满迷茫，不知自己今天的努力是否有价值，不知自己是否能够如同身边那些“其他人”一样，能够快速的在某些城市定居，获得生活上的安定。\n\n## 2.3 该如何排挤焦虑感？\n对于职场工作中的我们来说，一旦我们沉浸在工作中，总是会易于排挤焦虑，而一旦安静下来，反而会陷入深深的焦虑之中。所以最近由于新冠肺炎蔓延给大家带来的延长假期，我想可能会给大家带来的，或许不仅仅是充足的睡眠，或许还有远胜于以往的焦虑情绪。\n\n如果你总是莫名其妙的感到焦躁不安，而这种感觉又是与职场发展有一定的关系，那大概你也是职场焦虑症的受害者。我建议你得想办法从这个困境中走出来，例如学会积极的与人沟通、学会排挤工作中压力，采用适度的学习方法使自己的生活过得充实等等，没必要使自己过度焦虑，好好的找一个能够使自己专注的事情安定下来吧。\n\n# 三 姑娘们的职业规划\n## 3.1 客观存在的职场偏见\n回到开始的那个问题，关于程序媛的职业规划问题。这确实是一个很尴尬的问题。如果说程序员们的职场下坡路，大概是从30以后开始，或者35岁以后开始，那么程序媛们则是从结婚生子开始。\n\n不管程序媛曾经是如何优秀，一旦开始成为母亲，再回到职场上，竞争力将急剧降低，哪怕是有开明的人事或管理者试图留住像你这样的优秀开发者，也总会有其他人劝他三思而后行。\n\n这样的现象在互联网行业中层出不穷，不仅仅软件工程师岗位如此，其他岗位也同样如此，例如产品经理，市场推广，设计岗位等等。大概是因为在互联网时代，许多岗位已经不再是靠技能和创造力来创造价值，而是需要依靠更长的待机时间，更强大的心理承受力，更积极的工作态度来应对，而成为母亲的开发者们，往往会将更多的精力分给自己的家庭。\n\n当然，我们得承认，大部分情况下，程序媛们无法在职场进一步发展，难道程序媛就无法适应高强度的工作？性格不适合？技术不行？\n\n其实往往都不是，仅仅只是由于一种习惯性的职场偏见，或者曾经有过某些程序媛前辈们未能平衡职场和家庭的关系，让公司受到了一点点损失，因此在这方面吃过苦的中高层管理者们，即便想招人，有时候也不敢轻易聘用程序媛。 \n\n当然这样的偏见其实已经在逐渐改善了，如果有一位程序媛能够正确的将家庭和事业的水端平，其实还是能够找到合适的工作的。而一旦行业开始正确的看待程序媛，那么真正影响我们职业规划的，其实就是程序媛们是否正确的看待自己的职业规划的问题。\n\n## 3.2 职场规划的核心\n首先是自己的兴趣，你得明确自己的内心是否真正热爱软件编程，并把他当做一份事业？软件编程这份工作确实会给我们带来比其他行业相对较高的收入水平，但是这样的收入水平实际上依然取决于你的学习态度，如果始终保持着积极的学习态度，往往会有更多的机会选择，而如果抱着拿一份工资，上一份班的心态，这样的收入实际上并不长久。\n\n不要总想着转行，许多人总是不能正确的看待自己的职场，大概是因为他们总觉得自己在这份工作上干不长久。这样的心理暗示，也直接影响了他对于工作的长期规划。许多像我这样上了年纪的开发者都有深深的感悟，那些能够在这个行业一直干下来的人，他们不一定天赋异禀或者学习能力超群，恰好相反，他们能够坐得住冷板凳，不管工资高或低，他们都能始终如一的坚持这份工作。而还有许多潜力超群的人，他们今天想干这个，明天想干那个，到头来反而一事无成。\n\n第三，努力使自己成为最专业、不可替代的人。不管在什么岗位，只要使自己更加专业，一定不会错。你是否以专业的工程师思维应对未知技术问题带来的挑战？你是否能够以高度职业化的精神投入到工作中？你是否能够以专业的态度应对客户提出的刁钻需求。从这个点上看，其实程序员和程序媛本身没有太大的区别。\n\n真正影响程序员们未来发展的，年龄固然是一个关键性因素，但是是否足够专业、专注、不可替代这样的因素大概是核心因素。\n\n# 四 反思：如果不想干了，怎么办？\n当然，退一万步讲，如果你真的想转行怎么办？好吧，我们始终得相信一点，你当前所从事的岗位并不能证明你只适合干这个，而你能干什么，实际上依然取决于你是否在刻意培养对应岗位适合的能力。\n\n例如，你觉得自己能够成为产品经理，那么可以在写代码之余，刻意提高产品经理相关的技能，例如对于产品的感知力，对于需求的判断能力，如果到时候有一个成为产品经理的机会摆在你的面前，你也一定能够顺利的将相应的工作干好。\n\n例如你对文字特别有感知，那么或许你有成为文案的天赋。\n\n当前你选择的职业本身似乎对你的未来发展来说，其实只是人生中的一个小桥段而已，哪怕今天你从事软件开发，也无法说明一生都只能成为软件开发者。事实上单份工作对于人生的影响并没有那么重要，毕竟中国这么大，只要你具有某方面的能力，总是能找到合适的工作岗位，最重要的还是能够沉下心来认真工作。\n\n无论是未来干什么，你眼下的选择依然非常重要。如果你没办法预料自己未来的发展，那不如把眼下这份工作干到极致吧，谁知道上帝会不会给你开窗又开门呢？\n\n>本文纯属个人见解，不代表本号或长沙.NET技术社区意见。部分观点受[知乎文章](https://www.zhihu.com/question/21789640)的影响。如有疏漏错误，还请批评指正。\n\n","slug":"随笔/如何看待程序媛的未来职业规划","published":1,"updated":"2020-02-16T08:23:22.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt9g0046n4vix46v73dl","content":"<h1 id=\"一-引子\"><a href=\"#一-引子\" class=\"headerlink\" title=\"一  引子\"></a>一  引子</h1><p>昨天，有一位通过我们长沙.NET技术社区公众号【DotNET技术圈】加我的好友的姑娘问了一个关于职业规划的问题：</p>\n<p>“在你的身边有没有认识的女程序员，可以告诉一下我们她们的职业规划么？”</p>\n<p>“是你想知道么？”</p>\n<p>“是的。我最近挺迷茫的。”</p>\n<p>“我感觉你似乎有点焦虑。你参加工作多久啦？”</p>\n<p>“是的。我参加工作一年了，目前主要是从事.NET技术开发。不知道自己该干嘛，也不知道自己未来能干嘛。”</p>\n<p>。。。</p>\n<h1 id=\"二-职场焦虑\"><a href=\"#二-职场焦虑\" class=\"headerlink\" title=\"二  职场焦虑\"></a>二  职场焦虑</h1><h2 id=\"2-1-焦虑感从何而来？\"><a href=\"#2-1-焦虑感从何而来？\" class=\"headerlink\" title=\"2.1 焦虑感从何而来？\"></a>2.1 焦虑感从何而来？</h2><p>不知大家是否观察到，在博客园也好，在其他技术群也好，总是有人有意无意的透露出一些焦虑的气氛，而且这种焦虑似乎是一种传染病，有时一个人感染了，还会连带着使得其他人也受到影响。</p>\n<p>职场焦虑无处不在，如同空鼻症患者的每一次呼吸一般，无时无刻不在影响着我们的生活。有时候早上起床，都会感觉到莫名其妙的压力席卷而来，让人一天都很难打起精神来，自然而然也会对我们的工作造成不少干扰。 虽然，有时候适度的焦虑，能够让我们维持比较积极的工作态度，使得我们能够以正确的方式面临来自工作中的压力。但是当代开发者们给自己太会给自己找压力了，有时候一些很正常的文字也会让我们产生错误的心理暗示，以为是对方在向我们输出焦虑。</p>\n<p>当然，我们也得承认，许多自媒体作者确实比较喜欢通过输出焦虑的形式来获得眼球，还有一些主要面向线上教育的公众号广告，也会有意无意的释放一些让人感觉焦虑的文字，使得许多读者倍感压力山大。于是这些有意无意制造出来的焦虑感，不仅不能给我们带来任何积极的作用，反而会影响工作效率的降低，影响我们的人际交往，进而影响我们的生活质量。</p>\n<h2 id=\"2-2-焦虑感竟无处不在？\"><a href=\"#2-2-焦虑感竟无处不在？\" class=\"headerlink\" title=\"2.2 焦虑感竟无处不在？\"></a>2.2 焦虑感竟无处不在？</h2><p>过度焦虑已经成为普遍性的问题，尤其是30岁左右的这种习惯意义上的资深开发者或相对而言更加年长的开发者们。他们在30岁-40岁这个年龄，看似积累了不少经验理应能够在职场承担更多的工作压力，但是由于市场的影响，使得他们的工作本身并没有想象中那么稳定。与日俱增的裁员潮，随着年龄增长逐渐降低的性价比，来自家庭的压力本身，给30岁以上的开发者带来的压力或许许多人都有深刻的体会。</p>\n<p>如果说中年开发者们的焦虑其实与来自家庭的压力有关，那为何现在这种焦虑感已经蔓延到了更广的人群，甚至包括刚刚参加工作的开发者呢？许多刚刚参加工作的开发者，他们本来应该处于对待知识充满无穷渴望的大好年龄，但是由于来自普遍人群的焦虑情绪影响，使得他们对于自己的职业发展前途充满迷茫，不知自己今天的努力是否有价值，不知自己是否能够如同身边那些“其他人”一样，能够快速的在某些城市定居，获得生活上的安定。</p>\n<h2 id=\"2-3-该如何排挤焦虑感？\"><a href=\"#2-3-该如何排挤焦虑感？\" class=\"headerlink\" title=\"2.3 该如何排挤焦虑感？\"></a>2.3 该如何排挤焦虑感？</h2><p>对于职场工作中的我们来说，一旦我们沉浸在工作中，总是会易于排挤焦虑，而一旦安静下来，反而会陷入深深的焦虑之中。所以最近由于新冠肺炎蔓延给大家带来的延长假期，我想可能会给大家带来的，或许不仅仅是充足的睡眠，或许还有远胜于以往的焦虑情绪。</p>\n<p>如果你总是莫名其妙的感到焦躁不安，而这种感觉又是与职场发展有一定的关系，那大概你也是职场焦虑症的受害者。我建议你得想办法从这个困境中走出来，例如学会积极的与人沟通、学会排挤工作中压力，采用适度的学习方法使自己的生活过得充实等等，没必要使自己过度焦虑，好好的找一个能够使自己专注的事情安定下来吧。</p>\n<h1 id=\"三-姑娘们的职业规划\"><a href=\"#三-姑娘们的职业规划\" class=\"headerlink\" title=\"三 姑娘们的职业规划\"></a>三 姑娘们的职业规划</h1><h2 id=\"3-1-客观存在的职场偏见\"><a href=\"#3-1-客观存在的职场偏见\" class=\"headerlink\" title=\"3.1 客观存在的职场偏见\"></a>3.1 客观存在的职场偏见</h2><p>回到开始的那个问题，关于程序媛的职业规划问题。这确实是一个很尴尬的问题。如果说程序员们的职场下坡路，大概是从30以后开始，或者35岁以后开始，那么程序媛们则是从结婚生子开始。</p>\n<p>不管程序媛曾经是如何优秀，一旦开始成为母亲，再回到职场上，竞争力将急剧降低，哪怕是有开明的人事或管理者试图留住像你这样的优秀开发者，也总会有其他人劝他三思而后行。</p>\n<p>这样的现象在互联网行业中层出不穷，不仅仅软件工程师岗位如此，其他岗位也同样如此，例如产品经理，市场推广，设计岗位等等。大概是因为在互联网时代，许多岗位已经不再是靠技能和创造力来创造价值，而是需要依靠更长的待机时间，更强大的心理承受力，更积极的工作态度来应对，而成为母亲的开发者们，往往会将更多的精力分给自己的家庭。</p>\n<p>当然，我们得承认，大部分情况下，程序媛们无法在职场进一步发展，难道程序媛就无法适应高强度的工作？性格不适合？技术不行？</p>\n<p>其实往往都不是，仅仅只是由于一种习惯性的职场偏见，或者曾经有过某些程序媛前辈们未能平衡职场和家庭的关系，让公司受到了一点点损失，因此在这方面吃过苦的中高层管理者们，即便想招人，有时候也不敢轻易聘用程序媛。 </p>\n<p>当然这样的偏见其实已经在逐渐改善了，如果有一位程序媛能够正确的将家庭和事业的水端平，其实还是能够找到合适的工作的。而一旦行业开始正确的看待程序媛，那么真正影响我们职业规划的，其实就是程序媛们是否正确的看待自己的职业规划的问题。</p>\n<h2 id=\"3-2-职场规划的核心\"><a href=\"#3-2-职场规划的核心\" class=\"headerlink\" title=\"3.2 职场规划的核心\"></a>3.2 职场规划的核心</h2><p>首先是自己的兴趣，你得明确自己的内心是否真正热爱软件编程，并把他当做一份事业？软件编程这份工作确实会给我们带来比其他行业相对较高的收入水平，但是这样的收入水平实际上依然取决于你的学习态度，如果始终保持着积极的学习态度，往往会有更多的机会选择，而如果抱着拿一份工资，上一份班的心态，这样的收入实际上并不长久。</p>\n<p>不要总想着转行，许多人总是不能正确的看待自己的职场，大概是因为他们总觉得自己在这份工作上干不长久。这样的心理暗示，也直接影响了他对于工作的长期规划。许多像我这样上了年纪的开发者都有深深的感悟，那些能够在这个行业一直干下来的人，他们不一定天赋异禀或者学习能力超群，恰好相反，他们能够坐得住冷板凳，不管工资高或低，他们都能始终如一的坚持这份工作。而还有许多潜力超群的人，他们今天想干这个，明天想干那个，到头来反而一事无成。</p>\n<p>第三，努力使自己成为最专业、不可替代的人。不管在什么岗位，只要使自己更加专业，一定不会错。你是否以专业的工程师思维应对未知技术问题带来的挑战？你是否能够以高度职业化的精神投入到工作中？你是否能够以专业的态度应对客户提出的刁钻需求。从这个点上看，其实程序员和程序媛本身没有太大的区别。</p>\n<p>真正影响程序员们未来发展的，年龄固然是一个关键性因素，但是是否足够专业、专注、不可替代这样的因素大概是核心因素。</p>\n<h1 id=\"四-反思：如果不想干了，怎么办？\"><a href=\"#四-反思：如果不想干了，怎么办？\" class=\"headerlink\" title=\"四 反思：如果不想干了，怎么办？\"></a>四 反思：如果不想干了，怎么办？</h1><p>当然，退一万步讲，如果你真的想转行怎么办？好吧，我们始终得相信一点，你当前所从事的岗位并不能证明你只适合干这个，而你能干什么，实际上依然取决于你是否在刻意培养对应岗位适合的能力。</p>\n<p>例如，你觉得自己能够成为产品经理，那么可以在写代码之余，刻意提高产品经理相关的技能，例如对于产品的感知力，对于需求的判断能力，如果到时候有一个成为产品经理的机会摆在你的面前，你也一定能够顺利的将相应的工作干好。</p>\n<p>例如你对文字特别有感知，那么或许你有成为文案的天赋。</p>\n<p>当前你选择的职业本身似乎对你的未来发展来说，其实只是人生中的一个小桥段而已，哪怕今天你从事软件开发，也无法说明一生都只能成为软件开发者。事实上单份工作对于人生的影响并没有那么重要，毕竟中国这么大，只要你具有某方面的能力，总是能找到合适的工作岗位，最重要的还是能够沉下心来认真工作。</p>\n<p>无论是未来干什么，你眼下的选择依然非常重要。如果你没办法预料自己未来的发展，那不如把眼下这份工作干到极致吧，谁知道上帝会不会给你开窗又开门呢？</p>\n<blockquote>\n<p>本文纯属个人见解，不代表本号或长沙.NET技术社区意见。部分观点受<a href=\"https://www.zhihu.com/question/21789640\" target=\"_blank\" rel=\"noopener\">知乎文章</a>的影响。如有疏漏错误，还请批评指正。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一-引子\"><a href=\"#一-引子\" class=\"headerlink\" title=\"一  引子\"></a>一  引子</h1><p>昨天，有一位通过我们长沙.NET技术社区公众号【DotNET技术圈】加我的好友的姑娘问了一个关于职业规划的问题：</p>\n<p>“在你的身边有没有认识的女程序员，可以告诉一下我们她们的职业规划么？”</p>\n<p>“是你想知道么？”</p>\n<p>“是的。我最近挺迷茫的。”</p>\n<p>“我感觉你似乎有点焦虑。你参加工作多久啦？”</p>\n<p>“是的。我参加工作一年了，目前主要是从事.NET技术开发。不知道自己该干嘛，也不知道自己未来能干嘛。”</p>\n<p>。。。</p>\n<h1 id=\"二-职场焦虑\"><a href=\"#二-职场焦虑\" class=\"headerlink\" title=\"二  职场焦虑\"></a>二  职场焦虑</h1><h2 id=\"2-1-焦虑感从何而来？\"><a href=\"#2-1-焦虑感从何而来？\" class=\"headerlink\" title=\"2.1 焦虑感从何而来？\"></a>2.1 焦虑感从何而来？</h2><p>不知大家是否观察到，在博客园也好，在其他技术群也好，总是有人有意无意的透露出一些焦虑的气氛，而且这种焦虑似乎是一种传染病，有时一个人感染了，还会连带着使得其他人也受到影响。</p>\n<p>职场焦虑无处不在，如同空鼻症患者的每一次呼吸一般，无时无刻不在影响着我们的生活。有时候早上起床，都会感觉到莫名其妙的压力席卷而来，让人一天都很难打起精神来，自然而然也会对我们的工作造成不少干扰。 虽然，有时候适度的焦虑，能够让我们维持比较积极的工作态度，使得我们能够以正确的方式面临来自工作中的压力。但是当代开发者们给自己太会给自己找压力了，有时候一些很正常的文字也会让我们产生错误的心理暗示，以为是对方在向我们输出焦虑。</p>\n<p>当然，我们也得承认，许多自媒体作者确实比较喜欢通过输出焦虑的形式来获得眼球，还有一些主要面向线上教育的公众号广告，也会有意无意的释放一些让人感觉焦虑的文字，使得许多读者倍感压力山大。于是这些有意无意制造出来的焦虑感，不仅不能给我们带来任何积极的作用，反而会影响工作效率的降低，影响我们的人际交往，进而影响我们的生活质量。</p>\n<h2 id=\"2-2-焦虑感竟无处不在？\"><a href=\"#2-2-焦虑感竟无处不在？\" class=\"headerlink\" title=\"2.2 焦虑感竟无处不在？\"></a>2.2 焦虑感竟无处不在？</h2><p>过度焦虑已经成为普遍性的问题，尤其是30岁左右的这种习惯意义上的资深开发者或相对而言更加年长的开发者们。他们在30岁-40岁这个年龄，看似积累了不少经验理应能够在职场承担更多的工作压力，但是由于市场的影响，使得他们的工作本身并没有想象中那么稳定。与日俱增的裁员潮，随着年龄增长逐渐降低的性价比，来自家庭的压力本身，给30岁以上的开发者带来的压力或许许多人都有深刻的体会。</p>\n<p>如果说中年开发者们的焦虑其实与来自家庭的压力有关，那为何现在这种焦虑感已经蔓延到了更广的人群，甚至包括刚刚参加工作的开发者呢？许多刚刚参加工作的开发者，他们本来应该处于对待知识充满无穷渴望的大好年龄，但是由于来自普遍人群的焦虑情绪影响，使得他们对于自己的职业发展前途充满迷茫，不知自己今天的努力是否有价值，不知自己是否能够如同身边那些“其他人”一样，能够快速的在某些城市定居，获得生活上的安定。</p>\n<h2 id=\"2-3-该如何排挤焦虑感？\"><a href=\"#2-3-该如何排挤焦虑感？\" class=\"headerlink\" title=\"2.3 该如何排挤焦虑感？\"></a>2.3 该如何排挤焦虑感？</h2><p>对于职场工作中的我们来说，一旦我们沉浸在工作中，总是会易于排挤焦虑，而一旦安静下来，反而会陷入深深的焦虑之中。所以最近由于新冠肺炎蔓延给大家带来的延长假期，我想可能会给大家带来的，或许不仅仅是充足的睡眠，或许还有远胜于以往的焦虑情绪。</p>\n<p>如果你总是莫名其妙的感到焦躁不安，而这种感觉又是与职场发展有一定的关系，那大概你也是职场焦虑症的受害者。我建议你得想办法从这个困境中走出来，例如学会积极的与人沟通、学会排挤工作中压力，采用适度的学习方法使自己的生活过得充实等等，没必要使自己过度焦虑，好好的找一个能够使自己专注的事情安定下来吧。</p>\n<h1 id=\"三-姑娘们的职业规划\"><a href=\"#三-姑娘们的职业规划\" class=\"headerlink\" title=\"三 姑娘们的职业规划\"></a>三 姑娘们的职业规划</h1><h2 id=\"3-1-客观存在的职场偏见\"><a href=\"#3-1-客观存在的职场偏见\" class=\"headerlink\" title=\"3.1 客观存在的职场偏见\"></a>3.1 客观存在的职场偏见</h2><p>回到开始的那个问题，关于程序媛的职业规划问题。这确实是一个很尴尬的问题。如果说程序员们的职场下坡路，大概是从30以后开始，或者35岁以后开始，那么程序媛们则是从结婚生子开始。</p>\n<p>不管程序媛曾经是如何优秀，一旦开始成为母亲，再回到职场上，竞争力将急剧降低，哪怕是有开明的人事或管理者试图留住像你这样的优秀开发者，也总会有其他人劝他三思而后行。</p>\n<p>这样的现象在互联网行业中层出不穷，不仅仅软件工程师岗位如此，其他岗位也同样如此，例如产品经理，市场推广，设计岗位等等。大概是因为在互联网时代，许多岗位已经不再是靠技能和创造力来创造价值，而是需要依靠更长的待机时间，更强大的心理承受力，更积极的工作态度来应对，而成为母亲的开发者们，往往会将更多的精力分给自己的家庭。</p>\n<p>当然，我们得承认，大部分情况下，程序媛们无法在职场进一步发展，难道程序媛就无法适应高强度的工作？性格不适合？技术不行？</p>\n<p>其实往往都不是，仅仅只是由于一种习惯性的职场偏见，或者曾经有过某些程序媛前辈们未能平衡职场和家庭的关系，让公司受到了一点点损失，因此在这方面吃过苦的中高层管理者们，即便想招人，有时候也不敢轻易聘用程序媛。 </p>\n<p>当然这样的偏见其实已经在逐渐改善了，如果有一位程序媛能够正确的将家庭和事业的水端平，其实还是能够找到合适的工作的。而一旦行业开始正确的看待程序媛，那么真正影响我们职业规划的，其实就是程序媛们是否正确的看待自己的职业规划的问题。</p>\n<h2 id=\"3-2-职场规划的核心\"><a href=\"#3-2-职场规划的核心\" class=\"headerlink\" title=\"3.2 职场规划的核心\"></a>3.2 职场规划的核心</h2><p>首先是自己的兴趣，你得明确自己的内心是否真正热爱软件编程，并把他当做一份事业？软件编程这份工作确实会给我们带来比其他行业相对较高的收入水平，但是这样的收入水平实际上依然取决于你的学习态度，如果始终保持着积极的学习态度，往往会有更多的机会选择，而如果抱着拿一份工资，上一份班的心态，这样的收入实际上并不长久。</p>\n<p>不要总想着转行，许多人总是不能正确的看待自己的职场，大概是因为他们总觉得自己在这份工作上干不长久。这样的心理暗示，也直接影响了他对于工作的长期规划。许多像我这样上了年纪的开发者都有深深的感悟，那些能够在这个行业一直干下来的人，他们不一定天赋异禀或者学习能力超群，恰好相反，他们能够坐得住冷板凳，不管工资高或低，他们都能始终如一的坚持这份工作。而还有许多潜力超群的人，他们今天想干这个，明天想干那个，到头来反而一事无成。</p>\n<p>第三，努力使自己成为最专业、不可替代的人。不管在什么岗位，只要使自己更加专业，一定不会错。你是否以专业的工程师思维应对未知技术问题带来的挑战？你是否能够以高度职业化的精神投入到工作中？你是否能够以专业的态度应对客户提出的刁钻需求。从这个点上看，其实程序员和程序媛本身没有太大的区别。</p>\n<p>真正影响程序员们未来发展的，年龄固然是一个关键性因素，但是是否足够专业、专注、不可替代这样的因素大概是核心因素。</p>\n<h1 id=\"四-反思：如果不想干了，怎么办？\"><a href=\"#四-反思：如果不想干了，怎么办？\" class=\"headerlink\" title=\"四 反思：如果不想干了，怎么办？\"></a>四 反思：如果不想干了，怎么办？</h1><p>当然，退一万步讲，如果你真的想转行怎么办？好吧，我们始终得相信一点，你当前所从事的岗位并不能证明你只适合干这个，而你能干什么，实际上依然取决于你是否在刻意培养对应岗位适合的能力。</p>\n<p>例如，你觉得自己能够成为产品经理，那么可以在写代码之余，刻意提高产品经理相关的技能，例如对于产品的感知力，对于需求的判断能力，如果到时候有一个成为产品经理的机会摆在你的面前，你也一定能够顺利的将相应的工作干好。</p>\n<p>例如你对文字特别有感知，那么或许你有成为文案的天赋。</p>\n<p>当前你选择的职业本身似乎对你的未来发展来说，其实只是人生中的一个小桥段而已，哪怕今天你从事软件开发，也无法说明一生都只能成为软件开发者。事实上单份工作对于人生的影响并没有那么重要，毕竟中国这么大，只要你具有某方面的能力，总是能找到合适的工作岗位，最重要的还是能够沉下心来认真工作。</p>\n<p>无论是未来干什么，你眼下的选择依然非常重要。如果你没办法预料自己未来的发展，那不如把眼下这份工作干到极致吧，谁知道上帝会不会给你开窗又开门呢？</p>\n<blockquote>\n<p>本文纯属个人见解，不代表本号或长沙.NET技术社区意见。部分观点受<a href=\"https://www.zhihu.com/question/21789640\" target=\"_blank\" rel=\"noopener\">知乎文章</a>的影响。如有疏漏错误，还请批评指正。</p>\n</blockquote>\n"},{"title":"李文强先生的《容器入门教程》推荐序","date":"2019-12-11T13:28:00.000Z","author":"邹溪源","_content":"# 推荐序\n\n容器技术，大概是最近几年最为流行的一种技术。这种技术打破了原来用虚拟机部署软件对硬件环境和条件的限制，让软件的逻辑边界获得了更大程度的扩展。只要是一台能够安装Linux的个人PC机、服务器、甚至是小巧玲珑的树莓派，都可以非常轻松的安装容器，实现了硬件资源的最大化利用。这也让微服务技术得以更好的落地，更加便捷、高效的实现企业生产效率的提升。\n\n然而，虽然容器技术越来越流行、虽然网上的资料很多，但是往往多而杂乱，让人看得眼花缭乱。而且许多资料看起来能够有用，实际上大部分资料都是重复而错误的，许多文章都是从其他网站上生搬硬套、拷贝或者甚至直接抄过来的。这也导致了许多开发者虽然想真正学习容器技术，却还得自己一点点摸着石子过河，踩很多的坑。事实上借助于搜索引擎往往看似会给我们带来许多便利，也会让人产生摸不着头脑。缺乏靠谱的资料支持，缺乏系统的学习方法，缺乏深入浅出的过程描述，这大概是面向搜索引擎学习的开发者们最大的困扰。 \n\n在这个背景下，这本书应运而生。作者李文强是我们长沙互联网社区的一位开发者，而且也是一位创业者，平时工作很繁忙，但是却依然对技术充满了持续的学习精神。他从容器刚刚兴起就跟进技术，并灵活的将容器技术和kubernetes（k8s）技术运用到企业的实际项目中，获得了非常不错的效果。基于容器技术和k8s技术的完美结合，让公司的产品开发流程实现了足够细粒度的服务划分，然后再配上一键发布、所见即所得的持续交付流程，让他的企业能够快速适应客户需求和市场的变化，为企业的业绩腾飞带来了不少助力。\n\n这本书的每个案例都是作者悉心收集整理、书中的每个步骤作者都认真的尝试了好几遍，与步骤有关的每个截图都力求真实，可以是说精心打磨的上佳作品。他平时观察也很仔细，把在工作中踩过的每个坑都认真的记下来，并以博客的形式发布，获得了大家的一致好评。这几年来他在博客和公众号发表相关主题的帖子已经不下百篇，惠及数万开发者，事实上我也正是通过他的博客认识了他。这本书也是李文强先生在实践过程中的所思所感的汇聚，通过这本书，我们也还可以学习到如何科学有效的掌握新技术的方法。\n\n总之这是一本非常适合初学者入门容器和k8s的书，不管你是在校大学生、还是对容器和运维技术感兴趣的从业者，您都应该拥有这本书。它不仅能手把手指引你的学习，更能让你赢在起跑线上，为你的幸福生活添砖加瓦。\n\n某软件技术有限公司研发总监-邹锭","source":"_posts/随笔/容器-推荐序.md","raw":"---\ntitle: 李文强先生的《容器入门教程》推荐序\ndate: 2019-12-11 21:28\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n# 推荐序\n\n容器技术，大概是最近几年最为流行的一种技术。这种技术打破了原来用虚拟机部署软件对硬件环境和条件的限制，让软件的逻辑边界获得了更大程度的扩展。只要是一台能够安装Linux的个人PC机、服务器、甚至是小巧玲珑的树莓派，都可以非常轻松的安装容器，实现了硬件资源的最大化利用。这也让微服务技术得以更好的落地，更加便捷、高效的实现企业生产效率的提升。\n\n然而，虽然容器技术越来越流行、虽然网上的资料很多，但是往往多而杂乱，让人看得眼花缭乱。而且许多资料看起来能够有用，实际上大部分资料都是重复而错误的，许多文章都是从其他网站上生搬硬套、拷贝或者甚至直接抄过来的。这也导致了许多开发者虽然想真正学习容器技术，却还得自己一点点摸着石子过河，踩很多的坑。事实上借助于搜索引擎往往看似会给我们带来许多便利，也会让人产生摸不着头脑。缺乏靠谱的资料支持，缺乏系统的学习方法，缺乏深入浅出的过程描述，这大概是面向搜索引擎学习的开发者们最大的困扰。 \n\n在这个背景下，这本书应运而生。作者李文强是我们长沙互联网社区的一位开发者，而且也是一位创业者，平时工作很繁忙，但是却依然对技术充满了持续的学习精神。他从容器刚刚兴起就跟进技术，并灵活的将容器技术和kubernetes（k8s）技术运用到企业的实际项目中，获得了非常不错的效果。基于容器技术和k8s技术的完美结合，让公司的产品开发流程实现了足够细粒度的服务划分，然后再配上一键发布、所见即所得的持续交付流程，让他的企业能够快速适应客户需求和市场的变化，为企业的业绩腾飞带来了不少助力。\n\n这本书的每个案例都是作者悉心收集整理、书中的每个步骤作者都认真的尝试了好几遍，与步骤有关的每个截图都力求真实，可以是说精心打磨的上佳作品。他平时观察也很仔细，把在工作中踩过的每个坑都认真的记下来，并以博客的形式发布，获得了大家的一致好评。这几年来他在博客和公众号发表相关主题的帖子已经不下百篇，惠及数万开发者，事实上我也正是通过他的博客认识了他。这本书也是李文强先生在实践过程中的所思所感的汇聚，通过这本书，我们也还可以学习到如何科学有效的掌握新技术的方法。\n\n总之这是一本非常适合初学者入门容器和k8s的书，不管你是在校大学生、还是对容器和运维技术感兴趣的从业者，您都应该拥有这本书。它不仅能手把手指引你的学习，更能让你赢在起跑线上，为你的幸福生活添砖加瓦。\n\n某软件技术有限公司研发总监-邹锭","slug":"随笔/容器-推荐序","published":1,"updated":"2019-12-11T13:42:16.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt9h0049n4viyploq7t0","content":"<h1 id=\"推荐序\"><a href=\"#推荐序\" class=\"headerlink\" title=\"推荐序\"></a>推荐序</h1><p>容器技术，大概是最近几年最为流行的一种技术。这种技术打破了原来用虚拟机部署软件对硬件环境和条件的限制，让软件的逻辑边界获得了更大程度的扩展。只要是一台能够安装Linux的个人PC机、服务器、甚至是小巧玲珑的树莓派，都可以非常轻松的安装容器，实现了硬件资源的最大化利用。这也让微服务技术得以更好的落地，更加便捷、高效的实现企业生产效率的提升。</p>\n<p>然而，虽然容器技术越来越流行、虽然网上的资料很多，但是往往多而杂乱，让人看得眼花缭乱。而且许多资料看起来能够有用，实际上大部分资料都是重复而错误的，许多文章都是从其他网站上生搬硬套、拷贝或者甚至直接抄过来的。这也导致了许多开发者虽然想真正学习容器技术，却还得自己一点点摸着石子过河，踩很多的坑。事实上借助于搜索引擎往往看似会给我们带来许多便利，也会让人产生摸不着头脑。缺乏靠谱的资料支持，缺乏系统的学习方法，缺乏深入浅出的过程描述，这大概是面向搜索引擎学习的开发者们最大的困扰。 </p>\n<p>在这个背景下，这本书应运而生。作者李文强是我们长沙互联网社区的一位开发者，而且也是一位创业者，平时工作很繁忙，但是却依然对技术充满了持续的学习精神。他从容器刚刚兴起就跟进技术，并灵活的将容器技术和kubernetes（k8s）技术运用到企业的实际项目中，获得了非常不错的效果。基于容器技术和k8s技术的完美结合，让公司的产品开发流程实现了足够细粒度的服务划分，然后再配上一键发布、所见即所得的持续交付流程，让他的企业能够快速适应客户需求和市场的变化，为企业的业绩腾飞带来了不少助力。</p>\n<p>这本书的每个案例都是作者悉心收集整理、书中的每个步骤作者都认真的尝试了好几遍，与步骤有关的每个截图都力求真实，可以是说精心打磨的上佳作品。他平时观察也很仔细，把在工作中踩过的每个坑都认真的记下来，并以博客的形式发布，获得了大家的一致好评。这几年来他在博客和公众号发表相关主题的帖子已经不下百篇，惠及数万开发者，事实上我也正是通过他的博客认识了他。这本书也是李文强先生在实践过程中的所思所感的汇聚，通过这本书，我们也还可以学习到如何科学有效的掌握新技术的方法。</p>\n<p>总之这是一本非常适合初学者入门容器和k8s的书，不管你是在校大学生、还是对容器和运维技术感兴趣的从业者，您都应该拥有这本书。它不仅能手把手指引你的学习，更能让你赢在起跑线上，为你的幸福生活添砖加瓦。</p>\n<p>某软件技术有限公司研发总监-邹锭</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"推荐序\"><a href=\"#推荐序\" class=\"headerlink\" title=\"推荐序\"></a>推荐序</h1><p>容器技术，大概是最近几年最为流行的一种技术。这种技术打破了原来用虚拟机部署软件对硬件环境和条件的限制，让软件的逻辑边界获得了更大程度的扩展。只要是一台能够安装Linux的个人PC机、服务器、甚至是小巧玲珑的树莓派，都可以非常轻松的安装容器，实现了硬件资源的最大化利用。这也让微服务技术得以更好的落地，更加便捷、高效的实现企业生产效率的提升。</p>\n<p>然而，虽然容器技术越来越流行、虽然网上的资料很多，但是往往多而杂乱，让人看得眼花缭乱。而且许多资料看起来能够有用，实际上大部分资料都是重复而错误的，许多文章都是从其他网站上生搬硬套、拷贝或者甚至直接抄过来的。这也导致了许多开发者虽然想真正学习容器技术，却还得自己一点点摸着石子过河，踩很多的坑。事实上借助于搜索引擎往往看似会给我们带来许多便利，也会让人产生摸不着头脑。缺乏靠谱的资料支持，缺乏系统的学习方法，缺乏深入浅出的过程描述，这大概是面向搜索引擎学习的开发者们最大的困扰。 </p>\n<p>在这个背景下，这本书应运而生。作者李文强是我们长沙互联网社区的一位开发者，而且也是一位创业者，平时工作很繁忙，但是却依然对技术充满了持续的学习精神。他从容器刚刚兴起就跟进技术，并灵活的将容器技术和kubernetes（k8s）技术运用到企业的实际项目中，获得了非常不错的效果。基于容器技术和k8s技术的完美结合，让公司的产品开发流程实现了足够细粒度的服务划分，然后再配上一键发布、所见即所得的持续交付流程，让他的企业能够快速适应客户需求和市场的变化，为企业的业绩腾飞带来了不少助力。</p>\n<p>这本书的每个案例都是作者悉心收集整理、书中的每个步骤作者都认真的尝试了好几遍，与步骤有关的每个截图都力求真实，可以是说精心打磨的上佳作品。他平时观察也很仔细，把在工作中踩过的每个坑都认真的记下来，并以博客的形式发布，获得了大家的一致好评。这几年来他在博客和公众号发表相关主题的帖子已经不下百篇，惠及数万开发者，事实上我也正是通过他的博客认识了他。这本书也是李文强先生在实践过程中的所思所感的汇聚，通过这本书，我们也还可以学习到如何科学有效的掌握新技术的方法。</p>\n<p>总之这是一本非常适合初学者入门容器和k8s的书，不管你是在校大学生、还是对容器和运维技术感兴趣的从业者，您都应该拥有这本书。它不仅能手把手指引你的学习，更能让你赢在起跑线上，为你的幸福生活添砖加瓦。</p>\n<p>某软件技术有限公司研发总监-邹锭</p>\n"},{"title":"开发者的不断进取，源自对技术的点滴追求","date":"2019-11-05T08:28:00.000Z","author":"邹溪源","_content":"\n# 身边的优秀开发者，【DotNET骚操作】周杰\n# 一，社区的小圈子\n今年3月的一次技术交流活动上，那是我们.NET技术社区第一次组织线下活动，由于没什么经验，所以活动组织得比较仓促，内容也比较一般，效果还是有点欠缺。当然，活动本身是必要的，这次活动上有幸认识了许多长沙的优秀开发者，这让我非常的高兴。\n\n事实上搞技术活动，与其说是交流技术，倒不如说是扩大圈子，交流感情，认识更多的朋友。毕竟每个职场人往往圈子都是固定的，哪怕是在大公司，真正经常来往的朋友其实也不过三两人而已。但是在北上广深的大城市，往往有时候刚刚认识几个朋友，对方可能就离开了，这也是一种遗憾。相对而言，在小城市或许也相对容易形成更加稳定的精准小圈子，这也是我认为一个社区存在的最大价值。\n\n小城市的职业发展方向大概都是一样的，从入门级小程序员出发，然后到高级程序员，再到项目经理，然后逐渐脱离技术的主航道，直到被技术抛弃。有朋友戏谑道，长沙的程序员大概率都是一样的，靠经验的简单复制、依靠人际关系技巧或者靠资历，而真正钻研技术的非常少。\n\n哪怕有许多开发者得以突破转到了项目管理或其他方向，也很难能够在专业领域能够进一步的发展。毕竟首先企业大环境决定了个人的职业选择，其次就是很少有开发者能够明白的看清自己的职业发展规划，为了钱而生存无可厚非，然后整个职业生涯都迷迷茫茫，只能导致最终到了一定的年纪，就开始原地踏步了。\n\n![别瞎迷茫了](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/开发者的不断进取/image.png)\n\n# 二、周杰的成长历程\n而公众号DotNet骚操作的作者周杰则是小城市中少有的对技术始终保持热心的优秀开发者。周杰也是参加了我们第一次活动的三十位开发者中的一位。\n\n事实上很多年前（三年前）我就对他的名字有所耳闻，我的好几个朋友都说他的生活除了工作，家庭，剩下的就都是技术，是一个不折不扣的.NET技术狂。\n\n不过由于当时我主要是沉浸于小行业应用的泥坑之中，还不能体会.NET技术作为基础技术的巨大价值，自然而然相对来说比较无感。直到从泥坑中出来才能深深体会到技术的无穷魅力，也才真正理解在长沙这座城市，能够踏踏实实的以.NET技术作为自己的核心竞争力的开发者是何其的珍贵。\n\n当时的他的公众号【DotNet骚操作】还没开，以前他经常做开源项目。与许多内地城市的开源项目参与者热衷于刷开源项目，以fork了哪些项目贡献了多少文档的形式相比，他更倾向于自己造轮子。在他的github仓库（[https://github.com/sdcb](https://github.com/sdcb)）中还有许多各种各样的开源项目，这些都是他一点一滴的积累，几乎每个方法都会认真考虑代码背后的实现逻辑和性能优化，这些小巧玲珑、性能完美、代码整洁的小轮子，既让他在技能方面得到了积累，更是让其他人能从中获益。\n\n当时他还很少写博客，我就撺掇他写博客，他也说干就干，很快就写完一篇，那篇文章的具体内容我不太记得了，我只记得他对于技术问题的专注和专业，令我非常钦佩。\n\n这个时候就体现了他过去那么多年积累的价值，一旦开始写博客，就产量特别高。到现在短短五个月时间已经写了二十篇，而且素材越写越多，质量也越来越好，几乎每一篇都会成为博客园的推荐文章。他立下了一个flag，要写五十篇精品博客，让大家看到DotNet技术的美妙与精彩。\n\n我们偶尔会讨论.NET开发者的焦虑，许多.NET开发者都以自己选择了.NET为耻，总觉得是这个技术让自己的路越走越窄，经常在各种技术群里吐槽，说自己人生最大的错误就是选择了.Net。\n\n我们都对这种人觉得惋惜。他说，程序员只有因为自己没能努力学习而感到焦虑，真正掌握了一种开发技术，一定也能适应其他语言和技术。优秀开发者根本没时间焦虑，毕竟要学习的技能点随着年龄的增长越来越多，恨不能每天有48个小时来学习技术，哪里还有其他闲心去思考工作，家庭，技术之外的其他事情？只要自己技术过硬，哪里还需要担心什么未来前途不保？\n\n我们也经常讨论招人难的问题。尤其是对于基于.NET技术栈的企业来说，都遇到了这样的问题。一方面，确实越来越少的开发者使用.NET技术栈，一方面许多使用.NET技术栈的开发者都在从事边缘业务的开发者，很难触及底层技术或核心的技术。这并非企业行为，而是兴趣爱好驱动的。\n\n也必须承认，过去十年借助于互联网取得财富自由的.NET开发者几乎非常罕见，许多以前致力于研究.NET技术的开发者的出路都只能选择出国。这样的前提让功利的中国社会，越来越少人选择.NET技术。但是这也是.NET开发者最大的机会，好好学习技术、努力跳出自己的圈子，看看世界，选择将让你成长。\n\n我深以为然。程序员，不仅仅是.NET程序员或java程序员，能够用心学好技术，努力提高自己的技能，并时刻保持学习的精神，才是程序员的最大的价值。\n\n周杰正是按照这样的节奏在坚持自己的方向，他深刻的明白贪多嚼不烂的道理、没有追求一蹴而就，而是一步一个脚印，每一步都踏得严严实实。这种严于律己的优秀开发者的自我进取，也正是开发者所应该具备的自我刷新的精神。\n\n他使我明白，无论是什么岗位，在什么环境下，都应该清楚自己的职业发展方向，并努力提高自己的硬技能和软实力，这是开发者得以利足于时代永不淘汰的光辉色彩。\n\n![才华照](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/开发者的不断进取/person.png)\n\n（ps，大概需要减肥了。。）\n\n# 三、环境造人才\n在互联网技术飞速发展的今天，越是优秀的企业也往往最能凝聚最优秀的人才，正是这种人才间相互吸引的魅力，让企业更加优秀，也让人才得以借助企业提供的平台取得了更好的发展。\n\n他所在的公司是我一直神往的优秀互联网企业，也是长沙地区.NET开发者最多的企业。公司基于.NET方向的开发者超过一百人，福利好，制度好，充满了积极的分享氛围，正是这样的氛围才得以造就出周杰这样的优秀开发者。\n\n企业良好氛围的形成，并非个人或某几个人所能影响，而是一种从企业基因出发，到企业各个维度精神的集中体现，是集体智慧和创始人基因以及管理层管理能力的最好表达。\n\n互联网时代许多企业盲目追求眼前的快速扩展，总是恨不能招待机时间最长的二十几岁开发者完成原始积累之后再把资源甩开。而这家优秀的公司则并非如此，更在乎团队能力的整体提升。\n\n我仍然记得曾经问过他们的人事同学为何改成现在这个名字时，她说是总经理说的。不由得让我想起那个历经互联网大时代的优秀企业家，他曾经以一己之力，撑起了星城IT产业的繁荣。\n\n曾经，那些从这家公司毕业的优秀开发者都能成为其他公司最核心的开发者。而每年还有更多优秀开发者，正在这里跟随企业一起成长，正在成为企业和社会的顶梁支柱。\n\n生死看淡，不服来干的企业精神，让企业得以常盛不衰。积极分享、勇于进取、不断挑战，携手并进、共创辉煌的集体意识，让企业的人才队伍源远流长。\n\n人才、人才、人才，这正是在互联网大时代最宝贵的财富。\n\n（请大C小姐姐看到这篇文章后考虑一下广告赞助的形式）\n\n# 结语\n欢迎大家关注他的公众号，【DotNet骚操作】。也请大家记住他，一位年轻而充满激情的开发者。\n\n![DotNET骚操作公众号二维码](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/开发者的不断进取/qrcode.png)\n\n让我们一起跟随他的步伐，看看DotNet的一系列骚操作将如何给我们的生活带来更多精彩。\n\n\n","source":"_posts/随笔/开发者的不断进取，源自对技术的点滴追求.md","raw":"---\ntitle:  开发者的不断进取，源自对技术的点滴追求\ndate: 2019-11-5 16:28\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n\n# 身边的优秀开发者，【DotNET骚操作】周杰\n# 一，社区的小圈子\n今年3月的一次技术交流活动上，那是我们.NET技术社区第一次组织线下活动，由于没什么经验，所以活动组织得比较仓促，内容也比较一般，效果还是有点欠缺。当然，活动本身是必要的，这次活动上有幸认识了许多长沙的优秀开发者，这让我非常的高兴。\n\n事实上搞技术活动，与其说是交流技术，倒不如说是扩大圈子，交流感情，认识更多的朋友。毕竟每个职场人往往圈子都是固定的，哪怕是在大公司，真正经常来往的朋友其实也不过三两人而已。但是在北上广深的大城市，往往有时候刚刚认识几个朋友，对方可能就离开了，这也是一种遗憾。相对而言，在小城市或许也相对容易形成更加稳定的精准小圈子，这也是我认为一个社区存在的最大价值。\n\n小城市的职业发展方向大概都是一样的，从入门级小程序员出发，然后到高级程序员，再到项目经理，然后逐渐脱离技术的主航道，直到被技术抛弃。有朋友戏谑道，长沙的程序员大概率都是一样的，靠经验的简单复制、依靠人际关系技巧或者靠资历，而真正钻研技术的非常少。\n\n哪怕有许多开发者得以突破转到了项目管理或其他方向，也很难能够在专业领域能够进一步的发展。毕竟首先企业大环境决定了个人的职业选择，其次就是很少有开发者能够明白的看清自己的职业发展规划，为了钱而生存无可厚非，然后整个职业生涯都迷迷茫茫，只能导致最终到了一定的年纪，就开始原地踏步了。\n\n![别瞎迷茫了](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/开发者的不断进取/image.png)\n\n# 二、周杰的成长历程\n而公众号DotNet骚操作的作者周杰则是小城市中少有的对技术始终保持热心的优秀开发者。周杰也是参加了我们第一次活动的三十位开发者中的一位。\n\n事实上很多年前（三年前）我就对他的名字有所耳闻，我的好几个朋友都说他的生活除了工作，家庭，剩下的就都是技术，是一个不折不扣的.NET技术狂。\n\n不过由于当时我主要是沉浸于小行业应用的泥坑之中，还不能体会.NET技术作为基础技术的巨大价值，自然而然相对来说比较无感。直到从泥坑中出来才能深深体会到技术的无穷魅力，也才真正理解在长沙这座城市，能够踏踏实实的以.NET技术作为自己的核心竞争力的开发者是何其的珍贵。\n\n当时的他的公众号【DotNet骚操作】还没开，以前他经常做开源项目。与许多内地城市的开源项目参与者热衷于刷开源项目，以fork了哪些项目贡献了多少文档的形式相比，他更倾向于自己造轮子。在他的github仓库（[https://github.com/sdcb](https://github.com/sdcb)）中还有许多各种各样的开源项目，这些都是他一点一滴的积累，几乎每个方法都会认真考虑代码背后的实现逻辑和性能优化，这些小巧玲珑、性能完美、代码整洁的小轮子，既让他在技能方面得到了积累，更是让其他人能从中获益。\n\n当时他还很少写博客，我就撺掇他写博客，他也说干就干，很快就写完一篇，那篇文章的具体内容我不太记得了，我只记得他对于技术问题的专注和专业，令我非常钦佩。\n\n这个时候就体现了他过去那么多年积累的价值，一旦开始写博客，就产量特别高。到现在短短五个月时间已经写了二十篇，而且素材越写越多，质量也越来越好，几乎每一篇都会成为博客园的推荐文章。他立下了一个flag，要写五十篇精品博客，让大家看到DotNet技术的美妙与精彩。\n\n我们偶尔会讨论.NET开发者的焦虑，许多.NET开发者都以自己选择了.NET为耻，总觉得是这个技术让自己的路越走越窄，经常在各种技术群里吐槽，说自己人生最大的错误就是选择了.Net。\n\n我们都对这种人觉得惋惜。他说，程序员只有因为自己没能努力学习而感到焦虑，真正掌握了一种开发技术，一定也能适应其他语言和技术。优秀开发者根本没时间焦虑，毕竟要学习的技能点随着年龄的增长越来越多，恨不能每天有48个小时来学习技术，哪里还有其他闲心去思考工作，家庭，技术之外的其他事情？只要自己技术过硬，哪里还需要担心什么未来前途不保？\n\n我们也经常讨论招人难的问题。尤其是对于基于.NET技术栈的企业来说，都遇到了这样的问题。一方面，确实越来越少的开发者使用.NET技术栈，一方面许多使用.NET技术栈的开发者都在从事边缘业务的开发者，很难触及底层技术或核心的技术。这并非企业行为，而是兴趣爱好驱动的。\n\n也必须承认，过去十年借助于互联网取得财富自由的.NET开发者几乎非常罕见，许多以前致力于研究.NET技术的开发者的出路都只能选择出国。这样的前提让功利的中国社会，越来越少人选择.NET技术。但是这也是.NET开发者最大的机会，好好学习技术、努力跳出自己的圈子，看看世界，选择将让你成长。\n\n我深以为然。程序员，不仅仅是.NET程序员或java程序员，能够用心学好技术，努力提高自己的技能，并时刻保持学习的精神，才是程序员的最大的价值。\n\n周杰正是按照这样的节奏在坚持自己的方向，他深刻的明白贪多嚼不烂的道理、没有追求一蹴而就，而是一步一个脚印，每一步都踏得严严实实。这种严于律己的优秀开发者的自我进取，也正是开发者所应该具备的自我刷新的精神。\n\n他使我明白，无论是什么岗位，在什么环境下，都应该清楚自己的职业发展方向，并努力提高自己的硬技能和软实力，这是开发者得以利足于时代永不淘汰的光辉色彩。\n\n![才华照](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/开发者的不断进取/person.png)\n\n（ps，大概需要减肥了。。）\n\n# 三、环境造人才\n在互联网技术飞速发展的今天，越是优秀的企业也往往最能凝聚最优秀的人才，正是这种人才间相互吸引的魅力，让企业更加优秀，也让人才得以借助企业提供的平台取得了更好的发展。\n\n他所在的公司是我一直神往的优秀互联网企业，也是长沙地区.NET开发者最多的企业。公司基于.NET方向的开发者超过一百人，福利好，制度好，充满了积极的分享氛围，正是这样的氛围才得以造就出周杰这样的优秀开发者。\n\n企业良好氛围的形成，并非个人或某几个人所能影响，而是一种从企业基因出发，到企业各个维度精神的集中体现，是集体智慧和创始人基因以及管理层管理能力的最好表达。\n\n互联网时代许多企业盲目追求眼前的快速扩展，总是恨不能招待机时间最长的二十几岁开发者完成原始积累之后再把资源甩开。而这家优秀的公司则并非如此，更在乎团队能力的整体提升。\n\n我仍然记得曾经问过他们的人事同学为何改成现在这个名字时，她说是总经理说的。不由得让我想起那个历经互联网大时代的优秀企业家，他曾经以一己之力，撑起了星城IT产业的繁荣。\n\n曾经，那些从这家公司毕业的优秀开发者都能成为其他公司最核心的开发者。而每年还有更多优秀开发者，正在这里跟随企业一起成长，正在成为企业和社会的顶梁支柱。\n\n生死看淡，不服来干的企业精神，让企业得以常盛不衰。积极分享、勇于进取、不断挑战，携手并进、共创辉煌的集体意识，让企业的人才队伍源远流长。\n\n人才、人才、人才，这正是在互联网大时代最宝贵的财富。\n\n（请大C小姐姐看到这篇文章后考虑一下广告赞助的形式）\n\n# 结语\n欢迎大家关注他的公众号，【DotNet骚操作】。也请大家记住他，一位年轻而充满激情的开发者。\n\n![DotNET骚操作公众号二维码](https://raw.githubusercontent.com/farway000/techq.xyz/master/images/开发者的不断进取/qrcode.png)\n\n让我们一起跟随他的步伐，看看DotNet的一系列骚操作将如何给我们的生活带来更多精彩。\n\n\n","slug":"随笔/开发者的不断进取，源自对技术的点滴追求","published":1,"updated":"2019-11-05T08:54:51.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt9j004cn4vi3fu5ljoo","content":"<h1 id=\"身边的优秀开发者，【DotNET骚操作】周杰\"><a href=\"#身边的优秀开发者，【DotNET骚操作】周杰\" class=\"headerlink\" title=\"身边的优秀开发者，【DotNET骚操作】周杰\"></a>身边的优秀开发者，【DotNET骚操作】周杰</h1><h1 id=\"一，社区的小圈子\"><a href=\"#一，社区的小圈子\" class=\"headerlink\" title=\"一，社区的小圈子\"></a>一，社区的小圈子</h1><p>今年3月的一次技术交流活动上，那是我们.NET技术社区第一次组织线下活动，由于没什么经验，所以活动组织得比较仓促，内容也比较一般，效果还是有点欠缺。当然，活动本身是必要的，这次活动上有幸认识了许多长沙的优秀开发者，这让我非常的高兴。</p>\n<p>事实上搞技术活动，与其说是交流技术，倒不如说是扩大圈子，交流感情，认识更多的朋友。毕竟每个职场人往往圈子都是固定的，哪怕是在大公司，真正经常来往的朋友其实也不过三两人而已。但是在北上广深的大城市，往往有时候刚刚认识几个朋友，对方可能就离开了，这也是一种遗憾。相对而言，在小城市或许也相对容易形成更加稳定的精准小圈子，这也是我认为一个社区存在的最大价值。</p>\n<p>小城市的职业发展方向大概都是一样的，从入门级小程序员出发，然后到高级程序员，再到项目经理，然后逐渐脱离技术的主航道，直到被技术抛弃。有朋友戏谑道，长沙的程序员大概率都是一样的，靠经验的简单复制、依靠人际关系技巧或者靠资历，而真正钻研技术的非常少。</p>\n<p>哪怕有许多开发者得以突破转到了项目管理或其他方向，也很难能够在专业领域能够进一步的发展。毕竟首先企业大环境决定了个人的职业选择，其次就是很少有开发者能够明白的看清自己的职业发展规划，为了钱而生存无可厚非，然后整个职业生涯都迷迷茫茫，只能导致最终到了一定的年纪，就开始原地踏步了。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E4%B8%8D%E6%96%AD%E8%BF%9B%E5%8F%96/image.png\" alt=\"别瞎迷茫了\"></p>\n<h1 id=\"二、周杰的成长历程\"><a href=\"#二、周杰的成长历程\" class=\"headerlink\" title=\"二、周杰的成长历程\"></a>二、周杰的成长历程</h1><p>而公众号DotNet骚操作的作者周杰则是小城市中少有的对技术始终保持热心的优秀开发者。周杰也是参加了我们第一次活动的三十位开发者中的一位。</p>\n<p>事实上很多年前（三年前）我就对他的名字有所耳闻，我的好几个朋友都说他的生活除了工作，家庭，剩下的就都是技术，是一个不折不扣的.NET技术狂。</p>\n<p>不过由于当时我主要是沉浸于小行业应用的泥坑之中，还不能体会.NET技术作为基础技术的巨大价值，自然而然相对来说比较无感。直到从泥坑中出来才能深深体会到技术的无穷魅力，也才真正理解在长沙这座城市，能够踏踏实实的以.NET技术作为自己的核心竞争力的开发者是何其的珍贵。</p>\n<p>当时的他的公众号【DotNet骚操作】还没开，以前他经常做开源项目。与许多内地城市的开源项目参与者热衷于刷开源项目，以fork了哪些项目贡献了多少文档的形式相比，他更倾向于自己造轮子。在他的github仓库（<a href=\"https://github.com/sdcb\" target=\"_blank\" rel=\"noopener\">https://github.com/sdcb</a>）中还有许多各种各样的开源项目，这些都是他一点一滴的积累，几乎每个方法都会认真考虑代码背后的实现逻辑和性能优化，这些小巧玲珑、性能完美、代码整洁的小轮子，既让他在技能方面得到了积累，更是让其他人能从中获益。</p>\n<p>当时他还很少写博客，我就撺掇他写博客，他也说干就干，很快就写完一篇，那篇文章的具体内容我不太记得了，我只记得他对于技术问题的专注和专业，令我非常钦佩。</p>\n<p>这个时候就体现了他过去那么多年积累的价值，一旦开始写博客，就产量特别高。到现在短短五个月时间已经写了二十篇，而且素材越写越多，质量也越来越好，几乎每一篇都会成为博客园的推荐文章。他立下了一个flag，要写五十篇精品博客，让大家看到DotNet技术的美妙与精彩。</p>\n<p>我们偶尔会讨论.NET开发者的焦虑，许多.NET开发者都以自己选择了.NET为耻，总觉得是这个技术让自己的路越走越窄，经常在各种技术群里吐槽，说自己人生最大的错误就是选择了.Net。</p>\n<p>我们都对这种人觉得惋惜。他说，程序员只有因为自己没能努力学习而感到焦虑，真正掌握了一种开发技术，一定也能适应其他语言和技术。优秀开发者根本没时间焦虑，毕竟要学习的技能点随着年龄的增长越来越多，恨不能每天有48个小时来学习技术，哪里还有其他闲心去思考工作，家庭，技术之外的其他事情？只要自己技术过硬，哪里还需要担心什么未来前途不保？</p>\n<p>我们也经常讨论招人难的问题。尤其是对于基于.NET技术栈的企业来说，都遇到了这样的问题。一方面，确实越来越少的开发者使用.NET技术栈，一方面许多使用.NET技术栈的开发者都在从事边缘业务的开发者，很难触及底层技术或核心的技术。这并非企业行为，而是兴趣爱好驱动的。</p>\n<p>也必须承认，过去十年借助于互联网取得财富自由的.NET开发者几乎非常罕见，许多以前致力于研究.NET技术的开发者的出路都只能选择出国。这样的前提让功利的中国社会，越来越少人选择.NET技术。但是这也是.NET开发者最大的机会，好好学习技术、努力跳出自己的圈子，看看世界，选择将让你成长。</p>\n<p>我深以为然。程序员，不仅仅是.NET程序员或java程序员，能够用心学好技术，努力提高自己的技能，并时刻保持学习的精神，才是程序员的最大的价值。</p>\n<p>周杰正是按照这样的节奏在坚持自己的方向，他深刻的明白贪多嚼不烂的道理、没有追求一蹴而就，而是一步一个脚印，每一步都踏得严严实实。这种严于律己的优秀开发者的自我进取，也正是开发者所应该具备的自我刷新的精神。</p>\n<p>他使我明白，无论是什么岗位，在什么环境下，都应该清楚自己的职业发展方向，并努力提高自己的硬技能和软实力，这是开发者得以利足于时代永不淘汰的光辉色彩。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E4%B8%8D%E6%96%AD%E8%BF%9B%E5%8F%96/person.png\" alt=\"才华照\"></p>\n<p>（ps，大概需要减肥了。。）</p>\n<h1 id=\"三、环境造人才\"><a href=\"#三、环境造人才\" class=\"headerlink\" title=\"三、环境造人才\"></a>三、环境造人才</h1><p>在互联网技术飞速发展的今天，越是优秀的企业也往往最能凝聚最优秀的人才，正是这种人才间相互吸引的魅力，让企业更加优秀，也让人才得以借助企业提供的平台取得了更好的发展。</p>\n<p>他所在的公司是我一直神往的优秀互联网企业，也是长沙地区.NET开发者最多的企业。公司基于.NET方向的开发者超过一百人，福利好，制度好，充满了积极的分享氛围，正是这样的氛围才得以造就出周杰这样的优秀开发者。</p>\n<p>企业良好氛围的形成，并非个人或某几个人所能影响，而是一种从企业基因出发，到企业各个维度精神的集中体现，是集体智慧和创始人基因以及管理层管理能力的最好表达。</p>\n<p>互联网时代许多企业盲目追求眼前的快速扩展，总是恨不能招待机时间最长的二十几岁开发者完成原始积累之后再把资源甩开。而这家优秀的公司则并非如此，更在乎团队能力的整体提升。</p>\n<p>我仍然记得曾经问过他们的人事同学为何改成现在这个名字时，她说是总经理说的。不由得让我想起那个历经互联网大时代的优秀企业家，他曾经以一己之力，撑起了星城IT产业的繁荣。</p>\n<p>曾经，那些从这家公司毕业的优秀开发者都能成为其他公司最核心的开发者。而每年还有更多优秀开发者，正在这里跟随企业一起成长，正在成为企业和社会的顶梁支柱。</p>\n<p>生死看淡，不服来干的企业精神，让企业得以常盛不衰。积极分享、勇于进取、不断挑战，携手并进、共创辉煌的集体意识，让企业的人才队伍源远流长。</p>\n<p>人才、人才、人才，这正是在互联网大时代最宝贵的财富。</p>\n<p>（请大C小姐姐看到这篇文章后考虑一下广告赞助的形式）</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>欢迎大家关注他的公众号，【DotNet骚操作】。也请大家记住他，一位年轻而充满激情的开发者。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E4%B8%8D%E6%96%AD%E8%BF%9B%E5%8F%96/qrcode.png\" alt=\"DotNET骚操作公众号二维码\"></p>\n<p>让我们一起跟随他的步伐，看看DotNet的一系列骚操作将如何给我们的生活带来更多精彩。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"身边的优秀开发者，【DotNET骚操作】周杰\"><a href=\"#身边的优秀开发者，【DotNET骚操作】周杰\" class=\"headerlink\" title=\"身边的优秀开发者，【DotNET骚操作】周杰\"></a>身边的优秀开发者，【DotNET骚操作】周杰</h1><h1 id=\"一，社区的小圈子\"><a href=\"#一，社区的小圈子\" class=\"headerlink\" title=\"一，社区的小圈子\"></a>一，社区的小圈子</h1><p>今年3月的一次技术交流活动上，那是我们.NET技术社区第一次组织线下活动，由于没什么经验，所以活动组织得比较仓促，内容也比较一般，效果还是有点欠缺。当然，活动本身是必要的，这次活动上有幸认识了许多长沙的优秀开发者，这让我非常的高兴。</p>\n<p>事实上搞技术活动，与其说是交流技术，倒不如说是扩大圈子，交流感情，认识更多的朋友。毕竟每个职场人往往圈子都是固定的，哪怕是在大公司，真正经常来往的朋友其实也不过三两人而已。但是在北上广深的大城市，往往有时候刚刚认识几个朋友，对方可能就离开了，这也是一种遗憾。相对而言，在小城市或许也相对容易形成更加稳定的精准小圈子，这也是我认为一个社区存在的最大价值。</p>\n<p>小城市的职业发展方向大概都是一样的，从入门级小程序员出发，然后到高级程序员，再到项目经理，然后逐渐脱离技术的主航道，直到被技术抛弃。有朋友戏谑道，长沙的程序员大概率都是一样的，靠经验的简单复制、依靠人际关系技巧或者靠资历，而真正钻研技术的非常少。</p>\n<p>哪怕有许多开发者得以突破转到了项目管理或其他方向，也很难能够在专业领域能够进一步的发展。毕竟首先企业大环境决定了个人的职业选择，其次就是很少有开发者能够明白的看清自己的职业发展规划，为了钱而生存无可厚非，然后整个职业生涯都迷迷茫茫，只能导致最终到了一定的年纪，就开始原地踏步了。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E4%B8%8D%E6%96%AD%E8%BF%9B%E5%8F%96/image.png\" alt=\"别瞎迷茫了\"></p>\n<h1 id=\"二、周杰的成长历程\"><a href=\"#二、周杰的成长历程\" class=\"headerlink\" title=\"二、周杰的成长历程\"></a>二、周杰的成长历程</h1><p>而公众号DotNet骚操作的作者周杰则是小城市中少有的对技术始终保持热心的优秀开发者。周杰也是参加了我们第一次活动的三十位开发者中的一位。</p>\n<p>事实上很多年前（三年前）我就对他的名字有所耳闻，我的好几个朋友都说他的生活除了工作，家庭，剩下的就都是技术，是一个不折不扣的.NET技术狂。</p>\n<p>不过由于当时我主要是沉浸于小行业应用的泥坑之中，还不能体会.NET技术作为基础技术的巨大价值，自然而然相对来说比较无感。直到从泥坑中出来才能深深体会到技术的无穷魅力，也才真正理解在长沙这座城市，能够踏踏实实的以.NET技术作为自己的核心竞争力的开发者是何其的珍贵。</p>\n<p>当时的他的公众号【DotNet骚操作】还没开，以前他经常做开源项目。与许多内地城市的开源项目参与者热衷于刷开源项目，以fork了哪些项目贡献了多少文档的形式相比，他更倾向于自己造轮子。在他的github仓库（<a href=\"https://github.com/sdcb\" target=\"_blank\" rel=\"noopener\">https://github.com/sdcb</a>）中还有许多各种各样的开源项目，这些都是他一点一滴的积累，几乎每个方法都会认真考虑代码背后的实现逻辑和性能优化，这些小巧玲珑、性能完美、代码整洁的小轮子，既让他在技能方面得到了积累，更是让其他人能从中获益。</p>\n<p>当时他还很少写博客，我就撺掇他写博客，他也说干就干，很快就写完一篇，那篇文章的具体内容我不太记得了，我只记得他对于技术问题的专注和专业，令我非常钦佩。</p>\n<p>这个时候就体现了他过去那么多年积累的价值，一旦开始写博客，就产量特别高。到现在短短五个月时间已经写了二十篇，而且素材越写越多，质量也越来越好，几乎每一篇都会成为博客园的推荐文章。他立下了一个flag，要写五十篇精品博客，让大家看到DotNet技术的美妙与精彩。</p>\n<p>我们偶尔会讨论.NET开发者的焦虑，许多.NET开发者都以自己选择了.NET为耻，总觉得是这个技术让自己的路越走越窄，经常在各种技术群里吐槽，说自己人生最大的错误就是选择了.Net。</p>\n<p>我们都对这种人觉得惋惜。他说，程序员只有因为自己没能努力学习而感到焦虑，真正掌握了一种开发技术，一定也能适应其他语言和技术。优秀开发者根本没时间焦虑，毕竟要学习的技能点随着年龄的增长越来越多，恨不能每天有48个小时来学习技术，哪里还有其他闲心去思考工作，家庭，技术之外的其他事情？只要自己技术过硬，哪里还需要担心什么未来前途不保？</p>\n<p>我们也经常讨论招人难的问题。尤其是对于基于.NET技术栈的企业来说，都遇到了这样的问题。一方面，确实越来越少的开发者使用.NET技术栈，一方面许多使用.NET技术栈的开发者都在从事边缘业务的开发者，很难触及底层技术或核心的技术。这并非企业行为，而是兴趣爱好驱动的。</p>\n<p>也必须承认，过去十年借助于互联网取得财富自由的.NET开发者几乎非常罕见，许多以前致力于研究.NET技术的开发者的出路都只能选择出国。这样的前提让功利的中国社会，越来越少人选择.NET技术。但是这也是.NET开发者最大的机会，好好学习技术、努力跳出自己的圈子，看看世界，选择将让你成长。</p>\n<p>我深以为然。程序员，不仅仅是.NET程序员或java程序员，能够用心学好技术，努力提高自己的技能，并时刻保持学习的精神，才是程序员的最大的价值。</p>\n<p>周杰正是按照这样的节奏在坚持自己的方向，他深刻的明白贪多嚼不烂的道理、没有追求一蹴而就，而是一步一个脚印，每一步都踏得严严实实。这种严于律己的优秀开发者的自我进取，也正是开发者所应该具备的自我刷新的精神。</p>\n<p>他使我明白，无论是什么岗位，在什么环境下，都应该清楚自己的职业发展方向，并努力提高自己的硬技能和软实力，这是开发者得以利足于时代永不淘汰的光辉色彩。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E4%B8%8D%E6%96%AD%E8%BF%9B%E5%8F%96/person.png\" alt=\"才华照\"></p>\n<p>（ps，大概需要减肥了。。）</p>\n<h1 id=\"三、环境造人才\"><a href=\"#三、环境造人才\" class=\"headerlink\" title=\"三、环境造人才\"></a>三、环境造人才</h1><p>在互联网技术飞速发展的今天，越是优秀的企业也往往最能凝聚最优秀的人才，正是这种人才间相互吸引的魅力，让企业更加优秀，也让人才得以借助企业提供的平台取得了更好的发展。</p>\n<p>他所在的公司是我一直神往的优秀互联网企业，也是长沙地区.NET开发者最多的企业。公司基于.NET方向的开发者超过一百人，福利好，制度好，充满了积极的分享氛围，正是这样的氛围才得以造就出周杰这样的优秀开发者。</p>\n<p>企业良好氛围的形成，并非个人或某几个人所能影响，而是一种从企业基因出发，到企业各个维度精神的集中体现，是集体智慧和创始人基因以及管理层管理能力的最好表达。</p>\n<p>互联网时代许多企业盲目追求眼前的快速扩展，总是恨不能招待机时间最长的二十几岁开发者完成原始积累之后再把资源甩开。而这家优秀的公司则并非如此，更在乎团队能力的整体提升。</p>\n<p>我仍然记得曾经问过他们的人事同学为何改成现在这个名字时，她说是总经理说的。不由得让我想起那个历经互联网大时代的优秀企业家，他曾经以一己之力，撑起了星城IT产业的繁荣。</p>\n<p>曾经，那些从这家公司毕业的优秀开发者都能成为其他公司最核心的开发者。而每年还有更多优秀开发者，正在这里跟随企业一起成长，正在成为企业和社会的顶梁支柱。</p>\n<p>生死看淡，不服来干的企业精神，让企业得以常盛不衰。积极分享、勇于进取、不断挑战，携手并进、共创辉煌的集体意识，让企业的人才队伍源远流长。</p>\n<p>人才、人才、人才，这正是在互联网大时代最宝贵的财富。</p>\n<p>（请大C小姐姐看到这篇文章后考虑一下广告赞助的形式）</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>欢迎大家关注他的公众号，【DotNet骚操作】。也请大家记住他，一位年轻而充满激情的开发者。</p>\n<p><img src=\"https://raw.githubusercontent.com/farway000/techq.xyz/master/images/%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E4%B8%8D%E6%96%AD%E8%BF%9B%E5%8F%96/qrcode.png\" alt=\"DotNET骚操作公众号二维码\"></p>\n<p>让我们一起跟随他的步伐，看看DotNet的一系列骚操作将如何给我们的生活带来更多精彩。</p>\n"},{"title":"长沙IT技术圈的百万大佬，何处寻觅？","date":"2020-04-10T01:10:00.000Z","author":"邹溪源","_content":"# 引子\n不知不觉，IT技术圈开始流传起“百万年薪”的故事，有人问我，长沙有百万大佬么？其实我也不知道。\n\n# 一  背景\n长沙自古以来就是文风鼎盛之地，在今天也同样如此。\n\n目前长沙有211、985、一本、二本等本科院校数十所，大专以上的院校上百所.每年从长沙毕业，怀揣梦想选择去北上广深杭奋斗的互联网从业人员不下数万人，其中从事技术岗位的（例如开发、测试、运维等）或许是占比最大的部分。\n\n从某种意义上来说，湖南技术人可能真的撑起了全国互联网的半边天。（当然，这样的说法没有统计数据为准，笔者说了不算）。\n\n不过，一直以来，由于沿海地区落户政策的严格、购房和居家生活的成本高，使得许多离开湖南的开发者越来越倾向于选择回到长沙寻找适合自己的工作。\n\n他们都能在长沙找到合适的工作么？他们能成为“百万大佬”么？\n\n# 二 几个故事\n## 1\n老Q是我的同学，大学毕业后，我回了家乡长沙，他则选择去深圳发展。在毕业前的一次吃饭过程中，他说打算先去深圳看看，过几年在深圳混不下去了，再回长沙。\n\n2015年上半年，他的同学邀请他创业，他果断的把在酷派的工作辞了，回到了长沙。但经过半年的折腾，他的创业梦想最终还是“黄”了，又临近年光，他决定留在长沙找工作。\n\n由于他在酷派当时主要从事手机基站测试的相关领域工作，而在长沙实际上几乎没有对应的工作，除了软件测试，就是纯粹的硬件测试。而由于他属于转行的性质，最终工资..更是相当微薄。最终他还是离开了长沙，回到了深圳。\n\n一晃又是五年，当我在跟他交流是否有兴趣回长沙时，他一脸苦涩的说，就算想回，估计也不会在从事IT相关的行业了。\n\n“当时以为混不下去就回长沙，其实长沙反而比北上广深更难混下去。”\n\n## 2\n老L是2014年前后回的长沙。\n\n老L之前在广州，那是一家还不错的上市公司，他在这家公司也算是中层管理者，但考虑到在广州买房不太现实，而且长期离乡背井的工作，也让他对家乡产生了深深的眷恋之情，再加上他的对象也希望他回长沙发展，最终他抛弃了那份月收入破2w的工作，回到了长沙。\n\n回到长沙找工作之前，他找同学打听了长沙当时的开发者工资水平，他的同学告诉他，像这样七八年经验的.NET开发者，大概顶尖水平应该是万把块钱。\n\n老L是一位务实的开发者，他想到自己在广州那家公司，实际上每天投入到软件开发工作中的时间，其实只有不到3个小时，要与专业从事技术开发、天天浸淫其道的高手相比，还存在巨大的差距。\n\n既然顶尖水平才一万，那自己显然只能顶别人的六成，开六千肯定没问题。\n\n结果面试时，公司给他开了8k，顿时他就很欣喜。\n\n虽然他后来又离开了这家公司，但他还是给予了这家公司很高的评价：这充分证明，其实长沙的公司非常识货。\n\n## 3\n老C也是差不多同期回的长沙，当时他已经是一家大型互联网公司的中层管理者。\n\n（这家公司在他离开之后，迎来了一波飞速发展，引入了好几十个华为毕业的员工后，使得公司的整体技术水平和能力都有了巨大的飞跃，在2017年前后成功上市，之前跟他同期加入公司的同事、以及他在公司时招聘的人才，几乎都成为公司的核心骨干或甚至是事业部、分公司总经理。）\n\n老C回到长沙的原因，是因为他存够了能够在深圳付首付款的钱，他的家人却硬是说服他拿这个钱在长沙买房。\n\n当然，同样的钱，在深圳只能买偏僻城乡结合部的小两居，而回长沙则可以买中心地带，地铁口，公园口的120平三室一厅。\n\n他拿着这个钱之后，回来看了一圈房子，发现居然可以选择的余地这么多，而且还这么舒服的，当时就决定回长沙定居，他很快就把深圳的工作辞了，然后回到了长沙找工作。\n\n当他回到长沙找工作之后，得益于一个机会，有幸找到了一个非常有钱的老板，这位老板拉了一个规模还算大的团队，也非常重视像他这样优秀的管理者，以大概15k或更高的薪酬聘用了他。这在当时的长沙已经算非常不错的薪资，使得他能够维持相对高的生活条件。\n\n但公司的资金很快就烧完了，公司解散后，他被迫回到职场求职。\n\n他的心理预算是15k，但在长沙能够开得起15k的公司实在太少，而且这些公司对技术要求非常高，由于他平时工作中对技术的深度钻研有限，最终都被拒之门外。\n\n还好得益于他在HIS领域扎实的行业经验+原公司不错的背景，使得他能够在一家公立医院找到还算可以的工作。\n\n## 4\n当然，并非所有的开发者回到长沙都会面临工资砍一截、甚至减半的情况，我的身边也不乏一些开发者，从北上广深杭回到长沙之后，还能找到与原来公司工资差不多的工作、甚至还有的能找到超过在深圳工资的工作。\n\n那究竟是什么原因决定了长沙开发者的薪资水平，难道真的是长沙的互联网水平发展太低了么？\n\n# 三 长沙的开发者工资有多高？\n## 1\n在长沙有哪些公司的工资最高？\n\n首先还是得排除BAT公司和大型互联网公司也开始在长沙成立相应的分支机构或分公司、子公司。这些公司在长沙也好、深圳也好，其实工资是按照职级来，与城市关系不大。我的一位堂叔在恒大集团（虽然远离IT圈子），但他的工资还不错，据说在长沙一年的收入可以买一套房。。所以。。你懂的，如果你想回长沙，最好的办法就是选择加入BAT，然后公派回老家发展，大概这才是真正的“衣锦还乡”。\n\n其次首屈一指的大概是芒果TV。据悉..芒果TV的前台，每个月虽然工资不高，才8k，但每年能拿到手的年终奖也超过了16万。。而普通开发者，一般每年能够拿到手的收入是20w以上。\n\n稍微牛逼一点的开发者，其实工资并不亚于北上广深的同类型公司。\n\n关键是芒果TV朝九晚五，不用加班，工资还挺轻松，而且公司还挺不错，说出去挺有自豪感。\n\n我一位大学同学表示，他老公曾经在爱奇艺担任运维工程师，回长沙之后去了芒果TV，工资和爱奇艺齐平，工作压力少了一半。\n\n![图片](https://uploader.shimo.im/f/sjbRZaGv7hw4svjV.png!thumbnail)\n\n## 2\n其次，大概这张图上的公司，工资都还可以。。。但，离北上广深的同等排名的公司相比，应该还是差距比较大。\n\n此处还需点出几家公司，建议大家多投简历，例如我所了解的御泥坊、问卷星、兴盛优选、蜜獾信息等公司，他们对人才还是挺重视的，工资也还挺高的，值得大家关注关注。。\n\n当然，与北上广深的大公司比起来，嗯，还是别比了。\n\n另外，内推可能比社招工资高，如果你是大佬，想走社招加入这几家公司，估计会被压一些价。。。\n\n## 3\n那长沙的开发者普遍工资大概是什么水平？或许不同的语言体系有一定的不同，例如后端，一位顶尖的后端工程师，大概是30-50k。\n\n当然，目前我还没接触到突破50k的开发者。我接触到突破30k的开发者。。对不起，他们已经不是开发者了，基本上都是公司管理层、甚至在不少公司，甚至是高管级别。\n\n而资深开发者，基本上是在20-40k左右；高级开发者，应该是12-25k左右，中级开发者，大概是8-15k左右，初级开发者，大概是4-8k左右。在这一点上，Java和.NET或其他语言，其实区别不大。\n\n## 4\n当然，我的圈层束缚了我的想象力，显然还有更高收入的群体。。在我了解的圈层。\n\n例如芒果TV。。一个高级运维就能突破30k，而其他公司，不管你k8s\\openstack玩得多\n\n溜，20k已经是天花板了。\n\n圈层之外。。大概年薪50万到80万，其实也是长沙一些大型互联网公司技术高管的天花板。其实有的大公司高管，也没能突破40k，不过既然已经成为高管了，估计他们已经不靠工资，更多的是靠公司的业绩提成或股份分红吧。\n\n*5*\n\n对不起，所有初级、中级、高级、资深开发者，并不是按年资来衡量的，而是看真实实力来衡量。你不能说你工作十年，就一定是高级开发者。例如，如果你做后端开发，连gc、领域驱动设计、分布式缓存、NoSQL都没听过，可能你确实不太适合寻找跨行业的职位。。\n\n然而，事实上大多数开发者都是这么自以为的。我也面过一些工作十年的开发者，他们在特定的业务领域，或许是业务大佬，但一旦离开对应的领域求职，几乎找不到合适的工作。例如，我曾经面过一些做建筑信息化的开发者，工作也有十年多，但一旦问到涉及并发、缓存、gc等问题，他们基本上都没听过。与这类似的还有从事制造业信息化的开发者，可能连.NET技术中的一些新特性，例如async/await都可能没听过。就像搞java的，连稍微新一点的语法都没用过，又该如何被称为“高级Java工程师”。\n\n作为开发者，懂基础概念和术语还是很重要的，不过，长沙的技术圈子，似乎还没形成这样的氛围。面试时，有时不能问技术问题。\n\n当然，退一万不讲，公司不怎么地，居然还好意思问技术问题，不就是“拥有造核弹的心，却只有拧螺丝钉的命么？”。。。\n\n# 四  我技术牛逼，为何就不能拿高工资？\n## 1\n我已经见过不下十位优秀开发者，他们的岗位基本上都是技术经理、技术总监、架构师，而待遇要求基本上都是18k以上。结果他们的求职期无一例外，都达到了一个月以上，最终不得不一点点把自己的心理预期进一步降低，进一步降低，然后在15k左右徘徊。当然，这些都是.NET开发者，如果是Java开发者，可能多那么几千块钱。。（不过Java的竞争更激烈）\n\n这是由于他们能力不行造成的么？绝非如此，我相信，他们在没回长沙之前，公司也是好平台、他们能够成为公司的核心骨干，也证明他们非常优秀。\n\n## 2\n但是。。长沙确实是互联网的荒漠，能够给开发者带来更加丰厚收入、自豪感的公司，实在是太少太少。前面提到的那些技术管理层都是非常优秀的跨职能人才，这让他们能够在技术岗位快速进步的同时，还能很快的成为公司的管理者，给公司的发展带来很大的帮助。只是从他们离开公司开始，就无法以对应的title寻找工作，只能寻找技术领域的高级开发者。\n\n而市场上管理岗位显然少于技术岗位，且不说竞争是否激烈，更何况现在的技术岗位对于技能的要求本身就已经逐渐提高了。当你踏上管理者的岗位开始，一天又能维持几个小时的编码时间呢？你真的会持续刷新自己的技术，保持技术的持久战斗力么？\n\n或许。其实你内心，其实已经不再重视“编码”这个硬技能了吧。\n\n另外，依据“彼得原理”，大部分公司其实找的是当前岗位的胜任者，而不是超出对应岗位的“进阶者”。如果你的公司天花板非常低，那你又如何能在那些有高天花板的公司找到高职级的工作。即便有，或许也很难胜任吧。\n\n## 4\n长沙的软件公司或开发者技术不行么？这也是个悖论。文无第一，武无第二。工资不行不代表技术不行。 许多长沙的公司虽然公司效益远远比不上BAT大公司，一年净收入突破几千万就算是个不错的公司了，但这不能说明公司技术不行。恰好相反，一波一波回长沙的开发者，总会有人一点点把长沙的技术水平逐渐提高。\n\n技术水平的高低没有评判标准，许多大佬技术牛逼，但脱离了公司的平台效应和团队战斗力，单兵作战能力可能并不强。\n\n相比之下，许多长沙的开发者平时下班之后就是学习技术，交流技术，一天八小时撸码，还有四小时学习，这样的开发者技术还能差到哪里去。\n\n例如前面提到的蜜獾信息，就形成了这样一群人。而且公司待遇不错，技术氛围也很不错，公司管理层也重视技术和企业文化氛围，早就把“不加班，不写过时的文档，每两周发布一个版本的敏捷发布”玩的挺顺利的，非常适合大家关注。\n\n## 5\n当然，限于体量原因，许多技术含量较高的场景，长沙还真没有。我一位朋友吐槽，长沙的运维人员，还停留在最多百台服务器运维的能力，几乎相当于他2015年的水平。现在在长沙，能够玩得起自动化测试的公司，都还算不错的公司，所以如果你是拥有自动化测试经验的测试工程师，其实也还是有很多机会。\n\n但那些大公司才有的细分岗位，例如之前说的基站测试，还有咨询师，技术写作专家，配置管理工程师，甚至是python大数据分析师，长沙大概还几乎没有。长沙市场上python相关的职位还非常少，go语言的也并不多。。。\n\n## 6\n长沙的公司为什么不愿意花高工资聘请大牛呢？其实这也是一些回长沙的求职者向我吐槽的。也许他们的言下之意是：为啥不聘请“像自己这样的大牛”呢？\n\n好吧，其实长沙的IT圈也舍得花力气聘请大牛，像已经成为社区电商行业的领跑者的兴盛优选，公司本身已经有不少大牛，而且也愿意用月薪35到60以上的标准聘请阿里巴巴p7以上的开发者，考虑到长沙的物价水平，其实已经挺不错了。\n\n*如果你是真大牛。。我可以帮你推荐一番。*\n\n总之，长沙的IT公司并非不舍得花高工资聘请大佬，而是因为。。。还没遇到真正牛逼的大佬。\n\n# 五 高工资是怎么来的？\n## 1\n谈起高工资，我们得想想北上广深那么多百万年薪的程序员，他们的高工资是怎么来的？\n\n在互联网飞速发展的今天，靠近资本的北上广深杭已经成为风口浪尖，许多与互联网概念相关的企业都跟着业绩腾飞，员工的薪资也跟着水涨船高，此处就不需要举例子了，毕竟BAT那么多家公司的优秀开发者们，用他们的身价证明，自己的一份努力，完全可以代表中国互联网开发者的顶尖收入水平。\n\n但。。在这些行业巨头之外，还有许多开发者，其实依然处于温饱线的边缘，或稍微比温饱线好那么一点，财务自由？35岁退休？年入百万？大部分人别想了。是由于选择大于努力造成的？还是由于平时温水煮青蛙，不够努力造成的？其实基本上都不是的。事实上，许多开发者，例如一些外包或制造业外包的开发者，他们的条件远比BAT公司更艰苦，每周的工作时长更高，但拿的收入水平，却仅仅只是BAT开发者的零头，甚至不如。\n\n这大概有点像拿非洲人民和美国资本家对比。用经济学术语来说。。就是“剪刀差”（我打算称为工资剪刀差）。\n\n![图片](https://uploader.shimo.im/f/3jlkvgUiFD89FM37.png!thumbnail)\n\n互联网企业员工的高收入，其实来源于互联网企业本身对于资本的凝聚力和投资者对于未来的期望所带来的溢价。而有许多互联网公司其实本身已经不需要靠利润来发工资，仅仅依靠“市梦率”，就能维持公司的飞速发展，让员工获得足够的福利。\n\n## 2\n而长沙的互联网公司并不多，大部分都是所谓“行业互联网”，虽然沾上了“互联网”的名，却没有互联网的命。\n\n“行业互联网”企业由于发展较为缓慢、或者已经较为稳定，事实上已经不太可能从投资者市场获得更高，由于只能靠利润来给员工发工资。\n\n所以，员工的工资包含了公司获得的投资，公司的利润，公司的品牌溢价、个人的品牌溢价和个人的核心竞争力，个人的机遇。如果你核心竞争力强，让那些优秀的公司能够更早的认识你，自然而然也很容易成为职场上的香饽饽。\n\n## 3\n如果品牌竞争力一般，该如何寻找合适自己的工作呢？\n\n![图片](https://uploader.shimo.im/f/CNVf9Df1pBrsO07B.png!thumbnail)\n\n认清形势，放弃幻想。回归现实，别妄图拿那么高的工资。找一个自己感兴趣的行业、公司，踏踏实实干下去，通过自己的努力，为公司创造更大的价值，自然而然，你就获得了更好的发展。\n\n当你回到长沙，就别在幻想通过上班来获得“暴富”了。长沙这样的土壤，其实更像普通人凭借自己双手改变家庭命运的跳板。\n\n例如，校管家，就是这样的公司，老板们勤勤恳恳、踏踏实实，靠自己的努力，创造了一家优秀的公司，并成功的获得了投资者们的不断关注。在长沙，这样的公司不下数十家。\n\n# 结语\n与其他城市相比，长沙的IT业态或许更趋于“务实”“勤勉”“实干”“坚持”。\n\n长沙不是互联网人淘金的热土，也不是一夜暴富者的摇篮。\n\n在沿海地区互联网的热闹喧嚣之外，长沙其实就是一个这样静静发展、一声不响就创造出不错佳绩的“小而美”的现代化城市。\n\n在长沙，也许你见不到太多“英雄”，却充满了各种各样、努力付出、细心耕耘、用三年、五年或更长的时间来用心助力公司成长的“普通人”。\n\n显然，这个世界，既要“冒险家”“野心家”“成功学”，同样也需要“普通人”。\n\n","source":"_posts/随笔/how-to-find-millon-in-changsha-programmer.md","raw":"---\ntitle:  长沙IT技术圈的百万大佬，何处寻觅？\ndate: 2020-04-10 9:10\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n# 引子\n不知不觉，IT技术圈开始流传起“百万年薪”的故事，有人问我，长沙有百万大佬么？其实我也不知道。\n\n# 一  背景\n长沙自古以来就是文风鼎盛之地，在今天也同样如此。\n\n目前长沙有211、985、一本、二本等本科院校数十所，大专以上的院校上百所.每年从长沙毕业，怀揣梦想选择去北上广深杭奋斗的互联网从业人员不下数万人，其中从事技术岗位的（例如开发、测试、运维等）或许是占比最大的部分。\n\n从某种意义上来说，湖南技术人可能真的撑起了全国互联网的半边天。（当然，这样的说法没有统计数据为准，笔者说了不算）。\n\n不过，一直以来，由于沿海地区落户政策的严格、购房和居家生活的成本高，使得许多离开湖南的开发者越来越倾向于选择回到长沙寻找适合自己的工作。\n\n他们都能在长沙找到合适的工作么？他们能成为“百万大佬”么？\n\n# 二 几个故事\n## 1\n老Q是我的同学，大学毕业后，我回了家乡长沙，他则选择去深圳发展。在毕业前的一次吃饭过程中，他说打算先去深圳看看，过几年在深圳混不下去了，再回长沙。\n\n2015年上半年，他的同学邀请他创业，他果断的把在酷派的工作辞了，回到了长沙。但经过半年的折腾，他的创业梦想最终还是“黄”了，又临近年光，他决定留在长沙找工作。\n\n由于他在酷派当时主要从事手机基站测试的相关领域工作，而在长沙实际上几乎没有对应的工作，除了软件测试，就是纯粹的硬件测试。而由于他属于转行的性质，最终工资..更是相当微薄。最终他还是离开了长沙，回到了深圳。\n\n一晃又是五年，当我在跟他交流是否有兴趣回长沙时，他一脸苦涩的说，就算想回，估计也不会在从事IT相关的行业了。\n\n“当时以为混不下去就回长沙，其实长沙反而比北上广深更难混下去。”\n\n## 2\n老L是2014年前后回的长沙。\n\n老L之前在广州，那是一家还不错的上市公司，他在这家公司也算是中层管理者，但考虑到在广州买房不太现实，而且长期离乡背井的工作，也让他对家乡产生了深深的眷恋之情，再加上他的对象也希望他回长沙发展，最终他抛弃了那份月收入破2w的工作，回到了长沙。\n\n回到长沙找工作之前，他找同学打听了长沙当时的开发者工资水平，他的同学告诉他，像这样七八年经验的.NET开发者，大概顶尖水平应该是万把块钱。\n\n老L是一位务实的开发者，他想到自己在广州那家公司，实际上每天投入到软件开发工作中的时间，其实只有不到3个小时，要与专业从事技术开发、天天浸淫其道的高手相比，还存在巨大的差距。\n\n既然顶尖水平才一万，那自己显然只能顶别人的六成，开六千肯定没问题。\n\n结果面试时，公司给他开了8k，顿时他就很欣喜。\n\n虽然他后来又离开了这家公司，但他还是给予了这家公司很高的评价：这充分证明，其实长沙的公司非常识货。\n\n## 3\n老C也是差不多同期回的长沙，当时他已经是一家大型互联网公司的中层管理者。\n\n（这家公司在他离开之后，迎来了一波飞速发展，引入了好几十个华为毕业的员工后，使得公司的整体技术水平和能力都有了巨大的飞跃，在2017年前后成功上市，之前跟他同期加入公司的同事、以及他在公司时招聘的人才，几乎都成为公司的核心骨干或甚至是事业部、分公司总经理。）\n\n老C回到长沙的原因，是因为他存够了能够在深圳付首付款的钱，他的家人却硬是说服他拿这个钱在长沙买房。\n\n当然，同样的钱，在深圳只能买偏僻城乡结合部的小两居，而回长沙则可以买中心地带，地铁口，公园口的120平三室一厅。\n\n他拿着这个钱之后，回来看了一圈房子，发现居然可以选择的余地这么多，而且还这么舒服的，当时就决定回长沙定居，他很快就把深圳的工作辞了，然后回到了长沙找工作。\n\n当他回到长沙找工作之后，得益于一个机会，有幸找到了一个非常有钱的老板，这位老板拉了一个规模还算大的团队，也非常重视像他这样优秀的管理者，以大概15k或更高的薪酬聘用了他。这在当时的长沙已经算非常不错的薪资，使得他能够维持相对高的生活条件。\n\n但公司的资金很快就烧完了，公司解散后，他被迫回到职场求职。\n\n他的心理预算是15k，但在长沙能够开得起15k的公司实在太少，而且这些公司对技术要求非常高，由于他平时工作中对技术的深度钻研有限，最终都被拒之门外。\n\n还好得益于他在HIS领域扎实的行业经验+原公司不错的背景，使得他能够在一家公立医院找到还算可以的工作。\n\n## 4\n当然，并非所有的开发者回到长沙都会面临工资砍一截、甚至减半的情况，我的身边也不乏一些开发者，从北上广深杭回到长沙之后，还能找到与原来公司工资差不多的工作、甚至还有的能找到超过在深圳工资的工作。\n\n那究竟是什么原因决定了长沙开发者的薪资水平，难道真的是长沙的互联网水平发展太低了么？\n\n# 三 长沙的开发者工资有多高？\n## 1\n在长沙有哪些公司的工资最高？\n\n首先还是得排除BAT公司和大型互联网公司也开始在长沙成立相应的分支机构或分公司、子公司。这些公司在长沙也好、深圳也好，其实工资是按照职级来，与城市关系不大。我的一位堂叔在恒大集团（虽然远离IT圈子），但他的工资还不错，据说在长沙一年的收入可以买一套房。。所以。。你懂的，如果你想回长沙，最好的办法就是选择加入BAT，然后公派回老家发展，大概这才是真正的“衣锦还乡”。\n\n其次首屈一指的大概是芒果TV。据悉..芒果TV的前台，每个月虽然工资不高，才8k，但每年能拿到手的年终奖也超过了16万。。而普通开发者，一般每年能够拿到手的收入是20w以上。\n\n稍微牛逼一点的开发者，其实工资并不亚于北上广深的同类型公司。\n\n关键是芒果TV朝九晚五，不用加班，工资还挺轻松，而且公司还挺不错，说出去挺有自豪感。\n\n我一位大学同学表示，他老公曾经在爱奇艺担任运维工程师，回长沙之后去了芒果TV，工资和爱奇艺齐平，工作压力少了一半。\n\n![图片](https://uploader.shimo.im/f/sjbRZaGv7hw4svjV.png!thumbnail)\n\n## 2\n其次，大概这张图上的公司，工资都还可以。。。但，离北上广深的同等排名的公司相比，应该还是差距比较大。\n\n此处还需点出几家公司，建议大家多投简历，例如我所了解的御泥坊、问卷星、兴盛优选、蜜獾信息等公司，他们对人才还是挺重视的，工资也还挺高的，值得大家关注关注。。\n\n当然，与北上广深的大公司比起来，嗯，还是别比了。\n\n另外，内推可能比社招工资高，如果你是大佬，想走社招加入这几家公司，估计会被压一些价。。。\n\n## 3\n那长沙的开发者普遍工资大概是什么水平？或许不同的语言体系有一定的不同，例如后端，一位顶尖的后端工程师，大概是30-50k。\n\n当然，目前我还没接触到突破50k的开发者。我接触到突破30k的开发者。。对不起，他们已经不是开发者了，基本上都是公司管理层、甚至在不少公司，甚至是高管级别。\n\n而资深开发者，基本上是在20-40k左右；高级开发者，应该是12-25k左右，中级开发者，大概是8-15k左右，初级开发者，大概是4-8k左右。在这一点上，Java和.NET或其他语言，其实区别不大。\n\n## 4\n当然，我的圈层束缚了我的想象力，显然还有更高收入的群体。。在我了解的圈层。\n\n例如芒果TV。。一个高级运维就能突破30k，而其他公司，不管你k8s\\openstack玩得多\n\n溜，20k已经是天花板了。\n\n圈层之外。。大概年薪50万到80万，其实也是长沙一些大型互联网公司技术高管的天花板。其实有的大公司高管，也没能突破40k，不过既然已经成为高管了，估计他们已经不靠工资，更多的是靠公司的业绩提成或股份分红吧。\n\n*5*\n\n对不起，所有初级、中级、高级、资深开发者，并不是按年资来衡量的，而是看真实实力来衡量。你不能说你工作十年，就一定是高级开发者。例如，如果你做后端开发，连gc、领域驱动设计、分布式缓存、NoSQL都没听过，可能你确实不太适合寻找跨行业的职位。。\n\n然而，事实上大多数开发者都是这么自以为的。我也面过一些工作十年的开发者，他们在特定的业务领域，或许是业务大佬，但一旦离开对应的领域求职，几乎找不到合适的工作。例如，我曾经面过一些做建筑信息化的开发者，工作也有十年多，但一旦问到涉及并发、缓存、gc等问题，他们基本上都没听过。与这类似的还有从事制造业信息化的开发者，可能连.NET技术中的一些新特性，例如async/await都可能没听过。就像搞java的，连稍微新一点的语法都没用过，又该如何被称为“高级Java工程师”。\n\n作为开发者，懂基础概念和术语还是很重要的，不过，长沙的技术圈子，似乎还没形成这样的氛围。面试时，有时不能问技术问题。\n\n当然，退一万不讲，公司不怎么地，居然还好意思问技术问题，不就是“拥有造核弹的心，却只有拧螺丝钉的命么？”。。。\n\n# 四  我技术牛逼，为何就不能拿高工资？\n## 1\n我已经见过不下十位优秀开发者，他们的岗位基本上都是技术经理、技术总监、架构师，而待遇要求基本上都是18k以上。结果他们的求职期无一例外，都达到了一个月以上，最终不得不一点点把自己的心理预期进一步降低，进一步降低，然后在15k左右徘徊。当然，这些都是.NET开发者，如果是Java开发者，可能多那么几千块钱。。（不过Java的竞争更激烈）\n\n这是由于他们能力不行造成的么？绝非如此，我相信，他们在没回长沙之前，公司也是好平台、他们能够成为公司的核心骨干，也证明他们非常优秀。\n\n## 2\n但是。。长沙确实是互联网的荒漠，能够给开发者带来更加丰厚收入、自豪感的公司，实在是太少太少。前面提到的那些技术管理层都是非常优秀的跨职能人才，这让他们能够在技术岗位快速进步的同时，还能很快的成为公司的管理者，给公司的发展带来很大的帮助。只是从他们离开公司开始，就无法以对应的title寻找工作，只能寻找技术领域的高级开发者。\n\n而市场上管理岗位显然少于技术岗位，且不说竞争是否激烈，更何况现在的技术岗位对于技能的要求本身就已经逐渐提高了。当你踏上管理者的岗位开始，一天又能维持几个小时的编码时间呢？你真的会持续刷新自己的技术，保持技术的持久战斗力么？\n\n或许。其实你内心，其实已经不再重视“编码”这个硬技能了吧。\n\n另外，依据“彼得原理”，大部分公司其实找的是当前岗位的胜任者，而不是超出对应岗位的“进阶者”。如果你的公司天花板非常低，那你又如何能在那些有高天花板的公司找到高职级的工作。即便有，或许也很难胜任吧。\n\n## 4\n长沙的软件公司或开发者技术不行么？这也是个悖论。文无第一，武无第二。工资不行不代表技术不行。 许多长沙的公司虽然公司效益远远比不上BAT大公司，一年净收入突破几千万就算是个不错的公司了，但这不能说明公司技术不行。恰好相反，一波一波回长沙的开发者，总会有人一点点把长沙的技术水平逐渐提高。\n\n技术水平的高低没有评判标准，许多大佬技术牛逼，但脱离了公司的平台效应和团队战斗力，单兵作战能力可能并不强。\n\n相比之下，许多长沙的开发者平时下班之后就是学习技术，交流技术，一天八小时撸码，还有四小时学习，这样的开发者技术还能差到哪里去。\n\n例如前面提到的蜜獾信息，就形成了这样一群人。而且公司待遇不错，技术氛围也很不错，公司管理层也重视技术和企业文化氛围，早就把“不加班，不写过时的文档，每两周发布一个版本的敏捷发布”玩的挺顺利的，非常适合大家关注。\n\n## 5\n当然，限于体量原因，许多技术含量较高的场景，长沙还真没有。我一位朋友吐槽，长沙的运维人员，还停留在最多百台服务器运维的能力，几乎相当于他2015年的水平。现在在长沙，能够玩得起自动化测试的公司，都还算不错的公司，所以如果你是拥有自动化测试经验的测试工程师，其实也还是有很多机会。\n\n但那些大公司才有的细分岗位，例如之前说的基站测试，还有咨询师，技术写作专家，配置管理工程师，甚至是python大数据分析师，长沙大概还几乎没有。长沙市场上python相关的职位还非常少，go语言的也并不多。。。\n\n## 6\n长沙的公司为什么不愿意花高工资聘请大牛呢？其实这也是一些回长沙的求职者向我吐槽的。也许他们的言下之意是：为啥不聘请“像自己这样的大牛”呢？\n\n好吧，其实长沙的IT圈也舍得花力气聘请大牛，像已经成为社区电商行业的领跑者的兴盛优选，公司本身已经有不少大牛，而且也愿意用月薪35到60以上的标准聘请阿里巴巴p7以上的开发者，考虑到长沙的物价水平，其实已经挺不错了。\n\n*如果你是真大牛。。我可以帮你推荐一番。*\n\n总之，长沙的IT公司并非不舍得花高工资聘请大佬，而是因为。。。还没遇到真正牛逼的大佬。\n\n# 五 高工资是怎么来的？\n## 1\n谈起高工资，我们得想想北上广深那么多百万年薪的程序员，他们的高工资是怎么来的？\n\n在互联网飞速发展的今天，靠近资本的北上广深杭已经成为风口浪尖，许多与互联网概念相关的企业都跟着业绩腾飞，员工的薪资也跟着水涨船高，此处就不需要举例子了，毕竟BAT那么多家公司的优秀开发者们，用他们的身价证明，自己的一份努力，完全可以代表中国互联网开发者的顶尖收入水平。\n\n但。。在这些行业巨头之外，还有许多开发者，其实依然处于温饱线的边缘，或稍微比温饱线好那么一点，财务自由？35岁退休？年入百万？大部分人别想了。是由于选择大于努力造成的？还是由于平时温水煮青蛙，不够努力造成的？其实基本上都不是的。事实上，许多开发者，例如一些外包或制造业外包的开发者，他们的条件远比BAT公司更艰苦，每周的工作时长更高，但拿的收入水平，却仅仅只是BAT开发者的零头，甚至不如。\n\n这大概有点像拿非洲人民和美国资本家对比。用经济学术语来说。。就是“剪刀差”（我打算称为工资剪刀差）。\n\n![图片](https://uploader.shimo.im/f/3jlkvgUiFD89FM37.png!thumbnail)\n\n互联网企业员工的高收入，其实来源于互联网企业本身对于资本的凝聚力和投资者对于未来的期望所带来的溢价。而有许多互联网公司其实本身已经不需要靠利润来发工资，仅仅依靠“市梦率”，就能维持公司的飞速发展，让员工获得足够的福利。\n\n## 2\n而长沙的互联网公司并不多，大部分都是所谓“行业互联网”，虽然沾上了“互联网”的名，却没有互联网的命。\n\n“行业互联网”企业由于发展较为缓慢、或者已经较为稳定，事实上已经不太可能从投资者市场获得更高，由于只能靠利润来给员工发工资。\n\n所以，员工的工资包含了公司获得的投资，公司的利润，公司的品牌溢价、个人的品牌溢价和个人的核心竞争力，个人的机遇。如果你核心竞争力强，让那些优秀的公司能够更早的认识你，自然而然也很容易成为职场上的香饽饽。\n\n## 3\n如果品牌竞争力一般，该如何寻找合适自己的工作呢？\n\n![图片](https://uploader.shimo.im/f/CNVf9Df1pBrsO07B.png!thumbnail)\n\n认清形势，放弃幻想。回归现实，别妄图拿那么高的工资。找一个自己感兴趣的行业、公司，踏踏实实干下去，通过自己的努力，为公司创造更大的价值，自然而然，你就获得了更好的发展。\n\n当你回到长沙，就别在幻想通过上班来获得“暴富”了。长沙这样的土壤，其实更像普通人凭借自己双手改变家庭命运的跳板。\n\n例如，校管家，就是这样的公司，老板们勤勤恳恳、踏踏实实，靠自己的努力，创造了一家优秀的公司，并成功的获得了投资者们的不断关注。在长沙，这样的公司不下数十家。\n\n# 结语\n与其他城市相比，长沙的IT业态或许更趋于“务实”“勤勉”“实干”“坚持”。\n\n长沙不是互联网人淘金的热土，也不是一夜暴富者的摇篮。\n\n在沿海地区互联网的热闹喧嚣之外，长沙其实就是一个这样静静发展、一声不响就创造出不错佳绩的“小而美”的现代化城市。\n\n在长沙，也许你见不到太多“英雄”，却充满了各种各样、努力付出、细心耕耘、用三年、五年或更长的时间来用心助力公司成长的“普通人”。\n\n显然，这个世界，既要“冒险家”“野心家”“成功学”，同样也需要“普通人”。\n\n","slug":"随笔/how-to-find-millon-in-changsha-programmer","published":1,"updated":"2020-04-10T01:09:12.893Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt9k004fn4vitw9d7nt1","content":"<h1 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h1><p>不知不觉，IT技术圈开始流传起“百万年薪”的故事，有人问我，长沙有百万大佬么？其实我也不知道。</p>\n<h1 id=\"一-背景\"><a href=\"#一-背景\" class=\"headerlink\" title=\"一  背景\"></a>一  背景</h1><p>长沙自古以来就是文风鼎盛之地，在今天也同样如此。</p>\n<p>目前长沙有211、985、一本、二本等本科院校数十所，大专以上的院校上百所.每年从长沙毕业，怀揣梦想选择去北上广深杭奋斗的互联网从业人员不下数万人，其中从事技术岗位的（例如开发、测试、运维等）或许是占比最大的部分。</p>\n<p>从某种意义上来说，湖南技术人可能真的撑起了全国互联网的半边天。（当然，这样的说法没有统计数据为准，笔者说了不算）。</p>\n<p>不过，一直以来，由于沿海地区落户政策的严格、购房和居家生活的成本高，使得许多离开湖南的开发者越来越倾向于选择回到长沙寻找适合自己的工作。</p>\n<p>他们都能在长沙找到合适的工作么？他们能成为“百万大佬”么？</p>\n<h1 id=\"二-几个故事\"><a href=\"#二-几个故事\" class=\"headerlink\" title=\"二 几个故事\"></a>二 几个故事</h1><h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h2><p>老Q是我的同学，大学毕业后，我回了家乡长沙，他则选择去深圳发展。在毕业前的一次吃饭过程中，他说打算先去深圳看看，过几年在深圳混不下去了，再回长沙。</p>\n<p>2015年上半年，他的同学邀请他创业，他果断的把在酷派的工作辞了，回到了长沙。但经过半年的折腾，他的创业梦想最终还是“黄”了，又临近年光，他决定留在长沙找工作。</p>\n<p>由于他在酷派当时主要从事手机基站测试的相关领域工作，而在长沙实际上几乎没有对应的工作，除了软件测试，就是纯粹的硬件测试。而由于他属于转行的性质，最终工资..更是相当微薄。最终他还是离开了长沙，回到了深圳。</p>\n<p>一晃又是五年，当我在跟他交流是否有兴趣回长沙时，他一脸苦涩的说，就算想回，估计也不会在从事IT相关的行业了。</p>\n<p>“当时以为混不下去就回长沙，其实长沙反而比北上广深更难混下去。”</p>\n<h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h2><p>老L是2014年前后回的长沙。</p>\n<p>老L之前在广州，那是一家还不错的上市公司，他在这家公司也算是中层管理者，但考虑到在广州买房不太现实，而且长期离乡背井的工作，也让他对家乡产生了深深的眷恋之情，再加上他的对象也希望他回长沙发展，最终他抛弃了那份月收入破2w的工作，回到了长沙。</p>\n<p>回到长沙找工作之前，他找同学打听了长沙当时的开发者工资水平，他的同学告诉他，像这样七八年经验的.NET开发者，大概顶尖水平应该是万把块钱。</p>\n<p>老L是一位务实的开发者，他想到自己在广州那家公司，实际上每天投入到软件开发工作中的时间，其实只有不到3个小时，要与专业从事技术开发、天天浸淫其道的高手相比，还存在巨大的差距。</p>\n<p>既然顶尖水平才一万，那自己显然只能顶别人的六成，开六千肯定没问题。</p>\n<p>结果面试时，公司给他开了8k，顿时他就很欣喜。</p>\n<p>虽然他后来又离开了这家公司，但他还是给予了这家公司很高的评价：这充分证明，其实长沙的公司非常识货。</p>\n<h2 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a>3</h2><p>老C也是差不多同期回的长沙，当时他已经是一家大型互联网公司的中层管理者。</p>\n<p>（这家公司在他离开之后，迎来了一波飞速发展，引入了好几十个华为毕业的员工后，使得公司的整体技术水平和能力都有了巨大的飞跃，在2017年前后成功上市，之前跟他同期加入公司的同事、以及他在公司时招聘的人才，几乎都成为公司的核心骨干或甚至是事业部、分公司总经理。）</p>\n<p>老C回到长沙的原因，是因为他存够了能够在深圳付首付款的钱，他的家人却硬是说服他拿这个钱在长沙买房。</p>\n<p>当然，同样的钱，在深圳只能买偏僻城乡结合部的小两居，而回长沙则可以买中心地带，地铁口，公园口的120平三室一厅。</p>\n<p>他拿着这个钱之后，回来看了一圈房子，发现居然可以选择的余地这么多，而且还这么舒服的，当时就决定回长沙定居，他很快就把深圳的工作辞了，然后回到了长沙找工作。</p>\n<p>当他回到长沙找工作之后，得益于一个机会，有幸找到了一个非常有钱的老板，这位老板拉了一个规模还算大的团队，也非常重视像他这样优秀的管理者，以大概15k或更高的薪酬聘用了他。这在当时的长沙已经算非常不错的薪资，使得他能够维持相对高的生活条件。</p>\n<p>但公司的资金很快就烧完了，公司解散后，他被迫回到职场求职。</p>\n<p>他的心理预算是15k，但在长沙能够开得起15k的公司实在太少，而且这些公司对技术要求非常高，由于他平时工作中对技术的深度钻研有限，最终都被拒之门外。</p>\n<p>还好得益于他在HIS领域扎实的行业经验+原公司不错的背景，使得他能够在一家公立医院找到还算可以的工作。</p>\n<h2 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4\"></a>4</h2><p>当然，并非所有的开发者回到长沙都会面临工资砍一截、甚至减半的情况，我的身边也不乏一些开发者，从北上广深杭回到长沙之后，还能找到与原来公司工资差不多的工作、甚至还有的能找到超过在深圳工资的工作。</p>\n<p>那究竟是什么原因决定了长沙开发者的薪资水平，难道真的是长沙的互联网水平发展太低了么？</p>\n<h1 id=\"三-长沙的开发者工资有多高？\"><a href=\"#三-长沙的开发者工资有多高？\" class=\"headerlink\" title=\"三 长沙的开发者工资有多高？\"></a>三 长沙的开发者工资有多高？</h1><h2 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"1\"></a>1</h2><p>在长沙有哪些公司的工资最高？</p>\n<p>首先还是得排除BAT公司和大型互联网公司也开始在长沙成立相应的分支机构或分公司、子公司。这些公司在长沙也好、深圳也好，其实工资是按照职级来，与城市关系不大。我的一位堂叔在恒大集团（虽然远离IT圈子），但他的工资还不错，据说在长沙一年的收入可以买一套房。。所以。。你懂的，如果你想回长沙，最好的办法就是选择加入BAT，然后公派回老家发展，大概这才是真正的“衣锦还乡”。</p>\n<p>其次首屈一指的大概是芒果TV。据悉..芒果TV的前台，每个月虽然工资不高，才8k，但每年能拿到手的年终奖也超过了16万。。而普通开发者，一般每年能够拿到手的收入是20w以上。</p>\n<p>稍微牛逼一点的开发者，其实工资并不亚于北上广深的同类型公司。</p>\n<p>关键是芒果TV朝九晚五，不用加班，工资还挺轻松，而且公司还挺不错，说出去挺有自豪感。</p>\n<p>我一位大学同学表示，他老公曾经在爱奇艺担任运维工程师，回长沙之后去了芒果TV，工资和爱奇艺齐平，工作压力少了一半。</p>\n<p><img src=\"https://uploader.shimo.im/f/sjbRZaGv7hw4svjV.png!thumbnail\" alt=\"图片\"></p>\n<h2 id=\"2-1\"><a href=\"#2-1\" class=\"headerlink\" title=\"2\"></a>2</h2><p>其次，大概这张图上的公司，工资都还可以。。。但，离北上广深的同等排名的公司相比，应该还是差距比较大。</p>\n<p>此处还需点出几家公司，建议大家多投简历，例如我所了解的御泥坊、问卷星、兴盛优选、蜜獾信息等公司，他们对人才还是挺重视的，工资也还挺高的，值得大家关注关注。。</p>\n<p>当然，与北上广深的大公司比起来，嗯，还是别比了。</p>\n<p>另外，内推可能比社招工资高，如果你是大佬，想走社招加入这几家公司，估计会被压一些价。。。</p>\n<h2 id=\"3-1\"><a href=\"#3-1\" class=\"headerlink\" title=\"3\"></a>3</h2><p>那长沙的开发者普遍工资大概是什么水平？或许不同的语言体系有一定的不同，例如后端，一位顶尖的后端工程师，大概是30-50k。</p>\n<p>当然，目前我还没接触到突破50k的开发者。我接触到突破30k的开发者。。对不起，他们已经不是开发者了，基本上都是公司管理层、甚至在不少公司，甚至是高管级别。</p>\n<p>而资深开发者，基本上是在20-40k左右；高级开发者，应该是12-25k左右，中级开发者，大概是8-15k左右，初级开发者，大概是4-8k左右。在这一点上，Java和.NET或其他语言，其实区别不大。</p>\n<h2 id=\"4-1\"><a href=\"#4-1\" class=\"headerlink\" title=\"4\"></a>4</h2><p>当然，我的圈层束缚了我的想象力，显然还有更高收入的群体。。在我了解的圈层。</p>\n<p>例如芒果TV。。一个高级运维就能突破30k，而其他公司，不管你k8s\\openstack玩得多</p>\n<p>溜，20k已经是天花板了。</p>\n<p>圈层之外。。大概年薪50万到80万，其实也是长沙一些大型互联网公司技术高管的天花板。其实有的大公司高管，也没能突破40k，不过既然已经成为高管了，估计他们已经不靠工资，更多的是靠公司的业绩提成或股份分红吧。</p>\n<p><em>5</em></p>\n<p>对不起，所有初级、中级、高级、资深开发者，并不是按年资来衡量的，而是看真实实力来衡量。你不能说你工作十年，就一定是高级开发者。例如，如果你做后端开发，连gc、领域驱动设计、分布式缓存、NoSQL都没听过，可能你确实不太适合寻找跨行业的职位。。</p>\n<p>然而，事实上大多数开发者都是这么自以为的。我也面过一些工作十年的开发者，他们在特定的业务领域，或许是业务大佬，但一旦离开对应的领域求职，几乎找不到合适的工作。例如，我曾经面过一些做建筑信息化的开发者，工作也有十年多，但一旦问到涉及并发、缓存、gc等问题，他们基本上都没听过。与这类似的还有从事制造业信息化的开发者，可能连.NET技术中的一些新特性，例如async/await都可能没听过。就像搞java的，连稍微新一点的语法都没用过，又该如何被称为“高级Java工程师”。</p>\n<p>作为开发者，懂基础概念和术语还是很重要的，不过，长沙的技术圈子，似乎还没形成这样的氛围。面试时，有时不能问技术问题。</p>\n<p>当然，退一万不讲，公司不怎么地，居然还好意思问技术问题，不就是“拥有造核弹的心，却只有拧螺丝钉的命么？”。。。</p>\n<h1 id=\"四-我技术牛逼，为何就不能拿高工资？\"><a href=\"#四-我技术牛逼，为何就不能拿高工资？\" class=\"headerlink\" title=\"四  我技术牛逼，为何就不能拿高工资？\"></a>四  我技术牛逼，为何就不能拿高工资？</h1><h2 id=\"1-2\"><a href=\"#1-2\" class=\"headerlink\" title=\"1\"></a>1</h2><p>我已经见过不下十位优秀开发者，他们的岗位基本上都是技术经理、技术总监、架构师，而待遇要求基本上都是18k以上。结果他们的求职期无一例外，都达到了一个月以上，最终不得不一点点把自己的心理预期进一步降低，进一步降低，然后在15k左右徘徊。当然，这些都是.NET开发者，如果是Java开发者，可能多那么几千块钱。。（不过Java的竞争更激烈）</p>\n<p>这是由于他们能力不行造成的么？绝非如此，我相信，他们在没回长沙之前，公司也是好平台、他们能够成为公司的核心骨干，也证明他们非常优秀。</p>\n<h2 id=\"2-2\"><a href=\"#2-2\" class=\"headerlink\" title=\"2\"></a>2</h2><p>但是。。长沙确实是互联网的荒漠，能够给开发者带来更加丰厚收入、自豪感的公司，实在是太少太少。前面提到的那些技术管理层都是非常优秀的跨职能人才，这让他们能够在技术岗位快速进步的同时，还能很快的成为公司的管理者，给公司的发展带来很大的帮助。只是从他们离开公司开始，就无法以对应的title寻找工作，只能寻找技术领域的高级开发者。</p>\n<p>而市场上管理岗位显然少于技术岗位，且不说竞争是否激烈，更何况现在的技术岗位对于技能的要求本身就已经逐渐提高了。当你踏上管理者的岗位开始，一天又能维持几个小时的编码时间呢？你真的会持续刷新自己的技术，保持技术的持久战斗力么？</p>\n<p>或许。其实你内心，其实已经不再重视“编码”这个硬技能了吧。</p>\n<p>另外，依据“彼得原理”，大部分公司其实找的是当前岗位的胜任者，而不是超出对应岗位的“进阶者”。如果你的公司天花板非常低，那你又如何能在那些有高天花板的公司找到高职级的工作。即便有，或许也很难胜任吧。</p>\n<h2 id=\"4-2\"><a href=\"#4-2\" class=\"headerlink\" title=\"4\"></a>4</h2><p>长沙的软件公司或开发者技术不行么？这也是个悖论。文无第一，武无第二。工资不行不代表技术不行。 许多长沙的公司虽然公司效益远远比不上BAT大公司，一年净收入突破几千万就算是个不错的公司了，但这不能说明公司技术不行。恰好相反，一波一波回长沙的开发者，总会有人一点点把长沙的技术水平逐渐提高。</p>\n<p>技术水平的高低没有评判标准，许多大佬技术牛逼，但脱离了公司的平台效应和团队战斗力，单兵作战能力可能并不强。</p>\n<p>相比之下，许多长沙的开发者平时下班之后就是学习技术，交流技术，一天八小时撸码，还有四小时学习，这样的开发者技术还能差到哪里去。</p>\n<p>例如前面提到的蜜獾信息，就形成了这样一群人。而且公司待遇不错，技术氛围也很不错，公司管理层也重视技术和企业文化氛围，早就把“不加班，不写过时的文档，每两周发布一个版本的敏捷发布”玩的挺顺利的，非常适合大家关注。</p>\n<h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5\"></a>5</h2><p>当然，限于体量原因，许多技术含量较高的场景，长沙还真没有。我一位朋友吐槽，长沙的运维人员，还停留在最多百台服务器运维的能力，几乎相当于他2015年的水平。现在在长沙，能够玩得起自动化测试的公司，都还算不错的公司，所以如果你是拥有自动化测试经验的测试工程师，其实也还是有很多机会。</p>\n<p>但那些大公司才有的细分岗位，例如之前说的基站测试，还有咨询师，技术写作专家，配置管理工程师，甚至是python大数据分析师，长沙大概还几乎没有。长沙市场上python相关的职位还非常少，go语言的也并不多。。。</p>\n<h2 id=\"6\"><a href=\"#6\" class=\"headerlink\" title=\"6\"></a>6</h2><p>长沙的公司为什么不愿意花高工资聘请大牛呢？其实这也是一些回长沙的求职者向我吐槽的。也许他们的言下之意是：为啥不聘请“像自己这样的大牛”呢？</p>\n<p>好吧，其实长沙的IT圈也舍得花力气聘请大牛，像已经成为社区电商行业的领跑者的兴盛优选，公司本身已经有不少大牛，而且也愿意用月薪35到60以上的标准聘请阿里巴巴p7以上的开发者，考虑到长沙的物价水平，其实已经挺不错了。</p>\n<p><em>如果你是真大牛。。我可以帮你推荐一番。</em></p>\n<p>总之，长沙的IT公司并非不舍得花高工资聘请大佬，而是因为。。。还没遇到真正牛逼的大佬。</p>\n<h1 id=\"五-高工资是怎么来的？\"><a href=\"#五-高工资是怎么来的？\" class=\"headerlink\" title=\"五 高工资是怎么来的？\"></a>五 高工资是怎么来的？</h1><h2 id=\"1-3\"><a href=\"#1-3\" class=\"headerlink\" title=\"1\"></a>1</h2><p>谈起高工资，我们得想想北上广深那么多百万年薪的程序员，他们的高工资是怎么来的？</p>\n<p>在互联网飞速发展的今天，靠近资本的北上广深杭已经成为风口浪尖，许多与互联网概念相关的企业都跟着业绩腾飞，员工的薪资也跟着水涨船高，此处就不需要举例子了，毕竟BAT那么多家公司的优秀开发者们，用他们的身价证明，自己的一份努力，完全可以代表中国互联网开发者的顶尖收入水平。</p>\n<p>但。。在这些行业巨头之外，还有许多开发者，其实依然处于温饱线的边缘，或稍微比温饱线好那么一点，财务自由？35岁退休？年入百万？大部分人别想了。是由于选择大于努力造成的？还是由于平时温水煮青蛙，不够努力造成的？其实基本上都不是的。事实上，许多开发者，例如一些外包或制造业外包的开发者，他们的条件远比BAT公司更艰苦，每周的工作时长更高，但拿的收入水平，却仅仅只是BAT开发者的零头，甚至不如。</p>\n<p>这大概有点像拿非洲人民和美国资本家对比。用经济学术语来说。。就是“剪刀差”（我打算称为工资剪刀差）。</p>\n<p><img src=\"https://uploader.shimo.im/f/3jlkvgUiFD89FM37.png!thumbnail\" alt=\"图片\"></p>\n<p>互联网企业员工的高收入，其实来源于互联网企业本身对于资本的凝聚力和投资者对于未来的期望所带来的溢价。而有许多互联网公司其实本身已经不需要靠利润来发工资，仅仅依靠“市梦率”，就能维持公司的飞速发展，让员工获得足够的福利。</p>\n<h2 id=\"2-3\"><a href=\"#2-3\" class=\"headerlink\" title=\"2\"></a>2</h2><p>而长沙的互联网公司并不多，大部分都是所谓“行业互联网”，虽然沾上了“互联网”的名，却没有互联网的命。</p>\n<p>“行业互联网”企业由于发展较为缓慢、或者已经较为稳定，事实上已经不太可能从投资者市场获得更高，由于只能靠利润来给员工发工资。</p>\n<p>所以，员工的工资包含了公司获得的投资，公司的利润，公司的品牌溢价、个人的品牌溢价和个人的核心竞争力，个人的机遇。如果你核心竞争力强，让那些优秀的公司能够更早的认识你，自然而然也很容易成为职场上的香饽饽。</p>\n<h2 id=\"3-2\"><a href=\"#3-2\" class=\"headerlink\" title=\"3\"></a>3</h2><p>如果品牌竞争力一般，该如何寻找合适自己的工作呢？</p>\n<p><img src=\"https://uploader.shimo.im/f/CNVf9Df1pBrsO07B.png!thumbnail\" alt=\"图片\"></p>\n<p>认清形势，放弃幻想。回归现实，别妄图拿那么高的工资。找一个自己感兴趣的行业、公司，踏踏实实干下去，通过自己的努力，为公司创造更大的价值，自然而然，你就获得了更好的发展。</p>\n<p>当你回到长沙，就别在幻想通过上班来获得“暴富”了。长沙这样的土壤，其实更像普通人凭借自己双手改变家庭命运的跳板。</p>\n<p>例如，校管家，就是这样的公司，老板们勤勤恳恳、踏踏实实，靠自己的努力，创造了一家优秀的公司，并成功的获得了投资者们的不断关注。在长沙，这样的公司不下数十家。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>与其他城市相比，长沙的IT业态或许更趋于“务实”“勤勉”“实干”“坚持”。</p>\n<p>长沙不是互联网人淘金的热土，也不是一夜暴富者的摇篮。</p>\n<p>在沿海地区互联网的热闹喧嚣之外，长沙其实就是一个这样静静发展、一声不响就创造出不错佳绩的“小而美”的现代化城市。</p>\n<p>在长沙，也许你见不到太多“英雄”，却充满了各种各样、努力付出、细心耕耘、用三年、五年或更长的时间来用心助力公司成长的“普通人”。</p>\n<p>显然，这个世界，既要“冒险家”“野心家”“成功学”，同样也需要“普通人”。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h1><p>不知不觉，IT技术圈开始流传起“百万年薪”的故事，有人问我，长沙有百万大佬么？其实我也不知道。</p>\n<h1 id=\"一-背景\"><a href=\"#一-背景\" class=\"headerlink\" title=\"一  背景\"></a>一  背景</h1><p>长沙自古以来就是文风鼎盛之地，在今天也同样如此。</p>\n<p>目前长沙有211、985、一本、二本等本科院校数十所，大专以上的院校上百所.每年从长沙毕业，怀揣梦想选择去北上广深杭奋斗的互联网从业人员不下数万人，其中从事技术岗位的（例如开发、测试、运维等）或许是占比最大的部分。</p>\n<p>从某种意义上来说，湖南技术人可能真的撑起了全国互联网的半边天。（当然，这样的说法没有统计数据为准，笔者说了不算）。</p>\n<p>不过，一直以来，由于沿海地区落户政策的严格、购房和居家生活的成本高，使得许多离开湖南的开发者越来越倾向于选择回到长沙寻找适合自己的工作。</p>\n<p>他们都能在长沙找到合适的工作么？他们能成为“百万大佬”么？</p>\n<h1 id=\"二-几个故事\"><a href=\"#二-几个故事\" class=\"headerlink\" title=\"二 几个故事\"></a>二 几个故事</h1><h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h2><p>老Q是我的同学，大学毕业后，我回了家乡长沙，他则选择去深圳发展。在毕业前的一次吃饭过程中，他说打算先去深圳看看，过几年在深圳混不下去了，再回长沙。</p>\n<p>2015年上半年，他的同学邀请他创业，他果断的把在酷派的工作辞了，回到了长沙。但经过半年的折腾，他的创业梦想最终还是“黄”了，又临近年光，他决定留在长沙找工作。</p>\n<p>由于他在酷派当时主要从事手机基站测试的相关领域工作，而在长沙实际上几乎没有对应的工作，除了软件测试，就是纯粹的硬件测试。而由于他属于转行的性质，最终工资..更是相当微薄。最终他还是离开了长沙，回到了深圳。</p>\n<p>一晃又是五年，当我在跟他交流是否有兴趣回长沙时，他一脸苦涩的说，就算想回，估计也不会在从事IT相关的行业了。</p>\n<p>“当时以为混不下去就回长沙，其实长沙反而比北上广深更难混下去。”</p>\n<h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h2><p>老L是2014年前后回的长沙。</p>\n<p>老L之前在广州，那是一家还不错的上市公司，他在这家公司也算是中层管理者，但考虑到在广州买房不太现实，而且长期离乡背井的工作，也让他对家乡产生了深深的眷恋之情，再加上他的对象也希望他回长沙发展，最终他抛弃了那份月收入破2w的工作，回到了长沙。</p>\n<p>回到长沙找工作之前，他找同学打听了长沙当时的开发者工资水平，他的同学告诉他，像这样七八年经验的.NET开发者，大概顶尖水平应该是万把块钱。</p>\n<p>老L是一位务实的开发者，他想到自己在广州那家公司，实际上每天投入到软件开发工作中的时间，其实只有不到3个小时，要与专业从事技术开发、天天浸淫其道的高手相比，还存在巨大的差距。</p>\n<p>既然顶尖水平才一万，那自己显然只能顶别人的六成，开六千肯定没问题。</p>\n<p>结果面试时，公司给他开了8k，顿时他就很欣喜。</p>\n<p>虽然他后来又离开了这家公司，但他还是给予了这家公司很高的评价：这充分证明，其实长沙的公司非常识货。</p>\n<h2 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a>3</h2><p>老C也是差不多同期回的长沙，当时他已经是一家大型互联网公司的中层管理者。</p>\n<p>（这家公司在他离开之后，迎来了一波飞速发展，引入了好几十个华为毕业的员工后，使得公司的整体技术水平和能力都有了巨大的飞跃，在2017年前后成功上市，之前跟他同期加入公司的同事、以及他在公司时招聘的人才，几乎都成为公司的核心骨干或甚至是事业部、分公司总经理。）</p>\n<p>老C回到长沙的原因，是因为他存够了能够在深圳付首付款的钱，他的家人却硬是说服他拿这个钱在长沙买房。</p>\n<p>当然，同样的钱，在深圳只能买偏僻城乡结合部的小两居，而回长沙则可以买中心地带，地铁口，公园口的120平三室一厅。</p>\n<p>他拿着这个钱之后，回来看了一圈房子，发现居然可以选择的余地这么多，而且还这么舒服的，当时就决定回长沙定居，他很快就把深圳的工作辞了，然后回到了长沙找工作。</p>\n<p>当他回到长沙找工作之后，得益于一个机会，有幸找到了一个非常有钱的老板，这位老板拉了一个规模还算大的团队，也非常重视像他这样优秀的管理者，以大概15k或更高的薪酬聘用了他。这在当时的长沙已经算非常不错的薪资，使得他能够维持相对高的生活条件。</p>\n<p>但公司的资金很快就烧完了，公司解散后，他被迫回到职场求职。</p>\n<p>他的心理预算是15k，但在长沙能够开得起15k的公司实在太少，而且这些公司对技术要求非常高，由于他平时工作中对技术的深度钻研有限，最终都被拒之门外。</p>\n<p>还好得益于他在HIS领域扎实的行业经验+原公司不错的背景，使得他能够在一家公立医院找到还算可以的工作。</p>\n<h2 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4\"></a>4</h2><p>当然，并非所有的开发者回到长沙都会面临工资砍一截、甚至减半的情况，我的身边也不乏一些开发者，从北上广深杭回到长沙之后，还能找到与原来公司工资差不多的工作、甚至还有的能找到超过在深圳工资的工作。</p>\n<p>那究竟是什么原因决定了长沙开发者的薪资水平，难道真的是长沙的互联网水平发展太低了么？</p>\n<h1 id=\"三-长沙的开发者工资有多高？\"><a href=\"#三-长沙的开发者工资有多高？\" class=\"headerlink\" title=\"三 长沙的开发者工资有多高？\"></a>三 长沙的开发者工资有多高？</h1><h2 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"1\"></a>1</h2><p>在长沙有哪些公司的工资最高？</p>\n<p>首先还是得排除BAT公司和大型互联网公司也开始在长沙成立相应的分支机构或分公司、子公司。这些公司在长沙也好、深圳也好，其实工资是按照职级来，与城市关系不大。我的一位堂叔在恒大集团（虽然远离IT圈子），但他的工资还不错，据说在长沙一年的收入可以买一套房。。所以。。你懂的，如果你想回长沙，最好的办法就是选择加入BAT，然后公派回老家发展，大概这才是真正的“衣锦还乡”。</p>\n<p>其次首屈一指的大概是芒果TV。据悉..芒果TV的前台，每个月虽然工资不高，才8k，但每年能拿到手的年终奖也超过了16万。。而普通开发者，一般每年能够拿到手的收入是20w以上。</p>\n<p>稍微牛逼一点的开发者，其实工资并不亚于北上广深的同类型公司。</p>\n<p>关键是芒果TV朝九晚五，不用加班，工资还挺轻松，而且公司还挺不错，说出去挺有自豪感。</p>\n<p>我一位大学同学表示，他老公曾经在爱奇艺担任运维工程师，回长沙之后去了芒果TV，工资和爱奇艺齐平，工作压力少了一半。</p>\n<p><img src=\"https://uploader.shimo.im/f/sjbRZaGv7hw4svjV.png!thumbnail\" alt=\"图片\"></p>\n<h2 id=\"2-1\"><a href=\"#2-1\" class=\"headerlink\" title=\"2\"></a>2</h2><p>其次，大概这张图上的公司，工资都还可以。。。但，离北上广深的同等排名的公司相比，应该还是差距比较大。</p>\n<p>此处还需点出几家公司，建议大家多投简历，例如我所了解的御泥坊、问卷星、兴盛优选、蜜獾信息等公司，他们对人才还是挺重视的，工资也还挺高的，值得大家关注关注。。</p>\n<p>当然，与北上广深的大公司比起来，嗯，还是别比了。</p>\n<p>另外，内推可能比社招工资高，如果你是大佬，想走社招加入这几家公司，估计会被压一些价。。。</p>\n<h2 id=\"3-1\"><a href=\"#3-1\" class=\"headerlink\" title=\"3\"></a>3</h2><p>那长沙的开发者普遍工资大概是什么水平？或许不同的语言体系有一定的不同，例如后端，一位顶尖的后端工程师，大概是30-50k。</p>\n<p>当然，目前我还没接触到突破50k的开发者。我接触到突破30k的开发者。。对不起，他们已经不是开发者了，基本上都是公司管理层、甚至在不少公司，甚至是高管级别。</p>\n<p>而资深开发者，基本上是在20-40k左右；高级开发者，应该是12-25k左右，中级开发者，大概是8-15k左右，初级开发者，大概是4-8k左右。在这一点上，Java和.NET或其他语言，其实区别不大。</p>\n<h2 id=\"4-1\"><a href=\"#4-1\" class=\"headerlink\" title=\"4\"></a>4</h2><p>当然，我的圈层束缚了我的想象力，显然还有更高收入的群体。。在我了解的圈层。</p>\n<p>例如芒果TV。。一个高级运维就能突破30k，而其他公司，不管你k8s\\openstack玩得多</p>\n<p>溜，20k已经是天花板了。</p>\n<p>圈层之外。。大概年薪50万到80万，其实也是长沙一些大型互联网公司技术高管的天花板。其实有的大公司高管，也没能突破40k，不过既然已经成为高管了，估计他们已经不靠工资，更多的是靠公司的业绩提成或股份分红吧。</p>\n<p><em>5</em></p>\n<p>对不起，所有初级、中级、高级、资深开发者，并不是按年资来衡量的，而是看真实实力来衡量。你不能说你工作十年，就一定是高级开发者。例如，如果你做后端开发，连gc、领域驱动设计、分布式缓存、NoSQL都没听过，可能你确实不太适合寻找跨行业的职位。。</p>\n<p>然而，事实上大多数开发者都是这么自以为的。我也面过一些工作十年的开发者，他们在特定的业务领域，或许是业务大佬，但一旦离开对应的领域求职，几乎找不到合适的工作。例如，我曾经面过一些做建筑信息化的开发者，工作也有十年多，但一旦问到涉及并发、缓存、gc等问题，他们基本上都没听过。与这类似的还有从事制造业信息化的开发者，可能连.NET技术中的一些新特性，例如async/await都可能没听过。就像搞java的，连稍微新一点的语法都没用过，又该如何被称为“高级Java工程师”。</p>\n<p>作为开发者，懂基础概念和术语还是很重要的，不过，长沙的技术圈子，似乎还没形成这样的氛围。面试时，有时不能问技术问题。</p>\n<p>当然，退一万不讲，公司不怎么地，居然还好意思问技术问题，不就是“拥有造核弹的心，却只有拧螺丝钉的命么？”。。。</p>\n<h1 id=\"四-我技术牛逼，为何就不能拿高工资？\"><a href=\"#四-我技术牛逼，为何就不能拿高工资？\" class=\"headerlink\" title=\"四  我技术牛逼，为何就不能拿高工资？\"></a>四  我技术牛逼，为何就不能拿高工资？</h1><h2 id=\"1-2\"><a href=\"#1-2\" class=\"headerlink\" title=\"1\"></a>1</h2><p>我已经见过不下十位优秀开发者，他们的岗位基本上都是技术经理、技术总监、架构师，而待遇要求基本上都是18k以上。结果他们的求职期无一例外，都达到了一个月以上，最终不得不一点点把自己的心理预期进一步降低，进一步降低，然后在15k左右徘徊。当然，这些都是.NET开发者，如果是Java开发者，可能多那么几千块钱。。（不过Java的竞争更激烈）</p>\n<p>这是由于他们能力不行造成的么？绝非如此，我相信，他们在没回长沙之前，公司也是好平台、他们能够成为公司的核心骨干，也证明他们非常优秀。</p>\n<h2 id=\"2-2\"><a href=\"#2-2\" class=\"headerlink\" title=\"2\"></a>2</h2><p>但是。。长沙确实是互联网的荒漠，能够给开发者带来更加丰厚收入、自豪感的公司，实在是太少太少。前面提到的那些技术管理层都是非常优秀的跨职能人才，这让他们能够在技术岗位快速进步的同时，还能很快的成为公司的管理者，给公司的发展带来很大的帮助。只是从他们离开公司开始，就无法以对应的title寻找工作，只能寻找技术领域的高级开发者。</p>\n<p>而市场上管理岗位显然少于技术岗位，且不说竞争是否激烈，更何况现在的技术岗位对于技能的要求本身就已经逐渐提高了。当你踏上管理者的岗位开始，一天又能维持几个小时的编码时间呢？你真的会持续刷新自己的技术，保持技术的持久战斗力么？</p>\n<p>或许。其实你内心，其实已经不再重视“编码”这个硬技能了吧。</p>\n<p>另外，依据“彼得原理”，大部分公司其实找的是当前岗位的胜任者，而不是超出对应岗位的“进阶者”。如果你的公司天花板非常低，那你又如何能在那些有高天花板的公司找到高职级的工作。即便有，或许也很难胜任吧。</p>\n<h2 id=\"4-2\"><a href=\"#4-2\" class=\"headerlink\" title=\"4\"></a>4</h2><p>长沙的软件公司或开发者技术不行么？这也是个悖论。文无第一，武无第二。工资不行不代表技术不行。 许多长沙的公司虽然公司效益远远比不上BAT大公司，一年净收入突破几千万就算是个不错的公司了，但这不能说明公司技术不行。恰好相反，一波一波回长沙的开发者，总会有人一点点把长沙的技术水平逐渐提高。</p>\n<p>技术水平的高低没有评判标准，许多大佬技术牛逼，但脱离了公司的平台效应和团队战斗力，单兵作战能力可能并不强。</p>\n<p>相比之下，许多长沙的开发者平时下班之后就是学习技术，交流技术，一天八小时撸码，还有四小时学习，这样的开发者技术还能差到哪里去。</p>\n<p>例如前面提到的蜜獾信息，就形成了这样一群人。而且公司待遇不错，技术氛围也很不错，公司管理层也重视技术和企业文化氛围，早就把“不加班，不写过时的文档，每两周发布一个版本的敏捷发布”玩的挺顺利的，非常适合大家关注。</p>\n<h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5\"></a>5</h2><p>当然，限于体量原因，许多技术含量较高的场景，长沙还真没有。我一位朋友吐槽，长沙的运维人员，还停留在最多百台服务器运维的能力，几乎相当于他2015年的水平。现在在长沙，能够玩得起自动化测试的公司，都还算不错的公司，所以如果你是拥有自动化测试经验的测试工程师，其实也还是有很多机会。</p>\n<p>但那些大公司才有的细分岗位，例如之前说的基站测试，还有咨询师，技术写作专家，配置管理工程师，甚至是python大数据分析师，长沙大概还几乎没有。长沙市场上python相关的职位还非常少，go语言的也并不多。。。</p>\n<h2 id=\"6\"><a href=\"#6\" class=\"headerlink\" title=\"6\"></a>6</h2><p>长沙的公司为什么不愿意花高工资聘请大牛呢？其实这也是一些回长沙的求职者向我吐槽的。也许他们的言下之意是：为啥不聘请“像自己这样的大牛”呢？</p>\n<p>好吧，其实长沙的IT圈也舍得花力气聘请大牛，像已经成为社区电商行业的领跑者的兴盛优选，公司本身已经有不少大牛，而且也愿意用月薪35到60以上的标准聘请阿里巴巴p7以上的开发者，考虑到长沙的物价水平，其实已经挺不错了。</p>\n<p><em>如果你是真大牛。。我可以帮你推荐一番。</em></p>\n<p>总之，长沙的IT公司并非不舍得花高工资聘请大佬，而是因为。。。还没遇到真正牛逼的大佬。</p>\n<h1 id=\"五-高工资是怎么来的？\"><a href=\"#五-高工资是怎么来的？\" class=\"headerlink\" title=\"五 高工资是怎么来的？\"></a>五 高工资是怎么来的？</h1><h2 id=\"1-3\"><a href=\"#1-3\" class=\"headerlink\" title=\"1\"></a>1</h2><p>谈起高工资，我们得想想北上广深那么多百万年薪的程序员，他们的高工资是怎么来的？</p>\n<p>在互联网飞速发展的今天，靠近资本的北上广深杭已经成为风口浪尖，许多与互联网概念相关的企业都跟着业绩腾飞，员工的薪资也跟着水涨船高，此处就不需要举例子了，毕竟BAT那么多家公司的优秀开发者们，用他们的身价证明，自己的一份努力，完全可以代表中国互联网开发者的顶尖收入水平。</p>\n<p>但。。在这些行业巨头之外，还有许多开发者，其实依然处于温饱线的边缘，或稍微比温饱线好那么一点，财务自由？35岁退休？年入百万？大部分人别想了。是由于选择大于努力造成的？还是由于平时温水煮青蛙，不够努力造成的？其实基本上都不是的。事实上，许多开发者，例如一些外包或制造业外包的开发者，他们的条件远比BAT公司更艰苦，每周的工作时长更高，但拿的收入水平，却仅仅只是BAT开发者的零头，甚至不如。</p>\n<p>这大概有点像拿非洲人民和美国资本家对比。用经济学术语来说。。就是“剪刀差”（我打算称为工资剪刀差）。</p>\n<p><img src=\"https://uploader.shimo.im/f/3jlkvgUiFD89FM37.png!thumbnail\" alt=\"图片\"></p>\n<p>互联网企业员工的高收入，其实来源于互联网企业本身对于资本的凝聚力和投资者对于未来的期望所带来的溢价。而有许多互联网公司其实本身已经不需要靠利润来发工资，仅仅依靠“市梦率”，就能维持公司的飞速发展，让员工获得足够的福利。</p>\n<h2 id=\"2-3\"><a href=\"#2-3\" class=\"headerlink\" title=\"2\"></a>2</h2><p>而长沙的互联网公司并不多，大部分都是所谓“行业互联网”，虽然沾上了“互联网”的名，却没有互联网的命。</p>\n<p>“行业互联网”企业由于发展较为缓慢、或者已经较为稳定，事实上已经不太可能从投资者市场获得更高，由于只能靠利润来给员工发工资。</p>\n<p>所以，员工的工资包含了公司获得的投资，公司的利润，公司的品牌溢价、个人的品牌溢价和个人的核心竞争力，个人的机遇。如果你核心竞争力强，让那些优秀的公司能够更早的认识你，自然而然也很容易成为职场上的香饽饽。</p>\n<h2 id=\"3-2\"><a href=\"#3-2\" class=\"headerlink\" title=\"3\"></a>3</h2><p>如果品牌竞争力一般，该如何寻找合适自己的工作呢？</p>\n<p><img src=\"https://uploader.shimo.im/f/CNVf9Df1pBrsO07B.png!thumbnail\" alt=\"图片\"></p>\n<p>认清形势，放弃幻想。回归现实，别妄图拿那么高的工资。找一个自己感兴趣的行业、公司，踏踏实实干下去，通过自己的努力，为公司创造更大的价值，自然而然，你就获得了更好的发展。</p>\n<p>当你回到长沙，就别在幻想通过上班来获得“暴富”了。长沙这样的土壤，其实更像普通人凭借自己双手改变家庭命运的跳板。</p>\n<p>例如，校管家，就是这样的公司，老板们勤勤恳恳、踏踏实实，靠自己的努力，创造了一家优秀的公司，并成功的获得了投资者们的不断关注。在长沙，这样的公司不下数十家。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>与其他城市相比，长沙的IT业态或许更趋于“务实”“勤勉”“实干”“坚持”。</p>\n<p>长沙不是互联网人淘金的热土，也不是一夜暴富者的摇篮。</p>\n<p>在沿海地区互联网的热闹喧嚣之外，长沙其实就是一个这样静静发展、一声不响就创造出不错佳绩的“小而美”的现代化城市。</p>\n<p>在长沙，也许你见不到太多“英雄”，却充满了各种各样、努力付出、细心耕耘、用三年、五年或更长的时间来用心助力公司成长的“普通人”。</p>\n<p>显然，这个世界，既要“冒险家”“野心家”“成功学”，同样也需要“普通人”。</p>\n"},{"title":"是小厂全栈好，还是大厂专业工程师好？","date":"2020-05-17T08:28:00.000Z","author":"邹溪源","_content":"# 一\n在博客园中使用小公司大公司进行搜索，列入的搜索记录长达50页。虽然完全命中关键词的文章也许并不多，但这或许也能体现出这个话题的热门程度。\n\n今天我的公众号好友中也有人问了我这个问题：\n\n>在小公司里面做全栈好，还是大公司里面做专业的前端或者后台好？\n\n对于这个问题，我大概有一点点发言权。在我过去若干年的职业生涯中，各种类型的公司也算都经历过，小一点的公司，大概有四五十人，大一点的公司有大几百人。\n\n当然，与读者们的大厂比起来，都是小公司，着实不算大公司。但总体来说，也算是了解“专业工程师”和“全栈工程师”这两个名词背后的水深水浅。\n\n# 二\n\n有时，当我们去跟一些人交流，会发现一个奇怪的现象，往往小公司的更喜欢称自己为“全栈工程师”，而大厂出来的，则反而不敢自称自己为“全栈工程师”。这究竟是为何呢？\n\n我们可以继续引述经典理论“达克效应”。\n\n1、不知道自己不知道。\n\n2、知道自己不知道。\n\n3、知道自己知道。\n\n4、不知道自己知道。\n\n这四个阶段其实无论在技术层面，还是职场发展过程中，都无处不在。\n\n![图片](https://uploader.shimo.im/f/mPlz1AqvNxxvh5Pf.png!thumbnail)\n\n在我们每个人说起漫长，说起短暂的职业生涯中，总是会历经无穷次技术的发展，甚至变革，这些技术其实在给我们创造价值的同时，也一点点在我们的灵魂深处留下投影。\n\n有的技术或理论，会对我们的职业发展产生非常深刻的影响；有的则如雨后彩虹一般，突然出现，却有遽然消失。\n\n每一种技术或理论的产生总会有一套成体系的脉络，也许入门很容易，但要成为专家其实非常困难。达克效应表现的也是这样一种效应。\n\n那些看起来很容易就学会的东西，往往要深入或许更加困难。而许多大厂开发者深刻体会其中的不容易，所以若非经过最少几百小时的学习，其实不敢自称为专家，更遑论自称“全栈工程师”了。\n\n其实，有的人自称为“全栈工程师”，倒不如说是“全能工程师”---每种技术都或多或少懂一点，能够在很短的时间内完成任务，但一旦要有所深入，就略显不足，无法再进一步了。\n\n# 三\n\n但，无法在技术层面有所深入，是一件难以启齿的事情么？\n\n也许并非如此。我深深的感觉，在IT行业，看起来风起云涌，浪潮迭起，但依然充满前途和光明，其主要原因在于：人们对基于互联网场景下的应用，需求从来就没有因为互联网技术的发展而有所降低，反而越来越细致，越来越具体，产生着越来越深远的影响。\n\n例如，很多年前就说美国互联网泡沫破灭，但今天互联网经济反而越来越重要了；移动互联网也有人唱衰，“说BAT才掌握船票，已经垄断中国经济，其他公司几乎毫无机会”。却莫名其妙间，又多出了头条、美团、小米、滴滴、京东、拼多多等数不尽的优秀互联网公司。\n\n再过十年IT产业会逐渐退潮么，IT人才将会毫无施展才华的土壤么。不得而知，而且也不重要。重要的是，即便在互联网技术飞速发展的今天，中国依然对优秀的IT工程师非常稀缺。\n\n# 四\n\n![图片](https://uploader.shimo.im/f/PTI6SkTmd0rOlYEC.png!thumbnail)\n\n时至今日，软件实现过程并没有因为软件技术人才的增加而逐渐简化，反而依然非常复杂。我们其实都能看到，在IT行业，五年经验以下的开发者始终居于大多数，不管是十年前，还是今天，行业都几乎没有太大的变化。我们能指望现在的年轻开发者能够提前规避我们之前遇到过的那些问题么？\n\n历史告诉我们：人们走过的弯路，后人其实还是会再走一遍。看似大爆炸的互联网，知识满地都是。其实，知识过载和知识过乏没有任何区别。所以，我们写过的那些垃圾代码，我们以前遇到过的那些bug，依然有许多年轻人在沿着我们的步伐再走一遍。\n\n那些隐藏在软件界面的冰山之下，难道bug突然减少了？究竟会不会在哪天突然爆发？客户提出的需求，程序员们究竟是如何实现的？\n\n# 五\n\n我始终认为，专业工程师依然非常匮乏，无论过去、今天，或未来。\n\n专业工程师或许不一定是某个领域的专家，也许是某些具备优秀跨职能能力的开发者。\n\n他们首先能够基于某些行业场景出发，以独特的视角发掘问题的本质，并快速的将业务问题转换为技术实现，还能抽丝剥茧，发现不同事物之间的关联关系，从而更好的将业务问题以软件的形式进行呈现，\n\n他们也能灵活的发现不同技术之间的优缺点，并使用合适的技术问题来进行适配，使得问题能够以最快的速度进行解决。\n\n他们还能从多个角度出发，而不仅仅是从【软件代码实现】这个维度出发来解决问题，他们所具备的良好的沟通能力和专业素养，使得客户/用户能够愿意倾听提出的建议，从而以最少的代价来解决问题。\n\n# 六\n\n成为专业工程师，与选择“大厂”或选择“小厂”有非常明显的区别么？\n\n大公司和小公司都有不同的发展轨迹，不同的人适合不同的发展方向。无论怎么选，其实都是“小样本”。\n\n个体选择走【跨职能型人才路线】或走【专业人才】路线，对于偌大的中国来说，都其实不会对历史的车轮产生多大的影响，但我们的选择其实是在慢慢的改变我们的生活。\n\n有时，小厂在能够填补我们对于经济上的匮乏，又有时，选择了大厂会让我们以为未来的发展无忧。\n\n确实如此，有时一些小厂反而能够比大厂提供短期内更加诱人的薪资，这对一些经济条件不太好的人来说，犹如“久旱甘霖”；而大厂看似平滑的发展曲线，能够让我们只要沿着设定的方向走下去，肯定不会走错。\n\n但真的小厂就意味着“朝不保夕”，大厂就一定是“高枕无忧”么？谁也说不准。\n\n最重要的，也许依然是认清自己的定位，无论在大厂，还是小厂，使自己成为出色的“专业工程师”，更加全面的成长，或许更能让我们的职场利于不败之地。\n\n","source":"_posts/随笔/是小厂全栈好，还是大厂专业工程师好？.md","raw":"---\ntitle:  是小厂全栈好，还是大厂专业工程师好？\ndate: 2020-5-17 16:28\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n# 一\n在博客园中使用小公司大公司进行搜索，列入的搜索记录长达50页。虽然完全命中关键词的文章也许并不多，但这或许也能体现出这个话题的热门程度。\n\n今天我的公众号好友中也有人问了我这个问题：\n\n>在小公司里面做全栈好，还是大公司里面做专业的前端或者后台好？\n\n对于这个问题，我大概有一点点发言权。在我过去若干年的职业生涯中，各种类型的公司也算都经历过，小一点的公司，大概有四五十人，大一点的公司有大几百人。\n\n当然，与读者们的大厂比起来，都是小公司，着实不算大公司。但总体来说，也算是了解“专业工程师”和“全栈工程师”这两个名词背后的水深水浅。\n\n# 二\n\n有时，当我们去跟一些人交流，会发现一个奇怪的现象，往往小公司的更喜欢称自己为“全栈工程师”，而大厂出来的，则反而不敢自称自己为“全栈工程师”。这究竟是为何呢？\n\n我们可以继续引述经典理论“达克效应”。\n\n1、不知道自己不知道。\n\n2、知道自己不知道。\n\n3、知道自己知道。\n\n4、不知道自己知道。\n\n这四个阶段其实无论在技术层面，还是职场发展过程中，都无处不在。\n\n![图片](https://uploader.shimo.im/f/mPlz1AqvNxxvh5Pf.png!thumbnail)\n\n在我们每个人说起漫长，说起短暂的职业生涯中，总是会历经无穷次技术的发展，甚至变革，这些技术其实在给我们创造价值的同时，也一点点在我们的灵魂深处留下投影。\n\n有的技术或理论，会对我们的职业发展产生非常深刻的影响；有的则如雨后彩虹一般，突然出现，却有遽然消失。\n\n每一种技术或理论的产生总会有一套成体系的脉络，也许入门很容易，但要成为专家其实非常困难。达克效应表现的也是这样一种效应。\n\n那些看起来很容易就学会的东西，往往要深入或许更加困难。而许多大厂开发者深刻体会其中的不容易，所以若非经过最少几百小时的学习，其实不敢自称为专家，更遑论自称“全栈工程师”了。\n\n其实，有的人自称为“全栈工程师”，倒不如说是“全能工程师”---每种技术都或多或少懂一点，能够在很短的时间内完成任务，但一旦要有所深入，就略显不足，无法再进一步了。\n\n# 三\n\n但，无法在技术层面有所深入，是一件难以启齿的事情么？\n\n也许并非如此。我深深的感觉，在IT行业，看起来风起云涌，浪潮迭起，但依然充满前途和光明，其主要原因在于：人们对基于互联网场景下的应用，需求从来就没有因为互联网技术的发展而有所降低，反而越来越细致，越来越具体，产生着越来越深远的影响。\n\n例如，很多年前就说美国互联网泡沫破灭，但今天互联网经济反而越来越重要了；移动互联网也有人唱衰，“说BAT才掌握船票，已经垄断中国经济，其他公司几乎毫无机会”。却莫名其妙间，又多出了头条、美团、小米、滴滴、京东、拼多多等数不尽的优秀互联网公司。\n\n再过十年IT产业会逐渐退潮么，IT人才将会毫无施展才华的土壤么。不得而知，而且也不重要。重要的是，即便在互联网技术飞速发展的今天，中国依然对优秀的IT工程师非常稀缺。\n\n# 四\n\n![图片](https://uploader.shimo.im/f/PTI6SkTmd0rOlYEC.png!thumbnail)\n\n时至今日，软件实现过程并没有因为软件技术人才的增加而逐渐简化，反而依然非常复杂。我们其实都能看到，在IT行业，五年经验以下的开发者始终居于大多数，不管是十年前，还是今天，行业都几乎没有太大的变化。我们能指望现在的年轻开发者能够提前规避我们之前遇到过的那些问题么？\n\n历史告诉我们：人们走过的弯路，后人其实还是会再走一遍。看似大爆炸的互联网，知识满地都是。其实，知识过载和知识过乏没有任何区别。所以，我们写过的那些垃圾代码，我们以前遇到过的那些bug，依然有许多年轻人在沿着我们的步伐再走一遍。\n\n那些隐藏在软件界面的冰山之下，难道bug突然减少了？究竟会不会在哪天突然爆发？客户提出的需求，程序员们究竟是如何实现的？\n\n# 五\n\n我始终认为，专业工程师依然非常匮乏，无论过去、今天，或未来。\n\n专业工程师或许不一定是某个领域的专家，也许是某些具备优秀跨职能能力的开发者。\n\n他们首先能够基于某些行业场景出发，以独特的视角发掘问题的本质，并快速的将业务问题转换为技术实现，还能抽丝剥茧，发现不同事物之间的关联关系，从而更好的将业务问题以软件的形式进行呈现，\n\n他们也能灵活的发现不同技术之间的优缺点，并使用合适的技术问题来进行适配，使得问题能够以最快的速度进行解决。\n\n他们还能从多个角度出发，而不仅仅是从【软件代码实现】这个维度出发来解决问题，他们所具备的良好的沟通能力和专业素养，使得客户/用户能够愿意倾听提出的建议，从而以最少的代价来解决问题。\n\n# 六\n\n成为专业工程师，与选择“大厂”或选择“小厂”有非常明显的区别么？\n\n大公司和小公司都有不同的发展轨迹，不同的人适合不同的发展方向。无论怎么选，其实都是“小样本”。\n\n个体选择走【跨职能型人才路线】或走【专业人才】路线，对于偌大的中国来说，都其实不会对历史的车轮产生多大的影响，但我们的选择其实是在慢慢的改变我们的生活。\n\n有时，小厂在能够填补我们对于经济上的匮乏，又有时，选择了大厂会让我们以为未来的发展无忧。\n\n确实如此，有时一些小厂反而能够比大厂提供短期内更加诱人的薪资，这对一些经济条件不太好的人来说，犹如“久旱甘霖”；而大厂看似平滑的发展曲线，能够让我们只要沿着设定的方向走下去，肯定不会走错。\n\n但真的小厂就意味着“朝不保夕”，大厂就一定是“高枕无忧”么？谁也说不准。\n\n最重要的，也许依然是认清自己的定位，无论在大厂，还是小厂，使自己成为出色的“专业工程师”，更加全面的成长，或许更能让我们的职场利于不败之地。\n\n","slug":"随笔/是小厂全栈好，还是大厂专业工程师好？","published":1,"updated":"2020-05-26T11:11:24.520Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt9m004in4victr1866l","content":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>在博客园中使用小公司大公司进行搜索，列入的搜索记录长达50页。虽然完全命中关键词的文章也许并不多，但这或许也能体现出这个话题的热门程度。</p>\n<p>今天我的公众号好友中也有人问了我这个问题：</p>\n<blockquote>\n<p>在小公司里面做全栈好，还是大公司里面做专业的前端或者后台好？</p>\n</blockquote>\n<p>对于这个问题，我大概有一点点发言权。在我过去若干年的职业生涯中，各种类型的公司也算都经历过，小一点的公司，大概有四五十人，大一点的公司有大几百人。</p>\n<p>当然，与读者们的大厂比起来，都是小公司，着实不算大公司。但总体来说，也算是了解“专业工程师”和“全栈工程师”这两个名词背后的水深水浅。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>有时，当我们去跟一些人交流，会发现一个奇怪的现象，往往小公司的更喜欢称自己为“全栈工程师”，而大厂出来的，则反而不敢自称自己为“全栈工程师”。这究竟是为何呢？</p>\n<p>我们可以继续引述经典理论“达克效应”。</p>\n<p>1、不知道自己不知道。</p>\n<p>2、知道自己不知道。</p>\n<p>3、知道自己知道。</p>\n<p>4、不知道自己知道。</p>\n<p>这四个阶段其实无论在技术层面，还是职场发展过程中，都无处不在。</p>\n<p><img src=\"https://uploader.shimo.im/f/mPlz1AqvNxxvh5Pf.png!thumbnail\" alt=\"图片\"></p>\n<p>在我们每个人说起漫长，说起短暂的职业生涯中，总是会历经无穷次技术的发展，甚至变革，这些技术其实在给我们创造价值的同时，也一点点在我们的灵魂深处留下投影。</p>\n<p>有的技术或理论，会对我们的职业发展产生非常深刻的影响；有的则如雨后彩虹一般，突然出现，却有遽然消失。</p>\n<p>每一种技术或理论的产生总会有一套成体系的脉络，也许入门很容易，但要成为专家其实非常困难。达克效应表现的也是这样一种效应。</p>\n<p>那些看起来很容易就学会的东西，往往要深入或许更加困难。而许多大厂开发者深刻体会其中的不容易，所以若非经过最少几百小时的学习，其实不敢自称为专家，更遑论自称“全栈工程师”了。</p>\n<p>其实，有的人自称为“全栈工程师”，倒不如说是“全能工程师”—每种技术都或多或少懂一点，能够在很短的时间内完成任务，但一旦要有所深入，就略显不足，无法再进一步了。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>但，无法在技术层面有所深入，是一件难以启齿的事情么？</p>\n<p>也许并非如此。我深深的感觉，在IT行业，看起来风起云涌，浪潮迭起，但依然充满前途和光明，其主要原因在于：人们对基于互联网场景下的应用，需求从来就没有因为互联网技术的发展而有所降低，反而越来越细致，越来越具体，产生着越来越深远的影响。</p>\n<p>例如，很多年前就说美国互联网泡沫破灭，但今天互联网经济反而越来越重要了；移动互联网也有人唱衰，“说BAT才掌握船票，已经垄断中国经济，其他公司几乎毫无机会”。却莫名其妙间，又多出了头条、美团、小米、滴滴、京东、拼多多等数不尽的优秀互联网公司。</p>\n<p>再过十年IT产业会逐渐退潮么，IT人才将会毫无施展才华的土壤么。不得而知，而且也不重要。重要的是，即便在互联网技术飞速发展的今天，中国依然对优秀的IT工程师非常稀缺。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p><img src=\"https://uploader.shimo.im/f/PTI6SkTmd0rOlYEC.png!thumbnail\" alt=\"图片\"></p>\n<p>时至今日，软件实现过程并没有因为软件技术人才的增加而逐渐简化，反而依然非常复杂。我们其实都能看到，在IT行业，五年经验以下的开发者始终居于大多数，不管是十年前，还是今天，行业都几乎没有太大的变化。我们能指望现在的年轻开发者能够提前规避我们之前遇到过的那些问题么？</p>\n<p>历史告诉我们：人们走过的弯路，后人其实还是会再走一遍。看似大爆炸的互联网，知识满地都是。其实，知识过载和知识过乏没有任何区别。所以，我们写过的那些垃圾代码，我们以前遇到过的那些bug，依然有许多年轻人在沿着我们的步伐再走一遍。</p>\n<p>那些隐藏在软件界面的冰山之下，难道bug突然减少了？究竟会不会在哪天突然爆发？客户提出的需求，程序员们究竟是如何实现的？</p>\n<h1 id=\"五\"><a href=\"#五\" class=\"headerlink\" title=\"五\"></a>五</h1><p>我始终认为，专业工程师依然非常匮乏，无论过去、今天，或未来。</p>\n<p>专业工程师或许不一定是某个领域的专家，也许是某些具备优秀跨职能能力的开发者。</p>\n<p>他们首先能够基于某些行业场景出发，以独特的视角发掘问题的本质，并快速的将业务问题转换为技术实现，还能抽丝剥茧，发现不同事物之间的关联关系，从而更好的将业务问题以软件的形式进行呈现，</p>\n<p>他们也能灵活的发现不同技术之间的优缺点，并使用合适的技术问题来进行适配，使得问题能够以最快的速度进行解决。</p>\n<p>他们还能从多个角度出发，而不仅仅是从【软件代码实现】这个维度出发来解决问题，他们所具备的良好的沟通能力和专业素养，使得客户/用户能够愿意倾听提出的建议，从而以最少的代价来解决问题。</p>\n<h1 id=\"六\"><a href=\"#六\" class=\"headerlink\" title=\"六\"></a>六</h1><p>成为专业工程师，与选择“大厂”或选择“小厂”有非常明显的区别么？</p>\n<p>大公司和小公司都有不同的发展轨迹，不同的人适合不同的发展方向。无论怎么选，其实都是“小样本”。</p>\n<p>个体选择走【跨职能型人才路线】或走【专业人才】路线，对于偌大的中国来说，都其实不会对历史的车轮产生多大的影响，但我们的选择其实是在慢慢的改变我们的生活。</p>\n<p>有时，小厂在能够填补我们对于经济上的匮乏，又有时，选择了大厂会让我们以为未来的发展无忧。</p>\n<p>确实如此，有时一些小厂反而能够比大厂提供短期内更加诱人的薪资，这对一些经济条件不太好的人来说，犹如“久旱甘霖”；而大厂看似平滑的发展曲线，能够让我们只要沿着设定的方向走下去，肯定不会走错。</p>\n<p>但真的小厂就意味着“朝不保夕”，大厂就一定是“高枕无忧”么？谁也说不准。</p>\n<p>最重要的，也许依然是认清自己的定位，无论在大厂，还是小厂，使自己成为出色的“专业工程师”，更加全面的成长，或许更能让我们的职场利于不败之地。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>在博客园中使用小公司大公司进行搜索，列入的搜索记录长达50页。虽然完全命中关键词的文章也许并不多，但这或许也能体现出这个话题的热门程度。</p>\n<p>今天我的公众号好友中也有人问了我这个问题：</p>\n<blockquote>\n<p>在小公司里面做全栈好，还是大公司里面做专业的前端或者后台好？</p>\n</blockquote>\n<p>对于这个问题，我大概有一点点发言权。在我过去若干年的职业生涯中，各种类型的公司也算都经历过，小一点的公司，大概有四五十人，大一点的公司有大几百人。</p>\n<p>当然，与读者们的大厂比起来，都是小公司，着实不算大公司。但总体来说，也算是了解“专业工程师”和“全栈工程师”这两个名词背后的水深水浅。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>有时，当我们去跟一些人交流，会发现一个奇怪的现象，往往小公司的更喜欢称自己为“全栈工程师”，而大厂出来的，则反而不敢自称自己为“全栈工程师”。这究竟是为何呢？</p>\n<p>我们可以继续引述经典理论“达克效应”。</p>\n<p>1、不知道自己不知道。</p>\n<p>2、知道自己不知道。</p>\n<p>3、知道自己知道。</p>\n<p>4、不知道自己知道。</p>\n<p>这四个阶段其实无论在技术层面，还是职场发展过程中，都无处不在。</p>\n<p><img src=\"https://uploader.shimo.im/f/mPlz1AqvNxxvh5Pf.png!thumbnail\" alt=\"图片\"></p>\n<p>在我们每个人说起漫长，说起短暂的职业生涯中，总是会历经无穷次技术的发展，甚至变革，这些技术其实在给我们创造价值的同时，也一点点在我们的灵魂深处留下投影。</p>\n<p>有的技术或理论，会对我们的职业发展产生非常深刻的影响；有的则如雨后彩虹一般，突然出现，却有遽然消失。</p>\n<p>每一种技术或理论的产生总会有一套成体系的脉络，也许入门很容易，但要成为专家其实非常困难。达克效应表现的也是这样一种效应。</p>\n<p>那些看起来很容易就学会的东西，往往要深入或许更加困难。而许多大厂开发者深刻体会其中的不容易，所以若非经过最少几百小时的学习，其实不敢自称为专家，更遑论自称“全栈工程师”了。</p>\n<p>其实，有的人自称为“全栈工程师”，倒不如说是“全能工程师”—每种技术都或多或少懂一点，能够在很短的时间内完成任务，但一旦要有所深入，就略显不足，无法再进一步了。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>但，无法在技术层面有所深入，是一件难以启齿的事情么？</p>\n<p>也许并非如此。我深深的感觉，在IT行业，看起来风起云涌，浪潮迭起，但依然充满前途和光明，其主要原因在于：人们对基于互联网场景下的应用，需求从来就没有因为互联网技术的发展而有所降低，反而越来越细致，越来越具体，产生着越来越深远的影响。</p>\n<p>例如，很多年前就说美国互联网泡沫破灭，但今天互联网经济反而越来越重要了；移动互联网也有人唱衰，“说BAT才掌握船票，已经垄断中国经济，其他公司几乎毫无机会”。却莫名其妙间，又多出了头条、美团、小米、滴滴、京东、拼多多等数不尽的优秀互联网公司。</p>\n<p>再过十年IT产业会逐渐退潮么，IT人才将会毫无施展才华的土壤么。不得而知，而且也不重要。重要的是，即便在互联网技术飞速发展的今天，中国依然对优秀的IT工程师非常稀缺。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p><img src=\"https://uploader.shimo.im/f/PTI6SkTmd0rOlYEC.png!thumbnail\" alt=\"图片\"></p>\n<p>时至今日，软件实现过程并没有因为软件技术人才的增加而逐渐简化，反而依然非常复杂。我们其实都能看到，在IT行业，五年经验以下的开发者始终居于大多数，不管是十年前，还是今天，行业都几乎没有太大的变化。我们能指望现在的年轻开发者能够提前规避我们之前遇到过的那些问题么？</p>\n<p>历史告诉我们：人们走过的弯路，后人其实还是会再走一遍。看似大爆炸的互联网，知识满地都是。其实，知识过载和知识过乏没有任何区别。所以，我们写过的那些垃圾代码，我们以前遇到过的那些bug，依然有许多年轻人在沿着我们的步伐再走一遍。</p>\n<p>那些隐藏在软件界面的冰山之下，难道bug突然减少了？究竟会不会在哪天突然爆发？客户提出的需求，程序员们究竟是如何实现的？</p>\n<h1 id=\"五\"><a href=\"#五\" class=\"headerlink\" title=\"五\"></a>五</h1><p>我始终认为，专业工程师依然非常匮乏，无论过去、今天，或未来。</p>\n<p>专业工程师或许不一定是某个领域的专家，也许是某些具备优秀跨职能能力的开发者。</p>\n<p>他们首先能够基于某些行业场景出发，以独特的视角发掘问题的本质，并快速的将业务问题转换为技术实现，还能抽丝剥茧，发现不同事物之间的关联关系，从而更好的将业务问题以软件的形式进行呈现，</p>\n<p>他们也能灵活的发现不同技术之间的优缺点，并使用合适的技术问题来进行适配，使得问题能够以最快的速度进行解决。</p>\n<p>他们还能从多个角度出发，而不仅仅是从【软件代码实现】这个维度出发来解决问题，他们所具备的良好的沟通能力和专业素养，使得客户/用户能够愿意倾听提出的建议，从而以最少的代价来解决问题。</p>\n<h1 id=\"六\"><a href=\"#六\" class=\"headerlink\" title=\"六\"></a>六</h1><p>成为专业工程师，与选择“大厂”或选择“小厂”有非常明显的区别么？</p>\n<p>大公司和小公司都有不同的发展轨迹，不同的人适合不同的发展方向。无论怎么选，其实都是“小样本”。</p>\n<p>个体选择走【跨职能型人才路线】或走【专业人才】路线，对于偌大的中国来说，都其实不会对历史的车轮产生多大的影响，但我们的选择其实是在慢慢的改变我们的生活。</p>\n<p>有时，小厂在能够填补我们对于经济上的匮乏，又有时，选择了大厂会让我们以为未来的发展无忧。</p>\n<p>确实如此，有时一些小厂反而能够比大厂提供短期内更加诱人的薪资，这对一些经济条件不太好的人来说，犹如“久旱甘霖”；而大厂看似平滑的发展曲线，能够让我们只要沿着设定的方向走下去，肯定不会走错。</p>\n<p>但真的小厂就意味着“朝不保夕”，大厂就一定是“高枕无忧”么？谁也说不准。</p>\n<p>最重要的，也许依然是认清自己的定位，无论在大厂，还是小厂，使自己成为出色的“专业工程师”，更加全面的成长，或许更能让我们的职场利于不败之地。</p>\n"},{"title":"我在外包公司做增删改查有前途么？","date":"2019-12-15T13:28:00.000Z","author":"邹溪源","_content":"\n# 起因\n这是我无意中在筛选简历时，看到一位朋友发布的求职说明中，明确指出，外包勿扰，并给出了他做出这个决定的理由：\n\n过去若干年间，他一直在中软国际从事.NET方向的软件研发，虽然工作了很多年，但是做的项目类型特别多，总感觉没什么积累，而且工作很累，经常要加班，压力很大。不仅如此，由于外包类型的项目，往往需要驻场开发，一旦在客户现场进行开发，其实都会成为封闭式开发，每天投入工作的工时往往会超过十几个小时。而且在客户现场的开发时，有时候就是低等公民，得承受来自各方的压力。\n\n前不久也刚刚看到一位来自西安软通动力的资深Java工程师，由于长时间加班后引发身体疾病，并最终猝死，还得不到工伤补偿的新闻也触动了我们的心。\n\n这边的互联网公司从业人员还可以吐槽每天996，让自己成为被公司圈养的小绵羊，更是让自己的家庭生活都受到了无穷影响；那边的外包公司从业人员们显然没有互联网公司这么多的露脸机会，哪里有时间运营自己的公众号啊，每天都被客户压榨得死死的，还得跪下来对客户说：爸爸，再爱我一次！\n\n当然，坦率而言，现在国内的IT行业现状其实压力都很大，无论是外包公司、还是互联网公司，如果是几年前大环境还好的时候，或许大家压力大点，至少不会饿肚子，现在冬天来了，不仅压力大，而且还吃不饱穿不暖，一旦遇到公司困境，还得面临被裁员的后果。\n\n- ![image-20191130140814321](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/1.png)\n\n好吧，在这篇文章中，我还是不输出焦虑了，只单纯的讨论一下这个问题。\n\n# 在外包公司做增删改查有前途么？\n有没有感觉，这是一个通用的句式：干xxx有前途么？\n\n- ![image-20191130140814321](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/2.png)\n\n例如，在百度里面输入，“干程序”，首先会自动提示的就是“干程序员有没有前景”？好吧，有没有前途我也说不准，我就单纯的探讨几个问题，什么叫有前途；在外包公司有前途么；做增删改查有前途么？\n\n# 什么叫做有前途？\n世俗的说，金钱、名誉和地位大概就是许多人在追求的前途。而在IT领域，由于无法与从事公务员和经商的其他同龄人相比，往往会用待遇和岗位来形容。例如有时候总会以为技术总监一定是值得追求的前途；或者为了更高的收入，会选择一些特定的行业。例如这几年相继爆雷的P2P行业，在这些行业中的开发者的工资往往都非常高。\n\n然而，当公司的套路被人揭穿之后，无数投资人的巨额投资化作一堆废纸，这些P2P企业公司的开发者们在这段时间从公司获得的所有收入都会被列入非法所得，必须上缴给公安机关，以便清偿债务。\n\n不仅如此，有时候还不能过度的宣传自己在这些行业的职场工作经验，不然可能会被下家认为心术不正。 \n\n- ![image-20191130140814321](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/3.png)\n\n>爱因斯坦说：我坚信，世界上的财富无法促进人类发展，即使它掌握在哪些仍想达到此目标的人手中也无济于事。金钱只能滋生人们的自私自利，并使其不能自持地加以滥用。\n\n当然，当今时代终究是个世俗的世界。但追求金钱和Title所谓的看似有前途的工作，还是得建立道德和法律的基础上。\n\n# 在外包公司有前途么？\n外包公司的主要盈利点，其实是软件研发过程管理或者软件项目管理能力，一套优秀的软件项目管理流程体系，往往能够实现软件开发过程中的生产力最大化，进而为企业的发展带来巨大的利润。\n\n在外包公司，主要的收入其实是来源于项目参与人员的人工费用，一般会采用“工料合同”的形式。这种合同又称为单价合同，一般会根据产品在研发过程中的实际投入或服务来计算合同总价。\n\n当然，其实许多外包公司会采用这种方式来进行工作量的评估，然后再用总价合同的形式来签订合同，毕竟“工料合同”其实浮动空间很大，容易造成甲方的成本超支严重，而使用总价合同就可以将风险转嫁给乙方，对于甲方来说自然而然就实现了利益最大化了。\n\n而总价合同的特点是应该明确设定需求、对功能的工作量评估都应该尽可能的科学，问题是，客户明白他想要什么么？大概率客户并不懂他想要什么，或者他以为他懂他想要什么，而且你以为你也懂他想要什么。于是陷入双方需求的拉锯战，软件的风险急剧提高，让苦逼的乙方程序员们成为砧板上的肉，被迫每天牺牲自己的时间，拿有限的生命投入到无穷无尽的需求大坑中。\n\n而且有时候由于行业不同，还会陷入需求陷阱中，各行如隔山，客户想要的，往往与你能提供的，存在很大的差异。例如，连微软都会被武汉上诉，要求赔偿其在智慧城市项目中造成的大几千万损失，一般般的外包公司就更不用说了。\n\n如果遇到这种情况，请勇敢的选择拒绝，或者使自己成为更专业的人。努力花更多的时间学习行业知识，然后用数据或阶段性成果让客户尽可能的无话可说吧。\n\n当然并非所有的外包公司都是这种情况，例如像SAP或者Thoughtworks，其实也可以被世俗的理解为外包公司，他们也是为客户提供外包服务，但是由于他们是行业内的领先者，能够为客户需求提供更加专业的建议，所以他们有资格找客户签署“工料合同”。\n\n例如一个SAP的服务工程师，从上飞机起就开始计算工时费用，每天动辄万元的服务费，服务工程师的工资自然而然也低不到哪里去了。我一位同事他哥哥就是从事SAP的外包服务，他说他哥哥每年只上半年班，工资超过3万一个月。。。嗯,好吧，这种外包就等同于有前途。\n\n依然有许多公司会走在签署总价合同的外包公司的道路上，毕竟企业生存是第一要务，万一哪天接到一个合适的项目，让公司能够顺利的摆脱外包公司的这块皮，进入细分市场，获得进一步的生机呢？\n\n不过大部分外包公司或许其实并没有那么好的命，而且还会由于内卷化（指优秀员工逐渐流失，而新人难以加入，最后被中庸的老员工主宰企业的命运）最终越来越丧失竞争力，并最终只能凉凉。而且缺乏核心主业的外包公司确实很难获得技能上的积累，这需要开发者能够提高自己的技术学习能力，努力使自己成为最专业的工程师。\n\n- ![image-20191130140814321](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/4.png)\n\n# 做增删改查有前途么？\n许多开发者都吐槽，每天的工作都是CRUD，也有许多开发者经常吐槽身边的那些开发者没前途，只会增删改查。\n\n怎么觉得这个问题为啥这么魔性呢？难道你和他们不是同一拨人么？\n\n有时候还会看到有人吐槽，说每天都在做CRUD的业务开发，感觉自己人都要玩废了。还问我怎么想。\n\n我个人认为CRUD才是公司业务的常态，只有能够把CRUD玩得非常好，公司业务才能获得更快的发展。从表面上看，CRUD工程师的主要职责就是建表、封装接口、然后让接口输出数据符合客户端需求。实际上这里面依然牵涉到许多充满技术含量的东西。\n\n例如，该如何建表呢？从海量的用户需求中，分析出与系统息息相关的核心部分，并分析出符合用户需求的核心领域，这种业务分析与设计能力是一位软件工程师非常重要的核心技能。\n\n例如，以前都是撸sql，现在都用orm了，是不是觉得很香？增删改查一样也充满了期待啊。\n\n该怎么建表，也并非想象中那么简单。例如主键是用自增序列，还是用UUID，该怎么设计索引，如何设计缓存，如何运用分表分库策略？这些看起来很简单的东西，往往并不简单。\n\n除此之外，代码的质量本身，也是一件值得深入钻研的方面，例如《代码整洁之道》和《重构改善既有代码的艺术》这两本书就专门介绍了如何写代码和如何把代码写好。这也是一件看起来简单，却并不简单的事情。\n\n除此之外，沟通技能、架构能力、风险意识，也都会在这些CRUD的开发过程中得以体现。\n\n为什么总是会认为CRUD毫无挑战呢。如果你已经成为软件开发领域的大牛，请收下我的膝盖，否则大概率是因为你已经走在了云程序员的路上，把一切问题都想象得太简单了吧。\n\n突然想起之前看的的一张段子，说火箭其实没什么技术含量，因为中国古时候早就有了。还有之前看的郭德纲的段子，他说：如果我跟一位火箭工程师讨论火箭的燃料不应该用氢氧，应该烧煤，对方正眼看了我一眼，那就是我输。\n\n嗯，云程序员们，咱们离专业开发者还有不少差距啊！\n\n- ![image-20191130140814321](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/5.png)\n\n# # 总结\n回到主题：在外包公司做增删改查有前途么？\n\n1. 在外包公司也好，非外包公司也好，努力使自己成为专业的人，都会有前途。\n2. 不管在哪家公司，如果你觉得不开心可以离去；但是如果留下来了，请珍惜每一段时光，上帝既会给你关门，也往往会给你开一扇窗户，只要用心去发现，你总会有所收获。\n3. 其实认真干好每一件事情，都会充满前途。如果过于敏感，总觉得干这个没前途，干那个没前途，那大概你应该去选择创业。那里你可以找到属于你的好归宿。\n4. IT的职场的时光说漫长也漫长，说短暂也短暂。干得好就是四十年，干得不好，就是五年。\n5. 或许每个人都有机会花五年时间成为技术总监，但是却只有少数人，能够成为真正合格的工程师。\n","source":"_posts/随笔/我在外包公司做增删改查有前途么？.md","raw":"---\ntitle:  我在外包公司做增删改查有前途么？\ndate: 2019-12-15 21:28\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n\n# 起因\n这是我无意中在筛选简历时，看到一位朋友发布的求职说明中，明确指出，外包勿扰，并给出了他做出这个决定的理由：\n\n过去若干年间，他一直在中软国际从事.NET方向的软件研发，虽然工作了很多年，但是做的项目类型特别多，总感觉没什么积累，而且工作很累，经常要加班，压力很大。不仅如此，由于外包类型的项目，往往需要驻场开发，一旦在客户现场进行开发，其实都会成为封闭式开发，每天投入工作的工时往往会超过十几个小时。而且在客户现场的开发时，有时候就是低等公民，得承受来自各方的压力。\n\n前不久也刚刚看到一位来自西安软通动力的资深Java工程师，由于长时间加班后引发身体疾病，并最终猝死，还得不到工伤补偿的新闻也触动了我们的心。\n\n这边的互联网公司从业人员还可以吐槽每天996，让自己成为被公司圈养的小绵羊，更是让自己的家庭生活都受到了无穷影响；那边的外包公司从业人员们显然没有互联网公司这么多的露脸机会，哪里有时间运营自己的公众号啊，每天都被客户压榨得死死的，还得跪下来对客户说：爸爸，再爱我一次！\n\n当然，坦率而言，现在国内的IT行业现状其实压力都很大，无论是外包公司、还是互联网公司，如果是几年前大环境还好的时候，或许大家压力大点，至少不会饿肚子，现在冬天来了，不仅压力大，而且还吃不饱穿不暖，一旦遇到公司困境，还得面临被裁员的后果。\n\n- ![image-20191130140814321](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/1.png)\n\n好吧，在这篇文章中，我还是不输出焦虑了，只单纯的讨论一下这个问题。\n\n# 在外包公司做增删改查有前途么？\n有没有感觉，这是一个通用的句式：干xxx有前途么？\n\n- ![image-20191130140814321](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/2.png)\n\n例如，在百度里面输入，“干程序”，首先会自动提示的就是“干程序员有没有前景”？好吧，有没有前途我也说不准，我就单纯的探讨几个问题，什么叫有前途；在外包公司有前途么；做增删改查有前途么？\n\n# 什么叫做有前途？\n世俗的说，金钱、名誉和地位大概就是许多人在追求的前途。而在IT领域，由于无法与从事公务员和经商的其他同龄人相比，往往会用待遇和岗位来形容。例如有时候总会以为技术总监一定是值得追求的前途；或者为了更高的收入，会选择一些特定的行业。例如这几年相继爆雷的P2P行业，在这些行业中的开发者的工资往往都非常高。\n\n然而，当公司的套路被人揭穿之后，无数投资人的巨额投资化作一堆废纸，这些P2P企业公司的开发者们在这段时间从公司获得的所有收入都会被列入非法所得，必须上缴给公安机关，以便清偿债务。\n\n不仅如此，有时候还不能过度的宣传自己在这些行业的职场工作经验，不然可能会被下家认为心术不正。 \n\n- ![image-20191130140814321](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/3.png)\n\n>爱因斯坦说：我坚信，世界上的财富无法促进人类发展，即使它掌握在哪些仍想达到此目标的人手中也无济于事。金钱只能滋生人们的自私自利，并使其不能自持地加以滥用。\n\n当然，当今时代终究是个世俗的世界。但追求金钱和Title所谓的看似有前途的工作，还是得建立道德和法律的基础上。\n\n# 在外包公司有前途么？\n外包公司的主要盈利点，其实是软件研发过程管理或者软件项目管理能力，一套优秀的软件项目管理流程体系，往往能够实现软件开发过程中的生产力最大化，进而为企业的发展带来巨大的利润。\n\n在外包公司，主要的收入其实是来源于项目参与人员的人工费用，一般会采用“工料合同”的形式。这种合同又称为单价合同，一般会根据产品在研发过程中的实际投入或服务来计算合同总价。\n\n当然，其实许多外包公司会采用这种方式来进行工作量的评估，然后再用总价合同的形式来签订合同，毕竟“工料合同”其实浮动空间很大，容易造成甲方的成本超支严重，而使用总价合同就可以将风险转嫁给乙方，对于甲方来说自然而然就实现了利益最大化了。\n\n而总价合同的特点是应该明确设定需求、对功能的工作量评估都应该尽可能的科学，问题是，客户明白他想要什么么？大概率客户并不懂他想要什么，或者他以为他懂他想要什么，而且你以为你也懂他想要什么。于是陷入双方需求的拉锯战，软件的风险急剧提高，让苦逼的乙方程序员们成为砧板上的肉，被迫每天牺牲自己的时间，拿有限的生命投入到无穷无尽的需求大坑中。\n\n而且有时候由于行业不同，还会陷入需求陷阱中，各行如隔山，客户想要的，往往与你能提供的，存在很大的差异。例如，连微软都会被武汉上诉，要求赔偿其在智慧城市项目中造成的大几千万损失，一般般的外包公司就更不用说了。\n\n如果遇到这种情况，请勇敢的选择拒绝，或者使自己成为更专业的人。努力花更多的时间学习行业知识，然后用数据或阶段性成果让客户尽可能的无话可说吧。\n\n当然并非所有的外包公司都是这种情况，例如像SAP或者Thoughtworks，其实也可以被世俗的理解为外包公司，他们也是为客户提供外包服务，但是由于他们是行业内的领先者，能够为客户需求提供更加专业的建议，所以他们有资格找客户签署“工料合同”。\n\n例如一个SAP的服务工程师，从上飞机起就开始计算工时费用，每天动辄万元的服务费，服务工程师的工资自然而然也低不到哪里去了。我一位同事他哥哥就是从事SAP的外包服务，他说他哥哥每年只上半年班，工资超过3万一个月。。。嗯,好吧，这种外包就等同于有前途。\n\n依然有许多公司会走在签署总价合同的外包公司的道路上，毕竟企业生存是第一要务，万一哪天接到一个合适的项目，让公司能够顺利的摆脱外包公司的这块皮，进入细分市场，获得进一步的生机呢？\n\n不过大部分外包公司或许其实并没有那么好的命，而且还会由于内卷化（指优秀员工逐渐流失，而新人难以加入，最后被中庸的老员工主宰企业的命运）最终越来越丧失竞争力，并最终只能凉凉。而且缺乏核心主业的外包公司确实很难获得技能上的积累，这需要开发者能够提高自己的技术学习能力，努力使自己成为最专业的工程师。\n\n- ![image-20191130140814321](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/4.png)\n\n# 做增删改查有前途么？\n许多开发者都吐槽，每天的工作都是CRUD，也有许多开发者经常吐槽身边的那些开发者没前途，只会增删改查。\n\n怎么觉得这个问题为啥这么魔性呢？难道你和他们不是同一拨人么？\n\n有时候还会看到有人吐槽，说每天都在做CRUD的业务开发，感觉自己人都要玩废了。还问我怎么想。\n\n我个人认为CRUD才是公司业务的常态，只有能够把CRUD玩得非常好，公司业务才能获得更快的发展。从表面上看，CRUD工程师的主要职责就是建表、封装接口、然后让接口输出数据符合客户端需求。实际上这里面依然牵涉到许多充满技术含量的东西。\n\n例如，该如何建表呢？从海量的用户需求中，分析出与系统息息相关的核心部分，并分析出符合用户需求的核心领域，这种业务分析与设计能力是一位软件工程师非常重要的核心技能。\n\n例如，以前都是撸sql，现在都用orm了，是不是觉得很香？增删改查一样也充满了期待啊。\n\n该怎么建表，也并非想象中那么简单。例如主键是用自增序列，还是用UUID，该怎么设计索引，如何设计缓存，如何运用分表分库策略？这些看起来很简单的东西，往往并不简单。\n\n除此之外，代码的质量本身，也是一件值得深入钻研的方面，例如《代码整洁之道》和《重构改善既有代码的艺术》这两本书就专门介绍了如何写代码和如何把代码写好。这也是一件看起来简单，却并不简单的事情。\n\n除此之外，沟通技能、架构能力、风险意识，也都会在这些CRUD的开发过程中得以体现。\n\n为什么总是会认为CRUD毫无挑战呢。如果你已经成为软件开发领域的大牛，请收下我的膝盖，否则大概率是因为你已经走在了云程序员的路上，把一切问题都想象得太简单了吧。\n\n突然想起之前看的的一张段子，说火箭其实没什么技术含量，因为中国古时候早就有了。还有之前看的郭德纲的段子，他说：如果我跟一位火箭工程师讨论火箭的燃料不应该用氢氧，应该烧煤，对方正眼看了我一眼，那就是我输。\n\n嗯，云程序员们，咱们离专业开发者还有不少差距啊！\n\n- ![image-20191130140814321](https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/5.png)\n\n# # 总结\n回到主题：在外包公司做增删改查有前途么？\n\n1. 在外包公司也好，非外包公司也好，努力使自己成为专业的人，都会有前途。\n2. 不管在哪家公司，如果你觉得不开心可以离去；但是如果留下来了，请珍惜每一段时光，上帝既会给你关门，也往往会给你开一扇窗户，只要用心去发现，你总会有所收获。\n3. 其实认真干好每一件事情，都会充满前途。如果过于敏感，总觉得干这个没前途，干那个没前途，那大概你应该去选择创业。那里你可以找到属于你的好归宿。\n4. IT的职场的时光说漫长也漫长，说短暂也短暂。干得好就是四十年，干得不好，就是五年。\n5. 或许每个人都有机会花五年时间成为技术总监，但是却只有少数人，能够成为真正合格的工程师。\n","slug":"随笔/我在外包公司做增删改查有前途么？","published":1,"updated":"2019-12-15T13:30:47.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt9p004ln4vi9n6kwi35","content":"<h1 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h1><p>这是我无意中在筛选简历时，看到一位朋友发布的求职说明中，明确指出，外包勿扰，并给出了他做出这个决定的理由：</p>\n<p>过去若干年间，他一直在中软国际从事.NET方向的软件研发，虽然工作了很多年，但是做的项目类型特别多，总感觉没什么积累，而且工作很累，经常要加班，压力很大。不仅如此，由于外包类型的项目，往往需要驻场开发，一旦在客户现场进行开发，其实都会成为封闭式开发，每天投入工作的工时往往会超过十几个小时。而且在客户现场的开发时，有时候就是低等公民，得承受来自各方的压力。</p>\n<p>前不久也刚刚看到一位来自西安软通动力的资深Java工程师，由于长时间加班后引发身体疾病，并最终猝死，还得不到工伤补偿的新闻也触动了我们的心。</p>\n<p>这边的互联网公司从业人员还可以吐槽每天996，让自己成为被公司圈养的小绵羊，更是让自己的家庭生活都受到了无穷影响；那边的外包公司从业人员们显然没有互联网公司这么多的露脸机会，哪里有时间运营自己的公众号啊，每天都被客户压榨得死死的，还得跪下来对客户说：爸爸，再爱我一次！</p>\n<p>当然，坦率而言，现在国内的IT行业现状其实压力都很大，无论是外包公司、还是互联网公司，如果是几年前大环境还好的时候，或许大家压力大点，至少不会饿肚子，现在冬天来了，不仅压力大，而且还吃不饱穿不暖，一旦遇到公司困境，还得面临被裁员的后果。</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/1.png\" alt=\"image-20191130140814321\"></li>\n</ul>\n<p>好吧，在这篇文章中，我还是不输出焦虑了，只单纯的讨论一下这个问题。</p>\n<h1 id=\"在外包公司做增删改查有前途么？\"><a href=\"#在外包公司做增删改查有前途么？\" class=\"headerlink\" title=\"在外包公司做增删改查有前途么？\"></a>在外包公司做增删改查有前途么？</h1><p>有没有感觉，这是一个通用的句式：干xxx有前途么？</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/2.png\" alt=\"image-20191130140814321\"></li>\n</ul>\n<p>例如，在百度里面输入，“干程序”，首先会自动提示的就是“干程序员有没有前景”？好吧，有没有前途我也说不准，我就单纯的探讨几个问题，什么叫有前途；在外包公司有前途么；做增删改查有前途么？</p>\n<h1 id=\"什么叫做有前途？\"><a href=\"#什么叫做有前途？\" class=\"headerlink\" title=\"什么叫做有前途？\"></a>什么叫做有前途？</h1><p>世俗的说，金钱、名誉和地位大概就是许多人在追求的前途。而在IT领域，由于无法与从事公务员和经商的其他同龄人相比，往往会用待遇和岗位来形容。例如有时候总会以为技术总监一定是值得追求的前途；或者为了更高的收入，会选择一些特定的行业。例如这几年相继爆雷的P2P行业，在这些行业中的开发者的工资往往都非常高。</p>\n<p>然而，当公司的套路被人揭穿之后，无数投资人的巨额投资化作一堆废纸，这些P2P企业公司的开发者们在这段时间从公司获得的所有收入都会被列入非法所得，必须上缴给公安机关，以便清偿债务。</p>\n<p>不仅如此，有时候还不能过度的宣传自己在这些行业的职场工作经验，不然可能会被下家认为心术不正。 </p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/3.png\" alt=\"image-20191130140814321\"></li>\n</ul>\n<blockquote>\n<p>爱因斯坦说：我坚信，世界上的财富无法促进人类发展，即使它掌握在哪些仍想达到此目标的人手中也无济于事。金钱只能滋生人们的自私自利，并使其不能自持地加以滥用。</p>\n</blockquote>\n<p>当然，当今时代终究是个世俗的世界。但追求金钱和Title所谓的看似有前途的工作，还是得建立道德和法律的基础上。</p>\n<h1 id=\"在外包公司有前途么？\"><a href=\"#在外包公司有前途么？\" class=\"headerlink\" title=\"在外包公司有前途么？\"></a>在外包公司有前途么？</h1><p>外包公司的主要盈利点，其实是软件研发过程管理或者软件项目管理能力，一套优秀的软件项目管理流程体系，往往能够实现软件开发过程中的生产力最大化，进而为企业的发展带来巨大的利润。</p>\n<p>在外包公司，主要的收入其实是来源于项目参与人员的人工费用，一般会采用“工料合同”的形式。这种合同又称为单价合同，一般会根据产品在研发过程中的实际投入或服务来计算合同总价。</p>\n<p>当然，其实许多外包公司会采用这种方式来进行工作量的评估，然后再用总价合同的形式来签订合同，毕竟“工料合同”其实浮动空间很大，容易造成甲方的成本超支严重，而使用总价合同就可以将风险转嫁给乙方，对于甲方来说自然而然就实现了利益最大化了。</p>\n<p>而总价合同的特点是应该明确设定需求、对功能的工作量评估都应该尽可能的科学，问题是，客户明白他想要什么么？大概率客户并不懂他想要什么，或者他以为他懂他想要什么，而且你以为你也懂他想要什么。于是陷入双方需求的拉锯战，软件的风险急剧提高，让苦逼的乙方程序员们成为砧板上的肉，被迫每天牺牲自己的时间，拿有限的生命投入到无穷无尽的需求大坑中。</p>\n<p>而且有时候由于行业不同，还会陷入需求陷阱中，各行如隔山，客户想要的，往往与你能提供的，存在很大的差异。例如，连微软都会被武汉上诉，要求赔偿其在智慧城市项目中造成的大几千万损失，一般般的外包公司就更不用说了。</p>\n<p>如果遇到这种情况，请勇敢的选择拒绝，或者使自己成为更专业的人。努力花更多的时间学习行业知识，然后用数据或阶段性成果让客户尽可能的无话可说吧。</p>\n<p>当然并非所有的外包公司都是这种情况，例如像SAP或者Thoughtworks，其实也可以被世俗的理解为外包公司，他们也是为客户提供外包服务，但是由于他们是行业内的领先者，能够为客户需求提供更加专业的建议，所以他们有资格找客户签署“工料合同”。</p>\n<p>例如一个SAP的服务工程师，从上飞机起就开始计算工时费用，每天动辄万元的服务费，服务工程师的工资自然而然也低不到哪里去了。我一位同事他哥哥就是从事SAP的外包服务，他说他哥哥每年只上半年班，工资超过3万一个月。。。嗯,好吧，这种外包就等同于有前途。</p>\n<p>依然有许多公司会走在签署总价合同的外包公司的道路上，毕竟企业生存是第一要务，万一哪天接到一个合适的项目，让公司能够顺利的摆脱外包公司的这块皮，进入细分市场，获得进一步的生机呢？</p>\n<p>不过大部分外包公司或许其实并没有那么好的命，而且还会由于内卷化（指优秀员工逐渐流失，而新人难以加入，最后被中庸的老员工主宰企业的命运）最终越来越丧失竞争力，并最终只能凉凉。而且缺乏核心主业的外包公司确实很难获得技能上的积累，这需要开发者能够提高自己的技术学习能力，努力使自己成为最专业的工程师。</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/4.png\" alt=\"image-20191130140814321\"></li>\n</ul>\n<h1 id=\"做增删改查有前途么？\"><a href=\"#做增删改查有前途么？\" class=\"headerlink\" title=\"做增删改查有前途么？\"></a>做增删改查有前途么？</h1><p>许多开发者都吐槽，每天的工作都是CRUD，也有许多开发者经常吐槽身边的那些开发者没前途，只会增删改查。</p>\n<p>怎么觉得这个问题为啥这么魔性呢？难道你和他们不是同一拨人么？</p>\n<p>有时候还会看到有人吐槽，说每天都在做CRUD的业务开发，感觉自己人都要玩废了。还问我怎么想。</p>\n<p>我个人认为CRUD才是公司业务的常态，只有能够把CRUD玩得非常好，公司业务才能获得更快的发展。从表面上看，CRUD工程师的主要职责就是建表、封装接口、然后让接口输出数据符合客户端需求。实际上这里面依然牵涉到许多充满技术含量的东西。</p>\n<p>例如，该如何建表呢？从海量的用户需求中，分析出与系统息息相关的核心部分，并分析出符合用户需求的核心领域，这种业务分析与设计能力是一位软件工程师非常重要的核心技能。</p>\n<p>例如，以前都是撸sql，现在都用orm了，是不是觉得很香？增删改查一样也充满了期待啊。</p>\n<p>该怎么建表，也并非想象中那么简单。例如主键是用自增序列，还是用UUID，该怎么设计索引，如何设计缓存，如何运用分表分库策略？这些看起来很简单的东西，往往并不简单。</p>\n<p>除此之外，代码的质量本身，也是一件值得深入钻研的方面，例如《代码整洁之道》和《重构改善既有代码的艺术》这两本书就专门介绍了如何写代码和如何把代码写好。这也是一件看起来简单，却并不简单的事情。</p>\n<p>除此之外，沟通技能、架构能力、风险意识，也都会在这些CRUD的开发过程中得以体现。</p>\n<p>为什么总是会认为CRUD毫无挑战呢。如果你已经成为软件开发领域的大牛，请收下我的膝盖，否则大概率是因为你已经走在了云程序员的路上，把一切问题都想象得太简单了吧。</p>\n<p>突然想起之前看的的一张段子，说火箭其实没什么技术含量，因为中国古时候早就有了。还有之前看的郭德纲的段子，他说：如果我跟一位火箭工程师讨论火箭的燃料不应该用氢氧，应该烧煤，对方正眼看了我一眼，那就是我输。</p>\n<p>嗯，云程序员们，咱们离专业开发者还有不少差距啊！</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/5.png\" alt=\"image-20191130140814321\"></li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"# 总结\"></a># 总结</h1><p>回到主题：在外包公司做增删改查有前途么？</p>\n<ol>\n<li>在外包公司也好，非外包公司也好，努力使自己成为专业的人，都会有前途。</li>\n<li>不管在哪家公司，如果你觉得不开心可以离去；但是如果留下来了，请珍惜每一段时光，上帝既会给你关门，也往往会给你开一扇窗户，只要用心去发现，你总会有所收获。</li>\n<li>其实认真干好每一件事情，都会充满前途。如果过于敏感，总觉得干这个没前途，干那个没前途，那大概你应该去选择创业。那里你可以找到属于你的好归宿。</li>\n<li>IT的职场的时光说漫长也漫长，说短暂也短暂。干得好就是四十年，干得不好，就是五年。</li>\n<li>或许每个人都有机会花五年时间成为技术总监，但是却只有少数人，能够成为真正合格的工程师。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h1><p>这是我无意中在筛选简历时，看到一位朋友发布的求职说明中，明确指出，外包勿扰，并给出了他做出这个决定的理由：</p>\n<p>过去若干年间，他一直在中软国际从事.NET方向的软件研发，虽然工作了很多年，但是做的项目类型特别多，总感觉没什么积累，而且工作很累，经常要加班，压力很大。不仅如此，由于外包类型的项目，往往需要驻场开发，一旦在客户现场进行开发，其实都会成为封闭式开发，每天投入工作的工时往往会超过十几个小时。而且在客户现场的开发时，有时候就是低等公民，得承受来自各方的压力。</p>\n<p>前不久也刚刚看到一位来自西安软通动力的资深Java工程师，由于长时间加班后引发身体疾病，并最终猝死，还得不到工伤补偿的新闻也触动了我们的心。</p>\n<p>这边的互联网公司从业人员还可以吐槽每天996，让自己成为被公司圈养的小绵羊，更是让自己的家庭生活都受到了无穷影响；那边的外包公司从业人员们显然没有互联网公司这么多的露脸机会，哪里有时间运营自己的公众号啊，每天都被客户压榨得死死的，还得跪下来对客户说：爸爸，再爱我一次！</p>\n<p>当然，坦率而言，现在国内的IT行业现状其实压力都很大，无论是外包公司、还是互联网公司，如果是几年前大环境还好的时候，或许大家压力大点，至少不会饿肚子，现在冬天来了，不仅压力大，而且还吃不饱穿不暖，一旦遇到公司困境，还得面临被裁员的后果。</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/1.png\" alt=\"image-20191130140814321\"></li>\n</ul>\n<p>好吧，在这篇文章中，我还是不输出焦虑了，只单纯的讨论一下这个问题。</p>\n<h1 id=\"在外包公司做增删改查有前途么？\"><a href=\"#在外包公司做增删改查有前途么？\" class=\"headerlink\" title=\"在外包公司做增删改查有前途么？\"></a>在外包公司做增删改查有前途么？</h1><p>有没有感觉，这是一个通用的句式：干xxx有前途么？</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/2.png\" alt=\"image-20191130140814321\"></li>\n</ul>\n<p>例如，在百度里面输入，“干程序”，首先会自动提示的就是“干程序员有没有前景”？好吧，有没有前途我也说不准，我就单纯的探讨几个问题，什么叫有前途；在外包公司有前途么；做增删改查有前途么？</p>\n<h1 id=\"什么叫做有前途？\"><a href=\"#什么叫做有前途？\" class=\"headerlink\" title=\"什么叫做有前途？\"></a>什么叫做有前途？</h1><p>世俗的说，金钱、名誉和地位大概就是许多人在追求的前途。而在IT领域，由于无法与从事公务员和经商的其他同龄人相比，往往会用待遇和岗位来形容。例如有时候总会以为技术总监一定是值得追求的前途；或者为了更高的收入，会选择一些特定的行业。例如这几年相继爆雷的P2P行业，在这些行业中的开发者的工资往往都非常高。</p>\n<p>然而，当公司的套路被人揭穿之后，无数投资人的巨额投资化作一堆废纸，这些P2P企业公司的开发者们在这段时间从公司获得的所有收入都会被列入非法所得，必须上缴给公安机关，以便清偿债务。</p>\n<p>不仅如此，有时候还不能过度的宣传自己在这些行业的职场工作经验，不然可能会被下家认为心术不正。 </p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/3.png\" alt=\"image-20191130140814321\"></li>\n</ul>\n<blockquote>\n<p>爱因斯坦说：我坚信，世界上的财富无法促进人类发展，即使它掌握在哪些仍想达到此目标的人手中也无济于事。金钱只能滋生人们的自私自利，并使其不能自持地加以滥用。</p>\n</blockquote>\n<p>当然，当今时代终究是个世俗的世界。但追求金钱和Title所谓的看似有前途的工作，还是得建立道德和法律的基础上。</p>\n<h1 id=\"在外包公司有前途么？\"><a href=\"#在外包公司有前途么？\" class=\"headerlink\" title=\"在外包公司有前途么？\"></a>在外包公司有前途么？</h1><p>外包公司的主要盈利点，其实是软件研发过程管理或者软件项目管理能力，一套优秀的软件项目管理流程体系，往往能够实现软件开发过程中的生产力最大化，进而为企业的发展带来巨大的利润。</p>\n<p>在外包公司，主要的收入其实是来源于项目参与人员的人工费用，一般会采用“工料合同”的形式。这种合同又称为单价合同，一般会根据产品在研发过程中的实际投入或服务来计算合同总价。</p>\n<p>当然，其实许多外包公司会采用这种方式来进行工作量的评估，然后再用总价合同的形式来签订合同，毕竟“工料合同”其实浮动空间很大，容易造成甲方的成本超支严重，而使用总价合同就可以将风险转嫁给乙方，对于甲方来说自然而然就实现了利益最大化了。</p>\n<p>而总价合同的特点是应该明确设定需求、对功能的工作量评估都应该尽可能的科学，问题是，客户明白他想要什么么？大概率客户并不懂他想要什么，或者他以为他懂他想要什么，而且你以为你也懂他想要什么。于是陷入双方需求的拉锯战，软件的风险急剧提高，让苦逼的乙方程序员们成为砧板上的肉，被迫每天牺牲自己的时间，拿有限的生命投入到无穷无尽的需求大坑中。</p>\n<p>而且有时候由于行业不同，还会陷入需求陷阱中，各行如隔山，客户想要的，往往与你能提供的，存在很大的差异。例如，连微软都会被武汉上诉，要求赔偿其在智慧城市项目中造成的大几千万损失，一般般的外包公司就更不用说了。</p>\n<p>如果遇到这种情况，请勇敢的选择拒绝，或者使自己成为更专业的人。努力花更多的时间学习行业知识，然后用数据或阶段性成果让客户尽可能的无话可说吧。</p>\n<p>当然并非所有的外包公司都是这种情况，例如像SAP或者Thoughtworks，其实也可以被世俗的理解为外包公司，他们也是为客户提供外包服务，但是由于他们是行业内的领先者，能够为客户需求提供更加专业的建议，所以他们有资格找客户签署“工料合同”。</p>\n<p>例如一个SAP的服务工程师，从上飞机起就开始计算工时费用，每天动辄万元的服务费，服务工程师的工资自然而然也低不到哪里去了。我一位同事他哥哥就是从事SAP的外包服务，他说他哥哥每年只上半年班，工资超过3万一个月。。。嗯,好吧，这种外包就等同于有前途。</p>\n<p>依然有许多公司会走在签署总价合同的外包公司的道路上，毕竟企业生存是第一要务，万一哪天接到一个合适的项目，让公司能够顺利的摆脱外包公司的这块皮，进入细分市场，获得进一步的生机呢？</p>\n<p>不过大部分外包公司或许其实并没有那么好的命，而且还会由于内卷化（指优秀员工逐渐流失，而新人难以加入，最后被中庸的老员工主宰企业的命运）最终越来越丧失竞争力，并最终只能凉凉。而且缺乏核心主业的外包公司确实很难获得技能上的积累，这需要开发者能够提高自己的技术学习能力，努力使自己成为最专业的工程师。</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/4.png\" alt=\"image-20191130140814321\"></li>\n</ul>\n<h1 id=\"做增删改查有前途么？\"><a href=\"#做增删改查有前途么？\" class=\"headerlink\" title=\"做增删改查有前途么？\"></a>做增删改查有前途么？</h1><p>许多开发者都吐槽，每天的工作都是CRUD，也有许多开发者经常吐槽身边的那些开发者没前途，只会增删改查。</p>\n<p>怎么觉得这个问题为啥这么魔性呢？难道你和他们不是同一拨人么？</p>\n<p>有时候还会看到有人吐槽，说每天都在做CRUD的业务开发，感觉自己人都要玩废了。还问我怎么想。</p>\n<p>我个人认为CRUD才是公司业务的常态，只有能够把CRUD玩得非常好，公司业务才能获得更快的发展。从表面上看，CRUD工程师的主要职责就是建表、封装接口、然后让接口输出数据符合客户端需求。实际上这里面依然牵涉到许多充满技术含量的东西。</p>\n<p>例如，该如何建表呢？从海量的用户需求中，分析出与系统息息相关的核心部分，并分析出符合用户需求的核心领域，这种业务分析与设计能力是一位软件工程师非常重要的核心技能。</p>\n<p>例如，以前都是撸sql，现在都用orm了，是不是觉得很香？增删改查一样也充满了期待啊。</p>\n<p>该怎么建表，也并非想象中那么简单。例如主键是用自增序列，还是用UUID，该怎么设计索引，如何设计缓存，如何运用分表分库策略？这些看起来很简单的东西，往往并不简单。</p>\n<p>除此之外，代码的质量本身，也是一件值得深入钻研的方面，例如《代码整洁之道》和《重构改善既有代码的艺术》这两本书就专门介绍了如何写代码和如何把代码写好。这也是一件看起来简单，却并不简单的事情。</p>\n<p>除此之外，沟通技能、架构能力、风险意识，也都会在这些CRUD的开发过程中得以体现。</p>\n<p>为什么总是会认为CRUD毫无挑战呢。如果你已经成为软件开发领域的大牛，请收下我的膝盖，否则大概率是因为你已经走在了云程序员的路上，把一切问题都想象得太简单了吧。</p>\n<p>突然想起之前看的的一张段子，说火箭其实没什么技术含量，因为中国古时候早就有了。还有之前看的郭德纲的段子，他说：如果我跟一位火箭工程师讨论火箭的燃料不应该用氢氧，应该烧煤，对方正眼看了我一眼，那就是我输。</p>\n<p>嗯，云程序员们，咱们离专业开发者还有不少差距啊！</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/5.png\" alt=\"image-20191130140814321\"></li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"# 总结\"></a># 总结</h1><p>回到主题：在外包公司做增删改查有前途么？</p>\n<ol>\n<li>在外包公司也好，非外包公司也好，努力使自己成为专业的人，都会有前途。</li>\n<li>不管在哪家公司，如果你觉得不开心可以离去；但是如果留下来了，请珍惜每一段时光，上帝既会给你关门，也往往会给你开一扇窗户，只要用心去发现，你总会有所收获。</li>\n<li>其实认真干好每一件事情，都会充满前途。如果过于敏感，总觉得干这个没前途，干那个没前途，那大概你应该去选择创业。那里你可以找到属于你的好归宿。</li>\n<li>IT的职场的时光说漫长也漫长，说短暂也短暂。干得好就是四十年，干得不好，就是五年。</li>\n<li>或许每个人都有机会花五年时间成为技术总监，但是却只有少数人，能够成为真正合格的工程师。</li>\n</ol>\n"},{"title":"独立开发者，程序员们的美好梦想？","date":"2019-10-09T08:28:00.000Z","author":"邹溪源","_content":"\n\n在IT行业或任何行业，总有一群特别优秀的人，他们游走在公司体系之外，不靠工资为生，靠自己的能力从雇主手中承接项目来生存，这种“自由职业者”，在开发者体系中，被称为“独立开发者”。\n# 一\n不久前，某路人甲找我内推。\n甲：溪源，之前看到你分享过一些求职信息，恰好我最近私活没那么忙，你可以把我的简历代投一下么？\n溪源：我这边主要是帮别人发了点招聘，我没办法帮你代投的。不过你可以告诉我你想找怎样的工作，我帮你留意一下。\n甲：我靠私活每个月有万把块钱收入，就想找一个没什么压力，做一些简单增删改查的工作。我觉得我做企业信息系统挺厉害的，你可以帮我推一些这样的工作。\n甲：待遇要求嘛，应该像我这样八年经验的，一万多还是拿的到的。\n溪源：互联网公司有兴趣么？\n甲：没什么兴趣，经常要加班，压力比较大。我觉得可以找找那些外包公司之类的，做企业内部系统的就算了，业务流程太复杂，纠缠不清。\n溪源：你会什么技能呢？\n甲：.net三层架构和ado.net我玩得很溜了，ef了解一点点，其他技术就不太会了，项目不需要。\n然后我找了一位猎头小仙女，介绍了他说的情况。\n小仙女回答说，我也想找这样月薪过万，没有什么压力的工作。而且他的技术栈会不会有点太。。我担心我的雇主看不上。\n然后没有然后了。  \n……  \n# 二\n在七月左右，我有幸组织了一次读书会，后来拉了一个读书群，里面有一位开发者同样也是独立开发者，目前主要使用go语言进行开发，对vue等技术尤其擅长，关键是这些技术都是他自己这两年学会的。他不仅学得快，能够很快的获得收益，还经常去朋友的公司，以讲师的身份给他们公司的同事做培训。每年的收入挺可观的，基本上都两万+每月。他说自从成为独立开发者以后，比以前更拼了，压力更大了。\n如松原来在上海从事金融科技产业链的软件研发，前几年回到长沙，找了一圈工作，都找不到特别满意的工作，毕竟国内只有北上广深杭才有金融科技应用场景的公司，于是跌跌撞撞之下，由于经常有人找他开发独立应用或企业软件，这也是一个不错的选择，于是，他也成为了独立开发者。经历了一年多，也拉了三五条枪，撸了一个小团队，业内口碑也颇为不错，勉强能维持住团队的运营。问及他创业的心得，他说，以前上班是为老板赚钱，现在是为自己赚钱，虽然不见得能发大财，但能更加灵活的选择自己想做的方向，能够获得长期积累。\n当然，也有做出不同选择的，例如【ASP.NET MVC 企业级实战】的作者邹琼俊老师曾经说过，出版了第一本书之后，就经常能接到各种不同的项目，但是他都拒绝了，主要还是这些项目都看起来简单，但要花很多时间，如果全职还能勉强做下去，但是如果业余时间来做，看起来能获得收入，但是就没时间学习了，所以他宁可花时间多看看书，写写书。于是他又出版了一本新书【H5+跨平台移动应用实战开发】。（他把业余时间全花在看书写书上了，哪里还有时间做私活）\n历史是如此的相似，微信公众号【吃草的罗汉】作者王晔倞老师曾经在他的公众号中分享过十多年前他做私活的经历，靠给别人做私活，他曾经获得了不亚于职场的收入，零几年初在上海买车买房，这份收入助力颇多，而且这份工作激励他钻研技能，并为他的职业发展带来了许多帮助。后来他停下了这个过程，专注于职场主业，并获得了今天的成绩。\n# 三\n似乎在每个程序员的心中，都有一颗成为独立开发者的美好梦想，在这个梦想里面，可以脱离公司规则的束缚，选择自己想过的生活，想学习时，随时随地拿起书，靠着窗户边就可以看书，偶尔接一些私活，辛苦一下很快就能获得收入，岂不美哉。也确实有许多人靠这个能足不出户就赚到不亚于职场的收入，于是又激励了他们把这份收入当作长期收入，最终或许可以借此脱离企业管理的桎梏，获得心灵上的自由。\n我们来总结一下独立开发者的优点：\n1、更加灵活自由的安排自己的时间，能够实现收入的最大化。在职场中，往往需要牺牲自己的时间来加班完成领导的指标，并可能看起来导致利益受损【毕竟上班会影响你赚钱】，而独立开发者则可以根据自己的时间选择适合自己的任务，并有时候能够更好的谈好工钱和工期，能够小赚一笔。\n2、有机会塑造自己的个人品牌价值。市场竞争如此激烈，能够接到稳定的私活，往往需要更好的口碑，这其实就是在打造自己的个人品牌。\n3、按需提高和学习，在技能的广度上有更好的优势。也许你能适当的选择一些看起来没那么难的挑战，来学习其他在职场上学不到的技能。\n4、有可能打破圈子，获得不同的人脉关系。脱离职场人脉圈子的单一化，你有可能认识更多的朋友。\n当然，也存在许多缺点：\n1、最合理有效的工作时间依然是每天白天的八小时工作制，但是由于为了所谓自由可能会习惯于晚上完成工作，甚至有可能习惯于昼伏夜出，让生物钟紊乱，进而导致身体的长期损害。\n2、长期脱离职场发展，看似不被束缚，但是职场的管理制度，其实是一种规则，虽然企业不同，规则不一定相同，但是其核心目标都是为了实现对企业参与者更好的管理，更好的实现企业劳动生产力的提升，而脱离了职场，再回归职场时，会主观上对规则形成抗拒心理，进而难以适应。\n3、 虽然在职场容易造成人脉结构的单一化，但是脱离职场却不利于自身领导力和管理能力的积累，这些都是非常有价值的软实力。事实上在当今时代，单兵作战已经越来越困难了，独立开发者则往往不太可能培养管理能力。\n4、技术上可能会更趋于保守闭塞。虽然可以看似根据业务需求灵活的调整自己的技能发展方向，但是往往雇主只会选择对自己利益最大化的承包商，不大可能给资源或时间让乙方来学习，这客观上也容易让开发者陷入内卷化的境地。\n# 四\n仿佛有两种截然不同的情况，一种是自律能力和学习能力特别强的开发者，从他们选择成为独立开发者开始，他们的职业生涯才算真正的开始，在这个以自我价值实现为最大价值的新平台，他们自我刷新，像创业者一般走在了新职场的康庄大道上；另外一些人则恰好相反，也许短期内有项目，并能让他们短期收益颇多，但是很容易就内卷化了，失去了核心竞争力，成为廉价劳动力的输送者，甚至还会导致他们很难再回到职场。\n无论如何，独立开发者其实是一个特别需要自控能力的就业方向，如果一旦过于放纵，反而更容易被边缘化。\n当然，哪怕你在职场又如何？也同样需要提高自控能力。等着别人来给自己机会，等别人来让你实现价值的观念？往往都是有机会时，缺乏能力，有能力时，机会又会离你远去。\n不等不靠，才是王道。\n*这不是在输出焦虑，只是在探讨职场发展。欢迎拍砖。*\n","source":"_posts/随笔/独立开发者，程序员的美好梦想？.md","raw":"---\ntitle: 独立开发者，程序员们的美好梦想？\ndate: 2019-10-09 16:28\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n\n\n在IT行业或任何行业，总有一群特别优秀的人，他们游走在公司体系之外，不靠工资为生，靠自己的能力从雇主手中承接项目来生存，这种“自由职业者”，在开发者体系中，被称为“独立开发者”。\n# 一\n不久前，某路人甲找我内推。\n甲：溪源，之前看到你分享过一些求职信息，恰好我最近私活没那么忙，你可以把我的简历代投一下么？\n溪源：我这边主要是帮别人发了点招聘，我没办法帮你代投的。不过你可以告诉我你想找怎样的工作，我帮你留意一下。\n甲：我靠私活每个月有万把块钱收入，就想找一个没什么压力，做一些简单增删改查的工作。我觉得我做企业信息系统挺厉害的，你可以帮我推一些这样的工作。\n甲：待遇要求嘛，应该像我这样八年经验的，一万多还是拿的到的。\n溪源：互联网公司有兴趣么？\n甲：没什么兴趣，经常要加班，压力比较大。我觉得可以找找那些外包公司之类的，做企业内部系统的就算了，业务流程太复杂，纠缠不清。\n溪源：你会什么技能呢？\n甲：.net三层架构和ado.net我玩得很溜了，ef了解一点点，其他技术就不太会了，项目不需要。\n然后我找了一位猎头小仙女，介绍了他说的情况。\n小仙女回答说，我也想找这样月薪过万，没有什么压力的工作。而且他的技术栈会不会有点太。。我担心我的雇主看不上。\n然后没有然后了。  \n……  \n# 二\n在七月左右，我有幸组织了一次读书会，后来拉了一个读书群，里面有一位开发者同样也是独立开发者，目前主要使用go语言进行开发，对vue等技术尤其擅长，关键是这些技术都是他自己这两年学会的。他不仅学得快，能够很快的获得收益，还经常去朋友的公司，以讲师的身份给他们公司的同事做培训。每年的收入挺可观的，基本上都两万+每月。他说自从成为独立开发者以后，比以前更拼了，压力更大了。\n如松原来在上海从事金融科技产业链的软件研发，前几年回到长沙，找了一圈工作，都找不到特别满意的工作，毕竟国内只有北上广深杭才有金融科技应用场景的公司，于是跌跌撞撞之下，由于经常有人找他开发独立应用或企业软件，这也是一个不错的选择，于是，他也成为了独立开发者。经历了一年多，也拉了三五条枪，撸了一个小团队，业内口碑也颇为不错，勉强能维持住团队的运营。问及他创业的心得，他说，以前上班是为老板赚钱，现在是为自己赚钱，虽然不见得能发大财，但能更加灵活的选择自己想做的方向，能够获得长期积累。\n当然，也有做出不同选择的，例如【ASP.NET MVC 企业级实战】的作者邹琼俊老师曾经说过，出版了第一本书之后，就经常能接到各种不同的项目，但是他都拒绝了，主要还是这些项目都看起来简单，但要花很多时间，如果全职还能勉强做下去，但是如果业余时间来做，看起来能获得收入，但是就没时间学习了，所以他宁可花时间多看看书，写写书。于是他又出版了一本新书【H5+跨平台移动应用实战开发】。（他把业余时间全花在看书写书上了，哪里还有时间做私活）\n历史是如此的相似，微信公众号【吃草的罗汉】作者王晔倞老师曾经在他的公众号中分享过十多年前他做私活的经历，靠给别人做私活，他曾经获得了不亚于职场的收入，零几年初在上海买车买房，这份收入助力颇多，而且这份工作激励他钻研技能，并为他的职业发展带来了许多帮助。后来他停下了这个过程，专注于职场主业，并获得了今天的成绩。\n# 三\n似乎在每个程序员的心中，都有一颗成为独立开发者的美好梦想，在这个梦想里面，可以脱离公司规则的束缚，选择自己想过的生活，想学习时，随时随地拿起书，靠着窗户边就可以看书，偶尔接一些私活，辛苦一下很快就能获得收入，岂不美哉。也确实有许多人靠这个能足不出户就赚到不亚于职场的收入，于是又激励了他们把这份收入当作长期收入，最终或许可以借此脱离企业管理的桎梏，获得心灵上的自由。\n我们来总结一下独立开发者的优点：\n1、更加灵活自由的安排自己的时间，能够实现收入的最大化。在职场中，往往需要牺牲自己的时间来加班完成领导的指标，并可能看起来导致利益受损【毕竟上班会影响你赚钱】，而独立开发者则可以根据自己的时间选择适合自己的任务，并有时候能够更好的谈好工钱和工期，能够小赚一笔。\n2、有机会塑造自己的个人品牌价值。市场竞争如此激烈，能够接到稳定的私活，往往需要更好的口碑，这其实就是在打造自己的个人品牌。\n3、按需提高和学习，在技能的广度上有更好的优势。也许你能适当的选择一些看起来没那么难的挑战，来学习其他在职场上学不到的技能。\n4、有可能打破圈子，获得不同的人脉关系。脱离职场人脉圈子的单一化，你有可能认识更多的朋友。\n当然，也存在许多缺点：\n1、最合理有效的工作时间依然是每天白天的八小时工作制，但是由于为了所谓自由可能会习惯于晚上完成工作，甚至有可能习惯于昼伏夜出，让生物钟紊乱，进而导致身体的长期损害。\n2、长期脱离职场发展，看似不被束缚，但是职场的管理制度，其实是一种规则，虽然企业不同，规则不一定相同，但是其核心目标都是为了实现对企业参与者更好的管理，更好的实现企业劳动生产力的提升，而脱离了职场，再回归职场时，会主观上对规则形成抗拒心理，进而难以适应。\n3、 虽然在职场容易造成人脉结构的单一化，但是脱离职场却不利于自身领导力和管理能力的积累，这些都是非常有价值的软实力。事实上在当今时代，单兵作战已经越来越困难了，独立开发者则往往不太可能培养管理能力。\n4、技术上可能会更趋于保守闭塞。虽然可以看似根据业务需求灵活的调整自己的技能发展方向，但是往往雇主只会选择对自己利益最大化的承包商，不大可能给资源或时间让乙方来学习，这客观上也容易让开发者陷入内卷化的境地。\n# 四\n仿佛有两种截然不同的情况，一种是自律能力和学习能力特别强的开发者，从他们选择成为独立开发者开始，他们的职业生涯才算真正的开始，在这个以自我价值实现为最大价值的新平台，他们自我刷新，像创业者一般走在了新职场的康庄大道上；另外一些人则恰好相反，也许短期内有项目，并能让他们短期收益颇多，但是很容易就内卷化了，失去了核心竞争力，成为廉价劳动力的输送者，甚至还会导致他们很难再回到职场。\n无论如何，独立开发者其实是一个特别需要自控能力的就业方向，如果一旦过于放纵，反而更容易被边缘化。\n当然，哪怕你在职场又如何？也同样需要提高自控能力。等着别人来给自己机会，等别人来让你实现价值的观念？往往都是有机会时，缺乏能力，有能力时，机会又会离你远去。\n不等不靠，才是王道。\n*这不是在输出焦虑，只是在探讨职场发展。欢迎拍砖。*\n","slug":"随笔/独立开发者，程序员的美好梦想？","published":1,"updated":"2019-10-09T10:46:59.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt9q004on4vi74xqmfyi","content":"<p>在IT行业或任何行业，总有一群特别优秀的人，他们游走在公司体系之外，不靠工资为生，靠自己的能力从雇主手中承接项目来生存，这种“自由职业者”，在开发者体系中，被称为“独立开发者”。</p>\n<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>不久前，某路人甲找我内推。<br>甲：溪源，之前看到你分享过一些求职信息，恰好我最近私活没那么忙，你可以把我的简历代投一下么？<br>溪源：我这边主要是帮别人发了点招聘，我没办法帮你代投的。不过你可以告诉我你想找怎样的工作，我帮你留意一下。<br>甲：我靠私活每个月有万把块钱收入，就想找一个没什么压力，做一些简单增删改查的工作。我觉得我做企业信息系统挺厉害的，你可以帮我推一些这样的工作。<br>甲：待遇要求嘛，应该像我这样八年经验的，一万多还是拿的到的。<br>溪源：互联网公司有兴趣么？<br>甲：没什么兴趣，经常要加班，压力比较大。我觉得可以找找那些外包公司之类的，做企业内部系统的就算了，业务流程太复杂，纠缠不清。<br>溪源：你会什么技能呢？<br>甲：.net三层架构和ado.net我玩得很溜了，ef了解一点点，其他技术就不太会了，项目不需要。<br>然后我找了一位猎头小仙女，介绍了他说的情况。<br>小仙女回答说，我也想找这样月薪过万，没有什么压力的工作。而且他的技术栈会不会有点太。。我担心我的雇主看不上。<br>然后没有然后了。<br>……  </p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>在七月左右，我有幸组织了一次读书会，后来拉了一个读书群，里面有一位开发者同样也是独立开发者，目前主要使用go语言进行开发，对vue等技术尤其擅长，关键是这些技术都是他自己这两年学会的。他不仅学得快，能够很快的获得收益，还经常去朋友的公司，以讲师的身份给他们公司的同事做培训。每年的收入挺可观的，基本上都两万+每月。他说自从成为独立开发者以后，比以前更拼了，压力更大了。<br>如松原来在上海从事金融科技产业链的软件研发，前几年回到长沙，找了一圈工作，都找不到特别满意的工作，毕竟国内只有北上广深杭才有金融科技应用场景的公司，于是跌跌撞撞之下，由于经常有人找他开发独立应用或企业软件，这也是一个不错的选择，于是，他也成为了独立开发者。经历了一年多，也拉了三五条枪，撸了一个小团队，业内口碑也颇为不错，勉强能维持住团队的运营。问及他创业的心得，他说，以前上班是为老板赚钱，现在是为自己赚钱，虽然不见得能发大财，但能更加灵活的选择自己想做的方向，能够获得长期积累。<br>当然，也有做出不同选择的，例如【ASP.NET MVC 企业级实战】的作者邹琼俊老师曾经说过，出版了第一本书之后，就经常能接到各种不同的项目，但是他都拒绝了，主要还是这些项目都看起来简单，但要花很多时间，如果全职还能勉强做下去，但是如果业余时间来做，看起来能获得收入，但是就没时间学习了，所以他宁可花时间多看看书，写写书。于是他又出版了一本新书【H5+跨平台移动应用实战开发】。（他把业余时间全花在看书写书上了，哪里还有时间做私活）<br>历史是如此的相似，微信公众号【吃草的罗汉】作者王晔倞老师曾经在他的公众号中分享过十多年前他做私活的经历，靠给别人做私活，他曾经获得了不亚于职场的收入，零几年初在上海买车买房，这份收入助力颇多，而且这份工作激励他钻研技能，并为他的职业发展带来了许多帮助。后来他停下了这个过程，专注于职场主业，并获得了今天的成绩。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>似乎在每个程序员的心中，都有一颗成为独立开发者的美好梦想，在这个梦想里面，可以脱离公司规则的束缚，选择自己想过的生活，想学习时，随时随地拿起书，靠着窗户边就可以看书，偶尔接一些私活，辛苦一下很快就能获得收入，岂不美哉。也确实有许多人靠这个能足不出户就赚到不亚于职场的收入，于是又激励了他们把这份收入当作长期收入，最终或许可以借此脱离企业管理的桎梏，获得心灵上的自由。<br>我们来总结一下独立开发者的优点：<br>1、更加灵活自由的安排自己的时间，能够实现收入的最大化。在职场中，往往需要牺牲自己的时间来加班完成领导的指标，并可能看起来导致利益受损【毕竟上班会影响你赚钱】，而独立开发者则可以根据自己的时间选择适合自己的任务，并有时候能够更好的谈好工钱和工期，能够小赚一笔。<br>2、有机会塑造自己的个人品牌价值。市场竞争如此激烈，能够接到稳定的私活，往往需要更好的口碑，这其实就是在打造自己的个人品牌。<br>3、按需提高和学习，在技能的广度上有更好的优势。也许你能适当的选择一些看起来没那么难的挑战，来学习其他在职场上学不到的技能。<br>4、有可能打破圈子，获得不同的人脉关系。脱离职场人脉圈子的单一化，你有可能认识更多的朋友。<br>当然，也存在许多缺点：<br>1、最合理有效的工作时间依然是每天白天的八小时工作制，但是由于为了所谓自由可能会习惯于晚上完成工作，甚至有可能习惯于昼伏夜出，让生物钟紊乱，进而导致身体的长期损害。<br>2、长期脱离职场发展，看似不被束缚，但是职场的管理制度，其实是一种规则，虽然企业不同，规则不一定相同，但是其核心目标都是为了实现对企业参与者更好的管理，更好的实现企业劳动生产力的提升，而脱离了职场，再回归职场时，会主观上对规则形成抗拒心理，进而难以适应。<br>3、 虽然在职场容易造成人脉结构的单一化，但是脱离职场却不利于自身领导力和管理能力的积累，这些都是非常有价值的软实力。事实上在当今时代，单兵作战已经越来越困难了，独立开发者则往往不太可能培养管理能力。<br>4、技术上可能会更趋于保守闭塞。虽然可以看似根据业务需求灵活的调整自己的技能发展方向，但是往往雇主只会选择对自己利益最大化的承包商，不大可能给资源或时间让乙方来学习，这客观上也容易让开发者陷入内卷化的境地。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>仿佛有两种截然不同的情况，一种是自律能力和学习能力特别强的开发者，从他们选择成为独立开发者开始，他们的职业生涯才算真正的开始，在这个以自我价值实现为最大价值的新平台，他们自我刷新，像创业者一般走在了新职场的康庄大道上；另外一些人则恰好相反，也许短期内有项目，并能让他们短期收益颇多，但是很容易就内卷化了，失去了核心竞争力，成为廉价劳动力的输送者，甚至还会导致他们很难再回到职场。<br>无论如何，独立开发者其实是一个特别需要自控能力的就业方向，如果一旦过于放纵，反而更容易被边缘化。<br>当然，哪怕你在职场又如何？也同样需要提高自控能力。等着别人来给自己机会，等别人来让你实现价值的观念？往往都是有机会时，缺乏能力，有能力时，机会又会离你远去。<br>不等不靠，才是王道。<br><em>这不是在输出焦虑，只是在探讨职场发展。欢迎拍砖。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在IT行业或任何行业，总有一群特别优秀的人，他们游走在公司体系之外，不靠工资为生，靠自己的能力从雇主手中承接项目来生存，这种“自由职业者”，在开发者体系中，被称为“独立开发者”。</p>\n<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>不久前，某路人甲找我内推。<br>甲：溪源，之前看到你分享过一些求职信息，恰好我最近私活没那么忙，你可以把我的简历代投一下么？<br>溪源：我这边主要是帮别人发了点招聘，我没办法帮你代投的。不过你可以告诉我你想找怎样的工作，我帮你留意一下。<br>甲：我靠私活每个月有万把块钱收入，就想找一个没什么压力，做一些简单增删改查的工作。我觉得我做企业信息系统挺厉害的，你可以帮我推一些这样的工作。<br>甲：待遇要求嘛，应该像我这样八年经验的，一万多还是拿的到的。<br>溪源：互联网公司有兴趣么？<br>甲：没什么兴趣，经常要加班，压力比较大。我觉得可以找找那些外包公司之类的，做企业内部系统的就算了，业务流程太复杂，纠缠不清。<br>溪源：你会什么技能呢？<br>甲：.net三层架构和ado.net我玩得很溜了，ef了解一点点，其他技术就不太会了，项目不需要。<br>然后我找了一位猎头小仙女，介绍了他说的情况。<br>小仙女回答说，我也想找这样月薪过万，没有什么压力的工作。而且他的技术栈会不会有点太。。我担心我的雇主看不上。<br>然后没有然后了。<br>……  </p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>在七月左右，我有幸组织了一次读书会，后来拉了一个读书群，里面有一位开发者同样也是独立开发者，目前主要使用go语言进行开发，对vue等技术尤其擅长，关键是这些技术都是他自己这两年学会的。他不仅学得快，能够很快的获得收益，还经常去朋友的公司，以讲师的身份给他们公司的同事做培训。每年的收入挺可观的，基本上都两万+每月。他说自从成为独立开发者以后，比以前更拼了，压力更大了。<br>如松原来在上海从事金融科技产业链的软件研发，前几年回到长沙，找了一圈工作，都找不到特别满意的工作，毕竟国内只有北上广深杭才有金融科技应用场景的公司，于是跌跌撞撞之下，由于经常有人找他开发独立应用或企业软件，这也是一个不错的选择，于是，他也成为了独立开发者。经历了一年多，也拉了三五条枪，撸了一个小团队，业内口碑也颇为不错，勉强能维持住团队的运营。问及他创业的心得，他说，以前上班是为老板赚钱，现在是为自己赚钱，虽然不见得能发大财，但能更加灵活的选择自己想做的方向，能够获得长期积累。<br>当然，也有做出不同选择的，例如【ASP.NET MVC 企业级实战】的作者邹琼俊老师曾经说过，出版了第一本书之后，就经常能接到各种不同的项目，但是他都拒绝了，主要还是这些项目都看起来简单，但要花很多时间，如果全职还能勉强做下去，但是如果业余时间来做，看起来能获得收入，但是就没时间学习了，所以他宁可花时间多看看书，写写书。于是他又出版了一本新书【H5+跨平台移动应用实战开发】。（他把业余时间全花在看书写书上了，哪里还有时间做私活）<br>历史是如此的相似，微信公众号【吃草的罗汉】作者王晔倞老师曾经在他的公众号中分享过十多年前他做私活的经历，靠给别人做私活，他曾经获得了不亚于职场的收入，零几年初在上海买车买房，这份收入助力颇多，而且这份工作激励他钻研技能，并为他的职业发展带来了许多帮助。后来他停下了这个过程，专注于职场主业，并获得了今天的成绩。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>似乎在每个程序员的心中，都有一颗成为独立开发者的美好梦想，在这个梦想里面，可以脱离公司规则的束缚，选择自己想过的生活，想学习时，随时随地拿起书，靠着窗户边就可以看书，偶尔接一些私活，辛苦一下很快就能获得收入，岂不美哉。也确实有许多人靠这个能足不出户就赚到不亚于职场的收入，于是又激励了他们把这份收入当作长期收入，最终或许可以借此脱离企业管理的桎梏，获得心灵上的自由。<br>我们来总结一下独立开发者的优点：<br>1、更加灵活自由的安排自己的时间，能够实现收入的最大化。在职场中，往往需要牺牲自己的时间来加班完成领导的指标，并可能看起来导致利益受损【毕竟上班会影响你赚钱】，而独立开发者则可以根据自己的时间选择适合自己的任务，并有时候能够更好的谈好工钱和工期，能够小赚一笔。<br>2、有机会塑造自己的个人品牌价值。市场竞争如此激烈，能够接到稳定的私活，往往需要更好的口碑，这其实就是在打造自己的个人品牌。<br>3、按需提高和学习，在技能的广度上有更好的优势。也许你能适当的选择一些看起来没那么难的挑战，来学习其他在职场上学不到的技能。<br>4、有可能打破圈子，获得不同的人脉关系。脱离职场人脉圈子的单一化，你有可能认识更多的朋友。<br>当然，也存在许多缺点：<br>1、最合理有效的工作时间依然是每天白天的八小时工作制，但是由于为了所谓自由可能会习惯于晚上完成工作，甚至有可能习惯于昼伏夜出，让生物钟紊乱，进而导致身体的长期损害。<br>2、长期脱离职场发展，看似不被束缚，但是职场的管理制度，其实是一种规则，虽然企业不同，规则不一定相同，但是其核心目标都是为了实现对企业参与者更好的管理，更好的实现企业劳动生产力的提升，而脱离了职场，再回归职场时，会主观上对规则形成抗拒心理，进而难以适应。<br>3、 虽然在职场容易造成人脉结构的单一化，但是脱离职场却不利于自身领导力和管理能力的积累，这些都是非常有价值的软实力。事实上在当今时代，单兵作战已经越来越困难了，独立开发者则往往不太可能培养管理能力。<br>4、技术上可能会更趋于保守闭塞。虽然可以看似根据业务需求灵活的调整自己的技能发展方向，但是往往雇主只会选择对自己利益最大化的承包商，不大可能给资源或时间让乙方来学习，这客观上也容易让开发者陷入内卷化的境地。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>仿佛有两种截然不同的情况，一种是自律能力和学习能力特别强的开发者，从他们选择成为独立开发者开始，他们的职业生涯才算真正的开始，在这个以自我价值实现为最大价值的新平台，他们自我刷新，像创业者一般走在了新职场的康庄大道上；另外一些人则恰好相反，也许短期内有项目，并能让他们短期收益颇多，但是很容易就内卷化了，失去了核心竞争力，成为廉价劳动力的输送者，甚至还会导致他们很难再回到职场。<br>无论如何，独立开发者其实是一个特别需要自控能力的就业方向，如果一旦过于放纵，反而更容易被边缘化。<br>当然，哪怕你在职场又如何？也同样需要提高自控能力。等着别人来给自己机会，等别人来让你实现价值的观念？往往都是有机会时，缺乏能力，有能力时，机会又会离你远去。<br>不等不靠，才是王道。<br><em>这不是在输出焦虑，只是在探讨职场发展。欢迎拍砖。</em></p>\n"},{"title":"如何看待程序媛的未来职业规划","date":"2020-02-16T08:21:00.000Z","author":"邹溪源","_content":"```\n我今年三十岁，我很迷茫，不知道未来该选择什么发展方向。\n```\n这是我无意中在社区微信群中看到的一位年轻的开发者说的话，之前他也经常会在技术群中抛出一些有深度有内容的问题，并能积极乐观的进行问题思考和探寻技术解决方案，有时候可能会错误的以为他这样一位热爱学习的开发者，在公司也一定是技术的引领者，对自己的职场规划有着清楚的认识。\n所以他抛出这样的问题着实有点意外，不过细想之后，或许也属实正常是。对于30岁左右的开发者来说，从20出头的毛头小伙，逐渐成长为家庭和公司的顶梁柱，如果一直从事技术领域，大概很容易就到了瓶颈期，如下图，一个人的学习能力增长曲线，大概三年或五年左右，增长速度就会逐渐放缓。\n![图片](https://images.smcdn.cn/atfF82TaJ80ZFsKv/IMG_0222.PNG!thumbnail)\n（手画的） \n到了这个阶段会非常痛苦，如果身处一家优秀的公司还好，有一套完整的体系保证你持续成长，否则就得陷入了吃老本的时期，或许将一直这么平庸的下去，直到被迫退出行业。\n而那些不甘如此的优秀者，都渴望去改变现状，他们们往往承受着无比巨大的压力，尤其是互联网技术飞速发展、各种新技术新方法席卷而来，究竟该如何选择技术的发展方向和个人的职场规划，这个问题自然而然就出现在他们面前。\n以下是互联网开发者的“人才三角”结构，由专业技能、行业知识和软实力组成。每一个圆环均代表一个知识边界。\n![图片](https://uploader.shimo.im/f/sVmne1ru5W8I2EPH.png!thumbnail)\n1. 专业技能\n\n专业技能是开发者赖以生存的宝贵技能，而其中开发语言是最重要的一个方面。近年来飞速发展的互联网业，似乎对.NET开发者带来的冲击相当巨大，在许多城市，甚至出现了Java与.NET的招聘信息比例10比1的惊人情况，而在国内互联网公司，似乎除了同程艺龙、蔚来汽车等公司，已经找不出太多叫得上名头的大企业坚持使用.NET技术栈。\n但是即便如此，这并没有说明.NET技术已经逐渐落伍，尤其在技术领域，看起来火热的市场，从来也不是一门语言所能主宰。真正优秀的开发者从来不会被语言束缚，事实上虽然掌握一门核心语言非常重要，其次在语言之外的其他专业技能，诸如设计模式和设计原则、对于算法等的理解程度，都是开发者非常重要的能力，对他的价值评估产生了非常深远的影响。 \n在众多专业技能中，比较争议的大概是数据库、各类组件和其他专业技能，以及DevOps和微服务。首先是这些新概念，铺天盖地而来，让人难以抗拒学习的欲望，甚至不学习，也经常会被人说成知识体系闭塞。但是学习了之后，如果得不到实践，不见得能够带来短期或长期受益。除此之外能够恰到好处的掌握好数据库和各类第三方组件（诸如Redis、Consul）等，虽然能够让开发者获得不少机会，但是却并非每位开发者都有时间或精力了解这么多东西。毕竟每天只有24小时，花时间学习了A组件，往往就得忽略其他组件。而且如果只是浅尝辄止的了解某些组件，倒不如仔细的钻研众多同类组件中的一种。\n微服务容易让人陷入知识的海洋无可自拔，在宝玉老师的专栏《软件工程之美》也提到微服务架构并非软件系统的天然演进，要靠组织力量来完成。而在微服务书籍《微服务设计模式》中也提出，微服务实际上应该是一种组织架构形式的体现，而不仅仅只是一种软件架构。为了微服务而微服务，不见得会带来了团队沟通成本的提高，也不见得有利于软件系统的高效迭代。同样，为了DevOps而上容器，这样也不是一种值得推崇的策略。\n我把DDD和TDD纳入到专业技能中非常重要的一环。因为DDD是一种非常重要的软件问题分析方法，从宏观来看有点像团队问题分析方法，如果时间有限，大概不太有必要独自研究，毕竟要将其实践下去，还是要更多的依赖团队，不如拉几个同事一起探究。如果没办法将DDD完美的实践下去，也不必苛求，运用好领域的分层思想，可以让软件系统尽可能可控的管理各领域的知识，实现业务知识的沉淀。\nTDD看似能够让软件尽可能的减少后期的维护成本，但是要将其实践下去，取决于大环境和个人是否持续不断的刻意练习，而且需要一个漫长的周期。能够刻意练习显然是极好的，相信他一定能给你带来非常巨大的好处。\n2. 行业知识\n\n所处行业、和行业知识是决定开发者的关键，而不是专业技能本身。例如红得发紫的电商行业，阿里巴巴或拼多多等电商平台，最能给开发者带来丰厚收益的行业，也是竞争最为激烈的行业。而例如社区团购这种新兴商业业态在长沙，也同样为长沙技术圈的从业者带来的新的机遇。\n但是似乎许多行业的开发者们对本身行业知识的兴趣并不大。许多开发者往往执着于对专业技能的钻研，而忽略了对行业知识的了解。而事实上行业知识的认知深度，恰好更能体现产品的水平和公司的专业程度。如果每个人都矢志于为公司打造最专业的产品，这显然将为公司、为个人带来无穷收获。\n3. 软实力\n\n软实力是让你我与众不同的核心关键。他体现在外在，是一个人的谈吐和为人处世的态度。他通过领导力、管理能力、表达能力等许多种形式让你的优点得以更好的表现在世人面前。\n软实力，是程序员成功的关键。例如你是否能够与团队成员融洽的沟通，这能够促进你与团队成员间的相互认同、你是否能够将你打造的产品更好的展示在领导或客户面前，这有利于你和公司产品价值的彰显、你是否能用文字或PPT对你的工作进行总结，这又能体现你的组织表达能力。而你在公司与其他同事的良好沟通、与客户的良好沟通，既是在积累人脉，更是在投资未来。\n我独辟蹊径的把运气列入软实力的范畴，是因为我觉得运气是很重要的一环，不过如果没有足够的软实力积累，即便有不错的机遇，也不见得有能力支撑住。\n4. 总结\n\n在我参加工作的早期，总是片面的认为技术能力才是决定人与人区别的最大关键。但是事实上恰好相反。我们身边那些混得最好的，他们往往并不是技术最好的。他们往往更善于钻研一个行业，并从中发掘出价值。他们往往更注重软实力的培养，并通过这些软实力，获得许多常人不能拥有的机会。\n优秀的开发者也善于抓住职场中的每一次挑战。他们将每段职场当做修行和学习的机会，无时无刻不忘提升自己，哪怕在小公司，也同样能创造不平凡的成绩。 \n短暂的迷茫不可怕，怕的是看到了迷茫还不试图改变，例如知道能力有不足，却依然忽略了对能力的积累。能力的积累从来不仅仅只是停留在纸面上的简单文字，再多的迷茫，不如从眼下开始刻意练习和主动培养。例如作为.NET开发者，或许我们都需要更加深层次的了解C#/.NET技术的核心知识，一本好书《C# 7.0 核心技术指南》将为你解惑无穷。\n无论当下我们做的什么技术，最重要的关键，就是认清楚自己的缺点，然后有意识的去改善。不必苛求昨天的自己比今天的自己优秀，努力使明天的自己比今天更优秀，坚持一个方向，总能让你获得更多机会。\n\n","source":"_posts/随笔/让人迷茫的三十岁.md","raw":"---\ntitle:  如何看待程序媛的未来职业规划\ndate: 2020-02-16 16:21\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n```\n我今年三十岁，我很迷茫，不知道未来该选择什么发展方向。\n```\n这是我无意中在社区微信群中看到的一位年轻的开发者说的话，之前他也经常会在技术群中抛出一些有深度有内容的问题，并能积极乐观的进行问题思考和探寻技术解决方案，有时候可能会错误的以为他这样一位热爱学习的开发者，在公司也一定是技术的引领者，对自己的职场规划有着清楚的认识。\n所以他抛出这样的问题着实有点意外，不过细想之后，或许也属实正常是。对于30岁左右的开发者来说，从20出头的毛头小伙，逐渐成长为家庭和公司的顶梁柱，如果一直从事技术领域，大概很容易就到了瓶颈期，如下图，一个人的学习能力增长曲线，大概三年或五年左右，增长速度就会逐渐放缓。\n![图片](https://images.smcdn.cn/atfF82TaJ80ZFsKv/IMG_0222.PNG!thumbnail)\n（手画的） \n到了这个阶段会非常痛苦，如果身处一家优秀的公司还好，有一套完整的体系保证你持续成长，否则就得陷入了吃老本的时期，或许将一直这么平庸的下去，直到被迫退出行业。\n而那些不甘如此的优秀者，都渴望去改变现状，他们们往往承受着无比巨大的压力，尤其是互联网技术飞速发展、各种新技术新方法席卷而来，究竟该如何选择技术的发展方向和个人的职场规划，这个问题自然而然就出现在他们面前。\n以下是互联网开发者的“人才三角”结构，由专业技能、行业知识和软实力组成。每一个圆环均代表一个知识边界。\n![图片](https://uploader.shimo.im/f/sVmne1ru5W8I2EPH.png!thumbnail)\n1. 专业技能\n\n专业技能是开发者赖以生存的宝贵技能，而其中开发语言是最重要的一个方面。近年来飞速发展的互联网业，似乎对.NET开发者带来的冲击相当巨大，在许多城市，甚至出现了Java与.NET的招聘信息比例10比1的惊人情况，而在国内互联网公司，似乎除了同程艺龙、蔚来汽车等公司，已经找不出太多叫得上名头的大企业坚持使用.NET技术栈。\n但是即便如此，这并没有说明.NET技术已经逐渐落伍，尤其在技术领域，看起来火热的市场，从来也不是一门语言所能主宰。真正优秀的开发者从来不会被语言束缚，事实上虽然掌握一门核心语言非常重要，其次在语言之外的其他专业技能，诸如设计模式和设计原则、对于算法等的理解程度，都是开发者非常重要的能力，对他的价值评估产生了非常深远的影响。 \n在众多专业技能中，比较争议的大概是数据库、各类组件和其他专业技能，以及DevOps和微服务。首先是这些新概念，铺天盖地而来，让人难以抗拒学习的欲望，甚至不学习，也经常会被人说成知识体系闭塞。但是学习了之后，如果得不到实践，不见得能够带来短期或长期受益。除此之外能够恰到好处的掌握好数据库和各类第三方组件（诸如Redis、Consul）等，虽然能够让开发者获得不少机会，但是却并非每位开发者都有时间或精力了解这么多东西。毕竟每天只有24小时，花时间学习了A组件，往往就得忽略其他组件。而且如果只是浅尝辄止的了解某些组件，倒不如仔细的钻研众多同类组件中的一种。\n微服务容易让人陷入知识的海洋无可自拔，在宝玉老师的专栏《软件工程之美》也提到微服务架构并非软件系统的天然演进，要靠组织力量来完成。而在微服务书籍《微服务设计模式》中也提出，微服务实际上应该是一种组织架构形式的体现，而不仅仅只是一种软件架构。为了微服务而微服务，不见得会带来了团队沟通成本的提高，也不见得有利于软件系统的高效迭代。同样，为了DevOps而上容器，这样也不是一种值得推崇的策略。\n我把DDD和TDD纳入到专业技能中非常重要的一环。因为DDD是一种非常重要的软件问题分析方法，从宏观来看有点像团队问题分析方法，如果时间有限，大概不太有必要独自研究，毕竟要将其实践下去，还是要更多的依赖团队，不如拉几个同事一起探究。如果没办法将DDD完美的实践下去，也不必苛求，运用好领域的分层思想，可以让软件系统尽可能可控的管理各领域的知识，实现业务知识的沉淀。\nTDD看似能够让软件尽可能的减少后期的维护成本，但是要将其实践下去，取决于大环境和个人是否持续不断的刻意练习，而且需要一个漫长的周期。能够刻意练习显然是极好的，相信他一定能给你带来非常巨大的好处。\n2. 行业知识\n\n所处行业、和行业知识是决定开发者的关键，而不是专业技能本身。例如红得发紫的电商行业，阿里巴巴或拼多多等电商平台，最能给开发者带来丰厚收益的行业，也是竞争最为激烈的行业。而例如社区团购这种新兴商业业态在长沙，也同样为长沙技术圈的从业者带来的新的机遇。\n但是似乎许多行业的开发者们对本身行业知识的兴趣并不大。许多开发者往往执着于对专业技能的钻研，而忽略了对行业知识的了解。而事实上行业知识的认知深度，恰好更能体现产品的水平和公司的专业程度。如果每个人都矢志于为公司打造最专业的产品，这显然将为公司、为个人带来无穷收获。\n3. 软实力\n\n软实力是让你我与众不同的核心关键。他体现在外在，是一个人的谈吐和为人处世的态度。他通过领导力、管理能力、表达能力等许多种形式让你的优点得以更好的表现在世人面前。\n软实力，是程序员成功的关键。例如你是否能够与团队成员融洽的沟通，这能够促进你与团队成员间的相互认同、你是否能够将你打造的产品更好的展示在领导或客户面前，这有利于你和公司产品价值的彰显、你是否能用文字或PPT对你的工作进行总结，这又能体现你的组织表达能力。而你在公司与其他同事的良好沟通、与客户的良好沟通，既是在积累人脉，更是在投资未来。\n我独辟蹊径的把运气列入软实力的范畴，是因为我觉得运气是很重要的一环，不过如果没有足够的软实力积累，即便有不错的机遇，也不见得有能力支撑住。\n4. 总结\n\n在我参加工作的早期，总是片面的认为技术能力才是决定人与人区别的最大关键。但是事实上恰好相反。我们身边那些混得最好的，他们往往并不是技术最好的。他们往往更善于钻研一个行业，并从中发掘出价值。他们往往更注重软实力的培养，并通过这些软实力，获得许多常人不能拥有的机会。\n优秀的开发者也善于抓住职场中的每一次挑战。他们将每段职场当做修行和学习的机会，无时无刻不忘提升自己，哪怕在小公司，也同样能创造不平凡的成绩。 \n短暂的迷茫不可怕，怕的是看到了迷茫还不试图改变，例如知道能力有不足，却依然忽略了对能力的积累。能力的积累从来不仅仅只是停留在纸面上的简单文字，再多的迷茫，不如从眼下开始刻意练习和主动培养。例如作为.NET开发者，或许我们都需要更加深层次的了解C#/.NET技术的核心知识，一本好书《C# 7.0 核心技术指南》将为你解惑无穷。\n无论当下我们做的什么技术，最重要的关键，就是认清楚自己的缺点，然后有意识的去改善。不必苛求昨天的自己比今天的自己优秀，努力使明天的自己比今天更优秀，坚持一个方向，总能让你获得更多机会。\n\n","slug":"随笔/让人迷茫的三十岁","published":1,"updated":"2020-02-16T08:21:12.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt9r004rn4vip0kpuhpk","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我今年三十岁，我很迷茫，不知道未来该选择什么发展方向。</span><br></pre></td></tr></table></figure>\n\n<p>这是我无意中在社区微信群中看到的一位年轻的开发者说的话，之前他也经常会在技术群中抛出一些有深度有内容的问题，并能积极乐观的进行问题思考和探寻技术解决方案，有时候可能会错误的以为他这样一位热爱学习的开发者，在公司也一定是技术的引领者，对自己的职场规划有着清楚的认识。<br>所以他抛出这样的问题着实有点意外，不过细想之后，或许也属实正常是。对于30岁左右的开发者来说，从20出头的毛头小伙，逐渐成长为家庭和公司的顶梁柱，如果一直从事技术领域，大概很容易就到了瓶颈期，如下图，一个人的学习能力增长曲线，大概三年或五年左右，增长速度就会逐渐放缓。<br><img src=\"https://images.smcdn.cn/atfF82TaJ80ZFsKv/IMG_0222.PNG!thumbnail\" alt=\"图片\"><br>（手画的）<br>到了这个阶段会非常痛苦，如果身处一家优秀的公司还好，有一套完整的体系保证你持续成长，否则就得陷入了吃老本的时期，或许将一直这么平庸的下去，直到被迫退出行业。<br>而那些不甘如此的优秀者，都渴望去改变现状，他们们往往承受着无比巨大的压力，尤其是互联网技术飞速发展、各种新技术新方法席卷而来，究竟该如何选择技术的发展方向和个人的职场规划，这个问题自然而然就出现在他们面前。<br>以下是互联网开发者的“人才三角”结构，由专业技能、行业知识和软实力组成。每一个圆环均代表一个知识边界。<br><img src=\"https://uploader.shimo.im/f/sVmne1ru5W8I2EPH.png!thumbnail\" alt=\"图片\"></p>\n<ol>\n<li>专业技能</li>\n</ol>\n<p>专业技能是开发者赖以生存的宝贵技能，而其中开发语言是最重要的一个方面。近年来飞速发展的互联网业，似乎对.NET开发者带来的冲击相当巨大，在许多城市，甚至出现了Java与.NET的招聘信息比例10比1的惊人情况，而在国内互联网公司，似乎除了同程艺龙、蔚来汽车等公司，已经找不出太多叫得上名头的大企业坚持使用.NET技术栈。<br>但是即便如此，这并没有说明.NET技术已经逐渐落伍，尤其在技术领域，看起来火热的市场，从来也不是一门语言所能主宰。真正优秀的开发者从来不会被语言束缚，事实上虽然掌握一门核心语言非常重要，其次在语言之外的其他专业技能，诸如设计模式和设计原则、对于算法等的理解程度，都是开发者非常重要的能力，对他的价值评估产生了非常深远的影响。<br>在众多专业技能中，比较争议的大概是数据库、各类组件和其他专业技能，以及DevOps和微服务。首先是这些新概念，铺天盖地而来，让人难以抗拒学习的欲望，甚至不学习，也经常会被人说成知识体系闭塞。但是学习了之后，如果得不到实践，不见得能够带来短期或长期受益。除此之外能够恰到好处的掌握好数据库和各类第三方组件（诸如Redis、Consul）等，虽然能够让开发者获得不少机会，但是却并非每位开发者都有时间或精力了解这么多东西。毕竟每天只有24小时，花时间学习了A组件，往往就得忽略其他组件。而且如果只是浅尝辄止的了解某些组件，倒不如仔细的钻研众多同类组件中的一种。<br>微服务容易让人陷入知识的海洋无可自拔，在宝玉老师的专栏《软件工程之美》也提到微服务架构并非软件系统的天然演进，要靠组织力量来完成。而在微服务书籍《微服务设计模式》中也提出，微服务实际上应该是一种组织架构形式的体现，而不仅仅只是一种软件架构。为了微服务而微服务，不见得会带来了团队沟通成本的提高，也不见得有利于软件系统的高效迭代。同样，为了DevOps而上容器，这样也不是一种值得推崇的策略。<br>我把DDD和TDD纳入到专业技能中非常重要的一环。因为DDD是一种非常重要的软件问题分析方法，从宏观来看有点像团队问题分析方法，如果时间有限，大概不太有必要独自研究，毕竟要将其实践下去，还是要更多的依赖团队，不如拉几个同事一起探究。如果没办法将DDD完美的实践下去，也不必苛求，运用好领域的分层思想，可以让软件系统尽可能可控的管理各领域的知识，实现业务知识的沉淀。<br>TDD看似能够让软件尽可能的减少后期的维护成本，但是要将其实践下去，取决于大环境和个人是否持续不断的刻意练习，而且需要一个漫长的周期。能够刻意练习显然是极好的，相信他一定能给你带来非常巨大的好处。<br>2. 行业知识</p>\n<p>所处行业、和行业知识是决定开发者的关键，而不是专业技能本身。例如红得发紫的电商行业，阿里巴巴或拼多多等电商平台，最能给开发者带来丰厚收益的行业，也是竞争最为激烈的行业。而例如社区团购这种新兴商业业态在长沙，也同样为长沙技术圈的从业者带来的新的机遇。<br>但是似乎许多行业的开发者们对本身行业知识的兴趣并不大。许多开发者往往执着于对专业技能的钻研，而忽略了对行业知识的了解。而事实上行业知识的认知深度，恰好更能体现产品的水平和公司的专业程度。如果每个人都矢志于为公司打造最专业的产品，这显然将为公司、为个人带来无穷收获。<br>3. 软实力</p>\n<p>软实力是让你我与众不同的核心关键。他体现在外在，是一个人的谈吐和为人处世的态度。他通过领导力、管理能力、表达能力等许多种形式让你的优点得以更好的表现在世人面前。<br>软实力，是程序员成功的关键。例如你是否能够与团队成员融洽的沟通，这能够促进你与团队成员间的相互认同、你是否能够将你打造的产品更好的展示在领导或客户面前，这有利于你和公司产品价值的彰显、你是否能用文字或PPT对你的工作进行总结，这又能体现你的组织表达能力。而你在公司与其他同事的良好沟通、与客户的良好沟通，既是在积累人脉，更是在投资未来。<br>我独辟蹊径的把运气列入软实力的范畴，是因为我觉得运气是很重要的一环，不过如果没有足够的软实力积累，即便有不错的机遇，也不见得有能力支撑住。<br>4. 总结</p>\n<p>在我参加工作的早期，总是片面的认为技术能力才是决定人与人区别的最大关键。但是事实上恰好相反。我们身边那些混得最好的，他们往往并不是技术最好的。他们往往更善于钻研一个行业，并从中发掘出价值。他们往往更注重软实力的培养，并通过这些软实力，获得许多常人不能拥有的机会。<br>优秀的开发者也善于抓住职场中的每一次挑战。他们将每段职场当做修行和学习的机会，无时无刻不忘提升自己，哪怕在小公司，也同样能创造不平凡的成绩。<br>短暂的迷茫不可怕，怕的是看到了迷茫还不试图改变，例如知道能力有不足，却依然忽略了对能力的积累。能力的积累从来不仅仅只是停留在纸面上的简单文字，再多的迷茫，不如从眼下开始刻意练习和主动培养。例如作为.NET开发者，或许我们都需要更加深层次的了解C#/.NET技术的核心知识，一本好书《C# 7.0 核心技术指南》将为你解惑无穷。<br>无论当下我们做的什么技术，最重要的关键，就是认清楚自己的缺点，然后有意识的去改善。不必苛求昨天的自己比今天的自己优秀，努力使明天的自己比今天更优秀，坚持一个方向，总能让你获得更多机会。</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我今年三十岁，我很迷茫，不知道未来该选择什么发展方向。</span><br></pre></td></tr></table></figure>\n\n<p>这是我无意中在社区微信群中看到的一位年轻的开发者说的话，之前他也经常会在技术群中抛出一些有深度有内容的问题，并能积极乐观的进行问题思考和探寻技术解决方案，有时候可能会错误的以为他这样一位热爱学习的开发者，在公司也一定是技术的引领者，对自己的职场规划有着清楚的认识。<br>所以他抛出这样的问题着实有点意外，不过细想之后，或许也属实正常是。对于30岁左右的开发者来说，从20出头的毛头小伙，逐渐成长为家庭和公司的顶梁柱，如果一直从事技术领域，大概很容易就到了瓶颈期，如下图，一个人的学习能力增长曲线，大概三年或五年左右，增长速度就会逐渐放缓。<br><img src=\"https://images.smcdn.cn/atfF82TaJ80ZFsKv/IMG_0222.PNG!thumbnail\" alt=\"图片\"><br>（手画的）<br>到了这个阶段会非常痛苦，如果身处一家优秀的公司还好，有一套完整的体系保证你持续成长，否则就得陷入了吃老本的时期，或许将一直这么平庸的下去，直到被迫退出行业。<br>而那些不甘如此的优秀者，都渴望去改变现状，他们们往往承受着无比巨大的压力，尤其是互联网技术飞速发展、各种新技术新方法席卷而来，究竟该如何选择技术的发展方向和个人的职场规划，这个问题自然而然就出现在他们面前。<br>以下是互联网开发者的“人才三角”结构，由专业技能、行业知识和软实力组成。每一个圆环均代表一个知识边界。<br><img src=\"https://uploader.shimo.im/f/sVmne1ru5W8I2EPH.png!thumbnail\" alt=\"图片\"></p>\n<ol>\n<li>专业技能</li>\n</ol>\n<p>专业技能是开发者赖以生存的宝贵技能，而其中开发语言是最重要的一个方面。近年来飞速发展的互联网业，似乎对.NET开发者带来的冲击相当巨大，在许多城市，甚至出现了Java与.NET的招聘信息比例10比1的惊人情况，而在国内互联网公司，似乎除了同程艺龙、蔚来汽车等公司，已经找不出太多叫得上名头的大企业坚持使用.NET技术栈。<br>但是即便如此，这并没有说明.NET技术已经逐渐落伍，尤其在技术领域，看起来火热的市场，从来也不是一门语言所能主宰。真正优秀的开发者从来不会被语言束缚，事实上虽然掌握一门核心语言非常重要，其次在语言之外的其他专业技能，诸如设计模式和设计原则、对于算法等的理解程度，都是开发者非常重要的能力，对他的价值评估产生了非常深远的影响。<br>在众多专业技能中，比较争议的大概是数据库、各类组件和其他专业技能，以及DevOps和微服务。首先是这些新概念，铺天盖地而来，让人难以抗拒学习的欲望，甚至不学习，也经常会被人说成知识体系闭塞。但是学习了之后，如果得不到实践，不见得能够带来短期或长期受益。除此之外能够恰到好处的掌握好数据库和各类第三方组件（诸如Redis、Consul）等，虽然能够让开发者获得不少机会，但是却并非每位开发者都有时间或精力了解这么多东西。毕竟每天只有24小时，花时间学习了A组件，往往就得忽略其他组件。而且如果只是浅尝辄止的了解某些组件，倒不如仔细的钻研众多同类组件中的一种。<br>微服务容易让人陷入知识的海洋无可自拔，在宝玉老师的专栏《软件工程之美》也提到微服务架构并非软件系统的天然演进，要靠组织力量来完成。而在微服务书籍《微服务设计模式》中也提出，微服务实际上应该是一种组织架构形式的体现，而不仅仅只是一种软件架构。为了微服务而微服务，不见得会带来了团队沟通成本的提高，也不见得有利于软件系统的高效迭代。同样，为了DevOps而上容器，这样也不是一种值得推崇的策略。<br>我把DDD和TDD纳入到专业技能中非常重要的一环。因为DDD是一种非常重要的软件问题分析方法，从宏观来看有点像团队问题分析方法，如果时间有限，大概不太有必要独自研究，毕竟要将其实践下去，还是要更多的依赖团队，不如拉几个同事一起探究。如果没办法将DDD完美的实践下去，也不必苛求，运用好领域的分层思想，可以让软件系统尽可能可控的管理各领域的知识，实现业务知识的沉淀。<br>TDD看似能够让软件尽可能的减少后期的维护成本，但是要将其实践下去，取决于大环境和个人是否持续不断的刻意练习，而且需要一个漫长的周期。能够刻意练习显然是极好的，相信他一定能给你带来非常巨大的好处。<br>2. 行业知识</p>\n<p>所处行业、和行业知识是决定开发者的关键，而不是专业技能本身。例如红得发紫的电商行业，阿里巴巴或拼多多等电商平台，最能给开发者带来丰厚收益的行业，也是竞争最为激烈的行业。而例如社区团购这种新兴商业业态在长沙，也同样为长沙技术圈的从业者带来的新的机遇。<br>但是似乎许多行业的开发者们对本身行业知识的兴趣并不大。许多开发者往往执着于对专业技能的钻研，而忽略了对行业知识的了解。而事实上行业知识的认知深度，恰好更能体现产品的水平和公司的专业程度。如果每个人都矢志于为公司打造最专业的产品，这显然将为公司、为个人带来无穷收获。<br>3. 软实力</p>\n<p>软实力是让你我与众不同的核心关键。他体现在外在，是一个人的谈吐和为人处世的态度。他通过领导力、管理能力、表达能力等许多种形式让你的优点得以更好的表现在世人面前。<br>软实力，是程序员成功的关键。例如你是否能够与团队成员融洽的沟通，这能够促进你与团队成员间的相互认同、你是否能够将你打造的产品更好的展示在领导或客户面前，这有利于你和公司产品价值的彰显、你是否能用文字或PPT对你的工作进行总结，这又能体现你的组织表达能力。而你在公司与其他同事的良好沟通、与客户的良好沟通，既是在积累人脉，更是在投资未来。<br>我独辟蹊径的把运气列入软实力的范畴，是因为我觉得运气是很重要的一环，不过如果没有足够的软实力积累，即便有不错的机遇，也不见得有能力支撑住。<br>4. 总结</p>\n<p>在我参加工作的早期，总是片面的认为技术能力才是决定人与人区别的最大关键。但是事实上恰好相反。我们身边那些混得最好的，他们往往并不是技术最好的。他们往往更善于钻研一个行业，并从中发掘出价值。他们往往更注重软实力的培养，并通过这些软实力，获得许多常人不能拥有的机会。<br>优秀的开发者也善于抓住职场中的每一次挑战。他们将每段职场当做修行和学习的机会，无时无刻不忘提升自己，哪怕在小公司，也同样能创造不平凡的成绩。<br>短暂的迷茫不可怕，怕的是看到了迷茫还不试图改变，例如知道能力有不足，却依然忽略了对能力的积累。能力的积累从来不仅仅只是停留在纸面上的简单文字，再多的迷茫，不如从眼下开始刻意练习和主动培养。例如作为.NET开发者，或许我们都需要更加深层次的了解C#/.NET技术的核心知识，一本好书《C# 7.0 核心技术指南》将为你解惑无穷。<br>无论当下我们做的什么技术，最重要的关键，就是认清楚自己的缺点，然后有意识的去改善。不必苛求昨天的自己比今天的自己优秀，努力使明天的自己比今天更优秀，坚持一个方向，总能让你获得更多机会。</p>\n"},{"title":"网易事件，芸芸众生，相煎何急","date":"2019-12-01T08:28:00.000Z","author":"邹溪源","_content":"\n十一月初拖家带口去了上海，到了著名的城隍庙参观，无意中看到了一个仅出现在历史书上的古老物件“西洋镜”，仿佛跨越百年，来到那个如裹脚布般冗长而乏味的古老年代，看到了一群有一群卑微的小民在生活的裹挟之下，对外界充满兴趣，并透过一个西洋镜来看看外面的世界。对于古老时代的他们而言，西洋镜里的一切都充满稀奇。\n\n![图片](https://uploader.shimo.im/f/lsExqdP5K40rAqM2.png!thumbnail)\n\n有时候，今天的互联网就像西洋镜。\n\n今天，制度的优越性让我们取得了经济上的飞速成长，互联网技术拉近了彼此的距离，也容易打破隔阂，原来或许发生在与自己无关世界的事情，总是很容易的就让我们产生同理心。\n\n![图片](https://uploader.shimo.im/f/eNIdyrdU3M4PbZKA.png!thumbnail)\n\n《前网不易员工发文称患病后遭遇公司“暴力裁员”》引起了轩然大波，随着网不易拿出了更多的论点，也让事件掀起了小高潮，我想换一个角度来考虑一下问题，分析一下在事件中那些出现了的，或没出现的人群。\n\n# 主角：\n主角J是一位90后，拥有上海交大的学历，是职场上最走俏的优秀资源。而且业余运营了自己的公众号，文笔朴实简练流畅自然。如此年轻的他，也是企业最受欢迎的优秀成员，假以时日，如果能够善终，一定能谱写一篇非常不错的故事，让大家看到90后是如何快速成长为企业的栋梁人才，为公司创造无穷价值。然而，由于一场身体上的变故，让他的职场之路遇到了困境，而且扩展性心肌炎病症非常严重，最终必须面临换心的痛苦。\n\n人生之痛，莫过于让白发人送黑发人，难道要让他的父母成为失独老人么。扼腕叹息。\n\n# 主管和人事：\n在这个事件中，作为第一当事人的主管自然而然会成为焦点，甚至“网红”，即便他不想如此。\n\n当然，我们都知道，他的谈话是代表公司谈话的，所以他以为他的立场也同样代表了公司立场，嗯，那一刻他一定以为他是三石附体，公司要裁员，是裁掉那些劳动生产力低或者如大东子说的“性价比低”的员工，哪怕他生病了，也应该毫不犹豫的挥起屠刀，不能放过任何一个不能跟公司共同奋斗的人。于是他这么做了，并且他成功了。\n\n而人力资源部门显然是这件事情背后的幕后真凶，公司说要裁减人员，而作为裁员的直接被考核部门，自然而然要冲在最前面。\n\n在职场中，许多人都信奉这样的哲学：大家都是成年人，人性是什么重要么？难道还有什么比KPI更重要的么？\n\n![图片](https://uploader.shimo.im/f/4q8Af3sOgGsHZibc.png!thumbnail)\n\n# 三石兄：\n说实话，网不易的发展历史对于80后的我来说一度是一个非常古老的故事，就像昔日《硅谷之火》一般，指引着我走上了IT这条道路，并成为一位普通码农。但是吃到了互联网时代的红利，却在移动互联网时代开始逐渐走下坡路了。\n\n而且网不易和微软中国、金山一样被成为中国互联网的黄埔军校，从网不易毕业的许多创业者，他们创造出许多优秀的产品，也深深的影响着我们。\n\n当然，黄埔军校其实对于公司本身来说，并非是个非常好听的名词，因为他代表着公司能够培养人，但是却不能留住人。用《浪潮之巅》中的一句话来说，要看一家公司是好还是坏，就看是优秀的人才流入还是流出。每一个优秀的人员流失，对一家大公司来说看起来没什么，但是往往意味着公司的吸引力在逐渐下降。\n\n经济学中有一个“劣币驱逐良币”的现象，对于一家无法维持积极发展的企业，也往往会面临这样的现象。优秀的人才流失之后，往往留下来的是最能体会企业文化精神、并能在肉体上跟公司在一起的人。\n\n嗯，肉体上跟公司在一起的人似乎更能理解企业管理的规则，并愿意花时间熬工时。年初马云说996是福报时，大家都在吐槽说资本家的本质彰显无疑，但是实际上还有更多IT公司其实是维持着更长的小时，每天只上9个小时，确实是一种福报啊。好吧，对于大部分公司而言，加班，其实是为了靠苦劳来弥补管理层甚至老板吹过的牛或能力上的不足吧。\n\n三石兄似乎已经退居二线了，这也意味着，企业文化精神已经在逐渐衰微，公司已经在“大公司病”这条路上越病越深。\n\n在互联网寒冬的今天，许多中小企业都面临着裁员的艰难抉择，也许他们没办法经营，但为了给员工多一条生路，往往也会想办法给他们一些补偿。当然有一些企业确实拿不出钱，但是他们也会给出承诺。\n\n但网不易的吃相会不会太难看了？连网不易这样的大公司都不给补偿，而是以这么难看的吃相挥舞屠刀，肆意驱赶那些为公司发展做出巨大贡献的优秀员工？那其他的公司还有没有更加恶劣的手段来赶人呢？招人的时候不惜一切代价，赶人的时候，也同样不惜一切代价?企业的商誉难道如此廉价？\n\n出生90后的主角身患需要换心的重病，而大概同样90后的网不易，也需要三石兄出面，给公司来一场换心手术吧。\n\n# 工会\n在我的同学群讨论这个事情时，突然有人抛出了一个问题：工会去哪里了。大概大家都会觉得莫名其妙。虽然在有一部法律《工会法》明确了工会的职能是维系党和人民群众的关系、并维护广大工人阶级的基本利益，而且大部分公司似乎都设立了所谓的工会，但是真的有工会么？\n\n并非如此，工会代表老板的利益，或者说是管理层的利益，其目前的主要职能大概仅仅停留在“收会费、搞茶话会”。工会究竟还有什么用？\n\n期待全国总工会发声。\n\n# 劳动部门\n对于大部分普通群众来说，跟劳动部门似乎没有一丁点关系。\n\n虽然跟公司签署了劳动合同，看似应该受到劳动法的保护，但是当发生劳动纠纷，去劳动仲裁大队申请仲裁时，政府部门的工作方式往往会让人望而生畏。于是宁可自己吃点亏，也不愿意走那么冗长的劳动仲裁流程，毕竟搞不好就需要花大半年的时间，不定期就会接到劳动部门的电话让当事人去仲裁庭处理案子，对于个人来说确实是有点吃不消。\n\n期待劳动部门发声。\n\n我还记得多少年前，农民工的问题引起了政府部门的多次关注，连续好几年的中央一号文件都是关注农民工问题。IT民工呢？毕竟IT产业工人也算是个人所得税的主要纳税群体，难道就不应该引起更多关注？有关部门不要只想着GDP、招商引资、课税，而不想着如何维护劳动者的利益啊。\n\n# 结语\n城隍庙的西洋镜，看透百年，看透世间百态。\n\n网不易裁员事件，透过这个事件，我们看到了来自互联网时代的独特魅力，国民早已不再停留在鲁迅书中说过的矇昧和无知的区区看客，而是掌握了更多的方法，足以产生更加深远的影响力。\n\n使其生、使其亡。摧枯拉朽，谁能阻挡？\n\n时代在进步，那些该破灭的就让他破灭吧。\n\n由于时间仓促，胡言乱语，还请诸君一笑。\n\n","source":"_posts/随笔/网易事件背后众生相.md","raw":"---\ntitle:  网易事件，芸芸众生，相煎何急\ndate: 2019-12-1 16:28\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n\n十一月初拖家带口去了上海，到了著名的城隍庙参观，无意中看到了一个仅出现在历史书上的古老物件“西洋镜”，仿佛跨越百年，来到那个如裹脚布般冗长而乏味的古老年代，看到了一群有一群卑微的小民在生活的裹挟之下，对外界充满兴趣，并透过一个西洋镜来看看外面的世界。对于古老时代的他们而言，西洋镜里的一切都充满稀奇。\n\n![图片](https://uploader.shimo.im/f/lsExqdP5K40rAqM2.png!thumbnail)\n\n有时候，今天的互联网就像西洋镜。\n\n今天，制度的优越性让我们取得了经济上的飞速成长，互联网技术拉近了彼此的距离，也容易打破隔阂，原来或许发生在与自己无关世界的事情，总是很容易的就让我们产生同理心。\n\n![图片](https://uploader.shimo.im/f/eNIdyrdU3M4PbZKA.png!thumbnail)\n\n《前网不易员工发文称患病后遭遇公司“暴力裁员”》引起了轩然大波，随着网不易拿出了更多的论点，也让事件掀起了小高潮，我想换一个角度来考虑一下问题，分析一下在事件中那些出现了的，或没出现的人群。\n\n# 主角：\n主角J是一位90后，拥有上海交大的学历，是职场上最走俏的优秀资源。而且业余运营了自己的公众号，文笔朴实简练流畅自然。如此年轻的他，也是企业最受欢迎的优秀成员，假以时日，如果能够善终，一定能谱写一篇非常不错的故事，让大家看到90后是如何快速成长为企业的栋梁人才，为公司创造无穷价值。然而，由于一场身体上的变故，让他的职场之路遇到了困境，而且扩展性心肌炎病症非常严重，最终必须面临换心的痛苦。\n\n人生之痛，莫过于让白发人送黑发人，难道要让他的父母成为失独老人么。扼腕叹息。\n\n# 主管和人事：\n在这个事件中，作为第一当事人的主管自然而然会成为焦点，甚至“网红”，即便他不想如此。\n\n当然，我们都知道，他的谈话是代表公司谈话的，所以他以为他的立场也同样代表了公司立场，嗯，那一刻他一定以为他是三石附体，公司要裁员，是裁掉那些劳动生产力低或者如大东子说的“性价比低”的员工，哪怕他生病了，也应该毫不犹豫的挥起屠刀，不能放过任何一个不能跟公司共同奋斗的人。于是他这么做了，并且他成功了。\n\n而人力资源部门显然是这件事情背后的幕后真凶，公司说要裁减人员，而作为裁员的直接被考核部门，自然而然要冲在最前面。\n\n在职场中，许多人都信奉这样的哲学：大家都是成年人，人性是什么重要么？难道还有什么比KPI更重要的么？\n\n![图片](https://uploader.shimo.im/f/4q8Af3sOgGsHZibc.png!thumbnail)\n\n# 三石兄：\n说实话，网不易的发展历史对于80后的我来说一度是一个非常古老的故事，就像昔日《硅谷之火》一般，指引着我走上了IT这条道路，并成为一位普通码农。但是吃到了互联网时代的红利，却在移动互联网时代开始逐渐走下坡路了。\n\n而且网不易和微软中国、金山一样被成为中国互联网的黄埔军校，从网不易毕业的许多创业者，他们创造出许多优秀的产品，也深深的影响着我们。\n\n当然，黄埔军校其实对于公司本身来说，并非是个非常好听的名词，因为他代表着公司能够培养人，但是却不能留住人。用《浪潮之巅》中的一句话来说，要看一家公司是好还是坏，就看是优秀的人才流入还是流出。每一个优秀的人员流失，对一家大公司来说看起来没什么，但是往往意味着公司的吸引力在逐渐下降。\n\n经济学中有一个“劣币驱逐良币”的现象，对于一家无法维持积极发展的企业，也往往会面临这样的现象。优秀的人才流失之后，往往留下来的是最能体会企业文化精神、并能在肉体上跟公司在一起的人。\n\n嗯，肉体上跟公司在一起的人似乎更能理解企业管理的规则，并愿意花时间熬工时。年初马云说996是福报时，大家都在吐槽说资本家的本质彰显无疑，但是实际上还有更多IT公司其实是维持着更长的小时，每天只上9个小时，确实是一种福报啊。好吧，对于大部分公司而言，加班，其实是为了靠苦劳来弥补管理层甚至老板吹过的牛或能力上的不足吧。\n\n三石兄似乎已经退居二线了，这也意味着，企业文化精神已经在逐渐衰微，公司已经在“大公司病”这条路上越病越深。\n\n在互联网寒冬的今天，许多中小企业都面临着裁员的艰难抉择，也许他们没办法经营，但为了给员工多一条生路，往往也会想办法给他们一些补偿。当然有一些企业确实拿不出钱，但是他们也会给出承诺。\n\n但网不易的吃相会不会太难看了？连网不易这样的大公司都不给补偿，而是以这么难看的吃相挥舞屠刀，肆意驱赶那些为公司发展做出巨大贡献的优秀员工？那其他的公司还有没有更加恶劣的手段来赶人呢？招人的时候不惜一切代价，赶人的时候，也同样不惜一切代价?企业的商誉难道如此廉价？\n\n出生90后的主角身患需要换心的重病，而大概同样90后的网不易，也需要三石兄出面，给公司来一场换心手术吧。\n\n# 工会\n在我的同学群讨论这个事情时，突然有人抛出了一个问题：工会去哪里了。大概大家都会觉得莫名其妙。虽然在有一部法律《工会法》明确了工会的职能是维系党和人民群众的关系、并维护广大工人阶级的基本利益，而且大部分公司似乎都设立了所谓的工会，但是真的有工会么？\n\n并非如此，工会代表老板的利益，或者说是管理层的利益，其目前的主要职能大概仅仅停留在“收会费、搞茶话会”。工会究竟还有什么用？\n\n期待全国总工会发声。\n\n# 劳动部门\n对于大部分普通群众来说，跟劳动部门似乎没有一丁点关系。\n\n虽然跟公司签署了劳动合同，看似应该受到劳动法的保护，但是当发生劳动纠纷，去劳动仲裁大队申请仲裁时，政府部门的工作方式往往会让人望而生畏。于是宁可自己吃点亏，也不愿意走那么冗长的劳动仲裁流程，毕竟搞不好就需要花大半年的时间，不定期就会接到劳动部门的电话让当事人去仲裁庭处理案子，对于个人来说确实是有点吃不消。\n\n期待劳动部门发声。\n\n我还记得多少年前，农民工的问题引起了政府部门的多次关注，连续好几年的中央一号文件都是关注农民工问题。IT民工呢？毕竟IT产业工人也算是个人所得税的主要纳税群体，难道就不应该引起更多关注？有关部门不要只想着GDP、招商引资、课税，而不想着如何维护劳动者的利益啊。\n\n# 结语\n城隍庙的西洋镜，看透百年，看透世间百态。\n\n网不易裁员事件，透过这个事件，我们看到了来自互联网时代的独特魅力，国民早已不再停留在鲁迅书中说过的矇昧和无知的区区看客，而是掌握了更多的方法，足以产生更加深远的影响力。\n\n使其生、使其亡。摧枯拉朽，谁能阻挡？\n\n时代在进步，那些该破灭的就让他破灭吧。\n\n由于时间仓促，胡言乱语，还请诸君一笑。\n\n","slug":"随笔/网易事件背后众生相","published":1,"updated":"2019-12-01T10:56:20.399Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt9s004un4vixm29vilr","content":"<p>十一月初拖家带口去了上海，到了著名的城隍庙参观，无意中看到了一个仅出现在历史书上的古老物件“西洋镜”，仿佛跨越百年，来到那个如裹脚布般冗长而乏味的古老年代，看到了一群有一群卑微的小民在生活的裹挟之下，对外界充满兴趣，并透过一个西洋镜来看看外面的世界。对于古老时代的他们而言，西洋镜里的一切都充满稀奇。</p>\n<p><img src=\"https://uploader.shimo.im/f/lsExqdP5K40rAqM2.png!thumbnail\" alt=\"图片\"></p>\n<p>有时候，今天的互联网就像西洋镜。</p>\n<p>今天，制度的优越性让我们取得了经济上的飞速成长，互联网技术拉近了彼此的距离，也容易打破隔阂，原来或许发生在与自己无关世界的事情，总是很容易的就让我们产生同理心。</p>\n<p><img src=\"https://uploader.shimo.im/f/eNIdyrdU3M4PbZKA.png!thumbnail\" alt=\"图片\"></p>\n<p>《前网不易员工发文称患病后遭遇公司“暴力裁员”》引起了轩然大波，随着网不易拿出了更多的论点，也让事件掀起了小高潮，我想换一个角度来考虑一下问题，分析一下在事件中那些出现了的，或没出现的人群。</p>\n<h1 id=\"主角：\"><a href=\"#主角：\" class=\"headerlink\" title=\"主角：\"></a>主角：</h1><p>主角J是一位90后，拥有上海交大的学历，是职场上最走俏的优秀资源。而且业余运营了自己的公众号，文笔朴实简练流畅自然。如此年轻的他，也是企业最受欢迎的优秀成员，假以时日，如果能够善终，一定能谱写一篇非常不错的故事，让大家看到90后是如何快速成长为企业的栋梁人才，为公司创造无穷价值。然而，由于一场身体上的变故，让他的职场之路遇到了困境，而且扩展性心肌炎病症非常严重，最终必须面临换心的痛苦。</p>\n<p>人生之痛，莫过于让白发人送黑发人，难道要让他的父母成为失独老人么。扼腕叹息。</p>\n<h1 id=\"主管和人事：\"><a href=\"#主管和人事：\" class=\"headerlink\" title=\"主管和人事：\"></a>主管和人事：</h1><p>在这个事件中，作为第一当事人的主管自然而然会成为焦点，甚至“网红”，即便他不想如此。</p>\n<p>当然，我们都知道，他的谈话是代表公司谈话的，所以他以为他的立场也同样代表了公司立场，嗯，那一刻他一定以为他是三石附体，公司要裁员，是裁掉那些劳动生产力低或者如大东子说的“性价比低”的员工，哪怕他生病了，也应该毫不犹豫的挥起屠刀，不能放过任何一个不能跟公司共同奋斗的人。于是他这么做了，并且他成功了。</p>\n<p>而人力资源部门显然是这件事情背后的幕后真凶，公司说要裁减人员，而作为裁员的直接被考核部门，自然而然要冲在最前面。</p>\n<p>在职场中，许多人都信奉这样的哲学：大家都是成年人，人性是什么重要么？难道还有什么比KPI更重要的么？</p>\n<p><img src=\"https://uploader.shimo.im/f/4q8Af3sOgGsHZibc.png!thumbnail\" alt=\"图片\"></p>\n<h1 id=\"三石兄：\"><a href=\"#三石兄：\" class=\"headerlink\" title=\"三石兄：\"></a>三石兄：</h1><p>说实话，网不易的发展历史对于80后的我来说一度是一个非常古老的故事，就像昔日《硅谷之火》一般，指引着我走上了IT这条道路，并成为一位普通码农。但是吃到了互联网时代的红利，却在移动互联网时代开始逐渐走下坡路了。</p>\n<p>而且网不易和微软中国、金山一样被成为中国互联网的黄埔军校，从网不易毕业的许多创业者，他们创造出许多优秀的产品，也深深的影响着我们。</p>\n<p>当然，黄埔军校其实对于公司本身来说，并非是个非常好听的名词，因为他代表着公司能够培养人，但是却不能留住人。用《浪潮之巅》中的一句话来说，要看一家公司是好还是坏，就看是优秀的人才流入还是流出。每一个优秀的人员流失，对一家大公司来说看起来没什么，但是往往意味着公司的吸引力在逐渐下降。</p>\n<p>经济学中有一个“劣币驱逐良币”的现象，对于一家无法维持积极发展的企业，也往往会面临这样的现象。优秀的人才流失之后，往往留下来的是最能体会企业文化精神、并能在肉体上跟公司在一起的人。</p>\n<p>嗯，肉体上跟公司在一起的人似乎更能理解企业管理的规则，并愿意花时间熬工时。年初马云说996是福报时，大家都在吐槽说资本家的本质彰显无疑，但是实际上还有更多IT公司其实是维持着更长的小时，每天只上9个小时，确实是一种福报啊。好吧，对于大部分公司而言，加班，其实是为了靠苦劳来弥补管理层甚至老板吹过的牛或能力上的不足吧。</p>\n<p>三石兄似乎已经退居二线了，这也意味着，企业文化精神已经在逐渐衰微，公司已经在“大公司病”这条路上越病越深。</p>\n<p>在互联网寒冬的今天，许多中小企业都面临着裁员的艰难抉择，也许他们没办法经营，但为了给员工多一条生路，往往也会想办法给他们一些补偿。当然有一些企业确实拿不出钱，但是他们也会给出承诺。</p>\n<p>但网不易的吃相会不会太难看了？连网不易这样的大公司都不给补偿，而是以这么难看的吃相挥舞屠刀，肆意驱赶那些为公司发展做出巨大贡献的优秀员工？那其他的公司还有没有更加恶劣的手段来赶人呢？招人的时候不惜一切代价，赶人的时候，也同样不惜一切代价?企业的商誉难道如此廉价？</p>\n<p>出生90后的主角身患需要换心的重病，而大概同样90后的网不易，也需要三石兄出面，给公司来一场换心手术吧。</p>\n<h1 id=\"工会\"><a href=\"#工会\" class=\"headerlink\" title=\"工会\"></a>工会</h1><p>在我的同学群讨论这个事情时，突然有人抛出了一个问题：工会去哪里了。大概大家都会觉得莫名其妙。虽然在有一部法律《工会法》明确了工会的职能是维系党和人民群众的关系、并维护广大工人阶级的基本利益，而且大部分公司似乎都设立了所谓的工会，但是真的有工会么？</p>\n<p>并非如此，工会代表老板的利益，或者说是管理层的利益，其目前的主要职能大概仅仅停留在“收会费、搞茶话会”。工会究竟还有什么用？</p>\n<p>期待全国总工会发声。</p>\n<h1 id=\"劳动部门\"><a href=\"#劳动部门\" class=\"headerlink\" title=\"劳动部门\"></a>劳动部门</h1><p>对于大部分普通群众来说，跟劳动部门似乎没有一丁点关系。</p>\n<p>虽然跟公司签署了劳动合同，看似应该受到劳动法的保护，但是当发生劳动纠纷，去劳动仲裁大队申请仲裁时，政府部门的工作方式往往会让人望而生畏。于是宁可自己吃点亏，也不愿意走那么冗长的劳动仲裁流程，毕竟搞不好就需要花大半年的时间，不定期就会接到劳动部门的电话让当事人去仲裁庭处理案子，对于个人来说确实是有点吃不消。</p>\n<p>期待劳动部门发声。</p>\n<p>我还记得多少年前，农民工的问题引起了政府部门的多次关注，连续好几年的中央一号文件都是关注农民工问题。IT民工呢？毕竟IT产业工人也算是个人所得税的主要纳税群体，难道就不应该引起更多关注？有关部门不要只想着GDP、招商引资、课税，而不想着如何维护劳动者的利益啊。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>城隍庙的西洋镜，看透百年，看透世间百态。</p>\n<p>网不易裁员事件，透过这个事件，我们看到了来自互联网时代的独特魅力，国民早已不再停留在鲁迅书中说过的矇昧和无知的区区看客，而是掌握了更多的方法，足以产生更加深远的影响力。</p>\n<p>使其生、使其亡。摧枯拉朽，谁能阻挡？</p>\n<p>时代在进步，那些该破灭的就让他破灭吧。</p>\n<p>由于时间仓促，胡言乱语，还请诸君一笑。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>十一月初拖家带口去了上海，到了著名的城隍庙参观，无意中看到了一个仅出现在历史书上的古老物件“西洋镜”，仿佛跨越百年，来到那个如裹脚布般冗长而乏味的古老年代，看到了一群有一群卑微的小民在生活的裹挟之下，对外界充满兴趣，并透过一个西洋镜来看看外面的世界。对于古老时代的他们而言，西洋镜里的一切都充满稀奇。</p>\n<p><img src=\"https://uploader.shimo.im/f/lsExqdP5K40rAqM2.png!thumbnail\" alt=\"图片\"></p>\n<p>有时候，今天的互联网就像西洋镜。</p>\n<p>今天，制度的优越性让我们取得了经济上的飞速成长，互联网技术拉近了彼此的距离，也容易打破隔阂，原来或许发生在与自己无关世界的事情，总是很容易的就让我们产生同理心。</p>\n<p><img src=\"https://uploader.shimo.im/f/eNIdyrdU3M4PbZKA.png!thumbnail\" alt=\"图片\"></p>\n<p>《前网不易员工发文称患病后遭遇公司“暴力裁员”》引起了轩然大波，随着网不易拿出了更多的论点，也让事件掀起了小高潮，我想换一个角度来考虑一下问题，分析一下在事件中那些出现了的，或没出现的人群。</p>\n<h1 id=\"主角：\"><a href=\"#主角：\" class=\"headerlink\" title=\"主角：\"></a>主角：</h1><p>主角J是一位90后，拥有上海交大的学历，是职场上最走俏的优秀资源。而且业余运营了自己的公众号，文笔朴实简练流畅自然。如此年轻的他，也是企业最受欢迎的优秀成员，假以时日，如果能够善终，一定能谱写一篇非常不错的故事，让大家看到90后是如何快速成长为企业的栋梁人才，为公司创造无穷价值。然而，由于一场身体上的变故，让他的职场之路遇到了困境，而且扩展性心肌炎病症非常严重，最终必须面临换心的痛苦。</p>\n<p>人生之痛，莫过于让白发人送黑发人，难道要让他的父母成为失独老人么。扼腕叹息。</p>\n<h1 id=\"主管和人事：\"><a href=\"#主管和人事：\" class=\"headerlink\" title=\"主管和人事：\"></a>主管和人事：</h1><p>在这个事件中，作为第一当事人的主管自然而然会成为焦点，甚至“网红”，即便他不想如此。</p>\n<p>当然，我们都知道，他的谈话是代表公司谈话的，所以他以为他的立场也同样代表了公司立场，嗯，那一刻他一定以为他是三石附体，公司要裁员，是裁掉那些劳动生产力低或者如大东子说的“性价比低”的员工，哪怕他生病了，也应该毫不犹豫的挥起屠刀，不能放过任何一个不能跟公司共同奋斗的人。于是他这么做了，并且他成功了。</p>\n<p>而人力资源部门显然是这件事情背后的幕后真凶，公司说要裁减人员，而作为裁员的直接被考核部门，自然而然要冲在最前面。</p>\n<p>在职场中，许多人都信奉这样的哲学：大家都是成年人，人性是什么重要么？难道还有什么比KPI更重要的么？</p>\n<p><img src=\"https://uploader.shimo.im/f/4q8Af3sOgGsHZibc.png!thumbnail\" alt=\"图片\"></p>\n<h1 id=\"三石兄：\"><a href=\"#三石兄：\" class=\"headerlink\" title=\"三石兄：\"></a>三石兄：</h1><p>说实话，网不易的发展历史对于80后的我来说一度是一个非常古老的故事，就像昔日《硅谷之火》一般，指引着我走上了IT这条道路，并成为一位普通码农。但是吃到了互联网时代的红利，却在移动互联网时代开始逐渐走下坡路了。</p>\n<p>而且网不易和微软中国、金山一样被成为中国互联网的黄埔军校，从网不易毕业的许多创业者，他们创造出许多优秀的产品，也深深的影响着我们。</p>\n<p>当然，黄埔军校其实对于公司本身来说，并非是个非常好听的名词，因为他代表着公司能够培养人，但是却不能留住人。用《浪潮之巅》中的一句话来说，要看一家公司是好还是坏，就看是优秀的人才流入还是流出。每一个优秀的人员流失，对一家大公司来说看起来没什么，但是往往意味着公司的吸引力在逐渐下降。</p>\n<p>经济学中有一个“劣币驱逐良币”的现象，对于一家无法维持积极发展的企业，也往往会面临这样的现象。优秀的人才流失之后，往往留下来的是最能体会企业文化精神、并能在肉体上跟公司在一起的人。</p>\n<p>嗯，肉体上跟公司在一起的人似乎更能理解企业管理的规则，并愿意花时间熬工时。年初马云说996是福报时，大家都在吐槽说资本家的本质彰显无疑，但是实际上还有更多IT公司其实是维持着更长的小时，每天只上9个小时，确实是一种福报啊。好吧，对于大部分公司而言，加班，其实是为了靠苦劳来弥补管理层甚至老板吹过的牛或能力上的不足吧。</p>\n<p>三石兄似乎已经退居二线了，这也意味着，企业文化精神已经在逐渐衰微，公司已经在“大公司病”这条路上越病越深。</p>\n<p>在互联网寒冬的今天，许多中小企业都面临着裁员的艰难抉择，也许他们没办法经营，但为了给员工多一条生路，往往也会想办法给他们一些补偿。当然有一些企业确实拿不出钱，但是他们也会给出承诺。</p>\n<p>但网不易的吃相会不会太难看了？连网不易这样的大公司都不给补偿，而是以这么难看的吃相挥舞屠刀，肆意驱赶那些为公司发展做出巨大贡献的优秀员工？那其他的公司还有没有更加恶劣的手段来赶人呢？招人的时候不惜一切代价，赶人的时候，也同样不惜一切代价?企业的商誉难道如此廉价？</p>\n<p>出生90后的主角身患需要换心的重病，而大概同样90后的网不易，也需要三石兄出面，给公司来一场换心手术吧。</p>\n<h1 id=\"工会\"><a href=\"#工会\" class=\"headerlink\" title=\"工会\"></a>工会</h1><p>在我的同学群讨论这个事情时，突然有人抛出了一个问题：工会去哪里了。大概大家都会觉得莫名其妙。虽然在有一部法律《工会法》明确了工会的职能是维系党和人民群众的关系、并维护广大工人阶级的基本利益，而且大部分公司似乎都设立了所谓的工会，但是真的有工会么？</p>\n<p>并非如此，工会代表老板的利益，或者说是管理层的利益，其目前的主要职能大概仅仅停留在“收会费、搞茶话会”。工会究竟还有什么用？</p>\n<p>期待全国总工会发声。</p>\n<h1 id=\"劳动部门\"><a href=\"#劳动部门\" class=\"headerlink\" title=\"劳动部门\"></a>劳动部门</h1><p>对于大部分普通群众来说，跟劳动部门似乎没有一丁点关系。</p>\n<p>虽然跟公司签署了劳动合同，看似应该受到劳动法的保护，但是当发生劳动纠纷，去劳动仲裁大队申请仲裁时，政府部门的工作方式往往会让人望而生畏。于是宁可自己吃点亏，也不愿意走那么冗长的劳动仲裁流程，毕竟搞不好就需要花大半年的时间，不定期就会接到劳动部门的电话让当事人去仲裁庭处理案子，对于个人来说确实是有点吃不消。</p>\n<p>期待劳动部门发声。</p>\n<p>我还记得多少年前，农民工的问题引起了政府部门的多次关注，连续好几年的中央一号文件都是关注农民工问题。IT民工呢？毕竟IT产业工人也算是个人所得税的主要纳税群体，难道就不应该引起更多关注？有关部门不要只想着GDP、招商引资、课税，而不想着如何维护劳动者的利益啊。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>城隍庙的西洋镜，看透百年，看透世间百态。</p>\n<p>网不易裁员事件，透过这个事件，我们看到了来自互联网时代的独特魅力，国民早已不再停留在鲁迅书中说过的矇昧和无知的区区看客，而是掌握了更多的方法，足以产生更加深远的影响力。</p>\n<p>使其生、使其亡。摧枯拉朽，谁能阻挡？</p>\n<p>时代在进步，那些该破灭的就让他破灭吧。</p>\n<p>由于时间仓促，胡言乱语，还请诸君一笑。</p>\n"},{"title":"那个程序员，为什么选择改行_","date":"2020-04-17T14:28:00.000Z","author":"邹溪源","_content":"# 一\n有一天，一位同事跟我说：老w已经改行做美缝去了，你怎么看？\n\n我想了想，说：他大概终于做出了眼下最符合他的选择。\n\n# 二\n老w是我曾经一位同事。\n\n还记得2014年面试的时候第一次遇到他，当时的他精力旺盛，充满干劲。大概是因为他上一段职场中获得了他认为非常充足的收获，所以找工作的时候，心态也非常积极乐观，这也让面试的过程很轻松愉悦，技术问题一问一个准。\n\n这应该是一个能够为公司创造价值的优秀开发者吧！当时，我这样想，于是毫不犹豫的告知领导，让领导把老w留下来。\n\n被公司招进来之后，他也表现出他的足够专业，使得他能够在这段工作中平滑发展，获得让大家满意的评价。\n\n如果没有其他意外，大概他将从这里起步，在星城长沙好好发展，直到有一天不再适合IT为止。（而那一天，也许得42岁之后吧）。\n\n后来，我从这家公司离开若干年后，与他在一家初创公司相聚。\n\n# 三\n老w来到这里有不少原因。首先原公司项目回款陷入僵持状态，管理层和董事会出现了重大分歧，董事会已经无意于维持公司的进一步发展，进而导致了严重的经济问题，那几个月员工的工资和公积金已经无法按时间缴纳。而老w本身也自我感觉技术到了瓶颈，打算换一个岗位来提升自己，但是原公司的发展困境显然无法给他创造适当的机会。\n\n于是当有人挖他时，他顺势就把工作辞了，来到了这家新成立的公司。\n\n老板很慷慨，看到他是一位经验丰富的开发者，并没有给他安排试用期，而是入职就直接成为正式员工。加入公司的前几个月有点像蜜月期，他和部门经理之间经常对技术进行探讨。由于部门经理主要从事嵌入式系统开发，对互联网技术几乎不懂，老w则也算是从业老兵，虽然基础不扎实，但还能勉强应付部门经理的问题，所以双方的沟通比较融洽。\n\n他们部门的产品也主要是偏物联网的智慧监测管理平台，需要运用嵌入式技术开发设备上的组件，并通过Web平台来展示数据的状态信息。而老W之前并不了解物联网相关领域，但在Web开发领域还是有一点点积累，能够勉强把自己手头上的任务完成妥当。\n\n然而，在初创公司做产品并非只是干好那一亩三分地就够了。他和大部分拥有一定经验的所谓高级开发者一样，总是觉得干好技术就是自己的本份，对业务知识不太在乎。而物联网行业需要太多的行业基础，如果不能深入行业，几乎很难做出成熟的产品。\n\n随着项目的逐渐深入，也完美暴露出老w的技术短板。他已经工作了六七年，但是平时主要负责增删改查，对前端页面和框架底层几乎很少涉及，他本身缺乏主动学习的积极性和创造性，对新技术和前端技术缺乏兴趣和敏感度，甚至连搜索查找问题的能力也很欠缺，这使得他得花许多精力来学习框架知识，并间接导致项目速度进展缓慢。\n\n原本计划三个月做一个小产品，但由于种种原因，以及后来的迭代，硬生生五六个月才完成。在产品终于做完开始正式运行之后，由于后台代码存在的缺陷比较多，部门经理对他大为失望。于是被调到其他部门当研发工程师，但在新的工作岗位上，他很快就暴露出自己无法胜任相关岗位的能力，又回到了原部门。\n\n原部门已经没有他的工作安排了，从此他陷入了长达一个多月的清闲期。这段时间，他也没去找工作，每天朝九晚五，上上网，看看电影，由于他本身就对技术兴趣不足，自然而然也不会踏踏实实补足短板，于是安安稳稳的在公司混了好几个月。\n\n2018年过完年，就从公司离开。之后听说他前前后后找了好几轮工作，但都没能好好的干下去。听说他曾经一度打算选择成为独立开发者，却接不到什么好项目，有的项目完全是费力不讨好，付出了许多努力，却交货时被客户打回。\n\n所以最终选择改行也是万般无奈。\n\n# 四\n老w的职业发展历程总是令我扼腕叹息。虽然程序员转行很正常，但他年轻时也算是精力充沛，对技术充满激情，却为何刚过而立之年就不得不离开行业？要想维持职场长久的生命力，究竟该做哪些努力？这个问题想必已经深深的困扰着许多人。\n\n在我们的身边，有许多这样或那样的人选择IT行业，选择成为程序员。也许大家选择成为程序员的理由不尽相同，但是大家的学习曲线或许却大体类似。这种学习曲线，大概有点像“达克效应”曲线一般魔幻真实。\n\n![图片](https://uploader.shimo.im/f/WXL0JugXKFISHNSP.png!thumbnail)\n\n（达克效应）\n\n用来描述一种认知偏差。它表明，能力差的人总是有一种虚幻的自我优越感，他们总是错误的以为自己比真实的自己更优越。\n\n在这个效应中，将一个人求知的阶段划分为四个阶段：\n\n1、不知道自己不知道。\n\n这一阶段是我们刚刚加入职场的时候，由于眼界和见识的限制，我们将在较短的时间内获得完成短期工作所需的部分知识。这些知识使得我们在短期内自我膨胀，然后心态发生改变，渐渐的成为“愚昧山峰”上的一块顽固之石。过早的登上愚昧之山，对每个开发者来说都不是一件好事情，这意味着你或者你们公司所在行业的天花板太低、或者你的见识太低，使得你过于轻易的就掌握了驾驭当前应用场景的知识，如果不做出改变，将为未来埋下祸根。\n\n2、知道自己不知道。\n\n新技术的发展是如此的突飞猛进，当你还在睡安稳觉时，或许一不小心就被淘汰了。许多“顽固之石”对于新技术的出现，总是抱有成见，甚至会习惯于用自己的固有思想来思考问题。于是在市场面前，一旦遇到一波有一波的挫折，并陷入绝望之谷。\n\n3、知道自己知道\n\n绝望之谷，或使人逃离，或使人成长。\n\n前面故事提到的老w，就是逃离的典型。由于其固有习惯和见识，让他遇到新技术、新应用场景带来的挑战时，总是选择像海龟一样，把自己深藏在一个“壳”中，并且甚至逃避问题，最终只能在一波有一波的挫折面前，选择离开行业。\n\n还有一些人，他们会以过去的挫折为跳板，然后不断的学习，进入“开悟之谷”。这个阶段才是智慧形成的阶段，这意味着你过去的从业经验和知识将成为你成长的宝贵财富。\n\n4、不知道自己知道。\n\n如果始终保持积极乐观和空杯的心态，你掌握的知识也将越来越多，你所散发出的知识的馥郁，也将促使你能够成为身边人学习的榜样，并将促使你成为真正的“大师”。\n\n# 五\n在我们的身边，被类似“达克效应”困扰的现象其实无处不在。拿笔者为例，曾经有一段时间，我经常写博客，还以为自己的博客写得挺有文采的。后来读了许多书，发现自己简直就是可以称为“无知”，于是花了更多的时间来提高自己。\n\n作为开发者也许都将如此，你所知道的越多，其实意味着不知道的越多。每一次你以为大彻大悟，以为道理不过如此，但是往往随着你学习的进一步深入，只会使你更加清楚自己的愚昧。\n\n一次又一次探索中，不断的发现自己的无知，看似在浪费时间，其实是在不断的扎根。人生的每一次成长，从不是一蹴而就，而是像攀登高峰一般，一步一步脚印，每一步都得踏踏实实。\n\n你今天的积累，既是你过去的沉淀，更是适应未来变化的踏脚石。\n\n\n\n\n\n\n","source":"_posts/随笔/那个程序员，为什么选择改行_.md","raw":"---\ntitle:  那个程序员，为什么选择改行_\ndate: 2020-4-17 22:28\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n# 一\n有一天，一位同事跟我说：老w已经改行做美缝去了，你怎么看？\n\n我想了想，说：他大概终于做出了眼下最符合他的选择。\n\n# 二\n老w是我曾经一位同事。\n\n还记得2014年面试的时候第一次遇到他，当时的他精力旺盛，充满干劲。大概是因为他上一段职场中获得了他认为非常充足的收获，所以找工作的时候，心态也非常积极乐观，这也让面试的过程很轻松愉悦，技术问题一问一个准。\n\n这应该是一个能够为公司创造价值的优秀开发者吧！当时，我这样想，于是毫不犹豫的告知领导，让领导把老w留下来。\n\n被公司招进来之后，他也表现出他的足够专业，使得他能够在这段工作中平滑发展，获得让大家满意的评价。\n\n如果没有其他意外，大概他将从这里起步，在星城长沙好好发展，直到有一天不再适合IT为止。（而那一天，也许得42岁之后吧）。\n\n后来，我从这家公司离开若干年后，与他在一家初创公司相聚。\n\n# 三\n老w来到这里有不少原因。首先原公司项目回款陷入僵持状态，管理层和董事会出现了重大分歧，董事会已经无意于维持公司的进一步发展，进而导致了严重的经济问题，那几个月员工的工资和公积金已经无法按时间缴纳。而老w本身也自我感觉技术到了瓶颈，打算换一个岗位来提升自己，但是原公司的发展困境显然无法给他创造适当的机会。\n\n于是当有人挖他时，他顺势就把工作辞了，来到了这家新成立的公司。\n\n老板很慷慨，看到他是一位经验丰富的开发者，并没有给他安排试用期，而是入职就直接成为正式员工。加入公司的前几个月有点像蜜月期，他和部门经理之间经常对技术进行探讨。由于部门经理主要从事嵌入式系统开发，对互联网技术几乎不懂，老w则也算是从业老兵，虽然基础不扎实，但还能勉强应付部门经理的问题，所以双方的沟通比较融洽。\n\n他们部门的产品也主要是偏物联网的智慧监测管理平台，需要运用嵌入式技术开发设备上的组件，并通过Web平台来展示数据的状态信息。而老W之前并不了解物联网相关领域，但在Web开发领域还是有一点点积累，能够勉强把自己手头上的任务完成妥当。\n\n然而，在初创公司做产品并非只是干好那一亩三分地就够了。他和大部分拥有一定经验的所谓高级开发者一样，总是觉得干好技术就是自己的本份，对业务知识不太在乎。而物联网行业需要太多的行业基础，如果不能深入行业，几乎很难做出成熟的产品。\n\n随着项目的逐渐深入，也完美暴露出老w的技术短板。他已经工作了六七年，但是平时主要负责增删改查，对前端页面和框架底层几乎很少涉及，他本身缺乏主动学习的积极性和创造性，对新技术和前端技术缺乏兴趣和敏感度，甚至连搜索查找问题的能力也很欠缺，这使得他得花许多精力来学习框架知识，并间接导致项目速度进展缓慢。\n\n原本计划三个月做一个小产品，但由于种种原因，以及后来的迭代，硬生生五六个月才完成。在产品终于做完开始正式运行之后，由于后台代码存在的缺陷比较多，部门经理对他大为失望。于是被调到其他部门当研发工程师，但在新的工作岗位上，他很快就暴露出自己无法胜任相关岗位的能力，又回到了原部门。\n\n原部门已经没有他的工作安排了，从此他陷入了长达一个多月的清闲期。这段时间，他也没去找工作，每天朝九晚五，上上网，看看电影，由于他本身就对技术兴趣不足，自然而然也不会踏踏实实补足短板，于是安安稳稳的在公司混了好几个月。\n\n2018年过完年，就从公司离开。之后听说他前前后后找了好几轮工作，但都没能好好的干下去。听说他曾经一度打算选择成为独立开发者，却接不到什么好项目，有的项目完全是费力不讨好，付出了许多努力，却交货时被客户打回。\n\n所以最终选择改行也是万般无奈。\n\n# 四\n老w的职业发展历程总是令我扼腕叹息。虽然程序员转行很正常，但他年轻时也算是精力充沛，对技术充满激情，却为何刚过而立之年就不得不离开行业？要想维持职场长久的生命力，究竟该做哪些努力？这个问题想必已经深深的困扰着许多人。\n\n在我们的身边，有许多这样或那样的人选择IT行业，选择成为程序员。也许大家选择成为程序员的理由不尽相同，但是大家的学习曲线或许却大体类似。这种学习曲线，大概有点像“达克效应”曲线一般魔幻真实。\n\n![图片](https://uploader.shimo.im/f/WXL0JugXKFISHNSP.png!thumbnail)\n\n（达克效应）\n\n用来描述一种认知偏差。它表明，能力差的人总是有一种虚幻的自我优越感，他们总是错误的以为自己比真实的自己更优越。\n\n在这个效应中，将一个人求知的阶段划分为四个阶段：\n\n1、不知道自己不知道。\n\n这一阶段是我们刚刚加入职场的时候，由于眼界和见识的限制，我们将在较短的时间内获得完成短期工作所需的部分知识。这些知识使得我们在短期内自我膨胀，然后心态发生改变，渐渐的成为“愚昧山峰”上的一块顽固之石。过早的登上愚昧之山，对每个开发者来说都不是一件好事情，这意味着你或者你们公司所在行业的天花板太低、或者你的见识太低，使得你过于轻易的就掌握了驾驭当前应用场景的知识，如果不做出改变，将为未来埋下祸根。\n\n2、知道自己不知道。\n\n新技术的发展是如此的突飞猛进，当你还在睡安稳觉时，或许一不小心就被淘汰了。许多“顽固之石”对于新技术的出现，总是抱有成见，甚至会习惯于用自己的固有思想来思考问题。于是在市场面前，一旦遇到一波有一波的挫折，并陷入绝望之谷。\n\n3、知道自己知道\n\n绝望之谷，或使人逃离，或使人成长。\n\n前面故事提到的老w，就是逃离的典型。由于其固有习惯和见识，让他遇到新技术、新应用场景带来的挑战时，总是选择像海龟一样，把自己深藏在一个“壳”中，并且甚至逃避问题，最终只能在一波有一波的挫折面前，选择离开行业。\n\n还有一些人，他们会以过去的挫折为跳板，然后不断的学习，进入“开悟之谷”。这个阶段才是智慧形成的阶段，这意味着你过去的从业经验和知识将成为你成长的宝贵财富。\n\n4、不知道自己知道。\n\n如果始终保持积极乐观和空杯的心态，你掌握的知识也将越来越多，你所散发出的知识的馥郁，也将促使你能够成为身边人学习的榜样，并将促使你成为真正的“大师”。\n\n# 五\n在我们的身边，被类似“达克效应”困扰的现象其实无处不在。拿笔者为例，曾经有一段时间，我经常写博客，还以为自己的博客写得挺有文采的。后来读了许多书，发现自己简直就是可以称为“无知”，于是花了更多的时间来提高自己。\n\n作为开发者也许都将如此，你所知道的越多，其实意味着不知道的越多。每一次你以为大彻大悟，以为道理不过如此，但是往往随着你学习的进一步深入，只会使你更加清楚自己的愚昧。\n\n一次又一次探索中，不断的发现自己的无知，看似在浪费时间，其实是在不断的扎根。人生的每一次成长，从不是一蹴而就，而是像攀登高峰一般，一步一步脚印，每一步都得踏踏实实。\n\n你今天的积累，既是你过去的沉淀，更是适应未来变化的踏脚石。\n\n\n\n\n\n\n","slug":"随笔/那个程序员，为什么选择改行_","published":1,"updated":"2020-05-26T11:35:09.568Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt9u004xn4vibm452tus","content":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>有一天，一位同事跟我说：老w已经改行做美缝去了，你怎么看？</p>\n<p>我想了想，说：他大概终于做出了眼下最符合他的选择。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>老w是我曾经一位同事。</p>\n<p>还记得2014年面试的时候第一次遇到他，当时的他精力旺盛，充满干劲。大概是因为他上一段职场中获得了他认为非常充足的收获，所以找工作的时候，心态也非常积极乐观，这也让面试的过程很轻松愉悦，技术问题一问一个准。</p>\n<p>这应该是一个能够为公司创造价值的优秀开发者吧！当时，我这样想，于是毫不犹豫的告知领导，让领导把老w留下来。</p>\n<p>被公司招进来之后，他也表现出他的足够专业，使得他能够在这段工作中平滑发展，获得让大家满意的评价。</p>\n<p>如果没有其他意外，大概他将从这里起步，在星城长沙好好发展，直到有一天不再适合IT为止。（而那一天，也许得42岁之后吧）。</p>\n<p>后来，我从这家公司离开若干年后，与他在一家初创公司相聚。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>老w来到这里有不少原因。首先原公司项目回款陷入僵持状态，管理层和董事会出现了重大分歧，董事会已经无意于维持公司的进一步发展，进而导致了严重的经济问题，那几个月员工的工资和公积金已经无法按时间缴纳。而老w本身也自我感觉技术到了瓶颈，打算换一个岗位来提升自己，但是原公司的发展困境显然无法给他创造适当的机会。</p>\n<p>于是当有人挖他时，他顺势就把工作辞了，来到了这家新成立的公司。</p>\n<p>老板很慷慨，看到他是一位经验丰富的开发者，并没有给他安排试用期，而是入职就直接成为正式员工。加入公司的前几个月有点像蜜月期，他和部门经理之间经常对技术进行探讨。由于部门经理主要从事嵌入式系统开发，对互联网技术几乎不懂，老w则也算是从业老兵，虽然基础不扎实，但还能勉强应付部门经理的问题，所以双方的沟通比较融洽。</p>\n<p>他们部门的产品也主要是偏物联网的智慧监测管理平台，需要运用嵌入式技术开发设备上的组件，并通过Web平台来展示数据的状态信息。而老W之前并不了解物联网相关领域，但在Web开发领域还是有一点点积累，能够勉强把自己手头上的任务完成妥当。</p>\n<p>然而，在初创公司做产品并非只是干好那一亩三分地就够了。他和大部分拥有一定经验的所谓高级开发者一样，总是觉得干好技术就是自己的本份，对业务知识不太在乎。而物联网行业需要太多的行业基础，如果不能深入行业，几乎很难做出成熟的产品。</p>\n<p>随着项目的逐渐深入，也完美暴露出老w的技术短板。他已经工作了六七年，但是平时主要负责增删改查，对前端页面和框架底层几乎很少涉及，他本身缺乏主动学习的积极性和创造性，对新技术和前端技术缺乏兴趣和敏感度，甚至连搜索查找问题的能力也很欠缺，这使得他得花许多精力来学习框架知识，并间接导致项目速度进展缓慢。</p>\n<p>原本计划三个月做一个小产品，但由于种种原因，以及后来的迭代，硬生生五六个月才完成。在产品终于做完开始正式运行之后，由于后台代码存在的缺陷比较多，部门经理对他大为失望。于是被调到其他部门当研发工程师，但在新的工作岗位上，他很快就暴露出自己无法胜任相关岗位的能力，又回到了原部门。</p>\n<p>原部门已经没有他的工作安排了，从此他陷入了长达一个多月的清闲期。这段时间，他也没去找工作，每天朝九晚五，上上网，看看电影，由于他本身就对技术兴趣不足，自然而然也不会踏踏实实补足短板，于是安安稳稳的在公司混了好几个月。</p>\n<p>2018年过完年，就从公司离开。之后听说他前前后后找了好几轮工作，但都没能好好的干下去。听说他曾经一度打算选择成为独立开发者，却接不到什么好项目，有的项目完全是费力不讨好，付出了许多努力，却交货时被客户打回。</p>\n<p>所以最终选择改行也是万般无奈。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>老w的职业发展历程总是令我扼腕叹息。虽然程序员转行很正常，但他年轻时也算是精力充沛，对技术充满激情，却为何刚过而立之年就不得不离开行业？要想维持职场长久的生命力，究竟该做哪些努力？这个问题想必已经深深的困扰着许多人。</p>\n<p>在我们的身边，有许多这样或那样的人选择IT行业，选择成为程序员。也许大家选择成为程序员的理由不尽相同，但是大家的学习曲线或许却大体类似。这种学习曲线，大概有点像“达克效应”曲线一般魔幻真实。</p>\n<p><img src=\"https://uploader.shimo.im/f/WXL0JugXKFISHNSP.png!thumbnail\" alt=\"图片\"></p>\n<p>（达克效应）</p>\n<p>用来描述一种认知偏差。它表明，能力差的人总是有一种虚幻的自我优越感，他们总是错误的以为自己比真实的自己更优越。</p>\n<p>在这个效应中，将一个人求知的阶段划分为四个阶段：</p>\n<p>1、不知道自己不知道。</p>\n<p>这一阶段是我们刚刚加入职场的时候，由于眼界和见识的限制，我们将在较短的时间内获得完成短期工作所需的部分知识。这些知识使得我们在短期内自我膨胀，然后心态发生改变，渐渐的成为“愚昧山峰”上的一块顽固之石。过早的登上愚昧之山，对每个开发者来说都不是一件好事情，这意味着你或者你们公司所在行业的天花板太低、或者你的见识太低，使得你过于轻易的就掌握了驾驭当前应用场景的知识，如果不做出改变，将为未来埋下祸根。</p>\n<p>2、知道自己不知道。</p>\n<p>新技术的发展是如此的突飞猛进，当你还在睡安稳觉时，或许一不小心就被淘汰了。许多“顽固之石”对于新技术的出现，总是抱有成见，甚至会习惯于用自己的固有思想来思考问题。于是在市场面前，一旦遇到一波有一波的挫折，并陷入绝望之谷。</p>\n<p>3、知道自己知道</p>\n<p>绝望之谷，或使人逃离，或使人成长。</p>\n<p>前面故事提到的老w，就是逃离的典型。由于其固有习惯和见识，让他遇到新技术、新应用场景带来的挑战时，总是选择像海龟一样，把自己深藏在一个“壳”中，并且甚至逃避问题，最终只能在一波有一波的挫折面前，选择离开行业。</p>\n<p>还有一些人，他们会以过去的挫折为跳板，然后不断的学习，进入“开悟之谷”。这个阶段才是智慧形成的阶段，这意味着你过去的从业经验和知识将成为你成长的宝贵财富。</p>\n<p>4、不知道自己知道。</p>\n<p>如果始终保持积极乐观和空杯的心态，你掌握的知识也将越来越多，你所散发出的知识的馥郁，也将促使你能够成为身边人学习的榜样，并将促使你成为真正的“大师”。</p>\n<h1 id=\"五\"><a href=\"#五\" class=\"headerlink\" title=\"五\"></a>五</h1><p>在我们的身边，被类似“达克效应”困扰的现象其实无处不在。拿笔者为例，曾经有一段时间，我经常写博客，还以为自己的博客写得挺有文采的。后来读了许多书，发现自己简直就是可以称为“无知”，于是花了更多的时间来提高自己。</p>\n<p>作为开发者也许都将如此，你所知道的越多，其实意味着不知道的越多。每一次你以为大彻大悟，以为道理不过如此，但是往往随着你学习的进一步深入，只会使你更加清楚自己的愚昧。</p>\n<p>一次又一次探索中，不断的发现自己的无知，看似在浪费时间，其实是在不断的扎根。人生的每一次成长，从不是一蹴而就，而是像攀登高峰一般，一步一步脚印，每一步都得踏踏实实。</p>\n<p>你今天的积累，既是你过去的沉淀，更是适应未来变化的踏脚石。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>有一天，一位同事跟我说：老w已经改行做美缝去了，你怎么看？</p>\n<p>我想了想，说：他大概终于做出了眼下最符合他的选择。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>老w是我曾经一位同事。</p>\n<p>还记得2014年面试的时候第一次遇到他，当时的他精力旺盛，充满干劲。大概是因为他上一段职场中获得了他认为非常充足的收获，所以找工作的时候，心态也非常积极乐观，这也让面试的过程很轻松愉悦，技术问题一问一个准。</p>\n<p>这应该是一个能够为公司创造价值的优秀开发者吧！当时，我这样想，于是毫不犹豫的告知领导，让领导把老w留下来。</p>\n<p>被公司招进来之后，他也表现出他的足够专业，使得他能够在这段工作中平滑发展，获得让大家满意的评价。</p>\n<p>如果没有其他意外，大概他将从这里起步，在星城长沙好好发展，直到有一天不再适合IT为止。（而那一天，也许得42岁之后吧）。</p>\n<p>后来，我从这家公司离开若干年后，与他在一家初创公司相聚。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>老w来到这里有不少原因。首先原公司项目回款陷入僵持状态，管理层和董事会出现了重大分歧，董事会已经无意于维持公司的进一步发展，进而导致了严重的经济问题，那几个月员工的工资和公积金已经无法按时间缴纳。而老w本身也自我感觉技术到了瓶颈，打算换一个岗位来提升自己，但是原公司的发展困境显然无法给他创造适当的机会。</p>\n<p>于是当有人挖他时，他顺势就把工作辞了，来到了这家新成立的公司。</p>\n<p>老板很慷慨，看到他是一位经验丰富的开发者，并没有给他安排试用期，而是入职就直接成为正式员工。加入公司的前几个月有点像蜜月期，他和部门经理之间经常对技术进行探讨。由于部门经理主要从事嵌入式系统开发，对互联网技术几乎不懂，老w则也算是从业老兵，虽然基础不扎实，但还能勉强应付部门经理的问题，所以双方的沟通比较融洽。</p>\n<p>他们部门的产品也主要是偏物联网的智慧监测管理平台，需要运用嵌入式技术开发设备上的组件，并通过Web平台来展示数据的状态信息。而老W之前并不了解物联网相关领域，但在Web开发领域还是有一点点积累，能够勉强把自己手头上的任务完成妥当。</p>\n<p>然而，在初创公司做产品并非只是干好那一亩三分地就够了。他和大部分拥有一定经验的所谓高级开发者一样，总是觉得干好技术就是自己的本份，对业务知识不太在乎。而物联网行业需要太多的行业基础，如果不能深入行业，几乎很难做出成熟的产品。</p>\n<p>随着项目的逐渐深入，也完美暴露出老w的技术短板。他已经工作了六七年，但是平时主要负责增删改查，对前端页面和框架底层几乎很少涉及，他本身缺乏主动学习的积极性和创造性，对新技术和前端技术缺乏兴趣和敏感度，甚至连搜索查找问题的能力也很欠缺，这使得他得花许多精力来学习框架知识，并间接导致项目速度进展缓慢。</p>\n<p>原本计划三个月做一个小产品，但由于种种原因，以及后来的迭代，硬生生五六个月才完成。在产品终于做完开始正式运行之后，由于后台代码存在的缺陷比较多，部门经理对他大为失望。于是被调到其他部门当研发工程师，但在新的工作岗位上，他很快就暴露出自己无法胜任相关岗位的能力，又回到了原部门。</p>\n<p>原部门已经没有他的工作安排了，从此他陷入了长达一个多月的清闲期。这段时间，他也没去找工作，每天朝九晚五，上上网，看看电影，由于他本身就对技术兴趣不足，自然而然也不会踏踏实实补足短板，于是安安稳稳的在公司混了好几个月。</p>\n<p>2018年过完年，就从公司离开。之后听说他前前后后找了好几轮工作，但都没能好好的干下去。听说他曾经一度打算选择成为独立开发者，却接不到什么好项目，有的项目完全是费力不讨好，付出了许多努力，却交货时被客户打回。</p>\n<p>所以最终选择改行也是万般无奈。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>老w的职业发展历程总是令我扼腕叹息。虽然程序员转行很正常，但他年轻时也算是精力充沛，对技术充满激情，却为何刚过而立之年就不得不离开行业？要想维持职场长久的生命力，究竟该做哪些努力？这个问题想必已经深深的困扰着许多人。</p>\n<p>在我们的身边，有许多这样或那样的人选择IT行业，选择成为程序员。也许大家选择成为程序员的理由不尽相同，但是大家的学习曲线或许却大体类似。这种学习曲线，大概有点像“达克效应”曲线一般魔幻真实。</p>\n<p><img src=\"https://uploader.shimo.im/f/WXL0JugXKFISHNSP.png!thumbnail\" alt=\"图片\"></p>\n<p>（达克效应）</p>\n<p>用来描述一种认知偏差。它表明，能力差的人总是有一种虚幻的自我优越感，他们总是错误的以为自己比真实的自己更优越。</p>\n<p>在这个效应中，将一个人求知的阶段划分为四个阶段：</p>\n<p>1、不知道自己不知道。</p>\n<p>这一阶段是我们刚刚加入职场的时候，由于眼界和见识的限制，我们将在较短的时间内获得完成短期工作所需的部分知识。这些知识使得我们在短期内自我膨胀，然后心态发生改变，渐渐的成为“愚昧山峰”上的一块顽固之石。过早的登上愚昧之山，对每个开发者来说都不是一件好事情，这意味着你或者你们公司所在行业的天花板太低、或者你的见识太低，使得你过于轻易的就掌握了驾驭当前应用场景的知识，如果不做出改变，将为未来埋下祸根。</p>\n<p>2、知道自己不知道。</p>\n<p>新技术的发展是如此的突飞猛进，当你还在睡安稳觉时，或许一不小心就被淘汰了。许多“顽固之石”对于新技术的出现，总是抱有成见，甚至会习惯于用自己的固有思想来思考问题。于是在市场面前，一旦遇到一波有一波的挫折，并陷入绝望之谷。</p>\n<p>3、知道自己知道</p>\n<p>绝望之谷，或使人逃离，或使人成长。</p>\n<p>前面故事提到的老w，就是逃离的典型。由于其固有习惯和见识，让他遇到新技术、新应用场景带来的挑战时，总是选择像海龟一样，把自己深藏在一个“壳”中，并且甚至逃避问题，最终只能在一波有一波的挫折面前，选择离开行业。</p>\n<p>还有一些人，他们会以过去的挫折为跳板，然后不断的学习，进入“开悟之谷”。这个阶段才是智慧形成的阶段，这意味着你过去的从业经验和知识将成为你成长的宝贵财富。</p>\n<p>4、不知道自己知道。</p>\n<p>如果始终保持积极乐观和空杯的心态，你掌握的知识也将越来越多，你所散发出的知识的馥郁，也将促使你能够成为身边人学习的榜样，并将促使你成为真正的“大师”。</p>\n<h1 id=\"五\"><a href=\"#五\" class=\"headerlink\" title=\"五\"></a>五</h1><p>在我们的身边，被类似“达克效应”困扰的现象其实无处不在。拿笔者为例，曾经有一段时间，我经常写博客，还以为自己的博客写得挺有文采的。后来读了许多书，发现自己简直就是可以称为“无知”，于是花了更多的时间来提高自己。</p>\n<p>作为开发者也许都将如此，你所知道的越多，其实意味着不知道的越多。每一次你以为大彻大悟，以为道理不过如此，但是往往随着你学习的进一步深入，只会使你更加清楚自己的愚昧。</p>\n<p>一次又一次探索中，不断的发现自己的无知，看似在浪费时间，其实是在不断的扎根。人生的每一次成长，从不是一蹴而就，而是像攀登高峰一般，一步一步脚印，每一步都得踏踏实实。</p>\n<p>你今天的积累，既是你过去的沉淀，更是适应未来变化的踏脚石。</p>\n"},{"title":"那个年过半百的奋斗者~","date":"2020-04-17T14:28:00.000Z","author":"邹溪源","_content":"# 一\n我曾经提到过最终改行从事美缝行业的老w，他靠自己的“不够努力”，最终离开了行业。\n\n但是，这个世界其实有点讽刺。\n\n在沉迷于安逸小日子的老w每天朝九晚五，只想拿钱，不想干活的那段日子，隔壁的总经理办公室却经常通宵达旦、灯火通明，那位五十五岁的老板Y总，正在为了自己的梦想努力奋斗着。\n\n# 二\n在加入公司之前，我曾经见过一次Y总，那是在一个茶室，跟Y总有过一番简单的沟通后，我打算去公司看看，以便了解公司实际的产品情况。\n\n于是受到技术团队负责人的邀请，我选择了一个阳光明媚的下午，坐上了被当地人称为“最长公交线路”的127路公交车，在那条的弯弯曲曲的公交线路上，折腾了大概一个多小时，终于才来到了目的地，位于当地东北角的某商务写字楼。并再次见到了Y总。\n\n虽然是第二次见到Y总，但是第一次其实只是简单的沟通，并没有仔细打量这位领导。这一次，算是对Y总有了更加深刻的印象。\n\n那是一位两鬓开始逐渐开始冒出白发的中年男子，身体精瘦、精神饱满、看起来充满了力量，他操着一口相对于当地人来说非常纯粹的普通话，给我留下了非常深刻的印象。当听他提起他自己已经55岁时，我的内心泛起了波澜。\n\n这是一位和我的父亲一般年龄的中年人啊~在这个年龄，他居然选择了创业，着实让我大吃一惊。\n\n当然，他显然非常的专业，在简单概要的介绍了公司的创业方向、拥有的背景和资源之后，让我深刻的体会到，他一定是想干一番大事业。\n\n于是，我毫不犹豫的加入了公司，并期待在这里开启职场的新征程。\n\n# 三\n创业公司的发展，总是跌宕起伏，看似波澜不惊，其实暗藏杀机。尤其是选择合适的人才，更是难点中的难点。谁都想选择最优秀的人才，但是在优秀的专业人才和优秀的跨职能型人才间，其实非常难以选择。\n\n还好，本人算是一个勉强称职的跨职能型开发者，在我们部门的经理离职之后，毅然扛起了部门的重担，为公司勉强完成了一个非常不错的项目，使得公司能够获得短暂的喘息之机。\n\n但是老w所在的项目，却面临了巨大的问题。\n\n首先是优秀人才的缺失，毕竟能够深刻领悟如何基于物联网技术构建平台的应用开发者，在当时非常的稀缺，更何况公司所能付出的资源（要钱没钱，要股份没股份）其实非常有限，也显然很难招到合适的人才，而这仅仅只是我所看到的web开发方面，还有更严重的方面是物联网基础技术方面。\n\n说来也搞笑，没有物联网基础技术，又如何做物联网产品呢？其实倒也不完全没有积累，这位老板和物联网部门的负责人曾经参与创办了另外一家非常优秀的物联网公司H公司，他们花了十年时间让这家公司从无到有，到做到国际一流。后来H公司业绩到了瓶颈，他们想为公司开辟新的业务方向，才创建了这家新的物联网公司。但是虽然同是物联网创业方向，但选择的技术路线和实现模式却不尽相同，而在新的技术路线上公司的积累非常浅。而在最关键的时候，拥有核心开发能力的一位嵌入式系统开发者，居然只打了个招呼，连交接和培训新人都没有认真开展就离开了公司，使得公司技术层面面临巨大的断层。\n\n为了完成这个项目，Y总只好自己迎难而上。那段时间他不得不捡起曾经荒废多年的嵌入式系统开发技术，天天加班到深夜。每天早上又最早来到公司，恨不能尽早完成目标。\n\n他就不怕猝死么？显然，他是怕的。但为了公司的生存，其实他别无选择。\n\n# 四\n我曾经冒昧的问过他选择创业的原因，他只是轻轻一笑，还不是为了实现自己创业的梦想？\n\n显然他不愿意过多的描述。但是联想到Y总的职业生涯，我大概能猜到一部分原因。\n\nY总虽然是北方人，但是在这片热土已经呆了三十几年。八十年代在第一大学就读的Y总，年轻时学习成绩特别好，不仅保送本校研究生，还直博，方向是某个热门的领域。当博士毕业后，也许他也曾想去沿海地区发展，但是他最终留下来主导该校的某领域的学术研究。\n\n又过了几年，市场经济放开的九十年代，他也有许多选择的机会。在该领域浸淫十几年的他，一定收到了许多沿海企业或外资企业的聘书，但是他并没有做出这样的选择。\n\n又过了十年，四十岁，他已经决定放开手脚出去干一场时，又是家庭压力最大的时候。也许去沿海城市会让他家庭和事业难以兼顾，他最终还是没有迈出哪一步。\n\n一晃五十岁，他从学校退休。子女也出过留学，得到了顶级互联网公司的offer，基本上算是没什么压力了。\n\n也许，从二十几岁到五十几岁，他错过了太多的机会。\n\n他也曾经偶尔提到那些跟他一起读书的同学，或者研究所的同事，在离开象牙塔后，有的加入了互联网公司花了十年时间获得了财富自由，有的甚至创办了挺不错的公司。\n\nY总虽然也曾参与了一家公司的创办过程，却并没有从零开始创办一家属于自己的公司，而且他自认为这家公司虽然业务还算稳定，但在技术上，不能算卓越，只能算优秀。由于没有赶上风口，所以做得非常费力；而且行业领域非常狭小，很难获得更大的发展。\n\n他显然想挑战自己。\n\n# 五\n然而，创业难，难于上青天。\n\n我也最终选择了离开这家公司。依稀记得Y总说过的话：“人生短短80年，其中从二十几岁毕业到六十多岁退休，期间有四十年时间。如果抱着把行业当做一辈子的心态，就该前二十年学经验，后二十年才能有经验可以用。”\n\n当然，没有任何一个人敢说自己的技能能够通吃一辈子，也不可能每个人都会在一个公司、一份工作上干一辈子，变化才是人生的常态。适应变化和主动学习，正是人的基本能力。尤其是程序员，有许多程序员能够花十年赚到二十年才能赚到的钱，但是之后呢？年纪轻轻三十岁就养老吗？\n\n学习这条路，其实根本没有终点。\n\n\n\n","source":"_posts/随笔/那位五十多岁的创业者给我的启示.md","raw":"---\ntitle:  那个年过半百的奋斗者~\ndate: 2020-4-17 22:28\ntags: 随笔\nauthor: 邹溪源\ncategories:\n  - 随笔\n---\n# 一\n我曾经提到过最终改行从事美缝行业的老w，他靠自己的“不够努力”，最终离开了行业。\n\n但是，这个世界其实有点讽刺。\n\n在沉迷于安逸小日子的老w每天朝九晚五，只想拿钱，不想干活的那段日子，隔壁的总经理办公室却经常通宵达旦、灯火通明，那位五十五岁的老板Y总，正在为了自己的梦想努力奋斗着。\n\n# 二\n在加入公司之前，我曾经见过一次Y总，那是在一个茶室，跟Y总有过一番简单的沟通后，我打算去公司看看，以便了解公司实际的产品情况。\n\n于是受到技术团队负责人的邀请，我选择了一个阳光明媚的下午，坐上了被当地人称为“最长公交线路”的127路公交车，在那条的弯弯曲曲的公交线路上，折腾了大概一个多小时，终于才来到了目的地，位于当地东北角的某商务写字楼。并再次见到了Y总。\n\n虽然是第二次见到Y总，但是第一次其实只是简单的沟通，并没有仔细打量这位领导。这一次，算是对Y总有了更加深刻的印象。\n\n那是一位两鬓开始逐渐开始冒出白发的中年男子，身体精瘦、精神饱满、看起来充满了力量，他操着一口相对于当地人来说非常纯粹的普通话，给我留下了非常深刻的印象。当听他提起他自己已经55岁时，我的内心泛起了波澜。\n\n这是一位和我的父亲一般年龄的中年人啊~在这个年龄，他居然选择了创业，着实让我大吃一惊。\n\n当然，他显然非常的专业，在简单概要的介绍了公司的创业方向、拥有的背景和资源之后，让我深刻的体会到，他一定是想干一番大事业。\n\n于是，我毫不犹豫的加入了公司，并期待在这里开启职场的新征程。\n\n# 三\n创业公司的发展，总是跌宕起伏，看似波澜不惊，其实暗藏杀机。尤其是选择合适的人才，更是难点中的难点。谁都想选择最优秀的人才，但是在优秀的专业人才和优秀的跨职能型人才间，其实非常难以选择。\n\n还好，本人算是一个勉强称职的跨职能型开发者，在我们部门的经理离职之后，毅然扛起了部门的重担，为公司勉强完成了一个非常不错的项目，使得公司能够获得短暂的喘息之机。\n\n但是老w所在的项目，却面临了巨大的问题。\n\n首先是优秀人才的缺失，毕竟能够深刻领悟如何基于物联网技术构建平台的应用开发者，在当时非常的稀缺，更何况公司所能付出的资源（要钱没钱，要股份没股份）其实非常有限，也显然很难招到合适的人才，而这仅仅只是我所看到的web开发方面，还有更严重的方面是物联网基础技术方面。\n\n说来也搞笑，没有物联网基础技术，又如何做物联网产品呢？其实倒也不完全没有积累，这位老板和物联网部门的负责人曾经参与创办了另外一家非常优秀的物联网公司H公司，他们花了十年时间让这家公司从无到有，到做到国际一流。后来H公司业绩到了瓶颈，他们想为公司开辟新的业务方向，才创建了这家新的物联网公司。但是虽然同是物联网创业方向，但选择的技术路线和实现模式却不尽相同，而在新的技术路线上公司的积累非常浅。而在最关键的时候，拥有核心开发能力的一位嵌入式系统开发者，居然只打了个招呼，连交接和培训新人都没有认真开展就离开了公司，使得公司技术层面面临巨大的断层。\n\n为了完成这个项目，Y总只好自己迎难而上。那段时间他不得不捡起曾经荒废多年的嵌入式系统开发技术，天天加班到深夜。每天早上又最早来到公司，恨不能尽早完成目标。\n\n他就不怕猝死么？显然，他是怕的。但为了公司的生存，其实他别无选择。\n\n# 四\n我曾经冒昧的问过他选择创业的原因，他只是轻轻一笑，还不是为了实现自己创业的梦想？\n\n显然他不愿意过多的描述。但是联想到Y总的职业生涯，我大概能猜到一部分原因。\n\nY总虽然是北方人，但是在这片热土已经呆了三十几年。八十年代在第一大学就读的Y总，年轻时学习成绩特别好，不仅保送本校研究生，还直博，方向是某个热门的领域。当博士毕业后，也许他也曾想去沿海地区发展，但是他最终留下来主导该校的某领域的学术研究。\n\n又过了几年，市场经济放开的九十年代，他也有许多选择的机会。在该领域浸淫十几年的他，一定收到了许多沿海企业或外资企业的聘书，但是他并没有做出这样的选择。\n\n又过了十年，四十岁，他已经决定放开手脚出去干一场时，又是家庭压力最大的时候。也许去沿海城市会让他家庭和事业难以兼顾，他最终还是没有迈出哪一步。\n\n一晃五十岁，他从学校退休。子女也出过留学，得到了顶级互联网公司的offer，基本上算是没什么压力了。\n\n也许，从二十几岁到五十几岁，他错过了太多的机会。\n\n他也曾经偶尔提到那些跟他一起读书的同学，或者研究所的同事，在离开象牙塔后，有的加入了互联网公司花了十年时间获得了财富自由，有的甚至创办了挺不错的公司。\n\nY总虽然也曾参与了一家公司的创办过程，却并没有从零开始创办一家属于自己的公司，而且他自认为这家公司虽然业务还算稳定，但在技术上，不能算卓越，只能算优秀。由于没有赶上风口，所以做得非常费力；而且行业领域非常狭小，很难获得更大的发展。\n\n他显然想挑战自己。\n\n# 五\n然而，创业难，难于上青天。\n\n我也最终选择了离开这家公司。依稀记得Y总说过的话：“人生短短80年，其中从二十几岁毕业到六十多岁退休，期间有四十年时间。如果抱着把行业当做一辈子的心态，就该前二十年学经验，后二十年才能有经验可以用。”\n\n当然，没有任何一个人敢说自己的技能能够通吃一辈子，也不可能每个人都会在一个公司、一份工作上干一辈子，变化才是人生的常态。适应变化和主动学习，正是人的基本能力。尤其是程序员，有许多程序员能够花十年赚到二十年才能赚到的钱，但是之后呢？年纪轻轻三十岁就养老吗？\n\n学习这条路，其实根本没有终点。\n\n\n\n","slug":"随笔/那位五十多岁的创业者给我的启示","published":1,"updated":"2020-04-17T14:26:46.903Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujt9v0050n4viw2vzn5ey","content":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>我曾经提到过最终改行从事美缝行业的老w，他靠自己的“不够努力”，最终离开了行业。</p>\n<p>但是，这个世界其实有点讽刺。</p>\n<p>在沉迷于安逸小日子的老w每天朝九晚五，只想拿钱，不想干活的那段日子，隔壁的总经理办公室却经常通宵达旦、灯火通明，那位五十五岁的老板Y总，正在为了自己的梦想努力奋斗着。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>在加入公司之前，我曾经见过一次Y总，那是在一个茶室，跟Y总有过一番简单的沟通后，我打算去公司看看，以便了解公司实际的产品情况。</p>\n<p>于是受到技术团队负责人的邀请，我选择了一个阳光明媚的下午，坐上了被当地人称为“最长公交线路”的127路公交车，在那条的弯弯曲曲的公交线路上，折腾了大概一个多小时，终于才来到了目的地，位于当地东北角的某商务写字楼。并再次见到了Y总。</p>\n<p>虽然是第二次见到Y总，但是第一次其实只是简单的沟通，并没有仔细打量这位领导。这一次，算是对Y总有了更加深刻的印象。</p>\n<p>那是一位两鬓开始逐渐开始冒出白发的中年男子，身体精瘦、精神饱满、看起来充满了力量，他操着一口相对于当地人来说非常纯粹的普通话，给我留下了非常深刻的印象。当听他提起他自己已经55岁时，我的内心泛起了波澜。</p>\n<p>这是一位和我的父亲一般年龄的中年人啊~在这个年龄，他居然选择了创业，着实让我大吃一惊。</p>\n<p>当然，他显然非常的专业，在简单概要的介绍了公司的创业方向、拥有的背景和资源之后，让我深刻的体会到，他一定是想干一番大事业。</p>\n<p>于是，我毫不犹豫的加入了公司，并期待在这里开启职场的新征程。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>创业公司的发展，总是跌宕起伏，看似波澜不惊，其实暗藏杀机。尤其是选择合适的人才，更是难点中的难点。谁都想选择最优秀的人才，但是在优秀的专业人才和优秀的跨职能型人才间，其实非常难以选择。</p>\n<p>还好，本人算是一个勉强称职的跨职能型开发者，在我们部门的经理离职之后，毅然扛起了部门的重担，为公司勉强完成了一个非常不错的项目，使得公司能够获得短暂的喘息之机。</p>\n<p>但是老w所在的项目，却面临了巨大的问题。</p>\n<p>首先是优秀人才的缺失，毕竟能够深刻领悟如何基于物联网技术构建平台的应用开发者，在当时非常的稀缺，更何况公司所能付出的资源（要钱没钱，要股份没股份）其实非常有限，也显然很难招到合适的人才，而这仅仅只是我所看到的web开发方面，还有更严重的方面是物联网基础技术方面。</p>\n<p>说来也搞笑，没有物联网基础技术，又如何做物联网产品呢？其实倒也不完全没有积累，这位老板和物联网部门的负责人曾经参与创办了另外一家非常优秀的物联网公司H公司，他们花了十年时间让这家公司从无到有，到做到国际一流。后来H公司业绩到了瓶颈，他们想为公司开辟新的业务方向，才创建了这家新的物联网公司。但是虽然同是物联网创业方向，但选择的技术路线和实现模式却不尽相同，而在新的技术路线上公司的积累非常浅。而在最关键的时候，拥有核心开发能力的一位嵌入式系统开发者，居然只打了个招呼，连交接和培训新人都没有认真开展就离开了公司，使得公司技术层面面临巨大的断层。</p>\n<p>为了完成这个项目，Y总只好自己迎难而上。那段时间他不得不捡起曾经荒废多年的嵌入式系统开发技术，天天加班到深夜。每天早上又最早来到公司，恨不能尽早完成目标。</p>\n<p>他就不怕猝死么？显然，他是怕的。但为了公司的生存，其实他别无选择。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>我曾经冒昧的问过他选择创业的原因，他只是轻轻一笑，还不是为了实现自己创业的梦想？</p>\n<p>显然他不愿意过多的描述。但是联想到Y总的职业生涯，我大概能猜到一部分原因。</p>\n<p>Y总虽然是北方人，但是在这片热土已经呆了三十几年。八十年代在第一大学就读的Y总，年轻时学习成绩特别好，不仅保送本校研究生，还直博，方向是某个热门的领域。当博士毕业后，也许他也曾想去沿海地区发展，但是他最终留下来主导该校的某领域的学术研究。</p>\n<p>又过了几年，市场经济放开的九十年代，他也有许多选择的机会。在该领域浸淫十几年的他，一定收到了许多沿海企业或外资企业的聘书，但是他并没有做出这样的选择。</p>\n<p>又过了十年，四十岁，他已经决定放开手脚出去干一场时，又是家庭压力最大的时候。也许去沿海城市会让他家庭和事业难以兼顾，他最终还是没有迈出哪一步。</p>\n<p>一晃五十岁，他从学校退休。子女也出过留学，得到了顶级互联网公司的offer，基本上算是没什么压力了。</p>\n<p>也许，从二十几岁到五十几岁，他错过了太多的机会。</p>\n<p>他也曾经偶尔提到那些跟他一起读书的同学，或者研究所的同事，在离开象牙塔后，有的加入了互联网公司花了十年时间获得了财富自由，有的甚至创办了挺不错的公司。</p>\n<p>Y总虽然也曾参与了一家公司的创办过程，却并没有从零开始创办一家属于自己的公司，而且他自认为这家公司虽然业务还算稳定，但在技术上，不能算卓越，只能算优秀。由于没有赶上风口，所以做得非常费力；而且行业领域非常狭小，很难获得更大的发展。</p>\n<p>他显然想挑战自己。</p>\n<h1 id=\"五\"><a href=\"#五\" class=\"headerlink\" title=\"五\"></a>五</h1><p>然而，创业难，难于上青天。</p>\n<p>我也最终选择了离开这家公司。依稀记得Y总说过的话：“人生短短80年，其中从二十几岁毕业到六十多岁退休，期间有四十年时间。如果抱着把行业当做一辈子的心态，就该前二十年学经验，后二十年才能有经验可以用。”</p>\n<p>当然，没有任何一个人敢说自己的技能能够通吃一辈子，也不可能每个人都会在一个公司、一份工作上干一辈子，变化才是人生的常态。适应变化和主动学习，正是人的基本能力。尤其是程序员，有许多程序员能够花十年赚到二十年才能赚到的钱，但是之后呢？年纪轻轻三十岁就养老吗？</p>\n<p>学习这条路，其实根本没有终点。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p>我曾经提到过最终改行从事美缝行业的老w，他靠自己的“不够努力”，最终离开了行业。</p>\n<p>但是，这个世界其实有点讽刺。</p>\n<p>在沉迷于安逸小日子的老w每天朝九晚五，只想拿钱，不想干活的那段日子，隔壁的总经理办公室却经常通宵达旦、灯火通明，那位五十五岁的老板Y总，正在为了自己的梦想努力奋斗着。</p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p>在加入公司之前，我曾经见过一次Y总，那是在一个茶室，跟Y总有过一番简单的沟通后，我打算去公司看看，以便了解公司实际的产品情况。</p>\n<p>于是受到技术团队负责人的邀请，我选择了一个阳光明媚的下午，坐上了被当地人称为“最长公交线路”的127路公交车，在那条的弯弯曲曲的公交线路上，折腾了大概一个多小时，终于才来到了目的地，位于当地东北角的某商务写字楼。并再次见到了Y总。</p>\n<p>虽然是第二次见到Y总，但是第一次其实只是简单的沟通，并没有仔细打量这位领导。这一次，算是对Y总有了更加深刻的印象。</p>\n<p>那是一位两鬓开始逐渐开始冒出白发的中年男子，身体精瘦、精神饱满、看起来充满了力量，他操着一口相对于当地人来说非常纯粹的普通话，给我留下了非常深刻的印象。当听他提起他自己已经55岁时，我的内心泛起了波澜。</p>\n<p>这是一位和我的父亲一般年龄的中年人啊~在这个年龄，他居然选择了创业，着实让我大吃一惊。</p>\n<p>当然，他显然非常的专业，在简单概要的介绍了公司的创业方向、拥有的背景和资源之后，让我深刻的体会到，他一定是想干一番大事业。</p>\n<p>于是，我毫不犹豫的加入了公司，并期待在这里开启职场的新征程。</p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p>创业公司的发展，总是跌宕起伏，看似波澜不惊，其实暗藏杀机。尤其是选择合适的人才，更是难点中的难点。谁都想选择最优秀的人才，但是在优秀的专业人才和优秀的跨职能型人才间，其实非常难以选择。</p>\n<p>还好，本人算是一个勉强称职的跨职能型开发者，在我们部门的经理离职之后，毅然扛起了部门的重担，为公司勉强完成了一个非常不错的项目，使得公司能够获得短暂的喘息之机。</p>\n<p>但是老w所在的项目，却面临了巨大的问题。</p>\n<p>首先是优秀人才的缺失，毕竟能够深刻领悟如何基于物联网技术构建平台的应用开发者，在当时非常的稀缺，更何况公司所能付出的资源（要钱没钱，要股份没股份）其实非常有限，也显然很难招到合适的人才，而这仅仅只是我所看到的web开发方面，还有更严重的方面是物联网基础技术方面。</p>\n<p>说来也搞笑，没有物联网基础技术，又如何做物联网产品呢？其实倒也不完全没有积累，这位老板和物联网部门的负责人曾经参与创办了另外一家非常优秀的物联网公司H公司，他们花了十年时间让这家公司从无到有，到做到国际一流。后来H公司业绩到了瓶颈，他们想为公司开辟新的业务方向，才创建了这家新的物联网公司。但是虽然同是物联网创业方向，但选择的技术路线和实现模式却不尽相同，而在新的技术路线上公司的积累非常浅。而在最关键的时候，拥有核心开发能力的一位嵌入式系统开发者，居然只打了个招呼，连交接和培训新人都没有认真开展就离开了公司，使得公司技术层面面临巨大的断层。</p>\n<p>为了完成这个项目，Y总只好自己迎难而上。那段时间他不得不捡起曾经荒废多年的嵌入式系统开发技术，天天加班到深夜。每天早上又最早来到公司，恨不能尽早完成目标。</p>\n<p>他就不怕猝死么？显然，他是怕的。但为了公司的生存，其实他别无选择。</p>\n<h1 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h1><p>我曾经冒昧的问过他选择创业的原因，他只是轻轻一笑，还不是为了实现自己创业的梦想？</p>\n<p>显然他不愿意过多的描述。但是联想到Y总的职业生涯，我大概能猜到一部分原因。</p>\n<p>Y总虽然是北方人，但是在这片热土已经呆了三十几年。八十年代在第一大学就读的Y总，年轻时学习成绩特别好，不仅保送本校研究生，还直博，方向是某个热门的领域。当博士毕业后，也许他也曾想去沿海地区发展，但是他最终留下来主导该校的某领域的学术研究。</p>\n<p>又过了几年，市场经济放开的九十年代，他也有许多选择的机会。在该领域浸淫十几年的他，一定收到了许多沿海企业或外资企业的聘书，但是他并没有做出这样的选择。</p>\n<p>又过了十年，四十岁，他已经决定放开手脚出去干一场时，又是家庭压力最大的时候。也许去沿海城市会让他家庭和事业难以兼顾，他最终还是没有迈出哪一步。</p>\n<p>一晃五十岁，他从学校退休。子女也出过留学，得到了顶级互联网公司的offer，基本上算是没什么压力了。</p>\n<p>也许，从二十几岁到五十几岁，他错过了太多的机会。</p>\n<p>他也曾经偶尔提到那些跟他一起读书的同学，或者研究所的同事，在离开象牙塔后，有的加入了互联网公司花了十年时间获得了财富自由，有的甚至创办了挺不错的公司。</p>\n<p>Y总虽然也曾参与了一家公司的创办过程，却并没有从零开始创办一家属于自己的公司，而且他自认为这家公司虽然业务还算稳定，但在技术上，不能算卓越，只能算优秀。由于没有赶上风口，所以做得非常费力；而且行业领域非常狭小，很难获得更大的发展。</p>\n<p>他显然想挑战自己。</p>\n<h1 id=\"五\"><a href=\"#五\" class=\"headerlink\" title=\"五\"></a>五</h1><p>然而，创业难，难于上青天。</p>\n<p>我也最终选择了离开这家公司。依稀记得Y总说过的话：“人生短短80年，其中从二十几岁毕业到六十多岁退休，期间有四十年时间。如果抱着把行业当做一辈子的心态，就该前二十年学经验，后二十年才能有经验可以用。”</p>\n<p>当然，没有任何一个人敢说自己的技能能够通吃一辈子，也不可能每个人都会在一个公司、一份工作上干一辈子，变化才是人生的常态。适应变化和主动学习，正是人的基本能力。尤其是程序员，有许多程序员能够花十年赚到二十年才能赚到的钱，但是之后呢？年纪轻轻三十岁就养老吗？</p>\n<p>学习这条路，其实根本没有终点。</p>\n"},{"title":"在Asp.NET Core中如何优雅的管理用户机密数据","date":"2020-06-09T12:05:00.000Z","author":"邹溪源","_content":"\n\n\n# 在Asp.NET Core中如何优雅的管理用户机密数据\n\n## 背景\n\n#### 回顾\n\n在软件开发过程中，使用配置文件来管理某些对应用程序运行中需要使用的参数是常见的作法。在早期VB/VB.NET时代，经常使用.ini文件来进行配置管理；而在.NET FX开发中，我们则倾向于使用web.config文件，通过配置appsetting的配置节来处理；而在.NET Core开发中，我们有了新的基于json格式的appsetting.json文件。\n\n无论采用哪种方式，其实配置管理从来都是一件看起来简单，但影响非常深远的基础性工作。尤其是配置的安全性，贯穿应用程序的始终，如果没能做好安全性问题，极有可能会给系统带来不可控的风向。\n\n#### 源代码比配置文件安全么？\n\n有人以为把配置存放在源代码中，可能比存放在明文的配置文件中似乎更安全，其实是“皇帝的新装”。\n\n在前不久，笔者的一位朋友就跟我说了一段故事：他说一位同事在离职后，直接将曾经写过的一段代码上传到github的公共仓库，而这段代码中包含了某些涉及到原企业的机密数据，还好被github的安全机制提前发现而及时终止了该行为，否则后果不堪设想。\n\n于是，笔者顺手查了一下由于有意或无意泄露企业机密，造成企业损失的案例，发现还真不少。例如[大疆前员工通过 Github 泄露公司源代码，被罚 20 万、获刑半年](https://www.infoq.cn/article/RZzfel1m6-h8pSK8TTC9)  这起案件，也是一个典型的案例。\n\n该员工离职后，将包含关键配置信息的源代码上传到github的公共仓库，被黑客利用，使得大量用户私人数据被黑客获取，该前员工最终被刑拘。 ![大疆前员工通过Github泄露公司源代码，被罚20万、获刑半年](https://static.geekbang.org/infoq/5cc32361f3500.png?imageView2/0/w/800) \n\n 图片来源：[ http://www.digitalmunition.com/WhyIWalkedFrom3k.pdf](http://www.digitalmunition.com/WhyIWalkedFrom3k.pdf) \n\n大部分IT公司都会在入职前进行背景调查，而一旦有案底，可能就已经与许多IT公司无缘；即便是成为创业者，也可能面临无法跟很多正规企业合作的问题。\n\n#### 小结\n\n所以，安全性问题不容小觑，哪怕时间再忙，也不要急匆匆的就将数据库连接字符串或其他包含敏感信息的内容轻易的记录在源代码或配置文件中。在这个点上，一旦出现问题，往往都是非常严重的问题。\n\n## 如何实现\n\n在.NET FX时代，我们可以使用对web.config文件的关键配置节进行加密的方式，来保护我们的敏感信息，在.NET Core中，自然也有这些东西，接下来我将简述在开发环境和生产环境下不同的配置加密手段，希望能够给读者带来启迪。\n\n#### 开发环境\n\n在开发环境下，我们可以使用visual studio 工具提供的用户机密管理器，只需0行代码，即可轻松完成关键配置节的处理。\n\n##### 机密管理器概述\n\n根据[微软官方文档]( https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/secure-net-microservices-web-applications/developer-app-secrets-storage ) 的描述：\n\n> ASP.NET Core [机密管理器](https://docs.microsoft.com/zh-cn/aspnet/core/security/app-secrets#secret-manager)工具提供了开发过程中在源代码外部保存机密的另一种方法 。 若要使用机密管理器工具，请在项目文件中安装包 Microsoft.Extensions.Configuration.SecretManager 。 如果该依赖项存在并且已还原，则可以使用 `dotnet user-secrets` 命令来通过命令行设置机密的值。 这些机密将存储在用户配置文件目录中的 JSON 文件中（详细信息随操作系统而异），与源代码无关。\n>\n> 机密管理器工具设置的机密是由使用机密的项目的 `UserSecretsId` 属性组织的。 因此，必须确保在项目文件中设置 UserSecretsId 属性，如下面的代码片段所示。 默认值是 Visual Studio 分配的 GUID，但实际字符串并不重要，只要它在计算机中是唯一的。\n>\n> ```XML\n> <PropertyGroup>\n>    <UserSecretsId>UniqueIdentifyingString</UserSecretsId>\n> </PropertyGroup> \n> ```\n\nSecret Manager工具允许开发人员在开发ASP.NET Core应用程序期间存储和检索敏感数据。敏感数据存储在与应用程序源代码不同的位置。由于Secret Manager将秘密与源代码分开存储，因此敏感数据不会提交到源代码存储库。但机密管理器不会对存储的敏感数据进行加密，因此不应将其视为可信存储。敏感数据作为键值对存储在JSON文件中。最好**不要**在开发和测试环境中使用生产机密。[查看引文]( https://nvisium.com/blog/2019/05/02/Dev-Secrets-and-the-ASP-NET-Core-Secret-Manager.html )。\n\n##### 存放位置\n\n在windows平台下，机密数据的存放位置为：\n\n```JSON\n%APPDATA%\\Microsoft\\UserSecrets\\\\secrets.json\n```\n\n而在Linux/MacOs平台下，机密数据的存放位置为：\n\n```json\n ~/.microsoft/usersecrets/<user_secrets_id>/secrets.json \n```\n\n 在前面的文件路径中， ``将替换`UserSecretsId`为 *.csproj*文件中指定的值。 \n\n##### 在Windows环境下使用机密管理器\n\n在windows下，如果使用Visual Studio2019作为主力开发环境，只需在项目右键单击，选择菜单【管理用户机密】，即可添加用户机密数据。   \n\n![](/images/how-to-manage-user-secret-in-develop-and-production_1.png)\n\n\n在管理用户机密数据中，添加的配置信息和传统的配置信息没有任何区别。\n\n> {\n>   \"ConnectionStrings\": {\n>     \"Default\": \"Server=xxx;Database=xxx;User ID=xxx;Password=xxx;\"\n>   }\n> }\n\n我们同样也可以使用IConfiguration的方式、IOptions<T>的方式，进行配置的访问。\n\n##### 在非Windows/非Visual Studio环境下使用机密管理器\n\n完成安装dotnet-cli后，在控制台输入 \n\n```dotnet-cli\ndotnet user-secrets init \n```\n\n 前面的命令将在`UserSecretsId` .csproj 文件的`PropertyGroup`中添加 *.csproj*一个元素。 `UserSecretsId`是对项目是唯一的Guid值。 \n\n```xml\n <PropertyGroup>  \n \t<TargetFramework>netcoreapp3.1</TargetFramework>\n    <UserSecretsId>79a3edd0-2092-40a2-a04d-dcb46d5ca9ed</UserSecretsId> \n </PropertyGroup> \n```\n\n设置机密\n\n```dotnet-cli\n dotnet user-secrets set \"Movies:ServiceApiKey\" \"12345\" \n```\n\n列出机密\n\n```dotnet-cli\n dotnet user-secrets list \n```\n\n删除机密\n\n```dotnet-cli\n dotnet user-secrets remove \"Movies:ConnectionString\" \n```\n\n清除所有机密\n\n```dotnet-cli\n dotnet user-secrets clear \n```\n\n#### 生产环境\n\n机密管理器为开发者在开发环境下提供了一种保留机密数据的方法，但在开发环境下是不建议使用的，如果想在生产环境下，对机密数据进行保存该怎么办？\n\n按照微软官方文档的说法，推荐使用[Azure Key Vault ]( https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/secure-net-microservices-web-applications/azure-key-vault-protects-secrets ) 来保护机密数据，但。。我不是贵云的用户（当然，买不起贵云不是贵云太贵，而是我个人的问题[手动狗头]）。\n\n其次，与Azure Key Valut类似的套件，例如其他云，差不多都有，所以都可以为我们所用。\n\n但。。如果您如果跟我一样，不想通过第三方依赖的形式来解决这个问题，那不如就用最简单的办法，例如AES加密。\n\n##### 使用AES加密配置节 \n\n该方法与平时使用AES对字符串进行加密和解密的方法并无区别，此处从略。  \n\n##### 使用数据保护Api（DataProtect Api实现）\n\n在平时开发过程中，能够动手撸AES加密是一种非常好的习惯，而微软官方提供的数据保护API则将这个过程进一步简化，只需调Api即可完成相应的数据加密操作。\n\n关于数据保护api， [Savorboard](https://home.cnblogs.com/u/savorboard/) 大佬曾经写过3篇博客讨论这个技术问题，大家可以参考下面的文章来获取信息。\n\n[ASP.NET Core 数据保护（Data Protection 集群场景）【上】]( https://www.cnblogs.com/savorboard/p/dotnetcore-data-protection.html )\n\n[ASP.NET Core 数据保护（Data Protection 集群场景）【中】]( https://www.cnblogs.com/savorboard/p/dotnet-core-data-protection.html )\n\n[ASP.NET Core 数据保护（Data Protection 集群场景）【下】]( https://www.cnblogs.com/savorboard/p/dotnetcore-data-protected-farm.html )\n\n(接下来我要贴代码了，如果没兴趣，请出门左拐，代码不能完整运行，[查看代码]( https://stackoverflow.com/questions/36062670/encrypted-configuration-in-asp-net-core )）\n\n首先，注入配置项\n\n```C#\n public static IServiceCollection AddProtectedConfiguration(this IServiceCollection services, string directory)\n        {\n            services\n                .AddDataProtection()\n                .PersistKeysToFileSystem(new DirectoryInfo(directory))\n                .UseCustomCryptographicAlgorithms(new ManagedAuthenticatedEncryptorConfiguration\n                {\n                    EncryptionAlgorithmType = typeof(Aes),\n                    EncryptionAlgorithmKeySize = 256,\n                    ValidationAlgorithmType = typeof(HMACSHA256)\n                });\n            ;\n\n            return services;\n        }\n```\n\n其次，实现对配置节的加/解密。（使用AES算法的数据保护机制）\n\n```c#\n\npublic class ProtectedConfigurationSection : IConfigurationSection\n    {\n        private readonly IDataProtectionProvider _dataProtectionProvider;\n        private readonly IConfigurationSection _section;\n        private readonly Lazy<IDataProtector> _protector;\n\n        public ProtectedConfigurationSection(\n            IDataProtectionProvider dataProtectionProvider,\n            IConfigurationSection section)\n        {\n            _dataProtectionProvider = dataProtectionProvider;\n            _section = section;\n\n            _protector = new Lazy<IDataProtector>(() => dataProtectionProvider.CreateProtector(section.Path));\n        }\n\n        public IConfigurationSection GetSection(string key)\n        {\n            return new ProtectedConfigurationSection(_dataProtectionProvider, _section.GetSection(key));\n        }\n\n        public IEnumerable<IConfigurationSection> GetChildren()\n        {\n            return _section.GetChildren()\n                .Select(x => new ProtectedConfigurationSection(_dataProtectionProvider, x));\n        }\n\n        public IChangeToken GetReloadToken()\n        {\n            return _section.GetReloadToken();\n        }\n\n        public string this[string key]\n        {\n            get => GetProtectedValue(_section[key]);\n            set => _section[key] = _protector.Value.Protect(value);\n        }\n\n        public string Key => _section.Key;\n        public string Path => _section.Path;\n\n        public string Value\n        {\n            get => GetProtectedValue(_section.Value);\n            set => _section.Value = _protector.Value.Protect(value);\n        }\n\n        private string GetProtectedValue(string value)\n        {\n            if (value == null)\n                return null;\n\n            return _protector.Value.Unprotect(value);\n        }\n    }\n```\n\n再次，在使用前，先将待加密的字符串转换成BASE64纯文本，然后再使用数据保护API对数据进行处理，得到处理后的字符串。\n\n```c#\nprivate readonly IDataProtectionProvider _dataProtectorTokenProvider;\npublic TokenAuthController( IDataProtectionProvider dataProtectorTokenProvider)\n{\n}\n[Route(\"encrypt\"), HttpGet, HttpPost]\npublic string Encrypt(string section, string value)\n{\n     var protector = _dataProtectorTokenProvider.CreateProtector(section);\n     return protector.Protect(value);\n}\n```\n\n再替换配置文件中的对应内容。\n\n```json\n{\n  \"ConnectionStrings\": {\n    \"Default\": \"此处是加密后的字符串\"\n  }\n}\n```\n\n然后我们就可以按照平时获取IOptions<ConnectStrings>的方式来获取了。\n\n## 问题\n\n公众号【DotNET骚操作】号主【周杰】同学提出以下观点：\n\n**1、在生产环境下，使用AES加密，其实依然是一种不够安全的行为，充其量也就能忽悠下产品经理，毕竟几条简单的语句，就能把机密数据dump出来。**\n\n 也许在这种情况下，我们应该优先考虑accessKeyId/accessSecret，尽量通过设置多级子账号，通过授权Api的机制来管理机密数据，而不是直接暴露类似于数据库连接字符串这样的关键配置信息。另外，应该定期更换数据库的密码，尽量将类似的问题可能造成的风险降到最低。数据保护api也提供的类似的机制，使得开发者能够轻松的管理机密数据的时效性问题。\n\n**2、配置文件放到CI/CD中，发布的时候在CI/CD中进行组装，然后运维只是负责管理CI/CD的账户信息，而最高机密数据，则由其他人负责配置。**\n\n嗯，我完全同意他的第二种做法，另外考虑到由于运维同样有可能会有意无意泄露机密数据，所以如果再给运维配备一本《刑法》，并让他日常补习【侵犯商业秘密罪】相关条款，这个流程就更加闭环了。\n\n## 结语\n\n本文简述了在.NET Core中，如何在开发环境下使用用户机密管理器、在生产环境下使用AES+IDataProvider的方式来保护我们的用户敏感数据。由于时间仓促，如有考虑不周之处，还请各位大佬批评指正。","source":"_posts/技术/how-to-manage-user-secret-in-develop-and-production.md","raw":"---\ntitle:  在Asp.NET Core中如何优雅的管理用户机密数据\ndate: 2020-6-9 20:05\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n\n\n\n# 在Asp.NET Core中如何优雅的管理用户机密数据\n\n## 背景\n\n#### 回顾\n\n在软件开发过程中，使用配置文件来管理某些对应用程序运行中需要使用的参数是常见的作法。在早期VB/VB.NET时代，经常使用.ini文件来进行配置管理；而在.NET FX开发中，我们则倾向于使用web.config文件，通过配置appsetting的配置节来处理；而在.NET Core开发中，我们有了新的基于json格式的appsetting.json文件。\n\n无论采用哪种方式，其实配置管理从来都是一件看起来简单，但影响非常深远的基础性工作。尤其是配置的安全性，贯穿应用程序的始终，如果没能做好安全性问题，极有可能会给系统带来不可控的风向。\n\n#### 源代码比配置文件安全么？\n\n有人以为把配置存放在源代码中，可能比存放在明文的配置文件中似乎更安全，其实是“皇帝的新装”。\n\n在前不久，笔者的一位朋友就跟我说了一段故事：他说一位同事在离职后，直接将曾经写过的一段代码上传到github的公共仓库，而这段代码中包含了某些涉及到原企业的机密数据，还好被github的安全机制提前发现而及时终止了该行为，否则后果不堪设想。\n\n于是，笔者顺手查了一下由于有意或无意泄露企业机密，造成企业损失的案例，发现还真不少。例如[大疆前员工通过 Github 泄露公司源代码，被罚 20 万、获刑半年](https://www.infoq.cn/article/RZzfel1m6-h8pSK8TTC9)  这起案件，也是一个典型的案例。\n\n该员工离职后，将包含关键配置信息的源代码上传到github的公共仓库，被黑客利用，使得大量用户私人数据被黑客获取，该前员工最终被刑拘。 ![大疆前员工通过Github泄露公司源代码，被罚20万、获刑半年](https://static.geekbang.org/infoq/5cc32361f3500.png?imageView2/0/w/800) \n\n 图片来源：[ http://www.digitalmunition.com/WhyIWalkedFrom3k.pdf](http://www.digitalmunition.com/WhyIWalkedFrom3k.pdf) \n\n大部分IT公司都会在入职前进行背景调查，而一旦有案底，可能就已经与许多IT公司无缘；即便是成为创业者，也可能面临无法跟很多正规企业合作的问题。\n\n#### 小结\n\n所以，安全性问题不容小觑，哪怕时间再忙，也不要急匆匆的就将数据库连接字符串或其他包含敏感信息的内容轻易的记录在源代码或配置文件中。在这个点上，一旦出现问题，往往都是非常严重的问题。\n\n## 如何实现\n\n在.NET FX时代，我们可以使用对web.config文件的关键配置节进行加密的方式，来保护我们的敏感信息，在.NET Core中，自然也有这些东西，接下来我将简述在开发环境和生产环境下不同的配置加密手段，希望能够给读者带来启迪。\n\n#### 开发环境\n\n在开发环境下，我们可以使用visual studio 工具提供的用户机密管理器，只需0行代码，即可轻松完成关键配置节的处理。\n\n##### 机密管理器概述\n\n根据[微软官方文档]( https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/secure-net-microservices-web-applications/developer-app-secrets-storage ) 的描述：\n\n> ASP.NET Core [机密管理器](https://docs.microsoft.com/zh-cn/aspnet/core/security/app-secrets#secret-manager)工具提供了开发过程中在源代码外部保存机密的另一种方法 。 若要使用机密管理器工具，请在项目文件中安装包 Microsoft.Extensions.Configuration.SecretManager 。 如果该依赖项存在并且已还原，则可以使用 `dotnet user-secrets` 命令来通过命令行设置机密的值。 这些机密将存储在用户配置文件目录中的 JSON 文件中（详细信息随操作系统而异），与源代码无关。\n>\n> 机密管理器工具设置的机密是由使用机密的项目的 `UserSecretsId` 属性组织的。 因此，必须确保在项目文件中设置 UserSecretsId 属性，如下面的代码片段所示。 默认值是 Visual Studio 分配的 GUID，但实际字符串并不重要，只要它在计算机中是唯一的。\n>\n> ```XML\n> <PropertyGroup>\n>    <UserSecretsId>UniqueIdentifyingString</UserSecretsId>\n> </PropertyGroup> \n> ```\n\nSecret Manager工具允许开发人员在开发ASP.NET Core应用程序期间存储和检索敏感数据。敏感数据存储在与应用程序源代码不同的位置。由于Secret Manager将秘密与源代码分开存储，因此敏感数据不会提交到源代码存储库。但机密管理器不会对存储的敏感数据进行加密，因此不应将其视为可信存储。敏感数据作为键值对存储在JSON文件中。最好**不要**在开发和测试环境中使用生产机密。[查看引文]( https://nvisium.com/blog/2019/05/02/Dev-Secrets-and-the-ASP-NET-Core-Secret-Manager.html )。\n\n##### 存放位置\n\n在windows平台下，机密数据的存放位置为：\n\n```JSON\n%APPDATA%\\Microsoft\\UserSecrets\\\\secrets.json\n```\n\n而在Linux/MacOs平台下，机密数据的存放位置为：\n\n```json\n ~/.microsoft/usersecrets/<user_secrets_id>/secrets.json \n```\n\n 在前面的文件路径中， ``将替换`UserSecretsId`为 *.csproj*文件中指定的值。 \n\n##### 在Windows环境下使用机密管理器\n\n在windows下，如果使用Visual Studio2019作为主力开发环境，只需在项目右键单击，选择菜单【管理用户机密】，即可添加用户机密数据。   \n\n![](/images/how-to-manage-user-secret-in-develop-and-production_1.png)\n\n\n在管理用户机密数据中，添加的配置信息和传统的配置信息没有任何区别。\n\n> {\n>   \"ConnectionStrings\": {\n>     \"Default\": \"Server=xxx;Database=xxx;User ID=xxx;Password=xxx;\"\n>   }\n> }\n\n我们同样也可以使用IConfiguration的方式、IOptions<T>的方式，进行配置的访问。\n\n##### 在非Windows/非Visual Studio环境下使用机密管理器\n\n完成安装dotnet-cli后，在控制台输入 \n\n```dotnet-cli\ndotnet user-secrets init \n```\n\n 前面的命令将在`UserSecretsId` .csproj 文件的`PropertyGroup`中添加 *.csproj*一个元素。 `UserSecretsId`是对项目是唯一的Guid值。 \n\n```xml\n <PropertyGroup>  \n \t<TargetFramework>netcoreapp3.1</TargetFramework>\n    <UserSecretsId>79a3edd0-2092-40a2-a04d-dcb46d5ca9ed</UserSecretsId> \n </PropertyGroup> \n```\n\n设置机密\n\n```dotnet-cli\n dotnet user-secrets set \"Movies:ServiceApiKey\" \"12345\" \n```\n\n列出机密\n\n```dotnet-cli\n dotnet user-secrets list \n```\n\n删除机密\n\n```dotnet-cli\n dotnet user-secrets remove \"Movies:ConnectionString\" \n```\n\n清除所有机密\n\n```dotnet-cli\n dotnet user-secrets clear \n```\n\n#### 生产环境\n\n机密管理器为开发者在开发环境下提供了一种保留机密数据的方法，但在开发环境下是不建议使用的，如果想在生产环境下，对机密数据进行保存该怎么办？\n\n按照微软官方文档的说法，推荐使用[Azure Key Vault ]( https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/secure-net-microservices-web-applications/azure-key-vault-protects-secrets ) 来保护机密数据，但。。我不是贵云的用户（当然，买不起贵云不是贵云太贵，而是我个人的问题[手动狗头]）。\n\n其次，与Azure Key Valut类似的套件，例如其他云，差不多都有，所以都可以为我们所用。\n\n但。。如果您如果跟我一样，不想通过第三方依赖的形式来解决这个问题，那不如就用最简单的办法，例如AES加密。\n\n##### 使用AES加密配置节 \n\n该方法与平时使用AES对字符串进行加密和解密的方法并无区别，此处从略。  \n\n##### 使用数据保护Api（DataProtect Api实现）\n\n在平时开发过程中，能够动手撸AES加密是一种非常好的习惯，而微软官方提供的数据保护API则将这个过程进一步简化，只需调Api即可完成相应的数据加密操作。\n\n关于数据保护api， [Savorboard](https://home.cnblogs.com/u/savorboard/) 大佬曾经写过3篇博客讨论这个技术问题，大家可以参考下面的文章来获取信息。\n\n[ASP.NET Core 数据保护（Data Protection 集群场景）【上】]( https://www.cnblogs.com/savorboard/p/dotnetcore-data-protection.html )\n\n[ASP.NET Core 数据保护（Data Protection 集群场景）【中】]( https://www.cnblogs.com/savorboard/p/dotnet-core-data-protection.html )\n\n[ASP.NET Core 数据保护（Data Protection 集群场景）【下】]( https://www.cnblogs.com/savorboard/p/dotnetcore-data-protected-farm.html )\n\n(接下来我要贴代码了，如果没兴趣，请出门左拐，代码不能完整运行，[查看代码]( https://stackoverflow.com/questions/36062670/encrypted-configuration-in-asp-net-core )）\n\n首先，注入配置项\n\n```C#\n public static IServiceCollection AddProtectedConfiguration(this IServiceCollection services, string directory)\n        {\n            services\n                .AddDataProtection()\n                .PersistKeysToFileSystem(new DirectoryInfo(directory))\n                .UseCustomCryptographicAlgorithms(new ManagedAuthenticatedEncryptorConfiguration\n                {\n                    EncryptionAlgorithmType = typeof(Aes),\n                    EncryptionAlgorithmKeySize = 256,\n                    ValidationAlgorithmType = typeof(HMACSHA256)\n                });\n            ;\n\n            return services;\n        }\n```\n\n其次，实现对配置节的加/解密。（使用AES算法的数据保护机制）\n\n```c#\n\npublic class ProtectedConfigurationSection : IConfigurationSection\n    {\n        private readonly IDataProtectionProvider _dataProtectionProvider;\n        private readonly IConfigurationSection _section;\n        private readonly Lazy<IDataProtector> _protector;\n\n        public ProtectedConfigurationSection(\n            IDataProtectionProvider dataProtectionProvider,\n            IConfigurationSection section)\n        {\n            _dataProtectionProvider = dataProtectionProvider;\n            _section = section;\n\n            _protector = new Lazy<IDataProtector>(() => dataProtectionProvider.CreateProtector(section.Path));\n        }\n\n        public IConfigurationSection GetSection(string key)\n        {\n            return new ProtectedConfigurationSection(_dataProtectionProvider, _section.GetSection(key));\n        }\n\n        public IEnumerable<IConfigurationSection> GetChildren()\n        {\n            return _section.GetChildren()\n                .Select(x => new ProtectedConfigurationSection(_dataProtectionProvider, x));\n        }\n\n        public IChangeToken GetReloadToken()\n        {\n            return _section.GetReloadToken();\n        }\n\n        public string this[string key]\n        {\n            get => GetProtectedValue(_section[key]);\n            set => _section[key] = _protector.Value.Protect(value);\n        }\n\n        public string Key => _section.Key;\n        public string Path => _section.Path;\n\n        public string Value\n        {\n            get => GetProtectedValue(_section.Value);\n            set => _section.Value = _protector.Value.Protect(value);\n        }\n\n        private string GetProtectedValue(string value)\n        {\n            if (value == null)\n                return null;\n\n            return _protector.Value.Unprotect(value);\n        }\n    }\n```\n\n再次，在使用前，先将待加密的字符串转换成BASE64纯文本，然后再使用数据保护API对数据进行处理，得到处理后的字符串。\n\n```c#\nprivate readonly IDataProtectionProvider _dataProtectorTokenProvider;\npublic TokenAuthController( IDataProtectionProvider dataProtectorTokenProvider)\n{\n}\n[Route(\"encrypt\"), HttpGet, HttpPost]\npublic string Encrypt(string section, string value)\n{\n     var protector = _dataProtectorTokenProvider.CreateProtector(section);\n     return protector.Protect(value);\n}\n```\n\n再替换配置文件中的对应内容。\n\n```json\n{\n  \"ConnectionStrings\": {\n    \"Default\": \"此处是加密后的字符串\"\n  }\n}\n```\n\n然后我们就可以按照平时获取IOptions<ConnectStrings>的方式来获取了。\n\n## 问题\n\n公众号【DotNET骚操作】号主【周杰】同学提出以下观点：\n\n**1、在生产环境下，使用AES加密，其实依然是一种不够安全的行为，充其量也就能忽悠下产品经理，毕竟几条简单的语句，就能把机密数据dump出来。**\n\n 也许在这种情况下，我们应该优先考虑accessKeyId/accessSecret，尽量通过设置多级子账号，通过授权Api的机制来管理机密数据，而不是直接暴露类似于数据库连接字符串这样的关键配置信息。另外，应该定期更换数据库的密码，尽量将类似的问题可能造成的风险降到最低。数据保护api也提供的类似的机制，使得开发者能够轻松的管理机密数据的时效性问题。\n\n**2、配置文件放到CI/CD中，发布的时候在CI/CD中进行组装，然后运维只是负责管理CI/CD的账户信息，而最高机密数据，则由其他人负责配置。**\n\n嗯，我完全同意他的第二种做法，另外考虑到由于运维同样有可能会有意无意泄露机密数据，所以如果再给运维配备一本《刑法》，并让他日常补习【侵犯商业秘密罪】相关条款，这个流程就更加闭环了。\n\n## 结语\n\n本文简述了在.NET Core中，如何在开发环境下使用用户机密管理器、在生产环境下使用AES+IDataProvider的方式来保护我们的用户敏感数据。由于时间仓促，如有考虑不周之处，还请各位大佬批评指正。","slug":"技术/how-to-manage-user-secret-in-develop-and-production","published":1,"updated":"2020-06-25T13:58:48.664Z","_id":"ckbuujt9x0053n4vixe8ktpdx","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"在Asp-NET-Core中如何优雅的管理用户机密数据\"><a href=\"#在Asp-NET-Core中如何优雅的管理用户机密数据\" class=\"headerlink\" title=\"在Asp.NET Core中如何优雅的管理用户机密数据\"></a>在Asp.NET Core中如何优雅的管理用户机密数据</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><h4 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h4><p>在软件开发过程中，使用配置文件来管理某些对应用程序运行中需要使用的参数是常见的作法。在早期VB/VB.NET时代，经常使用.ini文件来进行配置管理；而在.NET FX开发中，我们则倾向于使用web.config文件，通过配置appsetting的配置节来处理；而在.NET Core开发中，我们有了新的基于json格式的appsetting.json文件。</p>\n<p>无论采用哪种方式，其实配置管理从来都是一件看起来简单，但影响非常深远的基础性工作。尤其是配置的安全性，贯穿应用程序的始终，如果没能做好安全性问题，极有可能会给系统带来不可控的风向。</p>\n<h4 id=\"源代码比配置文件安全么？\"><a href=\"#源代码比配置文件安全么？\" class=\"headerlink\" title=\"源代码比配置文件安全么？\"></a>源代码比配置文件安全么？</h4><p>有人以为把配置存放在源代码中，可能比存放在明文的配置文件中似乎更安全，其实是“皇帝的新装”。</p>\n<p>在前不久，笔者的一位朋友就跟我说了一段故事：他说一位同事在离职后，直接将曾经写过的一段代码上传到github的公共仓库，而这段代码中包含了某些涉及到原企业的机密数据，还好被github的安全机制提前发现而及时终止了该行为，否则后果不堪设想。</p>\n<p>于是，笔者顺手查了一下由于有意或无意泄露企业机密，造成企业损失的案例，发现还真不少。例如<a href=\"https://www.infoq.cn/article/RZzfel1m6-h8pSK8TTC9\" target=\"_blank\" rel=\"noopener\">大疆前员工通过 Github 泄露公司源代码，被罚 20 万、获刑半年</a>  这起案件，也是一个典型的案例。</p>\n<p>该员工离职后，将包含关键配置信息的源代码上传到github的公共仓库，被黑客利用，使得大量用户私人数据被黑客获取，该前员工最终被刑拘。 <img src=\"https://static.geekbang.org/infoq/5cc32361f3500.png?imageView2/0/w/800\" alt=\"大疆前员工通过Github泄露公司源代码，被罚20万、获刑半年\"> </p>\n<p> 图片来源：<a href=\"http://www.digitalmunition.com/WhyIWalkedFrom3k.pdf\" target=\"_blank\" rel=\"noopener\"> http://www.digitalmunition.com/WhyIWalkedFrom3k.pdf</a> </p>\n<p>大部分IT公司都会在入职前进行背景调查，而一旦有案底，可能就已经与许多IT公司无缘；即便是成为创业者，也可能面临无法跟很多正规企业合作的问题。</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>所以，安全性问题不容小觑，哪怕时间再忙，也不要急匆匆的就将数据库连接字符串或其他包含敏感信息的内容轻易的记录在源代码或配置文件中。在这个点上，一旦出现问题，往往都是非常严重的问题。</p>\n<h2 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><p>在.NET FX时代，我们可以使用对web.config文件的关键配置节进行加密的方式，来保护我们的敏感信息，在.NET Core中，自然也有这些东西，接下来我将简述在开发环境和生产环境下不同的配置加密手段，希望能够给读者带来启迪。</p>\n<h4 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h4><p>在开发环境下，我们可以使用visual studio 工具提供的用户机密管理器，只需0行代码，即可轻松完成关键配置节的处理。</p>\n<h5 id=\"机密管理器概述\"><a href=\"#机密管理器概述\" class=\"headerlink\" title=\"机密管理器概述\"></a>机密管理器概述</h5><p>根据<a href=\"https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/secure-net-microservices-web-applications/developer-app-secrets-storage\" target=\"_blank\" rel=\"noopener\">微软官方文档</a> 的描述：</p>\n<blockquote>\n<p>ASP.NET Core <a href=\"https://docs.microsoft.com/zh-cn/aspnet/core/security/app-secrets#secret-manager\" target=\"_blank\" rel=\"noopener\">机密管理器</a>工具提供了开发过程中在源代码外部保存机密的另一种方法 。 若要使用机密管理器工具，请在项目文件中安装包 Microsoft.Extensions.Configuration.SecretManager 。 如果该依赖项存在并且已还原，则可以使用 <code>dotnet user-secrets</code> 命令来通过命令行设置机密的值。 这些机密将存储在用户配置文件目录中的 JSON 文件中（详细信息随操作系统而异），与源代码无关。</p>\n<p>机密管理器工具设置的机密是由使用机密的项目的 <code>UserSecretsId</code> 属性组织的。 因此，必须确保在项目文件中设置 UserSecretsId 属性，如下面的代码片段所示。 默认值是 Visual Studio 分配的 GUID，但实际字符串并不重要，只要它在计算机中是唯一的。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"tag\">&lt;<span class=\"name\">PropertyGroup</span>&gt;</span></span><br><span class=\"line\">&gt;    <span class=\"tag\">&lt;<span class=\"name\">UserSecretsId</span>&gt;</span>UniqueIdentifyingString<span class=\"tag\">&lt;/<span class=\"name\">UserSecretsId</span>&gt;</span></span><br><span class=\"line\">&gt; <span class=\"tag\">&lt;/<span class=\"name\">PropertyGroup</span>&gt;</span> </span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Secret Manager工具允许开发人员在开发ASP.NET Core应用程序期间存储和检索敏感数据。敏感数据存储在与应用程序源代码不同的位置。由于Secret Manager将秘密与源代码分开存储，因此敏感数据不会提交到源代码存储库。但机密管理器不会对存储的敏感数据进行加密，因此不应将其视为可信存储。敏感数据作为键值对存储在JSON文件中。最好<strong>不要</strong>在开发和测试环境中使用生产机密。<a href=\"https://nvisium.com/blog/2019/05/02/Dev-Secrets-and-the-ASP-NET-Core-Secret-Manager.html\" target=\"_blank\" rel=\"noopener\">查看引文</a>。</p>\n<h5 id=\"存放位置\"><a href=\"#存放位置\" class=\"headerlink\" title=\"存放位置\"></a>存放位置</h5><p>在windows平台下，机密数据的存放位置为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%APPDATA%\\Microsoft\\UserSecrets\\\\secrets.json</span><br></pre></td></tr></table></figure>\n\n<p>而在Linux/MacOs平台下，机密数据的存放位置为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/.microsoft/usersecrets/&lt;user_secrets_id&gt;/secrets.json</span><br></pre></td></tr></table></figure>\n\n<p> 在前面的文件路径中， ``将替换<code>UserSecretsId</code>为 <em>.csproj</em>文件中指定的值。 </p>\n<h5 id=\"在Windows环境下使用机密管理器\"><a href=\"#在Windows环境下使用机密管理器\" class=\"headerlink\" title=\"在Windows环境下使用机密管理器\"></a>在Windows环境下使用机密管理器</h5><p>在windows下，如果使用Visual Studio2019作为主力开发环境，只需在项目右键单击，选择菜单【管理用户机密】，即可添加用户机密数据。   </p>\n<p><img src=\"/images/how-to-manage-user-secret-in-develop-and-production_1.png\" alt></p>\n<p>在管理用户机密数据中，添加的配置信息和传统的配置信息没有任何区别。</p>\n<blockquote>\n<p>{<br>  “ConnectionStrings”: {<br>    “Default”: “Server=xxx;Database=xxx;User ID=xxx;Password=xxx;”<br>  }<br>}</p>\n</blockquote>\n<p>我们同样也可以使用IConfiguration的方式、IOptions<t>的方式，进行配置的访问。</t></p>\n<h5 id=\"在非Windows-非Visual-Studio环境下使用机密管理器\"><a href=\"#在非Windows-非Visual-Studio环境下使用机密管理器\" class=\"headerlink\" title=\"在非Windows/非Visual Studio环境下使用机密管理器\"></a>在非Windows/非Visual Studio环境下使用机密管理器</h5><p>完成安装dotnet-cli后，在控制台输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet user-secrets init</span><br></pre></td></tr></table></figure>\n\n<p> 前面的命令将在<code>UserSecretsId</code> .csproj 文件的<code>PropertyGroup</code>中添加 <em>.csproj</em>一个元素。 <code>UserSecretsId</code>是对项目是唯一的Guid值。 </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">PropertyGroup</span>&gt;</span>  </span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">TargetFramework</span>&gt;</span>netcoreapp3.1<span class=\"tag\">&lt;/<span class=\"name\">TargetFramework</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">UserSecretsId</span>&gt;</span>79a3edd0-2092-40a2-a04d-dcb46d5ca9ed<span class=\"tag\">&lt;/<span class=\"name\">UserSecretsId</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>设置机密</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet user-secrets set &quot;Movies:ServiceApiKey&quot; &quot;12345&quot;</span><br></pre></td></tr></table></figure>\n\n<p>列出机密</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet user-secrets list</span><br></pre></td></tr></table></figure>\n\n<p>删除机密</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet user-secrets remove &quot;Movies:ConnectionString&quot;</span><br></pre></td></tr></table></figure>\n\n<p>清除所有机密</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet user-secrets clear</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生产环境\"><a href=\"#生产环境\" class=\"headerlink\" title=\"生产环境\"></a>生产环境</h4><p>机密管理器为开发者在开发环境下提供了一种保留机密数据的方法，但在开发环境下是不建议使用的，如果想在生产环境下，对机密数据进行保存该怎么办？</p>\n<p>按照微软官方文档的说法，推荐使用<a href=\"https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/secure-net-microservices-web-applications/azure-key-vault-protects-secrets\" target=\"_blank\" rel=\"noopener\">Azure Key Vault </a> 来保护机密数据，但。。我不是贵云的用户（当然，买不起贵云不是贵云太贵，而是我个人的问题[手动狗头]）。</p>\n<p>其次，与Azure Key Valut类似的套件，例如其他云，差不多都有，所以都可以为我们所用。</p>\n<p>但。。如果您如果跟我一样，不想通过第三方依赖的形式来解决这个问题，那不如就用最简单的办法，例如AES加密。</p>\n<h5 id=\"使用AES加密配置节\"><a href=\"#使用AES加密配置节\" class=\"headerlink\" title=\"使用AES加密配置节\"></a>使用AES加密配置节</h5><p>该方法与平时使用AES对字符串进行加密和解密的方法并无区别，此处从略。  </p>\n<h5 id=\"使用数据保护Api（DataProtect-Api实现）\"><a href=\"#使用数据保护Api（DataProtect-Api实现）\" class=\"headerlink\" title=\"使用数据保护Api（DataProtect Api实现）\"></a>使用数据保护Api（DataProtect Api实现）</h5><p>在平时开发过程中，能够动手撸AES加密是一种非常好的习惯，而微软官方提供的数据保护API则将这个过程进一步简化，只需调Api即可完成相应的数据加密操作。</p>\n<p>关于数据保护api， <a href=\"https://home.cnblogs.com/u/savorboard/\" target=\"_blank\" rel=\"noopener\">Savorboard</a> 大佬曾经写过3篇博客讨论这个技术问题，大家可以参考下面的文章来获取信息。</p>\n<p><a href=\"https://www.cnblogs.com/savorboard/p/dotnetcore-data-protection.html\" target=\"_blank\" rel=\"noopener\">ASP.NET Core 数据保护（Data Protection 集群场景）【上】</a></p>\n<p><a href=\"https://www.cnblogs.com/savorboard/p/dotnet-core-data-protection.html\" target=\"_blank\" rel=\"noopener\">ASP.NET Core 数据保护（Data Protection 集群场景）【中】</a></p>\n<p><a href=\"https://www.cnblogs.com/savorboard/p/dotnetcore-data-protected-farm.html\" target=\"_blank\" rel=\"noopener\">ASP.NET Core 数据保护（Data Protection 集群场景）【下】</a></p>\n<p>(接下来我要贴代码了，如果没兴趣，请出门左拐，代码不能完整运行，<a href=\"https://stackoverflow.com/questions/36062670/encrypted-configuration-in-asp-net-core\" target=\"_blank\" rel=\"noopener\">查看代码</a>）</p>\n<p>首先，注入配置项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static IServiceCollection AddProtectedConfiguration(this IServiceCollection services, string directory)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           services</span><br><span class=\"line\">               .AddDataProtection()</span><br><span class=\"line\">               .PersistKeysToFileSystem(new DirectoryInfo(directory))</span><br><span class=\"line\">               .UseCustomCryptographicAlgorithms(new ManagedAuthenticatedEncryptorConfiguration</span><br><span class=\"line\">               &#123;</span><br><span class=\"line\">                   EncryptionAlgorithmType = typeof(Aes),</span><br><span class=\"line\">                   EncryptionAlgorithmKeySize = 256,</span><br><span class=\"line\">                   ValidationAlgorithmType = typeof(HMACSHA256)</span><br><span class=\"line\">               &#125;);</span><br><span class=\"line\">           ;</span><br><span class=\"line\"></span><br><span class=\"line\">           return services;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n\n<p>其次，实现对配置节的加/解密。（使用AES算法的数据保护机制）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class ProtectedConfigurationSection : IConfigurationSection</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private readonly IDataProtectionProvider _dataProtectionProvider;</span><br><span class=\"line\">        private readonly IConfigurationSection _section;</span><br><span class=\"line\">        private readonly Lazy&lt;IDataProtector&gt; _protector;</span><br><span class=\"line\"></span><br><span class=\"line\">        public ProtectedConfigurationSection(</span><br><span class=\"line\">            IDataProtectionProvider dataProtectionProvider,</span><br><span class=\"line\">            IConfigurationSection section)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _dataProtectionProvider = dataProtectionProvider;</span><br><span class=\"line\">            _section = section;</span><br><span class=\"line\"></span><br><span class=\"line\">            _protector = new Lazy&lt;IDataProtector&gt;(() =&gt; dataProtectionProvider.CreateProtector(section.Path));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public IConfigurationSection GetSection(string key)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return new ProtectedConfigurationSection(_dataProtectionProvider, _section.GetSection(key));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public IEnumerable&lt;IConfigurationSection&gt; GetChildren()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return _section.GetChildren()</span><br><span class=\"line\">                .Select(x =&gt; new ProtectedConfigurationSection(_dataProtectionProvider, x));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public IChangeToken GetReloadToken()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return _section.GetReloadToken();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public string this[string key]</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            get =&gt; GetProtectedValue(_section[key]);</span><br><span class=\"line\">            set =&gt; _section[key] = _protector.Value.Protect(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public string Key =&gt; _section.Key;</span><br><span class=\"line\">        public string Path =&gt; _section.Path;</span><br><span class=\"line\"></span><br><span class=\"line\">        public string Value</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            get =&gt; GetProtectedValue(_section.Value);</span><br><span class=\"line\">            set =&gt; _section.Value = _protector.Value.Protect(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        private string GetProtectedValue(string value)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (value == null)</span><br><span class=\"line\">                return null;</span><br><span class=\"line\"></span><br><span class=\"line\">            return _protector.Value.Unprotect(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>再次，在使用前，先将待加密的字符串转换成BASE64纯文本，然后再使用数据保护API对数据进行处理，得到处理后的字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private readonly IDataProtectionProvider _dataProtectorTokenProvider;</span><br><span class=\"line\">public TokenAuthController( IDataProtectionProvider dataProtectorTokenProvider)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[Route(&quot;encrypt&quot;), HttpGet, HttpPost]</span><br><span class=\"line\">public string Encrypt(string section, string value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     var protector = _dataProtectorTokenProvider.CreateProtector(section);</span><br><span class=\"line\">     return protector.Protect(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再替换配置文件中的对应内容。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"ConnectionStrings\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"Default\"</span>: <span class=\"string\">\"此处是加密后的字符串\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们就可以按照平时获取IOptions<connectstrings>的方式来获取了。</connectstrings></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>公众号【DotNET骚操作】号主【周杰】同学提出以下观点：</p>\n<p><strong>1、在生产环境下，使用AES加密，其实依然是一种不够安全的行为，充其量也就能忽悠下产品经理，毕竟几条简单的语句，就能把机密数据dump出来。</strong></p>\n<p> 也许在这种情况下，我们应该优先考虑accessKeyId/accessSecret，尽量通过设置多级子账号，通过授权Api的机制来管理机密数据，而不是直接暴露类似于数据库连接字符串这样的关键配置信息。另外，应该定期更换数据库的密码，尽量将类似的问题可能造成的风险降到最低。数据保护api也提供的类似的机制，使得开发者能够轻松的管理机密数据的时效性问题。</p>\n<p><strong>2、配置文件放到CI/CD中，发布的时候在CI/CD中进行组装，然后运维只是负责管理CI/CD的账户信息，而最高机密数据，则由其他人负责配置。</strong></p>\n<p>嗯，我完全同意他的第二种做法，另外考虑到由于运维同样有可能会有意无意泄露机密数据，所以如果再给运维配备一本《刑法》，并让他日常补习【侵犯商业秘密罪】相关条款，这个流程就更加闭环了。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本文简述了在.NET Core中，如何在开发环境下使用用户机密管理器、在生产环境下使用AES+IDataProvider的方式来保护我们的用户敏感数据。由于时间仓促，如有考虑不周之处，还请各位大佬批评指正。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"在Asp-NET-Core中如何优雅的管理用户机密数据\"><a href=\"#在Asp-NET-Core中如何优雅的管理用户机密数据\" class=\"headerlink\" title=\"在Asp.NET Core中如何优雅的管理用户机密数据\"></a>在Asp.NET Core中如何优雅的管理用户机密数据</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><h4 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h4><p>在软件开发过程中，使用配置文件来管理某些对应用程序运行中需要使用的参数是常见的作法。在早期VB/VB.NET时代，经常使用.ini文件来进行配置管理；而在.NET FX开发中，我们则倾向于使用web.config文件，通过配置appsetting的配置节来处理；而在.NET Core开发中，我们有了新的基于json格式的appsetting.json文件。</p>\n<p>无论采用哪种方式，其实配置管理从来都是一件看起来简单，但影响非常深远的基础性工作。尤其是配置的安全性，贯穿应用程序的始终，如果没能做好安全性问题，极有可能会给系统带来不可控的风向。</p>\n<h4 id=\"源代码比配置文件安全么？\"><a href=\"#源代码比配置文件安全么？\" class=\"headerlink\" title=\"源代码比配置文件安全么？\"></a>源代码比配置文件安全么？</h4><p>有人以为把配置存放在源代码中，可能比存放在明文的配置文件中似乎更安全，其实是“皇帝的新装”。</p>\n<p>在前不久，笔者的一位朋友就跟我说了一段故事：他说一位同事在离职后，直接将曾经写过的一段代码上传到github的公共仓库，而这段代码中包含了某些涉及到原企业的机密数据，还好被github的安全机制提前发现而及时终止了该行为，否则后果不堪设想。</p>\n<p>于是，笔者顺手查了一下由于有意或无意泄露企业机密，造成企业损失的案例，发现还真不少。例如<a href=\"https://www.infoq.cn/article/RZzfel1m6-h8pSK8TTC9\" target=\"_blank\" rel=\"noopener\">大疆前员工通过 Github 泄露公司源代码，被罚 20 万、获刑半年</a>  这起案件，也是一个典型的案例。</p>\n<p>该员工离职后，将包含关键配置信息的源代码上传到github的公共仓库，被黑客利用，使得大量用户私人数据被黑客获取，该前员工最终被刑拘。 <img src=\"https://static.geekbang.org/infoq/5cc32361f3500.png?imageView2/0/w/800\" alt=\"大疆前员工通过Github泄露公司源代码，被罚20万、获刑半年\"> </p>\n<p> 图片来源：<a href=\"http://www.digitalmunition.com/WhyIWalkedFrom3k.pdf\" target=\"_blank\" rel=\"noopener\"> http://www.digitalmunition.com/WhyIWalkedFrom3k.pdf</a> </p>\n<p>大部分IT公司都会在入职前进行背景调查，而一旦有案底，可能就已经与许多IT公司无缘；即便是成为创业者，也可能面临无法跟很多正规企业合作的问题。</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>所以，安全性问题不容小觑，哪怕时间再忙，也不要急匆匆的就将数据库连接字符串或其他包含敏感信息的内容轻易的记录在源代码或配置文件中。在这个点上，一旦出现问题，往往都是非常严重的问题。</p>\n<h2 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><p>在.NET FX时代，我们可以使用对web.config文件的关键配置节进行加密的方式，来保护我们的敏感信息，在.NET Core中，自然也有这些东西，接下来我将简述在开发环境和生产环境下不同的配置加密手段，希望能够给读者带来启迪。</p>\n<h4 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h4><p>在开发环境下，我们可以使用visual studio 工具提供的用户机密管理器，只需0行代码，即可轻松完成关键配置节的处理。</p>\n<h5 id=\"机密管理器概述\"><a href=\"#机密管理器概述\" class=\"headerlink\" title=\"机密管理器概述\"></a>机密管理器概述</h5><p>根据<a href=\"https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/secure-net-microservices-web-applications/developer-app-secrets-storage\" target=\"_blank\" rel=\"noopener\">微软官方文档</a> 的描述：</p>\n<blockquote>\n<p>ASP.NET Core <a href=\"https://docs.microsoft.com/zh-cn/aspnet/core/security/app-secrets#secret-manager\" target=\"_blank\" rel=\"noopener\">机密管理器</a>工具提供了开发过程中在源代码外部保存机密的另一种方法 。 若要使用机密管理器工具，请在项目文件中安装包 Microsoft.Extensions.Configuration.SecretManager 。 如果该依赖项存在并且已还原，则可以使用 <code>dotnet user-secrets</code> 命令来通过命令行设置机密的值。 这些机密将存储在用户配置文件目录中的 JSON 文件中（详细信息随操作系统而异），与源代码无关。</p>\n<p>机密管理器工具设置的机密是由使用机密的项目的 <code>UserSecretsId</code> 属性组织的。 因此，必须确保在项目文件中设置 UserSecretsId 属性，如下面的代码片段所示。 默认值是 Visual Studio 分配的 GUID，但实际字符串并不重要，只要它在计算机中是唯一的。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"tag\">&lt;<span class=\"name\">PropertyGroup</span>&gt;</span></span><br><span class=\"line\">&gt;    <span class=\"tag\">&lt;<span class=\"name\">UserSecretsId</span>&gt;</span>UniqueIdentifyingString<span class=\"tag\">&lt;/<span class=\"name\">UserSecretsId</span>&gt;</span></span><br><span class=\"line\">&gt; <span class=\"tag\">&lt;/<span class=\"name\">PropertyGroup</span>&gt;</span> </span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>Secret Manager工具允许开发人员在开发ASP.NET Core应用程序期间存储和检索敏感数据。敏感数据存储在与应用程序源代码不同的位置。由于Secret Manager将秘密与源代码分开存储，因此敏感数据不会提交到源代码存储库。但机密管理器不会对存储的敏感数据进行加密，因此不应将其视为可信存储。敏感数据作为键值对存储在JSON文件中。最好<strong>不要</strong>在开发和测试环境中使用生产机密。<a href=\"https://nvisium.com/blog/2019/05/02/Dev-Secrets-and-the-ASP-NET-Core-Secret-Manager.html\" target=\"_blank\" rel=\"noopener\">查看引文</a>。</p>\n<h5 id=\"存放位置\"><a href=\"#存放位置\" class=\"headerlink\" title=\"存放位置\"></a>存放位置</h5><p>在windows平台下，机密数据的存放位置为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%APPDATA%\\Microsoft\\UserSecrets\\\\secrets.json</span><br></pre></td></tr></table></figure>\n\n<p>而在Linux/MacOs平台下，机密数据的存放位置为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/.microsoft/usersecrets/&lt;user_secrets_id&gt;/secrets.json</span><br></pre></td></tr></table></figure>\n\n<p> 在前面的文件路径中， ``将替换<code>UserSecretsId</code>为 <em>.csproj</em>文件中指定的值。 </p>\n<h5 id=\"在Windows环境下使用机密管理器\"><a href=\"#在Windows环境下使用机密管理器\" class=\"headerlink\" title=\"在Windows环境下使用机密管理器\"></a>在Windows环境下使用机密管理器</h5><p>在windows下，如果使用Visual Studio2019作为主力开发环境，只需在项目右键单击，选择菜单【管理用户机密】，即可添加用户机密数据。   </p>\n<p><img src=\"/images/how-to-manage-user-secret-in-develop-and-production_1.png\" alt></p>\n<p>在管理用户机密数据中，添加的配置信息和传统的配置信息没有任何区别。</p>\n<blockquote>\n<p>{<br>  “ConnectionStrings”: {<br>    “Default”: “Server=xxx;Database=xxx;User ID=xxx;Password=xxx;”<br>  }<br>}</p>\n</blockquote>\n<p>我们同样也可以使用IConfiguration的方式、IOptions<t>的方式，进行配置的访问。</t></p>\n<h5 id=\"在非Windows-非Visual-Studio环境下使用机密管理器\"><a href=\"#在非Windows-非Visual-Studio环境下使用机密管理器\" class=\"headerlink\" title=\"在非Windows/非Visual Studio环境下使用机密管理器\"></a>在非Windows/非Visual Studio环境下使用机密管理器</h5><p>完成安装dotnet-cli后，在控制台输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet user-secrets init</span><br></pre></td></tr></table></figure>\n\n<p> 前面的命令将在<code>UserSecretsId</code> .csproj 文件的<code>PropertyGroup</code>中添加 <em>.csproj</em>一个元素。 <code>UserSecretsId</code>是对项目是唯一的Guid值。 </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">PropertyGroup</span>&gt;</span>  </span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">TargetFramework</span>&gt;</span>netcoreapp3.1<span class=\"tag\">&lt;/<span class=\"name\">TargetFramework</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">UserSecretsId</span>&gt;</span>79a3edd0-2092-40a2-a04d-dcb46d5ca9ed<span class=\"tag\">&lt;/<span class=\"name\">UserSecretsId</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>设置机密</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet user-secrets set &quot;Movies:ServiceApiKey&quot; &quot;12345&quot;</span><br></pre></td></tr></table></figure>\n\n<p>列出机密</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet user-secrets list</span><br></pre></td></tr></table></figure>\n\n<p>删除机密</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet user-secrets remove &quot;Movies:ConnectionString&quot;</span><br></pre></td></tr></table></figure>\n\n<p>清除所有机密</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet user-secrets clear</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生产环境\"><a href=\"#生产环境\" class=\"headerlink\" title=\"生产环境\"></a>生产环境</h4><p>机密管理器为开发者在开发环境下提供了一种保留机密数据的方法，但在开发环境下是不建议使用的，如果想在生产环境下，对机密数据进行保存该怎么办？</p>\n<p>按照微软官方文档的说法，推荐使用<a href=\"https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/secure-net-microservices-web-applications/azure-key-vault-protects-secrets\" target=\"_blank\" rel=\"noopener\">Azure Key Vault </a> 来保护机密数据，但。。我不是贵云的用户（当然，买不起贵云不是贵云太贵，而是我个人的问题[手动狗头]）。</p>\n<p>其次，与Azure Key Valut类似的套件，例如其他云，差不多都有，所以都可以为我们所用。</p>\n<p>但。。如果您如果跟我一样，不想通过第三方依赖的形式来解决这个问题，那不如就用最简单的办法，例如AES加密。</p>\n<h5 id=\"使用AES加密配置节\"><a href=\"#使用AES加密配置节\" class=\"headerlink\" title=\"使用AES加密配置节\"></a>使用AES加密配置节</h5><p>该方法与平时使用AES对字符串进行加密和解密的方法并无区别，此处从略。  </p>\n<h5 id=\"使用数据保护Api（DataProtect-Api实现）\"><a href=\"#使用数据保护Api（DataProtect-Api实现）\" class=\"headerlink\" title=\"使用数据保护Api（DataProtect Api实现）\"></a>使用数据保护Api（DataProtect Api实现）</h5><p>在平时开发过程中，能够动手撸AES加密是一种非常好的习惯，而微软官方提供的数据保护API则将这个过程进一步简化，只需调Api即可完成相应的数据加密操作。</p>\n<p>关于数据保护api， <a href=\"https://home.cnblogs.com/u/savorboard/\" target=\"_blank\" rel=\"noopener\">Savorboard</a> 大佬曾经写过3篇博客讨论这个技术问题，大家可以参考下面的文章来获取信息。</p>\n<p><a href=\"https://www.cnblogs.com/savorboard/p/dotnetcore-data-protection.html\" target=\"_blank\" rel=\"noopener\">ASP.NET Core 数据保护（Data Protection 集群场景）【上】</a></p>\n<p><a href=\"https://www.cnblogs.com/savorboard/p/dotnet-core-data-protection.html\" target=\"_blank\" rel=\"noopener\">ASP.NET Core 数据保护（Data Protection 集群场景）【中】</a></p>\n<p><a href=\"https://www.cnblogs.com/savorboard/p/dotnetcore-data-protected-farm.html\" target=\"_blank\" rel=\"noopener\">ASP.NET Core 数据保护（Data Protection 集群场景）【下】</a></p>\n<p>(接下来我要贴代码了，如果没兴趣，请出门左拐，代码不能完整运行，<a href=\"https://stackoverflow.com/questions/36062670/encrypted-configuration-in-asp-net-core\" target=\"_blank\" rel=\"noopener\">查看代码</a>）</p>\n<p>首先，注入配置项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static IServiceCollection AddProtectedConfiguration(this IServiceCollection services, string directory)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           services</span><br><span class=\"line\">               .AddDataProtection()</span><br><span class=\"line\">               .PersistKeysToFileSystem(new DirectoryInfo(directory))</span><br><span class=\"line\">               .UseCustomCryptographicAlgorithms(new ManagedAuthenticatedEncryptorConfiguration</span><br><span class=\"line\">               &#123;</span><br><span class=\"line\">                   EncryptionAlgorithmType = typeof(Aes),</span><br><span class=\"line\">                   EncryptionAlgorithmKeySize = 256,</span><br><span class=\"line\">                   ValidationAlgorithmType = typeof(HMACSHA256)</span><br><span class=\"line\">               &#125;);</span><br><span class=\"line\">           ;</span><br><span class=\"line\"></span><br><span class=\"line\">           return services;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n\n<p>其次，实现对配置节的加/解密。（使用AES算法的数据保护机制）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class ProtectedConfigurationSection : IConfigurationSection</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        private readonly IDataProtectionProvider _dataProtectionProvider;</span><br><span class=\"line\">        private readonly IConfigurationSection _section;</span><br><span class=\"line\">        private readonly Lazy&lt;IDataProtector&gt; _protector;</span><br><span class=\"line\"></span><br><span class=\"line\">        public ProtectedConfigurationSection(</span><br><span class=\"line\">            IDataProtectionProvider dataProtectionProvider,</span><br><span class=\"line\">            IConfigurationSection section)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _dataProtectionProvider = dataProtectionProvider;</span><br><span class=\"line\">            _section = section;</span><br><span class=\"line\"></span><br><span class=\"line\">            _protector = new Lazy&lt;IDataProtector&gt;(() =&gt; dataProtectionProvider.CreateProtector(section.Path));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public IConfigurationSection GetSection(string key)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return new ProtectedConfigurationSection(_dataProtectionProvider, _section.GetSection(key));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public IEnumerable&lt;IConfigurationSection&gt; GetChildren()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return _section.GetChildren()</span><br><span class=\"line\">                .Select(x =&gt; new ProtectedConfigurationSection(_dataProtectionProvider, x));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public IChangeToken GetReloadToken()</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return _section.GetReloadToken();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public string this[string key]</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            get =&gt; GetProtectedValue(_section[key]);</span><br><span class=\"line\">            set =&gt; _section[key] = _protector.Value.Protect(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public string Key =&gt; _section.Key;</span><br><span class=\"line\">        public string Path =&gt; _section.Path;</span><br><span class=\"line\"></span><br><span class=\"line\">        public string Value</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            get =&gt; GetProtectedValue(_section.Value);</span><br><span class=\"line\">            set =&gt; _section.Value = _protector.Value.Protect(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        private string GetProtectedValue(string value)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (value == null)</span><br><span class=\"line\">                return null;</span><br><span class=\"line\"></span><br><span class=\"line\">            return _protector.Value.Unprotect(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>再次，在使用前，先将待加密的字符串转换成BASE64纯文本，然后再使用数据保护API对数据进行处理，得到处理后的字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private readonly IDataProtectionProvider _dataProtectorTokenProvider;</span><br><span class=\"line\">public TokenAuthController( IDataProtectionProvider dataProtectorTokenProvider)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[Route(&quot;encrypt&quot;), HttpGet, HttpPost]</span><br><span class=\"line\">public string Encrypt(string section, string value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     var protector = _dataProtectorTokenProvider.CreateProtector(section);</span><br><span class=\"line\">     return protector.Protect(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再替换配置文件中的对应内容。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"ConnectionStrings\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"Default\"</span>: <span class=\"string\">\"此处是加密后的字符串\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们就可以按照平时获取IOptions<connectstrings>的方式来获取了。</connectstrings></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>公众号【DotNET骚操作】号主【周杰】同学提出以下观点：</p>\n<p><strong>1、在生产环境下，使用AES加密，其实依然是一种不够安全的行为，充其量也就能忽悠下产品经理，毕竟几条简单的语句，就能把机密数据dump出来。</strong></p>\n<p> 也许在这种情况下，我们应该优先考虑accessKeyId/accessSecret，尽量通过设置多级子账号，通过授权Api的机制来管理机密数据，而不是直接暴露类似于数据库连接字符串这样的关键配置信息。另外，应该定期更换数据库的密码，尽量将类似的问题可能造成的风险降到最低。数据保护api也提供的类似的机制，使得开发者能够轻松的管理机密数据的时效性问题。</p>\n<p><strong>2、配置文件放到CI/CD中，发布的时候在CI/CD中进行组装，然后运维只是负责管理CI/CD的账户信息，而最高机密数据，则由其他人负责配置。</strong></p>\n<p>嗯，我完全同意他的第二种做法，另外考虑到由于运维同样有可能会有意无意泄露机密数据，所以如果再给运维配备一本《刑法》，并让他日常补习【侵犯商业秘密罪】相关条款，这个流程就更加闭环了。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本文简述了在.NET Core中，如何在开发环境下使用用户机密管理器、在生产环境下使用AES+IDataProvider的方式来保护我们的用户敏感数据。由于时间仓促，如有考虑不周之处，还请各位大佬批评指正。</p>\n"},{"title":"一步一步的构建整洁、可维护的RESTful APIs","date":"2020-02-23T14:24:00.000Z","author":"邹溪源","_content":"译者荐语：利用周末的时间，本人拜读了长沙.NET技术社区翻译的技术文章《[微软RESTFul API指南](http://techq.club/2019/08/02/%E6%8A%80%E6%9C%AF/Microsoft%20REST%20API%E6%8C%87%E5%8D%97/)》，打算按照步骤写一个完整的教程，后来无意中看到了这篇文章，与我要写的主题有不少相似之处，特意翻译下来。前方高能。\n\n![图片](https://uploader.shimo.im/f/U68C9NmcWwwWHATD.png!thumbnail)一步一步的构建整洁、可维护的RESTful APIs\n\n[查看原文](https://www.techq.xyz/2020/02/23/%E6%8A%80%E6%9C%AF/WPF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%A6%82%E8%BF%B0/)\n\n# 总览\nRESTful不是一个新名词。它是一种架构风格，这种架构风格使用Web服务从客户端应用程序接收数据和向客户端应用程序发送数据。其目标是集中不同客户端应用程序将使用的数据。\n\n选择正确的工具来编写RESTful服务至关重要，因为我们需要关注可伸缩性，维护，文档以及所有其他相关方面。在[ASP.NET](https://docs.microsoft.com/en-us/aspnet/) Core为我们提供了一个功能强大、易于使用的API，使用这些API将很好的实现这个目标。\n\n在本文中，我将向您展示如何使用ASP.NET Core框架为“几乎”现实世界的场景编写结构良好的RESTful API。我将详细介绍常见的模式和策略以简化开发过程。\n\n我还将向您展示如何集成通用框架和库，例如[Entity Framework Core](https://docs.microsoft.com/en-us/ef/core/)和[AutoMapper](https://automapper.org/)，以提供必要的功能。\n\n# **先决条件**\n我希望您了解面向对象的编程概念。\n\n即使我将介绍[C＃编程语言](https://docs.microsoft.com/en-us/dotnet/csharp/)的许多细节，我还是建议您具有该主题的基本知识。\n\n我还假设您知道什么是REST，[HTTP协议](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)如何工作，什么是API端点以及什么是[JSON](https://www.json.org/)。[这是](https://medium.freecodecamp.org/restful-services-part-i-http-in-a-nutshell-aab3bfedd131)关于此主题[的出色的入门教程](https://medium.freecodecamp.org/restful-services-part-i-http-in-a-nutshell-aab3bfedd131)。最后，您需要了解关系数据库的工作原理。\n\n要与我一起编码，您将必须安装[.NET Core 2.2](https://dotnet.microsoft.com/download)以及[Postman](https://www.getpostman.com/)（我将用来测试API的工具）。我建议您使用诸如[Visual Studio Code之](https://code.visualstudio.com/)类的代码编辑器来开发API。选择您喜欢的代码编辑器。如果选择Visual Studio Code作为您的代码编辑器，建议您安装[C＃扩展](https://code.visualstudio.com/docs/languages/csharp)以更好地突出显示代码。\n\n您可以在本文末尾找到该API的Github的链接，以检查最终结果。\n\n# **范围**\n让我们为一家超市编写一个虚构的Web API。假设我们必须实现以下范围：\n\n* *创建一个RESTful服务，该服务允许客户端应用程序管理超市的产品目录。它需要公开端点以创建，读取，编辑和删除产品类别，例如乳制品和化妆品，还需要管理这些类别的产品。*\n* *对于类别，我们需要存储其名称。对于产品，我们需要存储其名称，度量单位（例如，按重量测量的产品为KG），包装中的数量（例如，如果一包饼干是10，则为10）及其各自的类别。*\n\n为了简化示例，我将不处理库存产品，产品运输，安全性和任何其他功能。这个范围足以向您展示ASP.NET Core的工作方式。\n\n要开发此服务，我们基本上需要两个API 端点（译者注：指控制器）：一个用于管理类别，一个用于管理产品。在JSON通讯方面，我们可以认为响应如下：\n\n```\nAPI endpoint: /api/categories\nJSON Response (for GET requests):\n{\n  [\n    { \"id\": 1, \"name\": \"Fruits and Vegetables\" },\n    { \"id\": 2, \"name\": \"Breads\" },\n    … // Other categories\n  ]\n}\n```\n```\nAPI endpoint: /api/products\nJSON Response (for GET requests):\n{\n  [\n    {\n      \"id\": 1,\n      \"name\": \"Sugar\",\n      \"quantityInPackage\": 1,\n      \"unitOfMeasurement\": \"KG\"\n      \"category\": {\n        \"id\": 3,\n        \"name\": \"Sugar\"\n      }\n    },\n    … // Other products\n  ]\n}\n```\n让我们开始编写应用程序。\n# **第1步-创建API**\n首先，我们必须为Web服务创建文件夹结构，然后我们必须使用[.NET CLI工具](https://docs.microsoft.com/en-us/dotnet/core/tools/?tabs=netcore2x)来构建基本的Web API。打开终端或命令提示符（取决于您使用的操作系统），并依次键入以下命令：\n\n```\nmkdir src/Supermarket.API\n\ncd src/Supermarket.API\n\ndotnet new webapi\n```\n前两个命令只是为API创建一个新目录，然后将当前位置更改为新文件夹。最后一个遵循Web API模板生成一个新项目，这是我们正在开发的应用程序。您可以阅读有关这些命令和其他项目模板的更多信息，并可以通过[检查此链接](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new?tabs=netcore21)来生成其他项目模板。\n现在，新目录将具有以下结构：\n\n![图片](https://uploader.shimo.im/f/LuICwkhqHDsD5RcN.png!thumbnail)\n\n项目结构\n\n## 结构概述\nASP.NET Core应用程序由在类中配置的一组[中间件](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-2.2)（应用程序流水线中的小块应用程序，用于处理请求和响应）组成Startup。如果您以前已经使用过[Express.js](https://expressjs.com/)之类的框架，那么这个概念对您来说并不是什么新鲜事物。\n\n```\npublic class Startup\n\t{\n\t    public Startup(IConfiguration configuration)\n\t    {\n\t        Configuration = configuration;\n\t    }\n\t\n\n\t    public IConfiguration Configuration { get; }\n\t\n\n\t    // This method gets called by the runtime. Use this method to add services to the container.\n\t    public void ConfigureServices(IServiceCollection services)\n\t    {\n\t        services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);\n\t    }\n\t\n\n\t    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n\t    public void Configure(IApplicationBuilder app, IHostingEnvironment env)\n\t    {\n\t        if (env.IsDevelopment())\n\t        {\n\t            app.UseDeveloperExceptionPage();\n\t        }\n\t        else\n\t        {\n\t            // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.\n\t            app.UseHsts();\n\t        }\n\t\n\n\t        app.UseHttpsRedirection();\n\t        app.UseMvc();\n\t    }\n\t}\n```\n当应用程序启动时，将调用类中的Main** **方法Program。它使用启动配置创建默认的Web主机，通过HTTP通过特定端口（默认情况下，HTTP为5000，HTTPS为5001）公开应用程序。\n```\nnamespace Supermarket.API\n\t{\n\t    public class Program\n\t    {\n\t        public static void Main(string[] args)\n\t        {\n\t            CreateWebHostBuilder(args).Build().Run();\n\t        }\n\t\n\n\t        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =>\n\t            WebHost.CreateDefaultBuilder(args)\n\t                .UseStartup<Startup>();\n\t    }\n\t}\n```\n看一下文件夹中的ValuesController类Controllers。它公开了API通过路由接收请求时将调用的方法/api/values。\n```\n[Route(\"api/[controller]\")]\n\t[ApiController]\n\tpublic class ValuesController : ControllerBase\n\t{\n\t    // GET api/values\n\t    [HttpGet]\n\t    public ActionResult<IEnumerable<string>> Get()\n\t    {\n\t        return new string[] { \"value1\", \"value2\" };\n\t    }\n\t\n\n\t    // GET api/values/5\n\t    [HttpGet(\"{id}\")]\n\t    public ActionResult<string> Get(int id)\n\t    {\n\t        return \"value\";\n\t    }\n\t\n\n\t    // POST api/values\n\t    [HttpPost]\n\t    public void Post([FromBody] string value)\n\t    { \n\t    }\n\t\n\n\t    // PUT api/values/5\n\t    [HttpPut(\"{id}\")]\n\t    public void Put(int id, [FromBody] string value)\n\t    {   \n\t    }\n\t\n\n\t    // DELETE api/values/5\n\t    [HttpDelete(\"{id}\")]\n\t    public void Delete(int id)\n\t    {  \n\t    }\n\t}\n```\n如果您不了解此代码的某些部分，请不要担心。在开发必要的API端点时，我将详细介绍每一个。现在，只需删除此类，因为我们不会使用它。\n# **第2步-创建领域模型**\n我将应用一些设计概念，以使应用程序简单易维护。\n\n编写可以由您自己理解和维护的代码并不难，但是您必须牢记您将成为团队的一部分。如果您不注意如何编写代码，那么结果将是一个庞然大物，这将使您和您的团队成员头痛不已。听起来很极端吧？但是相信我，这就是事实。\n\n![图片](https://uploader.shimo.im/f/vMGZaW8zLiA39wxb.png!thumbnail)\n\n衡量好代码的标准是WTF的频率。原图来自[smitty42](https://www.flickr.com/photos/smitty/)，发表于[filckr](https://www.flickr.com/photos/smitty/2245445147)。该图遵循CC-BY-2.0。\n\n在Supermarket.API目录中，创建一个名为的新文件夹Domain。在新的领域文件夹中，创建另一个名为的文件夹Models。我们必须添加到此文件夹的第一个模型是Category。最初，它将是一个简单的[Plain Old CLR Object（POCO）](https://en.wikipedia.org/wiki/Plain_old_CLR_object)类。这意味着该类将仅具有描述其基本信息的属性。\n\n```\nusing System.Collections.Generic;\n\t\n\n\tnamespace Supermarket.API.Domain.Models\n\t{\n\t    public class Category\n\t    {\n\t        public int Id { get; set; }\n\t        public string Name { get; set; }\n\t        public IList<Product> Products { get; set; } = new List<Product>();\n\t    }\n\t}\n```\n该类具有一个Id** **属性（用于标识类别）和一个Name属性。以及一个Products** **属性。最后一个属性将由**Entity Framework Core使用**，大多数ASP.NET Core应用程序使用ORM将数据持久化到数据库中，以映射类别和产品之间的关系。由于类别具有许多相关产品，因此在面向对象的编程方面也具有合理的思维能力。\n我们还必须创建产品模型。在同一文件夹中，添加一个新Product类。\n\n```\nnamespace Supermarket.API.Domain.Models\n\t{\n\t    public class Product\n\t    {\n\t        public int Id { get; set; }\n\t        public string Name { get; set; }\n\t        public short QuantityInPackage { get; set; }\n\t        public EUnitOfMeasurement UnitOfMeasurement { get; set; }\n\t\n\n\t        public int CategoryId { get; set; }\n\t        public Category Category { get; set; }\n\t    }\n\t}\n```\n该产品还具有ID和名称的属性。属性QuantityInPackage，它告诉我们一包中有多少个产品单位（请记住应用范围的饼干示例）和一个UnitOfMeasurement** **属性，这是表示一个[枚举类型](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum)，它表示可能的度量单位的枚举。最后两个属性，CategoryId** **和Category将由ORM用于映射的产品和类别之间的关系。它表明一种产品只有一个类别。\n\n让我们定义领域模型的最后一部分，EUnitOfMeasurement** **枚举。\n\n按照惯例，枚举不需要在名称前以*“ E”*开头，但是在某些库和框架中，您会发现此前缀是将枚举与接口和类区分开的一种方式。\n\n```\nusing System.ComponentModel;\n\t\n\n\tnamespace Supermarket.API.Domain.Models\n\t{\n\t    public enum EUnitOfMeasurement : byte\n\t    {\n\t        [Description(\"UN\")]\n\t        Unity = 1,\n\t\n\n\t        [Description(\"MG\")]\n\t        Milligram = 2,\n\t\n\n\t        [Description(\"G\")]\n\t        Gram = 3,\n\t\n\n\t        [Description(\"KG\")]\n\t        Kilogram = 4,\n\t\n\n\t        [Description(\"L\")]\n\t        Liter = 5\n\t    }\n\t}\n```\n该代码非常简单。在这里，我们仅定义了几种度量单位的可能性，但是，在实际的超市系统中，您可能具有许多其他度量单位，并且可能还有一个单独的模型。\n注意，【Description】特性应用于所有枚举可能性。特性是一种在C＃语言的类，接口，属性和其他组件上定义元数据的方法。在这种情况下，我们将使用它来简化产品API端点的响应，但是您现在不必关心它。我们待会再回到这里。\n\n我们的基本模型已准备就绪，可以使用。现在，我们可以开始编写将管理所有类别的API端点。\n\n# **第3步-类别API**\n在Controllers文件夹中，添加一个名为的新类CategoriesController。\n\n按照惯例，该文件夹中所有后缀为*“ Controller”的类*都将成为我们应用程序的控制器。这意味着他们将处理请求和响应。您必须从[命名空间](https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/namespace)【Microsoft.AspNetCore.Mvc】继承Controller。\n\n命名空间由一组相关的类，接口，枚举和结构组成。您可以将其视为类似于Java语言[模块](https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc)或Java [程序包](https://docs.oracle.com/javase/tutorial/java/package/packages.html)的东西。\n\n新的控制器应通过路由/api/categories做出响应。我们通过Route** **在类名称上方添加属性，指定占位符来实现此目的，该占位符表示路由应按照惯例使用不带控制器后缀的类名称。\n\n```\nusing Microsoft.AspNetCore.Mvc;\n\t\n\n\tnamespace Supermarket.API.Controllers\n\t{\n\t    [Route(\"/api/[controller]\")]\n\t    public class CategoriesController : Controller\n\t    {\n\t    }\n\t}\n```\n让我们开始处理GET请求。首先，当有人/api/categories通过GET动词请求数据时，API需要返回所有类别。为此，我们可以创建**类别服务**。\n从概念上讲，服务基本上是定义用于处理某些业务逻辑的方法的类或接口。创建用于处理业务逻辑的服务是许多不同编程语言的一种常见做法，例如[身份验证和授权](https://medium.com/@evandro.ggomes/json-web-token-authentication-with-asp-net-core-2-0-b074b0cfc870)，付款，复杂的数据流，缓存和需要其他服务或模型之间进行某些交互的任务。\n\n使用服务，我们可以将请求和响应处理与完成任务所需的真实逻辑隔离开来。\n\n该服务，我们要创建将首先定义一个单独的行为**，**或**方法**：一个list方法。我们希望该方法返回数据库中所有现有的类别。\n\n为简单起见，在这篇博客中，我们将不处理数据分页或过滤，（译者注：基于RESTFul规范，提供了一套完整的分页和过滤的规则）。将来，我将写一篇文章，展示如何轻松处理这些功能。\n\n为了定义C＃（以及其他面向对象的语言，例如Java）中某事物的预期行为，我们定义一个**interface**。一个接口告诉某些事情应该如何工作，但是**没有实现行为的真实逻辑**。逻辑在实现接口的类中实现。如果您不清楚此概念，请不要担心。一段时间后您将了解它。\n\n在Domain文件夹中，创建一个名为的新目录Services。在此添加一个名为ICategoryService的接口。按照惯例，所有接口都应以C＃中的大写字母*“ I”*开头。定义接口代码，如下所示：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\t\n\n\tnamespace Supermarket.API.Domain.Services\n\t{\n\t    public interface ICategoryService\n\t    {\n\t         Task<IEnumerable<Category>> ListAsync();\n\t    }\n\t}\n```\n该ListAsync方法的实现必须**异步**返回类别的可枚举对象。\nTask封装返回的类表示异步。由于必须等待数据库完成操作才能返回数据，因此我们需要考虑执行此过程可能需要一段时间，因此我们需要使用异步方法。另请注意*“Async”*后缀。这是一个约定，告诉我们的方法应异步执行。\n\n我们有很多约定，对吗？我个人喜欢它，因为它使应用程序易于阅读，即使你在一家使用.NET技术的公司是新人。\n\n![图片](https://uploader.shimo.im/f/vQLzU6MpZkoChf0Y.png!thumbnail)\n\n*“-好的，我们定义了此接口，但是它什么也没做。有什么用？”*\n\n如果您来自Javascript或其他非强类型语言，则此概念可能看起来很奇怪。\n\n接口使我们能够从实际实现中抽象出所需的行为。使用称为[依赖注入](https://medium.freecodecamp.org/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f)的机制，我们可以实现这些接口并将它们与其他组件隔离。\n\n基本上，当您使用依赖项注入时，您可以使用接口定义一些行为。然后，创建一个实现该接口的类。最后，将引用从接口绑定到您创建的类。\n\n*”-听起来确实令人困惑。我们不能简单地创建一个为我们做这些事情的类吗？”*\n\n让我们继续实现我们的API，您将了解为什么使用这种方法。\n\n更改CategoriesController代码，如下所示：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Microsoft.AspNetCore.Mvc;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Services;\n\t\n\n\tnamespace Supermarket.API.Controllers\n\t{\n\t    [Route(\"/api/[controller]\")]\n\t    public class CategoriesController : Controller\n\t    {\n\t        private readonly ICategoryService _categoryService;\n\t        \n\t        public CategoriesController(ICategoryService categoryService)\n\t        {\n\t            _categoryService = categoryService;   \n\t        }\n\t\n\n\t        [HttpGet]\n\t        public async Task<IEnumerable<Category>> GetAllAsync()\n\t        {\n\t            var categories = await _categoryService.ListAsync();\n\t            return categories;\n\t        }\n\t    }\n\t}\n```\n我已经为控制器定义了一个构造函数（当创建一个类的新实例时会调用一个构造函数），并且它接收的实例ICategoryService。这意味着实例可以是任何实现服务接口的实例。我将此实例存储在一个私有的只读字段中_categoryService。我们将使用此字段访问类别服务实现的方法。\n顺便说一下，下划线前缀是表示字段的另一个通用约定。特别地，[.NET](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions)的[官方命名约定指南](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions)不建议使用此[约定](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions)，但是这是一种非常普遍的做法，可以避免使用*“ this”*关键字来区分类字段和局部变量。我个人认为阅读起来要干净得多，并且许多框架和库都使用此约定。\n\n在构造函数下，我定义了用于处理请求的方法/api/categories。该HttpGet** **属性告诉ASP.NET Core管道使用该属性来处理GET请求（可以省略此属性，但是最好编写它以便于阅读）。\n\n该方法使用我们的CategoryService实例列出所有类别，然后将类别返回给客户端。框架管道将数据序列化为JSON对象。IEnumerable类型告诉框架，我们想要返回一个类别的枚举，而Task类型(使用async关键字修饰)告诉管道，这个方法应该异步执行。最后，当我们定义一个异步方法时，我们必须使用await关键字来处理需要一些时间的任务。\n\n好的，我们定义了API的初始结构。现在，有必要真正实现类别服务。\n\n# **步骤4-实现类别服务**\n在API的根文件夹（即Supermarket.API文件夹）中，创建一个名为的新文件夹Services。在这里，我们将放置所有服务实现。在新文件夹中，添加一个名为CategoryService的新类。更改代码，如下所示：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Services;\n\t\n\n\tnamespace Supermarket.API.Services\n\t{\n\t    public class CategoryService : ICategoryService\n\t    {\n\t        public async Task<IEnumerable<Category>> ListAsync()\n\t        {\n\t        }\n\t    }\n\t}\n```\n以上只是接口实现的基本代码，我们暂时仍不处理任何逻辑。让我们考虑一下列表方法应该如何实现。\n我们需要访问数据库并返回所有类别，然后我们需要将此数据返回给客户端。\n\n服务类不是应该处理数据访问的类。我们将使用一种称为“仓储模式”的设计模式，定义仓储类，用于管理数据库中的数据。\n\n在使用仓储模式时，我们定义了repository 类，该类基本上封装了处理数据访问的所有逻辑。这些仓储类使方法可以列出，创建，编辑和删除给定模型的对象，与操作集合的方式相同。在内部，这些方法与数据库对话以执行CRUD操作，从而将数据库访问与应用程序的其余部分隔离开。\n\n我们的服务需要调用类别仓储，以获取列表对象。\n\n从概念上讲，服务可以与一个或多个仓储或其他服务“对话”以执行操作。\n\n创建用于处理数据访问逻辑的新定义似乎是多余的，但是您将在一段时间内看到将这种逻辑与服务类隔离是非常有利的。\n\n让我们创建一个仓储，该仓储负责与数据库通信，作为持久化保存类别的一种方式。\n\n# **步骤5-类别仓储和持久层**\n在该Domain文件夹内，创建一个名为的新目录Repositories。然后，添加一个名为的新接口ICategoryRespository。定义接口如下：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\tnamespace Supermarket.API.Domain.Repositories\n\t{\n\t    public interface ICategoryRepository\n\t    {\n\t         Task<IEnumerable<Category>> ListAsync();\n\t    }\n\t}\n```\n初始代码基本上与服务接口的代码相同。\n定义了接口之后，我们可以返回服务类并使用的实例ICategoryRepository返回数据来完成实现list方法。\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Repositories;\n\tusing Supermarket.API.Domain.Services;\n\t\n\n\tnamespace Supermarket.API.Services\n\t{\n\t    public class CategoryService : ICategoryService\n\t    {\n\t        private readonly ICategoryRepository _categoryRepository;\n\t\n\n\t        public CategoryService(ICategoryRepository categoryRepository)\n\t        {\n\t            this._categoryRepository = categoryRepository;\n\t        }\n\t\n\n\t        public async Task<IEnumerable<Category>> ListAsync()\n\t        { \n\t            return await _categoryRepository.ListAsync();\n\t        }\n\t    }\n\t}\n```\n现在，我们必须实现类别仓储的真实逻辑。在这样做之前，我们必须考虑如何访问数据库。\n*顺便说一句，我们仍然没有数据库！*\n\n我们将使用Entity Framework Core（为简单起见，我将其称为***EF Core***）作为我们的数据库ORM。该框架是ASP.NET Core的默认ORM，并公开了一个友好的API，该API使我们能够将应用程序的类映射到数据库表。\n\nEF Core还允许我们先设计应用程序，然后根据我们在代码中定义的内容生成数据库。此技术称为**Code First**。我们将使用Code First方法来生成数据库（实际上，在此示例中，我将使用内存数据库，但是您可以轻松地将其更改为像SQL Server或MySQL服务器这样的实例数据库）。\n\n在API的根文件夹中，创建一个名为的新目录Persistence。此目录将包含我们访问数据库所需的所有内容，例如仓储实现。\n\n在新文件夹中，创建一个名为的新目录Contexts，然后添加一个名为的新类AppDbContext。此类必须继承DbContext，EF Core通过DBContext用来将您的模型映射到数据库表的类。通过以下方式更改代码：\n\n```\nusing Microsoft.EntityFrameworkCore;\n\t\n\n\tnamespace Supermarket.API.Domain.Persistence.Contexts\n\t{\n\t    public class AppDbContext : DbContext\n\t    {\n\t        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options)\n\t        {\n\t        }\n\t    }\n\t}\n```\n我们添加到此类的构造函数负责通过依赖注入将数据库配置传递给基类。稍后您将看到其工作原理。\n现在，我们必须创建两个DbSet属性。这些属性是将模型映射到数据库表的集合（唯一对象的集合）。\n\n另外，我们必须将模型的属性映射到相应的列，指定哪些属性是主键，哪些是外键，列类型等。我们可以使用称为[Fluent API](http://www.entityframeworktutorial.net/efcore/fluent-api-in-entity-framework-core.aspx)的功能来覆盖OnModelCreating方法，以指定数据库映射。更改AppDbContext类，如下所示：\n\n该代码是如此直观。\n\n```\nusing Microsoft.EntityFrameworkCore;\n\tusing Supermarket.API.Domain.Models;\n\t\n\n\tnamespace Supermarket.API.Persistence.Contexts\n\t{\n\t    public class AppDbContext : DbContext\n\t    {\n\t        public DbSet<Category> Categories { get; set; }\n\t        public DbSet<Product> Products { get; set; }\n\t\n\n\t        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }\n\t\n\n\t        protected override void OnModelCreating(ModelBuilder builder)\n\t        {\n\t            base.OnModelCreating(builder);\n\t            \n\t            builder.Entity<Category>().ToTable(\"Categories\");\n\t            builder.Entity<Category>().HasKey(p => p.Id);\n\t            builder.Entity<Category>().Property(p => p.Id).IsRequired().ValueGeneratedOnAdd();\n\t            builder.Entity<Category>().Property(p => p.Name).IsRequired().HasMaxLength(30);\n\t            builder.Entity<Category>().HasMany(p => p.Products).WithOne(p => p.Category).HasForeignKey(p => p.CategoryId);\n\t\n\n\t            builder.Entity<Category>().HasData\n\t            (\n\t                new Category { Id = 100, Name = \"Fruits and Vegetables\" }, // Id set manually due to in-memory provider\n\t                new Category { Id = 101, Name = \"Dairy\" }\n\t            );\n\t\n\n\t            builder.Entity<Product>().ToTable(\"Products\");\n\t            builder.Entity<Product>().HasKey(p => p.Id);\n\t            builder.Entity<Product>().Property(p => p.Id).IsRequired().ValueGeneratedOnAdd();\n\t            builder.Entity<Product>().Property(p => p.Name).IsRequired().HasMaxLength(50);\n\t            builder.Entity<Product>().Property(p => p.QuantityInPackage).IsRequired();\n\t            builder.Entity<Product>().Property(p => p.UnitOfMeasurement).IsRequired();\n\t        }\n\t    }\n\t}\n```\n我们指定我们的模型应映射到哪些表。此外，我们设置了主键，使用该方法HasKey，该表的列，使用Property方法，和一些限制，例如IsRequired，HasMaxLength**，**和ValueGeneratedOnAdd，这些都是使用FluentApi的方式基于Lamada 表达式语法实现的（链式语法）。\n看一下下面的代码：\n\n```\nbuilder.Entity<Category>()\n       .HasMany(p => p.Products)\n       .WithOne(p => p.Category)\n       .HasForeignKey(p => p.CategoryId);\n```\n在这里，我们指定表之间的关系。我们说一个类别有很多产品，我们设置了将映射此关系的属性（Products，来自Category类，和Category，来自Product类）。我们还设置了外键（CategoryId）。\n如果您想学习如何使用EF Core配置一对一和多对多关系，以及如何完整的使用它，请看一下[本教程](https://www.learnentityframeworkcore.com/relationships)。\n\n还有一种用于通过HasData方法配置种子数据的方法：\n\n```\nbuilder.Entity<Category>().HasData\n(\n  new Category { Id = 100, Name = \"Fruits and Vegetables\" },\n  new Category { Id = 101, Name = \"Dairy\" }\n);\n```\n默认情况下，在这里我们仅添加两个示例类别。这对我们完成后进行API的测试来说是非常有必要的。\n>**注意：**我们在Id这里手动设置属性，因为内存提供程序的工作机制需要。我将标识符设置为大数字，以避免自动生成的标识符和种子数据之间发生冲突。\n>>真正的关系数据库提供程序中不存在此限制，因此，例如，如果要使用SQL Server等数据库，则不必指定这些标识符。如果您想了解此行为，请检查[此Github问题](https://github.com/aspnet/EntityFrameworkCore/issues/6872)。\n\n在实现数据库上下文类之后，我们可以实现类别仓储。添加一个名为新的文件夹Repositories里面Persistence的文件夹，然后添加一个名为新类BaseRepository。\n\n```\nusing Supermarket.API.Persistence.Contexts;\n\t\n\n\tnamespace Supermarket.API.Persistence.Repositories\n\t{\n\t    public abstract class BaseRepository\n\t    {\n\t        protected readonly AppDbContext _context;\n\t\n\n\t        public BaseRepository(AppDbContext context)\n\t        {\n\t            _context = context;\n\t        }\n\t    }\n\t}\n```\n此类只是我们所有仓储都将继承的**抽象类**。抽象类是没有直接实例的类。您必须创建直接类来创建实例。\n在BaseRepository接受我们的实例，AppDbContext通过依赖注入暴露了一个受保护的属性称为（只能是由子类访问一个属性）_context，即可以访问我们需要处理数据库操作的所有方法。\n\n在相同文件夹中添加一个新类CategoryRepository。现在，我们将真正实现仓储逻辑：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Microsoft.EntityFrameworkCore;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Repositories;\n\tusing Supermarket.API.Persistence.Contexts;\n\t\n\n\tnamespace Supermarket.API.Persistence.Repositories\n\t{\n\t    public class CategoryRepository : BaseRepository, ICategoryRepository\n\t    {\n\t        public CategoryRepository(AppDbContext context) : base(context)\n\t        {\n\t        }\n\t\n\n\t        public async Task<IEnumerable<Category>> ListAsync()\n\t        {\n\t            return await _context.Categories.ToListAsync();\n\t        }\n\t    }\n\t}\n```\n仓储继承BaseRepository和实现ICategoryRepository。\n注意实现list方法是很简单的。我们使用Categories数据库集访问类别表，然后调用扩展方法ToListAsync，该方法负责将查询结果转换为类别的集合。\n\nEF Core [将我们的方法调用转换为SQL查询](https://docs.microsoft.com/en-us/ef/core/querying/overview)，这是最有效的方法。这种方式仅当您调用将数据转换为集合的方法或使用方法获取特定数据时才执行查询。\n\n现在，我们有了类别控制器，服务和仓储库的代码实现。\n\n我们将关注点分离开来，创建了只执行应做的事情的类。\n\n测试应用程序之前的最后一步是使用ASP.NET Core依赖项注入机制将我们的接口绑定到相应的类。\n\n# **第6步-配置依赖注入**\n现在是时候让您最终了解此概念的工作原理了。\n\n![图片](https://uploader.shimo.im/f/GYbYOJqzMqsxEBg3.png!thumbnail)\n\n在应用程序的根文件夹中，打开Startup类。此类负责在应用程序启动时配置各种配置。\n\n该ConfigureServices和Configure方法通过框架管道在运行时调用来配置应用程序应该如何工作，必须使用哪些组件。\n\n打开ConfigureServices方法。在这里，我们只有一行配置应用程序以使用MVC管道，这基本上意味着该应用程序将使用控制器类来处理请求和响应（在这段代码背后发生了很多事情，但目前您仅需要知道这些）。\n\n我们可以使用ConfigureServices访问services参数的方法来配置我们的依赖项绑定。清理类代码，删除所有注释并按如下所示更改代码：\n\n```\nusing Microsoft.AspNetCore.Builder;\n\tusing Microsoft.AspNetCore.Hosting;\n\tusing Microsoft.AspNetCore.Mvc;\n\tusing Microsoft.EntityFrameworkCore;\n\tusing Microsoft.Extensions.Configuration;\n\tusing Microsoft.Extensions.DependencyInjection;\n\tusing Supermarket.API.Domain.Repositories;\n\tusing Supermarket.API.Domain.Services;\n\tusing Supermarket.API.Persistence.Contexts;\n\tusing Supermarket.API.Persistence.Repositories;\n\tusing Supermarket.API.Services;\n\t\n\n\tnamespace Supermarket.API\n\t{\n\t    public class Startup\n\t    {\n\t        public IConfiguration Configuration { get; }\n\t\n\n\t        public Startup(IConfiguration configuration)\n\t        {\n\t            Configuration = configuration;\n\t        }\n\t\n\n\t        public void ConfigureServices(IServiceCollection services)\n\t        {\n\t            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);\n\t\n\n\t            services.AddDbContext<AppDbContext>(options => {\n\t                options.UseInMemoryDatabase(\"supermarket-api-in-memory\");\n\t            });\n\t\n\n\t            services.AddScoped<ICategoryRepository, CategoryRepository>();\n\t            services.AddScoped<ICategoryService, CategoryService>();\n\t        }\n\t\n\n\t        public void Configure(IApplicationBuilder app, IHostingEnvironment env)\n\t        {\n\t            if (env.IsDevelopment())\n\t            {\n\t                app.UseDeveloperExceptionPage();\n\t            }\n\t            else\n\t            {\n\t                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.\n\t                app.UseHsts();\n\t            }\n\t\n\n\t            app.UseHttpsRedirection();\n\t            app.UseMvc();\n\t        }\n\t    }\n\t}\n```\n看一下这段代码：\n```\nservices.AddDbContext<AppDbContext>(options => {\n\n  options.UseInMemoryDatabase(\"supermarket-api-in-memory\");\n  \n});\n```\n在这里，我们配置数据库上下文。我们告诉ASP.NET Core将其AppDbContext与内存数据库实现一起使用，该实现由作为参数传递给我们方法的字符串标识。通常，在编写[集成测试](https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-2.2)时才会使用内存数据库，但是为了简单起见，我在这里使用了内存数据库。这样，我们无需连接到真实的数据库即可测试应用程序。\n这些代码行在内部配置我们的数据库上下文，以便使用确定作用域的生存周期进行依赖注入。\n\nscoped生存周期告诉ASP.NET Core管道，每当它需要解析接收AppDbContext作为构造函数参数的实例的类时，都应使用该类的相同实例。如果内存中没有实例，则管道将创建一个新实例，并在给定请求期间在需要它的所有类中重用它。这样，您无需在需要使用时手动创建类实例。\n\n如果你想了解其他有关生命周期的知识，可以阅读[官方文档](https://docs.microsoft.com/pt-br/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.2)。\n\n依赖注入技术为我们提供了许多优势，例如：\n\n* 代码可重用性；\n* 更高的生产力，因为当我们不得不更改实现时，我们无需费心去更改您使用该功能的一百个地方；\n* 您可以轻松地测试应用程序，因为我们可以使用mock（类的伪实现）隔离必须测试的内容，而我们必须将接口作为构造函数参数进行传递。\n* 当一个类需要通过构造函数接收更多的依赖关系时，您不必手动更改正在创建实例的所有位置（**太赞了！**）。\n\n配置数据库上下文之后，我们还将我们的服务和仓储绑定到相应的类。\n\n```\nservices.AddScoped<ICategoryRepository, CategoryRepository>();\n\nservices.AddScoped<ICategoryService, CategoryService>();\n```\n在这里，我们还使用了scoped生存周期，因为这些类在内部必须使用数据库上下文类。在这种情况下，指定相同的范围是有意义的。\n现在我们配置了依赖绑定，我们必须在Program类上进行一些小的更改，以便数据库正确地初始化种子数据。此步骤仅在使用内存数据库提供程序时才需要执行（请参阅[此Github问题](https://github.com/aspnet/EntityFrameworkCore/issues/11666)以了解原因）。\n\n```\nusing System;\n\tusing System.Collections.Generic;\n\tusing System.IO;\n\tusing System.Linq;\n\tusing System.Threading.Tasks;\n\tusing Microsoft.AspNetCore;\n\tusing Microsoft.AspNetCore.Hosting;\n\tusing Microsoft.Extensions.Configuration;\n\tusing Microsoft.Extensions.DependencyInjection;\n\tusing Microsoft.Extensions.Logging;\n\tusing Supermarket.API.Persistence.Contexts;\n\t\n\n\tnamespace Supermarket.API\n\t{\n\t    public class Program\n\t    {\n\t        public static void Main(string[] args)\n\t        {\n\t            var host = BuildWebHost(args);\n\t\n\n\t            using(var scope = host.Services.CreateScope())\n\t            using(var context = scope.ServiceProvider.GetService<AppDbContext>())\n\t            {\n\t                context.Database.EnsureCreated();\n\t            }\n\t\n\n\t            host.Run();\n\t        }\n\t\n\n\t        public static IWebHost BuildWebHost(string[] args) =>\n\t            WebHost.CreateDefaultBuilder(args)\n\t            .UseStartup<Startup>()\n\t            .Build();\n\t    }\n\t}\n```\n由于我们使用的是内存提供程序，因此有必要更改Main方法 添加“ context.Database.EnsureCreated();”代码以确保在应用程序启动时将“创建”数据库。没有此更改，将不会创建我们想要的初始化种子数据。\n实现了所有基本功能后，就该测试我们的API端点了。\n\n# **第7步-测试类别**\n在API根文件夹中打开终端或命令提示符，然后键入以下命令：\n\n```\ndotnet run\n```\n上面的命令启动应用程序。控制台将显示类似于以下内容的输出：\n```\ninfo: Microsoft.EntityFrameworkCore.Infrastructure[10403]\n\nEntity Framework Core 2.2.0-rtm-35687 initialized ‘AppDbContext’ using provider ‘Microsoft.EntityFrameworkCore.InMemory’ with options: StoreName=supermarket-api-in-memory\n\ninfo: Microsoft.EntityFrameworkCore.Update[30100]\n\nSaved 2 entities to in-memory store.\n\ninfo: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[0]\n\nUser profile is available. Using ‘C:\\Users\\evgomes\\AppData\\Local\\ASP.NET\\DataProtection-Keys’ as key repository and Windows DPAPI to encrypt keys at rest.\n\nHosting environment: Development\n\nContent root path: C:\\Users\\evgomes\\Desktop\\Tutorials\\src\\Supermarket.API\n\nNow listening on: https://localhost:5001\n\nNow listening on: http://localhost:5000\n\nApplication started. Press Ctrl+C to shut down.\n```\n您可以看到调用了EF Core来初始化数据库。最后几行显示应用程序在哪个端口上运行。\n打开浏览器，然后导航到 [http](http://localhost:5000/api/categories)[:](http://localhost:5000/api/categories)[//localhost](http://localhost:5000/api/categories)[:](http://localhost:5000/api/categories)[5000/api/categories](http://localhost:5000/api/categories) （或控制台输出上显示的URL）。如果您发现由于HTTPS导致的安全错误，则只需为应用程序添加一个例外。\n\n浏览器将显示以下JSON数据作为输出：\n\n```\n[\n  {\n     \"id\": 100,\n     \"name\": \"Fruits and Vegetables\",\n     \"products\": []\n  },\n  {\n     \"id\": 101,\n     \"name\": \"Dairy\",\n     \"products\": []\n  }\n]\n```\n在这里，我们看到配置数据库上下文时添加到数据库的数据。此输出确认我们的代码正在运行。\n您使用很少的代码行创建了GET API端点，并且由于当前API项目的架构模式，您的代码结构确实很容易更改。\n\n现在，该向您展示在由于业务需要而不得不对其进行更改时，更改此代码有多么容易。\n\n# **步骤8-创建类别资源**\n如果您还记得API端点的规范，您会注意到我们的实际JSON响应还有一个额外的属性：**products数组**。看一下所需响应的示例：\n\n```\n{\n  [\n    { \"id\": 1, \"name\": \"Fruits and Vegetables\" },\n    { \"id\": 2, \"name\": \"Breads\" },\n    … // Other categories\n  ]\n}\n```\n产品数组出现在我们当前的JSON响应中，因为我们的Category模型具有Products，EF Core需要的属性，以正确映射给定类别的产品。\n我们不希望在响应中使用此属性，但是不能更改模型类以排除此属性。当我们尝试管理类别数据时，这将导致EF Core引发错误，并且也将破坏我们的领域模型设计，因为没有产品的产品类别没有意义。\n\n要返回仅包含超级市场类别的标识符和名称的JSON数据，我们必须创建一个**资源类**。\n\n[资源类](https://restful-api-design.readthedocs.io/en/latest/resources.html)是一种包含将客户端应用程序和API端点之间进行交换的类型，通常以JSON数据的形式出现，以表示一些特定信息的类。\n\n来自API端点的所有响应都**必须**返回资源。\n\n将真实模型表示形式作为响应返回是一种不好的做法，因为它可能包含客户端应用程序不需要或没有其权限的信息（例如，用户模型可以返回用户密码的信息） ，这将是一个很大的安全问题）。\n\n我们需要一种资源来仅代表我们的类别，而没有产品。\n\n现在您知道什么是资源，让我们实现它。首先，在命令行中按**Ctrl + C**停止正在运行的应用程序。在应用程序的根文件夹中，创建一个名为Resources的新文件夹。在其中添加一个名为的新类CategoryResource。\n\n```\nnamespace Supermarket.API.Resources\n\t{\n\t    public class CategoryResource\n\t    {\n\t        public int Id { get; set; }\n\t        public string Name { get; set; }\n\t    }\n\t}\n```\n我们必须将类别服务提供的类别模型集合映射到类别资源集合。\n我们将使用一个名为[AutoMapper](https://automapper.org/)的库来处理对象之间的映射。AutoMapper是.NET世界中非常流行的库，并且在许多商业和开源项目中使用。\n\n在命令行中输入以下命令，以将AutoMapper添加到我们的应用程序中：\n\n```\ndotnet add package AutoMapper\n\ndotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection\n```\n要使用AutoMapper，我们必须做两件事：\n* 注册它以进行依赖注入；\n* 创建一个类，该类将告诉AutoMapper如何处理类映射。\n\n首先，打开Startup课程。在该ConfigureServices方法的最后一行之后，添加以下代码：\n\n```\nservices.AddAutoMapper();\n```\n此行处理AutoMapper的所有必需配置，例如注册它以进行依赖项注入以及在启动过程中扫描应用程序以配置映射配置文件。\n现在，在根目录中，添加一个名为的新文件夹Mapping，然后添加一个名为的类ModelToResourceProfile。通过以下方式更改代码：\n\n```\nusing AutoMapper;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Resources;\n\t\n\n\tnamespace Supermarket.API.Mapping\n\t{\n\t    public class ModelToResourceProfile : Profile\n\t    {\n\t        public ModelToResourceProfile()\n\t        {\n\t            CreateMap<Category, CategoryResource>();\n\t        }\n\t    }\n\t}\n```\n该类继承Profile了AutoMapper用于检查我们的映射如何工作的类类型。在构造函数上，我们在Category模型类和CategoryResource类之间创建一个映射。由于类的属性具有相同的名称和类型，因此我们不必为其使用任何特殊的配置。\n最后一步包括更改类别控制器以使用AutoMapper处理我们的对象映射。\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing AutoMapper;\n\tusing Microsoft.AspNetCore.Mvc;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Services;\n\tusing Supermarket.API.Resources;\n\t\n\n\tnamespace Supermarket.API.Controllers\n\t{\n\t    [Route(\"/api/[controller]\")]\n\t    public class CategoriesController : Controller\n\t    {\n\t        private readonly ICategoryService _categoryService;\n\t        private readonly IMapper _mapper;\n\t\n\n\t        public CategoriesController(ICategoryService categoryService, IMapper mapper)\n\t        {\n\t            _categoryService = categoryService;\n\t            _mapper = mapper;\n\t        }\n\t\n\n\t        [HttpGet]\n\t        public async Task<IEnumerable<CategoryResource>> GetAllAsync()\n\t        {\n\t            var categories = await _categoryService.ListAsync();\n\t            var resources = _mapper.Map<IEnumerable<Category>, IEnumerable<CategoryResource>>(categories);\n\t            \n\t            return resources;\n\t        }\n\t    }\n\t}\n```\n我更改了构造函数以接收IMapper实现的实例。您可以使用这些接口方法来使用AutoMapper映射方法。\n我还更改了GetAllAsync使用Map方法将类别枚举映射到资源枚举的方法。此方法接收我们要映射的类或集合的实例，并通过[通用类型定义](https://www.geeksforgeeks.org/c-generics-introduction/)定义必须映射到什么类型的类或集合。\n\n注意，我们只需将新的依赖项（IMapper）注入构造函数，就可以轻松地更改实现，而不必修改服务类或仓储。\n\n依赖注入使您的应用程序可维护且易于更改，因为您不必中断所有代码实现即可添加或删除功能。\n\n您可能意识到，不仅控制器类，而且所有接收依赖项的类（包括依赖项本身）都会根据绑定配置自动解析为接收正确的类。\n\n依赖注入如此的Amazing，不是吗？\n\n![图片](https://uploader.shimo.im/f/wGoOlHek0agFA3kQ.png!thumbnail)\n\n现在，使用dotnet run命令再次启动API，然后转到[http](http://localhost:5000/api/categories)[:](http://localhost:5000/api/categories)[//localhost](http://localhost:5000/api/categories)[:](http://localhost:5000/api/categories)[5000/api/categories](http://localhost:5000/api/categories)以查看新的JSON响应。\n\n![图片](https://uploader.shimo.im/f/xb8S1G8qcWQW3MSN.png!thumbnail)\n\n这是您应该看到的响应数据\n\n我们已经有了GET端点。现在，让我们为POST（**创建**）类别创建一个新端点。\n\n# **第9步-创建新类别**\n在处理资源创建时，我们必须关心很多事情，例如：\n\n* 数据验证和数据完整性；\n* 授权创建资源；\n* 错误处理；\n* 正在记录。\n\n在本教程中，我不会显示如何处理身份验证和授权，但是您可以阅读[JSON Web令牌身份验证](https://medium.com/@evandro.ggomes/json-web-token-authentication-with-asp-net-core-2-0-b074b0cfc870)教程，了解如何轻松实现这些功能。\n\n另外，有一个非常流行的框架称为**ASP.NET Identity**，该框架提供了有关安全性和用户注册的内置解决方案，您可以在应用程序中使用它们。它包括与EF Core配合使用的提供程序，例如IdentityDbContext可以使用的内置程序。您可以[在此处了解更多信息](https://docs.microsoft.com/en-us/aspnet/identity/overview/getting-started/introduction-to-aspnet-identity)。\n\n让我们编写一个HTTP POST端点，该端点将涵盖其他场景（日志记录除外，它可以根据不同的范围和工具进行更改）。\n\n在创建新端点之前，我们需要一个新资源。此资源会将客户端应用程序发送到此端点的数据（在本例中为类别名称）映射到我们应用程序的类。\n\n由于我们正在创建一个新类别，因此我们还没有ID，这意味着我们需要一种资源来表示仅包含其名称的类别。\n\n在Resources文件夹中，添加一个新类SaveCategoryResource：\n\n```\nusing System.ComponentModel.DataAnnotations;\n\t\n\n\tnamespace Supermarket.API.Resources\n\t{\n\t    public class SaveCategoryResource\n\t    {\n\t        [Required]\n\t        [MaxLength(30)]\n\t        public string Name { get; set; }\n\t    }\n\t}\n```\n注意Name属性上的Required和MaxLength特性。这些属性称为[数据注释](https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations?view=netframework-4.7.2)。ASP.NET Core管道使用此元数据来验证请求和响应。顾名思义，类别名称是必填项，最大长度为30个字符。\n现在，让我们定义新API端点的形状。将以下代码添加到类别控制器：\n\n```\n[HttpPost]\n\tpublic async Task<IActionResult> PostAsync([FromBody] SaveCategoryResource resource)\n\t{\n\t}\n```\n我们使用HttpPost特性告诉框架这是一个HTTP POST端点。\n注意此方法的响应类型Task<IActionResult>。控制器类中存在的方法称为**动作**，它们具有此签名，因为在应用程序执行动作之后，我们可以返回一个以上的可能结果。\n\n在这种情况下，如果类别名称无效或出现问题，我们必须返回**400代码（错误请求）**响应，该响应通常包含一条错误消息，客户端应用程序可以使用该错误消息来解决该问题，或者我们可以如果一切正常，则对数据进行**200次响应（成功）**。\n\n可以将多种类型的操作类型用作响应，但是通常，我们可以使用此接口，并且ASP.NET Core将为此使用默认类。\n\n该FromBody属性告诉ASP.NET Core将请求正文数据解析为我们的新资源类。这意味着当包含类别名称的JSON发送到我们的应用程序时，框架将自动将其解析为我们的新类。\n\n现在，让我们实现路由逻辑。我们必须遵循一些步骤才能成功创建新类别：\n\n* 首先，我们必须验证传入的请求。如果请求无效，我们必须返回包含错误消息的错误请求响应；\n* 然后，如果请求有效，则必须使用AutoMapper将新资源映射到类别模型类。\n* 现在，我们需要调用我们的服务，告诉它保存我们的新类别。如果执行保存逻辑没有问题，它将返回一个包含我们新类别数据的响应。如果没有，它应该给我们一个指示，表明该过程失败了，并可能出现错误消息。\n* 最后，如果有错误，我们将返回错误的请求。如果没有，我们将新的类别模型映射到类别资源，并向客户端返回包含新类别数据的成功响应。\n\n这似乎很复杂，但是使用为API构建的服务架构来实现此逻辑确实很容易。\n\n让我们开始验证传入的请求。\n\n# **步骤10-使用模型状态验证请求主体**\nASP.NET Core控制器具有名为ModelState的属性。在执行我们的操作**之前，**该属性在请求执行期间填充。它是ModelStateDictionary的实例，该类包含诸如请求是否有效以及潜在的验证错误消息之类的信息。\n\n如下更改端点代码：\n\n```\n[HttpPost]\n\tpublic async Task<IActionResult> PostAsync([FromBody] SaveCategoryResource resource)\n\t{\n\t\tif (!ModelState.IsValid)\n\t\t\treturn BadRequest(ModelState.GetErrorMessages());\n\t}\n```\n这段代码检查模型状态（在这种情况下为请求正文中发送的数据）是否无效，并检查我们的数据注释。如果不是，则API返回错误的请求（状态代码400），以及我们的注释元数据提供的默认错误消息。\n该ModelState.GetErrorMessages()方法尚未实现。这是一种[扩展方法](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)（一种扩展现有类或接口功能的方法），我将实现该方法将验证错误转换为简单的字符串以返回给客户端。\n\nExtensions在我们的API的根目录中添加一个新文件夹，然后添加一个新类ModelStateExtensions。\n\n```\nusing System.Collections.Generic;\n\tusing System.Linq;\n\tusing Microsoft.AspNetCore.Mvc.ModelBinding;\n\t\n\n\tnamespace Supermarket.API.Extensions\n\t{\n\t    public static class ModelStateExtensions\n\t    {\n\t        public static List<string> GetErrorMessages(this ModelStateDictionary dictionary)\n\t        {\n\t            return dictionary.SelectMany(m => m.Value.Errors)\n\t                             .Select(m => m.ErrorMessage)\n\t                             .ToList();\n\t        }\n\t    }\n\t}\n```\n所有扩展方法以及声明它们的类都应该是**静态的**。** **这意味着它们不处理特定的实例数据，并且在应用程序启动时仅被加载一次。\nthis参数声明前面的关键字告诉C＃编译器将其视为扩展方法。结果是我们可以像此类的常规方法一样调用它，因为我们在要使用扩展的地方包含的特定的using代码。\n\n该扩展使用[LINQ查询](https://www.tutorialsteacher.com/linq/what-is-linq)，这是.NET的非常有用的功能，它使我们能够使用链式语法来查询和转换数据。此处的表达式将验证错误方法转换为包含错误消息的字符串列表。\n\nSupermarket.API.Extensions在进行下一步之前，将名称空间导入Categories控制器。\n\n```\nusing Supermarket.API.Extensions;\n```\n让我们通过将新资源映射到类别模型类来继续实现端点逻辑。\n# **步骤11-映射新资源**\n我们已经定义了映射配置文件，可以将模型转换为资源。现在，我们需要一个与之相反的新配置项。\n\nResourceToModelProfile在Mapping文件夹中添加一个新类：\n\n```\nusing AutoMapper;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Resources;\n\t\n\n\tnamespace Supermarket.API.Mapping\n\t{\n\t    public class ResourceToModelProfile : Profile\n\t    {\n\t        public ResourceToModelProfile()\n\t        {\n\t            CreateMap<SaveCategoryResource, Category>();\n\t        }\n\t    }\n\t}\n```\n这里没有新内容。由于依赖注入的魔力，AutoMapper将在应用程序启动时自动注册此配置文件，而我们无需更改任何其他位置即可使用它。\n现在，我们可以将新资源映射到相应的模型类：\n\n```\n[HttpPost]\n\tpublic async Task<IActionResult> PostAsync([FromBody] SaveCategoryResource resource)\n\t{\n\t\tif (!ModelState.IsValid)\n\t\t\treturn BadRequest(ModelState.GetErrorMessages());\n\t\n\n\t\tvar category = _mapper.Map<SaveCategoryResource, Category>(resource);\n\t}\n```\n# **第12步-应用请求-响应模式来处理保存逻辑**\n现在我们必须实现最有趣的逻辑：保存一个新类别。我们希望我们的服务能够做到。\n\n由于连接到数据库时出现问题，或者由于任何内部业务规则使我们的数据无效，因此保存逻辑可能会失败。\n\n如果出现问题，我们不能简单地抛出一个错误，因为它可能会停止API，并且客户端应用程序也不知道如何处理该问题。另外，我们可能会有某种日志记录机制来记录错误。\n\n保存方法的约定（即方法的签名和响应类型）需要指示我们是否正确执行了该过程。如果处理正常，我们将接收类别数据。如果没有，我们至少必须收到一条错误消息，告诉您该过程失败的原因。\n\n我们可以通过应用**request-response模式**来实现此功能。这种企业设计模式将我们的请求和响应参数封装到类中，以封装我们的服务将用于处理某些任务并将信息返回给正在使用该服务的类的信息。\n\n这种模式为我们提供了一些优势，例如：\n\n* 如果我们需要更改服务以接收更多参数，则不必破坏其签名；\n* 我们可以为我们的请求和/或响应定义标准合同；\n* 我们可以在不停止应用程序流程的情况下处理业务逻辑和潜在的失败，并且我们不需要使用大量的try-catch块。\n\n让我们为处理数据更改的服务方法创建一个标准响应类型。对于这种类型的每个请求，我们都想知道该请求是否被正确执行。如果失败，我们要向客户端返回错误消息。\n\n在Domain文件夹的内部Services，添加一个名为的新目录Communication。在此处添加一个名为的新类BaseResponse。\n\n```\nnamespace Supermarket.API.Domain.Services.Communication\n\t{\n\t    public abstract class BaseResponse\n\t    {\n\t        public bool Success { get; protected set; }\n\t        public string Message { get; protected set; }\n\t\n\n\t        public BaseResponse(bool success, string message)\n\t        {\n\t            Success = success;\n\t            Message = message;\n\t        }\n\t    }\n\t}\n```\n那是我们的响应类型将继承的抽象类。\n抽象定义了一个Success属性和一个Message属性，该属性将告知请求是否已成功完成，如果失败，该属性将显示错误消息。\n\n请注意，这些属性是必需的，只有继承的类才能设置此数据，因为子类必须通过构造函数传递此信息。\n\n>**提示：**为所有内容定义基类不是一个好习惯，因为[基类会耦合您的代码](https://en.wikipedia.org/wiki/Fragile_base_class)并阻止您轻松对其进行修改。优先使用[组合而不是继承](https://medium.com/humans-create-software/composition-over-inheritance-cb6f88070205)。\n>>在此API的范围内，使用基类并不是真正的问题，因为我们的服务不会增长太多。如果您意识到服务或应用程序会经常增长和更改，请避免使用基类。\n\n现在，在同一文件夹中，添加一个名为的新类SaveCategoryResponse。\n\n```\nusing Supermarket.API.Domain.Models;\n\t\n\n\tnamespace Supermarket.API.Domain.Services.Communication\n\t{\n\t    public class SaveCategoryResponse : BaseResponse\n\t    {\n\t        public Category Category { get; private set; }\n\t\n\n\t        private SaveCategoryResponse(bool success, string message, Category category) : base(success, message)\n\t        {\n\t            Category = category;\n\t        }\n\t\n\n\t        /// <summary>\n\t        /// Creates a success response.\n\t        /// </summary>\n\t        /// <param name=\"category\">Saved category.</param>\n\t        /// <returns>Response.</returns>\n\t        public SaveCategoryResponse(Category category) : this(true, string.Empty, category)\n\t        { }\n\t\n\n\t        /// <summary>\n\t        /// Creates am error response.\n\t        /// </summary>\n\t        /// <param name=\"message\">Error message.</param>\n\t        /// <returns>Response.</returns>\n\t        public SaveCategoryResponse(string message) : this(false, message, null)\n\t        { }\n\t    }\n\t}\n```\n响应类型还设置了一个Category属性，如果请求成功完成，该属性将包含我们的类别数据。\n请注意，我为此类定义了三种不同的构造函数：\n\n* 一个私有的，它将把成功和消息参数传递给基类，并设置Category属性。\n* 仅接收类别作为参数的构造函数。这将创建一个成功的响应，调用私有构造函数来设置各自的属性；\n* 第三个构造函数仅指定消息。这将用于创建故障响应。\n\n因为C＃支持多个构造函数，所以我们仅通过使用不同的构造函数就简化了响应的创建过程，而无需定义其他方法来处理此问题。\n\n现在，我们可以更改服务界面以添加新的保存方法合同。\n\n更改ICategoryService接口，如下所示：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Services.Communication;\n\t\n\n\tnamespace Supermarket.API.Domain.Services\n\t{\n\t    public interface ICategoryService\n\t    {\n\t         Task<IEnumerable<Category>> ListAsync();\n\t         Task<SaveCategoryResponse> SaveAsync(Category category);\n\t    }\n\t}\n```\n我们只需将类别传递给此方法，它将处理保存模型数据，编排仓储和其他必要服务所需的所有逻辑。\n请注意，由于我们不需要任何其他参数来执行此任务，因此我不在此处创建特定的请求类。[计算机编程中](https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle)有一个名为[KISS](https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle)的[概念](https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle) —Keep It Simple，Stupid的简称。基本上，它说您应该使您的应用程序尽可能简单。\n\n设计应用程序时请记住这一点：**仅**应用**解决问题所需的内容**。**不要过度设计您的应用程序。**\n\n现在我们可以完成端点逻辑：\n\n```\n[HttpPost]\n\tpublic async Task<IActionResult> PostAsync([FromBody] SaveCategoryResource resource)\n\t{\n\t\tif (!ModelState.IsValid)\n\t\t\treturn BadRequest(ModelState.GetErrorMessages());\n\t\n\n\t\tvar category = _mapper.Map<SaveCategoryResource, Category>(resource);\n\t\tvar result = await _categoryService.SaveAsync(category);\n\t\n\n\t\tif (!result.Success)\n\t\t\treturn BadRequest(result.Message);\n\t\n\n\t\tvar categoryResource = _mapper.Map<Category, CategoryResource>(result.Category);\n\t\treturn Ok(categoryResource);\n\t}\n```\n在验证请求数据并将资源映射到我们的模型之后，我们将其传递给我们的服务以保留数据。\n如果失败，则API返回错误的请求。如果没有，API会将新类别（现在包括诸如new的数据Id）映射到我们先前创建的类别CategoryResource，并将其发送给客户端。\n\n现在，让我们为服务实现真正的逻辑。\n\n**第13步—数据库逻辑和工作单元模式**\n\n由于我们要将数据持久化到数据库中，因此我们需要在仓储中使用一种新方法。\n\n向ICategoryRepository接口添加AddAsync新方法：\n\n```\npublic interface ICategoryRepository\n\t{\n\t\t Task<IEnumerable<Category>> ListAsync();\n\t\t Task AddAsync(Category category);\n\t}\n```\n现在，让我们在真正的仓储类中实现此方法：\n```\npublic class CategoryRepository : BaseRepository, ICategoryRepository\n\t{\n\t\tpublic CategoryRepository(AppDbContext context) : base(context)\n\t\t{ }\n\t\n\n\t\tpublic async Task<IEnumerable<Category>> ListAsync()\n\t\t{\n\t\t\treturn await _context.Categories.ToListAsync();\n\t\t}\n\t\n\n\t\tpublic async Task AddAsync(Category category)\n\t\t{\n\t\t\tawait _context.Categories.AddAsync(category);\n\t\t}\n\t}\n```\n在这里，我们只是在集合中添加一个新类别。\n当我们向中添加类时DBSet<>，EF Core将开始跟踪模型发生的所有更改，并在当前状态下使用此数据生成将插入，更新或删除模型的查询。\n\n当前的实现只是将模型添加到我们的集合中，但是**我们的数据仍然不会保存**。\n\n在上下文类中提供了SaveChanges的方法，我们必须调用该方法才能真正将查询执行到数据库中。我之所以没有在这里调用它，是因为[仓储不应该持久化数据](https://programmingwithmosh.com/entity-framework/common-mistakes-with-the-repository-pattern/)，它只是一种内存集合对象。\n\n即使在经验丰富的.NET开发人员之间，该主题也引起很大争议，但是让我向您解释为什么您不应该在仓储类中调用SaveChanges方法。\n\n我们可以从概念上将仓储像.NET框架中存在的任何其他集合一样。在.NET（和许多其他编程语言，例如Javascript和Java）中处理集合时，通常可以：\n\n* 向其中添加新项（例如，当您将数据推送到列表，数组和字典时）；\n* 查找或过滤项目；\n* 从集合中删除一个项目；\n* 替换给定的项目，或更新它。\n\n想一想现实世界中的清单。想象一下，您正在编写一份购物清单以在超市购买东西（*巧合，不是吗？*）。\n\n在列表中，写下您需要购买的所有水果。您可以将水果添加到此列表中，如果放弃购买就删除水果，也可以替换水果的名称。但是您无法**将**水果**保存**到列表中。用简单的英语说这样的话是没有意义的。\n\n>**提示：**在使用面向对象的编程语言设计类和接口时，请尝试使用自然语言来检查您所做的工作是否正确。\n>>例如，说人实现了person的接口是有道理的，但是说一个人实现了一个帐户却没有道理。\n\n如果您要“保存”水果清单（在这种情况下，要购买所有水果），请付款，然后超市会处理库存数据以检查他们是否必须从供应商处购买更多水果。\n\n编程时可以应用相同的逻辑。仓储不应保存，更新或删除数据。相反，他们应该将其委托给其他类来处理此逻辑。\n\n将数据直接保存到仓储中时，还有另一个问题：**您不能使用transaction**。\n\n想象一下，我们的应用程序具有一种日志记录机制，该机制存储一些用户名，并且每次对API数据进行更改时都会执行操作。\n\n现在想象一下，由于某种原因，您调用了一个更新用户名的服务（这是不常见的情况，但让我们考虑一下）。\n\n您同意要更改虚拟用户表中的用户名，首先必须更新所有日志以正确告诉谁执行了该操作，对吗？\n\n现在想象我们已经为用户和不同仓储中的日志实现了update方法，它们都调用了SaveChanges。如果这些方法之一在更新过程中失败，会发生什么？最终会导致数据不一致。\n\n只有在一切完成之后，我们才应该将更改保存到数据库中。为此，我们必须使用[transaction](https://en.wikipedia.org/wiki/Database_transaction)，这基本上是大多数数据库实现的功能，只有在完成复杂的操作后才能保存数据。\n\n*“-好的，所以如果我们不能在这里保存东西，我们应该在哪里做？”*\n\n处理此问题的常见模式是[工作单元模式](https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)。此模式包含一个类，该类将我们的AppDbContext实例作为依赖项接收，并公开用于开始，完成或中止事务的方法。\n\n在这里，我们将使用工作单元的简单实现来解决我们的问题。\n\nRepositories在Domain层的仓储文件夹Repositories内添加一个新接口IUnitOfWork：\n\n```\nusing System.Threading.Tasks;\n\t\n\n\tnamespace Supermarket.API.Domain.Repositories\n\t{\n\t    public interface IUnitOfWork\n\t    {\n\t         Task CompleteAsync();\n\t    }\n\t}\n```\n如您所见，它仅公开一种将异步完成数据管理操作的方法。\n现在让我们添加实际的实现。\n\n在Persistence层RepositoriesRepositories文件夹中的添加一个名为的UnitOfWork的新类：\n\n```\nusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Repositories;\n\tusing Supermarket.API.Persistence.Contexts;\n\t\n\n\tnamespace Supermarket.API.Persistence.Repositories\n\t{\n\t    public class UnitOfWork : IUnitOfWork\n\t    {\n\t        private readonly AppDbContext _context;\n\t\n\n\t        public UnitOfWork(AppDbContext context)\n\t        {\n\t            _context = context;     \n\t        }\n\t\n\n\t        public async Task CompleteAsync()\n\t        {\n\t            await _context.SaveChangesAsync();\n\t        }\n\t    }\n\t}\n```\n这是一个简单，干净的实现，仅在使用仓储修改完所有更改后，才将所有更改保存到数据库中。\n如果研究工作单元模式的实现，则会发现实现回滚操作的更复杂的模式。\n\n由于**EF Core已经在后台实现了仓储模式和工作单元**，因此我们不必在意回滚方法。\n\n*“ - 什么？那么为什么我们必须创建所有这些接口和类？”*\n\n将持久性逻辑与业务规则分开在代码可重用性和维护方面具有许多优势。如果直接使用EF Core，我们最终将拥有更复杂的类，这些类将很难更改。\n\n想象一下，将来您决定将ORM框架更改为其他框架，例如[Dapper](https://www.c-sharpcorner.com/article/crud-operation-in-asp-net-core-2-0-using-dapper-orm/)，或者由于性能而必须实施纯SQL查询。如果将查询逻辑与服务耦合在一起，将很难更改该逻辑，因为您必须在许多类中进行此操作。\n\n使用仓储模式，您可以简单地实现一个新的仓储类并使用依赖注入将其绑定。\n\n因此，基本上，如果您直接在服务中使用EF Core，并且必须进行一些更改，那么您将获得：\n\n就像我说的那样，EF Core在后台实现了工作单元和仓储模式。我们可以将DbSet<>属性视为仓储。而且，SaveChanges仅在所有数据库操作成功的情况下才保留数据。\n\n现在，您知道什么是工作单元以及为什么将其与仓储一起使用，让我们实现真实服务的逻辑。\n\n```\npublic class CategoryService : ICategoryService\n\t{\n\t\tprivate readonly ICategoryRepository _categoryRepository;\n\t\tprivate readonly IUnitOfWork _unitOfWork;\n\t\n\n\t\tpublic CategoryService(ICategoryRepository categoryRepository, IUnitOfWork unitOfWork)\n\t\t{\n\t\t\t_categoryRepository = categoryRepository;\n\t\t\t_unitOfWork = unitOfWork;\n\t\t}\n\t\n\n\t\tpublic async Task<IEnumerable<Category>> ListAsync()\n\t\t{\n\t\t\treturn await _categoryRepository.ListAsync();\n\t\t}\n\t\n\n\t\tpublic async Task<SaveCategoryResponse> SaveAsync(Category category)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tawait _categoryRepository.AddAsync(category);\n\t\t\t\tawait _unitOfWork.CompleteAsync();\n\t\t\t\t\n\t\t\t\treturn new SaveCategoryResponse(category);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t// Do some logging stuff\n\t\t\t\treturn new SaveCategoryResponse($\"An error occurred when saving the category: {ex.Message}\");\n\t\t\t}\n\t\t}\n\t}\n```\n多亏了我们的解耦架构，我们可以简单地将实例UnitOfWork作为此类的依赖传递。\n我们的业务逻辑非常简单。\n\n首先，我们尝试将新类别添加到数据库中，然后API尝试保存新类别，将所有内容包装在try-catch块中。\n\n如果失败，则API会调用一些虚构的日志记录服务，并返回指示失败的响应。\n\n如果该过程顺利完成，则应用程序将返回成功响应，并发送我们的类别数据。简单吧？\n\n>**提示：**在现实世界的应用程序中，您不应将所有内容包装在通用的try-catch块中，而应分别处理所有可能的错误。\n>>简单地添加一个try-catch块并不能解决大多数可能的失败情况。请确保正确实现错误处理。\n\n测试我们的API之前的最后一步是将工作单元接口绑定到其各自的类。\n\n将此新行添加到类的ConfigureServices方法中Startup：\n\n```\nservices.AddScoped<IUnitOfWork, UnitOfWork>();\n```\n现在让我们测试一下！\n**第14步-使用Postman测试我们的POST端点**\n\n重新启动我们的应用程序dotnet run。\n\n我们无法使用浏览器测试POST端点。让我们使用**Postman**测试我们的端点。这是测试RESTful API的非常有用的工具。\n\n打开**Postman**，然后关闭介绍性消息。您会看到这样的屏幕：\n\n![图片](https://uploader.shimo.im/f/k9uqO0tzHP8sXyGu.png!thumbnail)\n\n屏幕显示测试端点的选项\n\nGET默认情况下，将所选内容更改为选择框POST。\n\n在Enter request URL字段中输入API地址。\n\n我们必须提供请求正文数据以发送到我们的API。单击Body菜单项，然后将其下方显示的选项更改为raw。\n\nPostman将在右侧显示一个Text选项，将其更改为JSON (application/json)并粘贴以下JSON数据：\n\n```\n{\n  \"name\": \"\"\n}\n```\n![图片](https://uploader.shimo.im/f/aMktVnVAavwvF3Q3.png!thumbnail)发送请求前的屏幕\n\n如您所见，我们将向我们的新端点发送一个空的名称字符串。\n\n点击Send按钮。您将收到如下输出：\n\n![图片](https://uploader.shimo.im/f/5yuSjCfYKD0ELqiA.png!thumbnail)\n\n如您所见，我们的验证逻辑有效！\n\n您还记得我们为端点创建的验证逻辑吗？此输出是它起作用的证明！\n\n还要注意右侧显示的400状态代码。该BadRequest结果自动将此状态码的响应。\n\n现在，让我们将JSON数据更改为有效数据，以查看新的响应：\n\n![图片](https://uploader.shimo.im/f/zDpJNG3Yl8Q0XimL.png!thumbnail)\n\n最后，我们期望得到的结果\n\nAPI正确创建了我们的新资源。\n\n到目前为止，我们的API可以列出和创建类别。您学到了很多有关C＃语言，ASP.NET Core框架以及构造API的通用设计方法的知识。\n\n让我们继续我们的类别API，创建用于更新类别的端点。\n\n从现在开始，由于我向您解释了大多数概念，因此我将加快解释速度，并专注于新主题，以免浪费您的时间。 Let’s go!\n\n# **第15步-更新类别**\n要更新类别，我们需要一个HTTP PUT端点。\n\n我们必须编写的逻辑与POST逻辑非常相似：\n\n* 首先，我们必须使用来验证传入的请求ModelState。\n* 如果请求有效，则API应使用AutoMapper将传入资源映射到模型类。\n* 然后，我们需要调用我们的服务，告诉它更新类别，提供相应的类别Id和更新的数据；\n* 如果Id数据库中没有给定的类别，我们将返回错误的请求。我们可以使用NotFound结果来代替，但是对于这个范围而言，这并不重要，因为我们向客户端应用程序提供了错误消息。\n* 如果正确执行了保存逻辑，则服务必须返回包含更新的类别数据的响应。如果不是，它应该给我们指示该过程失败，并显示一条消息指示原因；\n* 最后，如果有错误，则API返回错误的请求。如果不是，它将更新的类别模型映射到类别资源，并将成功响应返回给客户端应用程序。\n\n让我们将新PutAsync方法添加到控制器类中：\n\n```\n[HttpPut(\"{id}\")]\n\tpublic async Task<IActionResult> PutAsync(int id, [FromBody] SaveCategoryResource resource)\n\t{\n\t\tif (!ModelState.IsValid)\n\t\t\treturn BadRequest(ModelState.GetErrorMessages());\n\t\n\n\t\tvar category = _mapper.Map<SaveCategoryResource, Category>(resource);\n\t\tvar result = await _categoryService.UpdateAsync(id, category);\n\t\n\n\t\tif (!result.Success)\n\t\t\treturn BadRequest(result.Message);\n\t\n\n\t\tvar categoryResource = _mapper.Map<Category, CategoryResource>(result.Category);\n\t\treturn Ok(categoryResource);\n\t}\n```\n如果将其与POST逻辑进行比较，您会注意到这里只有一个区别：HttPut属性指定给定路由应接收的参数。\n我们将调用此端点，将类别指定Id 为最后一个URL片段，例如/api/categories/1。ASP.NET Core管道将此片段解析为相同名称的参数。\n\n现在我们必须UpdateAsync在ICategoryService接口中定义方法签名：\n\n```\npublic interface ICategoryService\n\t{\n\t\tTask<IEnumerable<Category>> ListAsync();\n\t\tTask<SaveCategoryResponse> SaveAsync(Category category);\n\t\tTask<SaveCategoryResponse> UpdateAsync(int id, Category category);\n\t}\n```\n现在让我们转向真正的逻辑。\n# **第16步-更新逻辑**\n首先，要更新类别，我们需要从数据库中返回当前数据（如果存在）。我们还需要将其更新到我们的中DBSet<>。\n\n让我们在ICategoryService界面中添加两个新的方法约定：\n\n```\npublic interface ICategoryRepository\n\t{\n\t\tTask<IEnumerable<Category>> ListAsync();\n\t\tTask AddAsync(Category category);\n\t\tTask<Category> FindByIdAsync(int id);\n\t\tvoid Update(Category category);\n\t}\n```\n我们已经定义了FindByIdAsync方法，该方法将从数据库中异步返回一个类别，以及该Update方法。请注意，该Update方法不是异步的，因为EF Core API不需要异步方法来更新模型。\n现在，让我们在CategoryRepository类中实现真正的逻辑：\n\n```\npublic async Task<Category> FindByIdAsync(int id)\n\t{\n\t\treturn await _context.Categories.FindAsync(id);\n\t}\n\t\n\n\tpublic void Update(Category category)\n\t{\n\t\t_context.Categories.Update(category);\n\t}\n```\n最后，我们可以对服务逻辑进行编码：\n```\npublic async Task<SaveCategoryResponse> UpdateAsync(int id, Category category)\n\t{\n\t\tvar existingCategory = await _categoryRepository.FindByIdAsync(id);\n\t\n\n\t\tif (existingCategory == null)\n\t\t\treturn new SaveCategoryResponse(\"Category not found.\");\n\t\n\n\t\texistingCategory.Name = category.Name;\n\t\n\n\t\ttry\n\t\t{\n\t\t\t_categoryRepository.Update(existingCategory);\n\t\t\tawait _unitOfWork.CompleteAsync();\n\t\n\n\t\t\treturn new SaveCategoryResponse(existingCategory);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\t// Do some logging stuff\n\t\t\treturn new SaveCategoryResponse($\"An error occurred when updating the category: {ex.Message}\");\n\t\t}\n\t}\n```\nAPI尝试从数据库中获取类别。如果结果为null，我们将返回一个响应，告知该类别不存在。如果类别存在，我们需要设置其新名称。\n然后，API会尝试保存更改，例如创建新类别时。如果该过程完成，则该服务将返回成功响应。如果不是，则执行日志记录逻辑，并且端点接收包含错误消息的响应。\n\n现在让我们对其进行测试。首先，让我们添加一个新类别Id以使用有效类别。我们可以使用播种到数据库中的类别的标识符，但是我想通过这种方式向您展示我们的API将更新正确的资源。\n\n再次运行该应用程序，然后使用Postman将新类别发布到数据库中：\n\n![图片](https://uploader.shimo.im/f/fxIzjvpz7Y0kf8XP.png!thumbnail)\n\n添加新类别以供日后更新\n\n使用一个可用的数据Id，将POST 选项更改PUT为选择框，然后在URL的末尾添加ID值。将name属性更改为其他名称，然后发送请求以检查结果：\n\n![图片](https://uploader.shimo.im/f/VMXmxLVsZNsqqXSK.png!thumbnail)\n\n类别数据已成功更新\n\n您可以将GET请求发送到API端点，以确保您正确编辑了类别名称：\n\n![图片](https://uploader.shimo.im/f/G5ipYxpQk5gJSVBI.png!thumbnail)\n\n那是现在GET请求的结果\n\n我们必须对类别执行的最后一项操作是排除类别。让我们创建一个HTTP Delete端点。\n\n# **第17步-删除类别**\n删除类别的逻辑确实很容易实现，因为我们所需的大多数方法都是先前构建的。\n\n这些是我们工作路线的必要步骤：\n\n* API需要调用我们的服务，告诉它删除我们的类别，并提供相应的Id;\n* 如果数据库中没有具有给定ID的类别，则该服务应返回一条消息指出该类别；\n* 如果执行删除逻辑没有问题，则服务应返回包含我们已删除类别数据的响应。如果没有，它应该给我们一个指示，表明该过程失败了，并可能出现错误消息。\n* 最后，如果有错误，则API返回错误的请求。如果不是，则API会将更新的类别映射到资源，并向客户端返回成功响应。\n\n让我们开始添加新的端点逻辑：\n\n```\n[HttpDelete(\"{id}\")]\n\tpublic async Task<IActionResult> DeleteAsync(int id)\n\t{\n\t\tvar result = await _categoryService.DeleteAsync(id);\n\t\n\n\t\tif (!result.Success)\n\t\t\treturn BadRequest(result.Message);\n\t\n\n\t\tvar categoryResource = _mapper.Map<Category, CategoryResource>(result.Category);\n\t\treturn Ok(categoryResource);\n\t}\n```\n该HttpDelete属性还定义了一个id 模板。\n在将DeleteAsync签名添加到我们的ICategoryService接口之前，我们需要做一些小的重构。\n\n新的服务方法必须返回包含类别数据的响应，就像对PostAsyncand UpdateAsync方法所做的一样。我们可以SaveCategoryResponse为此目的重用，但在这种情况下我们不会保存数据。\n\n为了避免创建具有相同形状的新类来满足此要求，我们可以将我们重命名SaveCategoryResponse为CategoryResponse。\n\n如果您使用的是Visual Studio Code，则可以打开SaveCategoryResponse类，将鼠标光标放在类名上方，然后使用选项Change All Occurrences*** ***来重命名该类：\n\n![图片](https://uploader.shimo.im/f/9F3zYANcrMUdFlMe.png!thumbnail)\n\n确保也重命名文件名。\n\n让我们将DeleteAsync方法签名添加到ICategoryService 接口中：\n\n```\npublic interface ICategoryService\n\t{\n\t\tTask<IEnumerable<Category>> ListAsync();\n\t\tTask<CategoryResponse> SaveAsync(Category category);\n\t\tTask<CategoryResponse> UpdateAsync(int id, Category category);\n\t\tTask<CategoryResponse> DeleteAsync(int id);\n\t}\n```\n在实施删除逻辑之前，我们需要在仓储中使用一种新方法。\n将Remove方法签名添加到ICategoryRepository接口：\n\n```\nvoid Remove(Category category);\n```\n现在，在仓储类上添加真正的实现：\n\n```\npublic void Remove(Category category)\n\t{\n\t\t_context.Categories.Remove(category);\n\t}\n```\nEF Core要求将模型的实例传递给Remove方法，以正确了解我们要删除的模型，而不是简单地传递Id。\n最后，让我们在CategoryService类上实现逻辑：\n\n```\npublic async Task<CategoryResponse> DeleteAsync(int id)\n\t{\n\t\tvar existingCategory = await _categoryRepository.FindByIdAsync(id);\n\t\n\n\t\tif (existingCategory == null)\n\t\t\treturn new CategoryResponse(\"Category not found.\");\n\t\n\n\t\ttry\n\t\t{\n\t\t\t_categoryRepository.Remove(existingCategory);\n\t\t\tawait _unitOfWork.CompleteAsync();\n\t\n\n\t\t\treturn new CategoryResponse(existingCategory);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\t// Do some logging stuff\n\t\t\treturn new CategoryResponse($\"An error occurred when deleting the category: {ex.Message}\");\n\t\t}\n\t}\n```\n这里没有新内容。该服务尝试通过ID查找类别，然后调用我们的仓储以删除类别。最后，工作单元完成将实际操作执行到数据库中的事务。\n*“-嘿，但是每个类别的产品呢？为避免出现错误，您是否不需要先创建仓储并删除产品？”*\n\n答案是**否定的**。借助[EF Core跟踪机制](https://docs.microsoft.com/en-us/ef/core/querying/tracking)，当我们从数据库中加载模型时，框架便知道了该模型具有哪些关系。如果我们删除它，EF Core知道它应该首先递归删除所有相关模型。\n\n在将类映射到数据库表时，我们可以禁用此功能，但这在本教程的范围之外。如果您想了解此功能，[请看这里](https://entityframeworkcore.com/saving-data-cascade-delete)。\n\n现在是时候测试我们的新端点了。再次运行该应用程序，并使用Postman发送DELETE请求，如下所示：\n\n![图片](https://uploader.shimo.im/f/VRCjsPelqx4qADIx.png!thumbnail)\n\n如您所见，API毫无问题地删除了现有类别\n\n我们可以通过发送GET请求来检查我们的API是否正常工作：\n\n![图片](https://uploader.shimo.im/f/iyiKvuB7e0IfSTQf.png!thumbnail)我们已经完成了类别API。现在是时候转向产品API。\n\n# **步骤18-产品API**\n到目前为止，您已经学习了如何实现所有基本的HTTP动词来使用ASP.NET Core处理CRUD操作。让我们进入实现产品API的下一个层次。\n\n我将不再详细介绍所有HTTP动词，因为这将是详尽无遗的。在本教程的最后一部分，我将仅介绍GET请求，以向您展示在从数据库查询数据时如何包括相关实体，以及如何使用Description我们为EUnitOfMeasurement 枚举值定义的属性。\n\n将新控制器ProductsController添加到名为Controllers的文件夹中。\n\n在这里编写任何代码之前，我们必须创建产品资源。\n\n让我刷新您的记忆，再次显示我们的资源应如何：\n\n```\n{\n [\n  {\n   \"id\": 1,\n   \"name\": \"Sugar\",\n   \"quantityInPackage\": 1,\n   \"unitOfMeasurement\": \"KG\"\n   \"category\": {\n   \"id\": 3,\n   \"name\": \"Sugar\"\n   }\n  },\n  … // Other products\n ]\n}\n```\n我们想要一个包含数据库中所有产品的JSON数组。\nJSON数据与产品模型有两点不同：\n\n* 测量单位以较短的方式显示，仅显示其缩写。\n* 我们输出类别数据**而不**包括CategoryId属性。\n\n为了表示度量单位，我们可以使用简单的字符串属性代替枚举类型（顺便说一下，我们没有JSON数据的默认枚举类型，因此我们必须将其转换为其他类型）。\n\n现在，我们现在要塑造新资源，让我们创建它。ProductResource在Resources文件夹中添加一个新类：\n\n```\nnamespace Supermarket.API.Resources\n\t{\n\t    public class ProductResource\n\t    {\n\t        public int Id { get; set; }\n\t        public string Name { get; set; }\n\t        public int QuantityInPackage { get; set; }\n\t        public string UnitOfMeasurement { get; set; }\n\t        public CategoryResource Category {get;set;}\n\t    }\n\t}\n```\n现在，我们必须配置模型类和新资源类之间的映射。\n映射配置将与用于其他映射的配置几乎相同，但是在这里，我们必须处理将EUnitOfMeasurement枚举转换为字符串的操作。\n\n您还记得StringValue应用于枚举类型的属性吗？现在，我将向您展示如何使用.NET框架的强大功能：[反射 API](https://www.tutorialspoint.com/csharp/csharp_reflection.htm)提取此信息。\n\n反射 API是一组强大的资源工具集，可让我们提取和操作元数据。许多框架和库（包括ASP.NET Core本身）都利用这些资源来处理许多后台工作。\n\n现在让我们看看它在实践中是如何工作的。将新类添加到Extensions名为的文件夹中EnumExtensions。\n\n```\nusing System.ComponentModel;\n\tusing System.Reflection;\n\t\n\n\tnamespace Supermarket.API.Extensions\n\t{\n\t    public static class EnumExtensions\n\t    {\n\t        public static string ToDescriptionString<TEnum>(this TEnum @enum)\n\t        {\n\t            FieldInfo info = @enum.GetType().GetField(@enum.ToString());\n\t            var attributes = (DescriptionAttribute[])info.GetCustomAttributes(typeof(DescriptionAttribute), false);\n\t\n\n\t            return attributes?[0].Description ?? @enum.ToString();\n\t        }\n\t    }\n\t}\n```\n第一次看代码可能会让人感到恐惧，但这并不复杂。让我们分解代码定义以了解其工作原理。\n首先，我们定义了一种[通用方法](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/)（一种方法，该方法可以接收不止一种类型的参数，在这种情况下，该方法由TEnum声明表示），该方法接收给定的枚举作为参数。\n\n由于enum是C＃中的保留关键字，因此我们在参数名称前面添加了@，以使其成为有效名称。\n\n该方法的第一步是使用该方法获取参数的类型信息（类，接口，枚举或结构定义）GetType。\n\n然后，该方法使用来获取特定的枚举值（例如Kilogram）GetField(@enum.ToString())。\n\n下一行找到Description应用于枚举值的所有属性，并将其数据存储到数组中（在某些情况下，我们可以为同一属性指定多个属性）。\n\n最后一行使用较短的语法来检查我们是否至少有一个枚举类型的描述属性。如果有，我们将返回Description此属性提供的值。如果不是，我们使用默认的强制类型转换将枚举作为字符串返回。\n\n?.操作者（[零条件运算](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/conditional-operator)）检查该值是否null访问其属性之前。\n\n??运算符（[空合并运算符](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator)）告诉应用程序在左边的返回值，如果它不为空，或者在正确的，否则价值。\n\n现在我们有了扩展方法来提取描述，让我们配置模型和资源之间的映射。多亏了AutoMapper，我们只需要多一行就可以做到这一点。\n\n打开ModelToResourceProfile类并通过以下方式更改代码：\n\n```\nusing AutoMapper;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Extensions;\n\tusing Supermarket.API.Resources;\n\t\n\n\tnamespace Supermarket.API.Mapping\n\t{\n\t    public class ModelToResourceProfile : Profile\n\t    {\n\t        public ModelToResourceProfile()\n\t        {\n\t            CreateMap<Category, CategoryResource>();\n\t\n\n\t            CreateMap<Product, ProductResource>()\n\t                .ForMember(src => src.UnitOfMeasurement,\n\t                           opt => opt.MapFrom(src => src.UnitOfMeasurement.ToDescriptionString()));\n\t        }\n\t    }\n\t}\n```\n此语法告诉AutoMapper使用新的扩展方法将我们的EUnitOfMeasurement值转换为包含其描述的字符串。简单吧？您可以[阅读官方文档](http://docs.automapper.org/en/stable/Inline-Mapping.html)以了解完整语法。\n注意，我们尚未为category属性定义任何映射配置。因为我们之前为类别配置了映射，并且由于产品模型具有相同类型和名称的category属性，所以AutoMapper隐式知道应该使用各自的配置来映射它。\n\n现在，我们添加端点代码。更改ProductsController代码：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing AutoMapper;\n\tusing Microsoft.AspNetCore.Mvc;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Services;\n\tusing Supermarket.API.Resources;\n\t\n\n\tnamespace Supermarket.API.Controllers\n\t{\n\t    [Route(\"/api/[controller]\")]\n\t    public class ProductsController : Controller\n\t    {\n\t        private readonly IProductService _productService;\n\t        private readonly IMapper _mapper;\n\t\n\n\t        public ProductsController(IProductService productService, IMapper mapper)\n\t        {\n\t            _productService = productService;\n\t            _mapper = mapper;\n\t        }\n\t\n\n\t        [HttpGet]\n\t        public async Task<IEnumerable<ProductResource>> ListAsync()\n\t        {\n\t            var products = await _productService.ListAsync();\n\t            var resources = _mapper.Map<IEnumerable<Product>, IEnumerable<ProductResource>>(products);\n\t            return resources;\n\t        }\n\t    }\n\t}\n```\n基本上，为类别控制器定义的结构相同。\n让我们进入服务部分。将一个新IProductService接口添加到Domain层中的Services文件夹中：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\t\n\n\tnamespace Supermarket.API.Domain.Services\n\t{\n\t    public interface IProductService\n\t    {\n\t         Task<IEnumerable<Product>> ListAsync();\n\t    }\n\t}\n```\n您应该已经意识到，在真正实现新服务之前，我们需要一个仓储。\nIProductRepository在相应的文件夹中添加一个名为的新接口：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\t\n\n\tnamespace Supermarket.API.Domain.Repositories\n\t{\n\t    public interface IProductRepository\n\t    {\n\t         Task<IEnumerable<Product>> ListAsync();\n\t    }\n\t}\n```\n现在，我们实现仓储。除了必须在查询数据时返回每个产品的相应类别数据外，我们几乎必须像对类别仓储一样实现。\n默认情况下，EF Core在查询数据时不包括与模型相关的实体，因为它可能非常慢（想象一个具有十个相关实体的模型，所有相关实体都有自己的关系）。\n\n要包括类别数据，我们只需要多一行：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Microsoft.EntityFrameworkCore;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Repositories;\n\tusing Supermarket.API.Persistence.Contexts;\n\t\n\n\tnamespace Supermarket.API.Persistence.Repositories\n\t{\n\t    public class ProductRepository : BaseRepository, IProductRepository\n\t    {\n\t        public ProductRepository(AppDbContext context) : base(context)\n\t        {\n\t        }\n\t\n\n\t        public async Task<IEnumerable<Product>> ListAsync()\n\t        {\n\t            return await _context.Products.Include(p => p.Category)\n\t                                          .ToListAsync();\n\t        }\n\t    }\n\t}\n```\n请注意对的调用Include(p => p.Category)。我们可以链接此语法，以在查询数据时包含尽可能多的实体。执行选择时，EF Core会将其转换为联接。\n现在，我们可以ProductService像处理类别一样实现类：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Repositories;\n\tusing Supermarket.API.Domain.Services;\n\t\n\n\tnamespace Supermarket.API.Services\n\t{\n\t    public class ProductService : IProductService\n\t    {\n\t        private readonly IProductRepository _productRepository;\n\t    \n\t        public ProductService(IProductRepository productRepository)\n\t        {\n\t            _productRepository = productRepository;\n\t        }\n\t\n\n\t        public async Task<IEnumerable<Product>> ListAsync()\n\t        {\n\t            return await _productRepository.ListAsync();\n\t        }\n\t    }\n\t}\n```\n让我们绑定更改Startup类的新依赖项：\n```\npublic void ConfigureServices(IServiceCollection services)\n\t{\n\t    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);\n\t\n\n\t    services.AddDbContext<AppDbContext>(options =>\n\t    {\n\t        options.UseInMemoryDatabase(\"supermarket-api-in-memory\");\n\t    });\n\t\n\n\t    services.AddScoped<ICategoryRepository, CategoryRepository>();\n\t    services.AddScoped<IProductRepository, ProductRepository>();\n\t    services.AddScoped<IUnitOfWork, UnitOfWork>();\n\t\n\n\t    services.AddScoped<ICategoryService, CategoryService>();\n\t    services.AddScoped<IProductService, ProductService>();\n\t\n\n\t    services.AddAutoMapper();\n\t}\n```\n最后，在测试API之前，让我们AppDbContext在初始化应用程序时更改类以包括一些产品，以便我们看到结果：\n```\nprotected override void OnModelCreating(ModelBuilder builder)\n\t{\n\t    base.OnModelCreating(builder);\n\t    \n\t    builder.Entity<Category>().ToTable(\"Categories\");\n\t    builder.Entity<Category>().HasKey(p => p.Id);\n\t    builder.Entity<Category>().Property(p => p.Id).IsRequired().ValueGeneratedOnAdd().HasValueGenerator<InMemoryIntegerValueGenerator<int>>();\n\t    builder.Entity<Category>().Property(p => p.Name).IsRequired().HasMaxLength(30);\n\t    builder.Entity<Category>().HasMany(p => p.Products).WithOne(p => p.Category).HasForeignKey(p => p.CategoryId);\n\t\n\n\t    builder.Entity<Category>().HasData\n\t    (\n\t        new Category { Id = 100, Name = \"Fruits and Vegetables\" }, // Id set manually due to in-memory provider\n\t        new Category { Id = 101, Name = \"Dairy\" }\n\t    );\n\t\n\n\t    builder.Entity<Product>().ToTable(\"Products\");\n\t    builder.Entity<Product>().HasKey(p => p.Id);\n\t    builder.Entity<Product>().Property(p => p.Id).IsRequired().ValueGeneratedOnAdd();\n\t    builder.Entity<Product>().Property(p => p.Name).IsRequired().HasMaxLength(50);\n\t    builder.Entity<Product>().Property(p => p.QuantityInPackage).IsRequired();\n\t    builder.Entity<Product>().Property(p => p.UnitOfMeasurement).IsRequired();\n\t\n\n\t    builder.Entity<Product>().HasData\n\t    (\n\t        new Product\n\t        {\n\t            Id = 100,\n\t            Name = \"Apple\",\n\t            QuantityInPackage = 1,\n\t            UnitOfMeasurement = EUnitOfMeasurement.Unity,\n\t            CategoryId = 100\n\t        },\n\t        new Product\n\t        {\n\t            Id = 101,\n\t            Name = \"Milk\",\n\t            QuantityInPackage = 2,\n\t            UnitOfMeasurement = EUnitOfMeasurement.Liter,\n\t            CategoryId = 101,\n\t        }\n\t    );\n\t}\n```\n我添加了两个虚构产品，将它们与初始化应用程序时我们播种的类别相关联。\n该测试了！再次运行API并发送GET请求以/api/products使用Postman：\n\n![图片](https://uploader.shimo.im/f/h9cMeoAIZg4vyRgj.png!thumbnail)\n\n就是这样！恭喜你！\n\n现在，您将了解如何使用解耦的代码架构使用ASP.NET Core构建RESTful API。您了解了.NET Core框架的许多知识，如何使用C＃，EF Core和AutoMapper的基础知识以及在设计应用程序时要使用的许多有用的模式。\n\n您可以检查API的完整实现，包括产品的其他HTTP动词，并检查Github仓储：\n\n[evgomes / supermarket-api](https://github.com/evgomes/supermarket-api)\n\n[使用ASP.NET Core 2.2构建的简单RESTful API，展示了如何使用分离的，可维护的……创建RESTful服务](https://github.com/evgomes/supermarket-api)[。github.com](https://github.com/evgomes/supermarket-api)\n\n# **结论**\nASP.NET Core是创建Web应用程序时使用的出色框架。它带有许多有用的API，可用于构建干净，可维护的应用程序。创建专业应用程序时，可以将其视为一种选择。\n\n本文并未涵盖专业API的所有方面，但您已学习了所有基础知识。您还学到了许多有用的模式，可以解决我们每天面临的模式。\n\n希望您喜欢这篇文章，希望对您有所帮助。期待你的反馈，以便我能进一步提高。\n\n**进一步学习的可用参考资料**\n\n[.NET Core教程-Microsoft文档](https://docs.microsoft.com/en-us/dotnet/core/tutorials/)\n\n[ASP.NET Core文档-Microsoft文档](https://docs.microsoft.com/zh-cn/aspnet/#pivot=core&panel=core_tutorials)\n\n","source":"_posts/技术/how-to-use-restfulapi-in-netcore.md","raw":"---\ntitle:  一步一步的构建整洁、可维护的RESTful APIs\ndate: 2020-02-23 22:24\ntags: 技术\nauthor: 邹溪源\ncategories:\n  - 技术\n---\n译者荐语：利用周末的时间，本人拜读了长沙.NET技术社区翻译的技术文章《[微软RESTFul API指南](http://techq.club/2019/08/02/%E6%8A%80%E6%9C%AF/Microsoft%20REST%20API%E6%8C%87%E5%8D%97/)》，打算按照步骤写一个完整的教程，后来无意中看到了这篇文章，与我要写的主题有不少相似之处，特意翻译下来。前方高能。\n\n![图片](https://uploader.shimo.im/f/U68C9NmcWwwWHATD.png!thumbnail)一步一步的构建整洁、可维护的RESTful APIs\n\n[查看原文](https://www.techq.xyz/2020/02/23/%E6%8A%80%E6%9C%AF/WPF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%A6%82%E8%BF%B0/)\n\n# 总览\nRESTful不是一个新名词。它是一种架构风格，这种架构风格使用Web服务从客户端应用程序接收数据和向客户端应用程序发送数据。其目标是集中不同客户端应用程序将使用的数据。\n\n选择正确的工具来编写RESTful服务至关重要，因为我们需要关注可伸缩性，维护，文档以及所有其他相关方面。在[ASP.NET](https://docs.microsoft.com/en-us/aspnet/) Core为我们提供了一个功能强大、易于使用的API，使用这些API将很好的实现这个目标。\n\n在本文中，我将向您展示如何使用ASP.NET Core框架为“几乎”现实世界的场景编写结构良好的RESTful API。我将详细介绍常见的模式和策略以简化开发过程。\n\n我还将向您展示如何集成通用框架和库，例如[Entity Framework Core](https://docs.microsoft.com/en-us/ef/core/)和[AutoMapper](https://automapper.org/)，以提供必要的功能。\n\n# **先决条件**\n我希望您了解面向对象的编程概念。\n\n即使我将介绍[C＃编程语言](https://docs.microsoft.com/en-us/dotnet/csharp/)的许多细节，我还是建议您具有该主题的基本知识。\n\n我还假设您知道什么是REST，[HTTP协议](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)如何工作，什么是API端点以及什么是[JSON](https://www.json.org/)。[这是](https://medium.freecodecamp.org/restful-services-part-i-http-in-a-nutshell-aab3bfedd131)关于此主题[的出色的入门教程](https://medium.freecodecamp.org/restful-services-part-i-http-in-a-nutshell-aab3bfedd131)。最后，您需要了解关系数据库的工作原理。\n\n要与我一起编码，您将必须安装[.NET Core 2.2](https://dotnet.microsoft.com/download)以及[Postman](https://www.getpostman.com/)（我将用来测试API的工具）。我建议您使用诸如[Visual Studio Code之](https://code.visualstudio.com/)类的代码编辑器来开发API。选择您喜欢的代码编辑器。如果选择Visual Studio Code作为您的代码编辑器，建议您安装[C＃扩展](https://code.visualstudio.com/docs/languages/csharp)以更好地突出显示代码。\n\n您可以在本文末尾找到该API的Github的链接，以检查最终结果。\n\n# **范围**\n让我们为一家超市编写一个虚构的Web API。假设我们必须实现以下范围：\n\n* *创建一个RESTful服务，该服务允许客户端应用程序管理超市的产品目录。它需要公开端点以创建，读取，编辑和删除产品类别，例如乳制品和化妆品，还需要管理这些类别的产品。*\n* *对于类别，我们需要存储其名称。对于产品，我们需要存储其名称，度量单位（例如，按重量测量的产品为KG），包装中的数量（例如，如果一包饼干是10，则为10）及其各自的类别。*\n\n为了简化示例，我将不处理库存产品，产品运输，安全性和任何其他功能。这个范围足以向您展示ASP.NET Core的工作方式。\n\n要开发此服务，我们基本上需要两个API 端点（译者注：指控制器）：一个用于管理类别，一个用于管理产品。在JSON通讯方面，我们可以认为响应如下：\n\n```\nAPI endpoint: /api/categories\nJSON Response (for GET requests):\n{\n  [\n    { \"id\": 1, \"name\": \"Fruits and Vegetables\" },\n    { \"id\": 2, \"name\": \"Breads\" },\n    … // Other categories\n  ]\n}\n```\n```\nAPI endpoint: /api/products\nJSON Response (for GET requests):\n{\n  [\n    {\n      \"id\": 1,\n      \"name\": \"Sugar\",\n      \"quantityInPackage\": 1,\n      \"unitOfMeasurement\": \"KG\"\n      \"category\": {\n        \"id\": 3,\n        \"name\": \"Sugar\"\n      }\n    },\n    … // Other products\n  ]\n}\n```\n让我们开始编写应用程序。\n# **第1步-创建API**\n首先，我们必须为Web服务创建文件夹结构，然后我们必须使用[.NET CLI工具](https://docs.microsoft.com/en-us/dotnet/core/tools/?tabs=netcore2x)来构建基本的Web API。打开终端或命令提示符（取决于您使用的操作系统），并依次键入以下命令：\n\n```\nmkdir src/Supermarket.API\n\ncd src/Supermarket.API\n\ndotnet new webapi\n```\n前两个命令只是为API创建一个新目录，然后将当前位置更改为新文件夹。最后一个遵循Web API模板生成一个新项目，这是我们正在开发的应用程序。您可以阅读有关这些命令和其他项目模板的更多信息，并可以通过[检查此链接](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new?tabs=netcore21)来生成其他项目模板。\n现在，新目录将具有以下结构：\n\n![图片](https://uploader.shimo.im/f/LuICwkhqHDsD5RcN.png!thumbnail)\n\n项目结构\n\n## 结构概述\nASP.NET Core应用程序由在类中配置的一组[中间件](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-2.2)（应用程序流水线中的小块应用程序，用于处理请求和响应）组成Startup。如果您以前已经使用过[Express.js](https://expressjs.com/)之类的框架，那么这个概念对您来说并不是什么新鲜事物。\n\n```\npublic class Startup\n\t{\n\t    public Startup(IConfiguration configuration)\n\t    {\n\t        Configuration = configuration;\n\t    }\n\t\n\n\t    public IConfiguration Configuration { get; }\n\t\n\n\t    // This method gets called by the runtime. Use this method to add services to the container.\n\t    public void ConfigureServices(IServiceCollection services)\n\t    {\n\t        services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);\n\t    }\n\t\n\n\t    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n\t    public void Configure(IApplicationBuilder app, IHostingEnvironment env)\n\t    {\n\t        if (env.IsDevelopment())\n\t        {\n\t            app.UseDeveloperExceptionPage();\n\t        }\n\t        else\n\t        {\n\t            // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.\n\t            app.UseHsts();\n\t        }\n\t\n\n\t        app.UseHttpsRedirection();\n\t        app.UseMvc();\n\t    }\n\t}\n```\n当应用程序启动时，将调用类中的Main** **方法Program。它使用启动配置创建默认的Web主机，通过HTTP通过特定端口（默认情况下，HTTP为5000，HTTPS为5001）公开应用程序。\n```\nnamespace Supermarket.API\n\t{\n\t    public class Program\n\t    {\n\t        public static void Main(string[] args)\n\t        {\n\t            CreateWebHostBuilder(args).Build().Run();\n\t        }\n\t\n\n\t        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =>\n\t            WebHost.CreateDefaultBuilder(args)\n\t                .UseStartup<Startup>();\n\t    }\n\t}\n```\n看一下文件夹中的ValuesController类Controllers。它公开了API通过路由接收请求时将调用的方法/api/values。\n```\n[Route(\"api/[controller]\")]\n\t[ApiController]\n\tpublic class ValuesController : ControllerBase\n\t{\n\t    // GET api/values\n\t    [HttpGet]\n\t    public ActionResult<IEnumerable<string>> Get()\n\t    {\n\t        return new string[] { \"value1\", \"value2\" };\n\t    }\n\t\n\n\t    // GET api/values/5\n\t    [HttpGet(\"{id}\")]\n\t    public ActionResult<string> Get(int id)\n\t    {\n\t        return \"value\";\n\t    }\n\t\n\n\t    // POST api/values\n\t    [HttpPost]\n\t    public void Post([FromBody] string value)\n\t    { \n\t    }\n\t\n\n\t    // PUT api/values/5\n\t    [HttpPut(\"{id}\")]\n\t    public void Put(int id, [FromBody] string value)\n\t    {   \n\t    }\n\t\n\n\t    // DELETE api/values/5\n\t    [HttpDelete(\"{id}\")]\n\t    public void Delete(int id)\n\t    {  \n\t    }\n\t}\n```\n如果您不了解此代码的某些部分，请不要担心。在开发必要的API端点时，我将详细介绍每一个。现在，只需删除此类，因为我们不会使用它。\n# **第2步-创建领域模型**\n我将应用一些设计概念，以使应用程序简单易维护。\n\n编写可以由您自己理解和维护的代码并不难，但是您必须牢记您将成为团队的一部分。如果您不注意如何编写代码，那么结果将是一个庞然大物，这将使您和您的团队成员头痛不已。听起来很极端吧？但是相信我，这就是事实。\n\n![图片](https://uploader.shimo.im/f/vMGZaW8zLiA39wxb.png!thumbnail)\n\n衡量好代码的标准是WTF的频率。原图来自[smitty42](https://www.flickr.com/photos/smitty/)，发表于[filckr](https://www.flickr.com/photos/smitty/2245445147)。该图遵循CC-BY-2.0。\n\n在Supermarket.API目录中，创建一个名为的新文件夹Domain。在新的领域文件夹中，创建另一个名为的文件夹Models。我们必须添加到此文件夹的第一个模型是Category。最初，它将是一个简单的[Plain Old CLR Object（POCO）](https://en.wikipedia.org/wiki/Plain_old_CLR_object)类。这意味着该类将仅具有描述其基本信息的属性。\n\n```\nusing System.Collections.Generic;\n\t\n\n\tnamespace Supermarket.API.Domain.Models\n\t{\n\t    public class Category\n\t    {\n\t        public int Id { get; set; }\n\t        public string Name { get; set; }\n\t        public IList<Product> Products { get; set; } = new List<Product>();\n\t    }\n\t}\n```\n该类具有一个Id** **属性（用于标识类别）和一个Name属性。以及一个Products** **属性。最后一个属性将由**Entity Framework Core使用**，大多数ASP.NET Core应用程序使用ORM将数据持久化到数据库中，以映射类别和产品之间的关系。由于类别具有许多相关产品，因此在面向对象的编程方面也具有合理的思维能力。\n我们还必须创建产品模型。在同一文件夹中，添加一个新Product类。\n\n```\nnamespace Supermarket.API.Domain.Models\n\t{\n\t    public class Product\n\t    {\n\t        public int Id { get; set; }\n\t        public string Name { get; set; }\n\t        public short QuantityInPackage { get; set; }\n\t        public EUnitOfMeasurement UnitOfMeasurement { get; set; }\n\t\n\n\t        public int CategoryId { get; set; }\n\t        public Category Category { get; set; }\n\t    }\n\t}\n```\n该产品还具有ID和名称的属性。属性QuantityInPackage，它告诉我们一包中有多少个产品单位（请记住应用范围的饼干示例）和一个UnitOfMeasurement** **属性，这是表示一个[枚举类型](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum)，它表示可能的度量单位的枚举。最后两个属性，CategoryId** **和Category将由ORM用于映射的产品和类别之间的关系。它表明一种产品只有一个类别。\n\n让我们定义领域模型的最后一部分，EUnitOfMeasurement** **枚举。\n\n按照惯例，枚举不需要在名称前以*“ E”*开头，但是在某些库和框架中，您会发现此前缀是将枚举与接口和类区分开的一种方式。\n\n```\nusing System.ComponentModel;\n\t\n\n\tnamespace Supermarket.API.Domain.Models\n\t{\n\t    public enum EUnitOfMeasurement : byte\n\t    {\n\t        [Description(\"UN\")]\n\t        Unity = 1,\n\t\n\n\t        [Description(\"MG\")]\n\t        Milligram = 2,\n\t\n\n\t        [Description(\"G\")]\n\t        Gram = 3,\n\t\n\n\t        [Description(\"KG\")]\n\t        Kilogram = 4,\n\t\n\n\t        [Description(\"L\")]\n\t        Liter = 5\n\t    }\n\t}\n```\n该代码非常简单。在这里，我们仅定义了几种度量单位的可能性，但是，在实际的超市系统中，您可能具有许多其他度量单位，并且可能还有一个单独的模型。\n注意，【Description】特性应用于所有枚举可能性。特性是一种在C＃语言的类，接口，属性和其他组件上定义元数据的方法。在这种情况下，我们将使用它来简化产品API端点的响应，但是您现在不必关心它。我们待会再回到这里。\n\n我们的基本模型已准备就绪，可以使用。现在，我们可以开始编写将管理所有类别的API端点。\n\n# **第3步-类别API**\n在Controllers文件夹中，添加一个名为的新类CategoriesController。\n\n按照惯例，该文件夹中所有后缀为*“ Controller”的类*都将成为我们应用程序的控制器。这意味着他们将处理请求和响应。您必须从[命名空间](https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/namespace)【Microsoft.AspNetCore.Mvc】继承Controller。\n\n命名空间由一组相关的类，接口，枚举和结构组成。您可以将其视为类似于Java语言[模块](https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc)或Java [程序包](https://docs.oracle.com/javase/tutorial/java/package/packages.html)的东西。\n\n新的控制器应通过路由/api/categories做出响应。我们通过Route** **在类名称上方添加属性，指定占位符来实现此目的，该占位符表示路由应按照惯例使用不带控制器后缀的类名称。\n\n```\nusing Microsoft.AspNetCore.Mvc;\n\t\n\n\tnamespace Supermarket.API.Controllers\n\t{\n\t    [Route(\"/api/[controller]\")]\n\t    public class CategoriesController : Controller\n\t    {\n\t    }\n\t}\n```\n让我们开始处理GET请求。首先，当有人/api/categories通过GET动词请求数据时，API需要返回所有类别。为此，我们可以创建**类别服务**。\n从概念上讲，服务基本上是定义用于处理某些业务逻辑的方法的类或接口。创建用于处理业务逻辑的服务是许多不同编程语言的一种常见做法，例如[身份验证和授权](https://medium.com/@evandro.ggomes/json-web-token-authentication-with-asp-net-core-2-0-b074b0cfc870)，付款，复杂的数据流，缓存和需要其他服务或模型之间进行某些交互的任务。\n\n使用服务，我们可以将请求和响应处理与完成任务所需的真实逻辑隔离开来。\n\n该服务，我们要创建将首先定义一个单独的行为**，**或**方法**：一个list方法。我们希望该方法返回数据库中所有现有的类别。\n\n为简单起见，在这篇博客中，我们将不处理数据分页或过滤，（译者注：基于RESTFul规范，提供了一套完整的分页和过滤的规则）。将来，我将写一篇文章，展示如何轻松处理这些功能。\n\n为了定义C＃（以及其他面向对象的语言，例如Java）中某事物的预期行为，我们定义一个**interface**。一个接口告诉某些事情应该如何工作，但是**没有实现行为的真实逻辑**。逻辑在实现接口的类中实现。如果您不清楚此概念，请不要担心。一段时间后您将了解它。\n\n在Domain文件夹中，创建一个名为的新目录Services。在此添加一个名为ICategoryService的接口。按照惯例，所有接口都应以C＃中的大写字母*“ I”*开头。定义接口代码，如下所示：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\t\n\n\tnamespace Supermarket.API.Domain.Services\n\t{\n\t    public interface ICategoryService\n\t    {\n\t         Task<IEnumerable<Category>> ListAsync();\n\t    }\n\t}\n```\n该ListAsync方法的实现必须**异步**返回类别的可枚举对象。\nTask封装返回的类表示异步。由于必须等待数据库完成操作才能返回数据，因此我们需要考虑执行此过程可能需要一段时间，因此我们需要使用异步方法。另请注意*“Async”*后缀。这是一个约定，告诉我们的方法应异步执行。\n\n我们有很多约定，对吗？我个人喜欢它，因为它使应用程序易于阅读，即使你在一家使用.NET技术的公司是新人。\n\n![图片](https://uploader.shimo.im/f/vQLzU6MpZkoChf0Y.png!thumbnail)\n\n*“-好的，我们定义了此接口，但是它什么也没做。有什么用？”*\n\n如果您来自Javascript或其他非强类型语言，则此概念可能看起来很奇怪。\n\n接口使我们能够从实际实现中抽象出所需的行为。使用称为[依赖注入](https://medium.freecodecamp.org/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f)的机制，我们可以实现这些接口并将它们与其他组件隔离。\n\n基本上，当您使用依赖项注入时，您可以使用接口定义一些行为。然后，创建一个实现该接口的类。最后，将引用从接口绑定到您创建的类。\n\n*”-听起来确实令人困惑。我们不能简单地创建一个为我们做这些事情的类吗？”*\n\n让我们继续实现我们的API，您将了解为什么使用这种方法。\n\n更改CategoriesController代码，如下所示：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Microsoft.AspNetCore.Mvc;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Services;\n\t\n\n\tnamespace Supermarket.API.Controllers\n\t{\n\t    [Route(\"/api/[controller]\")]\n\t    public class CategoriesController : Controller\n\t    {\n\t        private readonly ICategoryService _categoryService;\n\t        \n\t        public CategoriesController(ICategoryService categoryService)\n\t        {\n\t            _categoryService = categoryService;   \n\t        }\n\t\n\n\t        [HttpGet]\n\t        public async Task<IEnumerable<Category>> GetAllAsync()\n\t        {\n\t            var categories = await _categoryService.ListAsync();\n\t            return categories;\n\t        }\n\t    }\n\t}\n```\n我已经为控制器定义了一个构造函数（当创建一个类的新实例时会调用一个构造函数），并且它接收的实例ICategoryService。这意味着实例可以是任何实现服务接口的实例。我将此实例存储在一个私有的只读字段中_categoryService。我们将使用此字段访问类别服务实现的方法。\n顺便说一下，下划线前缀是表示字段的另一个通用约定。特别地，[.NET](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions)的[官方命名约定指南](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions)不建议使用此[约定](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions)，但是这是一种非常普遍的做法，可以避免使用*“ this”*关键字来区分类字段和局部变量。我个人认为阅读起来要干净得多，并且许多框架和库都使用此约定。\n\n在构造函数下，我定义了用于处理请求的方法/api/categories。该HttpGet** **属性告诉ASP.NET Core管道使用该属性来处理GET请求（可以省略此属性，但是最好编写它以便于阅读）。\n\n该方法使用我们的CategoryService实例列出所有类别，然后将类别返回给客户端。框架管道将数据序列化为JSON对象。IEnumerable类型告诉框架，我们想要返回一个类别的枚举，而Task类型(使用async关键字修饰)告诉管道，这个方法应该异步执行。最后，当我们定义一个异步方法时，我们必须使用await关键字来处理需要一些时间的任务。\n\n好的，我们定义了API的初始结构。现在，有必要真正实现类别服务。\n\n# **步骤4-实现类别服务**\n在API的根文件夹（即Supermarket.API文件夹）中，创建一个名为的新文件夹Services。在这里，我们将放置所有服务实现。在新文件夹中，添加一个名为CategoryService的新类。更改代码，如下所示：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Services;\n\t\n\n\tnamespace Supermarket.API.Services\n\t{\n\t    public class CategoryService : ICategoryService\n\t    {\n\t        public async Task<IEnumerable<Category>> ListAsync()\n\t        {\n\t        }\n\t    }\n\t}\n```\n以上只是接口实现的基本代码，我们暂时仍不处理任何逻辑。让我们考虑一下列表方法应该如何实现。\n我们需要访问数据库并返回所有类别，然后我们需要将此数据返回给客户端。\n\n服务类不是应该处理数据访问的类。我们将使用一种称为“仓储模式”的设计模式，定义仓储类，用于管理数据库中的数据。\n\n在使用仓储模式时，我们定义了repository 类，该类基本上封装了处理数据访问的所有逻辑。这些仓储类使方法可以列出，创建，编辑和删除给定模型的对象，与操作集合的方式相同。在内部，这些方法与数据库对话以执行CRUD操作，从而将数据库访问与应用程序的其余部分隔离开。\n\n我们的服务需要调用类别仓储，以获取列表对象。\n\n从概念上讲，服务可以与一个或多个仓储或其他服务“对话”以执行操作。\n\n创建用于处理数据访问逻辑的新定义似乎是多余的，但是您将在一段时间内看到将这种逻辑与服务类隔离是非常有利的。\n\n让我们创建一个仓储，该仓储负责与数据库通信，作为持久化保存类别的一种方式。\n\n# **步骤5-类别仓储和持久层**\n在该Domain文件夹内，创建一个名为的新目录Repositories。然后，添加一个名为的新接口ICategoryRespository。定义接口如下：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\tnamespace Supermarket.API.Domain.Repositories\n\t{\n\t    public interface ICategoryRepository\n\t    {\n\t         Task<IEnumerable<Category>> ListAsync();\n\t    }\n\t}\n```\n初始代码基本上与服务接口的代码相同。\n定义了接口之后，我们可以返回服务类并使用的实例ICategoryRepository返回数据来完成实现list方法。\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Repositories;\n\tusing Supermarket.API.Domain.Services;\n\t\n\n\tnamespace Supermarket.API.Services\n\t{\n\t    public class CategoryService : ICategoryService\n\t    {\n\t        private readonly ICategoryRepository _categoryRepository;\n\t\n\n\t        public CategoryService(ICategoryRepository categoryRepository)\n\t        {\n\t            this._categoryRepository = categoryRepository;\n\t        }\n\t\n\n\t        public async Task<IEnumerable<Category>> ListAsync()\n\t        { \n\t            return await _categoryRepository.ListAsync();\n\t        }\n\t    }\n\t}\n```\n现在，我们必须实现类别仓储的真实逻辑。在这样做之前，我们必须考虑如何访问数据库。\n*顺便说一句，我们仍然没有数据库！*\n\n我们将使用Entity Framework Core（为简单起见，我将其称为***EF Core***）作为我们的数据库ORM。该框架是ASP.NET Core的默认ORM，并公开了一个友好的API，该API使我们能够将应用程序的类映射到数据库表。\n\nEF Core还允许我们先设计应用程序，然后根据我们在代码中定义的内容生成数据库。此技术称为**Code First**。我们将使用Code First方法来生成数据库（实际上，在此示例中，我将使用内存数据库，但是您可以轻松地将其更改为像SQL Server或MySQL服务器这样的实例数据库）。\n\n在API的根文件夹中，创建一个名为的新目录Persistence。此目录将包含我们访问数据库所需的所有内容，例如仓储实现。\n\n在新文件夹中，创建一个名为的新目录Contexts，然后添加一个名为的新类AppDbContext。此类必须继承DbContext，EF Core通过DBContext用来将您的模型映射到数据库表的类。通过以下方式更改代码：\n\n```\nusing Microsoft.EntityFrameworkCore;\n\t\n\n\tnamespace Supermarket.API.Domain.Persistence.Contexts\n\t{\n\t    public class AppDbContext : DbContext\n\t    {\n\t        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options)\n\t        {\n\t        }\n\t    }\n\t}\n```\n我们添加到此类的构造函数负责通过依赖注入将数据库配置传递给基类。稍后您将看到其工作原理。\n现在，我们必须创建两个DbSet属性。这些属性是将模型映射到数据库表的集合（唯一对象的集合）。\n\n另外，我们必须将模型的属性映射到相应的列，指定哪些属性是主键，哪些是外键，列类型等。我们可以使用称为[Fluent API](http://www.entityframeworktutorial.net/efcore/fluent-api-in-entity-framework-core.aspx)的功能来覆盖OnModelCreating方法，以指定数据库映射。更改AppDbContext类，如下所示：\n\n该代码是如此直观。\n\n```\nusing Microsoft.EntityFrameworkCore;\n\tusing Supermarket.API.Domain.Models;\n\t\n\n\tnamespace Supermarket.API.Persistence.Contexts\n\t{\n\t    public class AppDbContext : DbContext\n\t    {\n\t        public DbSet<Category> Categories { get; set; }\n\t        public DbSet<Product> Products { get; set; }\n\t\n\n\t        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }\n\t\n\n\t        protected override void OnModelCreating(ModelBuilder builder)\n\t        {\n\t            base.OnModelCreating(builder);\n\t            \n\t            builder.Entity<Category>().ToTable(\"Categories\");\n\t            builder.Entity<Category>().HasKey(p => p.Id);\n\t            builder.Entity<Category>().Property(p => p.Id).IsRequired().ValueGeneratedOnAdd();\n\t            builder.Entity<Category>().Property(p => p.Name).IsRequired().HasMaxLength(30);\n\t            builder.Entity<Category>().HasMany(p => p.Products).WithOne(p => p.Category).HasForeignKey(p => p.CategoryId);\n\t\n\n\t            builder.Entity<Category>().HasData\n\t            (\n\t                new Category { Id = 100, Name = \"Fruits and Vegetables\" }, // Id set manually due to in-memory provider\n\t                new Category { Id = 101, Name = \"Dairy\" }\n\t            );\n\t\n\n\t            builder.Entity<Product>().ToTable(\"Products\");\n\t            builder.Entity<Product>().HasKey(p => p.Id);\n\t            builder.Entity<Product>().Property(p => p.Id).IsRequired().ValueGeneratedOnAdd();\n\t            builder.Entity<Product>().Property(p => p.Name).IsRequired().HasMaxLength(50);\n\t            builder.Entity<Product>().Property(p => p.QuantityInPackage).IsRequired();\n\t            builder.Entity<Product>().Property(p => p.UnitOfMeasurement).IsRequired();\n\t        }\n\t    }\n\t}\n```\n我们指定我们的模型应映射到哪些表。此外，我们设置了主键，使用该方法HasKey，该表的列，使用Property方法，和一些限制，例如IsRequired，HasMaxLength**，**和ValueGeneratedOnAdd，这些都是使用FluentApi的方式基于Lamada 表达式语法实现的（链式语法）。\n看一下下面的代码：\n\n```\nbuilder.Entity<Category>()\n       .HasMany(p => p.Products)\n       .WithOne(p => p.Category)\n       .HasForeignKey(p => p.CategoryId);\n```\n在这里，我们指定表之间的关系。我们说一个类别有很多产品，我们设置了将映射此关系的属性（Products，来自Category类，和Category，来自Product类）。我们还设置了外键（CategoryId）。\n如果您想学习如何使用EF Core配置一对一和多对多关系，以及如何完整的使用它，请看一下[本教程](https://www.learnentityframeworkcore.com/relationships)。\n\n还有一种用于通过HasData方法配置种子数据的方法：\n\n```\nbuilder.Entity<Category>().HasData\n(\n  new Category { Id = 100, Name = \"Fruits and Vegetables\" },\n  new Category { Id = 101, Name = \"Dairy\" }\n);\n```\n默认情况下，在这里我们仅添加两个示例类别。这对我们完成后进行API的测试来说是非常有必要的。\n>**注意：**我们在Id这里手动设置属性，因为内存提供程序的工作机制需要。我将标识符设置为大数字，以避免自动生成的标识符和种子数据之间发生冲突。\n>>真正的关系数据库提供程序中不存在此限制，因此，例如，如果要使用SQL Server等数据库，则不必指定这些标识符。如果您想了解此行为，请检查[此Github问题](https://github.com/aspnet/EntityFrameworkCore/issues/6872)。\n\n在实现数据库上下文类之后，我们可以实现类别仓储。添加一个名为新的文件夹Repositories里面Persistence的文件夹，然后添加一个名为新类BaseRepository。\n\n```\nusing Supermarket.API.Persistence.Contexts;\n\t\n\n\tnamespace Supermarket.API.Persistence.Repositories\n\t{\n\t    public abstract class BaseRepository\n\t    {\n\t        protected readonly AppDbContext _context;\n\t\n\n\t        public BaseRepository(AppDbContext context)\n\t        {\n\t            _context = context;\n\t        }\n\t    }\n\t}\n```\n此类只是我们所有仓储都将继承的**抽象类**。抽象类是没有直接实例的类。您必须创建直接类来创建实例。\n在BaseRepository接受我们的实例，AppDbContext通过依赖注入暴露了一个受保护的属性称为（只能是由子类访问一个属性）_context，即可以访问我们需要处理数据库操作的所有方法。\n\n在相同文件夹中添加一个新类CategoryRepository。现在，我们将真正实现仓储逻辑：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Microsoft.EntityFrameworkCore;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Repositories;\n\tusing Supermarket.API.Persistence.Contexts;\n\t\n\n\tnamespace Supermarket.API.Persistence.Repositories\n\t{\n\t    public class CategoryRepository : BaseRepository, ICategoryRepository\n\t    {\n\t        public CategoryRepository(AppDbContext context) : base(context)\n\t        {\n\t        }\n\t\n\n\t        public async Task<IEnumerable<Category>> ListAsync()\n\t        {\n\t            return await _context.Categories.ToListAsync();\n\t        }\n\t    }\n\t}\n```\n仓储继承BaseRepository和实现ICategoryRepository。\n注意实现list方法是很简单的。我们使用Categories数据库集访问类别表，然后调用扩展方法ToListAsync，该方法负责将查询结果转换为类别的集合。\n\nEF Core [将我们的方法调用转换为SQL查询](https://docs.microsoft.com/en-us/ef/core/querying/overview)，这是最有效的方法。这种方式仅当您调用将数据转换为集合的方法或使用方法获取特定数据时才执行查询。\n\n现在，我们有了类别控制器，服务和仓储库的代码实现。\n\n我们将关注点分离开来，创建了只执行应做的事情的类。\n\n测试应用程序之前的最后一步是使用ASP.NET Core依赖项注入机制将我们的接口绑定到相应的类。\n\n# **第6步-配置依赖注入**\n现在是时候让您最终了解此概念的工作原理了。\n\n![图片](https://uploader.shimo.im/f/GYbYOJqzMqsxEBg3.png!thumbnail)\n\n在应用程序的根文件夹中，打开Startup类。此类负责在应用程序启动时配置各种配置。\n\n该ConfigureServices和Configure方法通过框架管道在运行时调用来配置应用程序应该如何工作，必须使用哪些组件。\n\n打开ConfigureServices方法。在这里，我们只有一行配置应用程序以使用MVC管道，这基本上意味着该应用程序将使用控制器类来处理请求和响应（在这段代码背后发生了很多事情，但目前您仅需要知道这些）。\n\n我们可以使用ConfigureServices访问services参数的方法来配置我们的依赖项绑定。清理类代码，删除所有注释并按如下所示更改代码：\n\n```\nusing Microsoft.AspNetCore.Builder;\n\tusing Microsoft.AspNetCore.Hosting;\n\tusing Microsoft.AspNetCore.Mvc;\n\tusing Microsoft.EntityFrameworkCore;\n\tusing Microsoft.Extensions.Configuration;\n\tusing Microsoft.Extensions.DependencyInjection;\n\tusing Supermarket.API.Domain.Repositories;\n\tusing Supermarket.API.Domain.Services;\n\tusing Supermarket.API.Persistence.Contexts;\n\tusing Supermarket.API.Persistence.Repositories;\n\tusing Supermarket.API.Services;\n\t\n\n\tnamespace Supermarket.API\n\t{\n\t    public class Startup\n\t    {\n\t        public IConfiguration Configuration { get; }\n\t\n\n\t        public Startup(IConfiguration configuration)\n\t        {\n\t            Configuration = configuration;\n\t        }\n\t\n\n\t        public void ConfigureServices(IServiceCollection services)\n\t        {\n\t            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);\n\t\n\n\t            services.AddDbContext<AppDbContext>(options => {\n\t                options.UseInMemoryDatabase(\"supermarket-api-in-memory\");\n\t            });\n\t\n\n\t            services.AddScoped<ICategoryRepository, CategoryRepository>();\n\t            services.AddScoped<ICategoryService, CategoryService>();\n\t        }\n\t\n\n\t        public void Configure(IApplicationBuilder app, IHostingEnvironment env)\n\t        {\n\t            if (env.IsDevelopment())\n\t            {\n\t                app.UseDeveloperExceptionPage();\n\t            }\n\t            else\n\t            {\n\t                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.\n\t                app.UseHsts();\n\t            }\n\t\n\n\t            app.UseHttpsRedirection();\n\t            app.UseMvc();\n\t        }\n\t    }\n\t}\n```\n看一下这段代码：\n```\nservices.AddDbContext<AppDbContext>(options => {\n\n  options.UseInMemoryDatabase(\"supermarket-api-in-memory\");\n  \n});\n```\n在这里，我们配置数据库上下文。我们告诉ASP.NET Core将其AppDbContext与内存数据库实现一起使用，该实现由作为参数传递给我们方法的字符串标识。通常，在编写[集成测试](https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-2.2)时才会使用内存数据库，但是为了简单起见，我在这里使用了内存数据库。这样，我们无需连接到真实的数据库即可测试应用程序。\n这些代码行在内部配置我们的数据库上下文，以便使用确定作用域的生存周期进行依赖注入。\n\nscoped生存周期告诉ASP.NET Core管道，每当它需要解析接收AppDbContext作为构造函数参数的实例的类时，都应使用该类的相同实例。如果内存中没有实例，则管道将创建一个新实例，并在给定请求期间在需要它的所有类中重用它。这样，您无需在需要使用时手动创建类实例。\n\n如果你想了解其他有关生命周期的知识，可以阅读[官方文档](https://docs.microsoft.com/pt-br/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.2)。\n\n依赖注入技术为我们提供了许多优势，例如：\n\n* 代码可重用性；\n* 更高的生产力，因为当我们不得不更改实现时，我们无需费心去更改您使用该功能的一百个地方；\n* 您可以轻松地测试应用程序，因为我们可以使用mock（类的伪实现）隔离必须测试的内容，而我们必须将接口作为构造函数参数进行传递。\n* 当一个类需要通过构造函数接收更多的依赖关系时，您不必手动更改正在创建实例的所有位置（**太赞了！**）。\n\n配置数据库上下文之后，我们还将我们的服务和仓储绑定到相应的类。\n\n```\nservices.AddScoped<ICategoryRepository, CategoryRepository>();\n\nservices.AddScoped<ICategoryService, CategoryService>();\n```\n在这里，我们还使用了scoped生存周期，因为这些类在内部必须使用数据库上下文类。在这种情况下，指定相同的范围是有意义的。\n现在我们配置了依赖绑定，我们必须在Program类上进行一些小的更改，以便数据库正确地初始化种子数据。此步骤仅在使用内存数据库提供程序时才需要执行（请参阅[此Github问题](https://github.com/aspnet/EntityFrameworkCore/issues/11666)以了解原因）。\n\n```\nusing System;\n\tusing System.Collections.Generic;\n\tusing System.IO;\n\tusing System.Linq;\n\tusing System.Threading.Tasks;\n\tusing Microsoft.AspNetCore;\n\tusing Microsoft.AspNetCore.Hosting;\n\tusing Microsoft.Extensions.Configuration;\n\tusing Microsoft.Extensions.DependencyInjection;\n\tusing Microsoft.Extensions.Logging;\n\tusing Supermarket.API.Persistence.Contexts;\n\t\n\n\tnamespace Supermarket.API\n\t{\n\t    public class Program\n\t    {\n\t        public static void Main(string[] args)\n\t        {\n\t            var host = BuildWebHost(args);\n\t\n\n\t            using(var scope = host.Services.CreateScope())\n\t            using(var context = scope.ServiceProvider.GetService<AppDbContext>())\n\t            {\n\t                context.Database.EnsureCreated();\n\t            }\n\t\n\n\t            host.Run();\n\t        }\n\t\n\n\t        public static IWebHost BuildWebHost(string[] args) =>\n\t            WebHost.CreateDefaultBuilder(args)\n\t            .UseStartup<Startup>()\n\t            .Build();\n\t    }\n\t}\n```\n由于我们使用的是内存提供程序，因此有必要更改Main方法 添加“ context.Database.EnsureCreated();”代码以确保在应用程序启动时将“创建”数据库。没有此更改，将不会创建我们想要的初始化种子数据。\n实现了所有基本功能后，就该测试我们的API端点了。\n\n# **第7步-测试类别**\n在API根文件夹中打开终端或命令提示符，然后键入以下命令：\n\n```\ndotnet run\n```\n上面的命令启动应用程序。控制台将显示类似于以下内容的输出：\n```\ninfo: Microsoft.EntityFrameworkCore.Infrastructure[10403]\n\nEntity Framework Core 2.2.0-rtm-35687 initialized ‘AppDbContext’ using provider ‘Microsoft.EntityFrameworkCore.InMemory’ with options: StoreName=supermarket-api-in-memory\n\ninfo: Microsoft.EntityFrameworkCore.Update[30100]\n\nSaved 2 entities to in-memory store.\n\ninfo: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[0]\n\nUser profile is available. Using ‘C:\\Users\\evgomes\\AppData\\Local\\ASP.NET\\DataProtection-Keys’ as key repository and Windows DPAPI to encrypt keys at rest.\n\nHosting environment: Development\n\nContent root path: C:\\Users\\evgomes\\Desktop\\Tutorials\\src\\Supermarket.API\n\nNow listening on: https://localhost:5001\n\nNow listening on: http://localhost:5000\n\nApplication started. Press Ctrl+C to shut down.\n```\n您可以看到调用了EF Core来初始化数据库。最后几行显示应用程序在哪个端口上运行。\n打开浏览器，然后导航到 [http](http://localhost:5000/api/categories)[:](http://localhost:5000/api/categories)[//localhost](http://localhost:5000/api/categories)[:](http://localhost:5000/api/categories)[5000/api/categories](http://localhost:5000/api/categories) （或控制台输出上显示的URL）。如果您发现由于HTTPS导致的安全错误，则只需为应用程序添加一个例外。\n\n浏览器将显示以下JSON数据作为输出：\n\n```\n[\n  {\n     \"id\": 100,\n     \"name\": \"Fruits and Vegetables\",\n     \"products\": []\n  },\n  {\n     \"id\": 101,\n     \"name\": \"Dairy\",\n     \"products\": []\n  }\n]\n```\n在这里，我们看到配置数据库上下文时添加到数据库的数据。此输出确认我们的代码正在运行。\n您使用很少的代码行创建了GET API端点，并且由于当前API项目的架构模式，您的代码结构确实很容易更改。\n\n现在，该向您展示在由于业务需要而不得不对其进行更改时，更改此代码有多么容易。\n\n# **步骤8-创建类别资源**\n如果您还记得API端点的规范，您会注意到我们的实际JSON响应还有一个额外的属性：**products数组**。看一下所需响应的示例：\n\n```\n{\n  [\n    { \"id\": 1, \"name\": \"Fruits and Vegetables\" },\n    { \"id\": 2, \"name\": \"Breads\" },\n    … // Other categories\n  ]\n}\n```\n产品数组出现在我们当前的JSON响应中，因为我们的Category模型具有Products，EF Core需要的属性，以正确映射给定类别的产品。\n我们不希望在响应中使用此属性，但是不能更改模型类以排除此属性。当我们尝试管理类别数据时，这将导致EF Core引发错误，并且也将破坏我们的领域模型设计，因为没有产品的产品类别没有意义。\n\n要返回仅包含超级市场类别的标识符和名称的JSON数据，我们必须创建一个**资源类**。\n\n[资源类](https://restful-api-design.readthedocs.io/en/latest/resources.html)是一种包含将客户端应用程序和API端点之间进行交换的类型，通常以JSON数据的形式出现，以表示一些特定信息的类。\n\n来自API端点的所有响应都**必须**返回资源。\n\n将真实模型表示形式作为响应返回是一种不好的做法，因为它可能包含客户端应用程序不需要或没有其权限的信息（例如，用户模型可以返回用户密码的信息） ，这将是一个很大的安全问题）。\n\n我们需要一种资源来仅代表我们的类别，而没有产品。\n\n现在您知道什么是资源，让我们实现它。首先，在命令行中按**Ctrl + C**停止正在运行的应用程序。在应用程序的根文件夹中，创建一个名为Resources的新文件夹。在其中添加一个名为的新类CategoryResource。\n\n```\nnamespace Supermarket.API.Resources\n\t{\n\t    public class CategoryResource\n\t    {\n\t        public int Id { get; set; }\n\t        public string Name { get; set; }\n\t    }\n\t}\n```\n我们必须将类别服务提供的类别模型集合映射到类别资源集合。\n我们将使用一个名为[AutoMapper](https://automapper.org/)的库来处理对象之间的映射。AutoMapper是.NET世界中非常流行的库，并且在许多商业和开源项目中使用。\n\n在命令行中输入以下命令，以将AutoMapper添加到我们的应用程序中：\n\n```\ndotnet add package AutoMapper\n\ndotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection\n```\n要使用AutoMapper，我们必须做两件事：\n* 注册它以进行依赖注入；\n* 创建一个类，该类将告诉AutoMapper如何处理类映射。\n\n首先，打开Startup课程。在该ConfigureServices方法的最后一行之后，添加以下代码：\n\n```\nservices.AddAutoMapper();\n```\n此行处理AutoMapper的所有必需配置，例如注册它以进行依赖项注入以及在启动过程中扫描应用程序以配置映射配置文件。\n现在，在根目录中，添加一个名为的新文件夹Mapping，然后添加一个名为的类ModelToResourceProfile。通过以下方式更改代码：\n\n```\nusing AutoMapper;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Resources;\n\t\n\n\tnamespace Supermarket.API.Mapping\n\t{\n\t    public class ModelToResourceProfile : Profile\n\t    {\n\t        public ModelToResourceProfile()\n\t        {\n\t            CreateMap<Category, CategoryResource>();\n\t        }\n\t    }\n\t}\n```\n该类继承Profile了AutoMapper用于检查我们的映射如何工作的类类型。在构造函数上，我们在Category模型类和CategoryResource类之间创建一个映射。由于类的属性具有相同的名称和类型，因此我们不必为其使用任何特殊的配置。\n最后一步包括更改类别控制器以使用AutoMapper处理我们的对象映射。\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing AutoMapper;\n\tusing Microsoft.AspNetCore.Mvc;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Services;\n\tusing Supermarket.API.Resources;\n\t\n\n\tnamespace Supermarket.API.Controllers\n\t{\n\t    [Route(\"/api/[controller]\")]\n\t    public class CategoriesController : Controller\n\t    {\n\t        private readonly ICategoryService _categoryService;\n\t        private readonly IMapper _mapper;\n\t\n\n\t        public CategoriesController(ICategoryService categoryService, IMapper mapper)\n\t        {\n\t            _categoryService = categoryService;\n\t            _mapper = mapper;\n\t        }\n\t\n\n\t        [HttpGet]\n\t        public async Task<IEnumerable<CategoryResource>> GetAllAsync()\n\t        {\n\t            var categories = await _categoryService.ListAsync();\n\t            var resources = _mapper.Map<IEnumerable<Category>, IEnumerable<CategoryResource>>(categories);\n\t            \n\t            return resources;\n\t        }\n\t    }\n\t}\n```\n我更改了构造函数以接收IMapper实现的实例。您可以使用这些接口方法来使用AutoMapper映射方法。\n我还更改了GetAllAsync使用Map方法将类别枚举映射到资源枚举的方法。此方法接收我们要映射的类或集合的实例，并通过[通用类型定义](https://www.geeksforgeeks.org/c-generics-introduction/)定义必须映射到什么类型的类或集合。\n\n注意，我们只需将新的依赖项（IMapper）注入构造函数，就可以轻松地更改实现，而不必修改服务类或仓储。\n\n依赖注入使您的应用程序可维护且易于更改，因为您不必中断所有代码实现即可添加或删除功能。\n\n您可能意识到，不仅控制器类，而且所有接收依赖项的类（包括依赖项本身）都会根据绑定配置自动解析为接收正确的类。\n\n依赖注入如此的Amazing，不是吗？\n\n![图片](https://uploader.shimo.im/f/wGoOlHek0agFA3kQ.png!thumbnail)\n\n现在，使用dotnet run命令再次启动API，然后转到[http](http://localhost:5000/api/categories)[:](http://localhost:5000/api/categories)[//localhost](http://localhost:5000/api/categories)[:](http://localhost:5000/api/categories)[5000/api/categories](http://localhost:5000/api/categories)以查看新的JSON响应。\n\n![图片](https://uploader.shimo.im/f/xb8S1G8qcWQW3MSN.png!thumbnail)\n\n这是您应该看到的响应数据\n\n我们已经有了GET端点。现在，让我们为POST（**创建**）类别创建一个新端点。\n\n# **第9步-创建新类别**\n在处理资源创建时，我们必须关心很多事情，例如：\n\n* 数据验证和数据完整性；\n* 授权创建资源；\n* 错误处理；\n* 正在记录。\n\n在本教程中，我不会显示如何处理身份验证和授权，但是您可以阅读[JSON Web令牌身份验证](https://medium.com/@evandro.ggomes/json-web-token-authentication-with-asp-net-core-2-0-b074b0cfc870)教程，了解如何轻松实现这些功能。\n\n另外，有一个非常流行的框架称为**ASP.NET Identity**，该框架提供了有关安全性和用户注册的内置解决方案，您可以在应用程序中使用它们。它包括与EF Core配合使用的提供程序，例如IdentityDbContext可以使用的内置程序。您可以[在此处了解更多信息](https://docs.microsoft.com/en-us/aspnet/identity/overview/getting-started/introduction-to-aspnet-identity)。\n\n让我们编写一个HTTP POST端点，该端点将涵盖其他场景（日志记录除外，它可以根据不同的范围和工具进行更改）。\n\n在创建新端点之前，我们需要一个新资源。此资源会将客户端应用程序发送到此端点的数据（在本例中为类别名称）映射到我们应用程序的类。\n\n由于我们正在创建一个新类别，因此我们还没有ID，这意味着我们需要一种资源来表示仅包含其名称的类别。\n\n在Resources文件夹中，添加一个新类SaveCategoryResource：\n\n```\nusing System.ComponentModel.DataAnnotations;\n\t\n\n\tnamespace Supermarket.API.Resources\n\t{\n\t    public class SaveCategoryResource\n\t    {\n\t        [Required]\n\t        [MaxLength(30)]\n\t        public string Name { get; set; }\n\t    }\n\t}\n```\n注意Name属性上的Required和MaxLength特性。这些属性称为[数据注释](https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations?view=netframework-4.7.2)。ASP.NET Core管道使用此元数据来验证请求和响应。顾名思义，类别名称是必填项，最大长度为30个字符。\n现在，让我们定义新API端点的形状。将以下代码添加到类别控制器：\n\n```\n[HttpPost]\n\tpublic async Task<IActionResult> PostAsync([FromBody] SaveCategoryResource resource)\n\t{\n\t}\n```\n我们使用HttpPost特性告诉框架这是一个HTTP POST端点。\n注意此方法的响应类型Task<IActionResult>。控制器类中存在的方法称为**动作**，它们具有此签名，因为在应用程序执行动作之后，我们可以返回一个以上的可能结果。\n\n在这种情况下，如果类别名称无效或出现问题，我们必须返回**400代码（错误请求）**响应，该响应通常包含一条错误消息，客户端应用程序可以使用该错误消息来解决该问题，或者我们可以如果一切正常，则对数据进行**200次响应（成功）**。\n\n可以将多种类型的操作类型用作响应，但是通常，我们可以使用此接口，并且ASP.NET Core将为此使用默认类。\n\n该FromBody属性告诉ASP.NET Core将请求正文数据解析为我们的新资源类。这意味着当包含类别名称的JSON发送到我们的应用程序时，框架将自动将其解析为我们的新类。\n\n现在，让我们实现路由逻辑。我们必须遵循一些步骤才能成功创建新类别：\n\n* 首先，我们必须验证传入的请求。如果请求无效，我们必须返回包含错误消息的错误请求响应；\n* 然后，如果请求有效，则必须使用AutoMapper将新资源映射到类别模型类。\n* 现在，我们需要调用我们的服务，告诉它保存我们的新类别。如果执行保存逻辑没有问题，它将返回一个包含我们新类别数据的响应。如果没有，它应该给我们一个指示，表明该过程失败了，并可能出现错误消息。\n* 最后，如果有错误，我们将返回错误的请求。如果没有，我们将新的类别模型映射到类别资源，并向客户端返回包含新类别数据的成功响应。\n\n这似乎很复杂，但是使用为API构建的服务架构来实现此逻辑确实很容易。\n\n让我们开始验证传入的请求。\n\n# **步骤10-使用模型状态验证请求主体**\nASP.NET Core控制器具有名为ModelState的属性。在执行我们的操作**之前，**该属性在请求执行期间填充。它是ModelStateDictionary的实例，该类包含诸如请求是否有效以及潜在的验证错误消息之类的信息。\n\n如下更改端点代码：\n\n```\n[HttpPost]\n\tpublic async Task<IActionResult> PostAsync([FromBody] SaveCategoryResource resource)\n\t{\n\t\tif (!ModelState.IsValid)\n\t\t\treturn BadRequest(ModelState.GetErrorMessages());\n\t}\n```\n这段代码检查模型状态（在这种情况下为请求正文中发送的数据）是否无效，并检查我们的数据注释。如果不是，则API返回错误的请求（状态代码400），以及我们的注释元数据提供的默认错误消息。\n该ModelState.GetErrorMessages()方法尚未实现。这是一种[扩展方法](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)（一种扩展现有类或接口功能的方法），我将实现该方法将验证错误转换为简单的字符串以返回给客户端。\n\nExtensions在我们的API的根目录中添加一个新文件夹，然后添加一个新类ModelStateExtensions。\n\n```\nusing System.Collections.Generic;\n\tusing System.Linq;\n\tusing Microsoft.AspNetCore.Mvc.ModelBinding;\n\t\n\n\tnamespace Supermarket.API.Extensions\n\t{\n\t    public static class ModelStateExtensions\n\t    {\n\t        public static List<string> GetErrorMessages(this ModelStateDictionary dictionary)\n\t        {\n\t            return dictionary.SelectMany(m => m.Value.Errors)\n\t                             .Select(m => m.ErrorMessage)\n\t                             .ToList();\n\t        }\n\t    }\n\t}\n```\n所有扩展方法以及声明它们的类都应该是**静态的**。** **这意味着它们不处理特定的实例数据，并且在应用程序启动时仅被加载一次。\nthis参数声明前面的关键字告诉C＃编译器将其视为扩展方法。结果是我们可以像此类的常规方法一样调用它，因为我们在要使用扩展的地方包含的特定的using代码。\n\n该扩展使用[LINQ查询](https://www.tutorialsteacher.com/linq/what-is-linq)，这是.NET的非常有用的功能，它使我们能够使用链式语法来查询和转换数据。此处的表达式将验证错误方法转换为包含错误消息的字符串列表。\n\nSupermarket.API.Extensions在进行下一步之前，将名称空间导入Categories控制器。\n\n```\nusing Supermarket.API.Extensions;\n```\n让我们通过将新资源映射到类别模型类来继续实现端点逻辑。\n# **步骤11-映射新资源**\n我们已经定义了映射配置文件，可以将模型转换为资源。现在，我们需要一个与之相反的新配置项。\n\nResourceToModelProfile在Mapping文件夹中添加一个新类：\n\n```\nusing AutoMapper;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Resources;\n\t\n\n\tnamespace Supermarket.API.Mapping\n\t{\n\t    public class ResourceToModelProfile : Profile\n\t    {\n\t        public ResourceToModelProfile()\n\t        {\n\t            CreateMap<SaveCategoryResource, Category>();\n\t        }\n\t    }\n\t}\n```\n这里没有新内容。由于依赖注入的魔力，AutoMapper将在应用程序启动时自动注册此配置文件，而我们无需更改任何其他位置即可使用它。\n现在，我们可以将新资源映射到相应的模型类：\n\n```\n[HttpPost]\n\tpublic async Task<IActionResult> PostAsync([FromBody] SaveCategoryResource resource)\n\t{\n\t\tif (!ModelState.IsValid)\n\t\t\treturn BadRequest(ModelState.GetErrorMessages());\n\t\n\n\t\tvar category = _mapper.Map<SaveCategoryResource, Category>(resource);\n\t}\n```\n# **第12步-应用请求-响应模式来处理保存逻辑**\n现在我们必须实现最有趣的逻辑：保存一个新类别。我们希望我们的服务能够做到。\n\n由于连接到数据库时出现问题，或者由于任何内部业务规则使我们的数据无效，因此保存逻辑可能会失败。\n\n如果出现问题，我们不能简单地抛出一个错误，因为它可能会停止API，并且客户端应用程序也不知道如何处理该问题。另外，我们可能会有某种日志记录机制来记录错误。\n\n保存方法的约定（即方法的签名和响应类型）需要指示我们是否正确执行了该过程。如果处理正常，我们将接收类别数据。如果没有，我们至少必须收到一条错误消息，告诉您该过程失败的原因。\n\n我们可以通过应用**request-response模式**来实现此功能。这种企业设计模式将我们的请求和响应参数封装到类中，以封装我们的服务将用于处理某些任务并将信息返回给正在使用该服务的类的信息。\n\n这种模式为我们提供了一些优势，例如：\n\n* 如果我们需要更改服务以接收更多参数，则不必破坏其签名；\n* 我们可以为我们的请求和/或响应定义标准合同；\n* 我们可以在不停止应用程序流程的情况下处理业务逻辑和潜在的失败，并且我们不需要使用大量的try-catch块。\n\n让我们为处理数据更改的服务方法创建一个标准响应类型。对于这种类型的每个请求，我们都想知道该请求是否被正确执行。如果失败，我们要向客户端返回错误消息。\n\n在Domain文件夹的内部Services，添加一个名为的新目录Communication。在此处添加一个名为的新类BaseResponse。\n\n```\nnamespace Supermarket.API.Domain.Services.Communication\n\t{\n\t    public abstract class BaseResponse\n\t    {\n\t        public bool Success { get; protected set; }\n\t        public string Message { get; protected set; }\n\t\n\n\t        public BaseResponse(bool success, string message)\n\t        {\n\t            Success = success;\n\t            Message = message;\n\t        }\n\t    }\n\t}\n```\n那是我们的响应类型将继承的抽象类。\n抽象定义了一个Success属性和一个Message属性，该属性将告知请求是否已成功完成，如果失败，该属性将显示错误消息。\n\n请注意，这些属性是必需的，只有继承的类才能设置此数据，因为子类必须通过构造函数传递此信息。\n\n>**提示：**为所有内容定义基类不是一个好习惯，因为[基类会耦合您的代码](https://en.wikipedia.org/wiki/Fragile_base_class)并阻止您轻松对其进行修改。优先使用[组合而不是继承](https://medium.com/humans-create-software/composition-over-inheritance-cb6f88070205)。\n>>在此API的范围内，使用基类并不是真正的问题，因为我们的服务不会增长太多。如果您意识到服务或应用程序会经常增长和更改，请避免使用基类。\n\n现在，在同一文件夹中，添加一个名为的新类SaveCategoryResponse。\n\n```\nusing Supermarket.API.Domain.Models;\n\t\n\n\tnamespace Supermarket.API.Domain.Services.Communication\n\t{\n\t    public class SaveCategoryResponse : BaseResponse\n\t    {\n\t        public Category Category { get; private set; }\n\t\n\n\t        private SaveCategoryResponse(bool success, string message, Category category) : base(success, message)\n\t        {\n\t            Category = category;\n\t        }\n\t\n\n\t        /// <summary>\n\t        /// Creates a success response.\n\t        /// </summary>\n\t        /// <param name=\"category\">Saved category.</param>\n\t        /// <returns>Response.</returns>\n\t        public SaveCategoryResponse(Category category) : this(true, string.Empty, category)\n\t        { }\n\t\n\n\t        /// <summary>\n\t        /// Creates am error response.\n\t        /// </summary>\n\t        /// <param name=\"message\">Error message.</param>\n\t        /// <returns>Response.</returns>\n\t        public SaveCategoryResponse(string message) : this(false, message, null)\n\t        { }\n\t    }\n\t}\n```\n响应类型还设置了一个Category属性，如果请求成功完成，该属性将包含我们的类别数据。\n请注意，我为此类定义了三种不同的构造函数：\n\n* 一个私有的，它将把成功和消息参数传递给基类，并设置Category属性。\n* 仅接收类别作为参数的构造函数。这将创建一个成功的响应，调用私有构造函数来设置各自的属性；\n* 第三个构造函数仅指定消息。这将用于创建故障响应。\n\n因为C＃支持多个构造函数，所以我们仅通过使用不同的构造函数就简化了响应的创建过程，而无需定义其他方法来处理此问题。\n\n现在，我们可以更改服务界面以添加新的保存方法合同。\n\n更改ICategoryService接口，如下所示：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Services.Communication;\n\t\n\n\tnamespace Supermarket.API.Domain.Services\n\t{\n\t    public interface ICategoryService\n\t    {\n\t         Task<IEnumerable<Category>> ListAsync();\n\t         Task<SaveCategoryResponse> SaveAsync(Category category);\n\t    }\n\t}\n```\n我们只需将类别传递给此方法，它将处理保存模型数据，编排仓储和其他必要服务所需的所有逻辑。\n请注意，由于我们不需要任何其他参数来执行此任务，因此我不在此处创建特定的请求类。[计算机编程中](https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle)有一个名为[KISS](https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle)的[概念](https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle) —Keep It Simple，Stupid的简称。基本上，它说您应该使您的应用程序尽可能简单。\n\n设计应用程序时请记住这一点：**仅**应用**解决问题所需的内容**。**不要过度设计您的应用程序。**\n\n现在我们可以完成端点逻辑：\n\n```\n[HttpPost]\n\tpublic async Task<IActionResult> PostAsync([FromBody] SaveCategoryResource resource)\n\t{\n\t\tif (!ModelState.IsValid)\n\t\t\treturn BadRequest(ModelState.GetErrorMessages());\n\t\n\n\t\tvar category = _mapper.Map<SaveCategoryResource, Category>(resource);\n\t\tvar result = await _categoryService.SaveAsync(category);\n\t\n\n\t\tif (!result.Success)\n\t\t\treturn BadRequest(result.Message);\n\t\n\n\t\tvar categoryResource = _mapper.Map<Category, CategoryResource>(result.Category);\n\t\treturn Ok(categoryResource);\n\t}\n```\n在验证请求数据并将资源映射到我们的模型之后，我们将其传递给我们的服务以保留数据。\n如果失败，则API返回错误的请求。如果没有，API会将新类别（现在包括诸如new的数据Id）映射到我们先前创建的类别CategoryResource，并将其发送给客户端。\n\n现在，让我们为服务实现真正的逻辑。\n\n**第13步—数据库逻辑和工作单元模式**\n\n由于我们要将数据持久化到数据库中，因此我们需要在仓储中使用一种新方法。\n\n向ICategoryRepository接口添加AddAsync新方法：\n\n```\npublic interface ICategoryRepository\n\t{\n\t\t Task<IEnumerable<Category>> ListAsync();\n\t\t Task AddAsync(Category category);\n\t}\n```\n现在，让我们在真正的仓储类中实现此方法：\n```\npublic class CategoryRepository : BaseRepository, ICategoryRepository\n\t{\n\t\tpublic CategoryRepository(AppDbContext context) : base(context)\n\t\t{ }\n\t\n\n\t\tpublic async Task<IEnumerable<Category>> ListAsync()\n\t\t{\n\t\t\treturn await _context.Categories.ToListAsync();\n\t\t}\n\t\n\n\t\tpublic async Task AddAsync(Category category)\n\t\t{\n\t\t\tawait _context.Categories.AddAsync(category);\n\t\t}\n\t}\n```\n在这里，我们只是在集合中添加一个新类别。\n当我们向中添加类时DBSet<>，EF Core将开始跟踪模型发生的所有更改，并在当前状态下使用此数据生成将插入，更新或删除模型的查询。\n\n当前的实现只是将模型添加到我们的集合中，但是**我们的数据仍然不会保存**。\n\n在上下文类中提供了SaveChanges的方法，我们必须调用该方法才能真正将查询执行到数据库中。我之所以没有在这里调用它，是因为[仓储不应该持久化数据](https://programmingwithmosh.com/entity-framework/common-mistakes-with-the-repository-pattern/)，它只是一种内存集合对象。\n\n即使在经验丰富的.NET开发人员之间，该主题也引起很大争议，但是让我向您解释为什么您不应该在仓储类中调用SaveChanges方法。\n\n我们可以从概念上将仓储像.NET框架中存在的任何其他集合一样。在.NET（和许多其他编程语言，例如Javascript和Java）中处理集合时，通常可以：\n\n* 向其中添加新项（例如，当您将数据推送到列表，数组和字典时）；\n* 查找或过滤项目；\n* 从集合中删除一个项目；\n* 替换给定的项目，或更新它。\n\n想一想现实世界中的清单。想象一下，您正在编写一份购物清单以在超市购买东西（*巧合，不是吗？*）。\n\n在列表中，写下您需要购买的所有水果。您可以将水果添加到此列表中，如果放弃购买就删除水果，也可以替换水果的名称。但是您无法**将**水果**保存**到列表中。用简单的英语说这样的话是没有意义的。\n\n>**提示：**在使用面向对象的编程语言设计类和接口时，请尝试使用自然语言来检查您所做的工作是否正确。\n>>例如，说人实现了person的接口是有道理的，但是说一个人实现了一个帐户却没有道理。\n\n如果您要“保存”水果清单（在这种情况下，要购买所有水果），请付款，然后超市会处理库存数据以检查他们是否必须从供应商处购买更多水果。\n\n编程时可以应用相同的逻辑。仓储不应保存，更新或删除数据。相反，他们应该将其委托给其他类来处理此逻辑。\n\n将数据直接保存到仓储中时，还有另一个问题：**您不能使用transaction**。\n\n想象一下，我们的应用程序具有一种日志记录机制，该机制存储一些用户名，并且每次对API数据进行更改时都会执行操作。\n\n现在想象一下，由于某种原因，您调用了一个更新用户名的服务（这是不常见的情况，但让我们考虑一下）。\n\n您同意要更改虚拟用户表中的用户名，首先必须更新所有日志以正确告诉谁执行了该操作，对吗？\n\n现在想象我们已经为用户和不同仓储中的日志实现了update方法，它们都调用了SaveChanges。如果这些方法之一在更新过程中失败，会发生什么？最终会导致数据不一致。\n\n只有在一切完成之后，我们才应该将更改保存到数据库中。为此，我们必须使用[transaction](https://en.wikipedia.org/wiki/Database_transaction)，这基本上是大多数数据库实现的功能，只有在完成复杂的操作后才能保存数据。\n\n*“-好的，所以如果我们不能在这里保存东西，我们应该在哪里做？”*\n\n处理此问题的常见模式是[工作单元模式](https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)。此模式包含一个类，该类将我们的AppDbContext实例作为依赖项接收，并公开用于开始，完成或中止事务的方法。\n\n在这里，我们将使用工作单元的简单实现来解决我们的问题。\n\nRepositories在Domain层的仓储文件夹Repositories内添加一个新接口IUnitOfWork：\n\n```\nusing System.Threading.Tasks;\n\t\n\n\tnamespace Supermarket.API.Domain.Repositories\n\t{\n\t    public interface IUnitOfWork\n\t    {\n\t         Task CompleteAsync();\n\t    }\n\t}\n```\n如您所见，它仅公开一种将异步完成数据管理操作的方法。\n现在让我们添加实际的实现。\n\n在Persistence层RepositoriesRepositories文件夹中的添加一个名为的UnitOfWork的新类：\n\n```\nusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Repositories;\n\tusing Supermarket.API.Persistence.Contexts;\n\t\n\n\tnamespace Supermarket.API.Persistence.Repositories\n\t{\n\t    public class UnitOfWork : IUnitOfWork\n\t    {\n\t        private readonly AppDbContext _context;\n\t\n\n\t        public UnitOfWork(AppDbContext context)\n\t        {\n\t            _context = context;     \n\t        }\n\t\n\n\t        public async Task CompleteAsync()\n\t        {\n\t            await _context.SaveChangesAsync();\n\t        }\n\t    }\n\t}\n```\n这是一个简单，干净的实现，仅在使用仓储修改完所有更改后，才将所有更改保存到数据库中。\n如果研究工作单元模式的实现，则会发现实现回滚操作的更复杂的模式。\n\n由于**EF Core已经在后台实现了仓储模式和工作单元**，因此我们不必在意回滚方法。\n\n*“ - 什么？那么为什么我们必须创建所有这些接口和类？”*\n\n将持久性逻辑与业务规则分开在代码可重用性和维护方面具有许多优势。如果直接使用EF Core，我们最终将拥有更复杂的类，这些类将很难更改。\n\n想象一下，将来您决定将ORM框架更改为其他框架，例如[Dapper](https://www.c-sharpcorner.com/article/crud-operation-in-asp-net-core-2-0-using-dapper-orm/)，或者由于性能而必须实施纯SQL查询。如果将查询逻辑与服务耦合在一起，将很难更改该逻辑，因为您必须在许多类中进行此操作。\n\n使用仓储模式，您可以简单地实现一个新的仓储类并使用依赖注入将其绑定。\n\n因此，基本上，如果您直接在服务中使用EF Core，并且必须进行一些更改，那么您将获得：\n\n就像我说的那样，EF Core在后台实现了工作单元和仓储模式。我们可以将DbSet<>属性视为仓储。而且，SaveChanges仅在所有数据库操作成功的情况下才保留数据。\n\n现在，您知道什么是工作单元以及为什么将其与仓储一起使用，让我们实现真实服务的逻辑。\n\n```\npublic class CategoryService : ICategoryService\n\t{\n\t\tprivate readonly ICategoryRepository _categoryRepository;\n\t\tprivate readonly IUnitOfWork _unitOfWork;\n\t\n\n\t\tpublic CategoryService(ICategoryRepository categoryRepository, IUnitOfWork unitOfWork)\n\t\t{\n\t\t\t_categoryRepository = categoryRepository;\n\t\t\t_unitOfWork = unitOfWork;\n\t\t}\n\t\n\n\t\tpublic async Task<IEnumerable<Category>> ListAsync()\n\t\t{\n\t\t\treturn await _categoryRepository.ListAsync();\n\t\t}\n\t\n\n\t\tpublic async Task<SaveCategoryResponse> SaveAsync(Category category)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tawait _categoryRepository.AddAsync(category);\n\t\t\t\tawait _unitOfWork.CompleteAsync();\n\t\t\t\t\n\t\t\t\treturn new SaveCategoryResponse(category);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t// Do some logging stuff\n\t\t\t\treturn new SaveCategoryResponse($\"An error occurred when saving the category: {ex.Message}\");\n\t\t\t}\n\t\t}\n\t}\n```\n多亏了我们的解耦架构，我们可以简单地将实例UnitOfWork作为此类的依赖传递。\n我们的业务逻辑非常简单。\n\n首先，我们尝试将新类别添加到数据库中，然后API尝试保存新类别，将所有内容包装在try-catch块中。\n\n如果失败，则API会调用一些虚构的日志记录服务，并返回指示失败的响应。\n\n如果该过程顺利完成，则应用程序将返回成功响应，并发送我们的类别数据。简单吧？\n\n>**提示：**在现实世界的应用程序中，您不应将所有内容包装在通用的try-catch块中，而应分别处理所有可能的错误。\n>>简单地添加一个try-catch块并不能解决大多数可能的失败情况。请确保正确实现错误处理。\n\n测试我们的API之前的最后一步是将工作单元接口绑定到其各自的类。\n\n将此新行添加到类的ConfigureServices方法中Startup：\n\n```\nservices.AddScoped<IUnitOfWork, UnitOfWork>();\n```\n现在让我们测试一下！\n**第14步-使用Postman测试我们的POST端点**\n\n重新启动我们的应用程序dotnet run。\n\n我们无法使用浏览器测试POST端点。让我们使用**Postman**测试我们的端点。这是测试RESTful API的非常有用的工具。\n\n打开**Postman**，然后关闭介绍性消息。您会看到这样的屏幕：\n\n![图片](https://uploader.shimo.im/f/k9uqO0tzHP8sXyGu.png!thumbnail)\n\n屏幕显示测试端点的选项\n\nGET默认情况下，将所选内容更改为选择框POST。\n\n在Enter request URL字段中输入API地址。\n\n我们必须提供请求正文数据以发送到我们的API。单击Body菜单项，然后将其下方显示的选项更改为raw。\n\nPostman将在右侧显示一个Text选项，将其更改为JSON (application/json)并粘贴以下JSON数据：\n\n```\n{\n  \"name\": \"\"\n}\n```\n![图片](https://uploader.shimo.im/f/aMktVnVAavwvF3Q3.png!thumbnail)发送请求前的屏幕\n\n如您所见，我们将向我们的新端点发送一个空的名称字符串。\n\n点击Send按钮。您将收到如下输出：\n\n![图片](https://uploader.shimo.im/f/5yuSjCfYKD0ELqiA.png!thumbnail)\n\n如您所见，我们的验证逻辑有效！\n\n您还记得我们为端点创建的验证逻辑吗？此输出是它起作用的证明！\n\n还要注意右侧显示的400状态代码。该BadRequest结果自动将此状态码的响应。\n\n现在，让我们将JSON数据更改为有效数据，以查看新的响应：\n\n![图片](https://uploader.shimo.im/f/zDpJNG3Yl8Q0XimL.png!thumbnail)\n\n最后，我们期望得到的结果\n\nAPI正确创建了我们的新资源。\n\n到目前为止，我们的API可以列出和创建类别。您学到了很多有关C＃语言，ASP.NET Core框架以及构造API的通用设计方法的知识。\n\n让我们继续我们的类别API，创建用于更新类别的端点。\n\n从现在开始，由于我向您解释了大多数概念，因此我将加快解释速度，并专注于新主题，以免浪费您的时间。 Let’s go!\n\n# **第15步-更新类别**\n要更新类别，我们需要一个HTTP PUT端点。\n\n我们必须编写的逻辑与POST逻辑非常相似：\n\n* 首先，我们必须使用来验证传入的请求ModelState。\n* 如果请求有效，则API应使用AutoMapper将传入资源映射到模型类。\n* 然后，我们需要调用我们的服务，告诉它更新类别，提供相应的类别Id和更新的数据；\n* 如果Id数据库中没有给定的类别，我们将返回错误的请求。我们可以使用NotFound结果来代替，但是对于这个范围而言，这并不重要，因为我们向客户端应用程序提供了错误消息。\n* 如果正确执行了保存逻辑，则服务必须返回包含更新的类别数据的响应。如果不是，它应该给我们指示该过程失败，并显示一条消息指示原因；\n* 最后，如果有错误，则API返回错误的请求。如果不是，它将更新的类别模型映射到类别资源，并将成功响应返回给客户端应用程序。\n\n让我们将新PutAsync方法添加到控制器类中：\n\n```\n[HttpPut(\"{id}\")]\n\tpublic async Task<IActionResult> PutAsync(int id, [FromBody] SaveCategoryResource resource)\n\t{\n\t\tif (!ModelState.IsValid)\n\t\t\treturn BadRequest(ModelState.GetErrorMessages());\n\t\n\n\t\tvar category = _mapper.Map<SaveCategoryResource, Category>(resource);\n\t\tvar result = await _categoryService.UpdateAsync(id, category);\n\t\n\n\t\tif (!result.Success)\n\t\t\treturn BadRequest(result.Message);\n\t\n\n\t\tvar categoryResource = _mapper.Map<Category, CategoryResource>(result.Category);\n\t\treturn Ok(categoryResource);\n\t}\n```\n如果将其与POST逻辑进行比较，您会注意到这里只有一个区别：HttPut属性指定给定路由应接收的参数。\n我们将调用此端点，将类别指定Id 为最后一个URL片段，例如/api/categories/1。ASP.NET Core管道将此片段解析为相同名称的参数。\n\n现在我们必须UpdateAsync在ICategoryService接口中定义方法签名：\n\n```\npublic interface ICategoryService\n\t{\n\t\tTask<IEnumerable<Category>> ListAsync();\n\t\tTask<SaveCategoryResponse> SaveAsync(Category category);\n\t\tTask<SaveCategoryResponse> UpdateAsync(int id, Category category);\n\t}\n```\n现在让我们转向真正的逻辑。\n# **第16步-更新逻辑**\n首先，要更新类别，我们需要从数据库中返回当前数据（如果存在）。我们还需要将其更新到我们的中DBSet<>。\n\n让我们在ICategoryService界面中添加两个新的方法约定：\n\n```\npublic interface ICategoryRepository\n\t{\n\t\tTask<IEnumerable<Category>> ListAsync();\n\t\tTask AddAsync(Category category);\n\t\tTask<Category> FindByIdAsync(int id);\n\t\tvoid Update(Category category);\n\t}\n```\n我们已经定义了FindByIdAsync方法，该方法将从数据库中异步返回一个类别，以及该Update方法。请注意，该Update方法不是异步的，因为EF Core API不需要异步方法来更新模型。\n现在，让我们在CategoryRepository类中实现真正的逻辑：\n\n```\npublic async Task<Category> FindByIdAsync(int id)\n\t{\n\t\treturn await _context.Categories.FindAsync(id);\n\t}\n\t\n\n\tpublic void Update(Category category)\n\t{\n\t\t_context.Categories.Update(category);\n\t}\n```\n最后，我们可以对服务逻辑进行编码：\n```\npublic async Task<SaveCategoryResponse> UpdateAsync(int id, Category category)\n\t{\n\t\tvar existingCategory = await _categoryRepository.FindByIdAsync(id);\n\t\n\n\t\tif (existingCategory == null)\n\t\t\treturn new SaveCategoryResponse(\"Category not found.\");\n\t\n\n\t\texistingCategory.Name = category.Name;\n\t\n\n\t\ttry\n\t\t{\n\t\t\t_categoryRepository.Update(existingCategory);\n\t\t\tawait _unitOfWork.CompleteAsync();\n\t\n\n\t\t\treturn new SaveCategoryResponse(existingCategory);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\t// Do some logging stuff\n\t\t\treturn new SaveCategoryResponse($\"An error occurred when updating the category: {ex.Message}\");\n\t\t}\n\t}\n```\nAPI尝试从数据库中获取类别。如果结果为null，我们将返回一个响应，告知该类别不存在。如果类别存在，我们需要设置其新名称。\n然后，API会尝试保存更改，例如创建新类别时。如果该过程完成，则该服务将返回成功响应。如果不是，则执行日志记录逻辑，并且端点接收包含错误消息的响应。\n\n现在让我们对其进行测试。首先，让我们添加一个新类别Id以使用有效类别。我们可以使用播种到数据库中的类别的标识符，但是我想通过这种方式向您展示我们的API将更新正确的资源。\n\n再次运行该应用程序，然后使用Postman将新类别发布到数据库中：\n\n![图片](https://uploader.shimo.im/f/fxIzjvpz7Y0kf8XP.png!thumbnail)\n\n添加新类别以供日后更新\n\n使用一个可用的数据Id，将POST 选项更改PUT为选择框，然后在URL的末尾添加ID值。将name属性更改为其他名称，然后发送请求以检查结果：\n\n![图片](https://uploader.shimo.im/f/VMXmxLVsZNsqqXSK.png!thumbnail)\n\n类别数据已成功更新\n\n您可以将GET请求发送到API端点，以确保您正确编辑了类别名称：\n\n![图片](https://uploader.shimo.im/f/G5ipYxpQk5gJSVBI.png!thumbnail)\n\n那是现在GET请求的结果\n\n我们必须对类别执行的最后一项操作是排除类别。让我们创建一个HTTP Delete端点。\n\n# **第17步-删除类别**\n删除类别的逻辑确实很容易实现，因为我们所需的大多数方法都是先前构建的。\n\n这些是我们工作路线的必要步骤：\n\n* API需要调用我们的服务，告诉它删除我们的类别，并提供相应的Id;\n* 如果数据库中没有具有给定ID的类别，则该服务应返回一条消息指出该类别；\n* 如果执行删除逻辑没有问题，则服务应返回包含我们已删除类别数据的响应。如果没有，它应该给我们一个指示，表明该过程失败了，并可能出现错误消息。\n* 最后，如果有错误，则API返回错误的请求。如果不是，则API会将更新的类别映射到资源，并向客户端返回成功响应。\n\n让我们开始添加新的端点逻辑：\n\n```\n[HttpDelete(\"{id}\")]\n\tpublic async Task<IActionResult> DeleteAsync(int id)\n\t{\n\t\tvar result = await _categoryService.DeleteAsync(id);\n\t\n\n\t\tif (!result.Success)\n\t\t\treturn BadRequest(result.Message);\n\t\n\n\t\tvar categoryResource = _mapper.Map<Category, CategoryResource>(result.Category);\n\t\treturn Ok(categoryResource);\n\t}\n```\n该HttpDelete属性还定义了一个id 模板。\n在将DeleteAsync签名添加到我们的ICategoryService接口之前，我们需要做一些小的重构。\n\n新的服务方法必须返回包含类别数据的响应，就像对PostAsyncand UpdateAsync方法所做的一样。我们可以SaveCategoryResponse为此目的重用，但在这种情况下我们不会保存数据。\n\n为了避免创建具有相同形状的新类来满足此要求，我们可以将我们重命名SaveCategoryResponse为CategoryResponse。\n\n如果您使用的是Visual Studio Code，则可以打开SaveCategoryResponse类，将鼠标光标放在类名上方，然后使用选项Change All Occurrences*** ***来重命名该类：\n\n![图片](https://uploader.shimo.im/f/9F3zYANcrMUdFlMe.png!thumbnail)\n\n确保也重命名文件名。\n\n让我们将DeleteAsync方法签名添加到ICategoryService 接口中：\n\n```\npublic interface ICategoryService\n\t{\n\t\tTask<IEnumerable<Category>> ListAsync();\n\t\tTask<CategoryResponse> SaveAsync(Category category);\n\t\tTask<CategoryResponse> UpdateAsync(int id, Category category);\n\t\tTask<CategoryResponse> DeleteAsync(int id);\n\t}\n```\n在实施删除逻辑之前，我们需要在仓储中使用一种新方法。\n将Remove方法签名添加到ICategoryRepository接口：\n\n```\nvoid Remove(Category category);\n```\n现在，在仓储类上添加真正的实现：\n\n```\npublic void Remove(Category category)\n\t{\n\t\t_context.Categories.Remove(category);\n\t}\n```\nEF Core要求将模型的实例传递给Remove方法，以正确了解我们要删除的模型，而不是简单地传递Id。\n最后，让我们在CategoryService类上实现逻辑：\n\n```\npublic async Task<CategoryResponse> DeleteAsync(int id)\n\t{\n\t\tvar existingCategory = await _categoryRepository.FindByIdAsync(id);\n\t\n\n\t\tif (existingCategory == null)\n\t\t\treturn new CategoryResponse(\"Category not found.\");\n\t\n\n\t\ttry\n\t\t{\n\t\t\t_categoryRepository.Remove(existingCategory);\n\t\t\tawait _unitOfWork.CompleteAsync();\n\t\n\n\t\t\treturn new CategoryResponse(existingCategory);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\t// Do some logging stuff\n\t\t\treturn new CategoryResponse($\"An error occurred when deleting the category: {ex.Message}\");\n\t\t}\n\t}\n```\n这里没有新内容。该服务尝试通过ID查找类别，然后调用我们的仓储以删除类别。最后，工作单元完成将实际操作执行到数据库中的事务。\n*“-嘿，但是每个类别的产品呢？为避免出现错误，您是否不需要先创建仓储并删除产品？”*\n\n答案是**否定的**。借助[EF Core跟踪机制](https://docs.microsoft.com/en-us/ef/core/querying/tracking)，当我们从数据库中加载模型时，框架便知道了该模型具有哪些关系。如果我们删除它，EF Core知道它应该首先递归删除所有相关模型。\n\n在将类映射到数据库表时，我们可以禁用此功能，但这在本教程的范围之外。如果您想了解此功能，[请看这里](https://entityframeworkcore.com/saving-data-cascade-delete)。\n\n现在是时候测试我们的新端点了。再次运行该应用程序，并使用Postman发送DELETE请求，如下所示：\n\n![图片](https://uploader.shimo.im/f/VRCjsPelqx4qADIx.png!thumbnail)\n\n如您所见，API毫无问题地删除了现有类别\n\n我们可以通过发送GET请求来检查我们的API是否正常工作：\n\n![图片](https://uploader.shimo.im/f/iyiKvuB7e0IfSTQf.png!thumbnail)我们已经完成了类别API。现在是时候转向产品API。\n\n# **步骤18-产品API**\n到目前为止，您已经学习了如何实现所有基本的HTTP动词来使用ASP.NET Core处理CRUD操作。让我们进入实现产品API的下一个层次。\n\n我将不再详细介绍所有HTTP动词，因为这将是详尽无遗的。在本教程的最后一部分，我将仅介绍GET请求，以向您展示在从数据库查询数据时如何包括相关实体，以及如何使用Description我们为EUnitOfMeasurement 枚举值定义的属性。\n\n将新控制器ProductsController添加到名为Controllers的文件夹中。\n\n在这里编写任何代码之前，我们必须创建产品资源。\n\n让我刷新您的记忆，再次显示我们的资源应如何：\n\n```\n{\n [\n  {\n   \"id\": 1,\n   \"name\": \"Sugar\",\n   \"quantityInPackage\": 1,\n   \"unitOfMeasurement\": \"KG\"\n   \"category\": {\n   \"id\": 3,\n   \"name\": \"Sugar\"\n   }\n  },\n  … // Other products\n ]\n}\n```\n我们想要一个包含数据库中所有产品的JSON数组。\nJSON数据与产品模型有两点不同：\n\n* 测量单位以较短的方式显示，仅显示其缩写。\n* 我们输出类别数据**而不**包括CategoryId属性。\n\n为了表示度量单位，我们可以使用简单的字符串属性代替枚举类型（顺便说一下，我们没有JSON数据的默认枚举类型，因此我们必须将其转换为其他类型）。\n\n现在，我们现在要塑造新资源，让我们创建它。ProductResource在Resources文件夹中添加一个新类：\n\n```\nnamespace Supermarket.API.Resources\n\t{\n\t    public class ProductResource\n\t    {\n\t        public int Id { get; set; }\n\t        public string Name { get; set; }\n\t        public int QuantityInPackage { get; set; }\n\t        public string UnitOfMeasurement { get; set; }\n\t        public CategoryResource Category {get;set;}\n\t    }\n\t}\n```\n现在，我们必须配置模型类和新资源类之间的映射。\n映射配置将与用于其他映射的配置几乎相同，但是在这里，我们必须处理将EUnitOfMeasurement枚举转换为字符串的操作。\n\n您还记得StringValue应用于枚举类型的属性吗？现在，我将向您展示如何使用.NET框架的强大功能：[反射 API](https://www.tutorialspoint.com/csharp/csharp_reflection.htm)提取此信息。\n\n反射 API是一组强大的资源工具集，可让我们提取和操作元数据。许多框架和库（包括ASP.NET Core本身）都利用这些资源来处理许多后台工作。\n\n现在让我们看看它在实践中是如何工作的。将新类添加到Extensions名为的文件夹中EnumExtensions。\n\n```\nusing System.ComponentModel;\n\tusing System.Reflection;\n\t\n\n\tnamespace Supermarket.API.Extensions\n\t{\n\t    public static class EnumExtensions\n\t    {\n\t        public static string ToDescriptionString<TEnum>(this TEnum @enum)\n\t        {\n\t            FieldInfo info = @enum.GetType().GetField(@enum.ToString());\n\t            var attributes = (DescriptionAttribute[])info.GetCustomAttributes(typeof(DescriptionAttribute), false);\n\t\n\n\t            return attributes?[0].Description ?? @enum.ToString();\n\t        }\n\t    }\n\t}\n```\n第一次看代码可能会让人感到恐惧，但这并不复杂。让我们分解代码定义以了解其工作原理。\n首先，我们定义了一种[通用方法](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/)（一种方法，该方法可以接收不止一种类型的参数，在这种情况下，该方法由TEnum声明表示），该方法接收给定的枚举作为参数。\n\n由于enum是C＃中的保留关键字，因此我们在参数名称前面添加了@，以使其成为有效名称。\n\n该方法的第一步是使用该方法获取参数的类型信息（类，接口，枚举或结构定义）GetType。\n\n然后，该方法使用来获取特定的枚举值（例如Kilogram）GetField(@enum.ToString())。\n\n下一行找到Description应用于枚举值的所有属性，并将其数据存储到数组中（在某些情况下，我们可以为同一属性指定多个属性）。\n\n最后一行使用较短的语法来检查我们是否至少有一个枚举类型的描述属性。如果有，我们将返回Description此属性提供的值。如果不是，我们使用默认的强制类型转换将枚举作为字符串返回。\n\n?.操作者（[零条件运算](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/conditional-operator)）检查该值是否null访问其属性之前。\n\n??运算符（[空合并运算符](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator)）告诉应用程序在左边的返回值，如果它不为空，或者在正确的，否则价值。\n\n现在我们有了扩展方法来提取描述，让我们配置模型和资源之间的映射。多亏了AutoMapper，我们只需要多一行就可以做到这一点。\n\n打开ModelToResourceProfile类并通过以下方式更改代码：\n\n```\nusing AutoMapper;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Extensions;\n\tusing Supermarket.API.Resources;\n\t\n\n\tnamespace Supermarket.API.Mapping\n\t{\n\t    public class ModelToResourceProfile : Profile\n\t    {\n\t        public ModelToResourceProfile()\n\t        {\n\t            CreateMap<Category, CategoryResource>();\n\t\n\n\t            CreateMap<Product, ProductResource>()\n\t                .ForMember(src => src.UnitOfMeasurement,\n\t                           opt => opt.MapFrom(src => src.UnitOfMeasurement.ToDescriptionString()));\n\t        }\n\t    }\n\t}\n```\n此语法告诉AutoMapper使用新的扩展方法将我们的EUnitOfMeasurement值转换为包含其描述的字符串。简单吧？您可以[阅读官方文档](http://docs.automapper.org/en/stable/Inline-Mapping.html)以了解完整语法。\n注意，我们尚未为category属性定义任何映射配置。因为我们之前为类别配置了映射，并且由于产品模型具有相同类型和名称的category属性，所以AutoMapper隐式知道应该使用各自的配置来映射它。\n\n现在，我们添加端点代码。更改ProductsController代码：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing AutoMapper;\n\tusing Microsoft.AspNetCore.Mvc;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Services;\n\tusing Supermarket.API.Resources;\n\t\n\n\tnamespace Supermarket.API.Controllers\n\t{\n\t    [Route(\"/api/[controller]\")]\n\t    public class ProductsController : Controller\n\t    {\n\t        private readonly IProductService _productService;\n\t        private readonly IMapper _mapper;\n\t\n\n\t        public ProductsController(IProductService productService, IMapper mapper)\n\t        {\n\t            _productService = productService;\n\t            _mapper = mapper;\n\t        }\n\t\n\n\t        [HttpGet]\n\t        public async Task<IEnumerable<ProductResource>> ListAsync()\n\t        {\n\t            var products = await _productService.ListAsync();\n\t            var resources = _mapper.Map<IEnumerable<Product>, IEnumerable<ProductResource>>(products);\n\t            return resources;\n\t        }\n\t    }\n\t}\n```\n基本上，为类别控制器定义的结构相同。\n让我们进入服务部分。将一个新IProductService接口添加到Domain层中的Services文件夹中：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\t\n\n\tnamespace Supermarket.API.Domain.Services\n\t{\n\t    public interface IProductService\n\t    {\n\t         Task<IEnumerable<Product>> ListAsync();\n\t    }\n\t}\n```\n您应该已经意识到，在真正实现新服务之前，我们需要一个仓储。\nIProductRepository在相应的文件夹中添加一个名为的新接口：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\t\n\n\tnamespace Supermarket.API.Domain.Repositories\n\t{\n\t    public interface IProductRepository\n\t    {\n\t         Task<IEnumerable<Product>> ListAsync();\n\t    }\n\t}\n```\n现在，我们实现仓储。除了必须在查询数据时返回每个产品的相应类别数据外，我们几乎必须像对类别仓储一样实现。\n默认情况下，EF Core在查询数据时不包括与模型相关的实体，因为它可能非常慢（想象一个具有十个相关实体的模型，所有相关实体都有自己的关系）。\n\n要包括类别数据，我们只需要多一行：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Microsoft.EntityFrameworkCore;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Repositories;\n\tusing Supermarket.API.Persistence.Contexts;\n\t\n\n\tnamespace Supermarket.API.Persistence.Repositories\n\t{\n\t    public class ProductRepository : BaseRepository, IProductRepository\n\t    {\n\t        public ProductRepository(AppDbContext context) : base(context)\n\t        {\n\t        }\n\t\n\n\t        public async Task<IEnumerable<Product>> ListAsync()\n\t        {\n\t            return await _context.Products.Include(p => p.Category)\n\t                                          .ToListAsync();\n\t        }\n\t    }\n\t}\n```\n请注意对的调用Include(p => p.Category)。我们可以链接此语法，以在查询数据时包含尽可能多的实体。执行选择时，EF Core会将其转换为联接。\n现在，我们可以ProductService像处理类别一样实现类：\n\n```\nusing System.Collections.Generic;\n\tusing System.Threading.Tasks;\n\tusing Supermarket.API.Domain.Models;\n\tusing Supermarket.API.Domain.Repositories;\n\tusing Supermarket.API.Domain.Services;\n\t\n\n\tnamespace Supermarket.API.Services\n\t{\n\t    public class ProductService : IProductService\n\t    {\n\t        private readonly IProductRepository _productRepository;\n\t    \n\t        public ProductService(IProductRepository productRepository)\n\t        {\n\t            _productRepository = productRepository;\n\t        }\n\t\n\n\t        public async Task<IEnumerable<Product>> ListAsync()\n\t        {\n\t            return await _productRepository.ListAsync();\n\t        }\n\t    }\n\t}\n```\n让我们绑定更改Startup类的新依赖项：\n```\npublic void ConfigureServices(IServiceCollection services)\n\t{\n\t    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);\n\t\n\n\t    services.AddDbContext<AppDbContext>(options =>\n\t    {\n\t        options.UseInMemoryDatabase(\"supermarket-api-in-memory\");\n\t    });\n\t\n\n\t    services.AddScoped<ICategoryRepository, CategoryRepository>();\n\t    services.AddScoped<IProductRepository, ProductRepository>();\n\t    services.AddScoped<IUnitOfWork, UnitOfWork>();\n\t\n\n\t    services.AddScoped<ICategoryService, CategoryService>();\n\t    services.AddScoped<IProductService, ProductService>();\n\t\n\n\t    services.AddAutoMapper();\n\t}\n```\n最后，在测试API之前，让我们AppDbContext在初始化应用程序时更改类以包括一些产品，以便我们看到结果：\n```\nprotected override void OnModelCreating(ModelBuilder builder)\n\t{\n\t    base.OnModelCreating(builder);\n\t    \n\t    builder.Entity<Category>().ToTable(\"Categories\");\n\t    builder.Entity<Category>().HasKey(p => p.Id);\n\t    builder.Entity<Category>().Property(p => p.Id).IsRequired().ValueGeneratedOnAdd().HasValueGenerator<InMemoryIntegerValueGenerator<int>>();\n\t    builder.Entity<Category>().Property(p => p.Name).IsRequired().HasMaxLength(30);\n\t    builder.Entity<Category>().HasMany(p => p.Products).WithOne(p => p.Category).HasForeignKey(p => p.CategoryId);\n\t\n\n\t    builder.Entity<Category>().HasData\n\t    (\n\t        new Category { Id = 100, Name = \"Fruits and Vegetables\" }, // Id set manually due to in-memory provider\n\t        new Category { Id = 101, Name = \"Dairy\" }\n\t    );\n\t\n\n\t    builder.Entity<Product>().ToTable(\"Products\");\n\t    builder.Entity<Product>().HasKey(p => p.Id);\n\t    builder.Entity<Product>().Property(p => p.Id).IsRequired().ValueGeneratedOnAdd();\n\t    builder.Entity<Product>().Property(p => p.Name).IsRequired().HasMaxLength(50);\n\t    builder.Entity<Product>().Property(p => p.QuantityInPackage).IsRequired();\n\t    builder.Entity<Product>().Property(p => p.UnitOfMeasurement).IsRequired();\n\t\n\n\t    builder.Entity<Product>().HasData\n\t    (\n\t        new Product\n\t        {\n\t            Id = 100,\n\t            Name = \"Apple\",\n\t            QuantityInPackage = 1,\n\t            UnitOfMeasurement = EUnitOfMeasurement.Unity,\n\t            CategoryId = 100\n\t        },\n\t        new Product\n\t        {\n\t            Id = 101,\n\t            Name = \"Milk\",\n\t            QuantityInPackage = 2,\n\t            UnitOfMeasurement = EUnitOfMeasurement.Liter,\n\t            CategoryId = 101,\n\t        }\n\t    );\n\t}\n```\n我添加了两个虚构产品，将它们与初始化应用程序时我们播种的类别相关联。\n该测试了！再次运行API并发送GET请求以/api/products使用Postman：\n\n![图片](https://uploader.shimo.im/f/h9cMeoAIZg4vyRgj.png!thumbnail)\n\n就是这样！恭喜你！\n\n现在，您将了解如何使用解耦的代码架构使用ASP.NET Core构建RESTful API。您了解了.NET Core框架的许多知识，如何使用C＃，EF Core和AutoMapper的基础知识以及在设计应用程序时要使用的许多有用的模式。\n\n您可以检查API的完整实现，包括产品的其他HTTP动词，并检查Github仓储：\n\n[evgomes / supermarket-api](https://github.com/evgomes/supermarket-api)\n\n[使用ASP.NET Core 2.2构建的简单RESTful API，展示了如何使用分离的，可维护的……创建RESTful服务](https://github.com/evgomes/supermarket-api)[。github.com](https://github.com/evgomes/supermarket-api)\n\n# **结论**\nASP.NET Core是创建Web应用程序时使用的出色框架。它带有许多有用的API，可用于构建干净，可维护的应用程序。创建专业应用程序时，可以将其视为一种选择。\n\n本文并未涵盖专业API的所有方面，但您已学习了所有基础知识。您还学到了许多有用的模式，可以解决我们每天面临的模式。\n\n希望您喜欢这篇文章，希望对您有所帮助。期待你的反馈，以便我能进一步提高。\n\n**进一步学习的可用参考资料**\n\n[.NET Core教程-Microsoft文档](https://docs.microsoft.com/en-us/dotnet/core/tutorials/)\n\n[ASP.NET Core文档-Microsoft文档](https://docs.microsoft.com/zh-cn/aspnet/#pivot=core&panel=core_tutorials)\n\n","slug":"技术/how-to-use-restfulapi-in-netcore","published":1,"updated":"2020-02-23T14:24:23.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbuujta9005dn4vixl5zn6gx","content":"<p>译者荐语：利用周末的时间，本人拜读了长沙.NET技术社区翻译的技术文章《<a href=\"http://techq.club/2019/08/02/%E6%8A%80%E6%9C%AF/Microsoft%20REST%20API%E6%8C%87%E5%8D%97/\" target=\"_blank\" rel=\"noopener\">微软RESTFul API指南</a>》，打算按照步骤写一个完整的教程，后来无意中看到了这篇文章，与我要写的主题有不少相似之处，特意翻译下来。前方高能。</p>\n<p><img src=\"https://uploader.shimo.im/f/U68C9NmcWwwWHATD.png!thumbnail\" alt=\"图片\">一步一步的构建整洁、可维护的RESTful APIs</p>\n<p><a href=\"https://www.techq.xyz/2020/02/23/%E6%8A%80%E6%9C%AF/WPF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%A6%82%E8%BF%B0/\" target=\"_blank\" rel=\"noopener\">查看原文</a></p>\n<h1 id=\"总览\"><a href=\"#总览\" class=\"headerlink\" title=\"总览\"></a>总览</h1><p>RESTful不是一个新名词。它是一种架构风格，这种架构风格使用Web服务从客户端应用程序接收数据和向客户端应用程序发送数据。其目标是集中不同客户端应用程序将使用的数据。</p>\n<p>选择正确的工具来编写RESTful服务至关重要，因为我们需要关注可伸缩性，维护，文档以及所有其他相关方面。在<a href=\"https://docs.microsoft.com/en-us/aspnet/\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> Core为我们提供了一个功能强大、易于使用的API，使用这些API将很好的实现这个目标。</p>\n<p>在本文中，我将向您展示如何使用ASP.NET Core框架为“几乎”现实世界的场景编写结构良好的RESTful API。我将详细介绍常见的模式和策略以简化开发过程。</p>\n<p>我还将向您展示如何集成通用框架和库，例如<a href=\"https://docs.microsoft.com/en-us/ef/core/\" target=\"_blank\" rel=\"noopener\">Entity Framework Core</a>和<a href=\"https://automapper.org/\" target=\"_blank\" rel=\"noopener\">AutoMapper</a>，以提供必要的功能。</p>\n<h1 id=\"先决条件\"><a href=\"#先决条件\" class=\"headerlink\" title=\"先决条件\"></a><strong>先决条件</strong></h1><p>我希望您了解面向对象的编程概念。</p>\n<p>即使我将介绍<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/\" target=\"_blank\" rel=\"noopener\">C＃编程语言</a>的许多细节，我还是建议您具有该主题的基本知识。</p>\n<p>我还假设您知道什么是REST，<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview\" target=\"_blank\" rel=\"noopener\">HTTP协议</a>如何工作，什么是API端点以及什么是<a href=\"https://www.json.org/\" target=\"_blank\" rel=\"noopener\">JSON</a>。<a href=\"https://medium.freecodecamp.org/restful-services-part-i-http-in-a-nutshell-aab3bfedd131\" target=\"_blank\" rel=\"noopener\">这是</a>关于此主题<a href=\"https://medium.freecodecamp.org/restful-services-part-i-http-in-a-nutshell-aab3bfedd131\" target=\"_blank\" rel=\"noopener\">的出色的入门教程</a>。最后，您需要了解关系数据库的工作原理。</p>\n<p>要与我一起编码，您将必须安装<a href=\"https://dotnet.microsoft.com/download\" target=\"_blank\" rel=\"noopener\">.NET Core 2.2</a>以及<a href=\"https://www.getpostman.com/\" target=\"_blank\" rel=\"noopener\">Postman</a>（我将用来测试API的工具）。我建议您使用诸如<a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">Visual Studio Code之</a>类的代码编辑器来开发API。选择您喜欢的代码编辑器。如果选择Visual Studio Code作为您的代码编辑器，建议您安装<a href=\"https://code.visualstudio.com/docs/languages/csharp\" target=\"_blank\" rel=\"noopener\">C＃扩展</a>以更好地突出显示代码。</p>\n<p>您可以在本文末尾找到该API的Github的链接，以检查最终结果。</p>\n<h1 id=\"范围\"><a href=\"#范围\" class=\"headerlink\" title=\"范围\"></a><strong>范围</strong></h1><p>让我们为一家超市编写一个虚构的Web API。假设我们必须实现以下范围：</p>\n<ul>\n<li><em>创建一个RESTful服务，该服务允许客户端应用程序管理超市的产品目录。它需要公开端点以创建，读取，编辑和删除产品类别，例如乳制品和化妆品，还需要管理这些类别的产品。</em></li>\n<li><em>对于类别，我们需要存储其名称。对于产品，我们需要存储其名称，度量单位（例如，按重量测量的产品为KG），包装中的数量（例如，如果一包饼干是10，则为10）及其各自的类别。</em></li>\n</ul>\n<p>为了简化示例，我将不处理库存产品，产品运输，安全性和任何其他功能。这个范围足以向您展示ASP.NET Core的工作方式。</p>\n<p>要开发此服务，我们基本上需要两个API 端点（译者注：指控制器）：一个用于管理类别，一个用于管理产品。在JSON通讯方面，我们可以认为响应如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">API endpoint: /api/categories</span><br><span class=\"line\">JSON Response (for GET requests):</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  [</span><br><span class=\"line\">    &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Fruits and Vegetables&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;Breads&quot; &#125;,</span><br><span class=\"line\">    … // Other categories</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">API endpoint: /api/products</span><br><span class=\"line\">JSON Response (for GET requests):</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;id&quot;: 1,</span><br><span class=\"line\">      &quot;name&quot;: &quot;Sugar&quot;,</span><br><span class=\"line\">      &quot;quantityInPackage&quot;: 1,</span><br><span class=\"line\">      &quot;unitOfMeasurement&quot;: &quot;KG&quot;</span><br><span class=\"line\">      &quot;category&quot;: &#123;</span><br><span class=\"line\">        &quot;id&quot;: 3,</span><br><span class=\"line\">        &quot;name&quot;: &quot;Sugar&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    … // Other products</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>让我们开始编写应用程序。</p>\n<h1 id=\"第1步-创建API\"><a href=\"#第1步-创建API\" class=\"headerlink\" title=\"第1步-创建API\"></a><strong>第1步-创建API</strong></h1><p>首先，我们必须为Web服务创建文件夹结构，然后我们必须使用<a href=\"https://docs.microsoft.com/en-us/dotnet/core/tools/?tabs=netcore2x\" target=\"_blank\" rel=\"noopener\">.NET CLI工具</a>来构建基本的Web API。打开终端或命令提示符（取决于您使用的操作系统），并依次键入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir src/Supermarket.API</span><br><span class=\"line\"></span><br><span class=\"line\">cd src/Supermarket.API</span><br><span class=\"line\"></span><br><span class=\"line\">dotnet new webapi</span><br></pre></td></tr></table></figure>\n\n<p>前两个命令只是为API创建一个新目录，然后将当前位置更改为新文件夹。最后一个遵循Web API模板生成一个新项目，这是我们正在开发的应用程序。您可以阅读有关这些命令和其他项目模板的更多信息，并可以通过<a href=\"https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new?tabs=netcore21\" target=\"_blank\" rel=\"noopener\">检查此链接</a>来生成其他项目模板。<br>现在，新目录将具有以下结构：</p>\n<p><img src=\"https://uploader.shimo.im/f/LuICwkhqHDsD5RcN.png!thumbnail\" alt=\"图片\"></p>\n<p>项目结构</p>\n<h2 id=\"结构概述\"><a href=\"#结构概述\" class=\"headerlink\" title=\"结构概述\"></a>结构概述</h2><p>ASP.NET Core应用程序由在类中配置的一组<a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-2.2\" target=\"_blank\" rel=\"noopener\">中间件</a>（应用程序流水线中的小块应用程序，用于处理请求和响应）组成Startup。如果您以前已经使用过<a href=\"https://expressjs.com/\" target=\"_blank\" rel=\"noopener\">Express.js</a>之类的框架，那么这个概念对您来说并不是什么新鲜事物。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Startup</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public Startup(IConfiguration configuration)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        Configuration = configuration;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    public IConfiguration Configuration &#123; get; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    // This method gets called by the runtime. Use this method to add services to the container.</span><br><span class=\"line\">\t    public void ConfigureServices(IServiceCollection services)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span><br><span class=\"line\">\t    public void Configure(IApplicationBuilder app, IHostingEnvironment env)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        if (env.IsDevelopment())</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            app.UseDeveloperExceptionPage();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t        else</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.</span><br><span class=\"line\">\t            app.UseHsts();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        app.UseHttpsRedirection();</span><br><span class=\"line\">\t        app.UseMvc();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当应用程序启动时，将调用类中的Main** **方法Program。它使用启动配置创建默认的Web主机，通过HTTP通过特定端口（默认情况下，HTTP为5000，HTTPS为5001）公开应用程序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace Supermarket.API</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class Program</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public static void Main(string[] args)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            CreateWebHostBuilder(args).Build().Run();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;</span><br><span class=\"line\">\t            WebHost.CreateDefaultBuilder(args)</span><br><span class=\"line\">\t                .UseStartup&lt;Startup&gt;();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看一下文件夹中的ValuesController类Controllers。它公开了API通过路由接收请求时将调用的方法/api/values。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Route(&quot;api/[controller]&quot;)]</span><br><span class=\"line\">\t[ApiController]</span><br><span class=\"line\">\tpublic class ValuesController : ControllerBase</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    // GET api/values</span><br><span class=\"line\">\t    [HttpGet]</span><br><span class=\"line\">\t    public ActionResult&lt;IEnumerable&lt;string&gt;&gt; Get()</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        return new string[] &#123; &quot;value1&quot;, &quot;value2&quot; &#125;;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    // GET api/values/5</span><br><span class=\"line\">\t    [HttpGet(&quot;&#123;id&#125;&quot;)]</span><br><span class=\"line\">\t    public ActionResult&lt;string&gt; Get(int id)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        return &quot;value&quot;;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    // POST api/values</span><br><span class=\"line\">\t    [HttpPost]</span><br><span class=\"line\">\t    public void Post([FromBody] string value)</span><br><span class=\"line\">\t    &#123; </span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    // PUT api/values/5</span><br><span class=\"line\">\t    [HttpPut(&quot;&#123;id&#125;&quot;)]</span><br><span class=\"line\">\t    public void Put(int id, [FromBody] string value)</span><br><span class=\"line\">\t    &#123;   </span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    // DELETE api/values/5</span><br><span class=\"line\">\t    [HttpDelete(&quot;&#123;id&#125;&quot;)]</span><br><span class=\"line\">\t    public void Delete(int id)</span><br><span class=\"line\">\t    &#123;  </span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果您不了解此代码的某些部分，请不要担心。在开发必要的API端点时，我将详细介绍每一个。现在，只需删除此类，因为我们不会使用它。</p>\n<h1 id=\"第2步-创建领域模型\"><a href=\"#第2步-创建领域模型\" class=\"headerlink\" title=\"第2步-创建领域模型\"></a><strong>第2步-创建领域模型</strong></h1><p>我将应用一些设计概念，以使应用程序简单易维护。</p>\n<p>编写可以由您自己理解和维护的代码并不难，但是您必须牢记您将成为团队的一部分。如果您不注意如何编写代码，那么结果将是一个庞然大物，这将使您和您的团队成员头痛不已。听起来很极端吧？但是相信我，这就是事实。</p>\n<p><img src=\"https://uploader.shimo.im/f/vMGZaW8zLiA39wxb.png!thumbnail\" alt=\"图片\"></p>\n<p>衡量好代码的标准是WTF的频率。原图来自<a href=\"https://www.flickr.com/photos/smitty/\" target=\"_blank\" rel=\"noopener\">smitty42</a>，发表于<a href=\"https://www.flickr.com/photos/smitty/2245445147\" target=\"_blank\" rel=\"noopener\">filckr</a>。该图遵循CC-BY-2.0。</p>\n<p>在Supermarket.API目录中，创建一个名为的新文件夹Domain。在新的领域文件夹中，创建另一个名为的文件夹Models。我们必须添加到此文件夹的第一个模型是Category。最初，它将是一个简单的<a href=\"https://en.wikipedia.org/wiki/Plain_old_CLR_object\" target=\"_blank\" rel=\"noopener\">Plain Old CLR Object（POCO）</a>类。这意味着该类将仅具有描述其基本信息的属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Models</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class Category</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public int Id &#123; get; set; &#125;</span><br><span class=\"line\">\t        public string Name &#123; get; set; &#125;</span><br><span class=\"line\">\t        public IList&lt;Product&gt; Products &#123; get; set; &#125; = new List&lt;Product&gt;();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该类具有一个Id** <strong>属性（用于标识类别）和一个Name属性。以及一个Products</strong> <strong>属性。最后一个属性将由</strong>Entity Framework Core使用**，大多数ASP.NET Core应用程序使用ORM将数据持久化到数据库中，以映射类别和产品之间的关系。由于类别具有许多相关产品，因此在面向对象的编程方面也具有合理的思维能力。<br>我们还必须创建产品模型。在同一文件夹中，添加一个新Product类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace Supermarket.API.Domain.Models</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class Product</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public int Id &#123; get; set; &#125;</span><br><span class=\"line\">\t        public string Name &#123; get; set; &#125;</span><br><span class=\"line\">\t        public short QuantityInPackage &#123; get; set; &#125;</span><br><span class=\"line\">\t        public EUnitOfMeasurement UnitOfMeasurement &#123; get; set; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public int CategoryId &#123; get; set; &#125;</span><br><span class=\"line\">\t        public Category Category &#123; get; set; &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该产品还具有ID和名称的属性。属性QuantityInPackage，它告诉我们一包中有多少个产品单位（请记住应用范围的饼干示例）和一个UnitOfMeasurement** <strong>属性，这是表示一个<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum\" target=\"_blank\" rel=\"noopener\">枚举类型</a>，它表示可能的度量单位的枚举。最后两个属性，CategoryId</strong> **和Category将由ORM用于映射的产品和类别之间的关系。它表明一种产品只有一个类别。</p>\n<p>让我们定义领域模型的最后一部分，EUnitOfMeasurement** **枚举。</p>\n<p>按照惯例，枚举不需要在名称前以<em>“ E”</em>开头，但是在某些库和框架中，您会发现此前缀是将枚举与接口和类区分开的一种方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.ComponentModel;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Models</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public enum EUnitOfMeasurement : byte</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        [Description(&quot;UN&quot;)]</span><br><span class=\"line\">\t        Unity = 1,</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        [Description(&quot;MG&quot;)]</span><br><span class=\"line\">\t        Milligram = 2,</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        [Description(&quot;G&quot;)]</span><br><span class=\"line\">\t        Gram = 3,</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        [Description(&quot;KG&quot;)]</span><br><span class=\"line\">\t        Kilogram = 4,</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        [Description(&quot;L&quot;)]</span><br><span class=\"line\">\t        Liter = 5</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该代码非常简单。在这里，我们仅定义了几种度量单位的可能性，但是，在实际的超市系统中，您可能具有许多其他度量单位，并且可能还有一个单独的模型。<br>注意，【Description】特性应用于所有枚举可能性。特性是一种在C＃语言的类，接口，属性和其他组件上定义元数据的方法。在这种情况下，我们将使用它来简化产品API端点的响应，但是您现在不必关心它。我们待会再回到这里。</p>\n<p>我们的基本模型已准备就绪，可以使用。现在，我们可以开始编写将管理所有类别的API端点。</p>\n<h1 id=\"第3步-类别API\"><a href=\"#第3步-类别API\" class=\"headerlink\" title=\"第3步-类别API\"></a><strong>第3步-类别API</strong></h1><p>在Controllers文件夹中，添加一个名为的新类CategoriesController。</p>\n<p>按照惯例，该文件夹中所有后缀为<em>“ Controller”的类</em>都将成为我们应用程序的控制器。这意味着他们将处理请求和响应。您必须从<a href=\"https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/namespace\" target=\"_blank\" rel=\"noopener\">命名空间</a>【Microsoft.AspNetCore.Mvc】继承Controller。</p>\n<p>命名空间由一组相关的类，接口，枚举和结构组成。您可以将其视为类似于Java语言<a href=\"https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc\" target=\"_blank\" rel=\"noopener\">模块</a>或Java <a href=\"https://docs.oracle.com/javase/tutorial/java/package/packages.html\" target=\"_blank\" rel=\"noopener\">程序包</a>的东西。</p>\n<p>新的控制器应通过路由/api/categories做出响应。我们通过Route** **在类名称上方添加属性，指定占位符来实现此目的，该占位符表示路由应按照惯例使用不带控制器后缀的类名称。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Microsoft.AspNetCore.Mvc;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Controllers</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    [Route(&quot;/api/[controller]&quot;)]</span><br><span class=\"line\">\t    public class CategoriesController : Controller</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>让我们开始处理GET请求。首先，当有人/api/categories通过GET动词请求数据时，API需要返回所有类别。为此，我们可以创建<strong>类别服务</strong>。<br>从概念上讲，服务基本上是定义用于处理某些业务逻辑的方法的类或接口。创建用于处理业务逻辑的服务是许多不同编程语言的一种常见做法，例如<a href=\"https://medium.com/@evandro.ggomes/json-web-token-authentication-with-asp-net-core-2-0-b074b0cfc870\" target=\"_blank\" rel=\"noopener\">身份验证和授权</a>，付款，复杂的数据流，缓存和需要其他服务或模型之间进行某些交互的任务。</p>\n<p>使用服务，我们可以将请求和响应处理与完成任务所需的真实逻辑隔离开来。</p>\n<p>该服务，我们要创建将首先定义一个单独的行为<strong>，</strong>或<strong>方法</strong>：一个list方法。我们希望该方法返回数据库中所有现有的类别。</p>\n<p>为简单起见，在这篇博客中，我们将不处理数据分页或过滤，（译者注：基于RESTFul规范，提供了一套完整的分页和过滤的规则）。将来，我将写一篇文章，展示如何轻松处理这些功能。</p>\n<p>为了定义C＃（以及其他面向对象的语言，例如Java）中某事物的预期行为，我们定义一个<strong>interface</strong>。一个接口告诉某些事情应该如何工作，但是<strong>没有实现行为的真实逻辑</strong>。逻辑在实现接口的类中实现。如果您不清楚此概念，请不要担心。一段时间后您将了解它。</p>\n<p>在Domain文件夹中，创建一个名为的新目录Services。在此添加一个名为ICategoryService的接口。按照惯例，所有接口都应以C＃中的大写字母<em>“ I”</em>开头。定义接口代码，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Services</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public interface ICategoryService</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t         Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该ListAsync方法的实现必须<strong>异步</strong>返回类别的可枚举对象。<br>Task封装返回的类表示异步。由于必须等待数据库完成操作才能返回数据，因此我们需要考虑执行此过程可能需要一段时间，因此我们需要使用异步方法。另请注意<em>“Async”</em>后缀。这是一个约定，告诉我们的方法应异步执行。</p>\n<p>我们有很多约定，对吗？我个人喜欢它，因为它使应用程序易于阅读，即使你在一家使用.NET技术的公司是新人。</p>\n<p><img src=\"https://uploader.shimo.im/f/vQLzU6MpZkoChf0Y.png!thumbnail\" alt=\"图片\"></p>\n<p><em>“-好的，我们定义了此接口，但是它什么也没做。有什么用？”</em></p>\n<p>如果您来自Javascript或其他非强类型语言，则此概念可能看起来很奇怪。</p>\n<p>接口使我们能够从实际实现中抽象出所需的行为。使用称为<a href=\"https://medium.freecodecamp.org/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f\" target=\"_blank\" rel=\"noopener\">依赖注入</a>的机制，我们可以实现这些接口并将它们与其他组件隔离。</p>\n<p>基本上，当您使用依赖项注入时，您可以使用接口定义一些行为。然后，创建一个实现该接口的类。最后，将引用从接口绑定到您创建的类。</p>\n<p><em>”-听起来确实令人困惑。我们不能简单地创建一个为我们做这些事情的类吗？”</em></p>\n<p>让我们继续实现我们的API，您将了解为什么使用这种方法。</p>\n<p>更改CategoriesController代码，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore.Mvc;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Controllers</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    [Route(&quot;/api/[controller]&quot;)]</span><br><span class=\"line\">\t    public class CategoriesController : Controller</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        private readonly ICategoryService _categoryService;</span><br><span class=\"line\">\t        </span><br><span class=\"line\">\t        public CategoriesController(ICategoryService categoryService)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            _categoryService = categoryService;   </span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        [HttpGet]</span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;Category&gt;&gt; GetAllAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            var categories = await _categoryService.ListAsync();</span><br><span class=\"line\">\t            return categories;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我已经为控制器定义了一个构造函数（当创建一个类的新实例时会调用一个构造函数），并且它接收的实例ICategoryService。这意味着实例可以是任何实现服务接口的实例。我将此实例存储在一个私有的只读字段中_categoryService。我们将使用此字段访问类别服务实现的方法。<br>顺便说一下，下划线前缀是表示字段的另一个通用约定。特别地，<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions\" target=\"_blank\" rel=\"noopener\">.NET</a>的<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions\" target=\"_blank\" rel=\"noopener\">官方命名约定指南</a>不建议使用此<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions\" target=\"_blank\" rel=\"noopener\">约定</a>，但是这是一种非常普遍的做法，可以避免使用<em>“ this”</em>关键字来区分类字段和局部变量。我个人认为阅读起来要干净得多，并且许多框架和库都使用此约定。</p>\n<p>在构造函数下，我定义了用于处理请求的方法/api/categories。该HttpGet** **属性告诉ASP.NET Core管道使用该属性来处理GET请求（可以省略此属性，但是最好编写它以便于阅读）。</p>\n<p>该方法使用我们的CategoryService实例列出所有类别，然后将类别返回给客户端。框架管道将数据序列化为JSON对象。IEnumerable类型告诉框架，我们想要返回一个类别的枚举，而Task类型(使用async关键字修饰)告诉管道，这个方法应该异步执行。最后，当我们定义一个异步方法时，我们必须使用await关键字来处理需要一些时间的任务。</p>\n<p>好的，我们定义了API的初始结构。现在，有必要真正实现类别服务。</p>\n<h1 id=\"步骤4-实现类别服务\"><a href=\"#步骤4-实现类别服务\" class=\"headerlink\" title=\"步骤4-实现类别服务\"></a><strong>步骤4-实现类别服务</strong></h1><p>在API的根文件夹（即Supermarket.API文件夹）中，创建一个名为的新文件夹Services。在这里，我们将放置所有服务实现。在新文件夹中，添加一个名为CategoryService的新类。更改代码，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Services</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class CategoryService : ICategoryService</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上只是接口实现的基本代码，我们暂时仍不处理任何逻辑。让我们考虑一下列表方法应该如何实现。<br>我们需要访问数据库并返回所有类别，然后我们需要将此数据返回给客户端。</p>\n<p>服务类不是应该处理数据访问的类。我们将使用一种称为“仓储模式”的设计模式，定义仓储类，用于管理数据库中的数据。</p>\n<p>在使用仓储模式时，我们定义了repository 类，该类基本上封装了处理数据访问的所有逻辑。这些仓储类使方法可以列出，创建，编辑和删除给定模型的对象，与操作集合的方式相同。在内部，这些方法与数据库对话以执行CRUD操作，从而将数据库访问与应用程序的其余部分隔离开。</p>\n<p>我们的服务需要调用类别仓储，以获取列表对象。</p>\n<p>从概念上讲，服务可以与一个或多个仓储或其他服务“对话”以执行操作。</p>\n<p>创建用于处理数据访问逻辑的新定义似乎是多余的，但是您将在一段时间内看到将这种逻辑与服务类隔离是非常有利的。</p>\n<p>让我们创建一个仓储，该仓储负责与数据库通信，作为持久化保存类别的一种方式。</p>\n<h1 id=\"步骤5-类别仓储和持久层\"><a href=\"#步骤5-类别仓储和持久层\" class=\"headerlink\" title=\"步骤5-类别仓储和持久层\"></a><strong>步骤5-类别仓储和持久层</strong></h1><p>在该Domain文件夹内，创建一个名为的新目录Repositories。然后，添加一个名为的新接口ICategoryRespository。定义接口如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Repositories</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public interface ICategoryRepository</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t         Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始代码基本上与服务接口的代码相同。<br>定义了接口之后，我们可以返回服务类并使用的实例ICategoryRepository返回数据来完成实现list方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Repositories;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Services</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class CategoryService : ICategoryService</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        private readonly ICategoryRepository _categoryRepository;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public CategoryService(ICategoryRepository categoryRepository)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            this._categoryRepository = categoryRepository;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync()</span><br><span class=\"line\">\t        &#123; </span><br><span class=\"line\">\t            return await _categoryRepository.ListAsync();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们必须实现类别仓储的真实逻辑。在这样做之前，我们必须考虑如何访问数据库。<br><em>顺便说一句，我们仍然没有数据库！</em></p>\n<p>我们将使用Entity Framework Core（为简单起见，我将其称为<strong><em>EF Core</em></strong>）作为我们的数据库ORM。该框架是ASP.NET Core的默认ORM，并公开了一个友好的API，该API使我们能够将应用程序的类映射到数据库表。</p>\n<p>EF Core还允许我们先设计应用程序，然后根据我们在代码中定义的内容生成数据库。此技术称为<strong>Code First</strong>。我们将使用Code First方法来生成数据库（实际上，在此示例中，我将使用内存数据库，但是您可以轻松地将其更改为像SQL Server或MySQL服务器这样的实例数据库）。</p>\n<p>在API的根文件夹中，创建一个名为的新目录Persistence。此目录将包含我们访问数据库所需的所有内容，例如仓储实现。</p>\n<p>在新文件夹中，创建一个名为的新目录Contexts，然后添加一个名为的新类AppDbContext。此类必须继承DbContext，EF Core通过DBContext用来将您的模型映射到数据库表的类。通过以下方式更改代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Microsoft.EntityFrameworkCore;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Persistence.Contexts</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class AppDbContext : DbContext</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public AppDbContext(DbContextOptions&lt;AppDbContext&gt; options) : base(options)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们添加到此类的构造函数负责通过依赖注入将数据库配置传递给基类。稍后您将看到其工作原理。<br>现在，我们必须创建两个DbSet属性。这些属性是将模型映射到数据库表的集合（唯一对象的集合）。</p>\n<p>另外，我们必须将模型的属性映射到相应的列，指定哪些属性是主键，哪些是外键，列类型等。我们可以使用称为<a href=\"http://www.entityframeworktutorial.net/efcore/fluent-api-in-entity-framework-core.aspx\" target=\"_blank\" rel=\"noopener\">Fluent API</a>的功能来覆盖OnModelCreating方法，以指定数据库映射。更改AppDbContext类，如下所示：</p>\n<p>该代码是如此直观。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Microsoft.EntityFrameworkCore;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Persistence.Contexts</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class AppDbContext : DbContext</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public DbSet&lt;Category&gt; Categories &#123; get; set; &#125;</span><br><span class=\"line\">\t        public DbSet&lt;Product&gt; Products &#123; get; set; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public AppDbContext(DbContextOptions&lt;AppDbContext&gt; options) : base(options) &#123; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        protected override void OnModelCreating(ModelBuilder builder)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            base.OnModelCreating(builder);</span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t            builder.Entity&lt;Category&gt;().ToTable(&quot;Categories&quot;);</span><br><span class=\"line\">\t            builder.Entity&lt;Category&gt;().HasKey(p =&gt; p.Id);</span><br><span class=\"line\">\t            builder.Entity&lt;Category&gt;().Property(p =&gt; p.Id).IsRequired().ValueGeneratedOnAdd();</span><br><span class=\"line\">\t            builder.Entity&lt;Category&gt;().Property(p =&gt; p.Name).IsRequired().HasMaxLength(30);</span><br><span class=\"line\">\t            builder.Entity&lt;Category&gt;().HasMany(p =&gt; p.Products).WithOne(p =&gt; p.Category).HasForeignKey(p =&gt; p.CategoryId);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            builder.Entity&lt;Category&gt;().HasData</span><br><span class=\"line\">\t            (</span><br><span class=\"line\">\t                new Category &#123; Id = 100, Name = &quot;Fruits and Vegetables&quot; &#125;, // Id set manually due to in-memory provider</span><br><span class=\"line\">\t                new Category &#123; Id = 101, Name = &quot;Dairy&quot; &#125;</span><br><span class=\"line\">\t            );</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            builder.Entity&lt;Product&gt;().ToTable(&quot;Products&quot;);</span><br><span class=\"line\">\t            builder.Entity&lt;Product&gt;().HasKey(p =&gt; p.Id);</span><br><span class=\"line\">\t            builder.Entity&lt;Product&gt;().Property(p =&gt; p.Id).IsRequired().ValueGeneratedOnAdd();</span><br><span class=\"line\">\t            builder.Entity&lt;Product&gt;().Property(p =&gt; p.Name).IsRequired().HasMaxLength(50);</span><br><span class=\"line\">\t            builder.Entity&lt;Product&gt;().Property(p =&gt; p.QuantityInPackage).IsRequired();</span><br><span class=\"line\">\t            builder.Entity&lt;Product&gt;().Property(p =&gt; p.UnitOfMeasurement).IsRequired();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们指定我们的模型应映射到哪些表。此外，我们设置了主键，使用该方法HasKey，该表的列，使用Property方法，和一些限制，例如IsRequired，HasMaxLength<strong>，</strong>和ValueGeneratedOnAdd，这些都是使用FluentApi的方式基于Lamada 表达式语法实现的（链式语法）。<br>看一下下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">builder.Entity&lt;Category&gt;()</span><br><span class=\"line\">       .HasMany(p =&gt; p.Products)</span><br><span class=\"line\">       .WithOne(p =&gt; p.Category)</span><br><span class=\"line\">       .HasForeignKey(p =&gt; p.CategoryId);</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们指定表之间的关系。我们说一个类别有很多产品，我们设置了将映射此关系的属性（Products，来自Category类，和Category，来自Product类）。我们还设置了外键（CategoryId）。<br>如果您想学习如何使用EF Core配置一对一和多对多关系，以及如何完整的使用它，请看一下<a href=\"https://www.learnentityframeworkcore.com/relationships\" target=\"_blank\" rel=\"noopener\">本教程</a>。</p>\n<p>还有一种用于通过HasData方法配置种子数据的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">builder.Entity&lt;Category&gt;().HasData</span><br><span class=\"line\">(</span><br><span class=\"line\">  new Category &#123; Id = 100, Name = &quot;Fruits and Vegetables&quot; &#125;,</span><br><span class=\"line\">  new Category &#123; Id = 101, Name = &quot;Dairy&quot; &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，在这里我们仅添加两个示例类别。这对我们完成后进行API的测试来说是非常有必要的。</p>\n<blockquote>\n<p><strong>注意：</strong>我们在Id这里手动设置属性，因为内存提供程序的工作机制需要。我将标识符设置为大数字，以避免自动生成的标识符和种子数据之间发生冲突。</p>\n<blockquote>\n<p>真正的关系数据库提供程序中不存在此限制，因此，例如，如果要使用SQL Server等数据库，则不必指定这些标识符。如果您想了解此行为，请检查<a href=\"https://github.com/aspnet/EntityFrameworkCore/issues/6872\" target=\"_blank\" rel=\"noopener\">此Github问题</a>。</p>\n</blockquote>\n</blockquote>\n<p>在实现数据库上下文类之后，我们可以实现类别仓储。添加一个名为新的文件夹Repositories里面Persistence的文件夹，然后添加一个名为新类BaseRepository。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Supermarket.API.Persistence.Contexts;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Persistence.Repositories</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public abstract class BaseRepository</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        protected readonly AppDbContext _context;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public BaseRepository(AppDbContext context)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            _context = context;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此类只是我们所有仓储都将继承的<strong>抽象类</strong>。抽象类是没有直接实例的类。您必须创建直接类来创建实例。<br>在BaseRepository接受我们的实例，AppDbContext通过依赖注入暴露了一个受保护的属性称为（只能是由子类访问一个属性）_context，即可以访问我们需要处理数据库操作的所有方法。</p>\n<p>在相同文件夹中添加一个新类CategoryRepository。现在，我们将真正实现仓储逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Microsoft.EntityFrameworkCore;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Repositories;</span><br><span class=\"line\">\tusing Supermarket.API.Persistence.Contexts;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Persistence.Repositories</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class CategoryRepository : BaseRepository, ICategoryRepository</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public CategoryRepository(AppDbContext context) : base(context)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            return await _context.Categories.ToListAsync();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>仓储继承BaseRepository和实现ICategoryRepository。<br>注意实现list方法是很简单的。我们使用Categories数据库集访问类别表，然后调用扩展方法ToListAsync，该方法负责将查询结果转换为类别的集合。</p>\n<p>EF Core <a href=\"https://docs.microsoft.com/en-us/ef/core/querying/overview\" target=\"_blank\" rel=\"noopener\">将我们的方法调用转换为SQL查询</a>，这是最有效的方法。这种方式仅当您调用将数据转换为集合的方法或使用方法获取特定数据时才执行查询。</p>\n<p>现在，我们有了类别控制器，服务和仓储库的代码实现。</p>\n<p>我们将关注点分离开来，创建了只执行应做的事情的类。</p>\n<p>测试应用程序之前的最后一步是使用ASP.NET Core依赖项注入机制将我们的接口绑定到相应的类。</p>\n<h1 id=\"第6步-配置依赖注入\"><a href=\"#第6步-配置依赖注入\" class=\"headerlink\" title=\"第6步-配置依赖注入\"></a><strong>第6步-配置依赖注入</strong></h1><p>现在是时候让您最终了解此概念的工作原理了。</p>\n<p><img src=\"https://uploader.shimo.im/f/GYbYOJqzMqsxEBg3.png!thumbnail\" alt=\"图片\"></p>\n<p>在应用程序的根文件夹中，打开Startup类。此类负责在应用程序启动时配置各种配置。</p>\n<p>该ConfigureServices和Configure方法通过框架管道在运行时调用来配置应用程序应该如何工作，必须使用哪些组件。</p>\n<p>打开ConfigureServices方法。在这里，我们只有一行配置应用程序以使用MVC管道，这基本上意味着该应用程序将使用控制器类来处理请求和响应（在这段代码背后发生了很多事情，但目前您仅需要知道这些）。</p>\n<p>我们可以使用ConfigureServices访问services参数的方法来配置我们的依赖项绑定。清理类代码，删除所有注释并按如下所示更改代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Microsoft.AspNetCore.Builder;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore.Hosting;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore.Mvc;</span><br><span class=\"line\">\tusing Microsoft.EntityFrameworkCore;</span><br><span class=\"line\">\tusing Microsoft.Extensions.Configuration;</span><br><span class=\"line\">\tusing Microsoft.Extensions.DependencyInjection;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Repositories;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services;</span><br><span class=\"line\">\tusing Supermarket.API.Persistence.Contexts;</span><br><span class=\"line\">\tusing Supermarket.API.Persistence.Repositories;</span><br><span class=\"line\">\tusing Supermarket.API.Services;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class Startup</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public IConfiguration Configuration &#123; get; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public Startup(IConfiguration configuration)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            Configuration = configuration;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public void ConfigureServices(IServiceCollection services)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            services.AddDbContext&lt;AppDbContext&gt;(options =&gt; &#123;</span><br><span class=\"line\">\t                options.UseInMemoryDatabase(&quot;supermarket-api-in-memory&quot;);</span><br><span class=\"line\">\t            &#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            services.AddScoped&lt;ICategoryRepository, CategoryRepository&gt;();</span><br><span class=\"line\">\t            services.AddScoped&lt;ICategoryService, CategoryService&gt;();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public void Configure(IApplicationBuilder app, IHostingEnvironment env)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            if (env.IsDevelopment())</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                app.UseDeveloperExceptionPage();</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t            else</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.</span><br><span class=\"line\">\t                app.UseHsts();</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            app.UseHttpsRedirection();</span><br><span class=\"line\">\t            app.UseMvc();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看一下这段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">services.AddDbContext&lt;AppDbContext&gt;(options =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  options.UseInMemoryDatabase(&quot;supermarket-api-in-memory&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们配置数据库上下文。我们告诉ASP.NET Core将其AppDbContext与内存数据库实现一起使用，该实现由作为参数传递给我们方法的字符串标识。通常，在编写<a href=\"https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-2.2\" target=\"_blank\" rel=\"noopener\">集成测试</a>时才会使用内存数据库，但是为了简单起见，我在这里使用了内存数据库。这样，我们无需连接到真实的数据库即可测试应用程序。<br>这些代码行在内部配置我们的数据库上下文，以便使用确定作用域的生存周期进行依赖注入。</p>\n<p>scoped生存周期告诉ASP.NET Core管道，每当它需要解析接收AppDbContext作为构造函数参数的实例的类时，都应使用该类的相同实例。如果内存中没有实例，则管道将创建一个新实例，并在给定请求期间在需要它的所有类中重用它。这样，您无需在需要使用时手动创建类实例。</p>\n<p>如果你想了解其他有关生命周期的知识，可以阅读<a href=\"https://docs.microsoft.com/pt-br/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.2\" target=\"_blank\" rel=\"noopener\">官方文档</a>。</p>\n<p>依赖注入技术为我们提供了许多优势，例如：</p>\n<ul>\n<li>代码可重用性；</li>\n<li>更高的生产力，因为当我们不得不更改实现时，我们无需费心去更改您使用该功能的一百个地方；</li>\n<li>您可以轻松地测试应用程序，因为我们可以使用mock（类的伪实现）隔离必须测试的内容，而我们必须将接口作为构造函数参数进行传递。</li>\n<li>当一个类需要通过构造函数接收更多的依赖关系时，您不必手动更改正在创建实例的所有位置（<strong>太赞了！</strong>）。</li>\n</ul>\n<p>配置数据库上下文之后，我们还将我们的服务和仓储绑定到相应的类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">services.AddScoped&lt;ICategoryRepository, CategoryRepository&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">services.AddScoped&lt;ICategoryService, CategoryService&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们还使用了scoped生存周期，因为这些类在内部必须使用数据库上下文类。在这种情况下，指定相同的范围是有意义的。<br>现在我们配置了依赖绑定，我们必须在Program类上进行一些小的更改，以便数据库正确地初始化种子数据。此步骤仅在使用内存数据库提供程序时才需要执行（请参阅<a href=\"https://github.com/aspnet/EntityFrameworkCore/issues/11666\" target=\"_blank\" rel=\"noopener\">此Github问题</a>以了解原因）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">\tusing System.Collections.Generic;</span><br><span class=\"line\">\tusing System.IO;</span><br><span class=\"line\">\tusing System.Linq;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore.Hosting;</span><br><span class=\"line\">\tusing Microsoft.Extensions.Configuration;</span><br><span class=\"line\">\tusing Microsoft.Extensions.DependencyInjection;</span><br><span class=\"line\">\tusing Microsoft.Extensions.Logging;</span><br><span class=\"line\">\tusing Supermarket.API.Persistence.Contexts;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class Program</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public static void Main(string[] args)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            var host = BuildWebHost(args);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            using(var scope = host.Services.CreateScope())</span><br><span class=\"line\">\t            using(var context = scope.ServiceProvider.GetService&lt;AppDbContext&gt;())</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                context.Database.EnsureCreated();</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            host.Run();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public static IWebHost BuildWebHost(string[] args) =&gt;</span><br><span class=\"line\">\t            WebHost.CreateDefaultBuilder(args)</span><br><span class=\"line\">\t            .UseStartup&lt;Startup&gt;()</span><br><span class=\"line\">\t            .Build();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于我们使用的是内存提供程序，因此有必要更改Main方法 添加“ context.Database.EnsureCreated();”代码以确保在应用程序启动时将“创建”数据库。没有此更改，将不会创建我们想要的初始化种子数据。<br>实现了所有基本功能后，就该测试我们的API端点了。</p>\n<h1 id=\"第7步-测试类别\"><a href=\"#第7步-测试类别\" class=\"headerlink\" title=\"第7步-测试类别\"></a><strong>第7步-测试类别</strong></h1><p>在API根文件夹中打开终端或命令提示符，然后键入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet run</span><br></pre></td></tr></table></figure>\n\n<p>上面的命令启动应用程序。控制台将显示类似于以下内容的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">info: Microsoft.EntityFrameworkCore.Infrastructure[10403]</span><br><span class=\"line\"></span><br><span class=\"line\">Entity Framework Core 2.2.0-rtm-35687 initialized ‘AppDbContext’ using provider ‘Microsoft.EntityFrameworkCore.InMemory’ with options: StoreName=supermarket-api-in-memory</span><br><span class=\"line\"></span><br><span class=\"line\">info: Microsoft.EntityFrameworkCore.Update[30100]</span><br><span class=\"line\"></span><br><span class=\"line\">Saved 2 entities to in-memory store.</span><br><span class=\"line\"></span><br><span class=\"line\">info: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[0]</span><br><span class=\"line\"></span><br><span class=\"line\">User profile is available. Using ‘C:\\Users\\evgomes\\AppData\\Local\\ASP.NET\\DataProtection-Keys’ as key repository and Windows DPAPI to encrypt keys at rest.</span><br><span class=\"line\"></span><br><span class=\"line\">Hosting environment: Development</span><br><span class=\"line\"></span><br><span class=\"line\">Content root path: C:\\Users\\evgomes\\Desktop\\Tutorials\\src\\Supermarket.API</span><br><span class=\"line\"></span><br><span class=\"line\">Now listening on: https://localhost:5001</span><br><span class=\"line\"></span><br><span class=\"line\">Now listening on: http://localhost:5000</span><br><span class=\"line\"></span><br><span class=\"line\">Application started. Press Ctrl+C to shut down.</span><br></pre></td></tr></table></figure>\n\n<p>您可以看到调用了EF Core来初始化数据库。最后几行显示应用程序在哪个端口上运行。<br>打开浏览器，然后导航到 <a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">http</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">:</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">//localhost</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">:</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">5000/api/categories</a> （或控制台输出上显示的URL）。如果您发现由于HTTPS导致的安全错误，则只需为应用程序添加一个例外。</p>\n<p>浏览器将显示以下JSON数据作为输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">     &quot;id&quot;: 100,</span><br><span class=\"line\">     &quot;name&quot;: &quot;Fruits and Vegetables&quot;,</span><br><span class=\"line\">     &quot;products&quot;: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">     &quot;id&quot;: 101,</span><br><span class=\"line\">     &quot;name&quot;: &quot;Dairy&quot;,</span><br><span class=\"line\">     &quot;products&quot;: []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们看到配置数据库上下文时添加到数据库的数据。此输出确认我们的代码正在运行。<br>您使用很少的代码行创建了GET API端点，并且由于当前API项目的架构模式，您的代码结构确实很容易更改。</p>\n<p>现在，该向您展示在由于业务需要而不得不对其进行更改时，更改此代码有多么容易。</p>\n<h1 id=\"步骤8-创建类别资源\"><a href=\"#步骤8-创建类别资源\" class=\"headerlink\" title=\"步骤8-创建类别资源\"></a><strong>步骤8-创建类别资源</strong></h1><p>如果您还记得API端点的规范，您会注意到我们的实际JSON响应还有一个额外的属性：<strong>products数组</strong>。看一下所需响应的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  [</span><br><span class=\"line\">    &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Fruits and Vegetables&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;Breads&quot; &#125;,</span><br><span class=\"line\">    … // Other categories</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>产品数组出现在我们当前的JSON响应中，因为我们的Category模型具有Products，EF Core需要的属性，以正确映射给定类别的产品。<br>我们不希望在响应中使用此属性，但是不能更改模型类以排除此属性。当我们尝试管理类别数据时，这将导致EF Core引发错误，并且也将破坏我们的领域模型设计，因为没有产品的产品类别没有意义。</p>\n<p>要返回仅包含超级市场类别的标识符和名称的JSON数据，我们必须创建一个<strong>资源类</strong>。</p>\n<p><a href=\"https://restful-api-design.readthedocs.io/en/latest/resources.html\" target=\"_blank\" rel=\"noopener\">资源类</a>是一种包含将客户端应用程序和API端点之间进行交换的类型，通常以JSON数据的形式出现，以表示一些特定信息的类。</p>\n<p>来自API端点的所有响应都<strong>必须</strong>返回资源。</p>\n<p>将真实模型表示形式作为响应返回是一种不好的做法，因为它可能包含客户端应用程序不需要或没有其权限的信息（例如，用户模型可以返回用户密码的信息） ，这将是一个很大的安全问题）。</p>\n<p>我们需要一种资源来仅代表我们的类别，而没有产品。</p>\n<p>现在您知道什么是资源，让我们实现它。首先，在命令行中按<strong>Ctrl + C</strong>停止正在运行的应用程序。在应用程序的根文件夹中，创建一个名为Resources的新文件夹。在其中添加一个名为的新类CategoryResource。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace Supermarket.API.Resources</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class CategoryResource</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public int Id &#123; get; set; &#125;</span><br><span class=\"line\">\t        public string Name &#123; get; set; &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们必须将类别服务提供的类别模型集合映射到类别资源集合。<br>我们将使用一个名为<a href=\"https://automapper.org/\" target=\"_blank\" rel=\"noopener\">AutoMapper</a>的库来处理对象之间的映射。AutoMapper是.NET世界中非常流行的库，并且在许多商业和开源项目中使用。</p>\n<p>在命令行中输入以下命令，以将AutoMapper添加到我们的应用程序中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet add package AutoMapper</span><br><span class=\"line\"></span><br><span class=\"line\">dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection</span><br></pre></td></tr></table></figure>\n\n<p>要使用AutoMapper，我们必须做两件事：</p>\n<ul>\n<li>注册它以进行依赖注入；</li>\n<li>创建一个类，该类将告诉AutoMapper如何处理类映射。</li>\n</ul>\n<p>首先，打开Startup课程。在该ConfigureServices方法的最后一行之后，添加以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">services.AddAutoMapper();</span><br></pre></td></tr></table></figure>\n\n<p>此行处理AutoMapper的所有必需配置，例如注册它以进行依赖项注入以及在启动过程中扫描应用程序以配置映射配置文件。<br>现在，在根目录中，添加一个名为的新文件夹Mapping，然后添加一个名为的类ModelToResourceProfile。通过以下方式更改代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using AutoMapper;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Resources;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Mapping</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class ModelToResourceProfile : Profile</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public ModelToResourceProfile()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            CreateMap&lt;Category, CategoryResource&gt;();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该类继承Profile了AutoMapper用于检查我们的映射如何工作的类类型。在构造函数上，我们在Category模型类和CategoryResource类之间创建一个映射。由于类的属性具有相同的名称和类型，因此我们不必为其使用任何特殊的配置。<br>最后一步包括更改类别控制器以使用AutoMapper处理我们的对象映射。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing AutoMapper;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore.Mvc;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services;</span><br><span class=\"line\">\tusing Supermarket.API.Resources;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Controllers</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    [Route(&quot;/api/[controller]&quot;)]</span><br><span class=\"line\">\t    public class CategoriesController : Controller</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        private readonly ICategoryService _categoryService;</span><br><span class=\"line\">\t        private readonly IMapper _mapper;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public CategoriesController(ICategoryService categoryService, IMapper mapper)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            _categoryService = categoryService;</span><br><span class=\"line\">\t            _mapper = mapper;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        [HttpGet]</span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;CategoryResource&gt;&gt; GetAllAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            var categories = await _categoryService.ListAsync();</span><br><span class=\"line\">\t            var resources = _mapper.Map&lt;IEnumerable&lt;Category&gt;, IEnumerable&lt;CategoryResource&gt;&gt;(categories);</span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t            return resources;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我更改了构造函数以接收IMapper实现的实例。您可以使用这些接口方法来使用AutoMapper映射方法。<br>我还更改了GetAllAsync使用Map方法将类别枚举映射到资源枚举的方法。此方法接收我们要映射的类或集合的实例，并通过<a href=\"https://www.geeksforgeeks.org/c-generics-introduction/\" target=\"_blank\" rel=\"noopener\">通用类型定义</a>定义必须映射到什么类型的类或集合。</p>\n<p>注意，我们只需将新的依赖项（IMapper）注入构造函数，就可以轻松地更改实现，而不必修改服务类或仓储。</p>\n<p>依赖注入使您的应用程序可维护且易于更改，因为您不必中断所有代码实现即可添加或删除功能。</p>\n<p>您可能意识到，不仅控制器类，而且所有接收依赖项的类（包括依赖项本身）都会根据绑定配置自动解析为接收正确的类。</p>\n<p>依赖注入如此的Amazing，不是吗？</p>\n<p><img src=\"https://uploader.shimo.im/f/wGoOlHek0agFA3kQ.png!thumbnail\" alt=\"图片\"></p>\n<p>现在，使用dotnet run命令再次启动API，然后转到<a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">http</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">:</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">//localhost</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">:</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">5000/api/categories</a>以查看新的JSON响应。</p>\n<p><img src=\"https://uploader.shimo.im/f/xb8S1G8qcWQW3MSN.png!thumbnail\" alt=\"图片\"></p>\n<p>这是您应该看到的响应数据</p>\n<p>我们已经有了GET端点。现在，让我们为POST（<strong>创建</strong>）类别创建一个新端点。</p>\n<h1 id=\"第9步-创建新类别\"><a href=\"#第9步-创建新类别\" class=\"headerlink\" title=\"第9步-创建新类别\"></a><strong>第9步-创建新类别</strong></h1><p>在处理资源创建时，我们必须关心很多事情，例如：</p>\n<ul>\n<li>数据验证和数据完整性；</li>\n<li>授权创建资源；</li>\n<li>错误处理；</li>\n<li>正在记录。</li>\n</ul>\n<p>在本教程中，我不会显示如何处理身份验证和授权，但是您可以阅读<a href=\"https://medium.com/@evandro.ggomes/json-web-token-authentication-with-asp-net-core-2-0-b074b0cfc870\" target=\"_blank\" rel=\"noopener\">JSON Web令牌身份验证</a>教程，了解如何轻松实现这些功能。</p>\n<p>另外，有一个非常流行的框架称为<strong>ASP.NET Identity</strong>，该框架提供了有关安全性和用户注册的内置解决方案，您可以在应用程序中使用它们。它包括与EF Core配合使用的提供程序，例如IdentityDbContext可以使用的内置程序。您可以<a href=\"https://docs.microsoft.com/en-us/aspnet/identity/overview/getting-started/introduction-to-aspnet-identity\" target=\"_blank\" rel=\"noopener\">在此处了解更多信息</a>。</p>\n<p>让我们编写一个HTTP POST端点，该端点将涵盖其他场景（日志记录除外，它可以根据不同的范围和工具进行更改）。</p>\n<p>在创建新端点之前，我们需要一个新资源。此资源会将客户端应用程序发送到此端点的数据（在本例中为类别名称）映射到我们应用程序的类。</p>\n<p>由于我们正在创建一个新类别，因此我们还没有ID，这意味着我们需要一种资源来表示仅包含其名称的类别。</p>\n<p>在Resources文件夹中，添加一个新类SaveCategoryResource：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.ComponentModel.DataAnnotations;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Resources</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class SaveCategoryResource</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        [Required]</span><br><span class=\"line\">\t        [MaxLength(30)]</span><br><span class=\"line\">\t        public string Name &#123; get; set; &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意Name属性上的Required和MaxLength特性。这些属性称为<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations?view=netframework-4.7.2\" target=\"_blank\" rel=\"noopener\">数据注释</a>。ASP.NET Core管道使用此元数据来验证请求和响应。顾名思义，类别名称是必填项，最大长度为30个字符。<br>现在，让我们定义新API端点的形状。将以下代码添加到类别控制器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpPost]</span><br><span class=\"line\">\tpublic async Task&lt;IActionResult&gt; PostAsync([FromBody] SaveCategoryResource resource)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们使用HttpPost特性告诉框架这是一个HTTP POST端点。<br>注意此方法的响应类型Task<iactionresult>。控制器类中存在的方法称为<strong>动作</strong>，它们具有此签名，因为在应用程序执行动作之后，我们可以返回一个以上的可能结果。</iactionresult></p>\n<p>在这种情况下，如果类别名称无效或出现问题，我们必须返回<strong>400代码（错误请求）</strong>响应，该响应通常包含一条错误消息，客户端应用程序可以使用该错误消息来解决该问题，或者我们可以如果一切正常，则对数据进行<strong>200次响应（成功）</strong>。</p>\n<p>可以将多种类型的操作类型用作响应，但是通常，我们可以使用此接口，并且ASP.NET Core将为此使用默认类。</p>\n<p>该FromBody属性告诉ASP.NET Core将请求正文数据解析为我们的新资源类。这意味着当包含类别名称的JSON发送到我们的应用程序时，框架将自动将其解析为我们的新类。</p>\n<p>现在，让我们实现路由逻辑。我们必须遵循一些步骤才能成功创建新类别：</p>\n<ul>\n<li>首先，我们必须验证传入的请求。如果请求无效，我们必须返回包含错误消息的错误请求响应；</li>\n<li>然后，如果请求有效，则必须使用AutoMapper将新资源映射到类别模型类。</li>\n<li>现在，我们需要调用我们的服务，告诉它保存我们的新类别。如果执行保存逻辑没有问题，它将返回一个包含我们新类别数据的响应。如果没有，它应该给我们一个指示，表明该过程失败了，并可能出现错误消息。</li>\n<li>最后，如果有错误，我们将返回错误的请求。如果没有，我们将新的类别模型映射到类别资源，并向客户端返回包含新类别数据的成功响应。</li>\n</ul>\n<p>这似乎很复杂，但是使用为API构建的服务架构来实现此逻辑确实很容易。</p>\n<p>让我们开始验证传入的请求。</p>\n<h1 id=\"步骤10-使用模型状态验证请求主体\"><a href=\"#步骤10-使用模型状态验证请求主体\" class=\"headerlink\" title=\"步骤10-使用模型状态验证请求主体\"></a><strong>步骤10-使用模型状态验证请求主体</strong></h1><p>ASP.NET Core控制器具有名为ModelState的属性。在执行我们的操作<strong>之前，</strong>该属性在请求执行期间填充。它是ModelStateDictionary的实例，该类包含诸如请求是否有效以及潜在的验证错误消息之类的信息。</p>\n<p>如下更改端点代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpPost]</span><br><span class=\"line\">\tpublic async Task&lt;IActionResult&gt; PostAsync([FromBody] SaveCategoryResource resource)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (!ModelState.IsValid)</span><br><span class=\"line\">\t\t\treturn BadRequest(ModelState.GetErrorMessages());</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码检查模型状态（在这种情况下为请求正文中发送的数据）是否无效，并检查我们的数据注释。如果不是，则API返回错误的请求（状态代码400），以及我们的注释元数据提供的默认错误消息。<br>该ModelState.GetErrorMessages()方法尚未实现。这是一种<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods\" target=\"_blank\" rel=\"noopener\">扩展方法</a>（一种扩展现有类或接口功能的方法），我将实现该方法将验证错误转换为简单的字符串以返回给客户端。</p>\n<p>Extensions在我们的API的根目录中添加一个新文件夹，然后添加一个新类ModelStateExtensions。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Linq;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore.Mvc.ModelBinding;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Extensions</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public static class ModelStateExtensions</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public static List&lt;string&gt; GetErrorMessages(this ModelStateDictionary dictionary)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            return dictionary.SelectMany(m =&gt; m.Value.Errors)</span><br><span class=\"line\">\t                             .Select(m =&gt; m.ErrorMessage)</span><br><span class=\"line\">\t                             .ToList();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所有扩展方法以及声明它们的类都应该是<strong>静态的</strong>。** **这意味着它们不处理特定的实例数据，并且在应用程序启动时仅被加载一次。<br>this参数声明前面的关键字告诉C＃编译器将其视为扩展方法。结果是我们可以像此类的常规方法一样调用它，因为我们在要使用扩展的地方包含的特定的using代码。</p>\n<p>该扩展使用<a href=\"https://www.tutorialsteacher.com/linq/what-is-linq\" target=\"_blank\" rel=\"noopener\">LINQ查询</a>，这是.NET的非常有用的功能，它使我们能够使用链式语法来查询和转换数据。此处的表达式将验证错误方法转换为包含错误消息的字符串列表。</p>\n<p>Supermarket.API.Extensions在进行下一步之前，将名称空间导入Categories控制器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Supermarket.API.Extensions;</span><br></pre></td></tr></table></figure>\n\n<p>让我们通过将新资源映射到类别模型类来继续实现端点逻辑。</p>\n<h1 id=\"步骤11-映射新资源\"><a href=\"#步骤11-映射新资源\" class=\"headerlink\" title=\"步骤11-映射新资源\"></a><strong>步骤11-映射新资源</strong></h1><p>我们已经定义了映射配置文件，可以将模型转换为资源。现在，我们需要一个与之相反的新配置项。</p>\n<p>ResourceToModelProfile在Mapping文件夹中添加一个新类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using AutoMapper;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Resources;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Mapping</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class ResourceToModelProfile : Profile</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public ResourceToModelProfile()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            CreateMap&lt;SaveCategoryResource, Category&gt;();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里没有新内容。由于依赖注入的魔力，AutoMapper将在应用程序启动时自动注册此配置文件，而我们无需更改任何其他位置即可使用它。<br>现在，我们可以将新资源映射到相应的模型类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpPost]</span><br><span class=\"line\">\tpublic async Task&lt;IActionResult&gt; PostAsync([FromBody] SaveCategoryResource resource)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (!ModelState.IsValid)</span><br><span class=\"line\">\t\t\treturn BadRequest(ModelState.GetErrorMessages());</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar category = _mapper.Map&lt;SaveCategoryResource, Category&gt;(resource);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第12步-应用请求-响应模式来处理保存逻辑\"><a href=\"#第12步-应用请求-响应模式来处理保存逻辑\" class=\"headerlink\" title=\"第12步-应用请求-响应模式来处理保存逻辑\"></a><strong>第12步-应用请求-响应模式来处理保存逻辑</strong></h1><p>现在我们必须实现最有趣的逻辑：保存一个新类别。我们希望我们的服务能够做到。</p>\n<p>由于连接到数据库时出现问题，或者由于任何内部业务规则使我们的数据无效，因此保存逻辑可能会失败。</p>\n<p>如果出现问题，我们不能简单地抛出一个错误，因为它可能会停止API，并且客户端应用程序也不知道如何处理该问题。另外，我们可能会有某种日志记录机制来记录错误。</p>\n<p>保存方法的约定（即方法的签名和响应类型）需要指示我们是否正确执行了该过程。如果处理正常，我们将接收类别数据。如果没有，我们至少必须收到一条错误消息，告诉您该过程失败的原因。</p>\n<p>我们可以通过应用<strong>request-response模式</strong>来实现此功能。这种企业设计模式将我们的请求和响应参数封装到类中，以封装我们的服务将用于处理某些任务并将信息返回给正在使用该服务的类的信息。</p>\n<p>这种模式为我们提供了一些优势，例如：</p>\n<ul>\n<li>如果我们需要更改服务以接收更多参数，则不必破坏其签名；</li>\n<li>我们可以为我们的请求和/或响应定义标准合同；</li>\n<li>我们可以在不停止应用程序流程的情况下处理业务逻辑和潜在的失败，并且我们不需要使用大量的try-catch块。</li>\n</ul>\n<p>让我们为处理数据更改的服务方法创建一个标准响应类型。对于这种类型的每个请求，我们都想知道该请求是否被正确执行。如果失败，我们要向客户端返回错误消息。</p>\n<p>在Domain文件夹的内部Services，添加一个名为的新目录Communication。在此处添加一个名为的新类BaseResponse。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace Supermarket.API.Domain.Services.Communication</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public abstract class BaseResponse</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public bool Success &#123; get; protected set; &#125;</span><br><span class=\"line\">\t        public string Message &#123; get; protected set; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public BaseResponse(bool success, string message)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            Success = success;</span><br><span class=\"line\">\t            Message = message;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那是我们的响应类型将继承的抽象类。<br>抽象定义了一个Success属性和一个Message属性，该属性将告知请求是否已成功完成，如果失败，该属性将显示错误消息。</p>\n<p>请注意，这些属性是必需的，只有继承的类才能设置此数据，因为子类必须通过构造函数传递此信息。</p>\n<blockquote>\n<p><strong>提示：</strong>为所有内容定义基类不是一个好习惯，因为<a href=\"https://en.wikipedia.org/wiki/Fragile_base_class\" target=\"_blank\" rel=\"noopener\">基类会耦合您的代码</a>并阻止您轻松对其进行修改。优先使用<a href=\"https://medium.com/humans-create-software/composition-over-inheritance-cb6f88070205\" target=\"_blank\" rel=\"noopener\">组合而不是继承</a>。</p>\n<blockquote>\n<p>在此API的范围内，使用基类并不是真正的问题，因为我们的服务不会增长太多。如果您意识到服务或应用程序会经常增长和更改，请避免使用基类。</p>\n</blockquote>\n</blockquote>\n<p>现在，在同一文件夹中，添加一个名为的新类SaveCategoryResponse。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Supermarket.API.Domain.Models;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Services.Communication</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class SaveCategoryResponse : BaseResponse</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public Category Category &#123; get; private set; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        private SaveCategoryResponse(bool success, string message, Category category) : base(success, message)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            Category = category;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        /// &lt;summary&gt;</span><br><span class=\"line\">\t        /// Creates a success response.</span><br><span class=\"line\">\t        /// &lt;/summary&gt;</span><br><span class=\"line\">\t        /// &lt;param name=&quot;category&quot;&gt;Saved category.&lt;/param&gt;</span><br><span class=\"line\">\t        /// &lt;returns&gt;Response.&lt;/returns&gt;</span><br><span class=\"line\">\t        public SaveCategoryResponse(Category category) : this(true, string.Empty, category)</span><br><span class=\"line\">\t        &#123; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        /// &lt;summary&gt;</span><br><span class=\"line\">\t        /// Creates am error response.</span><br><span class=\"line\">\t        /// &lt;/summary&gt;</span><br><span class=\"line\">\t        /// &lt;param name=&quot;message&quot;&gt;Error message.&lt;/param&gt;</span><br><span class=\"line\">\t        /// &lt;returns&gt;Response.&lt;/returns&gt;</span><br><span class=\"line\">\t        public SaveCategoryResponse(string message) : this(false, message, null)</span><br><span class=\"line\">\t        &#123; &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>响应类型还设置了一个Category属性，如果请求成功完成，该属性将包含我们的类别数据。<br>请注意，我为此类定义了三种不同的构造函数：</p>\n<ul>\n<li>一个私有的，它将把成功和消息参数传递给基类，并设置Category属性。</li>\n<li>仅接收类别作为参数的构造函数。这将创建一个成功的响应，调用私有构造函数来设置各自的属性；</li>\n<li>第三个构造函数仅指定消息。这将用于创建故障响应。</li>\n</ul>\n<p>因为C＃支持多个构造函数，所以我们仅通过使用不同的构造函数就简化了响应的创建过程，而无需定义其他方法来处理此问题。</p>\n<p>现在，我们可以更改服务界面以添加新的保存方法合同。</p>\n<p>更改ICategoryService接口，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services.Communication;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Services</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public interface ICategoryService</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t         Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class=\"line\">\t         Task&lt;SaveCategoryResponse&gt; SaveAsync(Category category);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们只需将类别传递给此方法，它将处理保存模型数据，编排仓储和其他必要服务所需的所有逻辑。<br>请注意，由于我们不需要任何其他参数来执行此任务，因此我不在此处创建特定的请求类。<a href=\"https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle\" target=\"_blank\" rel=\"noopener\">计算机编程中</a>有一个名为<a href=\"https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle\" target=\"_blank\" rel=\"noopener\">KISS</a>的<a href=\"https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle\" target=\"_blank\" rel=\"noopener\">概念</a> —Keep It Simple，Stupid的简称。基本上，它说您应该使您的应用程序尽可能简单。</p>\n<p>设计应用程序时请记住这一点：<strong>仅</strong>应用<strong>解决问题所需的内容</strong>。<strong>不要过度设计您的应用程序。</strong></p>\n<p>现在我们可以完成端点逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpPost]</span><br><span class=\"line\">\tpublic async Task&lt;IActionResult&gt; PostAsync([FromBody] SaveCategoryResource resource)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (!ModelState.IsValid)</span><br><span class=\"line\">\t\t\treturn BadRequest(ModelState.GetErrorMessages());</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar category = _mapper.Map&lt;SaveCategoryResource, Category&gt;(resource);</span><br><span class=\"line\">\t\tvar result = await _categoryService.SaveAsync(category);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (!result.Success)</span><br><span class=\"line\">\t\t\treturn BadRequest(result.Message);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar categoryResource = _mapper.Map&lt;Category, CategoryResource&gt;(result.Category);</span><br><span class=\"line\">\t\treturn Ok(categoryResource);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在验证请求数据并将资源映射到我们的模型之后，我们将其传递给我们的服务以保留数据。<br>如果失败，则API返回错误的请求。如果没有，API会将新类别（现在包括诸如new的数据Id）映射到我们先前创建的类别CategoryResource，并将其发送给客户端。</p>\n<p>现在，让我们为服务实现真正的逻辑。</p>\n<p><strong>第13步—数据库逻辑和工作单元模式</strong></p>\n<p>由于我们要将数据持久化到数据库中，因此我们需要在仓储中使用一种新方法。</p>\n<p>向ICategoryRepository接口添加AddAsync新方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ICategoryRepository</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class=\"line\">\t\t Task AddAsync(Category category);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，让我们在真正的仓储类中实现此方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CategoryRepository : BaseRepository, ICategoryRepository</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpublic CategoryRepository(AppDbContext context) : base(context)</span><br><span class=\"line\">\t\t&#123; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublic async Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync()</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\treturn await _context.Categories.ToListAsync();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublic async Task AddAsync(Category category)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tawait _context.Categories.AddAsync(category);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们只是在集合中添加一个新类别。<br>当我们向中添加类时DBSet&lt;&gt;，EF Core将开始跟踪模型发生的所有更改，并在当前状态下使用此数据生成将插入，更新或删除模型的查询。</p>\n<p>当前的实现只是将模型添加到我们的集合中，但是<strong>我们的数据仍然不会保存</strong>。</p>\n<p>在上下文类中提供了SaveChanges的方法，我们必须调用该方法才能真正将查询执行到数据库中。我之所以没有在这里调用它，是因为<a href=\"https://programmingwithmosh.com/entity-framework/common-mistakes-with-the-repository-pattern/\" target=\"_blank\" rel=\"noopener\">仓储不应该持久化数据</a>，它只是一种内存集合对象。</p>\n<p>即使在经验丰富的.NET开发人员之间，该主题也引起很大争议，但是让我向您解释为什么您不应该在仓储类中调用SaveChanges方法。</p>\n<p>我们可以从概念上将仓储像.NET框架中存在的任何其他集合一样。在.NET（和许多其他编程语言，例如Javascript和Java）中处理集合时，通常可以：</p>\n<ul>\n<li>向其中添加新项（例如，当您将数据推送到列表，数组和字典时）；</li>\n<li>查找或过滤项目；</li>\n<li>从集合中删除一个项目；</li>\n<li>替换给定的项目，或更新它。</li>\n</ul>\n<p>想一想现实世界中的清单。想象一下，您正在编写一份购物清单以在超市购买东西（<em>巧合，不是吗？</em>）。</p>\n<p>在列表中，写下您需要购买的所有水果。您可以将水果添加到此列表中，如果放弃购买就删除水果，也可以替换水果的名称。但是您无法<strong>将</strong>水果<strong>保存</strong>到列表中。用简单的英语说这样的话是没有意义的。</p>\n<blockquote>\n<p><strong>提示：</strong>在使用面向对象的编程语言设计类和接口时，请尝试使用自然语言来检查您所做的工作是否正确。</p>\n<blockquote>\n<p>例如，说人实现了person的接口是有道理的，但是说一个人实现了一个帐户却没有道理。</p>\n</blockquote>\n</blockquote>\n<p>如果您要“保存”水果清单（在这种情况下，要购买所有水果），请付款，然后超市会处理库存数据以检查他们是否必须从供应商处购买更多水果。</p>\n<p>编程时可以应用相同的逻辑。仓储不应保存，更新或删除数据。相反，他们应该将其委托给其他类来处理此逻辑。</p>\n<p>将数据直接保存到仓储中时，还有另一个问题：<strong>您不能使用transaction</strong>。</p>\n<p>想象一下，我们的应用程序具有一种日志记录机制，该机制存储一些用户名，并且每次对API数据进行更改时都会执行操作。</p>\n<p>现在想象一下，由于某种原因，您调用了一个更新用户名的服务（这是不常见的情况，但让我们考虑一下）。</p>\n<p>您同意要更改虚拟用户表中的用户名，首先必须更新所有日志以正确告诉谁执行了该操作，对吗？</p>\n<p>现在想象我们已经为用户和不同仓储中的日志实现了update方法，它们都调用了SaveChanges。如果这些方法之一在更新过程中失败，会发生什么？最终会导致数据不一致。</p>\n<p>只有在一切完成之后，我们才应该将更改保存到数据库中。为此，我们必须使用<a href=\"https://en.wikipedia.org/wiki/Database_transaction\" target=\"_blank\" rel=\"noopener\">transaction</a>，这基本上是大多数数据库实现的功能，只有在完成复杂的操作后才能保存数据。</p>\n<p><em>“-好的，所以如果我们不能在这里保存东西，我们应该在哪里做？”</em></p>\n<p>处理此问题的常见模式是<a href=\"https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application\" target=\"_blank\" rel=\"noopener\">工作单元模式</a>。此模式包含一个类，该类将我们的AppDbContext实例作为依赖项接收，并公开用于开始，完成或中止事务的方法。</p>\n<p>在这里，我们将使用工作单元的简单实现来解决我们的问题。</p>\n<p>Repositories在Domain层的仓储文件夹Repositories内添加一个新接口IUnitOfWork：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Repositories</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public interface IUnitOfWork</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t         Task CompleteAsync();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如您所见，它仅公开一种将异步完成数据管理操作的方法。<br>现在让我们添加实际的实现。</p>\n<p>在Persistence层RepositoriesRepositories文件夹中的添加一个名为的UnitOfWork的新类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Repositories;</span><br><span class=\"line\">\tusing Supermarket.API.Persistence.Contexts;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Persistence.Repositories</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class UnitOfWork : IUnitOfWork</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        private readonly AppDbContext _context;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public UnitOfWork(AppDbContext context)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            _context = context;     </span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public async Task CompleteAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            await _context.SaveChangesAsync();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个简单，干净的实现，仅在使用仓储修改完所有更改后，才将所有更改保存到数据库中。<br>如果研究工作单元模式的实现，则会发现实现回滚操作的更复杂的模式。</p>\n<p>由于<strong>EF Core已经在后台实现了仓储模式和工作单元</strong>，因此我们不必在意回滚方法。</p>\n<p><em>“ - 什么？那么为什么我们必须创建所有这些接口和类？”</em></p>\n<p>将持久性逻辑与业务规则分开在代码可重用性和维护方面具有许多优势。如果直接使用EF Core，我们最终将拥有更复杂的类，这些类将很难更改。</p>\n<p>想象一下，将来您决定将ORM框架更改为其他框架，例如<a href=\"https://www.c-sharpcorner.com/article/crud-operation-in-asp-net-core-2-0-using-dapper-orm/\" target=\"_blank\" rel=\"noopener\">Dapper</a>，或者由于性能而必须实施纯SQL查询。如果将查询逻辑与服务耦合在一起，将很难更改该逻辑，因为您必须在许多类中进行此操作。</p>\n<p>使用仓储模式，您可以简单地实现一个新的仓储类并使用依赖注入将其绑定。</p>\n<p>因此，基本上，如果您直接在服务中使用EF Core，并且必须进行一些更改，那么您将获得：</p>\n<p>就像我说的那样，EF Core在后台实现了工作单元和仓储模式。我们可以将DbSet&lt;&gt;属性视为仓储。而且，SaveChanges仅在所有数据库操作成功的情况下才保留数据。</p>\n<p>现在，您知道什么是工作单元以及为什么将其与仓储一起使用，让我们实现真实服务的逻辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CategoryService : ICategoryService</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tprivate readonly ICategoryRepository _categoryRepository;</span><br><span class=\"line\">\t\tprivate readonly IUnitOfWork _unitOfWork;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublic CategoryService(ICategoryRepository categoryRepository, IUnitOfWork unitOfWork)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_categoryRepository = categoryRepository;</span><br><span class=\"line\">\t\t\t_unitOfWork = unitOfWork;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublic async Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync()</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\treturn await _categoryRepository.ListAsync();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublic async Task&lt;SaveCategoryResponse&gt; SaveAsync(Category category)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttry</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tawait _categoryRepository.AddAsync(category);</span><br><span class=\"line\">\t\t\t\tawait _unitOfWork.CompleteAsync();</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t\treturn new SaveCategoryResponse(category);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcatch (Exception ex)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t// Do some logging stuff</span><br><span class=\"line\">\t\t\t\treturn new SaveCategoryResponse($&quot;An error occurred when saving the category: &#123;ex.Message&#125;&quot;);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>多亏了我们的解耦架构，我们可以简单地将实例UnitOfWork作为此类的依赖传递。<br>我们的业务逻辑非常简单。</p>\n<p>首先，我们尝试将新类别添加到数据库中，然后API尝试保存新类别，将所有内容包装在try-catch块中。</p>\n<p>如果失败，则API会调用一些虚构的日志记录服务，并返回指示失败的响应。</p>\n<p>如果该过程顺利完成，则应用程序将返回成功响应，并发送我们的类别数据。简单吧？</p>\n<blockquote>\n<p><strong>提示：</strong>在现实世界的应用程序中，您不应将所有内容包装在通用的try-catch块中，而应分别处理所有可能的错误。</p>\n<blockquote>\n<p>简单地添加一个try-catch块并不能解决大多数可能的失败情况。请确保正确实现错误处理。</p>\n</blockquote>\n</blockquote>\n<p>测试我们的API之前的最后一步是将工作单元接口绑定到其各自的类。</p>\n<p>将此新行添加到类的ConfigureServices方法中Startup：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">services.AddScoped&lt;IUnitOfWork, UnitOfWork&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>现在让我们测试一下！<br><strong>第14步-使用Postman测试我们的POST端点</strong></p>\n<p>重新启动我们的应用程序dotnet run。</p>\n<p>我们无法使用浏览器测试POST端点。让我们使用<strong>Postman</strong>测试我们的端点。这是测试RESTful API的非常有用的工具。</p>\n<p>打开<strong>Postman</strong>，然后关闭介绍性消息。您会看到这样的屏幕：</p>\n<p><img src=\"https://uploader.shimo.im/f/k9uqO0tzHP8sXyGu.png!thumbnail\" alt=\"图片\"></p>\n<p>屏幕显示测试端点的选项</p>\n<p>GET默认情况下，将所选内容更改为选择框POST。</p>\n<p>在Enter request URL字段中输入API地址。</p>\n<p>我们必须提供请求正文数据以发送到我们的API。单击Body菜单项，然后将其下方显示的选项更改为raw。</p>\n<p>Postman将在右侧显示一个Text选项，将其更改为JSON (application/json)并粘贴以下JSON数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://uploader.shimo.im/f/aMktVnVAavwvF3Q3.png!thumbnail\" alt=\"图片\">发送请求前的屏幕</p>\n<p>如您所见，我们将向我们的新端点发送一个空的名称字符串。</p>\n<p>点击Send按钮。您将收到如下输出：</p>\n<p><img src=\"https://uploader.shimo.im/f/5yuSjCfYKD0ELqiA.png!thumbnail\" alt=\"图片\"></p>\n<p>如您所见，我们的验证逻辑有效！</p>\n<p>您还记得我们为端点创建的验证逻辑吗？此输出是它起作用的证明！</p>\n<p>还要注意右侧显示的400状态代码。该BadRequest结果自动将此状态码的响应。</p>\n<p>现在，让我们将JSON数据更改为有效数据，以查看新的响应：</p>\n<p><img src=\"https://uploader.shimo.im/f/zDpJNG3Yl8Q0XimL.png!thumbnail\" alt=\"图片\"></p>\n<p>最后，我们期望得到的结果</p>\n<p>API正确创建了我们的新资源。</p>\n<p>到目前为止，我们的API可以列出和创建类别。您学到了很多有关C＃语言，ASP.NET Core框架以及构造API的通用设计方法的知识。</p>\n<p>让我们继续我们的类别API，创建用于更新类别的端点。</p>\n<p>从现在开始，由于我向您解释了大多数概念，因此我将加快解释速度，并专注于新主题，以免浪费您的时间。 Let’s go!</p>\n<h1 id=\"第15步-更新类别\"><a href=\"#第15步-更新类别\" class=\"headerlink\" title=\"第15步-更新类别\"></a><strong>第15步-更新类别</strong></h1><p>要更新类别，我们需要一个HTTP PUT端点。</p>\n<p>我们必须编写的逻辑与POST逻辑非常相似：</p>\n<ul>\n<li>首先，我们必须使用来验证传入的请求ModelState。</li>\n<li>如果请求有效，则API应使用AutoMapper将传入资源映射到模型类。</li>\n<li>然后，我们需要调用我们的服务，告诉它更新类别，提供相应的类别Id和更新的数据；</li>\n<li>如果Id数据库中没有给定的类别，我们将返回错误的请求。我们可以使用NotFound结果来代替，但是对于这个范围而言，这并不重要，因为我们向客户端应用程序提供了错误消息。</li>\n<li>如果正确执行了保存逻辑，则服务必须返回包含更新的类别数据的响应。如果不是，它应该给我们指示该过程失败，并显示一条消息指示原因；</li>\n<li>最后，如果有错误，则API返回错误的请求。如果不是，它将更新的类别模型映射到类别资源，并将成功响应返回给客户端应用程序。</li>\n</ul>\n<p>让我们将新PutAsync方法添加到控制器类中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpPut(&quot;&#123;id&#125;&quot;)]</span><br><span class=\"line\">\tpublic async Task&lt;IActionResult&gt; PutAsync(int id, [FromBody] SaveCategoryResource resource)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (!ModelState.IsValid)</span><br><span class=\"line\">\t\t\treturn BadRequest(ModelState.GetErrorMessages());</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar category = _mapper.Map&lt;SaveCategoryResource, Category&gt;(resource);</span><br><span class=\"line\">\t\tvar result = await _categoryService.UpdateAsync(id, category);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (!result.Success)</span><br><span class=\"line\">\t\t\treturn BadRequest(result.Message);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar categoryResource = _mapper.Map&lt;Category, CategoryResource&gt;(result.Category);</span><br><span class=\"line\">\t\treturn Ok(categoryResource);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果将其与POST逻辑进行比较，您会注意到这里只有一个区别：HttPut属性指定给定路由应接收的参数。<br>我们将调用此端点，将类别指定Id 为最后一个URL片段，例如/api/categories/1。ASP.NET Core管道将此片段解析为相同名称的参数。</p>\n<p>现在我们必须UpdateAsync在ICategoryService接口中定义方法签名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ICategoryService</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tTask&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class=\"line\">\t\tTask&lt;SaveCategoryResponse&gt; SaveAsync(Category category);</span><br><span class=\"line\">\t\tTask&lt;SaveCategoryResponse&gt; UpdateAsync(int id, Category category);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在让我们转向真正的逻辑。</p>\n<h1 id=\"第16步-更新逻辑\"><a href=\"#第16步-更新逻辑\" class=\"headerlink\" title=\"第16步-更新逻辑\"></a><strong>第16步-更新逻辑</strong></h1><p>首先，要更新类别，我们需要从数据库中返回当前数据（如果存在）。我们还需要将其更新到我们的中DBSet&lt;&gt;。</p>\n<p>让我们在ICategoryService界面中添加两个新的方法约定：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ICategoryRepository</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tTask&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class=\"line\">\t\tTask AddAsync(Category category);</span><br><span class=\"line\">\t\tTask&lt;Category&gt; FindByIdAsync(int id);</span><br><span class=\"line\">\t\tvoid Update(Category category);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们已经定义了FindByIdAsync方法，该方法将从数据库中异步返回一个类别，以及该Update方法。请注意，该Update方法不是异步的，因为EF Core API不需要异步方法来更新模型。<br>现在，让我们在CategoryRepository类中实现真正的逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public async Task&lt;Category&gt; FindByIdAsync(int id)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn await _context.Categories.FindAsync(id);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void Update(Category category)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t_context.Categories.Update(category);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们可以对服务逻辑进行编码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public async Task&lt;SaveCategoryResponse&gt; UpdateAsync(int id, Category category)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvar existingCategory = await _categoryRepository.FindByIdAsync(id);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (existingCategory == null)</span><br><span class=\"line\">\t\t\treturn new SaveCategoryResponse(&quot;Category not found.&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\texistingCategory.Name = category.Name;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttry</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_categoryRepository.Update(existingCategory);</span><br><span class=\"line\">\t\t\tawait _unitOfWork.CompleteAsync();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\treturn new SaveCategoryResponse(existingCategory);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcatch (Exception ex)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t// Do some logging stuff</span><br><span class=\"line\">\t\t\treturn new SaveCategoryResponse($&quot;An error occurred when updating the category: &#123;ex.Message&#125;&quot;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>API尝试从数据库中获取类别。如果结果为null，我们将返回一个响应，告知该类别不存在。如果类别存在，我们需要设置其新名称。<br>然后，API会尝试保存更改，例如创建新类别时。如果该过程完成，则该服务将返回成功响应。如果不是，则执行日志记录逻辑，并且端点接收包含错误消息的响应。</p>\n<p>现在让我们对其进行测试。首先，让我们添加一个新类别Id以使用有效类别。我们可以使用播种到数据库中的类别的标识符，但是我想通过这种方式向您展示我们的API将更新正确的资源。</p>\n<p>再次运行该应用程序，然后使用Postman将新类别发布到数据库中：</p>\n<p><img src=\"https://uploader.shimo.im/f/fxIzjvpz7Y0kf8XP.png!thumbnail\" alt=\"图片\"></p>\n<p>添加新类别以供日后更新</p>\n<p>使用一个可用的数据Id，将POST 选项更改PUT为选择框，然后在URL的末尾添加ID值。将name属性更改为其他名称，然后发送请求以检查结果：</p>\n<p><img src=\"https://uploader.shimo.im/f/VMXmxLVsZNsqqXSK.png!thumbnail\" alt=\"图片\"></p>\n<p>类别数据已成功更新</p>\n<p>您可以将GET请求发送到API端点，以确保您正确编辑了类别名称：</p>\n<p><img src=\"https://uploader.shimo.im/f/G5ipYxpQk5gJSVBI.png!thumbnail\" alt=\"图片\"></p>\n<p>那是现在GET请求的结果</p>\n<p>我们必须对类别执行的最后一项操作是排除类别。让我们创建一个HTTP Delete端点。</p>\n<h1 id=\"第17步-删除类别\"><a href=\"#第17步-删除类别\" class=\"headerlink\" title=\"第17步-删除类别\"></a><strong>第17步-删除类别</strong></h1><p>删除类别的逻辑确实很容易实现，因为我们所需的大多数方法都是先前构建的。</p>\n<p>这些是我们工作路线的必要步骤：</p>\n<ul>\n<li>API需要调用我们的服务，告诉它删除我们的类别，并提供相应的Id;</li>\n<li>如果数据库中没有具有给定ID的类别，则该服务应返回一条消息指出该类别；</li>\n<li>如果执行删除逻辑没有问题，则服务应返回包含我们已删除类别数据的响应。如果没有，它应该给我们一个指示，表明该过程失败了，并可能出现错误消息。</li>\n<li>最后，如果有错误，则API返回错误的请求。如果不是，则API会将更新的类别映射到资源，并向客户端返回成功响应。</li>\n</ul>\n<p>让我们开始添加新的端点逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpDelete(&quot;&#123;id&#125;&quot;)]</span><br><span class=\"line\">\tpublic async Task&lt;IActionResult&gt; DeleteAsync(int id)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvar result = await _categoryService.DeleteAsync(id);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (!result.Success)</span><br><span class=\"line\">\t\t\treturn BadRequest(result.Message);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar categoryResource = _mapper.Map&lt;Category, CategoryResource&gt;(result.Category);</span><br><span class=\"line\">\t\treturn Ok(categoryResource);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该HttpDelete属性还定义了一个id 模板。<br>在将DeleteAsync签名添加到我们的ICategoryService接口之前，我们需要做一些小的重构。</p>\n<p>新的服务方法必须返回包含类别数据的响应，就像对PostAsyncand UpdateAsync方法所做的一样。我们可以SaveCategoryResponse为此目的重用，但在这种情况下我们不会保存数据。</p>\n<p>为了避免创建具有相同形状的新类来满足此要求，我们可以将我们重命名SaveCategoryResponse为CategoryResponse。</p>\n<p>如果您使用的是Visual Studio Code，则可以打开SaveCategoryResponse类，将鼠标光标放在类名上方，然后使用选项Change All Occurrences<strong>* *</strong>来重命名该类：</p>\n<p><img src=\"https://uploader.shimo.im/f/9F3zYANcrMUdFlMe.png!thumbnail\" alt=\"图片\"></p>\n<p>确保也重命名文件名。</p>\n<p>让我们将DeleteAsync方法签名添加到ICategoryService 接口中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ICategoryService</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tTask&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class=\"line\">\t\tTask&lt;CategoryResponse&gt; SaveAsync(Category category);</span><br><span class=\"line\">\t\tTask&lt;CategoryResponse&gt; UpdateAsync(int id, Category category);</span><br><span class=\"line\">\t\tTask&lt;CategoryResponse&gt; DeleteAsync(int id);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在实施删除逻辑之前，我们需要在仓储中使用一种新方法。<br>将Remove方法签名添加到ICategoryRepository接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Remove(Category category);</span><br></pre></td></tr></table></figure>\n\n<p>现在，在仓储类上添加真正的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void Remove(Category category)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t_context.Categories.Remove(category);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>EF Core要求将模型的实例传递给Remove方法，以正确了解我们要删除的模型，而不是简单地传递Id。<br>最后，让我们在CategoryService类上实现逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public async Task&lt;CategoryResponse&gt; DeleteAsync(int id)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvar existingCategory = await _categoryRepository.FindByIdAsync(id);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (existingCategory == null)</span><br><span class=\"line\">\t\t\treturn new CategoryResponse(&quot;Category not found.&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttry</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_categoryRepository.Remove(existingCategory);</span><br><span class=\"line\">\t\t\tawait _unitOfWork.CompleteAsync();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\treturn new CategoryResponse(existingCategory);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcatch (Exception ex)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t// Do some logging stuff</span><br><span class=\"line\">\t\t\treturn new CategoryResponse($&quot;An error occurred when deleting the category: &#123;ex.Message&#125;&quot;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里没有新内容。该服务尝试通过ID查找类别，然后调用我们的仓储以删除类别。最后，工作单元完成将实际操作执行到数据库中的事务。<br><em>“-嘿，但是每个类别的产品呢？为避免出现错误，您是否不需要先创建仓储并删除产品？”</em></p>\n<p>答案是<strong>否定的</strong>。借助<a href=\"https://docs.microsoft.com/en-us/ef/core/querying/tracking\" target=\"_blank\" rel=\"noopener\">EF Core跟踪机制</a>，当我们从数据库中加载模型时，框架便知道了该模型具有哪些关系。如果我们删除它，EF Core知道它应该首先递归删除所有相关模型。</p>\n<p>在将类映射到数据库表时，我们可以禁用此功能，但这在本教程的范围之外。如果您想了解此功能，<a href=\"https://entityframeworkcore.com/saving-data-cascade-delete\" target=\"_blank\" rel=\"noopener\">请看这里</a>。</p>\n<p>现在是时候测试我们的新端点了。再次运行该应用程序，并使用Postman发送DELETE请求，如下所示：</p>\n<p><img src=\"https://uploader.shimo.im/f/VRCjsPelqx4qADIx.png!thumbnail\" alt=\"图片\"></p>\n<p>如您所见，API毫无问题地删除了现有类别</p>\n<p>我们可以通过发送GET请求来检查我们的API是否正常工作：</p>\n<p><img src=\"https://uploader.shimo.im/f/iyiKvuB7e0IfSTQf.png!thumbnail\" alt=\"图片\">我们已经完成了类别API。现在是时候转向产品API。</p>\n<h1 id=\"步骤18-产品API\"><a href=\"#步骤18-产品API\" class=\"headerlink\" title=\"步骤18-产品API\"></a><strong>步骤18-产品API</strong></h1><p>到目前为止，您已经学习了如何实现所有基本的HTTP动词来使用ASP.NET Core处理CRUD操作。让我们进入实现产品API的下一个层次。</p>\n<p>我将不再详细介绍所有HTTP动词，因为这将是详尽无遗的。在本教程的最后一部分，我将仅介绍GET请求，以向您展示在从数据库查询数据时如何包括相关实体，以及如何使用Description我们为EUnitOfMeasurement 枚举值定义的属性。</p>\n<p>将新控制器ProductsController添加到名为Controllers的文件夹中。</p>\n<p>在这里编写任何代码之前，我们必须创建产品资源。</p>\n<p>让我刷新您的记忆，再次显示我们的资源应如何：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   &quot;id&quot;: 1,</span><br><span class=\"line\">   &quot;name&quot;: &quot;Sugar&quot;,</span><br><span class=\"line\">   &quot;quantityInPackage&quot;: 1,</span><br><span class=\"line\">   &quot;unitOfMeasurement&quot;: &quot;KG&quot;</span><br><span class=\"line\">   &quot;category&quot;: &#123;</span><br><span class=\"line\">   &quot;id&quot;: 3,</span><br><span class=\"line\">   &quot;name&quot;: &quot;Sugar&quot;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  … // Other products</span><br><span class=\"line\"> ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们想要一个包含数据库中所有产品的JSON数组。<br>JSON数据与产品模型有两点不同：</p>\n<ul>\n<li>测量单位以较短的方式显示，仅显示其缩写。</li>\n<li>我们输出类别数据<strong>而不</strong>包括CategoryId属性。</li>\n</ul>\n<p>为了表示度量单位，我们可以使用简单的字符串属性代替枚举类型（顺便说一下，我们没有JSON数据的默认枚举类型，因此我们必须将其转换为其他类型）。</p>\n<p>现在，我们现在要塑造新资源，让我们创建它。ProductResource在Resources文件夹中添加一个新类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace Supermarket.API.Resources</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class ProductResource</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public int Id &#123; get; set; &#125;</span><br><span class=\"line\">\t        public string Name &#123; get; set; &#125;</span><br><span class=\"line\">\t        public int QuantityInPackage &#123; get; set; &#125;</span><br><span class=\"line\">\t        public string UnitOfMeasurement &#123; get; set; &#125;</span><br><span class=\"line\">\t        public CategoryResource Category &#123;get;set;&#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们必须配置模型类和新资源类之间的映射。<br>映射配置将与用于其他映射的配置几乎相同，但是在这里，我们必须处理将EUnitOfMeasurement枚举转换为字符串的操作。</p>\n<p>您还记得StringValue应用于枚举类型的属性吗？现在，我将向您展示如何使用.NET框架的强大功能：<a href=\"https://www.tutorialspoint.com/csharp/csharp_reflection.htm\" target=\"_blank\" rel=\"noopener\">反射 API</a>提取此信息。</p>\n<p>反射 API是一组强大的资源工具集，可让我们提取和操作元数据。许多框架和库（包括ASP.NET Core本身）都利用这些资源来处理许多后台工作。</p>\n<p>现在让我们看看它在实践中是如何工作的。将新类添加到Extensions名为的文件夹中EnumExtensions。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.ComponentModel;</span><br><span class=\"line\">\tusing System.Reflection;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Extensions</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public static class EnumExtensions</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public static string ToDescriptionString&lt;TEnum&gt;(this TEnum @enum)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            FieldInfo info = @enum.GetType().GetField(@enum.ToString());</span><br><span class=\"line\">\t            var attributes = (DescriptionAttribute[])info.GetCustomAttributes(typeof(DescriptionAttribute), false);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            return attributes?[0].Description ?? @enum.ToString();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一次看代码可能会让人感到恐惧，但这并不复杂。让我们分解代码定义以了解其工作原理。<br>首先，我们定义了一种<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/\" target=\"_blank\" rel=\"noopener\">通用方法</a>（一种方法，该方法可以接收不止一种类型的参数，在这种情况下，该方法由TEnum声明表示），该方法接收给定的枚举作为参数。</p>\n<p>由于enum是C＃中的保留关键字，因此我们在参数名称前面添加了@，以使其成为有效名称。</p>\n<p>该方法的第一步是使用该方法获取参数的类型信息（类，接口，枚举或结构定义）GetType。</p>\n<p>然后，该方法使用来获取特定的枚举值（例如Kilogram）GetField(@enum.ToString())。</p>\n<p>下一行找到Description应用于枚举值的所有属性，并将其数据存储到数组中（在某些情况下，我们可以为同一属性指定多个属性）。</p>\n<p>最后一行使用较短的语法来检查我们是否至少有一个枚举类型的描述属性。如果有，我们将返回Description此属性提供的值。如果不是，我们使用默认的强制类型转换将枚举作为字符串返回。</p>\n<p>?.操作者（<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/conditional-operator\" target=\"_blank\" rel=\"noopener\">零条件运算</a>）检查该值是否null访问其属性之前。</p>\n<p>??运算符（<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator\" target=\"_blank\" rel=\"noopener\">空合并运算符</a>）告诉应用程序在左边的返回值，如果它不为空，或者在正确的，否则价值。</p>\n<p>现在我们有了扩展方法来提取描述，让我们配置模型和资源之间的映射。多亏了AutoMapper，我们只需要多一行就可以做到这一点。</p>\n<p>打开ModelToResourceProfile类并通过以下方式更改代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using AutoMapper;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Extensions;</span><br><span class=\"line\">\tusing Supermarket.API.Resources;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Mapping</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class ModelToResourceProfile : Profile</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public ModelToResourceProfile()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            CreateMap&lt;Category, CategoryResource&gt;();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            CreateMap&lt;Product, ProductResource&gt;()</span><br><span class=\"line\">\t                .ForMember(src =&gt; src.UnitOfMeasurement,</span><br><span class=\"line\">\t                           opt =&gt; opt.MapFrom(src =&gt; src.UnitOfMeasurement.ToDescriptionString()));</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此语法告诉AutoMapper使用新的扩展方法将我们的EUnitOfMeasurement值转换为包含其描述的字符串。简单吧？您可以<a href=\"http://docs.automapper.org/en/stable/Inline-Mapping.html\" target=\"_blank\" rel=\"noopener\">阅读官方文档</a>以了解完整语法。<br>注意，我们尚未为category属性定义任何映射配置。因为我们之前为类别配置了映射，并且由于产品模型具有相同类型和名称的category属性，所以AutoMapper隐式知道应该使用各自的配置来映射它。</p>\n<p>现在，我们添加端点代码。更改ProductsController代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing AutoMapper;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore.Mvc;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services;</span><br><span class=\"line\">\tusing Supermarket.API.Resources;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Controllers</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    [Route(&quot;/api/[controller]&quot;)]</span><br><span class=\"line\">\t    public class ProductsController : Controller</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        private readonly IProductService _productService;</span><br><span class=\"line\">\t        private readonly IMapper _mapper;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public ProductsController(IProductService productService, IMapper mapper)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            _productService = productService;</span><br><span class=\"line\">\t            _mapper = mapper;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        [HttpGet]</span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;ProductResource&gt;&gt; ListAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            var products = await _productService.ListAsync();</span><br><span class=\"line\">\t            var resources = _mapper.Map&lt;IEnumerable&lt;Product&gt;, IEnumerable&lt;ProductResource&gt;&gt;(products);</span><br><span class=\"line\">\t            return resources;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基本上，为类别控制器定义的结构相同。<br>让我们进入服务部分。将一个新IProductService接口添加到Domain层中的Services文件夹中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Services</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public interface IProductService</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t         Task&lt;IEnumerable&lt;Product&gt;&gt; ListAsync();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>您应该已经意识到，在真正实现新服务之前，我们需要一个仓储。<br>IProductRepository在相应的文件夹中添加一个名为的新接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Repositories</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public interface IProductRepository</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t         Task&lt;IEnumerable&lt;Product&gt;&gt; ListAsync();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们实现仓储。除了必须在查询数据时返回每个产品的相应类别数据外，我们几乎必须像对类别仓储一样实现。<br>默认情况下，EF Core在查询数据时不包括与模型相关的实体，因为它可能非常慢（想象一个具有十个相关实体的模型，所有相关实体都有自己的关系）。</p>\n<p>要包括类别数据，我们只需要多一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Microsoft.EntityFrameworkCore;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Repositories;</span><br><span class=\"line\">\tusing Supermarket.API.Persistence.Contexts;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Persistence.Repositories</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class ProductRepository : BaseRepository, IProductRepository</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public ProductRepository(AppDbContext context) : base(context)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;Product&gt;&gt; ListAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            return await _context.Products.Include(p =&gt; p.Category)</span><br><span class=\"line\">\t                                          .ToListAsync();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意对的调用Include(p =&gt; p.Category)。我们可以链接此语法，以在查询数据时包含尽可能多的实体。执行选择时，EF Core会将其转换为联接。<br>现在，我们可以ProductService像处理类别一样实现类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Repositories;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Services</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class ProductService : IProductService</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        private readonly IProductRepository _productRepository;</span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t        public ProductService(IProductRepository productRepository)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            _productRepository = productRepository;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;Product&gt;&gt; ListAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            return await _productRepository.ListAsync();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>让我们绑定更改Startup类的新依赖项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void ConfigureServices(IServiceCollection services)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    services.AddDbContext&lt;AppDbContext&gt;(options =&gt;</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        options.UseInMemoryDatabase(&quot;supermarket-api-in-memory&quot;);</span><br><span class=\"line\">\t    &#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    services.AddScoped&lt;ICategoryRepository, CategoryRepository&gt;();</span><br><span class=\"line\">\t    services.AddScoped&lt;IProductRepository, ProductRepository&gt;();</span><br><span class=\"line\">\t    services.AddScoped&lt;IUnitOfWork, UnitOfWork&gt;();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    services.AddScoped&lt;ICategoryService, CategoryService&gt;();</span><br><span class=\"line\">\t    services.AddScoped&lt;IProductService, ProductService&gt;();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    services.AddAutoMapper();</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，在测试API之前，让我们AppDbContext在初始化应用程序时更改类以包括一些产品，以便我们看到结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected override void OnModelCreating(ModelBuilder builder)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    base.OnModelCreating(builder);</span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t    builder.Entity&lt;Category&gt;().ToTable(&quot;Categories&quot;);</span><br><span class=\"line\">\t    builder.Entity&lt;Category&gt;().HasKey(p =&gt; p.Id);</span><br><span class=\"line\">\t    builder.Entity&lt;Category&gt;().Property(p =&gt; p.Id).IsRequired().ValueGeneratedOnAdd().HasValueGenerator&lt;InMemoryIntegerValueGenerator&lt;int&gt;&gt;();</span><br><span class=\"line\">\t    builder.Entity&lt;Category&gt;().Property(p =&gt; p.Name).IsRequired().HasMaxLength(30);</span><br><span class=\"line\">\t    builder.Entity&lt;Category&gt;().HasMany(p =&gt; p.Products).WithOne(p =&gt; p.Category).HasForeignKey(p =&gt; p.CategoryId);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    builder.Entity&lt;Category&gt;().HasData</span><br><span class=\"line\">\t    (</span><br><span class=\"line\">\t        new Category &#123; Id = 100, Name = &quot;Fruits and Vegetables&quot; &#125;, // Id set manually due to in-memory provider</span><br><span class=\"line\">\t        new Category &#123; Id = 101, Name = &quot;Dairy&quot; &#125;</span><br><span class=\"line\">\t    );</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    builder.Entity&lt;Product&gt;().ToTable(&quot;Products&quot;);</span><br><span class=\"line\">\t    builder.Entity&lt;Product&gt;().HasKey(p =&gt; p.Id);</span><br><span class=\"line\">\t    builder.Entity&lt;Product&gt;().Property(p =&gt; p.Id).IsRequired().ValueGeneratedOnAdd();</span><br><span class=\"line\">\t    builder.Entity&lt;Product&gt;().Property(p =&gt; p.Name).IsRequired().HasMaxLength(50);</span><br><span class=\"line\">\t    builder.Entity&lt;Product&gt;().Property(p =&gt; p.QuantityInPackage).IsRequired();</span><br><span class=\"line\">\t    builder.Entity&lt;Product&gt;().Property(p =&gt; p.UnitOfMeasurement).IsRequired();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    builder.Entity&lt;Product&gt;().HasData</span><br><span class=\"line\">\t    (</span><br><span class=\"line\">\t        new Product</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            Id = 100,</span><br><span class=\"line\">\t            Name = &quot;Apple&quot;,</span><br><span class=\"line\">\t            QuantityInPackage = 1,</span><br><span class=\"line\">\t            UnitOfMeasurement = EUnitOfMeasurement.Unity,</span><br><span class=\"line\">\t            CategoryId = 100</span><br><span class=\"line\">\t        &#125;,</span><br><span class=\"line\">\t        new Product</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            Id = 101,</span><br><span class=\"line\">\t            Name = &quot;Milk&quot;,</span><br><span class=\"line\">\t            QuantityInPackage = 2,</span><br><span class=\"line\">\t            UnitOfMeasurement = EUnitOfMeasurement.Liter,</span><br><span class=\"line\">\t            CategoryId = 101,</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    );</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我添加了两个虚构产品，将它们与初始化应用程序时我们播种的类别相关联。<br>该测试了！再次运行API并发送GET请求以/api/products使用Postman：</p>\n<p><img src=\"https://uploader.shimo.im/f/h9cMeoAIZg4vyRgj.png!thumbnail\" alt=\"图片\"></p>\n<p>就是这样！恭喜你！</p>\n<p>现在，您将了解如何使用解耦的代码架构使用ASP.NET Core构建RESTful API。您了解了.NET Core框架的许多知识，如何使用C＃，EF Core和AutoMapper的基础知识以及在设计应用程序时要使用的许多有用的模式。</p>\n<p>您可以检查API的完整实现，包括产品的其他HTTP动词，并检查Github仓储：</p>\n<p><a href=\"https://github.com/evgomes/supermarket-api\" target=\"_blank\" rel=\"noopener\">evgomes / supermarket-api</a></p>\n<p><a href=\"https://github.com/evgomes/supermarket-api\" target=\"_blank\" rel=\"noopener\">使用ASP.NET Core 2.2构建的简单RESTful API，展示了如何使用分离的，可维护的……创建RESTful服务</a><a href=\"https://github.com/evgomes/supermarket-api\" target=\"_blank\" rel=\"noopener\">。github.com</a></p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a><strong>结论</strong></h1><p>ASP.NET Core是创建Web应用程序时使用的出色框架。它带有许多有用的API，可用于构建干净，可维护的应用程序。创建专业应用程序时，可以将其视为一种选择。</p>\n<p>本文并未涵盖专业API的所有方面，但您已学习了所有基础知识。您还学到了许多有用的模式，可以解决我们每天面临的模式。</p>\n<p>希望您喜欢这篇文章，希望对您有所帮助。期待你的反馈，以便我能进一步提高。</p>\n<p><strong>进一步学习的可用参考资料</strong></p>\n<p><a href=\"https://docs.microsoft.com/en-us/dotnet/core/tutorials/\" target=\"_blank\" rel=\"noopener\">.NET Core教程-Microsoft文档</a></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/aspnet/#pivot=core&panel=core_tutorials\" target=\"_blank\" rel=\"noopener\">ASP.NET Core文档-Microsoft文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>译者荐语：利用周末的时间，本人拜读了长沙.NET技术社区翻译的技术文章《<a href=\"http://techq.club/2019/08/02/%E6%8A%80%E6%9C%AF/Microsoft%20REST%20API%E6%8C%87%E5%8D%97/\" target=\"_blank\" rel=\"noopener\">微软RESTFul API指南</a>》，打算按照步骤写一个完整的教程，后来无意中看到了这篇文章，与我要写的主题有不少相似之处，特意翻译下来。前方高能。</p>\n<p><img src=\"https://uploader.shimo.im/f/U68C9NmcWwwWHATD.png!thumbnail\" alt=\"图片\">一步一步的构建整洁、可维护的RESTful APIs</p>\n<p><a href=\"https://www.techq.xyz/2020/02/23/%E6%8A%80%E6%9C%AF/WPF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%A6%82%E8%BF%B0/\" target=\"_blank\" rel=\"noopener\">查看原文</a></p>\n<h1 id=\"总览\"><a href=\"#总览\" class=\"headerlink\" title=\"总览\"></a>总览</h1><p>RESTful不是一个新名词。它是一种架构风格，这种架构风格使用Web服务从客户端应用程序接收数据和向客户端应用程序发送数据。其目标是集中不同客户端应用程序将使用的数据。</p>\n<p>选择正确的工具来编写RESTful服务至关重要，因为我们需要关注可伸缩性，维护，文档以及所有其他相关方面。在<a href=\"https://docs.microsoft.com/en-us/aspnet/\" target=\"_blank\" rel=\"noopener\">ASP.NET</a> Core为我们提供了一个功能强大、易于使用的API，使用这些API将很好的实现这个目标。</p>\n<p>在本文中，我将向您展示如何使用ASP.NET Core框架为“几乎”现实世界的场景编写结构良好的RESTful API。我将详细介绍常见的模式和策略以简化开发过程。</p>\n<p>我还将向您展示如何集成通用框架和库，例如<a href=\"https://docs.microsoft.com/en-us/ef/core/\" target=\"_blank\" rel=\"noopener\">Entity Framework Core</a>和<a href=\"https://automapper.org/\" target=\"_blank\" rel=\"noopener\">AutoMapper</a>，以提供必要的功能。</p>\n<h1 id=\"先决条件\"><a href=\"#先决条件\" class=\"headerlink\" title=\"先决条件\"></a><strong>先决条件</strong></h1><p>我希望您了解面向对象的编程概念。</p>\n<p>即使我将介绍<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/\" target=\"_blank\" rel=\"noopener\">C＃编程语言</a>的许多细节，我还是建议您具有该主题的基本知识。</p>\n<p>我还假设您知道什么是REST，<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview\" target=\"_blank\" rel=\"noopener\">HTTP协议</a>如何工作，什么是API端点以及什么是<a href=\"https://www.json.org/\" target=\"_blank\" rel=\"noopener\">JSON</a>。<a href=\"https://medium.freecodecamp.org/restful-services-part-i-http-in-a-nutshell-aab3bfedd131\" target=\"_blank\" rel=\"noopener\">这是</a>关于此主题<a href=\"https://medium.freecodecamp.org/restful-services-part-i-http-in-a-nutshell-aab3bfedd131\" target=\"_blank\" rel=\"noopener\">的出色的入门教程</a>。最后，您需要了解关系数据库的工作原理。</p>\n<p>要与我一起编码，您将必须安装<a href=\"https://dotnet.microsoft.com/download\" target=\"_blank\" rel=\"noopener\">.NET Core 2.2</a>以及<a href=\"https://www.getpostman.com/\" target=\"_blank\" rel=\"noopener\">Postman</a>（我将用来测试API的工具）。我建议您使用诸如<a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">Visual Studio Code之</a>类的代码编辑器来开发API。选择您喜欢的代码编辑器。如果选择Visual Studio Code作为您的代码编辑器，建议您安装<a href=\"https://code.visualstudio.com/docs/languages/csharp\" target=\"_blank\" rel=\"noopener\">C＃扩展</a>以更好地突出显示代码。</p>\n<p>您可以在本文末尾找到该API的Github的链接，以检查最终结果。</p>\n<h1 id=\"范围\"><a href=\"#范围\" class=\"headerlink\" title=\"范围\"></a><strong>范围</strong></h1><p>让我们为一家超市编写一个虚构的Web API。假设我们必须实现以下范围：</p>\n<ul>\n<li><em>创建一个RESTful服务，该服务允许客户端应用程序管理超市的产品目录。它需要公开端点以创建，读取，编辑和删除产品类别，例如乳制品和化妆品，还需要管理这些类别的产品。</em></li>\n<li><em>对于类别，我们需要存储其名称。对于产品，我们需要存储其名称，度量单位（例如，按重量测量的产品为KG），包装中的数量（例如，如果一包饼干是10，则为10）及其各自的类别。</em></li>\n</ul>\n<p>为了简化示例，我将不处理库存产品，产品运输，安全性和任何其他功能。这个范围足以向您展示ASP.NET Core的工作方式。</p>\n<p>要开发此服务，我们基本上需要两个API 端点（译者注：指控制器）：一个用于管理类别，一个用于管理产品。在JSON通讯方面，我们可以认为响应如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">API endpoint: /api/categories</span><br><span class=\"line\">JSON Response (for GET requests):</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  [</span><br><span class=\"line\">    &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Fruits and Vegetables&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;Breads&quot; &#125;,</span><br><span class=\"line\">    … // Other categories</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">API endpoint: /api/products</span><br><span class=\"line\">JSON Response (for GET requests):</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;id&quot;: 1,</span><br><span class=\"line\">      &quot;name&quot;: &quot;Sugar&quot;,</span><br><span class=\"line\">      &quot;quantityInPackage&quot;: 1,</span><br><span class=\"line\">      &quot;unitOfMeasurement&quot;: &quot;KG&quot;</span><br><span class=\"line\">      &quot;category&quot;: &#123;</span><br><span class=\"line\">        &quot;id&quot;: 3,</span><br><span class=\"line\">        &quot;name&quot;: &quot;Sugar&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    … // Other products</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>让我们开始编写应用程序。</p>\n<h1 id=\"第1步-创建API\"><a href=\"#第1步-创建API\" class=\"headerlink\" title=\"第1步-创建API\"></a><strong>第1步-创建API</strong></h1><p>首先，我们必须为Web服务创建文件夹结构，然后我们必须使用<a href=\"https://docs.microsoft.com/en-us/dotnet/core/tools/?tabs=netcore2x\" target=\"_blank\" rel=\"noopener\">.NET CLI工具</a>来构建基本的Web API。打开终端或命令提示符（取决于您使用的操作系统），并依次键入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir src/Supermarket.API</span><br><span class=\"line\"></span><br><span class=\"line\">cd src/Supermarket.API</span><br><span class=\"line\"></span><br><span class=\"line\">dotnet new webapi</span><br></pre></td></tr></table></figure>\n\n<p>前两个命令只是为API创建一个新目录，然后将当前位置更改为新文件夹。最后一个遵循Web API模板生成一个新项目，这是我们正在开发的应用程序。您可以阅读有关这些命令和其他项目模板的更多信息，并可以通过<a href=\"https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new?tabs=netcore21\" target=\"_blank\" rel=\"noopener\">检查此链接</a>来生成其他项目模板。<br>现在，新目录将具有以下结构：</p>\n<p><img src=\"https://uploader.shimo.im/f/LuICwkhqHDsD5RcN.png!thumbnail\" alt=\"图片\"></p>\n<p>项目结构</p>\n<h2 id=\"结构概述\"><a href=\"#结构概述\" class=\"headerlink\" title=\"结构概述\"></a>结构概述</h2><p>ASP.NET Core应用程序由在类中配置的一组<a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-2.2\" target=\"_blank\" rel=\"noopener\">中间件</a>（应用程序流水线中的小块应用程序，用于处理请求和响应）组成Startup。如果您以前已经使用过<a href=\"https://expressjs.com/\" target=\"_blank\" rel=\"noopener\">Express.js</a>之类的框架，那么这个概念对您来说并不是什么新鲜事物。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Startup</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public Startup(IConfiguration configuration)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        Configuration = configuration;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    public IConfiguration Configuration &#123; get; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    // This method gets called by the runtime. Use this method to add services to the container.</span><br><span class=\"line\">\t    public void ConfigureServices(IServiceCollection services)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span><br><span class=\"line\">\t    public void Configure(IApplicationBuilder app, IHostingEnvironment env)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        if (env.IsDevelopment())</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            app.UseDeveloperExceptionPage();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t        else</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.</span><br><span class=\"line\">\t            app.UseHsts();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        app.UseHttpsRedirection();</span><br><span class=\"line\">\t        app.UseMvc();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当应用程序启动时，将调用类中的Main** **方法Program。它使用启动配置创建默认的Web主机，通过HTTP通过特定端口（默认情况下，HTTP为5000，HTTPS为5001）公开应用程序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace Supermarket.API</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class Program</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public static void Main(string[] args)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            CreateWebHostBuilder(args).Build().Run();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;</span><br><span class=\"line\">\t            WebHost.CreateDefaultBuilder(args)</span><br><span class=\"line\">\t                .UseStartup&lt;Startup&gt;();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看一下文件夹中的ValuesController类Controllers。它公开了API通过路由接收请求时将调用的方法/api/values。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Route(&quot;api/[controller]&quot;)]</span><br><span class=\"line\">\t[ApiController]</span><br><span class=\"line\">\tpublic class ValuesController : ControllerBase</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    // GET api/values</span><br><span class=\"line\">\t    [HttpGet]</span><br><span class=\"line\">\t    public ActionResult&lt;IEnumerable&lt;string&gt;&gt; Get()</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        return new string[] &#123; &quot;value1&quot;, &quot;value2&quot; &#125;;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    // GET api/values/5</span><br><span class=\"line\">\t    [HttpGet(&quot;&#123;id&#125;&quot;)]</span><br><span class=\"line\">\t    public ActionResult&lt;string&gt; Get(int id)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        return &quot;value&quot;;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    // POST api/values</span><br><span class=\"line\">\t    [HttpPost]</span><br><span class=\"line\">\t    public void Post([FromBody] string value)</span><br><span class=\"line\">\t    &#123; </span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    // PUT api/values/5</span><br><span class=\"line\">\t    [HttpPut(&quot;&#123;id&#125;&quot;)]</span><br><span class=\"line\">\t    public void Put(int id, [FromBody] string value)</span><br><span class=\"line\">\t    &#123;   </span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    // DELETE api/values/5</span><br><span class=\"line\">\t    [HttpDelete(&quot;&#123;id&#125;&quot;)]</span><br><span class=\"line\">\t    public void Delete(int id)</span><br><span class=\"line\">\t    &#123;  </span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果您不了解此代码的某些部分，请不要担心。在开发必要的API端点时，我将详细介绍每一个。现在，只需删除此类，因为我们不会使用它。</p>\n<h1 id=\"第2步-创建领域模型\"><a href=\"#第2步-创建领域模型\" class=\"headerlink\" title=\"第2步-创建领域模型\"></a><strong>第2步-创建领域模型</strong></h1><p>我将应用一些设计概念，以使应用程序简单易维护。</p>\n<p>编写可以由您自己理解和维护的代码并不难，但是您必须牢记您将成为团队的一部分。如果您不注意如何编写代码，那么结果将是一个庞然大物，这将使您和您的团队成员头痛不已。听起来很极端吧？但是相信我，这就是事实。</p>\n<p><img src=\"https://uploader.shimo.im/f/vMGZaW8zLiA39wxb.png!thumbnail\" alt=\"图片\"></p>\n<p>衡量好代码的标准是WTF的频率。原图来自<a href=\"https://www.flickr.com/photos/smitty/\" target=\"_blank\" rel=\"noopener\">smitty42</a>，发表于<a href=\"https://www.flickr.com/photos/smitty/2245445147\" target=\"_blank\" rel=\"noopener\">filckr</a>。该图遵循CC-BY-2.0。</p>\n<p>在Supermarket.API目录中，创建一个名为的新文件夹Domain。在新的领域文件夹中，创建另一个名为的文件夹Models。我们必须添加到此文件夹的第一个模型是Category。最初，它将是一个简单的<a href=\"https://en.wikipedia.org/wiki/Plain_old_CLR_object\" target=\"_blank\" rel=\"noopener\">Plain Old CLR Object（POCO）</a>类。这意味着该类将仅具有描述其基本信息的属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Models</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class Category</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public int Id &#123; get; set; &#125;</span><br><span class=\"line\">\t        public string Name &#123; get; set; &#125;</span><br><span class=\"line\">\t        public IList&lt;Product&gt; Products &#123; get; set; &#125; = new List&lt;Product&gt;();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该类具有一个Id** <strong>属性（用于标识类别）和一个Name属性。以及一个Products</strong> <strong>属性。最后一个属性将由</strong>Entity Framework Core使用**，大多数ASP.NET Core应用程序使用ORM将数据持久化到数据库中，以映射类别和产品之间的关系。由于类别具有许多相关产品，因此在面向对象的编程方面也具有合理的思维能力。<br>我们还必须创建产品模型。在同一文件夹中，添加一个新Product类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace Supermarket.API.Domain.Models</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class Product</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public int Id &#123; get; set; &#125;</span><br><span class=\"line\">\t        public string Name &#123; get; set; &#125;</span><br><span class=\"line\">\t        public short QuantityInPackage &#123; get; set; &#125;</span><br><span class=\"line\">\t        public EUnitOfMeasurement UnitOfMeasurement &#123; get; set; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public int CategoryId &#123; get; set; &#125;</span><br><span class=\"line\">\t        public Category Category &#123; get; set; &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该产品还具有ID和名称的属性。属性QuantityInPackage，它告诉我们一包中有多少个产品单位（请记住应用范围的饼干示例）和一个UnitOfMeasurement** <strong>属性，这是表示一个<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum\" target=\"_blank\" rel=\"noopener\">枚举类型</a>，它表示可能的度量单位的枚举。最后两个属性，CategoryId</strong> **和Category将由ORM用于映射的产品和类别之间的关系。它表明一种产品只有一个类别。</p>\n<p>让我们定义领域模型的最后一部分，EUnitOfMeasurement** **枚举。</p>\n<p>按照惯例，枚举不需要在名称前以<em>“ E”</em>开头，但是在某些库和框架中，您会发现此前缀是将枚举与接口和类区分开的一种方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.ComponentModel;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Models</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public enum EUnitOfMeasurement : byte</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        [Description(&quot;UN&quot;)]</span><br><span class=\"line\">\t        Unity = 1,</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        [Description(&quot;MG&quot;)]</span><br><span class=\"line\">\t        Milligram = 2,</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        [Description(&quot;G&quot;)]</span><br><span class=\"line\">\t        Gram = 3,</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        [Description(&quot;KG&quot;)]</span><br><span class=\"line\">\t        Kilogram = 4,</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        [Description(&quot;L&quot;)]</span><br><span class=\"line\">\t        Liter = 5</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该代码非常简单。在这里，我们仅定义了几种度量单位的可能性，但是，在实际的超市系统中，您可能具有许多其他度量单位，并且可能还有一个单独的模型。<br>注意，【Description】特性应用于所有枚举可能性。特性是一种在C＃语言的类，接口，属性和其他组件上定义元数据的方法。在这种情况下，我们将使用它来简化产品API端点的响应，但是您现在不必关心它。我们待会再回到这里。</p>\n<p>我们的基本模型已准备就绪，可以使用。现在，我们可以开始编写将管理所有类别的API端点。</p>\n<h1 id=\"第3步-类别API\"><a href=\"#第3步-类别API\" class=\"headerlink\" title=\"第3步-类别API\"></a><strong>第3步-类别API</strong></h1><p>在Controllers文件夹中，添加一个名为的新类CategoriesController。</p>\n<p>按照惯例，该文件夹中所有后缀为<em>“ Controller”的类</em>都将成为我们应用程序的控制器。这意味着他们将处理请求和响应。您必须从<a href=\"https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/namespace\" target=\"_blank\" rel=\"noopener\">命名空间</a>【Microsoft.AspNetCore.Mvc】继承Controller。</p>\n<p>命名空间由一组相关的类，接口，枚举和结构组成。您可以将其视为类似于Java语言<a href=\"https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc\" target=\"_blank\" rel=\"noopener\">模块</a>或Java <a href=\"https://docs.oracle.com/javase/tutorial/java/package/packages.html\" target=\"_blank\" rel=\"noopener\">程序包</a>的东西。</p>\n<p>新的控制器应通过路由/api/categories做出响应。我们通过Route** **在类名称上方添加属性，指定占位符来实现此目的，该占位符表示路由应按照惯例使用不带控制器后缀的类名称。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Microsoft.AspNetCore.Mvc;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Controllers</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    [Route(&quot;/api/[controller]&quot;)]</span><br><span class=\"line\">\t    public class CategoriesController : Controller</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>让我们开始处理GET请求。首先，当有人/api/categories通过GET动词请求数据时，API需要返回所有类别。为此，我们可以创建<strong>类别服务</strong>。<br>从概念上讲，服务基本上是定义用于处理某些业务逻辑的方法的类或接口。创建用于处理业务逻辑的服务是许多不同编程语言的一种常见做法，例如<a href=\"https://medium.com/@evandro.ggomes/json-web-token-authentication-with-asp-net-core-2-0-b074b0cfc870\" target=\"_blank\" rel=\"noopener\">身份验证和授权</a>，付款，复杂的数据流，缓存和需要其他服务或模型之间进行某些交互的任务。</p>\n<p>使用服务，我们可以将请求和响应处理与完成任务所需的真实逻辑隔离开来。</p>\n<p>该服务，我们要创建将首先定义一个单独的行为<strong>，</strong>或<strong>方法</strong>：一个list方法。我们希望该方法返回数据库中所有现有的类别。</p>\n<p>为简单起见，在这篇博客中，我们将不处理数据分页或过滤，（译者注：基于RESTFul规范，提供了一套完整的分页和过滤的规则）。将来，我将写一篇文章，展示如何轻松处理这些功能。</p>\n<p>为了定义C＃（以及其他面向对象的语言，例如Java）中某事物的预期行为，我们定义一个<strong>interface</strong>。一个接口告诉某些事情应该如何工作，但是<strong>没有实现行为的真实逻辑</strong>。逻辑在实现接口的类中实现。如果您不清楚此概念，请不要担心。一段时间后您将了解它。</p>\n<p>在Domain文件夹中，创建一个名为的新目录Services。在此添加一个名为ICategoryService的接口。按照惯例，所有接口都应以C＃中的大写字母<em>“ I”</em>开头。定义接口代码，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Services</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public interface ICategoryService</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t         Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该ListAsync方法的实现必须<strong>异步</strong>返回类别的可枚举对象。<br>Task封装返回的类表示异步。由于必须等待数据库完成操作才能返回数据，因此我们需要考虑执行此过程可能需要一段时间，因此我们需要使用异步方法。另请注意<em>“Async”</em>后缀。这是一个约定，告诉我们的方法应异步执行。</p>\n<p>我们有很多约定，对吗？我个人喜欢它，因为它使应用程序易于阅读，即使你在一家使用.NET技术的公司是新人。</p>\n<p><img src=\"https://uploader.shimo.im/f/vQLzU6MpZkoChf0Y.png!thumbnail\" alt=\"图片\"></p>\n<p><em>“-好的，我们定义了此接口，但是它什么也没做。有什么用？”</em></p>\n<p>如果您来自Javascript或其他非强类型语言，则此概念可能看起来很奇怪。</p>\n<p>接口使我们能够从实际实现中抽象出所需的行为。使用称为<a href=\"https://medium.freecodecamp.org/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f\" target=\"_blank\" rel=\"noopener\">依赖注入</a>的机制，我们可以实现这些接口并将它们与其他组件隔离。</p>\n<p>基本上，当您使用依赖项注入时，您可以使用接口定义一些行为。然后，创建一个实现该接口的类。最后，将引用从接口绑定到您创建的类。</p>\n<p><em>”-听起来确实令人困惑。我们不能简单地创建一个为我们做这些事情的类吗？”</em></p>\n<p>让我们继续实现我们的API，您将了解为什么使用这种方法。</p>\n<p>更改CategoriesController代码，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore.Mvc;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Controllers</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    [Route(&quot;/api/[controller]&quot;)]</span><br><span class=\"line\">\t    public class CategoriesController : Controller</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        private readonly ICategoryService _categoryService;</span><br><span class=\"line\">\t        </span><br><span class=\"line\">\t        public CategoriesController(ICategoryService categoryService)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            _categoryService = categoryService;   </span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        [HttpGet]</span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;Category&gt;&gt; GetAllAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            var categories = await _categoryService.ListAsync();</span><br><span class=\"line\">\t            return categories;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我已经为控制器定义了一个构造函数（当创建一个类的新实例时会调用一个构造函数），并且它接收的实例ICategoryService。这意味着实例可以是任何实现服务接口的实例。我将此实例存储在一个私有的只读字段中_categoryService。我们将使用此字段访问类别服务实现的方法。<br>顺便说一下，下划线前缀是表示字段的另一个通用约定。特别地，<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions\" target=\"_blank\" rel=\"noopener\">.NET</a>的<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions\" target=\"_blank\" rel=\"noopener\">官方命名约定指南</a>不建议使用此<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions\" target=\"_blank\" rel=\"noopener\">约定</a>，但是这是一种非常普遍的做法，可以避免使用<em>“ this”</em>关键字来区分类字段和局部变量。我个人认为阅读起来要干净得多，并且许多框架和库都使用此约定。</p>\n<p>在构造函数下，我定义了用于处理请求的方法/api/categories。该HttpGet** **属性告诉ASP.NET Core管道使用该属性来处理GET请求（可以省略此属性，但是最好编写它以便于阅读）。</p>\n<p>该方法使用我们的CategoryService实例列出所有类别，然后将类别返回给客户端。框架管道将数据序列化为JSON对象。IEnumerable类型告诉框架，我们想要返回一个类别的枚举，而Task类型(使用async关键字修饰)告诉管道，这个方法应该异步执行。最后，当我们定义一个异步方法时，我们必须使用await关键字来处理需要一些时间的任务。</p>\n<p>好的，我们定义了API的初始结构。现在，有必要真正实现类别服务。</p>\n<h1 id=\"步骤4-实现类别服务\"><a href=\"#步骤4-实现类别服务\" class=\"headerlink\" title=\"步骤4-实现类别服务\"></a><strong>步骤4-实现类别服务</strong></h1><p>在API的根文件夹（即Supermarket.API文件夹）中，创建一个名为的新文件夹Services。在这里，我们将放置所有服务实现。在新文件夹中，添加一个名为CategoryService的新类。更改代码，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Services</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class CategoryService : ICategoryService</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上只是接口实现的基本代码，我们暂时仍不处理任何逻辑。让我们考虑一下列表方法应该如何实现。<br>我们需要访问数据库并返回所有类别，然后我们需要将此数据返回给客户端。</p>\n<p>服务类不是应该处理数据访问的类。我们将使用一种称为“仓储模式”的设计模式，定义仓储类，用于管理数据库中的数据。</p>\n<p>在使用仓储模式时，我们定义了repository 类，该类基本上封装了处理数据访问的所有逻辑。这些仓储类使方法可以列出，创建，编辑和删除给定模型的对象，与操作集合的方式相同。在内部，这些方法与数据库对话以执行CRUD操作，从而将数据库访问与应用程序的其余部分隔离开。</p>\n<p>我们的服务需要调用类别仓储，以获取列表对象。</p>\n<p>从概念上讲，服务可以与一个或多个仓储或其他服务“对话”以执行操作。</p>\n<p>创建用于处理数据访问逻辑的新定义似乎是多余的，但是您将在一段时间内看到将这种逻辑与服务类隔离是非常有利的。</p>\n<p>让我们创建一个仓储，该仓储负责与数据库通信，作为持久化保存类别的一种方式。</p>\n<h1 id=\"步骤5-类别仓储和持久层\"><a href=\"#步骤5-类别仓储和持久层\" class=\"headerlink\" title=\"步骤5-类别仓储和持久层\"></a><strong>步骤5-类别仓储和持久层</strong></h1><p>在该Domain文件夹内，创建一个名为的新目录Repositories。然后，添加一个名为的新接口ICategoryRespository。定义接口如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Repositories</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public interface ICategoryRepository</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t         Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始代码基本上与服务接口的代码相同。<br>定义了接口之后，我们可以返回服务类并使用的实例ICategoryRepository返回数据来完成实现list方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Repositories;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Services</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class CategoryService : ICategoryService</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        private readonly ICategoryRepository _categoryRepository;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public CategoryService(ICategoryRepository categoryRepository)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            this._categoryRepository = categoryRepository;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync()</span><br><span class=\"line\">\t        &#123; </span><br><span class=\"line\">\t            return await _categoryRepository.ListAsync();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们必须实现类别仓储的真实逻辑。在这样做之前，我们必须考虑如何访问数据库。<br><em>顺便说一句，我们仍然没有数据库！</em></p>\n<p>我们将使用Entity Framework Core（为简单起见，我将其称为<strong><em>EF Core</em></strong>）作为我们的数据库ORM。该框架是ASP.NET Core的默认ORM，并公开了一个友好的API，该API使我们能够将应用程序的类映射到数据库表。</p>\n<p>EF Core还允许我们先设计应用程序，然后根据我们在代码中定义的内容生成数据库。此技术称为<strong>Code First</strong>。我们将使用Code First方法来生成数据库（实际上，在此示例中，我将使用内存数据库，但是您可以轻松地将其更改为像SQL Server或MySQL服务器这样的实例数据库）。</p>\n<p>在API的根文件夹中，创建一个名为的新目录Persistence。此目录将包含我们访问数据库所需的所有内容，例如仓储实现。</p>\n<p>在新文件夹中，创建一个名为的新目录Contexts，然后添加一个名为的新类AppDbContext。此类必须继承DbContext，EF Core通过DBContext用来将您的模型映射到数据库表的类。通过以下方式更改代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Microsoft.EntityFrameworkCore;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Persistence.Contexts</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class AppDbContext : DbContext</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public AppDbContext(DbContextOptions&lt;AppDbContext&gt; options) : base(options)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们添加到此类的构造函数负责通过依赖注入将数据库配置传递给基类。稍后您将看到其工作原理。<br>现在，我们必须创建两个DbSet属性。这些属性是将模型映射到数据库表的集合（唯一对象的集合）。</p>\n<p>另外，我们必须将模型的属性映射到相应的列，指定哪些属性是主键，哪些是外键，列类型等。我们可以使用称为<a href=\"http://www.entityframeworktutorial.net/efcore/fluent-api-in-entity-framework-core.aspx\" target=\"_blank\" rel=\"noopener\">Fluent API</a>的功能来覆盖OnModelCreating方法，以指定数据库映射。更改AppDbContext类，如下所示：</p>\n<p>该代码是如此直观。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Microsoft.EntityFrameworkCore;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Persistence.Contexts</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class AppDbContext : DbContext</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public DbSet&lt;Category&gt; Categories &#123; get; set; &#125;</span><br><span class=\"line\">\t        public DbSet&lt;Product&gt; Products &#123; get; set; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public AppDbContext(DbContextOptions&lt;AppDbContext&gt; options) : base(options) &#123; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        protected override void OnModelCreating(ModelBuilder builder)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            base.OnModelCreating(builder);</span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t            builder.Entity&lt;Category&gt;().ToTable(&quot;Categories&quot;);</span><br><span class=\"line\">\t            builder.Entity&lt;Category&gt;().HasKey(p =&gt; p.Id);</span><br><span class=\"line\">\t            builder.Entity&lt;Category&gt;().Property(p =&gt; p.Id).IsRequired().ValueGeneratedOnAdd();</span><br><span class=\"line\">\t            builder.Entity&lt;Category&gt;().Property(p =&gt; p.Name).IsRequired().HasMaxLength(30);</span><br><span class=\"line\">\t            builder.Entity&lt;Category&gt;().HasMany(p =&gt; p.Products).WithOne(p =&gt; p.Category).HasForeignKey(p =&gt; p.CategoryId);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            builder.Entity&lt;Category&gt;().HasData</span><br><span class=\"line\">\t            (</span><br><span class=\"line\">\t                new Category &#123; Id = 100, Name = &quot;Fruits and Vegetables&quot; &#125;, // Id set manually due to in-memory provider</span><br><span class=\"line\">\t                new Category &#123; Id = 101, Name = &quot;Dairy&quot; &#125;</span><br><span class=\"line\">\t            );</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            builder.Entity&lt;Product&gt;().ToTable(&quot;Products&quot;);</span><br><span class=\"line\">\t            builder.Entity&lt;Product&gt;().HasKey(p =&gt; p.Id);</span><br><span class=\"line\">\t            builder.Entity&lt;Product&gt;().Property(p =&gt; p.Id).IsRequired().ValueGeneratedOnAdd();</span><br><span class=\"line\">\t            builder.Entity&lt;Product&gt;().Property(p =&gt; p.Name).IsRequired().HasMaxLength(50);</span><br><span class=\"line\">\t            builder.Entity&lt;Product&gt;().Property(p =&gt; p.QuantityInPackage).IsRequired();</span><br><span class=\"line\">\t            builder.Entity&lt;Product&gt;().Property(p =&gt; p.UnitOfMeasurement).IsRequired();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们指定我们的模型应映射到哪些表。此外，我们设置了主键，使用该方法HasKey，该表的列，使用Property方法，和一些限制，例如IsRequired，HasMaxLength<strong>，</strong>和ValueGeneratedOnAdd，这些都是使用FluentApi的方式基于Lamada 表达式语法实现的（链式语法）。<br>看一下下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">builder.Entity&lt;Category&gt;()</span><br><span class=\"line\">       .HasMany(p =&gt; p.Products)</span><br><span class=\"line\">       .WithOne(p =&gt; p.Category)</span><br><span class=\"line\">       .HasForeignKey(p =&gt; p.CategoryId);</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们指定表之间的关系。我们说一个类别有很多产品，我们设置了将映射此关系的属性（Products，来自Category类，和Category，来自Product类）。我们还设置了外键（CategoryId）。<br>如果您想学习如何使用EF Core配置一对一和多对多关系，以及如何完整的使用它，请看一下<a href=\"https://www.learnentityframeworkcore.com/relationships\" target=\"_blank\" rel=\"noopener\">本教程</a>。</p>\n<p>还有一种用于通过HasData方法配置种子数据的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">builder.Entity&lt;Category&gt;().HasData</span><br><span class=\"line\">(</span><br><span class=\"line\">  new Category &#123; Id = 100, Name = &quot;Fruits and Vegetables&quot; &#125;,</span><br><span class=\"line\">  new Category &#123; Id = 101, Name = &quot;Dairy&quot; &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，在这里我们仅添加两个示例类别。这对我们完成后进行API的测试来说是非常有必要的。</p>\n<blockquote>\n<p><strong>注意：</strong>我们在Id这里手动设置属性，因为内存提供程序的工作机制需要。我将标识符设置为大数字，以避免自动生成的标识符和种子数据之间发生冲突。</p>\n<blockquote>\n<p>真正的关系数据库提供程序中不存在此限制，因此，例如，如果要使用SQL Server等数据库，则不必指定这些标识符。如果您想了解此行为，请检查<a href=\"https://github.com/aspnet/EntityFrameworkCore/issues/6872\" target=\"_blank\" rel=\"noopener\">此Github问题</a>。</p>\n</blockquote>\n</blockquote>\n<p>在实现数据库上下文类之后，我们可以实现类别仓储。添加一个名为新的文件夹Repositories里面Persistence的文件夹，然后添加一个名为新类BaseRepository。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Supermarket.API.Persistence.Contexts;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Persistence.Repositories</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public abstract class BaseRepository</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        protected readonly AppDbContext _context;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public BaseRepository(AppDbContext context)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            _context = context;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此类只是我们所有仓储都将继承的<strong>抽象类</strong>。抽象类是没有直接实例的类。您必须创建直接类来创建实例。<br>在BaseRepository接受我们的实例，AppDbContext通过依赖注入暴露了一个受保护的属性称为（只能是由子类访问一个属性）_context，即可以访问我们需要处理数据库操作的所有方法。</p>\n<p>在相同文件夹中添加一个新类CategoryRepository。现在，我们将真正实现仓储逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Microsoft.EntityFrameworkCore;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Repositories;</span><br><span class=\"line\">\tusing Supermarket.API.Persistence.Contexts;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Persistence.Repositories</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class CategoryRepository : BaseRepository, ICategoryRepository</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public CategoryRepository(AppDbContext context) : base(context)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            return await _context.Categories.ToListAsync();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>仓储继承BaseRepository和实现ICategoryRepository。<br>注意实现list方法是很简单的。我们使用Categories数据库集访问类别表，然后调用扩展方法ToListAsync，该方法负责将查询结果转换为类别的集合。</p>\n<p>EF Core <a href=\"https://docs.microsoft.com/en-us/ef/core/querying/overview\" target=\"_blank\" rel=\"noopener\">将我们的方法调用转换为SQL查询</a>，这是最有效的方法。这种方式仅当您调用将数据转换为集合的方法或使用方法获取特定数据时才执行查询。</p>\n<p>现在，我们有了类别控制器，服务和仓储库的代码实现。</p>\n<p>我们将关注点分离开来，创建了只执行应做的事情的类。</p>\n<p>测试应用程序之前的最后一步是使用ASP.NET Core依赖项注入机制将我们的接口绑定到相应的类。</p>\n<h1 id=\"第6步-配置依赖注入\"><a href=\"#第6步-配置依赖注入\" class=\"headerlink\" title=\"第6步-配置依赖注入\"></a><strong>第6步-配置依赖注入</strong></h1><p>现在是时候让您最终了解此概念的工作原理了。</p>\n<p><img src=\"https://uploader.shimo.im/f/GYbYOJqzMqsxEBg3.png!thumbnail\" alt=\"图片\"></p>\n<p>在应用程序的根文件夹中，打开Startup类。此类负责在应用程序启动时配置各种配置。</p>\n<p>该ConfigureServices和Configure方法通过框架管道在运行时调用来配置应用程序应该如何工作，必须使用哪些组件。</p>\n<p>打开ConfigureServices方法。在这里，我们只有一行配置应用程序以使用MVC管道，这基本上意味着该应用程序将使用控制器类来处理请求和响应（在这段代码背后发生了很多事情，但目前您仅需要知道这些）。</p>\n<p>我们可以使用ConfigureServices访问services参数的方法来配置我们的依赖项绑定。清理类代码，删除所有注释并按如下所示更改代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Microsoft.AspNetCore.Builder;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore.Hosting;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore.Mvc;</span><br><span class=\"line\">\tusing Microsoft.EntityFrameworkCore;</span><br><span class=\"line\">\tusing Microsoft.Extensions.Configuration;</span><br><span class=\"line\">\tusing Microsoft.Extensions.DependencyInjection;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Repositories;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services;</span><br><span class=\"line\">\tusing Supermarket.API.Persistence.Contexts;</span><br><span class=\"line\">\tusing Supermarket.API.Persistence.Repositories;</span><br><span class=\"line\">\tusing Supermarket.API.Services;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class Startup</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public IConfiguration Configuration &#123; get; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public Startup(IConfiguration configuration)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            Configuration = configuration;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public void ConfigureServices(IServiceCollection services)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            services.AddDbContext&lt;AppDbContext&gt;(options =&gt; &#123;</span><br><span class=\"line\">\t                options.UseInMemoryDatabase(&quot;supermarket-api-in-memory&quot;);</span><br><span class=\"line\">\t            &#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            services.AddScoped&lt;ICategoryRepository, CategoryRepository&gt;();</span><br><span class=\"line\">\t            services.AddScoped&lt;ICategoryService, CategoryService&gt;();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public void Configure(IApplicationBuilder app, IHostingEnvironment env)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            if (env.IsDevelopment())</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                app.UseDeveloperExceptionPage();</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t            else</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.</span><br><span class=\"line\">\t                app.UseHsts();</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            app.UseHttpsRedirection();</span><br><span class=\"line\">\t            app.UseMvc();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看一下这段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">services.AddDbContext&lt;AppDbContext&gt;(options =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  options.UseInMemoryDatabase(&quot;supermarket-api-in-memory&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们配置数据库上下文。我们告诉ASP.NET Core将其AppDbContext与内存数据库实现一起使用，该实现由作为参数传递给我们方法的字符串标识。通常，在编写<a href=\"https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-2.2\" target=\"_blank\" rel=\"noopener\">集成测试</a>时才会使用内存数据库，但是为了简单起见，我在这里使用了内存数据库。这样，我们无需连接到真实的数据库即可测试应用程序。<br>这些代码行在内部配置我们的数据库上下文，以便使用确定作用域的生存周期进行依赖注入。</p>\n<p>scoped生存周期告诉ASP.NET Core管道，每当它需要解析接收AppDbContext作为构造函数参数的实例的类时，都应使用该类的相同实例。如果内存中没有实例，则管道将创建一个新实例，并在给定请求期间在需要它的所有类中重用它。这样，您无需在需要使用时手动创建类实例。</p>\n<p>如果你想了解其他有关生命周期的知识，可以阅读<a href=\"https://docs.microsoft.com/pt-br/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.2\" target=\"_blank\" rel=\"noopener\">官方文档</a>。</p>\n<p>依赖注入技术为我们提供了许多优势，例如：</p>\n<ul>\n<li>代码可重用性；</li>\n<li>更高的生产力，因为当我们不得不更改实现时，我们无需费心去更改您使用该功能的一百个地方；</li>\n<li>您可以轻松地测试应用程序，因为我们可以使用mock（类的伪实现）隔离必须测试的内容，而我们必须将接口作为构造函数参数进行传递。</li>\n<li>当一个类需要通过构造函数接收更多的依赖关系时，您不必手动更改正在创建实例的所有位置（<strong>太赞了！</strong>）。</li>\n</ul>\n<p>配置数据库上下文之后，我们还将我们的服务和仓储绑定到相应的类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">services.AddScoped&lt;ICategoryRepository, CategoryRepository&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">services.AddScoped&lt;ICategoryService, CategoryService&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们还使用了scoped生存周期，因为这些类在内部必须使用数据库上下文类。在这种情况下，指定相同的范围是有意义的。<br>现在我们配置了依赖绑定，我们必须在Program类上进行一些小的更改，以便数据库正确地初始化种子数据。此步骤仅在使用内存数据库提供程序时才需要执行（请参阅<a href=\"https://github.com/aspnet/EntityFrameworkCore/issues/11666\" target=\"_blank\" rel=\"noopener\">此Github问题</a>以了解原因）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System;</span><br><span class=\"line\">\tusing System.Collections.Generic;</span><br><span class=\"line\">\tusing System.IO;</span><br><span class=\"line\">\tusing System.Linq;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore.Hosting;</span><br><span class=\"line\">\tusing Microsoft.Extensions.Configuration;</span><br><span class=\"line\">\tusing Microsoft.Extensions.DependencyInjection;</span><br><span class=\"line\">\tusing Microsoft.Extensions.Logging;</span><br><span class=\"line\">\tusing Supermarket.API.Persistence.Contexts;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class Program</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public static void Main(string[] args)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            var host = BuildWebHost(args);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            using(var scope = host.Services.CreateScope())</span><br><span class=\"line\">\t            using(var context = scope.ServiceProvider.GetService&lt;AppDbContext&gt;())</span><br><span class=\"line\">\t            &#123;</span><br><span class=\"line\">\t                context.Database.EnsureCreated();</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            host.Run();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public static IWebHost BuildWebHost(string[] args) =&gt;</span><br><span class=\"line\">\t            WebHost.CreateDefaultBuilder(args)</span><br><span class=\"line\">\t            .UseStartup&lt;Startup&gt;()</span><br><span class=\"line\">\t            .Build();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于我们使用的是内存提供程序，因此有必要更改Main方法 添加“ context.Database.EnsureCreated();”代码以确保在应用程序启动时将“创建”数据库。没有此更改，将不会创建我们想要的初始化种子数据。<br>实现了所有基本功能后，就该测试我们的API端点了。</p>\n<h1 id=\"第7步-测试类别\"><a href=\"#第7步-测试类别\" class=\"headerlink\" title=\"第7步-测试类别\"></a><strong>第7步-测试类别</strong></h1><p>在API根文件夹中打开终端或命令提示符，然后键入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet run</span><br></pre></td></tr></table></figure>\n\n<p>上面的命令启动应用程序。控制台将显示类似于以下内容的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">info: Microsoft.EntityFrameworkCore.Infrastructure[10403]</span><br><span class=\"line\"></span><br><span class=\"line\">Entity Framework Core 2.2.0-rtm-35687 initialized ‘AppDbContext’ using provider ‘Microsoft.EntityFrameworkCore.InMemory’ with options: StoreName=supermarket-api-in-memory</span><br><span class=\"line\"></span><br><span class=\"line\">info: Microsoft.EntityFrameworkCore.Update[30100]</span><br><span class=\"line\"></span><br><span class=\"line\">Saved 2 entities to in-memory store.</span><br><span class=\"line\"></span><br><span class=\"line\">info: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[0]</span><br><span class=\"line\"></span><br><span class=\"line\">User profile is available. Using ‘C:\\Users\\evgomes\\AppData\\Local\\ASP.NET\\DataProtection-Keys’ as key repository and Windows DPAPI to encrypt keys at rest.</span><br><span class=\"line\"></span><br><span class=\"line\">Hosting environment: Development</span><br><span class=\"line\"></span><br><span class=\"line\">Content root path: C:\\Users\\evgomes\\Desktop\\Tutorials\\src\\Supermarket.API</span><br><span class=\"line\"></span><br><span class=\"line\">Now listening on: https://localhost:5001</span><br><span class=\"line\"></span><br><span class=\"line\">Now listening on: http://localhost:5000</span><br><span class=\"line\"></span><br><span class=\"line\">Application started. Press Ctrl+C to shut down.</span><br></pre></td></tr></table></figure>\n\n<p>您可以看到调用了EF Core来初始化数据库。最后几行显示应用程序在哪个端口上运行。<br>打开浏览器，然后导航到 <a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">http</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">:</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">//localhost</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">:</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">5000/api/categories</a> （或控制台输出上显示的URL）。如果您发现由于HTTPS导致的安全错误，则只需为应用程序添加一个例外。</p>\n<p>浏览器将显示以下JSON数据作为输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">     &quot;id&quot;: 100,</span><br><span class=\"line\">     &quot;name&quot;: &quot;Fruits and Vegetables&quot;,</span><br><span class=\"line\">     &quot;products&quot;: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">     &quot;id&quot;: 101,</span><br><span class=\"line\">     &quot;name&quot;: &quot;Dairy&quot;,</span><br><span class=\"line\">     &quot;products&quot;: []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们看到配置数据库上下文时添加到数据库的数据。此输出确认我们的代码正在运行。<br>您使用很少的代码行创建了GET API端点，并且由于当前API项目的架构模式，您的代码结构确实很容易更改。</p>\n<p>现在，该向您展示在由于业务需要而不得不对其进行更改时，更改此代码有多么容易。</p>\n<h1 id=\"步骤8-创建类别资源\"><a href=\"#步骤8-创建类别资源\" class=\"headerlink\" title=\"步骤8-创建类别资源\"></a><strong>步骤8-创建类别资源</strong></h1><p>如果您还记得API端点的规范，您会注意到我们的实际JSON响应还有一个额外的属性：<strong>products数组</strong>。看一下所需响应的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  [</span><br><span class=\"line\">    &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Fruits and Vegetables&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;Breads&quot; &#125;,</span><br><span class=\"line\">    … // Other categories</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>产品数组出现在我们当前的JSON响应中，因为我们的Category模型具有Products，EF Core需要的属性，以正确映射给定类别的产品。<br>我们不希望在响应中使用此属性，但是不能更改模型类以排除此属性。当我们尝试管理类别数据时，这将导致EF Core引发错误，并且也将破坏我们的领域模型设计，因为没有产品的产品类别没有意义。</p>\n<p>要返回仅包含超级市场类别的标识符和名称的JSON数据，我们必须创建一个<strong>资源类</strong>。</p>\n<p><a href=\"https://restful-api-design.readthedocs.io/en/latest/resources.html\" target=\"_blank\" rel=\"noopener\">资源类</a>是一种包含将客户端应用程序和API端点之间进行交换的类型，通常以JSON数据的形式出现，以表示一些特定信息的类。</p>\n<p>来自API端点的所有响应都<strong>必须</strong>返回资源。</p>\n<p>将真实模型表示形式作为响应返回是一种不好的做法，因为它可能包含客户端应用程序不需要或没有其权限的信息（例如，用户模型可以返回用户密码的信息） ，这将是一个很大的安全问题）。</p>\n<p>我们需要一种资源来仅代表我们的类别，而没有产品。</p>\n<p>现在您知道什么是资源，让我们实现它。首先，在命令行中按<strong>Ctrl + C</strong>停止正在运行的应用程序。在应用程序的根文件夹中，创建一个名为Resources的新文件夹。在其中添加一个名为的新类CategoryResource。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace Supermarket.API.Resources</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class CategoryResource</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public int Id &#123; get; set; &#125;</span><br><span class=\"line\">\t        public string Name &#123; get; set; &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们必须将类别服务提供的类别模型集合映射到类别资源集合。<br>我们将使用一个名为<a href=\"https://automapper.org/\" target=\"_blank\" rel=\"noopener\">AutoMapper</a>的库来处理对象之间的映射。AutoMapper是.NET世界中非常流行的库，并且在许多商业和开源项目中使用。</p>\n<p>在命令行中输入以下命令，以将AutoMapper添加到我们的应用程序中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet add package AutoMapper</span><br><span class=\"line\"></span><br><span class=\"line\">dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection</span><br></pre></td></tr></table></figure>\n\n<p>要使用AutoMapper，我们必须做两件事：</p>\n<ul>\n<li>注册它以进行依赖注入；</li>\n<li>创建一个类，该类将告诉AutoMapper如何处理类映射。</li>\n</ul>\n<p>首先，打开Startup课程。在该ConfigureServices方法的最后一行之后，添加以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">services.AddAutoMapper();</span><br></pre></td></tr></table></figure>\n\n<p>此行处理AutoMapper的所有必需配置，例如注册它以进行依赖项注入以及在启动过程中扫描应用程序以配置映射配置文件。<br>现在，在根目录中，添加一个名为的新文件夹Mapping，然后添加一个名为的类ModelToResourceProfile。通过以下方式更改代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using AutoMapper;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Resources;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Mapping</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class ModelToResourceProfile : Profile</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public ModelToResourceProfile()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            CreateMap&lt;Category, CategoryResource&gt;();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该类继承Profile了AutoMapper用于检查我们的映射如何工作的类类型。在构造函数上，我们在Category模型类和CategoryResource类之间创建一个映射。由于类的属性具有相同的名称和类型，因此我们不必为其使用任何特殊的配置。<br>最后一步包括更改类别控制器以使用AutoMapper处理我们的对象映射。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing AutoMapper;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore.Mvc;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services;</span><br><span class=\"line\">\tusing Supermarket.API.Resources;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Controllers</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    [Route(&quot;/api/[controller]&quot;)]</span><br><span class=\"line\">\t    public class CategoriesController : Controller</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        private readonly ICategoryService _categoryService;</span><br><span class=\"line\">\t        private readonly IMapper _mapper;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public CategoriesController(ICategoryService categoryService, IMapper mapper)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            _categoryService = categoryService;</span><br><span class=\"line\">\t            _mapper = mapper;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        [HttpGet]</span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;CategoryResource&gt;&gt; GetAllAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            var categories = await _categoryService.ListAsync();</span><br><span class=\"line\">\t            var resources = _mapper.Map&lt;IEnumerable&lt;Category&gt;, IEnumerable&lt;CategoryResource&gt;&gt;(categories);</span><br><span class=\"line\">\t            </span><br><span class=\"line\">\t            return resources;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我更改了构造函数以接收IMapper实现的实例。您可以使用这些接口方法来使用AutoMapper映射方法。<br>我还更改了GetAllAsync使用Map方法将类别枚举映射到资源枚举的方法。此方法接收我们要映射的类或集合的实例，并通过<a href=\"https://www.geeksforgeeks.org/c-generics-introduction/\" target=\"_blank\" rel=\"noopener\">通用类型定义</a>定义必须映射到什么类型的类或集合。</p>\n<p>注意，我们只需将新的依赖项（IMapper）注入构造函数，就可以轻松地更改实现，而不必修改服务类或仓储。</p>\n<p>依赖注入使您的应用程序可维护且易于更改，因为您不必中断所有代码实现即可添加或删除功能。</p>\n<p>您可能意识到，不仅控制器类，而且所有接收依赖项的类（包括依赖项本身）都会根据绑定配置自动解析为接收正确的类。</p>\n<p>依赖注入如此的Amazing，不是吗？</p>\n<p><img src=\"https://uploader.shimo.im/f/wGoOlHek0agFA3kQ.png!thumbnail\" alt=\"图片\"></p>\n<p>现在，使用dotnet run命令再次启动API，然后转到<a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">http</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">:</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">//localhost</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">:</a><a href=\"http://localhost:5000/api/categories\" target=\"_blank\" rel=\"noopener\">5000/api/categories</a>以查看新的JSON响应。</p>\n<p><img src=\"https://uploader.shimo.im/f/xb8S1G8qcWQW3MSN.png!thumbnail\" alt=\"图片\"></p>\n<p>这是您应该看到的响应数据</p>\n<p>我们已经有了GET端点。现在，让我们为POST（<strong>创建</strong>）类别创建一个新端点。</p>\n<h1 id=\"第9步-创建新类别\"><a href=\"#第9步-创建新类别\" class=\"headerlink\" title=\"第9步-创建新类别\"></a><strong>第9步-创建新类别</strong></h1><p>在处理资源创建时，我们必须关心很多事情，例如：</p>\n<ul>\n<li>数据验证和数据完整性；</li>\n<li>授权创建资源；</li>\n<li>错误处理；</li>\n<li>正在记录。</li>\n</ul>\n<p>在本教程中，我不会显示如何处理身份验证和授权，但是您可以阅读<a href=\"https://medium.com/@evandro.ggomes/json-web-token-authentication-with-asp-net-core-2-0-b074b0cfc870\" target=\"_blank\" rel=\"noopener\">JSON Web令牌身份验证</a>教程，了解如何轻松实现这些功能。</p>\n<p>另外，有一个非常流行的框架称为<strong>ASP.NET Identity</strong>，该框架提供了有关安全性和用户注册的内置解决方案，您可以在应用程序中使用它们。它包括与EF Core配合使用的提供程序，例如IdentityDbContext可以使用的内置程序。您可以<a href=\"https://docs.microsoft.com/en-us/aspnet/identity/overview/getting-started/introduction-to-aspnet-identity\" target=\"_blank\" rel=\"noopener\">在此处了解更多信息</a>。</p>\n<p>让我们编写一个HTTP POST端点，该端点将涵盖其他场景（日志记录除外，它可以根据不同的范围和工具进行更改）。</p>\n<p>在创建新端点之前，我们需要一个新资源。此资源会将客户端应用程序发送到此端点的数据（在本例中为类别名称）映射到我们应用程序的类。</p>\n<p>由于我们正在创建一个新类别，因此我们还没有ID，这意味着我们需要一种资源来表示仅包含其名称的类别。</p>\n<p>在Resources文件夹中，添加一个新类SaveCategoryResource：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.ComponentModel.DataAnnotations;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Resources</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class SaveCategoryResource</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        [Required]</span><br><span class=\"line\">\t        [MaxLength(30)]</span><br><span class=\"line\">\t        public string Name &#123; get; set; &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意Name属性上的Required和MaxLength特性。这些属性称为<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations?view=netframework-4.7.2\" target=\"_blank\" rel=\"noopener\">数据注释</a>。ASP.NET Core管道使用此元数据来验证请求和响应。顾名思义，类别名称是必填项，最大长度为30个字符。<br>现在，让我们定义新API端点的形状。将以下代码添加到类别控制器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpPost]</span><br><span class=\"line\">\tpublic async Task&lt;IActionResult&gt; PostAsync([FromBody] SaveCategoryResource resource)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们使用HttpPost特性告诉框架这是一个HTTP POST端点。<br>注意此方法的响应类型Task<iactionresult>。控制器类中存在的方法称为<strong>动作</strong>，它们具有此签名，因为在应用程序执行动作之后，我们可以返回一个以上的可能结果。</iactionresult></p>\n<p>在这种情况下，如果类别名称无效或出现问题，我们必须返回<strong>400代码（错误请求）</strong>响应，该响应通常包含一条错误消息，客户端应用程序可以使用该错误消息来解决该问题，或者我们可以如果一切正常，则对数据进行<strong>200次响应（成功）</strong>。</p>\n<p>可以将多种类型的操作类型用作响应，但是通常，我们可以使用此接口，并且ASP.NET Core将为此使用默认类。</p>\n<p>该FromBody属性告诉ASP.NET Core将请求正文数据解析为我们的新资源类。这意味着当包含类别名称的JSON发送到我们的应用程序时，框架将自动将其解析为我们的新类。</p>\n<p>现在，让我们实现路由逻辑。我们必须遵循一些步骤才能成功创建新类别：</p>\n<ul>\n<li>首先，我们必须验证传入的请求。如果请求无效，我们必须返回包含错误消息的错误请求响应；</li>\n<li>然后，如果请求有效，则必须使用AutoMapper将新资源映射到类别模型类。</li>\n<li>现在，我们需要调用我们的服务，告诉它保存我们的新类别。如果执行保存逻辑没有问题，它将返回一个包含我们新类别数据的响应。如果没有，它应该给我们一个指示，表明该过程失败了，并可能出现错误消息。</li>\n<li>最后，如果有错误，我们将返回错误的请求。如果没有，我们将新的类别模型映射到类别资源，并向客户端返回包含新类别数据的成功响应。</li>\n</ul>\n<p>这似乎很复杂，但是使用为API构建的服务架构来实现此逻辑确实很容易。</p>\n<p>让我们开始验证传入的请求。</p>\n<h1 id=\"步骤10-使用模型状态验证请求主体\"><a href=\"#步骤10-使用模型状态验证请求主体\" class=\"headerlink\" title=\"步骤10-使用模型状态验证请求主体\"></a><strong>步骤10-使用模型状态验证请求主体</strong></h1><p>ASP.NET Core控制器具有名为ModelState的属性。在执行我们的操作<strong>之前，</strong>该属性在请求执行期间填充。它是ModelStateDictionary的实例，该类包含诸如请求是否有效以及潜在的验证错误消息之类的信息。</p>\n<p>如下更改端点代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpPost]</span><br><span class=\"line\">\tpublic async Task&lt;IActionResult&gt; PostAsync([FromBody] SaveCategoryResource resource)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (!ModelState.IsValid)</span><br><span class=\"line\">\t\t\treturn BadRequest(ModelState.GetErrorMessages());</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码检查模型状态（在这种情况下为请求正文中发送的数据）是否无效，并检查我们的数据注释。如果不是，则API返回错误的请求（状态代码400），以及我们的注释元数据提供的默认错误消息。<br>该ModelState.GetErrorMessages()方法尚未实现。这是一种<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods\" target=\"_blank\" rel=\"noopener\">扩展方法</a>（一种扩展现有类或接口功能的方法），我将实现该方法将验证错误转换为简单的字符串以返回给客户端。</p>\n<p>Extensions在我们的API的根目录中添加一个新文件夹，然后添加一个新类ModelStateExtensions。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Linq;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore.Mvc.ModelBinding;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Extensions</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public static class ModelStateExtensions</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public static List&lt;string&gt; GetErrorMessages(this ModelStateDictionary dictionary)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            return dictionary.SelectMany(m =&gt; m.Value.Errors)</span><br><span class=\"line\">\t                             .Select(m =&gt; m.ErrorMessage)</span><br><span class=\"line\">\t                             .ToList();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所有扩展方法以及声明它们的类都应该是<strong>静态的</strong>。** **这意味着它们不处理特定的实例数据，并且在应用程序启动时仅被加载一次。<br>this参数声明前面的关键字告诉C＃编译器将其视为扩展方法。结果是我们可以像此类的常规方法一样调用它，因为我们在要使用扩展的地方包含的特定的using代码。</p>\n<p>该扩展使用<a href=\"https://www.tutorialsteacher.com/linq/what-is-linq\" target=\"_blank\" rel=\"noopener\">LINQ查询</a>，这是.NET的非常有用的功能，它使我们能够使用链式语法来查询和转换数据。此处的表达式将验证错误方法转换为包含错误消息的字符串列表。</p>\n<p>Supermarket.API.Extensions在进行下一步之前，将名称空间导入Categories控制器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Supermarket.API.Extensions;</span><br></pre></td></tr></table></figure>\n\n<p>让我们通过将新资源映射到类别模型类来继续实现端点逻辑。</p>\n<h1 id=\"步骤11-映射新资源\"><a href=\"#步骤11-映射新资源\" class=\"headerlink\" title=\"步骤11-映射新资源\"></a><strong>步骤11-映射新资源</strong></h1><p>我们已经定义了映射配置文件，可以将模型转换为资源。现在，我们需要一个与之相反的新配置项。</p>\n<p>ResourceToModelProfile在Mapping文件夹中添加一个新类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using AutoMapper;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Resources;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Mapping</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class ResourceToModelProfile : Profile</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public ResourceToModelProfile()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            CreateMap&lt;SaveCategoryResource, Category&gt;();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里没有新内容。由于依赖注入的魔力，AutoMapper将在应用程序启动时自动注册此配置文件，而我们无需更改任何其他位置即可使用它。<br>现在，我们可以将新资源映射到相应的模型类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpPost]</span><br><span class=\"line\">\tpublic async Task&lt;IActionResult&gt; PostAsync([FromBody] SaveCategoryResource resource)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (!ModelState.IsValid)</span><br><span class=\"line\">\t\t\treturn BadRequest(ModelState.GetErrorMessages());</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar category = _mapper.Map&lt;SaveCategoryResource, Category&gt;(resource);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第12步-应用请求-响应模式来处理保存逻辑\"><a href=\"#第12步-应用请求-响应模式来处理保存逻辑\" class=\"headerlink\" title=\"第12步-应用请求-响应模式来处理保存逻辑\"></a><strong>第12步-应用请求-响应模式来处理保存逻辑</strong></h1><p>现在我们必须实现最有趣的逻辑：保存一个新类别。我们希望我们的服务能够做到。</p>\n<p>由于连接到数据库时出现问题，或者由于任何内部业务规则使我们的数据无效，因此保存逻辑可能会失败。</p>\n<p>如果出现问题，我们不能简单地抛出一个错误，因为它可能会停止API，并且客户端应用程序也不知道如何处理该问题。另外，我们可能会有某种日志记录机制来记录错误。</p>\n<p>保存方法的约定（即方法的签名和响应类型）需要指示我们是否正确执行了该过程。如果处理正常，我们将接收类别数据。如果没有，我们至少必须收到一条错误消息，告诉您该过程失败的原因。</p>\n<p>我们可以通过应用<strong>request-response模式</strong>来实现此功能。这种企业设计模式将我们的请求和响应参数封装到类中，以封装我们的服务将用于处理某些任务并将信息返回给正在使用该服务的类的信息。</p>\n<p>这种模式为我们提供了一些优势，例如：</p>\n<ul>\n<li>如果我们需要更改服务以接收更多参数，则不必破坏其签名；</li>\n<li>我们可以为我们的请求和/或响应定义标准合同；</li>\n<li>我们可以在不停止应用程序流程的情况下处理业务逻辑和潜在的失败，并且我们不需要使用大量的try-catch块。</li>\n</ul>\n<p>让我们为处理数据更改的服务方法创建一个标准响应类型。对于这种类型的每个请求，我们都想知道该请求是否被正确执行。如果失败，我们要向客户端返回错误消息。</p>\n<p>在Domain文件夹的内部Services，添加一个名为的新目录Communication。在此处添加一个名为的新类BaseResponse。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace Supermarket.API.Domain.Services.Communication</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public abstract class BaseResponse</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public bool Success &#123; get; protected set; &#125;</span><br><span class=\"line\">\t        public string Message &#123; get; protected set; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public BaseResponse(bool success, string message)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            Success = success;</span><br><span class=\"line\">\t            Message = message;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那是我们的响应类型将继承的抽象类。<br>抽象定义了一个Success属性和一个Message属性，该属性将告知请求是否已成功完成，如果失败，该属性将显示错误消息。</p>\n<p>请注意，这些属性是必需的，只有继承的类才能设置此数据，因为子类必须通过构造函数传递此信息。</p>\n<blockquote>\n<p><strong>提示：</strong>为所有内容定义基类不是一个好习惯，因为<a href=\"https://en.wikipedia.org/wiki/Fragile_base_class\" target=\"_blank\" rel=\"noopener\">基类会耦合您的代码</a>并阻止您轻松对其进行修改。优先使用<a href=\"https://medium.com/humans-create-software/composition-over-inheritance-cb6f88070205\" target=\"_blank\" rel=\"noopener\">组合而不是继承</a>。</p>\n<blockquote>\n<p>在此API的范围内，使用基类并不是真正的问题，因为我们的服务不会增长太多。如果您意识到服务或应用程序会经常增长和更改，请避免使用基类。</p>\n</blockquote>\n</blockquote>\n<p>现在，在同一文件夹中，添加一个名为的新类SaveCategoryResponse。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using Supermarket.API.Domain.Models;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Services.Communication</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class SaveCategoryResponse : BaseResponse</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public Category Category &#123; get; private set; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        private SaveCategoryResponse(bool success, string message, Category category) : base(success, message)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            Category = category;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        /// &lt;summary&gt;</span><br><span class=\"line\">\t        /// Creates a success response.</span><br><span class=\"line\">\t        /// &lt;/summary&gt;</span><br><span class=\"line\">\t        /// &lt;param name=&quot;category&quot;&gt;Saved category.&lt;/param&gt;</span><br><span class=\"line\">\t        /// &lt;returns&gt;Response.&lt;/returns&gt;</span><br><span class=\"line\">\t        public SaveCategoryResponse(Category category) : this(true, string.Empty, category)</span><br><span class=\"line\">\t        &#123; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        /// &lt;summary&gt;</span><br><span class=\"line\">\t        /// Creates am error response.</span><br><span class=\"line\">\t        /// &lt;/summary&gt;</span><br><span class=\"line\">\t        /// &lt;param name=&quot;message&quot;&gt;Error message.&lt;/param&gt;</span><br><span class=\"line\">\t        /// &lt;returns&gt;Response.&lt;/returns&gt;</span><br><span class=\"line\">\t        public SaveCategoryResponse(string message) : this(false, message, null)</span><br><span class=\"line\">\t        &#123; &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>响应类型还设置了一个Category属性，如果请求成功完成，该属性将包含我们的类别数据。<br>请注意，我为此类定义了三种不同的构造函数：</p>\n<ul>\n<li>一个私有的，它将把成功和消息参数传递给基类，并设置Category属性。</li>\n<li>仅接收类别作为参数的构造函数。这将创建一个成功的响应，调用私有构造函数来设置各自的属性；</li>\n<li>第三个构造函数仅指定消息。这将用于创建故障响应。</li>\n</ul>\n<p>因为C＃支持多个构造函数，所以我们仅通过使用不同的构造函数就简化了响应的创建过程，而无需定义其他方法来处理此问题。</p>\n<p>现在，我们可以更改服务界面以添加新的保存方法合同。</p>\n<p>更改ICategoryService接口，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services.Communication;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Services</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public interface ICategoryService</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t         Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class=\"line\">\t         Task&lt;SaveCategoryResponse&gt; SaveAsync(Category category);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们只需将类别传递给此方法，它将处理保存模型数据，编排仓储和其他必要服务所需的所有逻辑。<br>请注意，由于我们不需要任何其他参数来执行此任务，因此我不在此处创建特定的请求类。<a href=\"https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle\" target=\"_blank\" rel=\"noopener\">计算机编程中</a>有一个名为<a href=\"https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle\" target=\"_blank\" rel=\"noopener\">KISS</a>的<a href=\"https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle\" target=\"_blank\" rel=\"noopener\">概念</a> —Keep It Simple，Stupid的简称。基本上，它说您应该使您的应用程序尽可能简单。</p>\n<p>设计应用程序时请记住这一点：<strong>仅</strong>应用<strong>解决问题所需的内容</strong>。<strong>不要过度设计您的应用程序。</strong></p>\n<p>现在我们可以完成端点逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpPost]</span><br><span class=\"line\">\tpublic async Task&lt;IActionResult&gt; PostAsync([FromBody] SaveCategoryResource resource)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (!ModelState.IsValid)</span><br><span class=\"line\">\t\t\treturn BadRequest(ModelState.GetErrorMessages());</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar category = _mapper.Map&lt;SaveCategoryResource, Category&gt;(resource);</span><br><span class=\"line\">\t\tvar result = await _categoryService.SaveAsync(category);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (!result.Success)</span><br><span class=\"line\">\t\t\treturn BadRequest(result.Message);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar categoryResource = _mapper.Map&lt;Category, CategoryResource&gt;(result.Category);</span><br><span class=\"line\">\t\treturn Ok(categoryResource);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在验证请求数据并将资源映射到我们的模型之后，我们将其传递给我们的服务以保留数据。<br>如果失败，则API返回错误的请求。如果没有，API会将新类别（现在包括诸如new的数据Id）映射到我们先前创建的类别CategoryResource，并将其发送给客户端。</p>\n<p>现在，让我们为服务实现真正的逻辑。</p>\n<p><strong>第13步—数据库逻辑和工作单元模式</strong></p>\n<p>由于我们要将数据持久化到数据库中，因此我们需要在仓储中使用一种新方法。</p>\n<p>向ICategoryRepository接口添加AddAsync新方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ICategoryRepository</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class=\"line\">\t\t Task AddAsync(Category category);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，让我们在真正的仓储类中实现此方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CategoryRepository : BaseRepository, ICategoryRepository</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpublic CategoryRepository(AppDbContext context) : base(context)</span><br><span class=\"line\">\t\t&#123; &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublic async Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync()</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\treturn await _context.Categories.ToListAsync();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublic async Task AddAsync(Category category)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tawait _context.Categories.AddAsync(category);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们只是在集合中添加一个新类别。<br>当我们向中添加类时DBSet&lt;&gt;，EF Core将开始跟踪模型发生的所有更改，并在当前状态下使用此数据生成将插入，更新或删除模型的查询。</p>\n<p>当前的实现只是将模型添加到我们的集合中，但是<strong>我们的数据仍然不会保存</strong>。</p>\n<p>在上下文类中提供了SaveChanges的方法，我们必须调用该方法才能真正将查询执行到数据库中。我之所以没有在这里调用它，是因为<a href=\"https://programmingwithmosh.com/entity-framework/common-mistakes-with-the-repository-pattern/\" target=\"_blank\" rel=\"noopener\">仓储不应该持久化数据</a>，它只是一种内存集合对象。</p>\n<p>即使在经验丰富的.NET开发人员之间，该主题也引起很大争议，但是让我向您解释为什么您不应该在仓储类中调用SaveChanges方法。</p>\n<p>我们可以从概念上将仓储像.NET框架中存在的任何其他集合一样。在.NET（和许多其他编程语言，例如Javascript和Java）中处理集合时，通常可以：</p>\n<ul>\n<li>向其中添加新项（例如，当您将数据推送到列表，数组和字典时）；</li>\n<li>查找或过滤项目；</li>\n<li>从集合中删除一个项目；</li>\n<li>替换给定的项目，或更新它。</li>\n</ul>\n<p>想一想现实世界中的清单。想象一下，您正在编写一份购物清单以在超市购买东西（<em>巧合，不是吗？</em>）。</p>\n<p>在列表中，写下您需要购买的所有水果。您可以将水果添加到此列表中，如果放弃购买就删除水果，也可以替换水果的名称。但是您无法<strong>将</strong>水果<strong>保存</strong>到列表中。用简单的英语说这样的话是没有意义的。</p>\n<blockquote>\n<p><strong>提示：</strong>在使用面向对象的编程语言设计类和接口时，请尝试使用自然语言来检查您所做的工作是否正确。</p>\n<blockquote>\n<p>例如，说人实现了person的接口是有道理的，但是说一个人实现了一个帐户却没有道理。</p>\n</blockquote>\n</blockquote>\n<p>如果您要“保存”水果清单（在这种情况下，要购买所有水果），请付款，然后超市会处理库存数据以检查他们是否必须从供应商处购买更多水果。</p>\n<p>编程时可以应用相同的逻辑。仓储不应保存，更新或删除数据。相反，他们应该将其委托给其他类来处理此逻辑。</p>\n<p>将数据直接保存到仓储中时，还有另一个问题：<strong>您不能使用transaction</strong>。</p>\n<p>想象一下，我们的应用程序具有一种日志记录机制，该机制存储一些用户名，并且每次对API数据进行更改时都会执行操作。</p>\n<p>现在想象一下，由于某种原因，您调用了一个更新用户名的服务（这是不常见的情况，但让我们考虑一下）。</p>\n<p>您同意要更改虚拟用户表中的用户名，首先必须更新所有日志以正确告诉谁执行了该操作，对吗？</p>\n<p>现在想象我们已经为用户和不同仓储中的日志实现了update方法，它们都调用了SaveChanges。如果这些方法之一在更新过程中失败，会发生什么？最终会导致数据不一致。</p>\n<p>只有在一切完成之后，我们才应该将更改保存到数据库中。为此，我们必须使用<a href=\"https://en.wikipedia.org/wiki/Database_transaction\" target=\"_blank\" rel=\"noopener\">transaction</a>，这基本上是大多数数据库实现的功能，只有在完成复杂的操作后才能保存数据。</p>\n<p><em>“-好的，所以如果我们不能在这里保存东西，我们应该在哪里做？”</em></p>\n<p>处理此问题的常见模式是<a href=\"https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application\" target=\"_blank\" rel=\"noopener\">工作单元模式</a>。此模式包含一个类，该类将我们的AppDbContext实例作为依赖项接收，并公开用于开始，完成或中止事务的方法。</p>\n<p>在这里，我们将使用工作单元的简单实现来解决我们的问题。</p>\n<p>Repositories在Domain层的仓储文件夹Repositories内添加一个新接口IUnitOfWork：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Repositories</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public interface IUnitOfWork</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t         Task CompleteAsync();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如您所见，它仅公开一种将异步完成数据管理操作的方法。<br>现在让我们添加实际的实现。</p>\n<p>在Persistence层RepositoriesRepositories文件夹中的添加一个名为的UnitOfWork的新类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Repositories;</span><br><span class=\"line\">\tusing Supermarket.API.Persistence.Contexts;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Persistence.Repositories</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class UnitOfWork : IUnitOfWork</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        private readonly AppDbContext _context;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public UnitOfWork(AppDbContext context)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            _context = context;     </span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public async Task CompleteAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            await _context.SaveChangesAsync();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个简单，干净的实现，仅在使用仓储修改完所有更改后，才将所有更改保存到数据库中。<br>如果研究工作单元模式的实现，则会发现实现回滚操作的更复杂的模式。</p>\n<p>由于<strong>EF Core已经在后台实现了仓储模式和工作单元</strong>，因此我们不必在意回滚方法。</p>\n<p><em>“ - 什么？那么为什么我们必须创建所有这些接口和类？”</em></p>\n<p>将持久性逻辑与业务规则分开在代码可重用性和维护方面具有许多优势。如果直接使用EF Core，我们最终将拥有更复杂的类，这些类将很难更改。</p>\n<p>想象一下，将来您决定将ORM框架更改为其他框架，例如<a href=\"https://www.c-sharpcorner.com/article/crud-operation-in-asp-net-core-2-0-using-dapper-orm/\" target=\"_blank\" rel=\"noopener\">Dapper</a>，或者由于性能而必须实施纯SQL查询。如果将查询逻辑与服务耦合在一起，将很难更改该逻辑，因为您必须在许多类中进行此操作。</p>\n<p>使用仓储模式，您可以简单地实现一个新的仓储类并使用依赖注入将其绑定。</p>\n<p>因此，基本上，如果您直接在服务中使用EF Core，并且必须进行一些更改，那么您将获得：</p>\n<p>就像我说的那样，EF Core在后台实现了工作单元和仓储模式。我们可以将DbSet&lt;&gt;属性视为仓储。而且，SaveChanges仅在所有数据库操作成功的情况下才保留数据。</p>\n<p>现在，您知道什么是工作单元以及为什么将其与仓储一起使用，让我们实现真实服务的逻辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CategoryService : ICategoryService</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tprivate readonly ICategoryRepository _categoryRepository;</span><br><span class=\"line\">\t\tprivate readonly IUnitOfWork _unitOfWork;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublic CategoryService(ICategoryRepository categoryRepository, IUnitOfWork unitOfWork)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_categoryRepository = categoryRepository;</span><br><span class=\"line\">\t\t\t_unitOfWork = unitOfWork;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublic async Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync()</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\treturn await _categoryRepository.ListAsync();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublic async Task&lt;SaveCategoryResponse&gt; SaveAsync(Category category)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttry</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tawait _categoryRepository.AddAsync(category);</span><br><span class=\"line\">\t\t\t\tawait _unitOfWork.CompleteAsync();</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t\treturn new SaveCategoryResponse(category);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcatch (Exception ex)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t// Do some logging stuff</span><br><span class=\"line\">\t\t\t\treturn new SaveCategoryResponse($&quot;An error occurred when saving the category: &#123;ex.Message&#125;&quot;);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>多亏了我们的解耦架构，我们可以简单地将实例UnitOfWork作为此类的依赖传递。<br>我们的业务逻辑非常简单。</p>\n<p>首先，我们尝试将新类别添加到数据库中，然后API尝试保存新类别，将所有内容包装在try-catch块中。</p>\n<p>如果失败，则API会调用一些虚构的日志记录服务，并返回指示失败的响应。</p>\n<p>如果该过程顺利完成，则应用程序将返回成功响应，并发送我们的类别数据。简单吧？</p>\n<blockquote>\n<p><strong>提示：</strong>在现实世界的应用程序中，您不应将所有内容包装在通用的try-catch块中，而应分别处理所有可能的错误。</p>\n<blockquote>\n<p>简单地添加一个try-catch块并不能解决大多数可能的失败情况。请确保正确实现错误处理。</p>\n</blockquote>\n</blockquote>\n<p>测试我们的API之前的最后一步是将工作单元接口绑定到其各自的类。</p>\n<p>将此新行添加到类的ConfigureServices方法中Startup：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">services.AddScoped&lt;IUnitOfWork, UnitOfWork&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>现在让我们测试一下！<br><strong>第14步-使用Postman测试我们的POST端点</strong></p>\n<p>重新启动我们的应用程序dotnet run。</p>\n<p>我们无法使用浏览器测试POST端点。让我们使用<strong>Postman</strong>测试我们的端点。这是测试RESTful API的非常有用的工具。</p>\n<p>打开<strong>Postman</strong>，然后关闭介绍性消息。您会看到这样的屏幕：</p>\n<p><img src=\"https://uploader.shimo.im/f/k9uqO0tzHP8sXyGu.png!thumbnail\" alt=\"图片\"></p>\n<p>屏幕显示测试端点的选项</p>\n<p>GET默认情况下，将所选内容更改为选择框POST。</p>\n<p>在Enter request URL字段中输入API地址。</p>\n<p>我们必须提供请求正文数据以发送到我们的API。单击Body菜单项，然后将其下方显示的选项更改为raw。</p>\n<p>Postman将在右侧显示一个Text选项，将其更改为JSON (application/json)并粘贴以下JSON数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://uploader.shimo.im/f/aMktVnVAavwvF3Q3.png!thumbnail\" alt=\"图片\">发送请求前的屏幕</p>\n<p>如您所见，我们将向我们的新端点发送一个空的名称字符串。</p>\n<p>点击Send按钮。您将收到如下输出：</p>\n<p><img src=\"https://uploader.shimo.im/f/5yuSjCfYKD0ELqiA.png!thumbnail\" alt=\"图片\"></p>\n<p>如您所见，我们的验证逻辑有效！</p>\n<p>您还记得我们为端点创建的验证逻辑吗？此输出是它起作用的证明！</p>\n<p>还要注意右侧显示的400状态代码。该BadRequest结果自动将此状态码的响应。</p>\n<p>现在，让我们将JSON数据更改为有效数据，以查看新的响应：</p>\n<p><img src=\"https://uploader.shimo.im/f/zDpJNG3Yl8Q0XimL.png!thumbnail\" alt=\"图片\"></p>\n<p>最后，我们期望得到的结果</p>\n<p>API正确创建了我们的新资源。</p>\n<p>到目前为止，我们的API可以列出和创建类别。您学到了很多有关C＃语言，ASP.NET Core框架以及构造API的通用设计方法的知识。</p>\n<p>让我们继续我们的类别API，创建用于更新类别的端点。</p>\n<p>从现在开始，由于我向您解释了大多数概念，因此我将加快解释速度，并专注于新主题，以免浪费您的时间。 Let’s go!</p>\n<h1 id=\"第15步-更新类别\"><a href=\"#第15步-更新类别\" class=\"headerlink\" title=\"第15步-更新类别\"></a><strong>第15步-更新类别</strong></h1><p>要更新类别，我们需要一个HTTP PUT端点。</p>\n<p>我们必须编写的逻辑与POST逻辑非常相似：</p>\n<ul>\n<li>首先，我们必须使用来验证传入的请求ModelState。</li>\n<li>如果请求有效，则API应使用AutoMapper将传入资源映射到模型类。</li>\n<li>然后，我们需要调用我们的服务，告诉它更新类别，提供相应的类别Id和更新的数据；</li>\n<li>如果Id数据库中没有给定的类别，我们将返回错误的请求。我们可以使用NotFound结果来代替，但是对于这个范围而言，这并不重要，因为我们向客户端应用程序提供了错误消息。</li>\n<li>如果正确执行了保存逻辑，则服务必须返回包含更新的类别数据的响应。如果不是，它应该给我们指示该过程失败，并显示一条消息指示原因；</li>\n<li>最后，如果有错误，则API返回错误的请求。如果不是，它将更新的类别模型映射到类别资源，并将成功响应返回给客户端应用程序。</li>\n</ul>\n<p>让我们将新PutAsync方法添加到控制器类中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpPut(&quot;&#123;id&#125;&quot;)]</span><br><span class=\"line\">\tpublic async Task&lt;IActionResult&gt; PutAsync(int id, [FromBody] SaveCategoryResource resource)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (!ModelState.IsValid)</span><br><span class=\"line\">\t\t\treturn BadRequest(ModelState.GetErrorMessages());</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar category = _mapper.Map&lt;SaveCategoryResource, Category&gt;(resource);</span><br><span class=\"line\">\t\tvar result = await _categoryService.UpdateAsync(id, category);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (!result.Success)</span><br><span class=\"line\">\t\t\treturn BadRequest(result.Message);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar categoryResource = _mapper.Map&lt;Category, CategoryResource&gt;(result.Category);</span><br><span class=\"line\">\t\treturn Ok(categoryResource);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果将其与POST逻辑进行比较，您会注意到这里只有一个区别：HttPut属性指定给定路由应接收的参数。<br>我们将调用此端点，将类别指定Id 为最后一个URL片段，例如/api/categories/1。ASP.NET Core管道将此片段解析为相同名称的参数。</p>\n<p>现在我们必须UpdateAsync在ICategoryService接口中定义方法签名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ICategoryService</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tTask&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class=\"line\">\t\tTask&lt;SaveCategoryResponse&gt; SaveAsync(Category category);</span><br><span class=\"line\">\t\tTask&lt;SaveCategoryResponse&gt; UpdateAsync(int id, Category category);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在让我们转向真正的逻辑。</p>\n<h1 id=\"第16步-更新逻辑\"><a href=\"#第16步-更新逻辑\" class=\"headerlink\" title=\"第16步-更新逻辑\"></a><strong>第16步-更新逻辑</strong></h1><p>首先，要更新类别，我们需要从数据库中返回当前数据（如果存在）。我们还需要将其更新到我们的中DBSet&lt;&gt;。</p>\n<p>让我们在ICategoryService界面中添加两个新的方法约定：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ICategoryRepository</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tTask&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class=\"line\">\t\tTask AddAsync(Category category);</span><br><span class=\"line\">\t\tTask&lt;Category&gt; FindByIdAsync(int id);</span><br><span class=\"line\">\t\tvoid Update(Category category);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们已经定义了FindByIdAsync方法，该方法将从数据库中异步返回一个类别，以及该Update方法。请注意，该Update方法不是异步的，因为EF Core API不需要异步方法来更新模型。<br>现在，让我们在CategoryRepository类中实现真正的逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public async Task&lt;Category&gt; FindByIdAsync(int id)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn await _context.Categories.FindAsync(id);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void Update(Category category)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t_context.Categories.Update(category);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们可以对服务逻辑进行编码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public async Task&lt;SaveCategoryResponse&gt; UpdateAsync(int id, Category category)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvar existingCategory = await _categoryRepository.FindByIdAsync(id);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (existingCategory == null)</span><br><span class=\"line\">\t\t\treturn new SaveCategoryResponse(&quot;Category not found.&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\texistingCategory.Name = category.Name;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttry</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_categoryRepository.Update(existingCategory);</span><br><span class=\"line\">\t\t\tawait _unitOfWork.CompleteAsync();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\treturn new SaveCategoryResponse(existingCategory);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcatch (Exception ex)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t// Do some logging stuff</span><br><span class=\"line\">\t\t\treturn new SaveCategoryResponse($&quot;An error occurred when updating the category: &#123;ex.Message&#125;&quot;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>API尝试从数据库中获取类别。如果结果为null，我们将返回一个响应，告知该类别不存在。如果类别存在，我们需要设置其新名称。<br>然后，API会尝试保存更改，例如创建新类别时。如果该过程完成，则该服务将返回成功响应。如果不是，则执行日志记录逻辑，并且端点接收包含错误消息的响应。</p>\n<p>现在让我们对其进行测试。首先，让我们添加一个新类别Id以使用有效类别。我们可以使用播种到数据库中的类别的标识符，但是我想通过这种方式向您展示我们的API将更新正确的资源。</p>\n<p>再次运行该应用程序，然后使用Postman将新类别发布到数据库中：</p>\n<p><img src=\"https://uploader.shimo.im/f/fxIzjvpz7Y0kf8XP.png!thumbnail\" alt=\"图片\"></p>\n<p>添加新类别以供日后更新</p>\n<p>使用一个可用的数据Id，将POST 选项更改PUT为选择框，然后在URL的末尾添加ID值。将name属性更改为其他名称，然后发送请求以检查结果：</p>\n<p><img src=\"https://uploader.shimo.im/f/VMXmxLVsZNsqqXSK.png!thumbnail\" alt=\"图片\"></p>\n<p>类别数据已成功更新</p>\n<p>您可以将GET请求发送到API端点，以确保您正确编辑了类别名称：</p>\n<p><img src=\"https://uploader.shimo.im/f/G5ipYxpQk5gJSVBI.png!thumbnail\" alt=\"图片\"></p>\n<p>那是现在GET请求的结果</p>\n<p>我们必须对类别执行的最后一项操作是排除类别。让我们创建一个HTTP Delete端点。</p>\n<h1 id=\"第17步-删除类别\"><a href=\"#第17步-删除类别\" class=\"headerlink\" title=\"第17步-删除类别\"></a><strong>第17步-删除类别</strong></h1><p>删除类别的逻辑确实很容易实现，因为我们所需的大多数方法都是先前构建的。</p>\n<p>这些是我们工作路线的必要步骤：</p>\n<ul>\n<li>API需要调用我们的服务，告诉它删除我们的类别，并提供相应的Id;</li>\n<li>如果数据库中没有具有给定ID的类别，则该服务应返回一条消息指出该类别；</li>\n<li>如果执行删除逻辑没有问题，则服务应返回包含我们已删除类别数据的响应。如果没有，它应该给我们一个指示，表明该过程失败了，并可能出现错误消息。</li>\n<li>最后，如果有错误，则API返回错误的请求。如果不是，则API会将更新的类别映射到资源，并向客户端返回成功响应。</li>\n</ul>\n<p>让我们开始添加新的端点逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpDelete(&quot;&#123;id&#125;&quot;)]</span><br><span class=\"line\">\tpublic async Task&lt;IActionResult&gt; DeleteAsync(int id)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvar result = await _categoryService.DeleteAsync(id);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (!result.Success)</span><br><span class=\"line\">\t\t\treturn BadRequest(result.Message);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar categoryResource = _mapper.Map&lt;Category, CategoryResource&gt;(result.Category);</span><br><span class=\"line\">\t\treturn Ok(categoryResource);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该HttpDelete属性还定义了一个id 模板。<br>在将DeleteAsync签名添加到我们的ICategoryService接口之前，我们需要做一些小的重构。</p>\n<p>新的服务方法必须返回包含类别数据的响应，就像对PostAsyncand UpdateAsync方法所做的一样。我们可以SaveCategoryResponse为此目的重用，但在这种情况下我们不会保存数据。</p>\n<p>为了避免创建具有相同形状的新类来满足此要求，我们可以将我们重命名SaveCategoryResponse为CategoryResponse。</p>\n<p>如果您使用的是Visual Studio Code，则可以打开SaveCategoryResponse类，将鼠标光标放在类名上方，然后使用选项Change All Occurrences<strong>* *</strong>来重命名该类：</p>\n<p><img src=\"https://uploader.shimo.im/f/9F3zYANcrMUdFlMe.png!thumbnail\" alt=\"图片\"></p>\n<p>确保也重命名文件名。</p>\n<p>让我们将DeleteAsync方法签名添加到ICategoryService 接口中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ICategoryService</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tTask&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class=\"line\">\t\tTask&lt;CategoryResponse&gt; SaveAsync(Category category);</span><br><span class=\"line\">\t\tTask&lt;CategoryResponse&gt; UpdateAsync(int id, Category category);</span><br><span class=\"line\">\t\tTask&lt;CategoryResponse&gt; DeleteAsync(int id);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在实施删除逻辑之前，我们需要在仓储中使用一种新方法。<br>将Remove方法签名添加到ICategoryRepository接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Remove(Category category);</span><br></pre></td></tr></table></figure>\n\n<p>现在，在仓储类上添加真正的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void Remove(Category category)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t_context.Categories.Remove(category);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>EF Core要求将模型的实例传递给Remove方法，以正确了解我们要删除的模型，而不是简单地传递Id。<br>最后，让我们在CategoryService类上实现逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public async Task&lt;CategoryResponse&gt; DeleteAsync(int id)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tvar existingCategory = await _categoryRepository.FindByIdAsync(id);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (existingCategory == null)</span><br><span class=\"line\">\t\t\treturn new CategoryResponse(&quot;Category not found.&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttry</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_categoryRepository.Remove(existingCategory);</span><br><span class=\"line\">\t\t\tawait _unitOfWork.CompleteAsync();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\treturn new CategoryResponse(existingCategory);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcatch (Exception ex)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t// Do some logging stuff</span><br><span class=\"line\">\t\t\treturn new CategoryResponse($&quot;An error occurred when deleting the category: &#123;ex.Message&#125;&quot;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里没有新内容。该服务尝试通过ID查找类别，然后调用我们的仓储以删除类别。最后，工作单元完成将实际操作执行到数据库中的事务。<br><em>“-嘿，但是每个类别的产品呢？为避免出现错误，您是否不需要先创建仓储并删除产品？”</em></p>\n<p>答案是<strong>否定的</strong>。借助<a href=\"https://docs.microsoft.com/en-us/ef/core/querying/tracking\" target=\"_blank\" rel=\"noopener\">EF Core跟踪机制</a>，当我们从数据库中加载模型时，框架便知道了该模型具有哪些关系。如果我们删除它，EF Core知道它应该首先递归删除所有相关模型。</p>\n<p>在将类映射到数据库表时，我们可以禁用此功能，但这在本教程的范围之外。如果您想了解此功能，<a href=\"https://entityframeworkcore.com/saving-data-cascade-delete\" target=\"_blank\" rel=\"noopener\">请看这里</a>。</p>\n<p>现在是时候测试我们的新端点了。再次运行该应用程序，并使用Postman发送DELETE请求，如下所示：</p>\n<p><img src=\"https://uploader.shimo.im/f/VRCjsPelqx4qADIx.png!thumbnail\" alt=\"图片\"></p>\n<p>如您所见，API毫无问题地删除了现有类别</p>\n<p>我们可以通过发送GET请求来检查我们的API是否正常工作：</p>\n<p><img src=\"https://uploader.shimo.im/f/iyiKvuB7e0IfSTQf.png!thumbnail\" alt=\"图片\">我们已经完成了类别API。现在是时候转向产品API。</p>\n<h1 id=\"步骤18-产品API\"><a href=\"#步骤18-产品API\" class=\"headerlink\" title=\"步骤18-产品API\"></a><strong>步骤18-产品API</strong></h1><p>到目前为止，您已经学习了如何实现所有基本的HTTP动词来使用ASP.NET Core处理CRUD操作。让我们进入实现产品API的下一个层次。</p>\n<p>我将不再详细介绍所有HTTP动词，因为这将是详尽无遗的。在本教程的最后一部分，我将仅介绍GET请求，以向您展示在从数据库查询数据时如何包括相关实体，以及如何使用Description我们为EUnitOfMeasurement 枚举值定义的属性。</p>\n<p>将新控制器ProductsController添加到名为Controllers的文件夹中。</p>\n<p>在这里编写任何代码之前，我们必须创建产品资源。</p>\n<p>让我刷新您的记忆，再次显示我们的资源应如何：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">   &quot;id&quot;: 1,</span><br><span class=\"line\">   &quot;name&quot;: &quot;Sugar&quot;,</span><br><span class=\"line\">   &quot;quantityInPackage&quot;: 1,</span><br><span class=\"line\">   &quot;unitOfMeasurement&quot;: &quot;KG&quot;</span><br><span class=\"line\">   &quot;category&quot;: &#123;</span><br><span class=\"line\">   &quot;id&quot;: 3,</span><br><span class=\"line\">   &quot;name&quot;: &quot;Sugar&quot;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  … // Other products</span><br><span class=\"line\"> ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们想要一个包含数据库中所有产品的JSON数组。<br>JSON数据与产品模型有两点不同：</p>\n<ul>\n<li>测量单位以较短的方式显示，仅显示其缩写。</li>\n<li>我们输出类别数据<strong>而不</strong>包括CategoryId属性。</li>\n</ul>\n<p>为了表示度量单位，我们可以使用简单的字符串属性代替枚举类型（顺便说一下，我们没有JSON数据的默认枚举类型，因此我们必须将其转换为其他类型）。</p>\n<p>现在，我们现在要塑造新资源，让我们创建它。ProductResource在Resources文件夹中添加一个新类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace Supermarket.API.Resources</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class ProductResource</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public int Id &#123; get; set; &#125;</span><br><span class=\"line\">\t        public string Name &#123; get; set; &#125;</span><br><span class=\"line\">\t        public int QuantityInPackage &#123; get; set; &#125;</span><br><span class=\"line\">\t        public string UnitOfMeasurement &#123; get; set; &#125;</span><br><span class=\"line\">\t        public CategoryResource Category &#123;get;set;&#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们必须配置模型类和新资源类之间的映射。<br>映射配置将与用于其他映射的配置几乎相同，但是在这里，我们必须处理将EUnitOfMeasurement枚举转换为字符串的操作。</p>\n<p>您还记得StringValue应用于枚举类型的属性吗？现在，我将向您展示如何使用.NET框架的强大功能：<a href=\"https://www.tutorialspoint.com/csharp/csharp_reflection.htm\" target=\"_blank\" rel=\"noopener\">反射 API</a>提取此信息。</p>\n<p>反射 API是一组强大的资源工具集，可让我们提取和操作元数据。许多框架和库（包括ASP.NET Core本身）都利用这些资源来处理许多后台工作。</p>\n<p>现在让我们看看它在实践中是如何工作的。将新类添加到Extensions名为的文件夹中EnumExtensions。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.ComponentModel;</span><br><span class=\"line\">\tusing System.Reflection;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Extensions</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public static class EnumExtensions</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public static string ToDescriptionString&lt;TEnum&gt;(this TEnum @enum)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            FieldInfo info = @enum.GetType().GetField(@enum.ToString());</span><br><span class=\"line\">\t            var attributes = (DescriptionAttribute[])info.GetCustomAttributes(typeof(DescriptionAttribute), false);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            return attributes?[0].Description ?? @enum.ToString();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一次看代码可能会让人感到恐惧，但这并不复杂。让我们分解代码定义以了解其工作原理。<br>首先，我们定义了一种<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/\" target=\"_blank\" rel=\"noopener\">通用方法</a>（一种方法，该方法可以接收不止一种类型的参数，在这种情况下，该方法由TEnum声明表示），该方法接收给定的枚举作为参数。</p>\n<p>由于enum是C＃中的保留关键字，因此我们在参数名称前面添加了@，以使其成为有效名称。</p>\n<p>该方法的第一步是使用该方法获取参数的类型信息（类，接口，枚举或结构定义）GetType。</p>\n<p>然后，该方法使用来获取特定的枚举值（例如Kilogram）GetField(@enum.ToString())。</p>\n<p>下一行找到Description应用于枚举值的所有属性，并将其数据存储到数组中（在某些情况下，我们可以为同一属性指定多个属性）。</p>\n<p>最后一行使用较短的语法来检查我们是否至少有一个枚举类型的描述属性。如果有，我们将返回Description此属性提供的值。如果不是，我们使用默认的强制类型转换将枚举作为字符串返回。</p>\n<p>?.操作者（<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/conditional-operator\" target=\"_blank\" rel=\"noopener\">零条件运算</a>）检查该值是否null访问其属性之前。</p>\n<p>??运算符（<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator\" target=\"_blank\" rel=\"noopener\">空合并运算符</a>）告诉应用程序在左边的返回值，如果它不为空，或者在正确的，否则价值。</p>\n<p>现在我们有了扩展方法来提取描述，让我们配置模型和资源之间的映射。多亏了AutoMapper，我们只需要多一行就可以做到这一点。</p>\n<p>打开ModelToResourceProfile类并通过以下方式更改代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using AutoMapper;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Extensions;</span><br><span class=\"line\">\tusing Supermarket.API.Resources;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Mapping</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class ModelToResourceProfile : Profile</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public ModelToResourceProfile()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            CreateMap&lt;Category, CategoryResource&gt;();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t            CreateMap&lt;Product, ProductResource&gt;()</span><br><span class=\"line\">\t                .ForMember(src =&gt; src.UnitOfMeasurement,</span><br><span class=\"line\">\t                           opt =&gt; opt.MapFrom(src =&gt; src.UnitOfMeasurement.ToDescriptionString()));</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此语法告诉AutoMapper使用新的扩展方法将我们的EUnitOfMeasurement值转换为包含其描述的字符串。简单吧？您可以<a href=\"http://docs.automapper.org/en/stable/Inline-Mapping.html\" target=\"_blank\" rel=\"noopener\">阅读官方文档</a>以了解完整语法。<br>注意，我们尚未为category属性定义任何映射配置。因为我们之前为类别配置了映射，并且由于产品模型具有相同类型和名称的category属性，所以AutoMapper隐式知道应该使用各自的配置来映射它。</p>\n<p>现在，我们添加端点代码。更改ProductsController代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing AutoMapper;</span><br><span class=\"line\">\tusing Microsoft.AspNetCore.Mvc;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services;</span><br><span class=\"line\">\tusing Supermarket.API.Resources;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Controllers</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    [Route(&quot;/api/[controller]&quot;)]</span><br><span class=\"line\">\t    public class ProductsController : Controller</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        private readonly IProductService _productService;</span><br><span class=\"line\">\t        private readonly IMapper _mapper;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public ProductsController(IProductService productService, IMapper mapper)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            _productService = productService;</span><br><span class=\"line\">\t            _mapper = mapper;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        [HttpGet]</span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;ProductResource&gt;&gt; ListAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            var products = await _productService.ListAsync();</span><br><span class=\"line\">\t            var resources = _mapper.Map&lt;IEnumerable&lt;Product&gt;, IEnumerable&lt;ProductResource&gt;&gt;(products);</span><br><span class=\"line\">\t            return resources;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基本上，为类别控制器定义的结构相同。<br>让我们进入服务部分。将一个新IProductService接口添加到Domain层中的Services文件夹中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Services</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public interface IProductService</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t         Task&lt;IEnumerable&lt;Product&gt;&gt; ListAsync();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>您应该已经意识到，在真正实现新服务之前，我们需要一个仓储。<br>IProductRepository在相应的文件夹中添加一个名为的新接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Domain.Repositories</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public interface IProductRepository</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t         Task&lt;IEnumerable&lt;Product&gt;&gt; ListAsync();</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们实现仓储。除了必须在查询数据时返回每个产品的相应类别数据外，我们几乎必须像对类别仓储一样实现。<br>默认情况下，EF Core在查询数据时不包括与模型相关的实体，因为它可能非常慢（想象一个具有十个相关实体的模型，所有相关实体都有自己的关系）。</p>\n<p>要包括类别数据，我们只需要多一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Microsoft.EntityFrameworkCore;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Repositories;</span><br><span class=\"line\">\tusing Supermarket.API.Persistence.Contexts;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Persistence.Repositories</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class ProductRepository : BaseRepository, IProductRepository</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        public ProductRepository(AppDbContext context) : base(context)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;Product&gt;&gt; ListAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            return await _context.Products.Include(p =&gt; p.Category)</span><br><span class=\"line\">\t                                          .ToListAsync();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意对的调用Include(p =&gt; p.Category)。我们可以链接此语法，以在查询数据时包含尽可能多的实体。执行选择时，EF Core会将其转换为联接。<br>现在，我们可以ProductService像处理类别一样实现类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">\tusing System.Threading.Tasks;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Models;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Repositories;</span><br><span class=\"line\">\tusing Supermarket.API.Domain.Services;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tnamespace Supermarket.API.Services</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    public class ProductService : IProductService</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        private readonly IProductRepository _productRepository;</span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t        public ProductService(IProductRepository productRepository)</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            _productRepository = productRepository;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t        public async Task&lt;IEnumerable&lt;Product&gt;&gt; ListAsync()</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            return await _productRepository.ListAsync();</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>让我们绑定更改Startup类的新依赖项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void ConfigureServices(IServiceCollection services)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    services.AddDbContext&lt;AppDbContext&gt;(options =&gt;</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t        options.UseInMemoryDatabase(&quot;supermarket-api-in-memory&quot;);</span><br><span class=\"line\">\t    &#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    services.AddScoped&lt;ICategoryRepository, CategoryRepository&gt;();</span><br><span class=\"line\">\t    services.AddScoped&lt;IProductRepository, ProductRepository&gt;();</span><br><span class=\"line\">\t    services.AddScoped&lt;IUnitOfWork, UnitOfWork&gt;();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    services.AddScoped&lt;ICategoryService, CategoryService&gt;();</span><br><span class=\"line\">\t    services.AddScoped&lt;IProductService, ProductService&gt;();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    services.AddAutoMapper();</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，在测试API之前，让我们AppDbContext在初始化应用程序时更改类以包括一些产品，以便我们看到结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected override void OnModelCreating(ModelBuilder builder)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    base.OnModelCreating(builder);</span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t    builder.Entity&lt;Category&gt;().ToTable(&quot;Categories&quot;);</span><br><span class=\"line\">\t    builder.Entity&lt;Category&gt;().HasKey(p =&gt; p.Id);</span><br><span class=\"line\">\t    builder.Entity&lt;Category&gt;().Property(p =&gt; p.Id).IsRequired().ValueGeneratedOnAdd().HasValueGenerator&lt;InMemoryIntegerValueGenerator&lt;int&gt;&gt;();</span><br><span class=\"line\">\t    builder.Entity&lt;Category&gt;().Property(p =&gt; p.Name).IsRequired().HasMaxLength(30);</span><br><span class=\"line\">\t    builder.Entity&lt;Category&gt;().HasMany(p =&gt; p.Products).WithOne(p =&gt; p.Category).HasForeignKey(p =&gt; p.CategoryId);</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    builder.Entity&lt;Category&gt;().HasData</span><br><span class=\"line\">\t    (</span><br><span class=\"line\">\t        new Category &#123; Id = 100, Name = &quot;Fruits and Vegetables&quot; &#125;, // Id set manually due to in-memory provider</span><br><span class=\"line\">\t        new Category &#123; Id = 101, Name = &quot;Dairy&quot; &#125;</span><br><span class=\"line\">\t    );</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    builder.Entity&lt;Product&gt;().ToTable(&quot;Products&quot;);</span><br><span class=\"line\">\t    builder.Entity&lt;Product&gt;().HasKey(p =&gt; p.Id);</span><br><span class=\"line\">\t    builder.Entity&lt;Product&gt;().Property(p =&gt; p.Id).IsRequired().ValueGeneratedOnAdd();</span><br><span class=\"line\">\t    builder.Entity&lt;Product&gt;().Property(p =&gt; p.Name).IsRequired().HasMaxLength(50);</span><br><span class=\"line\">\t    builder.Entity&lt;Product&gt;().Property(p =&gt; p.QuantityInPackage).IsRequired();</span><br><span class=\"line\">\t    builder.Entity&lt;Product&gt;().Property(p =&gt; p.UnitOfMeasurement).IsRequired();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t    builder.Entity&lt;Product&gt;().HasData</span><br><span class=\"line\">\t    (</span><br><span class=\"line\">\t        new Product</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            Id = 100,</span><br><span class=\"line\">\t            Name = &quot;Apple&quot;,</span><br><span class=\"line\">\t            QuantityInPackage = 1,</span><br><span class=\"line\">\t            UnitOfMeasurement = EUnitOfMeasurement.Unity,</span><br><span class=\"line\">\t            CategoryId = 100</span><br><span class=\"line\">\t        &#125;,</span><br><span class=\"line\">\t        new Product</span><br><span class=\"line\">\t        &#123;</span><br><span class=\"line\">\t            Id = 101,</span><br><span class=\"line\">\t            Name = &quot;Milk&quot;,</span><br><span class=\"line\">\t            QuantityInPackage = 2,</span><br><span class=\"line\">\t            UnitOfMeasurement = EUnitOfMeasurement.Liter,</span><br><span class=\"line\">\t            CategoryId = 101,</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    );</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我添加了两个虚构产品，将它们与初始化应用程序时我们播种的类别相关联。<br>该测试了！再次运行API并发送GET请求以/api/products使用Postman：</p>\n<p><img src=\"https://uploader.shimo.im/f/h9cMeoAIZg4vyRgj.png!thumbnail\" alt=\"图片\"></p>\n<p>就是这样！恭喜你！</p>\n<p>现在，您将了解如何使用解耦的代码架构使用ASP.NET Core构建RESTful API。您了解了.NET Core框架的许多知识，如何使用C＃，EF Core和AutoMapper的基础知识以及在设计应用程序时要使用的许多有用的模式。</p>\n<p>您可以检查API的完整实现，包括产品的其他HTTP动词，并检查Github仓储：</p>\n<p><a href=\"https://github.com/evgomes/supermarket-api\" target=\"_blank\" rel=\"noopener\">evgomes / supermarket-api</a></p>\n<p><a href=\"https://github.com/evgomes/supermarket-api\" target=\"_blank\" rel=\"noopener\">使用ASP.NET Core 2.2构建的简单RESTful API，展示了如何使用分离的，可维护的……创建RESTful服务</a><a href=\"https://github.com/evgomes/supermarket-api\" target=\"_blank\" rel=\"noopener\">。github.com</a></p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a><strong>结论</strong></h1><p>ASP.NET Core是创建Web应用程序时使用的出色框架。它带有许多有用的API，可用于构建干净，可维护的应用程序。创建专业应用程序时，可以将其视为一种选择。</p>\n<p>本文并未涵盖专业API的所有方面，但您已学习了所有基础知识。您还学到了许多有用的模式，可以解决我们每天面临的模式。</p>\n<p>希望您喜欢这篇文章，希望对您有所帮助。期待你的反馈，以便我能进一步提高。</p>\n<p><strong>进一步学习的可用参考资料</strong></p>\n<p><a href=\"https://docs.microsoft.com/en-us/dotnet/core/tutorials/\" target=\"_blank\" rel=\"noopener\">.NET Core教程-Microsoft文档</a></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/aspnet/#pivot=core&panel=core_tutorials\" target=\"_blank\" rel=\"noopener\">ASP.NET Core文档-Microsoft文档</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/技术/how-to-manage-user-secret-in-develop-and-production/image-20200608205613844.png","slug":"image-20200608205613844.png","post":"ckbuujt9x0053n4vixe8ktpdx","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckbuujt2w0000n4vijybrfdfp","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt3h0002n4vi16e8yq0p"},{"post_id":"ckbuujt650004n4viv7u7c391","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt6r0009n4vifcggotd3"},{"post_id":"ckbuujt6j0005n4vitz62ng3r","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt6t000bn4vi168kzqp4"},{"post_id":"ckbuujt6p0008n4vitndsgk6p","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt6z000hn4viijg377a4"},{"post_id":"ckbuujt6r000an4vienjgq92d","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt74000kn4vi1qlk2hn2"},{"post_id":"ckbuujt6v000en4vinz05je93","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt76000nn4vi816pq0zj"},{"post_id":"ckbuujt6x000gn4vibro7d6xn","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt79000qn4vi8imfi0bo"},{"post_id":"ckbuujt70000jn4viwmch7wlh","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt7c000tn4vixr2y9373"},{"post_id":"ckbuujt74000mn4vig1utmtje","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt7f000wn4vipxtno6my"},{"post_id":"ckbuujt77000pn4vif3gd2810","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt7g000zn4vitmlnfo28"},{"post_id":"ckbuujt7a000sn4vi1dumzrjm","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt7i0012n4viwsalpfev"},{"post_id":"ckbuujt7d000vn4vi6aa067nd","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt7m0015n4vis9xo46ob"},{"post_id":"ckbuujt7g000yn4vi9p4ezdbd","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt7o0018n4vik5qwy3vw"},{"post_id":"ckbuujt7h0011n4vivzxt16h1","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt7p001bn4vixy9m5ye1"},{"post_id":"ckbuujt7l0014n4vipfviey3z","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt7r001en4vi8z301eyu"},{"post_id":"ckbuujt7n0017n4vi7sojq6vh","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt7s001hn4viy356knfj"},{"post_id":"ckbuujt7p001an4vikdrwcvmj","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt7u001kn4vi6fk5gytw"},{"post_id":"ckbuujt7s001gn4vi0dz0pteu","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt7z001pn4vire3rz5ub"},{"post_id":"ckbuujt7t001jn4vimcmfg8wh","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt81001sn4vicfxemo15"},{"post_id":"ckbuujt7v001mn4vi80hy9elj","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt83001vn4vi8kvysxf7"},{"post_id":"ckbuujt7y001on4vimoy7aqzq","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt86001yn4vidad2m0ii"},{"post_id":"ckbuujt80001rn4vi6wec6cr3","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt880021n4vij2ote9tu"},{"post_id":"ckbuujt82001un4vil60alhw9","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt8a0024n4vi0mx28c10"},{"post_id":"ckbuujt85001xn4vijsp5hrys","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt8b0027n4viagad71vj"},{"post_id":"ckbuujt870020n4vi4kpmz80v","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujt8d002bn4vii1oqhuxx"},{"post_id":"ckbuujt890023n4vihclf3fxu","category_id":"ckbuucqyq002s3cviu1detito","_id":"ckbuujt8e002dn4vibziukbhc"},{"post_id":"ckbuujt8b0026n4vi7roghgxn","category_id":"ckbuucqyq002s3cviu1detito","_id":"ckbuujt8g002hn4virled62yu"},{"post_id":"ckbuujt8c002an4vi770hnra7","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt8h002kn4vidm9dd5gx"},{"post_id":"ckbuujt8d002cn4vixwx7zerk","category_id":"ckbuucqyq002s3cviu1detito","_id":"ckbuujt8j002on4vixtqhrc3h"},{"post_id":"ckbuujt8f002fn4vi3vzeit6m","category_id":"ckbuucqwz00073cvidfgjrf0h","_id":"ckbuujt8k002rn4vi4m3xnvb6"},{"post_id":"ckbuujt8h002jn4vimt4y59hd","category_id":"ckbuucqwz00073cvidfgjrf0h","_id":"ckbuujt8m002tn4vijn7yja91"},{"post_id":"ckbuujt8i002mn4vidsbwtzmc","category_id":"ckbuucqwz00073cvidfgjrf0h","_id":"ckbuujt8r002xn4vi35g2rf0w"},{"post_id":"ckbuujt8k002qn4visg55xb9q","category_id":"ckbuucqwz00073cvidfgjrf0h","_id":"ckbuujt8t0030n4vie9qd2jsm"},{"post_id":"ckbuujt8l002sn4viokemlbiu","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt8x0034n4vip6e1ano4"},{"post_id":"ckbuujt8n002wn4vigpj5m9mw","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt8z0037n4vixokl1hty"},{"post_id":"ckbuujt8s002zn4vikupeohmx","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt91003an4vi3bzalj9l"},{"post_id":"ckbuujt8w0033n4vi6wufclbm","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt92003dn4vibxk2h0fy"},{"post_id":"ckbuujt8y0036n4vig5t92hzn","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt93003gn4viihsqstze"},{"post_id":"ckbuujt900039n4vissvw0sqh","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt95003jn4vi6ps1q82m"},{"post_id":"ckbuujt91003cn4vi3nu8myt4","category_id":"ckbuucqwz00073cvidfgjrf0h","_id":"ckbuujt96003mn4vij33hrm58"},{"post_id":"ckbuujt92003fn4vijwxf3y6u","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt98003pn4viyxx8ca59"},{"post_id":"ckbuujt94003in4vismjhpomz","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt99003sn4vimnyvqdvl"},{"post_id":"ckbuujt95003ln4vipykxzue1","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9b003vn4viy3bicepo"},{"post_id":"ckbuujt97003on4vi3c32da6i","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9c003yn4vix16soabo"},{"post_id":"ckbuujt98003rn4vipii5dnmi","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9e0041n4vic7mmsm2s"},{"post_id":"ckbuujt9a003un4vi3m7o4s74","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9f0044n4vi7i83a63d"},{"post_id":"ckbuujt9c003xn4vi1qouvjyd","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9g0047n4vi8v8u8nac"},{"post_id":"ckbuujt9d0040n4vim47o4ge9","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9i004an4vizci0ktrx"},{"post_id":"ckbuujt9e0043n4viynnstal1","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9k004dn4vijmh6g03d"},{"post_id":"ckbuujt9g0046n4vix46v73dl","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9l004gn4vi6ehiv448"},{"post_id":"ckbuujt9h0049n4viyploq7t0","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9o004jn4vijv3ubk4e"},{"post_id":"ckbuujt9j004cn4vi3fu5ljoo","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9p004mn4vi5a490dr5"},{"post_id":"ckbuujt9k004fn4vitw9d7nt1","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9r004pn4vitb3z7pyp"},{"post_id":"ckbuujt9m004in4victr1866l","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9s004sn4viik4se982"},{"post_id":"ckbuujt9p004ln4vi9n6kwi35","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9t004vn4vi28kj6ftj"},{"post_id":"ckbuujt9q004on4vi74xqmfyi","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9u004yn4vi3zyjncjb"},{"post_id":"ckbuujt9r004rn4vip0kpuhpk","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9w0051n4vi7p8jjh6c"},{"post_id":"ckbuujt9s004un4vixm29vilr","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9y0054n4vizxo0elms"},{"post_id":"ckbuujt9u004xn4vibm452tus","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9z0056n4viv823ozbq"},{"post_id":"ckbuujt9v0050n4viw2vzn5ey","category_id":"ckbuucqtu00013cvi9ugfhi1e","_id":"ckbuujt9z0058n4vit7cbb142"},{"post_id":"ckbuujt9x0053n4vixe8ktpdx","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujta0005an4viyljaqxpm"},{"post_id":"ckbuujta9005dn4vixl5zn6gx","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuujtac005fn4vioqqul0et"},{"post_id":"ckbuujt7q001dn4vic76zncve","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuus3g40001p8vifa8qak8m"},{"post_id":"ckbuujt6m0007n4vimwa8lxgf","category_id":"ckbuucqxg000p3cvinriajhve","_id":"ckbuust8t0003p8vixsq3kp14"}],"PostTag":[{"post_id":"ckbuujt2w0000n4vijybrfdfp","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt3h0003n4viaanutp9s"},{"post_id":"ckbuujt6p0008n4vitndsgk6p","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt6u000dn4vi8r29nm7x"},{"post_id":"ckbuujt650004n4viv7u7c391","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt6w000fn4vidxg2l9t9"},{"post_id":"ckbuujt6r000an4vienjgq92d","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt70000in4vi5baa7u2o"},{"post_id":"ckbuujt6v000en4vinz05je93","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt74000ln4vir23d1hqp"},{"post_id":"ckbuujt6j0005n4vitz62ng3r","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt77000on4vi75oau6sa"},{"post_id":"ckbuujt6x000gn4vibro7d6xn","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt79000rn4viuyafsux0"},{"post_id":"ckbuujt70000jn4viwmch7wlh","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt7d000un4vi7v5ytw4t"},{"post_id":"ckbuujt74000mn4vig1utmtje","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt7f000xn4vinfd8ds6k"},{"post_id":"ckbuujt77000pn4vif3gd2810","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt7h0010n4vi1s2hymmo"},{"post_id":"ckbuujt7a000sn4vi1dumzrjm","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt7k0013n4vi0qamrurr"},{"post_id":"ckbuujt7d000vn4vi6aa067nd","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt7n0016n4viwl75xu4m"},{"post_id":"ckbuujt7g000yn4vi9p4ezdbd","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt7o0019n4vi5t6ytov7"},{"post_id":"ckbuujt7h0011n4vivzxt16h1","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt7q001cn4vihei6gpm5"},{"post_id":"ckbuujt7l0014n4vipfviey3z","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt7r001fn4vimde2j0k0"},{"post_id":"ckbuujt7n0017n4vi7sojq6vh","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt7t001in4viu00qxuuh"},{"post_id":"ckbuujt7p001an4vikdrwcvmj","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt7u001ln4vicdoy93fd"},{"post_id":"ckbuujt7s001gn4vi0dz0pteu","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt7x001nn4vix930xyu6"},{"post_id":"ckbuujt7t001jn4vimcmfg8wh","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt80001qn4vi5gsmpa66"},{"post_id":"ckbuujt7v001mn4vi80hy9elj","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt82001tn4vismyp0kid"},{"post_id":"ckbuujt7y001on4vimoy7aqzq","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt84001wn4viy08hmvoz"},{"post_id":"ckbuujt80001rn4vi6wec6cr3","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt86001zn4vig7v3xirl"},{"post_id":"ckbuujt82001un4vil60alhw9","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt890022n4vilysexnpk"},{"post_id":"ckbuujt85001xn4vijsp5hrys","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt8a0025n4vi7w12ceeg"},{"post_id":"ckbuujt870020n4vi4kpmz80v","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujt8c0029n4vi25ri93d5"},{"post_id":"ckbuujt8c002an4vi770hnra7","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt8e002en4viu0jqr3ci"},{"post_id":"ckbuujt8d002cn4vixwx7zerk","tag_id":"ckbuujt8c0028n4vidwrcjmj9","_id":"ckbuujt8g002in4viznfrodmr"},{"post_id":"ckbuujt890023n4vihclf3fxu","tag_id":"ckbuujt8c0028n4vidwrcjmj9","_id":"ckbuujt8i002ln4viyhc9opom"},{"post_id":"ckbuujt8b0026n4vi7roghgxn","tag_id":"ckbuujt8c0028n4vidwrcjmj9","_id":"ckbuujt8j002pn4vi2vk5fpbo"},{"post_id":"ckbuujt8k002qn4visg55xb9q","tag_id":"ckbuujt8j002nn4vi1p5xfbzy","_id":"ckbuujt8m002vn4viyk24xceh"},{"post_id":"ckbuujt8f002fn4vi3vzeit6m","tag_id":"ckbuujt8j002nn4vi1p5xfbzy","_id":"ckbuujt8s002yn4vivwgv49bf"},{"post_id":"ckbuujt8l002sn4viokemlbiu","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt8v0032n4viqqqvv9yp"},{"post_id":"ckbuujt8n002wn4vigpj5m9mw","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt8x0035n4vid91r2bpn"},{"post_id":"ckbuujt8h002jn4vimt4y59hd","tag_id":"ckbuujt8j002nn4vi1p5xfbzy","_id":"ckbuujt900038n4vipqdtqvcz"},{"post_id":"ckbuujt8s002zn4vikupeohmx","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt91003bn4viy6nrsng5"},{"post_id":"ckbuujt8w0033n4vi6wufclbm","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt92003en4vinjfgjjve"},{"post_id":"ckbuujt8i002mn4vidsbwtzmc","tag_id":"ckbuujt8j002nn4vi1p5xfbzy","_id":"ckbuujt94003hn4viv793gjoe"},{"post_id":"ckbuujt8y0036n4vig5t92hzn","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt95003kn4vi643a08y7"},{"post_id":"ckbuujt900039n4vissvw0sqh","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt96003nn4vicnqnoks7"},{"post_id":"ckbuujt91003cn4vi3nu8myt4","tag_id":"ckbuujt8j002nn4vi1p5xfbzy","_id":"ckbuujt98003qn4vi1r1m1mga"},{"post_id":"ckbuujt92003fn4vijwxf3y6u","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9a003tn4visc0m5v9p"},{"post_id":"ckbuujt94003in4vismjhpomz","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9b003wn4viilgyeq1v"},{"post_id":"ckbuujt95003ln4vipykxzue1","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9d003zn4viwj2iyiaz"},{"post_id":"ckbuujt97003on4vi3c32da6i","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9e0042n4viiqxkvjb0"},{"post_id":"ckbuujt98003rn4vipii5dnmi","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9f0045n4viv9wvbnuw"},{"post_id":"ckbuujt9a003un4vi3m7o4s74","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9h0048n4vi4z67ewsr"},{"post_id":"ckbuujt9c003xn4vi1qouvjyd","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9j004bn4vil87xmgbl"},{"post_id":"ckbuujt9d0040n4vim47o4ge9","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9k004en4vieau0823a"},{"post_id":"ckbuujt9e0043n4viynnstal1","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9m004hn4viylq8rujs"},{"post_id":"ckbuujt9g0046n4vix46v73dl","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9o004kn4vij5zfj8x3"},{"post_id":"ckbuujt9h0049n4viyploq7t0","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9q004nn4vigv2v6wz3"},{"post_id":"ckbuujt9j004cn4vi3fu5ljoo","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9r004qn4vikpdvu27z"},{"post_id":"ckbuujt9k004fn4vitw9d7nt1","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9s004tn4vizkpye4ub"},{"post_id":"ckbuujt9m004in4victr1866l","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9t004wn4vikualkkl1"},{"post_id":"ckbuujt9p004ln4vi9n6kwi35","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9v004zn4viciau5yb5"},{"post_id":"ckbuujt9q004on4vi74xqmfyi","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9x0052n4via5jpwmwh"},{"post_id":"ckbuujt9r004rn4vip0kpuhpk","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9y0055n4viaox0trhf"},{"post_id":"ckbuujt9s004un4vixm29vilr","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujt9z0057n4vi2cn4l462"},{"post_id":"ckbuujt9u004xn4vibm452tus","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujta00059n4vixrshnrb5"},{"post_id":"ckbuujt9v0050n4viw2vzn5ey","tag_id":"ckbuujt3e0001n4vi9nbidheo","_id":"ckbuujta0005bn4vijxw7enqm"},{"post_id":"ckbuujt9x0053n4vixe8ktpdx","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujta0005cn4virm3gxhct"},{"post_id":"ckbuujta9005dn4vixl5zn6gx","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuujtab005en4vitloj0qqx"},{"post_id":"ckbuujt7q001dn4vic76zncve","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuus3g20000p8vi55z8ojmc"},{"post_id":"ckbuujt6m0007n4vimwa8lxgf","tag_id":"ckbuujt6m0006n4viba3jg7q4","_id":"ckbuust8t0002p8viy2wt3n47"}],"Tag":[{"name":"随笔","_id":"ckbuujt3e0001n4vi9nbidheo"},{"name":"技术","_id":"ckbuujt6m0006n4viba3jg7q4"},{"name":"管理","_id":"ckbuujt8c0028n4vidwrcjmj9"},{"name":"读书","_id":"ckbuujt8j002nn4vi1p5xfbzy"}]}}