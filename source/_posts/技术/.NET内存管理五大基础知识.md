---
title:  .NET内存管理五大基础知识
date: 2020-5-26 19:07
tags: 技术
author: 邹溪源
categories:
  - 技术
---
# .NET内存管理五大基础知识

## 1.小对象怎么处理的？

小型.NET对象被分配到小型对象堆（SOH）上。其中有3种：第0代，第1代和第2代。对象根据其寿命向上移动。

将新对象放在Gen 0上。当Gen 0充满时，.NET垃圾收集器（GC）运行，处理不再需要的对象，并将其他所有内容移至Gen1。如果Gen 1充满，则GC再次运行，也可以将Gen 1中的对象移动到Gen 2中。

当Gen 2变满时，将发生GC完全运行。这将清除不需要的Gen 2对象，将Gen 1对象移至Gen 2，然后将Gen 0对象移至Gen 1，最后清除所有未引用的内容。每次运行GC之后，都会压缩受影响的堆，以将仍在使用的内存保持在一起。

这种代代相传的方法可确保事情高效运行-耗时的压缩过程仅在绝对必要时才会发生。

注意：如果您在Gen 2中看到大量的内存，则表明内存已被保留很长时间，并且可能存在内存问题。这是内存分析工具可以派上用场的地方。

## 2.较大的对象会怎样？

大于85 KB的对象被分配到大对象堆（LOH）。由于复制大块内存的开销，它们没有被压缩。当发生完整的GC时，未使用的LOH对象的地址范围将记录在可用空间分配表中。

分配新对象后，将在此可用空间表中检查足以容纳该对象的地址范围。如果存在，则将对象分配到那里，如果不存在，则将对象分配到下一个可用空间。

由于对象不太可能是空地址范围的确切大小，因此对象之间几乎总是会留有小块内存，从而导致碎片。如果这些块小于85 KB，则根本没有重用的可能性。因此，随着分配需求的增加，即使碎片空间仍然可用，也会保留新的段。

此外，当需要分配大对象时，.NET还是倾向于将对象附加到末尾，而不是运行昂贵的Gen 2 GC。这对性能有好处，但是是导致内存碎片的重要原因

## 3.垃圾收集器可以在不同的模式下运行以优化性能

.NET通过为GC提供多种模式来解决性能与堆效率之间的权衡问题。

工作站模式为用户提供了最大的响应速度，并减少了由于GC造成的暂停。它可以作为“并发”或“非并发”运行，指的是运行GC的线程。默认值为并发，它为GC使用单独的线程，因此应用程序可以在GC运行时继续执行。

服务器模式可为服务器环境提供最大的吞吐量，可伸缩性和性能。在服务器模式下，段大小和生成阈值通常比工作站模式大得多，这反映了对服务器的更高要求。

服务器模式在多个线程上并行运行垃圾回收，为每个逻辑处理器分配一个单独的SOH和LOH，以防止线程相互干扰。

.NET框架提供了一种交叉引用机制，因此对象仍然可以在堆之间相互引用。但是，由于应用程序响应能力不是服务器模式的直接目标，因此在GC期间，所有应用程序线程都将被挂起。

## 4.引用不足会在性能和内存效率之间折衷

弱对象引用了GC根的替代来源，使您可以保留对象，同时在GC需要时可以收集对象。它们是代码性能和内存效率之间的折衷。创建对象需要占用CPU时间，但保持加载状态需要占用内存。

弱引用特别适用于大型数据结构。例如，假设您有一个允许用户浏览大型数据结构的应用程序，他们可能会返回其中的一些数据。您可以将任何强引用转换为他们浏览的结构为弱引用。如果用户返回到这些结构，则可以使用它们，但如果没有，GC可以根据需要回收内存。

## 5.对象固定可以创建在托管和非托管代码之间传递的引用

.NET使用一种称为GCHandle的结构来跟踪堆对象。GCHandle可用于在托管域和非托管域之间传递对象引用，.NET维护一个GCHandles表以实现此目的。GCHandle有四种类型，包括固定的，用于将对象固定在内存中的特定地址。

对象固定的主要问题是它可能导致SOH碎片化。如果将对象固定在GC期间，则根据定义，该对象无法重定位。根据您使用固定的方式，它会降低压缩的效率，在堆中留下间隙。避免这种情况的最佳策略是在很短的时间内锁定，然后释放。