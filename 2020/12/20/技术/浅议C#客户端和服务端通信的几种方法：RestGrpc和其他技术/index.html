<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="浅议C#客户端和服务端通信的几种方法：Rest和GRPC 在C＃客户端和C＃服务器之间进行通信的方法有很多。一些功能强大，而其他功能则不是很多。有些非常快，有些则不是。知道不同的选择很重要，这样您才能决定最适合自己的选择。 本文将介绍当今最流行的技术，以及为何如此广泛地使用它们。我们将讨论REST，gRPC及其两者之间的所有内容。  最佳方案让我们考虑一下我们希望如何在最佳环境中使客户端与服务器之">
<meta name="keywords" content="技术">
<meta property="og:type" content="article">
<meta property="og:title" content="浅议C#客户端和服务端通信的几种方法：Rest和GRPC">
<meta property="og:url" content="http://techq.xyz/2020/12/20/技术/浅议C#客户端和服务端通信的几种方法：RestGrpc和其他技术/index.html">
<meta property="og:site_name" content="xiyuan技术圈">
<meta property="og:description" content="浅议C#客户端和服务端通信的几种方法：Rest和GRPC 在C＃客户端和C＃服务器之间进行通信的方法有很多。一些功能强大，而其他功能则不是很多。有些非常快，有些则不是。知道不同的选择很重要，这样您才能决定最适合自己的选择。 本文将介绍当今最流行的技术，以及为何如此广泛地使用它们。我们将讨论REST，gRPC及其两者之间的所有内容。  最佳方案让我们考虑一下我们希望如何在最佳环境中使客户端与服务器之">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://michaelscodingspot.com/wp-content/uploads/2020/02/addAutoRestToVS.png">
<meta property="og:updated_time" content="2021-04-25T11:04:00.924Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅议C#客户端和服务端通信的几种方法：Rest和GRPC">
<meta name="twitter:description" content="浅议C#客户端和服务端通信的几种方法：Rest和GRPC 在C＃客户端和C＃服务器之间进行通信的方法有很多。一些功能强大，而其他功能则不是很多。有些非常快，有些则不是。知道不同的选择很重要，这样您才能决定最适合自己的选择。 本文将介绍当今最流行的技术，以及为何如此广泛地使用它们。我们将讨论REST，gRPC及其两者之间的所有内容。  最佳方案让我们考虑一下我们希望如何在最佳环境中使客户端与服务器之">
<meta name="twitter:image" content="https://michaelscodingspot.com/wp-content/uploads/2020/02/addAutoRestToVS.png">





  
  
  <link rel="canonical" href="http://techq.xyz/2020/12/20/技术/浅议C#客户端和服务端通信的几种方法：RestGrpc和其他技术/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>浅议C#客户端和服务端通信的几种方法：Rest和GRPC | xiyuan技术圈</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiyuan技术圈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">溪源的技术博客，技术的不断进取之路</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-技术">

    
    
    
      
    

    

    <a href="/categories/技术/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>技术</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-随笔">

    
    
    
      
    

    

    <a href="/categories/随笔/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>随笔</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-读书">

    
    
    
      
    

    

    <a href="/categories/读书/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>读书</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-管理">

    
    
    
      
    

    

    <a href="/categories/管理/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>管理</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-归档">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archives"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/12/20/技术/浅议C#客户端和服务端通信的几种方法：RestGrpc和其他技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">浅议C#客户端和服务端通信的几种方法：Rest和GRPC

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-12-20 21:05:00" itemprop="dateCreated datePublished" datetime="2020-12-20T21:05:00+00:00">2020-12-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2021-04-25 11:04:00" itemprop="dateModified" datetime="2021-04-25T11:04:00+00:00">2021-04-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="浅议C-客户端和服务端通信的几种方法：Rest和GRPC"><a href="#浅议C-客户端和服务端通信的几种方法：Rest和GRPC" class="headerlink" title="浅议C#客户端和服务端通信的几种方法：Rest和GRPC"></a>浅议C#客户端和服务端通信的几种方法：Rest和GRPC</h1><p> 在C＃客户端和C＃服务器之间进行通信的方法有很多。一些功能强大，而其他功能则不是很多。有些非常快，有些则不是。知道不同的选择很重要，这样您才能决定最适合自己的选择。</p>
<p>本文将介绍当今最流行的技术，以及为何如此广泛地使用它们。我们将讨论REST，gRPC及其两者之间的所有内容。 </p>
<h2 id="最佳方案"><a href="#最佳方案" class="headerlink" title="最佳方案"></a>最佳方案</h2><p>让我们考虑一下我们希望如何在最佳环境中使客户端与服务器之间的通信看起来像。我在想像这样的东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// on client side</span><br><span class="line">public void Foo()</span><br><span class="line">&#123;</span><br><span class="line">    var server = new MyServer(new Uri(&quot;https://www.myserver.com/&quot;);)</span><br><span class="line">    int sum = server.Calculator.SumNumbers(12,13); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// on server side</span><br><span class="line">class CalculatorController : Controller&#123;</span><br><span class="line">    public int SumNumbers(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我当然想要完整的Intellisense。当我单击<code>server</code>并<code>.</code> 希望Visual Studio显示所有控制器时。当我单击<code>CalculatorController</code>和时<code>.</code>，我想查看所有操作。我还想要一流的性能，很少的网络负载和双向通信。而且我想要一个能够完美处理版本控制的强大系统，这样我就可以毫不费力地部署新的客户端版本和新的服务器版本。</p>
<p>要求太多吗？</p>
<p>请注意，我在这里谈论的是<strong>无状态</strong>API。这等效于C＃项目，其中只有两种类型的类：</p>
<ul>
<li>静态类，只有静态方法。</li>
<li><a href="https://www.c-sharpcorner.com/UploadFile/5d065a/poco-classes-in-entity-framework/" target="_blank" rel="noopener">POCO类</a>仅具有类型为基本类型或其他POCO类的字段和属性。</li>
</ul>
<p>在API中使用状态会带来复杂性，而这正是万恶之源。因此，为了本文的方便，让我们保持美好和无状态。</p>
<h2 id="传统REST"><a href="#传统REST" class="headerlink" title="传统REST"></a>传统REST</h2><p>REST API出现在2000年代初期，席卷了整个互联网。到目前为止，它是创建Web服务的最流行的方法。</p>
<p>REST为客户端到服务器的请求定义了一组固定的操作<strong>GET，POST，PUT</strong>和<strong>DELETE</strong>。每个请求都将通过包含有效负载（通常为JSON）的响应来回答。请求包含在查询本身中的参数，或者在它是POST请求时包含为有效负载（通常为JSON）的参数。</p>
<p>有一个称为RESTful API的标准，它定义了以下规则（您实际上不必使用它）：</p>
<ul>
<li>GET用于检索资源</li>
<li>PUT用于更改资源状态</li>
<li>POST用于创建资源</li>
<li>DELETE用于删除资源</li>
</ul>
<p>如果您到目前为止还不熟悉REST，则上面的解释可能不会减少它，因此这里有一个示例。在.NET中，内置了对REST的支持。实际上，默认情况下，ASP.NET Web API被构建为REST Web服务。这是典型的客户端和ASP.NET服务器的外观：</p>
<p>在服务器中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;People&quot;)]</span><br><span class="line">public class PeopleController : Controller</span><br><span class="line">&#123;</span><br><span class="line">    [HttpGet]</span><br><span class="line">    public Person GetPersonById(int id)</span><br><span class="line">    &#123;</span><br><span class="line">        Person person = _db.GetPerson(id);</span><br><span class="line">        return person;//Automatically serialized to JSON</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在客户中： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var client = new HttpClient();</span><br><span class="line">string resultJson = </span><br><span class="line">    await client.GetStringAsync(&quot;https://www.myserver.com/People/GetPersonById?id=123&quot;);</span><br><span class="line">Person person = JsonConvert.DeserializeObject&lt;Person&gt;(resultJson);</span><br></pre></td></tr></table></figure>

<p>REST非常方便，但是并没有达到最佳方案。因此，让我们看看是否可以做得更好。</p>
<h2 id="ReFit"><a href="#ReFit" class="headerlink" title="ReFit"></a>ReFit</h2><p>ReFit不能替代REST。相反，它建立在REST之上，并允许我们像调用简单方法一样调用服务器端点。这是通过在客户端和服务器之间共享接口来实现的。在服务器端，您的控制器将实现一个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IMyEmployeeApi</span><br><span class="line">&#123;</span><br><span class="line">    [Get(&quot;/employee/&#123;id&#125;&quot;)]</span><br><span class="line">    Task&lt;Employee&gt; GetEmployee(string id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在客户端，您需要包括相同的接口并使用以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var api = RestService.For&lt;IMyEmployeeApi&gt;(&quot;https://www.myserver.com&quot;);</span><br><span class="line">var employee = await api.GetEmployee(&quot;abc&quot;);</span><br></pre></td></tr></table></figure>

<p>就这么简单。除了几个NuGet软件包外，无需运行困难的自动化程序或使用任何第三方工具。</p>
<p>这更接近最佳方案。现在，我们有了IntelliSense，并且客户端和服务器之间的合同很牢固。但是还有另一种选择，在某些方面甚至更好。</p>
<h2 id="昂首阔步"><a href="#昂首阔步" class="headerlink" title="昂首阔步"></a>昂首阔步</h2><p>像ReFit一样，Swagger也建立在REST之上。<a href="https://swagger.io/specification/" target="_blank" rel="noopener">OpenAPI</a>或<strong>Swagger</strong>是REST API的规范。它描述了具有简单JSON文件的REST Web服务。这些文件是Web服务的API架构。它们包括：</p>
<ul>
<li>API中的所有路径（URL）。</li>
<li>每个路径的预期操作（GET，POST等）。每个路径可以处理不同的操作。例如，单个路径<code>https://mystore.com/Product</code>可能接受添加产品的POST操作和返回产品的GET操作。</li>
<li>每个路径和操作的预期参数。</li>
<li>每个路径的预期响应。</li>
<li>每个参数和响应对象的类型。</li>
</ul>
<p>该JSON文件实质上是客户端和服务器之间的合同。这是一个描述一个称为<a href="https://bfanger.nl/swagger-explained/#operationObject" target="_blank" rel="noopener">Swagger Petstore</a>的Web服务的swagger文件的示例（为清楚起见，我删除了一些部分）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">   &quot;swagger&quot;:&quot;2.0&quot;,</span><br><span class="line">   &quot;info&quot;:&#123; </span><br><span class="line">      &quot;version&quot;:&quot;1.0.0&quot;,</span><br><span class="line">      &quot;title&quot;:&quot;Swagger Petstore&quot;,</span><br><span class="line">      &quot;description&quot;:&quot;A sample API that uses a petstore as an example to demonstrate features in the swagger-2.0 specification&quot;,</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;host&quot;:&quot;petstore.swagger.io&quot;,</span><br><span class="line">   &quot;basePath&quot;:&quot;/api&quot;,</span><br><span class="line">   &quot;schemes&quot;:[ </span><br><span class="line">      &quot;http&quot;</span><br><span class="line">   ],</span><br><span class="line">   &quot;consumes&quot;:[ </span><br><span class="line">      &quot;application/json&quot;</span><br><span class="line">   ],</span><br><span class="line">   &quot;produces&quot;:[ </span><br><span class="line">      &quot;application/json&quot;</span><br><span class="line">   ],</span><br><span class="line">   &quot;paths&quot;:&#123; </span><br><span class="line">      &quot;/pets&quot;:&#123; </span><br><span class="line">         &quot;get&quot;:&#123; </span><br><span class="line">            &quot;description&quot;:&quot;Returns all pets from the system that the user has access to&quot;,</span><br><span class="line">            &quot;operationId&quot;:&quot;findPets&quot;,</span><br><span class="line">            &quot;produces&quot;:[ </span><br><span class="line">               &quot;application/json&quot;,</span><br><span class="line">               &quot;application/xml&quot;,</span><br><span class="line">            ],</span><br><span class="line">            &quot;parameters&quot;:[ </span><br><span class="line">               &#123; </span><br><span class="line">                  &quot;name&quot;:&quot;tags&quot;,</span><br><span class="line">                  &quot;in&quot;:&quot;query&quot;,</span><br><span class="line">                  &quot;description&quot;:&quot;tags to filter by&quot;,</span><br><span class="line">                  &quot;required&quot;:false,</span><br><span class="line">                  &quot;type&quot;:&quot;array&quot;,</span><br><span class="line">                  &quot;items&quot;:&#123; </span><br><span class="line">                     &quot;type&quot;:&quot;string&quot;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &quot;collectionFormat&quot;:&quot;csv&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               &#123; </span><br><span class="line">                  &quot;name&quot;:&quot;limit&quot;,</span><br><span class="line">                  &quot;in&quot;:&quot;query&quot;,</span><br><span class="line">                  &quot;description&quot;:&quot;maximum number of results to return&quot;,</span><br><span class="line">                  &quot;required&quot;:false,</span><br><span class="line">                  &quot;type&quot;:&quot;integer&quot;,</span><br><span class="line">                  &quot;format&quot;:&quot;int32&quot;</span><br><span class="line">               &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;responses&quot;:&#123; </span><br><span class="line">               &quot;200&quot;:&#123; </span><br><span class="line">                  &quot;description&quot;:&quot;pet response&quot;,</span><br><span class="line">                  &quot;schema&quot;:&#123; </span><br><span class="line">                     &quot;type&quot;:&quot;array&quot;,</span><br><span class="line">                     &quot;items&quot;:&#123; </span><br><span class="line">                        &quot;$ref&quot;:&quot;#/definitions/Pet&quot;</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>让我们考虑一下这个结果。使用上面的JSON文件，您可以潜在地创建具有完整IntelliSense的C＃客户端。毕竟，您知道所有路径，操作，它们期望的参数，什么参数类型，什么是响应等等。</p>
<p>有几种工具可以做到这一点。对于服务器端，可以使用<a href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore" target="_blank" rel="noopener">Swashbuckle.AspNetCore</a>将Swagger添加到ASP.NET中并生成所述JSON文件。对于客户端，您可以使用<a href="https://github.com/swagger-api/swagger-codegen" target="_blank" rel="noopener">swagger-codegen</a>和<a href="https://azure.github.io/autorest/" target="_blank" rel="noopener">AutoRest</a>来使用这些JSON文件并生成客户端。让我们看一个如何做到这一点的例子：</p>
<h3 id="将Swagger添加到ASP-NET服务器"><a href="#将Swagger添加到ASP-NET服务器" class="headerlink" title="将Swagger添加到ASP.NET服务器"></a>将Swagger添加到ASP.NET服务器</h3><p>首先添加NuGet包<a href="https://www.nuget.org/packages/Swashbuckle.AspNetCore" target="_blank" rel="noopener">Swashbuckle.AspNetCore</a>。在中<code>ConfigureServices</code>，注册Swagger生成器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">services.AddSwaggerGen(options =&gt; </span><br><span class="line">	options.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo &#123;Title = &quot;My Web API&quot;, Version = &quot;v1&quot;&#125;));</span><br></pre></td></tr></table></figure>

<p>在添加<code>Configure</code>方法中<code>Startup.cs</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.UseSwagger();</span><br></pre></td></tr></table></figure>

<p>最后，控制器内部的动作应使用<code>[HttpXXX]</code>和<code>[FromXXX]</code>属性修饰：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[HttpPost]</span><br><span class="line">public async Task AddEmployee([FromBody]Employee employee)</span><br><span class="line">&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">[HttpGet]</span><br><span class="line">public async Task&lt;Employee&gt; Employee([FromQuery]string id)</span><br><span class="line">&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像服务器端一样简单。运行项目时，<code>swagger.json</code>将生成一个文件，可用于生成客户端。</p>
<h3 id="使用AutoRest从Swagger生成客户端"><a href="#使用AutoRest从Swagger生成客户端" class="headerlink" title="使用AutoRest从Swagger生成客户端"></a>使用AutoRest从Swagger生成客户端</h3><p>要开始使用<a href="https://github.com/Azure/autorest" target="_blank" rel="noopener">AutoRest</a>，与安装<a href="https://www.w3schools.com/nodejs/nodejs_npm.asp" target="_blank" rel="noopener">NPM</a>：<code>npm install -g autorest</code>。安装后，您将需要使用AutoRest的命令行界面从该<code>swagger.json</code>文件生成C＃客户端。这是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autorest --input-file=&quot;./swagger.json&quot; --output-folder=&quot;GeneratedClient&quot; --namespace=&quot;MyClient&quot; --override-client-name=&quot;MyClient&quot; --csharp</span><br></pre></td></tr></table></figure>

<p>这将产生一个<code>GeneratedClient</code>包含生成的C＃文件的文件夹。请注意，名称空间和客户端名称被覆盖。从这里，将此文件夹添加到Visual Studio中的客户端项目。</p>
<p><img src="https://michaelscodingspot.com/wp-content/uploads/2020/02/addAutoRestToVS.png" alt="Visual Studio中的AutoRest"></p>
<p>您需要安装<code>Microsoft.Rest.ClientRuntime</code>NuGet软件包，因为生成的代码取决于该软件包。安装后，您可以像使用常规C＃类一样使用API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var client = new MyClient();</span><br><span class="line">Employee employee = client.Employee(id: &quot;abc&quot;);</span><br></pre></td></tr></table></figure>

<p>您可以在AutoRest的<a href="https://azure.github.io/autorest/client/ops.html" target="_blank" rel="noopener">文档中</a>阅读一些细微之处。而且您需要使该过程自动化，因此我建议阅读Patrik Svensson的<a href="https://www.patriksvensson.se/2018/10/generating-api-clients-using-autorest" target="_blank" rel="noopener">教程，</a>以获得一些好的建议以及Peter Jausovec的这篇<a href="https://medium.com/@pjausovec/creating-c-client-library-for-web-api-projects-be132c831f9c" target="_blank" rel="noopener">文章</a>。</p>
<p>Swagger的问题是JSON文件是在运行时创建的，因此这使得在CI / CD流程中实现自动化有点困难。</p>
<h2 id="传统REST-vs-Swagger-vs-ReFit"><a href="#传统REST-vs-Swagger-vs-ReFit" class="headerlink" title="传统REST vs Swagger vs ReFit"></a>传统REST vs Swagger vs ReFit</h2><p>进行选择时，请注意以下几点。</p>
<ul>
<li>如果您有一个非常简单的私有REST API，则也许不必理会客户端生成和共享接口。小任务并不能证明付出额外的努力是合理的。</li>
<li>Swagger支持多种语言，而ReFit仅支持.NET。Swagger还是许多工具，测试，自动化和UI工具的基础。如果您要创建一个大型的公共API，它将可能是最佳选择。</li>
<li>Swagger比ReFit复杂得多。使用ReFit，只需在服务器和客户端项目中添加一个接口即可。另一方面，使用ReFit，您必须为每个控制器创建新的接口，而Swagger会自动进行处理。</li>
</ul>
<p>但是在决定任何事情之前，请检查与REST无关的第四个选项。</p>
<h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p><a href="https://grpc.io/" target="_blank" rel="noopener">gRPC</a>（<strong>gRPC远程过程调用</strong>）是Google开发的开源远程过程调用系统。它有点像REST，它提供了一种将请求从客户端发送到服务器的方式。但这在许多方面都不同，这是相同点和不同点：</p>
<ul>
<li>像REST一样，gRPC与语言无关。有适用于所有流行语言的工具，包括C＃。</li>
<li>gRPC是契约的基础，并使用<code>.proto</code>文件来定义契约。这有点类似于Swagger<code>swagger.json</code>和ReFit的共享界面。可以从那些文件中生成任何编程语言的客户端。</li>
<li>gRPC使用<a href="https://en.wikipedia.org/wiki/Protocol_Buffers" target="_blank" rel="noopener">协议缓冲区（Protobuf）</a>二进制序列化。这与REST（通常序列化为JSON或XML）不同。二进制序列化较小，因此更快。</li>
<li>gRPC用于使用HTTP / 2协议创建持久连接。该协议更简单，更紧凑。REST使用HTTP 1.x协议（通常为HTTP 1.1）。</li>
<li>HTTP 1.1要求每个请求都进行TCP握手，而HTTP / 2则保持连接打开。</li>
<li>HTTP / 2连接使用多路复用流。这意味着单个TCP连接可以支持许多流。这些流可以并行执行，而不必像HTTP 1.1中那样互相等待。</li>
<li>gRPC允许双向流。</li>
</ul>
<p>有两种使用gRPC的方法。对于.NET Core 3.0，有一个完全托管的库，称为<a href="https://github.com/grpc/grpc-dotnet" target="_blank" rel="noopener">.NET的gRPC</a>。对于其中的任何内容，您都可以使用<a href="https://github.com/grpc/grpc/tree/master/src/csharp" target="_blank" rel="noopener">gRPC C＃</a>，它是使用本机代码构建的。这并不意味着<strong>适用于.NET的gRPC可以</strong>替代<strong>gRPC C＃</strong>。让我们来看一个<strong>用于.NET</strong>的更新<strong>gRPC</strong>的示例。</p>
<h3 id="NET的gRPC的服务器端"><a href="#NET的gRPC的服务器端" class="headerlink" title=".NET的gRPC的服务器端"></a>.NET的gRPC的服务器端</h3><p>这不是教程，而是更多有关预期内容的一般性想法。这是示例控制器在gRPC中的外观：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class GreeterService : Greeter.GreeterBase</span><br><span class="line">&#123;</span><br><span class="line">    public override Task&lt;HelloReply&gt; SayHello(HelloRequest request,</span><br><span class="line">        ServerCallContext context)</span><br><span class="line">    &#123;</span><br><span class="line">        _logger.LogInformation(&quot;Saying hello to &#123;Name&#125;&quot;, request.Name);</span><br><span class="line">        return Task.FromResult(new HelloReply </span><br><span class="line">        &#123;</span><br><span class="line">            Message = &quot;Hello &quot; + request.Name</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您需要添加以下的<code>Configure</code>在<code>Startup.cs</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.UseEndpoints(endpoints =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    endpoints.MapGrpcService&lt;GreeterService&gt;();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>API在<code>.proto</code>文件中描述，该文件是项目的一部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"> </span><br><span class="line">service Greeter &#123;</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 此<code>.proto</code>文件添加到<code>.csproj</code>： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemGroup&gt;</span><br><span class="line">  &lt;Protobuf Include=&quot;Protos\greet.proto&quot; /&gt;</span><br><span class="line">&lt;/ItemGroup&gt;</span><br></pre></td></tr></table></figure>

<p>.NET的gRPC客户端</p>
<p>客户端是从<code>.proto</code>文件生成的。代码本身非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var channel = GrpcChannel.ForAddress(&quot;https://localhost:5001&quot;);</span><br><span class="line">var client = new Greeter.GreeterClient(channel);</span><br><span class="line"> </span><br><span class="line">var response = await client.SayHello(</span><br><span class="line">    new HelloRequest &#123; Name = &quot;World&quot; &#125;);</span><br><span class="line"> </span><br><span class="line">Console.WriteLine(response.Message);</span><br></pre></td></tr></table></figure>

<h2 id="gRPC与REST"><a href="#gRPC与REST" class="headerlink" title="gRPC与REST"></a>gRPC与REST</h2><p>gRPC听起来不错。它在框架下更快，更简单。那么，我们都应该从REST变为gRPC吗？答案是，这取决于你的应用场景。</p>
<p>以下是一些注意事项：</p>
<p>从我的印象来看，使用gRPC和ASP.NET仍然不是很好。借助对REST的成熟支持，您会变得更好。就基于契约的通信而言，这很不错，除了在REST中有我们已经讨论过的类似替代方案：Swagger和ReFit。</p>
<p>最大的优势是性能。<a href="https://www.yonego.com/nl/why-milliseconds-matter/#gref" target="_blank" rel="noopener">根据这些基准</a>，在大多数情况下，gRPC更快。特别是对于大型有效载荷，Protobuf序列化确实有所作为。这意味着对于高负载服务器而言，这是一个巨大的优势。</p>
<p>在大型ASP.NET应用程序中从REST过渡到gRPC将非常困难。但是，如果您具有基于微服务的体系结构，那么逐步完成此过渡就变得容易得多。</p>
<h2 id="其他沟通方式"><a href="#其他沟通方式" class="headerlink" title="其他沟通方式"></a>其他沟通方式</h2><p>还有其他一些我完全没有提及的通信方式，但是值得一提的是：</p>
<ul>
<li><a href="https://graphql.org/" target="_blank" rel="noopener">GraphQL</a>是Facebook开发的API的查询语言。它允许客户端从服务器确切地要求它需要的数据。这样，您可以在服务器上仅创建一个端点，该端点将非常灵活，并且仅返回客户端所需的数据。近年来，GraphQL变得非常流行。</li>
<li><a href="https://github.com/SignalR/SignalR" target="_blank" rel="noopener">SignalR</a>是一项允许服务器与客户端之间进行实时双向通信的技术。SignalR不仅允许客户端始终向服务器发送请求，还允许服务器向客户端发送推送通知。这样可以查看Web应用程序中的实时更新。SignalR在ASP.NET中非常流行。</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.tcpclient?view=netframework-4.8" target="_blank" rel="noopener">TcpClient</a>和<a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.tcplistener?view=netframework-4.8" target="_blank" rel="noopener">TcpListener</a>（在中<code>System.Net.Sockets</code>）提供基于TCP的低级连接。基本上，您将建立连接并传输字节数组。对于大型应用程序而言，它不是理想的选择，在大型应用程序中，您可以使用ASP.NET的控制器和操作在大型API中进行订购。</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.udpclient?view=netframework-4.8" target="_blank" rel="noopener">UdpClient</a>提供了一种通过UDP协议进行通信的方法。TCP建立连接，然后发送数据，而UDP仅发送数据。TCP确保数据中没有错误，而UDP没有。UDP可以更有效地快速传输数据，您不必担心它是否可靠且没有错误。一些示例是：视频流，实时广播和IP语音（VoIP）。</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/framework/wcf/whats-wcf" target="_blank" rel="noopener">WCF</a>是一种较旧的技术，主要在进程之间使用基于SOAP的通信。这是一个庞大的框架，我要说的是它已不再受REST和JSON负载的欢迎。</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/技术/" rel="tag"># 技术</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/10/17/技术/Golden Master Pattern ：一种在.NET Core中重构遗留代码的利器/" rel="next" title="一种在.NET Core中重构遗留代码的利器">
                <i class="fa fa-chevron-left"></i> 一种在.NET Core中重构遗留代码的利器
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/02/17/技术/linq-how-to-rule-all-language/" rel="prev" title="LINQ：最终统治了所有的语言！">
                LINQ：最终统治了所有的语言！ <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">溪源</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">81</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">categories</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.cnblogs.com/xiyuanmore" title="博客园 &rarr; https://www.cnblogs.com/xiyuanmore" rel="noopener" target="_blank"><i class="fa fa-fw fa-博客园"></i>博客园</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/farway000" title="CSDN &rarr; https://blog.csdn.net/farway000" rel="noopener" target="_blank"><i class="fa fa-fw fa-CSDN"></i>CSDN</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#浅议C-客户端和服务端通信的几种方法：Rest和GRPC"><span class="nav-number">1.</span> <span class="nav-text">浅议C#客户端和服务端通信的几种方法：Rest和GRPC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#最佳方案"><span class="nav-number">1.1.</span> <span class="nav-text">最佳方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传统REST"><span class="nav-number">1.2.</span> <span class="nav-text">传统REST</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReFit"><span class="nav-number">1.3.</span> <span class="nav-text">ReFit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#昂首阔步"><span class="nav-number">1.4.</span> <span class="nav-text">昂首阔步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#将Swagger添加到ASP-NET服务器"><span class="nav-number">1.4.1.</span> <span class="nav-text">将Swagger添加到ASP.NET服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用AutoRest从Swagger生成客户端"><span class="nav-number">1.4.2.</span> <span class="nav-text">使用AutoRest从Swagger生成客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传统REST-vs-Swagger-vs-ReFit"><span class="nav-number">1.5.</span> <span class="nav-text">传统REST vs Swagger vs ReFit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gRPC"><span class="nav-number">1.6.</span> <span class="nav-text">gRPC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NET的gRPC的服务器端"><span class="nav-number">1.6.1.</span> <span class="nav-text">.NET的gRPC的服务器端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gRPC与REST"><span class="nav-number">1.7.</span> <span class="nav-text">gRPC与REST</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他沟通方式"><span class="nav-number">1.8.</span> <span class="nav-text">其他沟通方式</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">溪源</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.2</div>
#<div><a href="http://www.beian.miit.gov.cn/">ICP备案号:湘ICP备19001531号-2</a></div>



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>



  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
