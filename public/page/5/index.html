<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="xiyuan技术圈">
<meta property="og:url" content="http://techq.xyz/page/5/index.html">
<meta property="og:site_name" content="xiyuan技术圈">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xiyuan技术圈">





  
  
  <link rel="canonical" href="http://techq.xyz/page/5/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>xiyuan技术圈</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiyuan技术圈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">溪源的技术博客，技术的不断进取之路</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-技术">

    
    
    
      
    

    

    <a href="/categories/技术/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>技术</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-随笔">

    
    
    
      
    

    

    <a href="/categories/随笔/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>随笔</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-读书">

    
    
    
      
    

    

    <a href="/categories/读书/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>读书</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-管理">

    
    
    
      
    

    

    <a href="/categories/管理/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>管理</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-归档">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archives"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/01/05/技术/持续交付全流程思考与实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/05/技术/持续交付全流程思考与实践/" class="post-title-link" itemprop="url">持续交付全流程思考与实践</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-01-05 21:28:00" itemprop="dateCreated datePublished" datetime="2020-01-05T21:28:00+08:00">2020-01-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-01-09 22:24:04" itemprop="dateModified" datetime="2020-01-09T22:24:04+08:00">2020-01-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-从理论开始"><a href="#1-从理论开始" class="headerlink" title="1 从理论开始"></a>1 从理论开始</h1><h2 id="什么是DevOps"><a href="#什么是DevOps" class="headerlink" title="什么是DevOps?"></a>什么是DevOps?</h2><p>近年来，随着DevOps理念的逐渐深入人心，企业逐渐意识到从看似重复的手工劳动中实现自动化流程处理，对于提高企业劳动生产力已经非常重要，尤其是面向互联网的开发者，往往每次上线时，最大的挑战并非需求的走查或测试和改bug，而是由于发布的流程不够规范，将成果发布到目标环境后可能造成的配置错误或引发其他已知未知问题所造成的额外工作量，使得生产环境的发布流程总会存在不顺利。</p>
<p>而DevOps则致力于统一整合软件开发和软件运维，其特点是强烈倡导对构建软件的所有环节（从集成、测试、发布到部署和基础架构管理）进行全面的自动化监控。目标是缩短软件开发周期，提高部署频率和更可靠的发布，与业务目标保持一致。</p>
<p>在实际操作过程中，对于许多公司而言，开发者和运维者并没有明确的界限，而且即便将运维与开发的岗位职责分开了，也并非意味着双方的职业发展方向将大不相同。实际上在实际操作过程中，开发人员和运维人员依然会使用相同的工具、统一的流程、一致的管理思想，并通过一系列管理手段和工具实现流程的优化。</p>
<h2 id="什么是持续集成和持续交付？"><a href="#什么是持续集成和持续交付？" class="headerlink" title="什么是持续集成和持续交付？"></a>什么是持续集成和持续交付？</h2><p>持续集成（Continuous Integration）与持续交付(Continuous Delivery)也正是DevOps中最为基础的两种企业级研发和交付活动。</p>
<p>持续集成来源于敏捷项目管理思想，其核心是团队成员应该经常集成他们的工作，通常每天要求集成一次，当然也可以要求团队成员每天集成多次。每次集成之后，会通过持续集成工具自动运行自动化的构建手段（例如编译、单元测试、集成测试、系统测试），并对集成后的成果进行验证，从而实现了企业管理流程中尽早的发现未知问题的目标。而在传统的软件交付中，可能会将所有问题积压到系统整体测试或甚至UAT（用户验收测试）环节，使得软件的测试时间被拉长，甚至使得软件的问题流入到客户现场，让客户成为小白鼠的情况时有发生。</p>
<p>实际上而言，看似简单的集成，却并非简单，他应该是企业管理过程中的一项铁律，只有严格执行，才能确保软件时刻处于可用状态；否则就意味着所谓交付过程中完成进度的百分之多少，只不过是一个虚无缥缈的空口白话。</p>
<p>持续集成往往离不开持续交付，在乔梁老师翻译的《持续交付》一书中，作者Jez Humber说：持续交付是一种能力，也就是说，能够以可持续的方式，安全快速的把代码变更（包括特性、配置、缺陷和试验）部署到生产环境中，让用户使用。这本书的作者也在书的最后一章中指出：它（持续交付）不仅仅是一种新的软件交付方法论，而且对依赖软件的业务来说，也是一种全新的范式。</p>
<p>持续交付与持续部署看似类似，其实有所区别，前者往往是指将环境推送到用户面前，使用户能够触及和使用它们；而部署则仅仅只是把软件包安装到目标计算机上，用户可能还无法直接使用。</p>
<p>对于面向互联网的软件企业来说，往往都已经在过去若干年间已经建立了一套完整的持续集成/持续交付流程，但对于某些处于飞速发展期的企业来说，依然相对而言后知后觉，主要是由于企业过去飞速发展的背后所依托的人力物力资源，能够足以保证企业的产出能够适应企业发展的需要，然而随着团队规模的发展赶不上企业业务发展的需要时，重复劳动和看似毫无价值的等待期、后期积压的测试任务、无法有效度量的软件功能实现，实质上也会造成企业的管理成本进一步提高。</p>
<h2 id="从哪里可以获得系统的方法论？"><a href="#从哪里可以获得系统的方法论？" class="headerlink" title="从哪里可以获得系统的方法论？"></a>从哪里可以获得系统的方法论？</h2><p>对于需要搭建一套完整环境的开发者来说，网上资料很齐全，本文也试图尽可能的对各方面的内容进行综述，努力为开发者提供一个开箱即用的操作流程，但是对于那些想系统的学习持续交付或DevOps领域的知识的开发者来说，你其实不仅仅满足于把环境搭起来，那么你应该看看书。</p>
<p>在持续集成和持续交付领域有大量优秀的作品，而我觉得来自乔梁老师的作品《持续交付2.0》堪称精品，乔梁老师是一位经验丰富的行业专家，在他的职业生涯中积累了与该领域相关非常丰富的产品研发经验，他也身体力行的参与到许多企业的持续交付流程优化过程中，这些经验都让他能够从更全面的视角来分析持续交付的问题。在这本书中介绍了许多直接拿来就可以使用的管理方法、项目案例、工具，能够让有需求在该领域有所作为的开发者带来不少思考。</p>
<p>实质上对于一家要实践持续集成/持续交付的企业来说，将工具搭建完成并非核心难点，难点依然在于如何使用敏捷项目管理的思想，实现软件的细粒度任务拆分，并能够对单个任务进行更好的测试，或许TDD是一种不错的模式，但是却可能给开发者的基础技能提出了更高的要求，这将导致TDD无法落地。</p>
<p>如何快速验证产品需求？在《持续交付2.0》中提出的了一系列的方法，例如装饰窗、最小可行特性法、特区法、定向搜索法、稻草人法、、最小可行产品法等六种方法，通过建立快速验证模型，提高软件从需求到实现的整个流程，能够为企业带来不少便利。</p>
<p>而在研发阶段，可以采用特性分支和特性开关的手法，利用git源代码管理工具分支的妙处，将需求和代码有机的耦合在一起，同时又依托项目管理工具，实现从需求=》实现=》发布的完整闭环，从而为需求的验证提供了双保险；特性开关我最早在刘华老师的《猎豹行动-敏捷转型》一书中看到，通过使用软开关的形式，避免未开发完成的提前上线造成巨大的风险，而在这边书中也同样提到了这样的方法。在.NET中同样也可以使用特性分支组件，后期我将尝试一下。</p>
<p>而对于如何减少等待期，作者提到的方法是：</p>
<p>1、通过“拉动”让价值流动起来，例如，如果是一个生产线的滞留，通过扩大瓶颈的处理能力，让更多的需求能够快速交付，这种手法看似能够临时提高环节处理能力，保障团队的产出，但是显然不是个良好的措施，更合理的措施就是根据下游的生产能力来确定上游的处理能力，由下游来拉动上游的需求。这客观上要求将任务和需求的粒度进一步均匀化，将需求划分成更加易于执行、工作量类似的小需求，使得开发过程更加平滑。</p>
<p>2、任务自助化：也就是让团队掌握某些通用技能，以便在其他人员阻塞时，能够同步完成相关任务，避免了某些关键任务阻塞造成了整体流程的滞后。 </p>
<p>在此我就不过多描述书中的精华了，有兴趣的可以入手一本，绝对物超所值。</p>
<h1 id="2、总体流程和环境部署"><a href="#2、总体流程和环境部署" class="headerlink" title="2、总体流程和环境部署"></a>2、总体流程和环境部署</h1><p>接下来我将进入本文的主题，首先我将构建一个简单的企业级持续集成/持续交付的管理流程，然后再对流程的实现过程进行较为详细的介绍。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/jenkins-pipeline/1.png" alt="图片"></p>
<p>在这个流程中，使用了master/dev的分支模式。</p>
<p>1、对于dev分支提交的代码，经过代码编辑、静态代码扫描、自动化单元测试的流程，在运行通过后，有测试人员进行代码的测试，并在代码测试通过后，通过pull request提交给master分支的审查人员进行代码检查和合并。</p>
<p>2、测试人员对dev提交的代码进行确认，并由master分支代码审查人员进行代码审查，通过后对代码进行确认，并生成用于发布的生成包。</p>
<h2 id="涉及的组件和说明"><a href="#涉及的组件和说明" class="headerlink" title="涉及的组件和说明"></a>涉及的组件和说明</h2><p>在流程中，使用了以下工具，依次安装即可。</p>
<p>1、安装OpenJDK</p>
<p>2、安装Jenkins和相关插件</p>
<p>3、安装PostgresDb</p>
<p>4、安装SonarQube</p>
<p>5、安装dotnetsdk3.1</p>
<p>6、安装git</p>
<p>7、安装nexus包管理器 for windows版用以实现包管理。</p>
<p>8、安装Qy Wechat Notification或HTTP Request 用以实现企业微信提醒。</p>
<p>好吧，环境安装就不介绍了。。</p>
<h2 id="安装补充说明"><a href="#安装补充说明" class="headerlink" title="安装补充说明"></a>安装补充说明</h2><p>1、其中jenkins安装的版本为2.190.3,OpenJDK安装的版本为openjdk12.0。安装完jenkins和openjdk后，需要进行环境变量的设置。 </p>
<p>2、SonarQube安装的版本为7.9.1，根据官方网站的说明，推荐使用的数据库包括：sqlserver\oracle\postgresdb，在7.9.1和更高版本中，已经不再推荐使用mysql。 </p>
<p>3、SonarQube默认使用了基于H2内存数据库的嵌入式数据库，可以在测试环境下使用，但是不建议用于生产环境。 </p>
<p>5、安装完sonarqube、和数据库后，需要修改sonarqube/conf/sonar.properties文件中的数据库配置地址，并将sonarqube的服务重启。</p>
<p><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/jenkins-pipeline/2.png" alt="图片"></p>
<p>在windows系统中，点击sonarqube-xxx\bin\windows-x86-64文件夹中的InstallNTService.bat用以安装SonarQube的服务，而StartNTService.bat则用于启动SonarQube的应用服务。如果数据库配置失败，则SonarQube会启动失败，并提示以下错误：</p>
<blockquote>
<p>[sonar-1510653879773] exception caught on transport layer [[id: 0x346b46fb, /127.0.0.1:59330 =&gt; /127.0.0.1:9001]], closing connection<br>java.io.IOException: An existing connection was forcibly closed by the remote host</p>
</blockquote>
<p>6、由于使用了自行搭建的Nuget包源管理器，所以在进行构建时，会提示错误，jenkins会使用</p>
<h2 id="Jenkins的项目类型"><a href="#Jenkins的项目类型" class="headerlink" title="Jenkins的项目类型"></a>Jenkins的项目类型</h2><p>在jenkins中提供了自由风格、单流水线、多分支流水线、多配置项目等不同类型的项目，可以根据实际情况进行取舍，在本人的尝试过程中，分别总结了三种不同类型的项目可适用的场景：</p>
<h3 id="自由风格项目"><a href="#自由风格项目" class="headerlink" title="自由风格项目"></a>自由风格项目</h3><p>操作流程简单，无需配置groovy脚本，即可简单的完成项目的自动化构建。 </p>
<p>在自由风格模式的项目中，实现代码编译的过程主要在构建窗口中，主要使用dotnet -相关命令来完成。包括：</p>
<p>1、dotnet restore 还原依赖包。</p>
<p>2、dotnet build 编译</p>
<p>3、dotnet publish -o ./bin/release 发布到指定目录下。</p>
<p>4、如果需要使用sonarqube来进行静态代码检查，需要在服务器上安装dotnet-sonarscanner组件，这个组件是基于.net core构建的静态代码检查组件，安装的命令为：</p>
<blockquote>
<p>dotnet tool install –global dotnet-sonarscanner –version 4.8.0；</p>
</blockquote>
<p>5、如果采用.net framework 传统框架，则可以继续使用原来的SonarScanner.MSBuild.exe组件进行代码检查结果的上传。</p>
<p>6、如果需要在自由风格项目中使用powershell脚本，可以在jenkins=》插件管理=》可用插件中搜索powershell即可。</p>
<h3 id="单流水线项目"><a href="#单流水线项目" class="headerlink" title="单流水线项目"></a>单流水线项目</h3><p>单流水线项目：可适用于只有一个分支和一套环境需要部署时的项目构建，其发布流程需要使用groovy脚本来实现。点击查看<a href="https://jenkins.io/zh/doc/book/pipeline/syntax/" target="_blank" rel="noopener">pipeline的语法</a></p>
<p>1、在流水线项目中，都在项目文件的根目录中添加jenkinsfile文件（无扩展名）作为jenkins编译时的脚本文件，而这个文件的脚本语法采用groovy语言，并支持开发者按照脚本语言进行扩展。</p>
<p>2、在单流水线项目中不支持groovy的分支判断条件，支持逻辑比较简单的脚本。</p>
<p>3、与编译有关的结构均写在jenkinsfile中，因此jenkins的UI界面可以理解为配置与项目相关的环境变量信息。</p>
<p>4、可以在jenkinsfile中定义输入的参数，例如：</p>
<blockquote>
<p>parameters{<br>       string(name:’ProjectName’, defaultValue: ‘Enter Your ProjectName’, description: ‘Enter your project name here’)<br>       string(name:’Contact’, defaultValue: ‘“@All”,”xxx”‘, description: ‘Enter Your Contract’)<br>       string(name:’RepoUrl’, defaultValue: ‘<a href="https://gitee.com/xxx/xxx.git&#39;" target="_blank" rel="noopener">https://gitee.com/xxx/xxx.git&#39;</a>, description: ‘ gitee代码路径’)<br>}</p>
</blockquote>
<p>在jenkins界面中，可以显示成</p>
<p><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/jenkins-pipeline/3.png" alt="图片"></p>
<p>在具体场景下就可以通过jenkins界面传入相关参数进行编译的测试了。</p>
<h3 id="多流水线项目"><a href="#多流水线项目" class="headerlink" title="多流水线项目"></a>多流水线项目</h3><p>多分支流水线项目：使用于一个仓库下各分支不同环境需要部署时的项目构建，其发布流程也需要使用groovy脚本实现。 </p>
<p>1、多流水线项目支持使用分支判断条件的语法，因此可以使用的场景更多。</p>
<p>2、其他的总体上和单分支流水线差不多，此处就不在赘述了。</p>
<p>以下编写了一个简单的示例，仅供参考。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">    agent any </span><br><span class="line">    parameters&#123;</span><br><span class="line">        string(name:&apos;Contact&apos;, defaultValue: &apos;&quot;@All&quot;,&quot;&quot;&apos;, description: &apos;Enter Your Contract&apos;) </span><br><span class="line">        string(name:&apos;RepoUrl&apos;, defaultValue: &apos;&apos;, description: &apos; 代码路径&apos;)</span><br><span class="line">        string(name:&apos;SonarUrl&apos;, defaultValue: &apos;http://localhost:9000&apos;, description: &apos; sonar代码路径&apos;)</span><br><span class="line">    &#125; </span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&apos;When Master&apos;) &#123; </span><br><span class="line">            when &#123;</span><br><span class="line">                expression &#123;BRANCH_NAME==~/(master)/&#125;</span><br><span class="line">            &#125; </span><br><span class="line">           steps&#123;        </span><br><span class="line">               checkout([$class: &apos;GitSCM&apos;, branches: [[name: &apos;*/master&apos;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: &apos;xxx&apos;, url: params.RepoUrl]]]) </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage (&quot;When Dev&quot;)&#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                branch &apos;dev&apos;</span><br><span class="line">            &#125; </span><br><span class="line">            steps&#123; rojectName&#125;&quot;) </span><br><span class="line">                checkout([$class: &apos;GitSCM&apos;, branches: [[name: &apos;*/dev&apos;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: &apos;xxx&apos;, url: params.RepoUrl]]])</span><br><span class="line">                bat &quot;dotnet restore $&#123;params.SlnName&#125;&quot;</span><br><span class="line">                bat &quot;dotnet-sonarscanner  begin /k:\&quot;$&#123;params.SlnName&#125;\&quot; /d:sonar.host.url=\&quot;$&#123;params.SonarUrl&#125;\&quot; /d:sonar.login=\&quot;$&#123;params.SonarToken&#125;\&quot;&quot; </span><br><span class="line">                bat &quot;dotnet build $&#123;params.SlnName&#125;&quot;</span><br><span class="line">                bat &apos;&apos;&apos;if not exist bin\\release mkdir bin\\release&apos;&apos;&apos;</span><br><span class="line">                bat &quot;dotnet sonarscanner end /d:sonar.login=\&quot;$&#123;params.SonarToken&#125;\&quot;&quot;</span><br><span class="line">                echo &quot;CodeCheck Success&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        stage(&quot;test&quot;)&#123;</span><br><span class="line">            when&#123;</span><br><span class="line">                expression&#123;return true&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps&#123;</span><br><span class="line">                echo &quot;OK&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        stage(&apos;Web Dev Build&apos;) &#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                echo env.BRANCH_NAME</span><br><span class="line">                echo params.RepoUrl</span><br><span class="line">                echo params.SonarUrl</span><br><span class="line">                  bat &quot;dotnet build $&#123;params.SlnName&#125;&quot;</span><br><span class="line">                bat &apos;&apos;&apos;if not exist bin\\release mkdir bin\\release&apos;&apos;&apos;</span><br><span class="line">                bat &apos;&apos;&apos;</span><br><span class="line">                dotnet publish -o ./bin/release </span><br><span class="line">                &apos;&apos;&apos;</span><br><span class="line">                echo &apos;Publish Success&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    post&#123;</span><br><span class="line">      success&#123;</span><br><span class="line">        SendToWeChatWork(&quot;CI Task success,ProjectName is $&#123;params.ProjectName&#125;&quot;) </span><br><span class="line">        echo &apos;Publish Success&apos;</span><br><span class="line">      &#125;</span><br><span class="line">      failure&#123;</span><br><span class="line">        SendToWeChatWork(&quot;CI Task Failure,ProjectName is $&#123;params.ProjectName&#125;&quot;) </span><br><span class="line">        echo &apos;Publish Failure&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">def SendToWeChatWork(content) &#123;   </span><br><span class="line">    def command = &quot;&quot;&quot;&#123;</span><br><span class="line">          &quot;msgtype&quot;: &quot;text&quot;,</span><br><span class="line">          &quot;text&quot;: &#123;</span><br><span class="line">          &quot;content&quot;: &quot;$&#123;content&#125;,See the detail in Control Panel:$&#123;params.Jenkins&#125;&quot;,</span><br><span class="line">          &quot;mentioned_list&quot;:[&quot;$&#123;params.Contact&#125;&quot;]</span><br><span class="line">          &#125;</span><br><span class="line">         &quot;&quot;&quot;</span><br><span class="line">    echo(command)</span><br><span class="line">    response = httpRequest (consoleLogResponseBody: true,</span><br><span class="line">      contentType: &apos;APPLICATION_JSON&apos;,</span><br><span class="line">      httpMode: &apos;POST&apos;,</span><br><span class="line">      requestBody: command,</span><br><span class="line">      url: &quot;$&#123;params.WeChatWork&#125;&quot;,</span><br><span class="line">      validResponseCodes: &apos;200&apos;)</span><br><span class="line">    return response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多配置项目"><a href="#多配置项目" class="headerlink" title="多配置项目"></a>多配置项目</h3><p>如果组件代码需要在不同的配置、不同的环境下重复部署，其基本逻辑类似，只是配置不同，就可以使用多配置项目。</p>
<p>好吧，我就没有尝试了，因为我已经用了多流水线项目来实现了。在这篇<a href="http://dtt4725.github.io/blog/2016/07/25/Jenkins%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Multi-Configuration-Projects/" target="_blank" rel="noopener">示例</a>中对多配置项目有比较详细的用法，需要可自取。 </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>将企业级持续集成的环境搭建起来本身并不难，难的是如何将整套体系与公司现有的开发流程相结合，考虑到受康威定律的影响，不同的组织对于新事物的接受程度总是不同的，原有组织或许已经习惯了基于手工拷贝再部署的模式，而目前采用这种持续集成、持续发布的模式，会产出哪些问题，这需要随时做好应对的方案。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/01/03/随笔/如何快速融入团队并成为团队核心（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/03/随笔/如何快速融入团队并成为团队核心（一）/" class="post-title-link" itemprop="url">如何快速融入团队并成为团队核心（一）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-01-03 09:28:00" itemprop="dateCreated datePublished" datetime="2020-01-03T09:28:00+08:00">2020-01-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-01-19 08:46:36" itemprop="dateModified" datetime="2020-01-19T08:46:36+08:00">2020-01-19</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随笔/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>我们难免需要离开一个圈子，加入一个陌生的集体。毋庸置疑，离开熟知的圈子，走向未知的圈子难免会产生许多畏惧甚至情怯，这都是人之常情，但不同的性格驱使我们会做出不同的决定。</p>
<p>外向者也并非时时刻刻外向，但他们习惯于把自己表现在更多陌生人面前，这使得他们总是看起来易于被人接受。</p>
<p>而内向者总是纠结于自己可能会犯错，而失去了展示自我的机会。他们纠结于自己的小圈子，总是需要花特别长的时间才能真正融入集体。</p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>一个人加入一个新团队，就像一滴热水突然坠入一片冰河之中。</p>
<p>有时候总需要一场破冰行动，说不定这场破冰行动会成为撕裂冰河的关键力量，在类似于蝴蝶效应的作用之下，整个河面最终都会融化，变成一片充满活力的美好世界，那时的你往往会觉得周围的一切是如此的亲切。</p>
<p>其实往往只需一念之间，不必寻求取悦他人，不必担心自己会不会犯错，只需单纯的选择一个恰当的时间，然后展示出自己，一切无需机遇，无需刻意安排，仅此而已。</p>
<p>其实人群中的每个人都不见得一定是具有才艺的个体，拥有才艺的往往是那么少数。也很少有喷子或者毒舌，那些习惯于没事嘲讽别人、看不到别人优点的人，其实很难在一个圈子中留下来，往往恰好是自己融不入圈子而逐渐的疏离。</p>
<p>在一个团队中的大部分人，都是富有包容心的。所以不用担心自己的表现会使自己的形象受损，恰好相反，有时候在展示自己的才艺时一不小心搞砸了这样看起来很没面子的事情，反而会更容易让大家把你记住，并认为你是一个非常有趣的人，而易于跟你打交道。</p>
<p>其实加入一个新集体就是这样简单，无需矫揉造作，无需刻意讨好，是什么就是什么。</p>
<p>你当然应该在乎你的形象，但是那是靠经常修剪自己的羽毛来完成的，而不是刻意扮演出一个多么独特的形象。真正决定你的形象的，并非这样的一瞬间，而是平时自己的一点一滴的积累和努力，并能与时俱进，保持进取。做一个专注的人，静下心来沉入到一个事情中，并努力的使自己专业，一定更容易让人重视，并也将使你得以在社会职责中扮演更加重要的责任。</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p>笔者亲历了一位内向者到社区发起者的成长之路。</p>
<p>他是长沙互联网社区的领袖唐胡子，他说当他才20几岁时，也是一个非常内向的人，甚至比一般的人还要内向，到29岁时，谈过好几个对象都因为过于内向而未能修成正果。</p>
<p>直到后来由于一次偶然的机会，他决定做出改变，然后他开始积极的放开自我，以更加积极的心态去接受陌生人，不再畏惧丢脸和面子，而是抓住一切机会表现自我，有圈子就融入圈子，没圈子就创造圈子。</p>
<p>首先借助于网络，成为网络社区的积极份子，然后把人从线上拉到线下，通过面对面沟通来加强凝聚力，使得虚拟圈子逐渐的变成稳定的大圈子，然后又不断的有新人加入，有人离去，血液不断，细水长流，源远流长。可以说以他为中心的许多圈子都被带活了，数千人为之获益。</p>
<p>要说他做了什么了不起的事情么，也许许多人会嗤之以鼻，不就是拉人头，搞活动，自我介绍，闲聊，聊技术话题么？</p>
<p>运营一个社群其实就是这样看似简单，但是却同样不简单，优秀的运营者总是能在一片陌生人的世界中开创出属于自己品牌的小圈子，然后借助于圈子创造出更大的价值。  </p>
<h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><p>有时我们应该积极的去拥抱陌生的领域。因为我们每个人都是独立存在的个体，独立的思维方式和行为的方式决定了我们跟周围人的区别，这恰好是人与人之间相处最大的乐趣，求同存异，在别人的世界中寻找自己，并探寻属于自己的未知领域，从而使自己的知识面进一步扩展。</p>
<blockquote>
<p>“你有一个苹果，我有一个苹果，我们交换一下，一人还是只有一个苹果；你有一个思想，我有一个思想，我们交换一下，一人就有两个思想。</p>
</blockquote>
<p>我们可以怎么做呢？</p>
<p>1、利用一切可以利用的资源，例如从网络开始，或者从花名册开始找人交流，寻找一些能够开启话题的方面，例如姓氏或兴趣爱好、或者籍贯等这些看起来无关紧要的东西。当然，有时你挑起的话题可能对方不感兴趣，没关系，至少冰层会一点点的融化开。这次不行，还有下次。</p>
<p>2、跟你周围的陌生人打招呼。多打招呼，对方将从你的每一次笑容中认识你。</p>
<p>3、去试图融入他们，从聆听他们的沟通开始，坐在陌生人的周围，营造一些沟通的机会。</p>
<p>4、抓住每一次团队建设的机会，这就是破冰的良机。优秀的企业都会有团队建设，通过团队建设，你将有希望看到在你所处的组织架构的一维世界之外的另外一层维度，这将使你对组织有更新的认识。</p>
<p>然后你将逐渐收获特别多的朋友，关键是你掌握了在陌生环境下生存的方法，这将成为你最重要的一种财富。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/01/03/随笔/2019年年终总结，静候时光与一步一个脚印/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/03/随笔/2019年年终总结，静候时光与一步一个脚印/" class="post-title-link" itemprop="url">2019年年终总结，静候时光与一步一个脚印</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-01-03 09:10:00 / Modified: 08:54:07" itemprop="dateCreated datePublished" datetime="2020-01-03T09:10:00+08:00">2020-01-03</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随笔/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>不知不觉，一晃年关将近，即将翻开2019，进入新的一页。</p>
<p>这周已经在朋友圈看到了来自公众号《恰同学少年》《Edi.Wang》和《吃草的罗汉》几位老师写下的年终总结，他们的年终总结让我感想颇多，对自己的2019年也感想颇深，对2020年也充满期待，是时候对过去一年的一些感悟做一个简单的总结了。</p>
<h1 id="关于“云程序员”"><a href="#关于“云程序员”" class="headerlink" title="关于“云程序员”"></a>关于“云程序员”</h1><p>在2<a href="https://www.cnblogs.com/xiyuanMore/p/10171587.html" target="_blank" rel="noopener">018年的年终总结</a>中，与其说是一个总结，不如说是写了一堆漂亮话，其实真正落地的flag太少，而且总结不够彻底，没有起到总结经验，反思教训的意义。</p>
<p>总体上来说，我应该做个对技术充满热情和追求的开发者，而在去年的年终总结大概也只表达了一个意思，不要做云程序员，不要做云程序员，不要做云程序员。</p>
<p>而2019年，我的目标就是回归本质，不做云程序员，从现在来看，至少从思维模式上，已经发生了很大的变化，至少“我觉得xxx技术也不过如此”“我以为xxx技术不过是xxx”这样的主观评判的口气已经不会在说了。</p>
<p>之所以成为“云程序员”，大概是来源于过去若干年有意无意的习惯使然。</p>
<p>有时候得承认，越是中小公司，越容易培养所谓通才，因为公司的发展尚处于摸石头过河的阶段，往往需要在纷繁复杂的混沌乱局中寻找一切可以生存的机会，这也意味着中小企业对开发者的要求几乎都是招之能来，来之能战，战之能胜的通才。中小企业也并没有太多职业生涯规划或培训指导的工作安排，所以工程师的成长往往需要靠自己的方式。</p>
<p>大部分所谓成长，其实是在憋工龄，在一个又一个圈子中绕来绕去。你会用到许多东西，实际上你无法学到真正属于自己的技能。有时候会贪图掌握更多知识，尤其是新技术，于是就开始走在了云程序员的路上。似乎许多中小企业出来的开发者更喜欢自称为全栈工程师，并自称自己什么都会，有的甚至会因此而对那些真正从事技术领域的专业开发者带有偏见，以为他们是死脑筋，其实往往是井底之蛙的个人之见。</p>
<p>专业公司的培养形式是以提高效率为目标的工业化培养形式，对专才的要求也越来越高。IT是一个复杂程度丝毫不亚于其他产业的系统工程，它涉及的领域和技术非常多，几乎每一个方面都值得人花一辈子去认真探究。事实上只有优秀的公司才有可能培养出专才，而且才有这样的土壤，能够让一些开发者能够把时间花在某些专业领域持续学习和研究，然后让知识产生价值。</p>
<p>规模越大、越优秀的公司越容易对开发者产生吸引力，除了其待遇问题外，往往是因为这些公司专业化程度更高，也意味着你更容易快速成长，因为专注于一个领域显然比无法专注于一个领域更能带来更快的成长。从软件研发岗位来说，当你在某些技术方向上的深度上到一定程度，再来扩充广度时，也更容易吸收到有用的东西。当然，现在互联网公司也逐渐开始往通才发展，因为掌握全局思维的开发者更容易做出产品，但是互联网公司和中小企业的通才区别依然比较大。互联网公司需要的是具备互联网思维，能够把自己一块小天地处理完美，还能兼顾其他人工作的可复用型T字型人才，而小企业要的大概是一字型人才。</p>
<p>尤其对于长沙这座小城市而言，更难以发现专注于某些领域的开发者，或许与企业规模和职业定位有一定的关系，其实哪怕优秀如BAT或华为，也或许无法找到太多某些领域的专业开发者，除了公司的客观因素，与开发者们的主观选择也有关系。当然，不管在大公司或小公司，这不能妨碍我们成为专业开发者，只是意味着如果我们要成为某些领域的大牛，得花更多的时间和精力来经营自己的领域。</p>
<p> 当然，专业/不专业，云程序员/非云程序员或许本身不重要，毕竟对于大部分开发者来说，选择IT知识混口饭吃。而对于有追求的开发者来说，更应该长期的职业发展全局均衡，而不要仅仅关注眼前的利益。尤其在目前这个时代，你的每一段职场，其实不仅仅在为金钱工作，而是为你的简历工作。如何从你的职场中积累对未来发展有价值的东西，才是核心关键的因素。不论你在哪家公司，总会有许多让你收获颇多的东西。常怀感恩之心，用心去发现价值，总能让你成为正能量的传播者。这样的你，既是公司最宝贵的财富，也同时会让你成为人群中的闪光点。 </p>
<h1 id="关于软件研发技能"><a href="#关于软件研发技能" class="headerlink" title="关于软件研发技能"></a>关于软件研发技能</h1><p>如前文所说，软件领域是一个非常复杂的系统工程，每一个专业领域都值得人花一辈子去努力钻研，但是对于大部分开发者来说其实无需如此，往往只需花几年时间，就能快速吸取到IT软件发展的精髓，并成长为公司的核心人员。</p>
<p>当你成长起来之后，或许会以为框架就是技术的王道；也会以为软件就是工具+框架的结合，而忽略了更具有普遍意义的基础技能和算法能力；在抽象化思维上，在过程式思维这条路上越走越远，也极大的局限了开发者的成长；你会以为只有底层代码才是代码，业务代码或增删改查就不是代码；你会以为写文档、写PPT的人都是吹牛逼的。这些都是开发者的怪毛病</p>
<p>软件研发技能确实是一个值得仔细探究的核心领域，哪怕简单到一句需求的描述，也需要用系统性思维来思考这个问题。</p>
<p>回顾过去，我总是在想，我真的懂得做项目么，真的懂得如何做好一个软件么？我做的项目是否还有进一步可以提高的空间？如何优雅的收集客户需求，如何优雅的打造完美的产品？如何优雅的做好一个项目？如何让每一个项目都成为标杆项目？如何从失败中吸取经验教训。好吧，我有点啰嗦。</p>
<p>做一个软件真的并非想象中那么简单，需要将行业思维与IT思维更加完美的融合，既要从更高的战略层面思考问题，又要从代码的微观层面思考问题，有思考有设计、有碰撞有火花，这恰好是软件工程最大的魅力所在。</p>
<h1 id="关于读书"><a href="#关于读书" class="headerlink" title="关于读书"></a>关于读书</h1><p>2019年看了大概20-30本书，并写了超过15篇书评。包括以下书籍，我认为这些书籍给我带来的无穷收获，远超这些书本身的货币价值。</p>
<p>《领域驱动设计-软件系统核心复杂性应对之道》：这本书来自埃文斯-埃里克的书，是一本经典的领域驱动设计的书，在2018年8月我开始认真阅读其中的每个文字，并让我对领域驱动有了更深层次的理解；今年我还通过GitChat购买了张逸老师的领域驱动设计的课程，张逸老师不愧为领域驱动设计方面的专家，他用自己的经验解释了领域驱动设计，让我对这本书、以及相关知识都有了系统而全面的了解，同时还通过这一个课程了解了更多的知识领域，对健全我的知识体系产生了巨大的作用。</p>
<p>《中台》：来自阿里巴巴钟春老师的中台，这本书介绍了阿里巴巴中台建设的历程，这本书造出了一个独特的中国概念，也刷新了我的知识观，虽然短期来看我所经历的企业都没有中台的打算，但能够让我具备全局性思维来思考IT体系建设的问题。</p>
<p>《小团队、大架构》：来自张清辉老师，这本书介绍了携程的.NET技术架构转型过程，让我对.NET架构的演进方向有了明确的认识。当然这本书过多的介绍轮子，许多读者或许不喜欢，如果跟《微服务架构模式》一起交替的看，一定会产生不错的效果。</p>
<p> 《构建之法》：来自邹欣老师，这本书介绍了软件工程师的成长和微软的IT管理模式，让我能够静下来思考当下自己的发展方向。作为一个拥有十年工作经验的开发者，已经陷入了一个以自我为中心的乖蹇，而周筠老师对我的悉心教导，也让我非常感动，我也要持续努力，坚定自己的发展方向，努力做一个脚踏实地的开发者。</p>
<p>《浪潮之巅》共两卷：这是吴军老师的作品，吴军老师的质朴清新，不刻意使用过多的辞藻铺垫的写作风格让我获益匪浅，同时讲述的一个个故事又是如此的引人入胜。从故事中，我们看到了一群充满梦想的年轻人们，他们在互联网的浪潮之下做出的选择，是如何一点一点的改变了世界。</p>
<p>《实例化需求》：这是一本介绍BDD模式的书，介绍了行为驱动开发这种模式，让我获得了新的知识。当然短期内用不起来，但多学一点总不会吃亏。 </p>
<p>除此之外还有：《代码整洁之道》、《重构-改善既有代码的艺术2》、《持续交付2.0》、《PMBook》（好吧，考了12月的pmp，把pmbook看了四遍）、《程序员的三门课》、《Http/2基础教程》、《混乱：如何成为失控时代的掌控者》、《我的世界观》、《算法图解》、《未来简史》、《刷新》、《修炼之道》、《猎豹行动》、《单元测试的艺术》和刚刚读完的《华为方法论》。</p>
<p>这20几本书都是不同方向的书，与能够读完50本书或更多的优秀前辈们相比确实还存在一点差距，当然这些书有精读有略读，甚至有的其实是牛嚼牡丹，值得以后细细品味。</p>
<p>有的书着实发人深省带来了许多启迪，有的书则让我的知识体系进一步全面，不过从书到知识到技能，还需要进一步实践、修炼和理解，不然依然是走在云程序员的路上。 </p>
<h1 id="关于社区"><a href="#关于社区" class="headerlink" title="关于社区"></a>关于社区</h1><p> 2019年比较大的成绩，拉了一个技术社区应该算是一个；从2月的酝酿，到4月的落地，花了不少的精力，而且这些都是利用业余时间完成的，连筹款都是靠社区大佬、微软、腾讯运加以及社区朋友们的大力支持。也把公众号从80开始，做到了目前的5000+，这些也算是小收获吧，不过没什么骄傲的，毕竟那么多人都是从零开始，做到万粉大号。</p>
<p>从某种意义上来说，社区似乎离大家都比较远。有时候会感觉试图打造社区来凝聚开发者，其实是一厢情愿。技术社区，或许只会给那些拥有开放性基因的企业和开发者带来好处，并有望助力企业的进一步腾飞。尤其在长沙，究竟有几家企业拥有开放的技术心态？这是个问题。长沙的技术氛围着实令人窒息。</p>
<p>我们总是渴望打造一个优秀开发者社区。其实优秀开发者本身是一个不好衡量的问题，毕竟成为前百分之二十已经是优秀者，而张一鸣口中的那百分之一的精英，本身就并非一朝一夕所能炼成。</p>
<p>最终还是落在产出上，你助力企业腾飞、或者你做出了优秀的产品、或者你能够具备自己的系统性思维，并能写出一辆本书；优秀有太多种了，每一种都来之不易。</p>
<p>一个所谓社区，如果没有形成长期有价值的积累，没能打造优秀的平台，最终走向消亡反而会是“众望所归”。如何让社区避免成为水群、如何发掘更多优秀开发者，形成精英小圈子，我想说每个人都得继续努力，最起码不能成为一个菜市场，否则这样的圈子，其实毫无价值。</p>
<p>有时候会发现，每个群都是那么几个固定的人，沉迷于群其实根本不能带来个人成长，真正的成长还是得静下来自己认真学习。</p>
<p>要成为优秀开发者，有时候三天打鱼，两天晒网的刻意憋一点大招，表面上看能带来一点好气象，但是过了那个热度就被客观条件或主观条件抛弃。技术这东西真得坚持个三五年，才真的能够成长起来。有的人，看到这个火，就追逐这个，看到那个热门就赶潮流搞那个，一边写着代码，一边想着明年是不是该转行，这样的学习方式如何能够提高自己？</p>
<p>从这一点上来看，我只想说我已经在努力朝着好的方向进步，但是还远远不够，与那些已经坚持优秀习惯五年、十年之久的开发者相比，我需要做的远远不止眼前这一点点。</p>
<h1 id="关于2020年的计划"><a href="#关于2020年的计划" class="headerlink" title="关于2020年的计划"></a>关于2020年的计划</h1><p>有时候不太想列过于宏大的计划，因为往往计划会变成插红旗，然后在自己的背上插满了红旗，变成了一个京剧里面的大英雄。这样的计划或许毫无意义。</p>
<p>所以还是得认真思考，踏踏实实的做几个能够落地的计划：</p>
<ul>
<li>1、勿忘初衷，踏实前进：不吹水，不装逼。做一位优秀的专业开发者，在专业方向上持续形成系统性思维。</li>
<li>2、减法和加法：<ul>
<li>有感于今年随着参与了社区活动，加的群也越来越多了，2020年得在这一点上多做减法。</li>
<li>有时候追逐于信息的热度，其实大部分都与我毫无关系。为何关注这些东西？还是八卦性思维的束缚，这一点也有做减法。</li>
<li>而知识体系的厚度上则需要做加法，多看书，多思考。朋友圈做加法，并非多交更多的朋友，而是都跟优秀的朋友交流沟通，吸取他们的优点，转化成自己的优点。</li>
</ul>
</li>
<li>3、写满一百篇博客，看五十本书。</li>
<li>4、也得学Edsion周同学锻炼身体了。</li>
<li>5、努力践行积极乐观向上的团队文化、努力培养一支有战斗力的学习型团队。</li>
</ul>
<p>超过30岁的开发者总是会焦虑于自己的职业发展，不知道自己的未来该如何选择，那大概是由于想得太多，做得太少。</p>
<p>行走在IT这条路，成长太快反而不是好事，只有脚踏实地，一步一个脚印，才能真正无所畏惧。 “易定者无感，易感者无定。”，谋划好未来，并经营自己的当下，才有美好未来。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2019/12/15/读书/《程序员的三门课》读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/15/读书/《程序员的三门课》读书笔记/" class="post-title-link" itemprop="url">《程序员的三门课》读书随想</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-15 21:28:00" itemprop="dateCreated datePublished" datetime="2019-12-15T21:28:00+08:00">2019-12-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-12-18 08:33:40" itemprop="dateModified" datetime="2019-12-18T08:33:40+08:00">2019-12-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书/" itemprop="url" rel="index"><span itemprop="name">读书</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一-回顾我的职场体会"><a href="#一-回顾我的职场体会" class="headerlink" title="一  回顾我的职场体会"></a>一  回顾我的职场体会</h1><p>我的职场生涯开始于十年前，一直在中小企业发展，未曾有幸到沿海那些高速发展的互联网公司工作，也就错过了互联网的大时代。</p>
<p>但这不影响我的正常工作生活，事实上无论你身在何处，或在哪家公司，以各种title生存，我们都是在属于自己的职场道路上奋力拼搏，为了实现自己的人生梦想，我们需要付出的代价和努力，或许并不亚于我们的父辈。</p>
<p>我们的父辈大部分都生于50后，60后，70后，成长于七零年代，八零年代，九零年代。他们的时代，是举国体制逐渐退潮，市场经济开始唱主角的时代，他们往往没那么多的学问，有时候得靠自己的勇气和双手才能改变自己的命运。而我们的时代，更多的得依靠自己的学问和知识领域来直面社会发展。互联网的大时代，汹涌澎湃如斯，浪花卷卷，看似卑微的小人物，同样也能在时代扮演不平凡的角色。</p>
<p>事实上过去十年正是中国互联网产业飞速发展最为波澜壮阔的十年，哪怕从世界层面来说，也同样如此。中国的互联网本身就比美国晚了将近十年，但是凭借过去的十年，我们取得的飞速发展让我们得以跟美国看起来不相上下。</p>
<p>当然，大时代的发展看似与我们大多数人关系不大，我们只是时代的见证者和受益人，而还有一些人，他们都积极的参与到其中，并为这个时代的发展起到了看似简单但也至关重要的作用。</p>
<h1 id="二-价值或没价值，其实不用争执"><a href="#二-价值或没价值，其实不用争执" class="headerlink" title="二 价值或没价值，其实不用争执"></a>二 价值或没价值，其实不用争执</h1><p>我一贯认为围绕价值的争执毫无意义，毕竟每个人的评判标准截然不同，但不同的人大概目标是一致的，追求创造属于自己的价值，实现自己的梦想。当然，在时代的裹挟之下，大多数人都难以真正拥有自己的梦想。往往都是在本能的驱使下，选择工作，家庭，按部就班的工作，陪伴家庭逐渐的向未来前进。</p>
<p>但这不影响我们可以设想一下我们应该拥有的一些共识，例如使命，价值观和文化。我觉得这三者是非常重要的东西，使命驱使我们前进，价值观促使我们拥有自己的原则，而文化是我们过去受到的家庭教育，学校教育和社会教育在灵魂上的投影。这些东西某种意义来说决定了我们的货币价值。</p>
<p>为了提高货币价值，我们往往都得超越自我，去做一些在现在知识层面下难以实现的东西。</p>
<p>一个人的知识领域，往往是知道得越多，越会感觉到自己的欠缺，在刚开始的时候或许是一个小圆圈，但是随着逐渐的学习，这个圆圈也越来越大。</p>
<p>未知越多，潜力越大。每个人都是独一无二的个体，并在自己的舞台上努力表演，我们虽然难免需要妥协于生活，但是我们其实并不必莫名其妙的取悦于任何人。</p>
<p>而社会中的每个个体都看似不一样，但往往也能够互相协作，互相支撑，每个人都有自己的职业分工，但总有工作交集的存在。这就意味着看似不一样的生活或工作，总能找到一些值得复用和思考的知识领域，这就需要我们放开心胸与其他人交流，从而使自己的精神更加饱满。</p>
<h1 id="三-写书和读书，是一种灵魂对话"><a href="#三-写书和读书，是一种灵魂对话" class="headerlink" title="三 写书和读书，是一种灵魂对话"></a>三 写书和读书，是一种灵魂对话</h1><p>而写博客，写书或读书大概是最好的一种方式，作者把自己的成长故事和所思所感记下来，再借助书这种载体输出，既实现了自己知识的沉淀，又能将自己的知识领域向外播撒；</p>
<p>读者可以花并不高的代价购买到来自于作者一手的知识分享，又能在书中寻找自己的存在，达到与作者的共鸣，这样的学习一定会让人获益非浅。</p>
<p>在软件研发领域的许多知识，不像我们受到的教育一般，有些东西是有明显的对错之分的，像程序员成长，架构思维或管理模式，无论是哪种方式，总能实现我们的目标。</p>
<p>我们中的大部分人的成长都大体一样，来源于某份工作或多份工作的自我学习，而不是靠真正的书本或教育，在社会中学习，大概如此。但是这样的东西难免有失节奏，不够系统，甚至要走特别多的弯路，吃很多亏。</p>
<p>有时候我们会想知道，哪里可以获得系统的学习方法呢？</p>
<h1 id="四-这本书值得读的点"><a href="#四-这本书值得读的点" class="headerlink" title="四 这本书值得读的点"></a>四 这本书值得读的点</h1><p>一本《程序员的三门课》，或许能够给你带来思考。</p>
<p>这本书没有试图像那些能够给我们带来直接收入的【21天学会xx技术】的书一样，能够迅速让我们迅速的学会新技术，他甚至有点像啰嗦的前辈一样，说了一些让人摸不着边际的东西。</p>
<p>事实上书的作者恰好是亲历了互联网大时代的一波人，有阿里巴巴的技术大佬右军老师，李伟山老师，还有彭首长老师和刘朋老师，也有年轻如张洪亮的青年才俊，他们都致力于学习和为企业创造价值，他们事实上也颇有成就。他们都经历了职场的历练，无论是996甚至007，他们都是第一批冲杀在前线的斗士。他们不仅做事雷厉风行，他们更是喜欢思考人生的意义。</p>
<p>他们都并非像这篇文章一样喜欢说啰嗦的话，他们把自己过去若干年的思考汇集在这本书中，目标是渴望给读者带来真正的收获。</p>
<p>当你刚参加工作时，需要快速入门的书给你带来顿悟，但一旦稍微稳定下来，一定得站在更高的视角来规划一下自己的未来。编程技术，你可以快速的提升，而掌握这本书中的某些部分，你将有希望看破迷雾，不至于在职场面前过于迷茫。这些从工作中出发，提取自技术、思维模式和管理方法不同层面的知识，每一种都很有思考的意义。</p>
<p>当然，看完这本书你甚至需要看更多的书，因为这本书他虽然凝淬了许多书的精华，但也是来源于本书作者对于知识的提炼，或许与原作者的原意稍有差别。在读完这本书之后，你或许将拥有一把去开启更多知识领域的钥匙。</p>
<p>一本经典，往往能让你产生无尽思考；而一本好书，则会让你看破一些道理，甚至会觉得，原来这些其实就是这么回事啊。</p>
<p>越是看起来简单的道理，越是需要花心思去揣摩才能体会。就像许多看似简单的技术实现，没有亲身经历的，都是“二手知识”。网上有许多的学习资料，尤其是当我们打开某些信息流app时，其实那是你的“信息茧房”，每天阅读这些内容，你会以为技术的获得是多么的轻易，但只有手把手写过一波，才能真正获得价值。而阿里巴巴和众多互联网公司们，花了十年时间做了那么多东西，一定是走了弯路，踩了许多坑才最终获得了最佳实践，而这些在这本书里都有所介绍。</p>
<p>例如，如果你想在组织中建设一套质量管理体系，书中花了不少章节介绍了代码审查的方式和工具，以及代码审查清单的五个大方向和十六个小方向，这些能够从代码层面建立第一道防线；接着可以从架构体系做好第二层防线，例如分析架构质量的问题来源和解决策略，以及实现流程。这些几乎都是拿来就能应用的良好策略。</p>
<p>对于程序员的快速成长，作者们都深有体会，例如积极主动的应对困难，以空杯的形态去看待学习，以及别怕犯错，这些都是良好的习惯，尤其要掌握学习方法，打破舒适区和终身成长，能够让我们更快的成长。</p>
<p>如果初涉管理，作者们也介绍了他们的许多感受，包括做好准备，抓住机会，构建领导力，和高效的时间管理。尤其是时间管理，为什么同样都是996，作者们却不仅把代码写得很完美，还能有时间写那么多博客呢。团队培养，看起来简单却不简单，书里面也提到了许多措施。</p>
<h1 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h1><p>一本好书，能够给你带来一点思考，就已经足够了，如果让你获得了超过一点思考，那就是赚大了。</p>
<p>冷静的阅读一下，你会有不一样的收获。这些都是你自己的收获，更是属于你自己的无穷财富。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2019/12/15/随笔/我在外包公司做增删改查有前途么？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/15/随笔/我在外包公司做增删改查有前途么？/" class="post-title-link" itemprop="url">我在外包公司做增删改查有前途么？</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-15 21:28:00 / Modified: 21:30:47" itemprop="dateCreated datePublished" datetime="2019-12-15T21:28:00+08:00">2019-12-15</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随笔/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>这是我无意中在筛选简历时，看到一位朋友发布的求职说明中，明确指出，外包勿扰，并给出了他做出这个决定的理由：</p>
<p>过去若干年间，他一直在中软国际从事.NET方向的软件研发，虽然工作了很多年，但是做的项目类型特别多，总感觉没什么积累，而且工作很累，经常要加班，压力很大。不仅如此，由于外包类型的项目，往往需要驻场开发，一旦在客户现场进行开发，其实都会成为封闭式开发，每天投入工作的工时往往会超过十几个小时。而且在客户现场的开发时，有时候就是低等公民，得承受来自各方的压力。</p>
<p>前不久也刚刚看到一位来自西安软通动力的资深Java工程师，由于长时间加班后引发身体疾病，并最终猝死，还得不到工伤补偿的新闻也触动了我们的心。</p>
<p>这边的互联网公司从业人员还可以吐槽每天996，让自己成为被公司圈养的小绵羊，更是让自己的家庭生活都受到了无穷影响；那边的外包公司从业人员们显然没有互联网公司这么多的露脸机会，哪里有时间运营自己的公众号啊，每天都被客户压榨得死死的，还得跪下来对客户说：爸爸，再爱我一次！</p>
<p>当然，坦率而言，现在国内的IT行业现状其实压力都很大，无论是外包公司、还是互联网公司，如果是几年前大环境还好的时候，或许大家压力大点，至少不会饿肚子，现在冬天来了，不仅压力大，而且还吃不饱穿不暖，一旦遇到公司困境，还得面临被裁员的后果。</p>
<ul>
<li><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/1.png" alt="image-20191130140814321"></li>
</ul>
<p>好吧，在这篇文章中，我还是不输出焦虑了，只单纯的讨论一下这个问题。</p>
<h1 id="在外包公司做增删改查有前途么？"><a href="#在外包公司做增删改查有前途么？" class="headerlink" title="在外包公司做增删改查有前途么？"></a>在外包公司做增删改查有前途么？</h1><p>有没有感觉，这是一个通用的句式：干xxx有前途么？</p>
<ul>
<li><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/2.png" alt="image-20191130140814321"></li>
</ul>
<p>例如，在百度里面输入，“干程序”，首先会自动提示的就是“干程序员有没有前景”？好吧，有没有前途我也说不准，我就单纯的探讨几个问题，什么叫有前途；在外包公司有前途么；做增删改查有前途么？</p>
<h1 id="什么叫做有前途？"><a href="#什么叫做有前途？" class="headerlink" title="什么叫做有前途？"></a>什么叫做有前途？</h1><p>世俗的说，金钱、名誉和地位大概就是许多人在追求的前途。而在IT领域，由于无法与从事公务员和经商的其他同龄人相比，往往会用待遇和岗位来形容。例如有时候总会以为技术总监一定是值得追求的前途；或者为了更高的收入，会选择一些特定的行业。例如这几年相继爆雷的P2P行业，在这些行业中的开发者的工资往往都非常高。</p>
<p>然而，当公司的套路被人揭穿之后，无数投资人的巨额投资化作一堆废纸，这些P2P企业公司的开发者们在这段时间从公司获得的所有收入都会被列入非法所得，必须上缴给公安机关，以便清偿债务。</p>
<p>不仅如此，有时候还不能过度的宣传自己在这些行业的职场工作经验，不然可能会被下家认为心术不正。 </p>
<ul>
<li><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/3.png" alt="image-20191130140814321"></li>
</ul>
<blockquote>
<p>爱因斯坦说：我坚信，世界上的财富无法促进人类发展，即使它掌握在哪些仍想达到此目标的人手中也无济于事。金钱只能滋生人们的自私自利，并使其不能自持地加以滥用。</p>
</blockquote>
<p>当然，当今时代终究是个世俗的世界。但追求金钱和Title所谓的看似有前途的工作，还是得建立道德和法律的基础上。</p>
<h1 id="在外包公司有前途么？"><a href="#在外包公司有前途么？" class="headerlink" title="在外包公司有前途么？"></a>在外包公司有前途么？</h1><p>外包公司的主要盈利点，其实是软件研发过程管理或者软件项目管理能力，一套优秀的软件项目管理流程体系，往往能够实现软件开发过程中的生产力最大化，进而为企业的发展带来巨大的利润。</p>
<p>在外包公司，主要的收入其实是来源于项目参与人员的人工费用，一般会采用“工料合同”的形式。这种合同又称为单价合同，一般会根据产品在研发过程中的实际投入或服务来计算合同总价。</p>
<p>当然，其实许多外包公司会采用这种方式来进行工作量的评估，然后再用总价合同的形式来签订合同，毕竟“工料合同”其实浮动空间很大，容易造成甲方的成本超支严重，而使用总价合同就可以将风险转嫁给乙方，对于甲方来说自然而然就实现了利益最大化了。</p>
<p>而总价合同的特点是应该明确设定需求、对功能的工作量评估都应该尽可能的科学，问题是，客户明白他想要什么么？大概率客户并不懂他想要什么，或者他以为他懂他想要什么，而且你以为你也懂他想要什么。于是陷入双方需求的拉锯战，软件的风险急剧提高，让苦逼的乙方程序员们成为砧板上的肉，被迫每天牺牲自己的时间，拿有限的生命投入到无穷无尽的需求大坑中。</p>
<p>而且有时候由于行业不同，还会陷入需求陷阱中，各行如隔山，客户想要的，往往与你能提供的，存在很大的差异。例如，连微软都会被武汉上诉，要求赔偿其在智慧城市项目中造成的大几千万损失，一般般的外包公司就更不用说了。</p>
<p>如果遇到这种情况，请勇敢的选择拒绝，或者使自己成为更专业的人。努力花更多的时间学习行业知识，然后用数据或阶段性成果让客户尽可能的无话可说吧。</p>
<p>当然并非所有的外包公司都是这种情况，例如像SAP或者Thoughtworks，其实也可以被世俗的理解为外包公司，他们也是为客户提供外包服务，但是由于他们是行业内的领先者，能够为客户需求提供更加专业的建议，所以他们有资格找客户签署“工料合同”。</p>
<p>例如一个SAP的服务工程师，从上飞机起就开始计算工时费用，每天动辄万元的服务费，服务工程师的工资自然而然也低不到哪里去了。我一位同事他哥哥就是从事SAP的外包服务，他说他哥哥每年只上半年班，工资超过3万一个月。。。嗯,好吧，这种外包就等同于有前途。</p>
<p>依然有许多公司会走在签署总价合同的外包公司的道路上，毕竟企业生存是第一要务，万一哪天接到一个合适的项目，让公司能够顺利的摆脱外包公司的这块皮，进入细分市场，获得进一步的生机呢？</p>
<p>不过大部分外包公司或许其实并没有那么好的命，而且还会由于内卷化（指优秀员工逐渐流失，而新人难以加入，最后被中庸的老员工主宰企业的命运）最终越来越丧失竞争力，并最终只能凉凉。而且缺乏核心主业的外包公司确实很难获得技能上的积累，这需要开发者能够提高自己的技术学习能力，努力使自己成为最专业的工程师。</p>
<ul>
<li><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/4.png" alt="image-20191130140814321"></li>
</ul>
<h1 id="做增删改查有前途么？"><a href="#做增删改查有前途么？" class="headerlink" title="做增删改查有前途么？"></a>做增删改查有前途么？</h1><p>许多开发者都吐槽，每天的工作都是CRUD，也有许多开发者经常吐槽身边的那些开发者没前途，只会增删改查。</p>
<p>怎么觉得这个问题为啥这么魔性呢？难道你和他们不是同一拨人么？</p>
<p>有时候还会看到有人吐槽，说每天都在做CRUD的业务开发，感觉自己人都要玩废了。还问我怎么想。</p>
<p>我个人认为CRUD才是公司业务的常态，只有能够把CRUD玩得非常好，公司业务才能获得更快的发展。从表面上看，CRUD工程师的主要职责就是建表、封装接口、然后让接口输出数据符合客户端需求。实际上这里面依然牵涉到许多充满技术含量的东西。</p>
<p>例如，该如何建表呢？从海量的用户需求中，分析出与系统息息相关的核心部分，并分析出符合用户需求的核心领域，这种业务分析与设计能力是一位软件工程师非常重要的核心技能。</p>
<p>例如，以前都是撸sql，现在都用orm了，是不是觉得很香？增删改查一样也充满了期待啊。</p>
<p>该怎么建表，也并非想象中那么简单。例如主键是用自增序列，还是用UUID，该怎么设计索引，如何设计缓存，如何运用分表分库策略？这些看起来很简单的东西，往往并不简单。</p>
<p>除此之外，代码的质量本身，也是一件值得深入钻研的方面，例如《代码整洁之道》和《重构改善既有代码的艺术》这两本书就专门介绍了如何写代码和如何把代码写好。这也是一件看起来简单，却并不简单的事情。</p>
<p>除此之外，沟通技能、架构能力、风险意识，也都会在这些CRUD的开发过程中得以体现。</p>
<p>为什么总是会认为CRUD毫无挑战呢。如果你已经成为软件开发领域的大牛，请收下我的膝盖，否则大概率是因为你已经走在了云程序员的路上，把一切问题都想象得太简单了吧。</p>
<p>突然想起之前看的的一张段子，说火箭其实没什么技术含量，因为中国古时候早就有了。还有之前看的郭德纲的段子，他说：如果我跟一位火箭工程师讨论火箭的燃料不应该用氢氧，应该烧煤，对方正眼看了我一眼，那就是我输。</p>
<p>嗯，云程序员们，咱们离专业开发者还有不少差距啊！</p>
<ul>
<li><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/waibao/5.png" alt="image-20191130140814321"></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="# 总结"></a># 总结</h1><p>回到主题：在外包公司做增删改查有前途么？</p>
<ol>
<li>在外包公司也好，非外包公司也好，努力使自己成为专业的人，都会有前途。</li>
<li>不管在哪家公司，如果你觉得不开心可以离去；但是如果留下来了，请珍惜每一段时光，上帝既会给你关门，也往往会给你开一扇窗户，只要用心去发现，你总会有所收获。</li>
<li>其实认真干好每一件事情，都会充满前途。如果过于敏感，总觉得干这个没前途，干那个没前途，那大概你应该去选择创业。那里你可以找到属于你的好归宿。</li>
<li>IT的职场的时光说漫长也漫长，说短暂也短暂。干得好就是四十年，干得不好，就是五年。</li>
<li>或许每个人都有机会花五年时间成为技术总监，但是却只有少数人，能够成为真正合格的工程师。</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2019/12/11/随笔/容器-推荐序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/11/随笔/容器-推荐序/" class="post-title-link" itemprop="url">李文强先生的《容器入门教程》推荐序</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-11 21:28:00 / Modified: 21:42:16" itemprop="dateCreated datePublished" datetime="2019-12-11T21:28:00+08:00">2019-12-11</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随笔/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="推荐序"><a href="#推荐序" class="headerlink" title="推荐序"></a>推荐序</h1><p>容器技术，大概是最近几年最为流行的一种技术。这种技术打破了原来用虚拟机部署软件对硬件环境和条件的限制，让软件的逻辑边界获得了更大程度的扩展。只要是一台能够安装Linux的个人PC机、服务器、甚至是小巧玲珑的树莓派，都可以非常轻松的安装容器，实现了硬件资源的最大化利用。这也让微服务技术得以更好的落地，更加便捷、高效的实现企业生产效率的提升。</p>
<p>然而，虽然容器技术越来越流行、虽然网上的资料很多，但是往往多而杂乱，让人看得眼花缭乱。而且许多资料看起来能够有用，实际上大部分资料都是重复而错误的，许多文章都是从其他网站上生搬硬套、拷贝或者甚至直接抄过来的。这也导致了许多开发者虽然想真正学习容器技术，却还得自己一点点摸着石子过河，踩很多的坑。事实上借助于搜索引擎往往看似会给我们带来许多便利，也会让人产生摸不着头脑。缺乏靠谱的资料支持，缺乏系统的学习方法，缺乏深入浅出的过程描述，这大概是面向搜索引擎学习的开发者们最大的困扰。 </p>
<p>在这个背景下，这本书应运而生。作者李文强是我们长沙互联网社区的一位开发者，而且也是一位创业者，平时工作很繁忙，但是却依然对技术充满了持续的学习精神。他从容器刚刚兴起就跟进技术，并灵活的将容器技术和kubernetes（k8s）技术运用到企业的实际项目中，获得了非常不错的效果。基于容器技术和k8s技术的完美结合，让公司的产品开发流程实现了足够细粒度的服务划分，然后再配上一键发布、所见即所得的持续交付流程，让他的企业能够快速适应客户需求和市场的变化，为企业的业绩腾飞带来了不少助力。</p>
<p>这本书的每个案例都是作者悉心收集整理、书中的每个步骤作者都认真的尝试了好几遍，与步骤有关的每个截图都力求真实，可以是说精心打磨的上佳作品。他平时观察也很仔细，把在工作中踩过的每个坑都认真的记下来，并以博客的形式发布，获得了大家的一致好评。这几年来他在博客和公众号发表相关主题的帖子已经不下百篇，惠及数万开发者，事实上我也正是通过他的博客认识了他。这本书也是李文强先生在实践过程中的所思所感的汇聚，通过这本书，我们也还可以学习到如何科学有效的掌握新技术的方法。</p>
<p>总之这是一本非常适合初学者入门容器和k8s的书，不管你是在校大学生、还是对容器和运维技术感兴趣的从业者，您都应该拥有这本书。它不仅能手把手指引你的学习，更能让你赢在起跑线上，为你的幸福生活添砖加瓦。</p>
<p>某软件技术有限公司研发总监-邹锭</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2019/12/09/随笔/PMP学习之旅回顾/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/09/随笔/PMP学习之旅回顾/" class="post-title-link" itemprop="url">复盘2019年，我花了3个月时间备考PMP</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-09 22:28:00" itemprop="dateCreated datePublished" datetime="2019-12-09T22:28:00+08:00">2019-12-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-02-06 22:03:26" itemprop="dateModified" datetime="2020-02-06T22:03:26+08:00">2020-02-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随笔/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="引子​"><a href="#引子​" class="headerlink" title="引子​"></a>引子​</h1><p>​        经过几个月的准备，终于在2019年12月7日完成了PMP的考试，并于今天查到了成绩，总结这次考试的具体情况：涉及题型虽然都没有超出大纲的范围，但是原题出现的概率似乎不高，还有一些原来未曾见过的题目，例如矩阵型组织或弱矩阵型组织等，以及造一个能够能飞三米的纸飞机，存在5%的废品，该如何处理，这样的题目让人有点摸不着头脑，还有一些原题，虽然是模拟题上的题目，但是。。我居然到了考试的时候居然忘记答案了，这有点过于尴尬。  </p>
<h2 id="为什么考PMP"><a href="#为什么考PMP" class="headerlink" title="为什么考PMP"></a>为什么考PMP</h2><p>​    回顾职场，我是在参加工作的第二年成为项目经理的，当时还是啥都不同的毛头小伙，就被公司指派担任一个十几万小项目的项目经理，并和两位老鸟一起共同参与项目的研发，每天都出入XX勘测设计院的大门之中，基本上都认识了这些勘测院的机关工作人员，还好这个项目本身技术并不复杂，加上有足够的资源和不急的时间需求，做出的成果也符合了甲方的需求，所以这个项目总体上处理的还算不错；</p>
<p>​    随后又参加了另外一个几十万的小项目，并在其中担任项目经理和技术负责人，由于有了一位资深工程师、一位资深从业者（虽然对编程技术不够了解，但是沟通能力很强）所以这个项目也能如鱼得水。</p>
<p>​    再后来同时带了两个项目，一个是XXX规划局的XX信息平台，一个是地下管线系统，同时带两个项目的压力确实很大，而且公司的技术水平其实并不好，这两个都是研发型项目，作为一个开发出生的我，难免很难同时兼顾两个项目，加上地下管线系统其实是有老鸟参与研发设计，而我基本上只用跟需求，而空间信息平台则是我带一些没有工作经验的新手，所以我对于管线系统也就没太放在心上，精力也就全部放在空间信息平台上，所以当项目结项时，虽然两个项目都完成了，但是差别却特别大，空间信息平台广受赞誉，为后来接下数百万的合同奠定了基础，而地下管线系统（其实合同额更高）中的老程序员们却由于被过度放权，反而疏于管理，虽然软件做出来了，但是却没能派上用场，到后来被尘封，只能成为一个经费项目。</p>
<p>​    再后来，公司内部组织结构发生了变更，我也进入了一个的高光时期，被选为部门的项目主管，同时兼顾多个项目，负责管理了超过20位项目团队成员，管了3个项目经理。当时的我一度以为是自己的优秀打动了领导，其实是因为公司确实是没人了，才让我临时暂代，然而我还以此为骄傲，最终什么事情都没搞好。</p>
<p>​    后来就从这家公司离职，开始了新的职场过程，前前后后也陆陆续续带了不少项目，有大有小，成功或失败，也或多或少有一些。总体上来评价，差强人意，虽然试图做好项目，但是却总感觉阻塞颇多，无论是人员上的，还是技术上，或者沟通上的，总觉得没有特别完美。尤其是做互联网项目时，花了许多时间去打磨产品，却依然没能做出令人眼前一亮的东西，固然与产品有一定的关系，其实也与未能管理领导的预期有更大的关系。</p>
<p>​    确实如此，一个成功的项目，首先要管好客户的预期，其次得做好资源的调配。真正好的项目经理，一定是那些看起来很闲的项目经理，因为他们把什么事情都能很好的规划，只是做好任务分配、任务审查、和任务总结以及汇报就够了，而像过去的我那样的渣项目经理，不仅事无巨细、连代码要管，衣食住行要管，还让大家累死累活下来也根本没赚到多少钱。</p>
<p>​    在IT领域，不仅软件开发有德雷福斯的能力成熟度模型，连项目经理也同样具备，同样必须经过一万小时，经过从新手到高级新手，到胜任者，精通者，到专家的蜕变，而这个过程，要么必须吃了很多亏（意味着要花费公司大量的人力物力财力来培养），要么就是能够真正自发成为专业的项目管理者。</p>
<p>​    事实上专业的项目管理者比开发者或许更困难，在我从业的这十年中，也遇到了个别优秀的项目经理，他们善于运用领导力的强大魄力，在项目各方间游刃有余，而更多的项目经理，都像我一样，运用程序员的沟通技巧，与各方沟通，往往会吃尽苦头。</p>
<p>​    技术出生的管理者，往往都具备类似的毛病：例如过度在意过程和实现；忽略沟通的力量；渴望全局掌控；缺乏领导艺术；缺乏政治敏感度；藐视人情世故等。好吧，在后来的项目过程中，我已经逐步掌握了沟通、政治敏感度和人情世故这样的法宝，并通过这种手段获得过各方的认同，但是还是或多或少在乎细节、在乎流程的完备性，反而忽略了对于客户预期的把控，最终依然造出了几个不太成果的项目。</p>
<p>​    一个人的成长，大概就是得经历从失败的挫折、吸取教训、逐渐成长的过程，无论是哪个岗位都大体类似。优秀的项目管理能力一定是开发者的必备基础技能，唯有灵活的掌握项目管理技能的多个方面，才能让软件项目能够高效、快速的契合各方的需求，实现组织从一种状态到另外一种状态。</p>
<p>​    如果说以前带的项目，基本上已经到了胜任者的层级，那么大概这种层级，其实是自封的，如何来真正证明自己具备\胜任相关岗位呢，我觉得大概需要一个纸质证明了。这就是我打算考PMP的原因。</p>
<h2 id="为什么选择培训班"><a href="#为什么选择培训班" class="headerlink" title="为什么选择培训班"></a>为什么选择培训班</h2><p>​    不过考PMP有很多种方式，而且PMP本身也不是一种特别困难的资格证，在我的身边已经有许多人考了PMP，并获得了证书，甚至有许多人拿到了5A证书，例如我参加的培训班，5A率已经超过70%了。</p>
<p>​    而在国内，每种证书最常见的质疑是，考这个有用么？我倒是觉得，有没有用先不管，至少学到知识的过程就一定值得花这点钱。知识的价值，也并非那些可以用直接卖多少钱来衡量，他其实是一点一滴深入你的骨肉，并最终构成你的灵魂，并且在需要体现价值的时候，一点一点的凸显出来。</p>
<p>​    除此之外，我也感觉虽然考试范围就是在PMBOOK这本书，而且只考前538页，但是书本上有太多内容了，每一个点都能够写出许多许多的故事出来，甚至而言，把五大过程，四十九过程组中，任意抽出一个过程组出来专精，都可以成为一个称职的专家，所以纯粹看书其实并不能提高自己对于项目管理技能的领悟力，而那些能够给我们提供培训的老师，他们往往首先是真正优秀的项目经理。其次不仅对项目管理这一本砖头书要烂熟于心，也需要能够用自己的语言把枯燥无味、干涩的知识讲出花来，这更需要本事。</p>
<p>​    再加上项目管理这种管理体系，其实更是一种团队技能，靠自己看书，往往找不到重点，而借助于培训机构，反而能够跟其他具有相同爱好的人一起学习，也算是一段不错的过程。</p>
<p>​    选择现代卓越面授班对我来说确实是个非常明智的决定，因为面授班确实是这样的好地方，大家一起讨论项目管理方面的问题，着实是一种不错的体验。</p>
<h2 id="通过培训获得的收获"><a href="#通过培训获得的收获" class="headerlink" title="通过培训获得的收获"></a>通过培训获得的收获</h2><p>​    近年来随着离软件公司越来越远，离各种行业软件越来越近，觉得自己的项目管理能力的某些方面诸如沟通表达能力和领导力有所提升，但是对于项目管理过层中的计划管理能力反而已经越来越差了。毕竟原来一直从事IT技术研发+项目管理，对于时间的计划安排，无外乎就是按照自己的经验去套、或者借助于模仿，这是初学者的典型惯例。</p>
<p>​    除此之外，在项目中，虽然用到了瀑布模型这种预测性生命周期来管理项目，但是又接触到许多敏捷的项目管理方法，所以技能点反而不纯粹了，总结就是，什么都懂一点，却什么都只懂一点，所以专业级项目经理是如何做项目的？这确实是一个值得仔细讨论的问题。而这也是参加培训最大的收获。</p>
<p>​    总结一下可以为我未来做项目提供指导的一些点：</p>
<p>1、需求的重要-紧急矩阵：评估需求时，先把重要紧急矩阵画好，然后再来指导工作。以前难道不知道么，确实没这么系统的学习这套理论吧。</p>
<p>2、权力-利益方格、相关方认知模型、相关方参与度评估矩阵：</p>
<p>3、能力-欲望矩阵：有能力有欲望、有能力没欲望、没能力有欲望、没能力没欲望，你在哪个象限？值得深思。</p>
<p>4、成本管理：老板的钱来之不易，成本管理得做好。</p>
<p>6、三大管理学原理：彼得原理、帕金森定律和墨菲定律，大概可以好好讲一天。</p>
<p>7、如何做好团队激励和团队建设：哪些是保健因素，哪些是激励因素，如何打造一支优秀的团队？知易行难啊。</p>
<p>9、风险责任矩阵RBS:提前做好风险评估和责任人分配，让风险防范于未然很有必要。</p>
<p>10、问题日志、经验教训登记册、风险登记册和营造积极分享的氛围。</p>
<p>11、会议管理：罗伯特议事规则。开会太长确实需要规则。</p>
<p>12、关键链法：盲目的设定项目工作包或活动其实没什么意义，倒不如先做好关键链，然后再逐步的实现里程碑，只要关键链做好了，往往也离项目做完不远了。毕竟一个项目是花有限的资源做有限的事，而不是无穷尽的盲目的投入。</p>
<p>13、挣值分析技术：虽然挣值分析技术是一种数学评估方法，看起来有点不太精准，但是将这种技术高效的运用到项目中，也许会给项目管理带来不少便利。</p>
<p>14、责任分解矩阵：做好工作分解和责任分解固然重要，更要给责任人指派明确的责任，而不是口头上的任命，做到有根有据，有考核指标和评价依据非常重要。</p>
<p>15、塔克曼团队发展阶段理论：一个团队的成长早期，往往是相互独立、甚至互相提防的，只有互相磨合，经历开诚布公，才能打造成熟稳定的团队。</p>
<p>16、TEAM团队理论：Today Everyone Achive More。没有完美的个人，只有完美的团队。团队并非一个人、而是大家彼此拿出自己最擅长的方面，共同打造一个完美的群体。</p>
<p>17、冲突管理：团队中适度的沟通反而能够促进团队关系的更加融洽。而没有冲突的团队往往是一滩死水，有了冲突，各方才能更好的理解对方的思维模式和思考方式，进而促进团队的进一步完善。</p>
<p>18、沟通的漏斗效应：是沟通就一定会衰减，但是如何让衰减尽可能的减小、控制在一定的范围呢。这大概需要更加重视沟通相关方的影响力。</p>
<p>​    当然，实际上还有更多内容，只是以上几点特别熟悉，整个PMP的考试过程确实给我带来了不少启发，我也希望以后能够逐步的把pmp中学到的一些知识应用到项目和团队管理中，并渴望能够带来效率上的提升。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    好吧， 说那么多，我尽力了，是真的尽力了么，我完全还可以更努力啊。</p>
<p>​    当然，深受帕金森定律的影响，能够提前学的东西，到最后一天才学，不过庆幸自己的努力没有白费，相信一份付出，总有一份回报。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2019/12/01/技术/浅议Grpc的双向流和WCF中的回调机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/技术/浅议Grpc的双向流和WCF中的回调机制/" class="post-title-link" itemprop="url">浅议gRPC的数据传输机制和WCF中的回调如何迁移到gRPC</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-01 18:28:00" itemprop="dateCreated datePublished" datetime="2019-12-01T18:28:00+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-12-09 23:06:16" itemprop="dateModified" datetime="2019-12-09T23:06:16+08:00">2019-12-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="浅议Grpc的双向流和WCF中的回调机制"><a href="#浅议Grpc的双向流和WCF中的回调机制" class="headerlink" title="浅议Grpc的双向流和WCF中的回调机制"></a>浅议Grpc的双向流和WCF中的回调机制</h1><h2 id="一、引子"><a href="#一、引子" class="headerlink" title="一、引子"></a>一、引子</h2><p>如您所知，gRPC是目前比较常见的rpc框架，可以方便的作为服务与服务之间的通信基础设施，为构建微服务体系提供非常强有力的支持。</p>
<p>而基于.NET Core的gRPC.NET 组件截至2019年11月30日的最新版本为2.25.0，该版本基于.netstrandard2.1进行，能够在.NET Core3.0上非常方便的实现，而且还能方便的迁移到基于.NET Core的windows桌面端开发体系。</p>
<p>在本文中参考微软官方文档的示例，实现了一个从WCF 服务回调机制迁移到gRPC的过程，由于时间仓促，如有疏漏，还望批评指正。第一篇主要从技术层面来分析迁移流程，第二篇打算从业务和代码整洁性角度来思考这个问题。</p>
<h3 id="1-1、一些新东西："><a href="#1-1、一些新东西：" class="headerlink" title="1.1、一些新东西："></a>1.1、一些新东西：</h3><h6 id="1-、使用客户端工厂组件-Grpc-Net-ClientFactory-："><a href="#1-、使用客户端工厂组件-Grpc-Net-ClientFactory-：" class="headerlink" title="1)、使用客户端工厂组件 Grpc.Net.ClientFactory ："></a>1)、使用客户端工厂组件 Grpc.Net.ClientFactory ：</h6><p>在新版本中，可以使用  Grpc.Net.ClientFactory 支持以依赖注入的形式AddGrpcClient，将grpc客户端引入中，而无需每一次方法调用都使用 New 关键词进行创建。 这对客户端调用来说是极大的方便，毕竟随着.NET Core的普及，对于许多开发者来说，看到 New 关键词其实是很难受的啊。</p>
<p>示例：</p>
<p>以下代码以注册了 GreetClient ，并在发送 http 请求前，对请求头信息进行修改，添加 jwt 标识，以便发送带鉴权标识的请求。</p>
<pre><code>serviceCollection.AddGrpcClient&lt;GreeterClient&gt;(
    o =&gt;
    {
    o.Address = new Uri(configuration[&quot;address&quot;]);
    })
    .AddHttpMessageHandler&lt;JwtTokenHeader&gt;();</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class GreetImpl</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    private readonly GreetClient _greetClient;</span><br><span class="line">    public GreetImpl(GreetClient greetClient)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JwtTokenHeader中的代码段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.Headers.Authorization = new AuthenticationHeaderValue(&quot;Bearer&quot;, &quot;&quot;);</span><br><span class="line">HttpResponseMessage response = await base.SendAsync(request, cancellationToken);</span><br></pre></td></tr></table></figure>

<p>(以上示例代码仅供参考，不支持直接运行，且不支持.NET Framework。。) </p>
<p>所以到此为止，我们在使用gRPC开发时，需要（能）使用的组件包括以下几种：</p>
<ul>
<li>Grpc.AspNETCore包：这个包用于在asp.net core中提供grpc服务支持，在asp.netcore的服务端项目中以nuget安装grpc组件时，需要安装这个包。<ul>
<li>Google.Protobuf组件：Protobuf协议的实现。</li>
<li>Grpc.AspNetCore.Server ：gRPC Asp.NET Core服务端核心库</li>
<li>Grpc.Core.Api ：gRPC  Core API核心库</li>
</ul>
</li>
<li>Grpc.Tools 包：内部封装了从proto文件生成gRPC服务端/客户端方法存根的流程。</li>
<li>Grpc.Core：gRPC核心包。</li>
<li>Grpc.Net.Client：gRPC 客户端实现核心库。<ul>
<li>Grpc.Core.Api ：gRPC  Core API核心库</li>
<li>Grpc.Net.Common：gRPC 常用方法。</li>
</ul>
</li>
<li>Grpc.Net.ClientFactory： gRPC客户端工厂方法。仅用于标准库2.1。</li>
</ul>
<h6 id="2-、其他特性："><a href="#2-、其他特性：" class="headerlink" title="2)、其他特性："></a>2)、其他特性：</h6><ol>
<li>支持  SerializationContext.GetBufferWriter 。</li>
<li>性能优化。 Optimize server’s gRPC message serialization </li>
<li>验证协议降级。 Validate gRPC response protocol is not downgraded  </li>
<li>New Grpc.AspNetCore.Server.Reflection package </li>
<li>Log unsupported request content-type and protocol </li>
<li>Major client performance improvement </li>
<li>修bug等。</li>
</ol>
<p>（ 当然，由于各种原因，未能亲测。）</p>
<h3 id="1-2、存在的缺陷"><a href="#1-2、存在的缺陷" class="headerlink" title="1.2、存在的缺陷"></a>1.2、存在的缺陷</h3><ul>
<li><p>目前的grpc的定位仅仅是一种数据传输机制，因此本身不包含负载均衡和服务管理的功能，一般会引入consul/etcd/zk等框架来实现服务治理。</p>
</li>
<li><p>由于最新版本基于标准库2.1进行构建，因此该最新版本无法在.net fx上使用（因为.netframework最高仅支持到标准库2.0），不过只是新版本不支持，依然可以使用2.23.2的版本来实现。当然，以后也不会支持.netfx了。。</p>
</li>
</ul>
<h2 id="二、gRPC通信方式"><a href="#二、gRPC通信方式" class="headerlink" title="二、gRPC通信方式"></a>二、gRPC通信方式</h2><p>gRPC提供了以下四种传输方式：</p>
<p>查看</p>
<h3 id="2-1、Simple-RPC"><a href="#2-1、Simple-RPC" class="headerlink" title="2.1、Simple RPC"></a>2.1、Simple RPC</h3><p>简单RPC 传输。一般的rpc方法调用，一次请求返回一个对象。适用于类似于以前的webapi请求调用的形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc Hello (HelloRequest) returns (HelloReply);</span><br></pre></td></tr></table></figure>

<h3 id="2-1、Server-side-streaming-RPC"><a href="#2-1、Server-side-streaming-RPC" class="headerlink" title="2.1、Server-side streaming RPC"></a>2.1、Server-side streaming RPC</h3><p>一种单向流，服务端流式RPC，客户端向服务端请求后，由服务端以流的形式返回多个结果。例如可以用于客户端需要从服务端获取流媒体文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc Subscribe (SubscribeRequest) returns (stream StockTickerUpdate);</span><br></pre></td></tr></table></figure>

<h3 id="2-3、Client-Side-streaming-RPC"><a href="#2-3、Client-Side-streaming-RPC" class="headerlink" title="2.3、Client-Side streaming RPC"></a>2.3、Client-Side streaming RPC</h3><p>一种单向流，客户端单向流，客户端以流的形式传输多个请求，服务端返回一个响应结果。例如可以用于客户端需要向服务端推流的场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc Subscribe (stream SubscribeRequest) returns (StockTickerUpdate);</span><br></pre></td></tr></table></figure>

<h4 id="2-4、-Bidirectional-streaming-RPC"><a href="#2-4、-Bidirectional-streaming-RPC" class="headerlink" title="2.4、 Bidirectional streaming RPC"></a>2.4、 Bidirectional streaming RPC</h4><p> 双向流式rpc。客户端和服务端均可以传输多个请求。例如可以用于游戏中的双向传输。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc Subscribe (stream SubscribeRequest) returns (stream StockTickerUpdate);</span><br></pre></td></tr></table></figure>

<p>总之，看起来gRPC能够实现目前所能设想的大部分场景，因此也被视为是古老的rpc框架 wcf ( Windows Communication Foundation )的替代者，官方专门编写了一本电子书，用来给需要从 wcf 转 gRPC的开发者提供指引。</p>
<p>具体地址为： <a href="https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/</a> </p>
<p>除此之外，本人还看到了一些外网作者使用grpc 来移植 wcf的一些博客。</p>
<p>1、 <a href="https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/" target="_blank" rel="noopener">https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/</a> </p>
<p>2、<a href="https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/" target="_blank" rel="noopener">https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/</a> </p>
<p>这两篇博客的作者在.NET Core中使用了WCF，根据作者的说法，在.NET Core2.0中还能使用，但是随着3.0的发布，他已经不再使用WCF了，而是改用了gRPC。</p>
<h2 id="三、WCF的通信方式"><a href="#三、WCF的通信方式" class="headerlink" title="三、WCF的通信方式"></a>三、WCF的通信方式</h2><h3 id="3-1、简述"><a href="#3-1、简述" class="headerlink" title="3.1、简述"></a>3.1、简述</h3><p>WCF 是.NET框架中非常常用的一种组件，在.NET Framework 3.0时被引入，它整合了一些历史悠久的技术框架或通信机制，诸如 soap、remoting等。</p>
<p>由于WCF技术体系庞大，学习路线也比较陡峭，能够驾驭的往往都是拥有多年工作经验的资深开发者，开发者们有时需针对各个阶段的内涵做深入的了解，才能开发对应的应用。</p>
<p>由于本人使用WCF的经验尚浅（以前的项目用得少，充其量就用过Remoting），所以以下文字均来自网上现有资料的演绎，如有疏漏，敬请批评指正。</p>
<p>WCF中，需要定义合约作为通信过程中的沟通方式。通信双方所遵循的通信方式，有合约绑定来制定；通信期间的安全性，有双方约定的安全性层级来定义。</p>
<h3 id="3-2、合约-Contract"><a href="#3-2、合约-Contract" class="headerlink" title="3.2、合约(Contract)"></a>3.2、合约(Contract)</h3><p>合约（ Contract） 是WCF中最重要的基本概念，合约的使用分成两个部分，一部分是以接口形式体现的合约，一部分是基于合约派生出的实现类。</p>
<p>合约分成四种类型：</p>
<p>数据合约 （Data Contract） ：订定双方沟通时的数据格式。</p>
<p>服务合约 （Service Contract） ：订定服务的定义。</p>
<p>操作合约 （Operation Contract） ：订定服务提供的方法。在维基百科中翻译为营运合约。</p>
<p>消息合约 （Message Contract） ：订定在通信期间改写消息内容的规范。</p>
<p>在维基百科中，提供了一个如下的代码示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using System.ServiceModel;</span><br><span class="line">namespace Microsoft.ServiceModel.Samples</span><br><span class="line">&#123;</span><br><span class="line">  [ServiceContract(Namespace = &quot;http://Microsoft.ServiceModel.Samples&quot;)] // 服务合约</span><br><span class="line">  public interface ICalculator</span><br><span class="line">  &#123;</span><br><span class="line">    [OperationContract] // 操作合约</span><br><span class="line">    double Add（double n1, double n2）;</span><br><span class="line">    [OperationContract] // 操作合约</span><br><span class="line">    double Subtract（double n1, double n2）;</span><br><span class="line">    [OperationContract] // 操作合约</span><br><span class="line">    double Multiply（double n1, double n2）;</span><br><span class="line">    [OperationContract] // 操作合约</span><br><span class="line">    double Divide（double n1, double n2）;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3、协议绑定"><a href="#3-3、协议绑定" class="headerlink" title="3.3、协议绑定"></a>3.3、协议绑定</h3><p>WCF支持HTTP\TCP\命名管道（ <a href="https://zh.wikipedia.org/w/index.php?title=Named_Pipe&action=edit&redlink=1" target="_blank" rel="noopener">Named Pipe</a> ）、MSMQ（ <a href="https://zh.wikipedia.org/w/index.php?title=MSMQ&action=edit&redlink=1" target="_blank" rel="noopener">MSMQ</a> ）、点对点TCP Peer-To-Peer TCP 等协议。其中对HTTP协议的支持分为:基本HTTP支持\WS-HTTP支持；对TCP的协议也支NetTcpBinding\NetPeerTcpBinding等通信方式。</p>
<p><del>从这里可以看出，能够驾驭WCF技术的，基本上都是.NET开发领域的大牛，涉及到如此多的技术栈，实在是令人钦佩。</del></p>
<p>由于WCF支持的协议很多，所以在进行WCF的客户端和服务端开发时，需要使用统一通信的协议，并且在编码以及格式上也要一致。</p>
<p>维基百科提供了一个设置通信绑定的示例配置文件，当然，有时候无需通过配置文件来配置wcf的服务信息，通过代码创建也同样可行。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">system.serviceModel</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 接口协议 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">services</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">" CalculatorService"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">endpoint</span> <span class="attr">address</span>=<span class="string">""</span> <span class="attr">binding</span>=<span class="string">"wsHttpBinding"</span> <span class="attr">bindingConfiguration</span>=<span class="string">"Binding1"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">contract</span>=<span class="string">"ICalculator"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">services</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通信机制 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bindings</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">wsHttpBinding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">binding</span> <span class="attr">name</span>=<span class="string">"Binding1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">binding</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">wsHttpBinding</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bindings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">system.serviceModel</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4、代码迁移"><a href="#4、代码迁移" class="headerlink" title="4、代码迁移"></a>4、代码迁移</h2><h3 id="4-1-迁移WCF的单工通信"><a href="#4-1-迁移WCF的单工通信" class="headerlink" title="4.1 迁移WCF的单工通信"></a>4.1 迁移WCF的单工通信</h3><p>在WCF中，一般默认的契约形式为点对点的请求-响应方式。即客户端发出请求后，一直阻塞方法，指导服务端响应后，才能执行后面的代码。</p>
<p>这种模式类似于gRPC中的简单传输机制，所以如果从WCF服务迁移到gRPC服务时，比较简单纯粹，只需根据对应的数据方法来订定我们的服务协议文件 proto 文件。 </p>
<p>例如，大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ServiceContract]</span><br><span class="line">public interface ISimpleStockTickerCallback</span><br><span class="line">&#123;</span><br><span class="line">    [OperationContract]</span><br><span class="line">    void HelloWorld(string msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迁移到 gRpc中之后，就是这样的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpc Hello (HelloRequest) returns (google.protobuf.Empty);</span><br><span class="line">message HelloReply&#123;</span><br><span class="line">	string msg=1;</span><br><span class="line">&#125;</span><br><span class="line">message HelloRequest&#123;</span><br><span class="line">	string msg=1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再在两端代码中实现方法即可。（由于代码过于简单，此处省略若干字）在引文3中，提供了非常完善的Wcf迁移到gRPC的代码流程，需要请自取。</p>
<h3 id="4-2-迁移WCF的双工通信"><a href="#4-2-迁移WCF的双工通信" class="headerlink" title="4.2 迁移WCF的双工通信"></a>4.2 迁移WCF的双工通信</h3><h4 id="1、WCF中的双工通信示例"><a href="#1、WCF中的双工通信示例" class="headerlink" title="1、WCF中的双工通信示例"></a>1、WCF中的双工通信示例</h4><p>在WCF中，双工（Duplex）通信很常用，在通信过程中，双方都可以向对方发送消息，使得很容易的就实现了服务端回调客户端。</p>
<p>在这种模式下，客户端向服务端调用一个方法，然后在服务端回调客户端方法，可以理解为双方的位置发生了改变，此时的服务端变成了客户端，而客户端变成了服务端。</p>
<p>如图所示。  </p>
<ul>
<li><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-mirgate-wcf-to-grpc/wcf-callback.png" alt="image-20191130140814321"></li>
</ul>
<p>代码如下：</p>
<ol>
<li><p>服务端：</p>
<ul>
<li>订定契约HelloCallback，用于处理回调的逻辑。</li>
<li>订定契约UserService 和 UserServiceImpl，并定义了一个 GetUser 方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 用于回调的Hello方法</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">[ServiceContract]</span><br><span class="line">public interface HelloCallback</span><br><span class="line">&#123;</span><br><span class="line">    [OperationContract(IsOneWay = true)]</span><br><span class="line">    void SayHelloworld(string msg);</span><br><span class="line">&#125;</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 用户服务,并回调客户端到HelloCallback</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">[ServiceContract(SessionMode = SessionMode.Required, CallbackContract = typeof(HelloCallback))]</span><br><span class="line">public interface UserService</span><br><span class="line">&#123;</span><br><span class="line">    [OperationContract(IsOneWay = true)]</span><br><span class="line">    void GetUser(string userName);</span><br><span class="line">&#125;</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 用户服务</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">[ServiceBehavior(InstanceContextMode = InstanceContextMode.PerSession)]</span><br><span class="line">public class UserServiceImpl : UserService</span><br><span class="line">&#123;</span><br><span class="line">    HelloCallback callback;</span><br><span class="line">    public void GetUser(string userName)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(userName);</span><br><span class="line">        OperationContext context = OperationContext.Current;</span><br><span class="line">        callback = context.GetCallbackChannel&lt;HelloCallback&gt;();</span><br><span class="line">        callback.SayHelloworld($&quot;&#123;userName&#125;:hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务端程序时，需要创建服务端的Host主机信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> private static ServiceHost StartUserService()</span><br><span class="line"> &#123;</span><br><span class="line">     var host = new ServiceHost(typeof(UserServiceImpl));</span><br><span class="line">     var binding = new NetTcpBinding(SecurityMode.None);</span><br><span class="line">     host.AddServiceEndpoint(typeof(UserService), binding,</span><br><span class="line">     &quot;net.tcp://localhost:12384/userservice&quot;);</span><br><span class="line"></span><br><span class="line">    host.Open();</span><br><span class="line">    return host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端：</p>
<ul>
<li><p>订定契约HelloCallback 和客户端的契约实现 HelloCallbackImpl 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 回调Hello方法</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">[ServiceContract]</span><br><span class="line">public interface HelloCallback</span><br><span class="line">&#123;</span><br><span class="line">    [OperationContract(IsOneWay = true)]</span><br><span class="line">    void SayHelloworld(string msg);</span><br><span class="line">&#125;</span><br><span class="line">public class HelloCallbackImpl : HelloCallback</span><br><span class="line">&#123;</span><br><span class="line">    public void SayHelloworld(string msg)</span><br><span class="line">    &#123;</span><br><span class="line">    	Console.Write(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ul>
<li><p>订定契约UserService，用以保持和服务端的契约保持一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 用户服务</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">[ServiceContract(CallbackContract = typeof(HelloCallback))]</span><br><span class="line">public interface UserService</span><br><span class="line">&#123;</span><br><span class="line">    [OperationContract(IsOneWay = true)]</span><br><span class="line">    void GetUser(string userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端启动时，连接到服务端。并发送GetUser方法。 </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void GetUser(NetTcpBinding binding)</span><br><span class="line">        &#123;</span><br><span class="line">            var address = new EndpointAddress(&quot;net.tcp://localhost:12384/userservice&quot;);</span><br><span class="line">            var factory =</span><br><span class="line">                new DuplexChannelFactory&lt;UserService&gt;(typeof(HelloCallbackImpl), binding,</span><br><span class="line">                    address);</span><br><span class="line">            var context = new InstanceContext(new HelloCallbackImpl());</span><br><span class="line">            var server = factory.CreateChannel(context);</span><br><span class="line"></span><br><span class="line">            server.GetUser(&quot;zhangssan&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-mirgate-wcf-to-grpc/result.png" alt="image-20191130144237825"></p>
<p>这是一个典型的WCF双工通信的示例，在传统的.NET Framework开发中可能非常常见，但是该如何才能迁移到gRPC服务中呢？</p>
<h4 id="2、gRPC中的代码实现"><a href="#2、gRPC中的代码实现" class="headerlink" title="2、gRPC中的代码实现"></a>2、gRPC中的代码实现</h4><ul>
<li>流程说明</li>
</ul>
<p>gRPC中实现此双工通信，需要使用来自服务端的单向流来实现，但在gRPC中不能直接回调对应的方法，而是在服务端将流返回后，触发对应客户端代码中的方法来实现这个回调的流程。</p>
<p>如图所示： </p>
<p><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-mirgate-wcf-to-grpc/grpc-callback.png" alt="image-20191130214340416"></p>
<ul>
<li><p>代码实现流程：</p>
<p>1、定义 proto 协议文件</p>
<p>请求方法为getUser，并返回流。首先定义服务协议文件，命名为 userService.proto 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option csharp_namespace = &quot;DulpexGrpcDemo&quot;; </span><br><span class="line"></span><br><span class="line">package DulpexGrpcDemo;</span><br><span class="line"></span><br><span class="line">service userService &#123;</span><br><span class="line">  rpc GetUser (HelloRequest) returns (stream HelloReply);  </span><br><span class="line">  rpc GetTest (HelloRequest) returns (HelloReply);</span><br><span class="line">&#125;</span><br><span class="line">message HelloReply&#123;</span><br><span class="line">	string msg=1;</span><br><span class="line">&#125;</span><br><span class="line">message HelloRequest&#123;</span><br><span class="line">	string msg=1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、服务端实现</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceImpl : userService.userServiceBase</span><br><span class="line">    &#123;</span><br><span class="line">        public override async Task GetUser(HelloRequest request, IServerStreamWriter&lt;HelloReply&gt; responseStream, ServerCallContext context)</span><br><span class="line">        &#123;</span><br><span class="line">            await DoSomeThing(request.Msg, (msg) =&gt; &#123; responseStream.WriteAsync(new HelloReply &#123; Msg = $&quot;&#123;msg&#125;:hello&quot; &#125;); &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //处理回调逻辑</span><br><span class="line">        private async Task DoSomeThing(string msg, Action&lt;string&gt; action)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(msg);</span><br><span class="line">            action?.Invoke(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        public override Task&lt;HelloReply&gt; GetTest(HelloRequest request, ServerCallContext context)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(request.Msg);</span><br><span class="line">            return Task.FromResult(new HelloReply &#123; Msg = $&quot;&#123;request.Msg&#125;:hello&quot; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<pre><code>3、客户端实现（需要被调用的方法）</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloCallback</span><br><span class="line">&#123;</span><br><span class="line">    void SayHelloworld(string msg);</span><br><span class="line">&#125;</span><br><span class="line">public class HelloCallbackImpl : HelloCallback</span><br><span class="line">&#123;</span><br><span class="line">   public void SayHelloworld(string msg)</span><br><span class="line">   &#123;</span><br><span class="line">      Console.Write(msg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、用户服务方法的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceImpl</span><br><span class="line"> &#123;</span><br><span class="line">     private userService.userServiceClient userServiceClient;</span><br><span class="line">     private readonly HelloCallback _helloCallback;</span><br><span class="line"></span><br><span class="line">    public UserServiceImpl(userService.userServiceClient serviceClient, HelloCallback helloCallback)</span><br><span class="line">    &#123;</span><br><span class="line">        userServiceClient = serviceClient;</span><br><span class="line">        _helloCallback = helloCallback;</span><br><span class="line">    &#125;</span><br><span class="line">    public async Task GetUser()</span><br><span class="line">    &#123;</span><br><span class="line">        AsyncServerStreamingCall&lt;HelloReply&gt; stream = userServiceClient.GetUser(new HelloRequest &#123; Msg = &quot;张三&quot; &#125;);</span><br><span class="line">        await Helloworld(stream.ResponseStream);</span><br><span class="line">    &#125;</span><br><span class="line">    async Task Helloworld(IAsyncStreamReader&lt;HelloReply&gt; stream)</span><br><span class="line">    &#123;</span><br><span class="line">        await foreach (var update in stream.ReadAllAsync())</span><br><span class="line">        &#123;</span><br><span class="line">            _helloCallback.SayHelloworld(update.Msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、客户端程序的入口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static async Task Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            IServiceCollection servicesCollection = new ServiceCollection();</span><br><span class="line">            IConfiguration configuration = new ConfigurationBuilder()</span><br><span class="line">                        .SetBasePath(Directory.GetCurrentDirectory()).AddJsonFile(&quot;appsettings.json&quot;, true, false).Build();</span><br><span class="line"></span><br><span class="line">        servicesCollection.AddGrpcClient&lt;userService.userServiceClient&gt;(</span><br><span class="line">           o =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                o.Address = new Uri(&quot;https://localhost:5001&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">        servicesCollection.AddSingleton&lt;UserServiceImpl&gt;();</span><br><span class="line">        servicesCollection.AddSingleton&lt;HelloCallback, HelloCallbackImpl&gt;();</span><br><span class="line">        var userServiceImpl = servicesCollection.BuildServiceProvider().GetService&lt;UserServiceImpl&gt;();</span><br><span class="line">        await userServiceImpl.GetUser();</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，从这个示例中，可能会觉得有点奇怪，明明可以使用请求-响应的简单RPC模式，为什么要使用服务端的单向流来实现了？</p>
<p>这种单向流中，客户端无需等待服务端执行方法执行完，而是由服务端完成后续流程后，再回调客户端的方法，使得流程变得简单清晰。</p>
<p>在微软的官方文档（参考文献1）更适合介绍这个迁移过程的单向流的实现，通过实现服务端向客户端推流的形式来介绍，只是方法相对而言实现的逻辑比较多，而鄙人这个示例则剥离了与让我们理解服务端单向流流程无关的部分，使得流程看起来更简单。</p>
<p>参考文献</p>
<p>[1] 官方文档： <a href="https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/migrate-duplex-services" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/migrate-duplex-services</a> </p>
<p>[2] Jon Seeley的官方博客，如何迁移将wcf服务迁移到grpc：<a href="https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/" target="_blank" rel="noopener">https://www.seeleycoder.com/blog/migrating-wcf-to-grpc-netcore/</a> </p>
<p>[3] Jon Seeley的官方博客，如何在.netcore中使用wcf：<a href="https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/" target="_blank" rel="noopener">https://www.seeleycoder.com/blog/using-wcf-with-dotnetcore/</a> </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2019/12/01/技术/简述介绍.NET Core中的依赖注入方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/技术/简述介绍.NET Core中的依赖注入方法/" class="post-title-link" itemprop="url">在.NET  Core/Framework中使用依赖注入框架</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-01 16:28:00" itemprop="dateCreated datePublished" datetime="2019-12-01T16:28:00+08:00">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-12-09 23:06:32" itemprop="dateModified" datetime="2019-12-09T23:06:32+08:00">2019-12-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在-NET-Core-Framework中使用依赖注入框架"><a href="#在-NET-Core-Framework中使用依赖注入框架" class="headerlink" title="在.NET  Core/Framework中使用依赖注入框架"></a>在.NET  Core/Framework中使用依赖注入框架</h1><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>在传统的.NET Framework中通常会使用 new 关键词和静态对象或静态方法作为对象创建的形式，但是由于这两种方式存在以下缺陷：</p>
<h5 id="使用New的方式创建对象的缺陷："><a href="#使用New的方式创建对象的缺陷：" class="headerlink" title="使用New的方式创建对象的缺陷："></a>使用New的方式创建对象的缺陷：</h5><p>1、使用New的方式创建的对象，需要在由GC在不同的位置分别管理生命周期。<br>2、如果在不同的方法中需要创建相同的对象，往往需要用很多个new来进行管理。<br>3、当一个对象有多个子类时，创建的过程更加麻烦。</p>
<h4 id="使用静态变量的缺陷。"><a href="#使用静态变量的缺陷。" class="headerlink" title="使用静态变量的缺陷。"></a>使用静态变量的缺陷。</h4><p>1、静态变量的内存空间是应用程序启动时创建、并在程序消亡时统一释放。<br>2、在高并发场景下，静态变量容易被不同的线程频繁读写，从而成为系统的主要性能瓶颈。</p>
<h2 id="为啥要使用依赖注入"><a href="#为啥要使用依赖注入" class="headerlink" title="为啥要使用依赖注入"></a>为啥要使用依赖注入</h2><p>在.NET Core或.NET FX中目前已经倾向于使用依赖注入框架来对对象的创建过程进行统一管理，这样的好处：<br>1、封装了对象的创建过程，可以实现对象创建过程和内存管理过程的一致性，<br>2、如果一个对象有多个实现，也容易使用依赖注入对象对其进行拆分。<br>3、提供统一的对象生命周期管理。</p>
<h2 id="依赖注入的生命周期"><a href="#依赖注入的生命周期" class="headerlink" title="依赖注入的生命周期"></a>依赖注入的生命周期</h2><p>目前在.NET Core（.NET FX也有）中提供了3种依赖注入的生命周期，分别是：<br>1、单例的生命周期SingleTon。每次从同根容器中（同根 IServiceProvider）获取的时候都是同一个实例，类似于静态变量。主要用来存储系统中需要保持唯一一份的对象<br>2、瞬时的生命周期Transient。每次从容器 （IServiceProvider）中获取的时候都是一个新的实例，可以用于 控制台程序。<br>3、作用域的生命周期Scoped。每次从同一个容器中获取的实例是相同的。往往用于ASP.NET Core 网站。<br>使用依赖注入的方式实现对象的创建虽然会给程序带来一点不便利，但是容易实现程序的耦合度降低，更有利于程序未来的横向扩展，也逐渐成为ASP.NET开发（不仅仅是.NET Core）的的一种最佳实践。</p>
<h2 id="依赖注入的使用"><a href="#依赖注入的使用" class="headerlink" title="依赖注入的使用"></a>依赖注入的使用</h2><p>目前.NET中的依赖注入组件是基于.NET Strandard（标准库）进行开发的无其他依赖项的组件，能够被基于标准库的各种.NET技术方案所实现。<br>主要分为两个步骤，<br>1：初始化时，将对象注册到依赖注入组件中；例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceCollection.AddScoped&lt;DBContext&gt;();</span><br></pre></td></tr></table></figure>

<p>2：对象使用时，从依赖注入组件中取出对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var dbContext = MyServiceProvider.GetService&lt;DBContext&gt;();</span><br></pre></td></tr></table></figure>

<p>从依赖注入组件中取出对象的过程，往往会伴随着对象创建的过程，即在依赖注入框架内部，封装了原来与 New 一致的流程。</p>
<p>如果一个对象如果需要引用的对象已经被注册到依赖注入组件中，则无需使用 GetService 方法从依赖注入组件中取出对象，依赖注入框架在创建对象时，也会连带着将其他与之相关的对象一起创建。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>例如：<br>1、在示例代码中，设置 DBContext 为 Scoped </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceCollection.AddScoped&lt;DBContext&gt;();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">static ServiceProvider MyServiceProvider;</span><br><span class="line">       static void Main(string[] args)</span><br><span class="line">       &#123;</span><br><span class="line">           IServiceCollection serviceCollection = new ServiceCollection();</span><br><span class="line">           serviceCollection.UseDBContext();</span><br><span class="line">           serviceCollection.UseDBService();</span><br><span class="line">           serviceCollection.UseAppService();</span><br><span class="line">           MyServiceProvider = serviceCollection.BuildServiceProvider();</span><br><span class="line">           var dbContext = MyServiceProvider.GetService&lt;DBContext&gt;();</span><br><span class="line">           dbContext.DBConfig = &quot;127.0.0.1&quot;;</span><br><span class="line">           TestSingleTon();</span><br><span class="line">           TestTransient();</span><br><span class="line">           Console.ReadKey();</span><br><span class="line">       &#125;</span><br><span class="line">       static void TestSingleTon()</span><br><span class="line">       &#123;</span><br><span class="line">           for (int i = 0; i &lt; 5; i++)</span><br><span class="line">           &#123;</span><br><span class="line">               var task = new Task(() =&gt;</span><br><span class="line">               &#123; </span><br><span class="line">                   var dbService = MyServiceProvider.GetService&lt;UserDbService&gt;();</span><br><span class="line">                   Console.WriteLine(dbService.GetDBConfig());</span><br><span class="line">                   Console.WriteLine(&quot;设置用户名为张三&quot;);</span><br><span class="line">                   dbService.UserName = &quot;张三&quot; + i;</span><br><span class="line">               &#125;);</span><br><span class="line">               task.Wait(100);</span><br><span class="line">               task.Start();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       static void TestTransient()</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           for (int i = 0; i &lt; 5; i++)</span><br><span class="line">           &#123;</span><br><span class="line">               var task = new Task(() =&gt;</span><br><span class="line">               &#123;</span><br><span class="line">                   var userAppService = MyServiceProvider.GetService&lt;UserAppService&gt;();</span><br><span class="line">                   Console.WriteLine($&quot;获取数据库中的用户名:&#123;userAppService.GetDBUserName()&#125;&quot;);</span><br><span class="line">               &#125;);</span><br><span class="line">               task.Wait(200);</span><br><span class="line">               task.Start();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>那么在创建 UserDbService 对象时，依赖注入框架会自动创建dbContext对象，并将其注入到 UserDbService中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public UserDbService(DBContext dBContext)</span><br></pre></td></tr></table></figure>

<p>这样就封装了原来的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IUserDBService dbService=new UserDBService(new DBContext());</span><br></pre></td></tr></table></figure>

<p>的代码过程，弥补了调用者需要与UserDBService 高度耦合的缺陷。</p>
<h2 id="值得注意的是："><a href="#值得注意的是：" class="headerlink" title="值得注意的是："></a>值得注意的是：</h2><p>1、在.NET Core（.NET Framework) 控制台中，需要手动创建对象IServiceCollection，并创建一个静态的 ServiceProvider 对象，由这个对象来实现对象的加载。<br>2、在.NET Core 网站项目中，由WebHost管理的生命周期，会创建一个统一的 IServiceCollection和 ServiceProvider 对象，无需再单独创建这个ServiceProvider. </p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>在示例代码中，提供了一个DIExtension的静态类，并定义了三个注册对象的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static IServiceCollection UseDBContext(this IServiceCollection serviceCollection)</span><br><span class="line">        &#123;</span><br><span class="line">            serviceCollection.AddScoped&lt;DBContext&gt;();</span><br><span class="line">            return serviceCollection;</span><br><span class="line">        &#125;</span><br><span class="line">        public static IServiceCollection UseDBService(this IServiceCollection serviceCollection)</span><br><span class="line">        &#123;</span><br><span class="line">            serviceCollection.AddSingleton&lt;UserDbService&gt;();</span><br><span class="line">            return serviceCollection;</span><br><span class="line">        &#125;</span><br><span class="line">        public static IServiceCollection UseAppService(this IServiceCollection serviceCollection)</span><br><span class="line">        &#123;</span><br><span class="line">            serviceCollection.AddTransient&lt;UserAppService&gt;();</span><br><span class="line">            return serviceCollection;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2019/12/01/随笔/网易事件背后众生相/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/随笔/网易事件背后众生相/" class="post-title-link" itemprop="url">网易事件，芸芸众生，相煎何急</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-01 16:28:00 / Modified: 18:56:20" itemprop="dateCreated datePublished" datetime="2019-12-01T16:28:00+08:00">2019-12-01</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随笔/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>十一月初拖家带口去了上海，到了著名的城隍庙参观，无意中看到了一个仅出现在历史书上的古老物件“西洋镜”，仿佛跨越百年，来到那个如裹脚布般冗长而乏味的古老年代，看到了一群有一群卑微的小民在生活的裹挟之下，对外界充满兴趣，并透过一个西洋镜来看看外面的世界。对于古老时代的他们而言，西洋镜里的一切都充满稀奇。</p>
<p><img src="https://uploader.shimo.im/f/lsExqdP5K40rAqM2.png!thumbnail" alt="图片"></p>
<p>有时候，今天的互联网就像西洋镜。</p>
<p>今天，制度的优越性让我们取得了经济上的飞速成长，互联网技术拉近了彼此的距离，也容易打破隔阂，原来或许发生在与自己无关世界的事情，总是很容易的就让我们产生同理心。</p>
<p><img src="https://uploader.shimo.im/f/eNIdyrdU3M4PbZKA.png!thumbnail" alt="图片"></p>
<p>《前网不易员工发文称患病后遭遇公司“暴力裁员”》引起了轩然大波，随着网不易拿出了更多的论点，也让事件掀起了小高潮，我想换一个角度来考虑一下问题，分析一下在事件中那些出现了的，或没出现的人群。</p>
<h1 id="主角："><a href="#主角：" class="headerlink" title="主角："></a>主角：</h1><p>主角J是一位90后，拥有上海交大的学历，是职场上最走俏的优秀资源。而且业余运营了自己的公众号，文笔朴实简练流畅自然。如此年轻的他，也是企业最受欢迎的优秀成员，假以时日，如果能够善终，一定能谱写一篇非常不错的故事，让大家看到90后是如何快速成长为企业的栋梁人才，为公司创造无穷价值。然而，由于一场身体上的变故，让他的职场之路遇到了困境，而且扩展性心肌炎病症非常严重，最终必须面临换心的痛苦。</p>
<p>人生之痛，莫过于让白发人送黑发人，难道要让他的父母成为失独老人么。扼腕叹息。</p>
<h1 id="主管和人事："><a href="#主管和人事：" class="headerlink" title="主管和人事："></a>主管和人事：</h1><p>在这个事件中，作为第一当事人的主管自然而然会成为焦点，甚至“网红”，即便他不想如此。</p>
<p>当然，我们都知道，他的谈话是代表公司谈话的，所以他以为他的立场也同样代表了公司立场，嗯，那一刻他一定以为他是三石附体，公司要裁员，是裁掉那些劳动生产力低或者如大东子说的“性价比低”的员工，哪怕他生病了，也应该毫不犹豫的挥起屠刀，不能放过任何一个不能跟公司共同奋斗的人。于是他这么做了，并且他成功了。</p>
<p>而人力资源部门显然是这件事情背后的幕后真凶，公司说要裁减人员，而作为裁员的直接被考核部门，自然而然要冲在最前面。</p>
<p>在职场中，许多人都信奉这样的哲学：大家都是成年人，人性是什么重要么？难道还有什么比KPI更重要的么？</p>
<p><img src="https://uploader.shimo.im/f/4q8Af3sOgGsHZibc.png!thumbnail" alt="图片"></p>
<h1 id="三石兄："><a href="#三石兄：" class="headerlink" title="三石兄："></a>三石兄：</h1><p>说实话，网不易的发展历史对于80后的我来说一度是一个非常古老的故事，就像昔日《硅谷之火》一般，指引着我走上了IT这条道路，并成为一位普通码农。但是吃到了互联网时代的红利，却在移动互联网时代开始逐渐走下坡路了。</p>
<p>而且网不易和微软中国、金山一样被成为中国互联网的黄埔军校，从网不易毕业的许多创业者，他们创造出许多优秀的产品，也深深的影响着我们。</p>
<p>当然，黄埔军校其实对于公司本身来说，并非是个非常好听的名词，因为他代表着公司能够培养人，但是却不能留住人。用《浪潮之巅》中的一句话来说，要看一家公司是好还是坏，就看是优秀的人才流入还是流出。每一个优秀的人员流失，对一家大公司来说看起来没什么，但是往往意味着公司的吸引力在逐渐下降。</p>
<p>经济学中有一个“劣币驱逐良币”的现象，对于一家无法维持积极发展的企业，也往往会面临这样的现象。优秀的人才流失之后，往往留下来的是最能体会企业文化精神、并能在肉体上跟公司在一起的人。</p>
<p>嗯，肉体上跟公司在一起的人似乎更能理解企业管理的规则，并愿意花时间熬工时。年初马云说996是福报时，大家都在吐槽说资本家的本质彰显无疑，但是实际上还有更多IT公司其实是维持着更长的小时，每天只上9个小时，确实是一种福报啊。好吧，对于大部分公司而言，加班，其实是为了靠苦劳来弥补管理层甚至老板吹过的牛或能力上的不足吧。</p>
<p>三石兄似乎已经退居二线了，这也意味着，企业文化精神已经在逐渐衰微，公司已经在“大公司病”这条路上越病越深。</p>
<p>在互联网寒冬的今天，许多中小企业都面临着裁员的艰难抉择，也许他们没办法经营，但为了给员工多一条生路，往往也会想办法给他们一些补偿。当然有一些企业确实拿不出钱，但是他们也会给出承诺。</p>
<p>但网不易的吃相会不会太难看了？连网不易这样的大公司都不给补偿，而是以这么难看的吃相挥舞屠刀，肆意驱赶那些为公司发展做出巨大贡献的优秀员工？那其他的公司还有没有更加恶劣的手段来赶人呢？招人的时候不惜一切代价，赶人的时候，也同样不惜一切代价?企业的商誉难道如此廉价？</p>
<p>出生90后的主角身患需要换心的重病，而大概同样90后的网不易，也需要三石兄出面，给公司来一场换心手术吧。</p>
<h1 id="工会"><a href="#工会" class="headerlink" title="工会"></a>工会</h1><p>在我的同学群讨论这个事情时，突然有人抛出了一个问题：工会去哪里了。大概大家都会觉得莫名其妙。虽然在有一部法律《工会法》明确了工会的职能是维系党和人民群众的关系、并维护广大工人阶级的基本利益，而且大部分公司似乎都设立了所谓的工会，但是真的有工会么？</p>
<p>并非如此，工会代表老板的利益，或者说是管理层的利益，其目前的主要职能大概仅仅停留在“收会费、搞茶话会”。工会究竟还有什么用？</p>
<p>期待全国总工会发声。</p>
<h1 id="劳动部门"><a href="#劳动部门" class="headerlink" title="劳动部门"></a>劳动部门</h1><p>对于大部分普通群众来说，跟劳动部门似乎没有一丁点关系。</p>
<p>虽然跟公司签署了劳动合同，看似应该受到劳动法的保护，但是当发生劳动纠纷，去劳动仲裁大队申请仲裁时，政府部门的工作方式往往会让人望而生畏。于是宁可自己吃点亏，也不愿意走那么冗长的劳动仲裁流程，毕竟搞不好就需要花大半年的时间，不定期就会接到劳动部门的电话让当事人去仲裁庭处理案子，对于个人来说确实是有点吃不消。</p>
<p>期待劳动部门发声。</p>
<p>我还记得多少年前，农民工的问题引起了政府部门的多次关注，连续好几年的中央一号文件都是关注农民工问题。IT民工呢？毕竟IT产业工人也算是个人所得税的主要纳税群体，难道就不应该引起更多关注？有关部门不要只想着GDP、招商引资、课税，而不想着如何维护劳动者的利益啊。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>城隍庙的西洋镜，看透百年，看透世间百态。</p>
<p>网不易裁员事件，透过这个事件，我们看到了来自互联网时代的独特魅力，国民早已不再停留在鲁迅书中说过的矇昧和无知的区区看客，而是掌握了更多的方法，足以产生更加深远的影响力。</p>
<p>使其生、使其亡。摧枯拉朽，谁能阻挡？</p>
<p>时代在进步，那些该破灭的就让他破灭吧。</p>
<p>由于时间仓促，胡言乱语，还请诸君一笑。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">溪源</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">65</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">categories</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.cnblogs.com/xiyuanmore" title="博客园 &rarr; https://www.cnblogs.com/xiyuanmore" rel="noopener" target="_blank"><i class="fa fa-fw fa-博客园"></i>博客园</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/farway000" title="CSDN &rarr; https://blog.csdn.net/farway000" rel="noopener" target="_blank"><i class="fa fa-fw fa-CSDN"></i>CSDN</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">溪源</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.2</div>
#<div><a href="http://www.beian.miit.gov.cn/">ICP备案号:湘ICP备19001531号-2</a></div>



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
