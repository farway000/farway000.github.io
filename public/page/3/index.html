<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="xiyuan技术圈">
<meta property="og:url" content="http://techq.xyz/page/3/index.html">
<meta property="og:site_name" content="xiyuan技术圈">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xiyuan技术圈">





  
  
  <link rel="canonical" href="http://techq.xyz/page/3/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>xiyuan技术圈</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiyuan技术圈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">溪源的技术博客，技术的不断进取之路</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-技术">

    
    
    
      
    

    

    <a href="/categories/技术/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>技术</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-随笔">

    
    
    
      
    

    

    <a href="/categories/随笔/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>随笔</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-读书">

    
    
    
      
    

    

    <a href="/categories/读书/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>读书</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-管理">

    
    
    
      
    

    

    <a href="/categories/管理/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>管理</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-归档">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archives"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/04/10/随笔/how-to-find-millon-in-changsha-programmer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/04/10/随笔/how-to-find-millon-in-changsha-programmer/" class="post-title-link" itemprop="url">长沙IT技术圈的百万大佬，何处寻觅？</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-04-10 09:10:00 / Modified: 09:09:12" itemprop="dateCreated datePublished" datetime="2020-04-10T09:10:00+08:00">2020-04-10</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随笔/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>不知不觉，IT技术圈开始流传起“百万年薪”的故事，有人问我，长沙有百万大佬么？其实我也不知道。</p>
<h1 id="一-背景"><a href="#一-背景" class="headerlink" title="一  背景"></a>一  背景</h1><p>长沙自古以来就是文风鼎盛之地，在今天也同样如此。</p>
<p>目前长沙有211、985、一本、二本等本科院校数十所，大专以上的院校上百所.每年从长沙毕业，怀揣梦想选择去北上广深杭奋斗的互联网从业人员不下数万人，其中从事技术岗位的（例如开发、测试、运维等）或许是占比最大的部分。</p>
<p>从某种意义上来说，湖南技术人可能真的撑起了全国互联网的半边天。（当然，这样的说法没有统计数据为准，笔者说了不算）。</p>
<p>不过，一直以来，由于沿海地区落户政策的严格、购房和居家生活的成本高，使得许多离开湖南的开发者越来越倾向于选择回到长沙寻找适合自己的工作。</p>
<p>他们都能在长沙找到合适的工作么？他们能成为“百万大佬”么？</p>
<h1 id="二-几个故事"><a href="#二-几个故事" class="headerlink" title="二 几个故事"></a>二 几个故事</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>老Q是我的同学，大学毕业后，我回了家乡长沙，他则选择去深圳发展。在毕业前的一次吃饭过程中，他说打算先去深圳看看，过几年在深圳混不下去了，再回长沙。</p>
<p>2015年上半年，他的同学邀请他创业，他果断的把在酷派的工作辞了，回到了长沙。但经过半年的折腾，他的创业梦想最终还是“黄”了，又临近年光，他决定留在长沙找工作。</p>
<p>由于他在酷派当时主要从事手机基站测试的相关领域工作，而在长沙实际上几乎没有对应的工作，除了软件测试，就是纯粹的硬件测试。而由于他属于转行的性质，最终工资..更是相当微薄。最终他还是离开了长沙，回到了深圳。</p>
<p>一晃又是五年，当我在跟他交流是否有兴趣回长沙时，他一脸苦涩的说，就算想回，估计也不会在从事IT相关的行业了。</p>
<p>“当时以为混不下去就回长沙，其实长沙反而比北上广深更难混下去。”</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>老L是2014年前后回的长沙。</p>
<p>老L之前在广州，那是一家还不错的上市公司，他在这家公司也算是中层管理者，但考虑到在广州买房不太现实，而且长期离乡背井的工作，也让他对家乡产生了深深的眷恋之情，再加上他的对象也希望他回长沙发展，最终他抛弃了那份月收入破2w的工作，回到了长沙。</p>
<p>回到长沙找工作之前，他找同学打听了长沙当时的开发者工资水平，他的同学告诉他，像这样七八年经验的.NET开发者，大概顶尖水平应该是万把块钱。</p>
<p>老L是一位务实的开发者，他想到自己在广州那家公司，实际上每天投入到软件开发工作中的时间，其实只有不到3个小时，要与专业从事技术开发、天天浸淫其道的高手相比，还存在巨大的差距。</p>
<p>既然顶尖水平才一万，那自己显然只能顶别人的六成，开六千肯定没问题。</p>
<p>结果面试时，公司给他开了8k，顿时他就很欣喜。</p>
<p>虽然他后来又离开了这家公司，但他还是给予了这家公司很高的评价：这充分证明，其实长沙的公司非常识货。</p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>老C也是差不多同期回的长沙，当时他已经是一家大型互联网公司的中层管理者。</p>
<p>（这家公司在他离开之后，迎来了一波飞速发展，引入了好几十个华为毕业的员工后，使得公司的整体技术水平和能力都有了巨大的飞跃，在2017年前后成功上市，之前跟他同期加入公司的同事、以及他在公司时招聘的人才，几乎都成为公司的核心骨干或甚至是事业部、分公司总经理。）</p>
<p>老C回到长沙的原因，是因为他存够了能够在深圳付首付款的钱，他的家人却硬是说服他拿这个钱在长沙买房。</p>
<p>当然，同样的钱，在深圳只能买偏僻城乡结合部的小两居，而回长沙则可以买中心地带，地铁口，公园口的120平三室一厅。</p>
<p>他拿着这个钱之后，回来看了一圈房子，发现居然可以选择的余地这么多，而且还这么舒服的，当时就决定回长沙定居，他很快就把深圳的工作辞了，然后回到了长沙找工作。</p>
<p>当他回到长沙找工作之后，得益于一个机会，有幸找到了一个非常有钱的老板，这位老板拉了一个规模还算大的团队，也非常重视像他这样优秀的管理者，以大概15k或更高的薪酬聘用了他。这在当时的长沙已经算非常不错的薪资，使得他能够维持相对高的生活条件。</p>
<p>但公司的资金很快就烧完了，公司解散后，他被迫回到职场求职。</p>
<p>他的心理预算是15k，但在长沙能够开得起15k的公司实在太少，而且这些公司对技术要求非常高，由于他平时工作中对技术的深度钻研有限，最终都被拒之门外。</p>
<p>还好得益于他在HIS领域扎实的行业经验+原公司不错的背景，使得他能够在一家公立医院找到还算可以的工作。</p>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>当然，并非所有的开发者回到长沙都会面临工资砍一截、甚至减半的情况，我的身边也不乏一些开发者，从北上广深杭回到长沙之后，还能找到与原来公司工资差不多的工作、甚至还有的能找到超过在深圳工资的工作。</p>
<p>那究竟是什么原因决定了长沙开发者的薪资水平，难道真的是长沙的互联网水平发展太低了么？</p>
<h1 id="三-长沙的开发者工资有多高？"><a href="#三-长沙的开发者工资有多高？" class="headerlink" title="三 长沙的开发者工资有多高？"></a>三 长沙的开发者工资有多高？</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h2><p>在长沙有哪些公司的工资最高？</p>
<p>首先还是得排除BAT公司和大型互联网公司也开始在长沙成立相应的分支机构或分公司、子公司。这些公司在长沙也好、深圳也好，其实工资是按照职级来，与城市关系不大。我的一位堂叔在恒大集团（虽然远离IT圈子），但他的工资还不错，据说在长沙一年的收入可以买一套房。。所以。。你懂的，如果你想回长沙，最好的办法就是选择加入BAT，然后公派回老家发展，大概这才是真正的“衣锦还乡”。</p>
<p>其次首屈一指的大概是芒果TV。据悉..芒果TV的前台，每个月虽然工资不高，才8k，但每年能拿到手的年终奖也超过了16万。。而普通开发者，一般每年能够拿到手的收入是20w以上。</p>
<p>稍微牛逼一点的开发者，其实工资并不亚于北上广深的同类型公司。</p>
<p>关键是芒果TV朝九晚五，不用加班，工资还挺轻松，而且公司还挺不错，说出去挺有自豪感。</p>
<p>我一位大学同学表示，他老公曾经在爱奇艺担任运维工程师，回长沙之后去了芒果TV，工资和爱奇艺齐平，工作压力少了一半。</p>
<p><img src="https://uploader.shimo.im/f/sjbRZaGv7hw4svjV.png!thumbnail" alt="图片"></p>
<h2 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h2><p>其次，大概这张图上的公司，工资都还可以。。。但，离北上广深的同等排名的公司相比，应该还是差距比较大。</p>
<p>此处还需点出几家公司，建议大家多投简历，例如我所了解的御泥坊、问卷星、兴盛优选、蜜獾信息等公司，他们对人才还是挺重视的，工资也还挺高的，值得大家关注关注。。</p>
<p>当然，与北上广深的大公司比起来，嗯，还是别比了。</p>
<p>另外，内推可能比社招工资高，如果你是大佬，想走社招加入这几家公司，估计会被压一些价。。。</p>
<h2 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h2><p>那长沙的开发者普遍工资大概是什么水平？或许不同的语言体系有一定的不同，例如后端，一位顶尖的后端工程师，大概是30-50k。</p>
<p>当然，目前我还没接触到突破50k的开发者。我接触到突破30k的开发者。。对不起，他们已经不是开发者了，基本上都是公司管理层、甚至在不少公司，甚至是高管级别。</p>
<p>而资深开发者，基本上是在20-40k左右；高级开发者，应该是12-25k左右，中级开发者，大概是8-15k左右，初级开发者，大概是4-8k左右。在这一点上，Java和.NET或其他语言，其实区别不大。</p>
<h2 id="4-1"><a href="#4-1" class="headerlink" title="4"></a>4</h2><p>当然，我的圈层束缚了我的想象力，显然还有更高收入的群体。。在我了解的圈层。</p>
<p>例如芒果TV。。一个高级运维就能突破30k，而其他公司，不管你k8s\openstack玩得多</p>
<p>溜，20k已经是天花板了。</p>
<p>圈层之外。。大概年薪50万到80万，其实也是长沙一些大型互联网公司技术高管的天花板。其实有的大公司高管，也没能突破40k，不过既然已经成为高管了，估计他们已经不靠工资，更多的是靠公司的业绩提成或股份分红吧。</p>
<p><em>5</em></p>
<p>对不起，所有初级、中级、高级、资深开发者，并不是按年资来衡量的，而是看真实实力来衡量。你不能说你工作十年，就一定是高级开发者。例如，如果你做后端开发，连gc、领域驱动设计、分布式缓存、NoSQL都没听过，可能你确实不太适合寻找跨行业的职位。。</p>
<p>然而，事实上大多数开发者都是这么自以为的。我也面过一些工作十年的开发者，他们在特定的业务领域，或许是业务大佬，但一旦离开对应的领域求职，几乎找不到合适的工作。例如，我曾经面过一些做建筑信息化的开发者，工作也有十年多，但一旦问到涉及并发、缓存、gc等问题，他们基本上都没听过。与这类似的还有从事制造业信息化的开发者，可能连.NET技术中的一些新特性，例如async/await都可能没听过。就像搞java的，连稍微新一点的语法都没用过，又该如何被称为“高级Java工程师”。</p>
<p>作为开发者，懂基础概念和术语还是很重要的，不过，长沙的技术圈子，似乎还没形成这样的氛围。面试时，有时不能问技术问题。</p>
<p>当然，退一万不讲，公司不怎么地，居然还好意思问技术问题，不就是“拥有造核弹的心，却只有拧螺丝钉的命么？”。。。</p>
<h1 id="四-我技术牛逼，为何就不能拿高工资？"><a href="#四-我技术牛逼，为何就不能拿高工资？" class="headerlink" title="四  我技术牛逼，为何就不能拿高工资？"></a>四  我技术牛逼，为何就不能拿高工资？</h1><h2 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h2><p>我已经见过不下十位优秀开发者，他们的岗位基本上都是技术经理、技术总监、架构师，而待遇要求基本上都是18k以上。结果他们的求职期无一例外，都达到了一个月以上，最终不得不一点点把自己的心理预期进一步降低，进一步降低，然后在15k左右徘徊。当然，这些都是.NET开发者，如果是Java开发者，可能多那么几千块钱。。（不过Java的竞争更激烈）</p>
<p>这是由于他们能力不行造成的么？绝非如此，我相信，他们在没回长沙之前，公司也是好平台、他们能够成为公司的核心骨干，也证明他们非常优秀。</p>
<h2 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h2><p>但是。。长沙确实是互联网的荒漠，能够给开发者带来更加丰厚收入、自豪感的公司，实在是太少太少。前面提到的那些技术管理层都是非常优秀的跨职能人才，这让他们能够在技术岗位快速进步的同时，还能很快的成为公司的管理者，给公司的发展带来很大的帮助。只是从他们离开公司开始，就无法以对应的title寻找工作，只能寻找技术领域的高级开发者。</p>
<p>而市场上管理岗位显然少于技术岗位，且不说竞争是否激烈，更何况现在的技术岗位对于技能的要求本身就已经逐渐提高了。当你踏上管理者的岗位开始，一天又能维持几个小时的编码时间呢？你真的会持续刷新自己的技术，保持技术的持久战斗力么？</p>
<p>或许。其实你内心，其实已经不再重视“编码”这个硬技能了吧。</p>
<p>另外，依据“彼得原理”，大部分公司其实找的是当前岗位的胜任者，而不是超出对应岗位的“进阶者”。如果你的公司天花板非常低，那你又如何能在那些有高天花板的公司找到高职级的工作。即便有，或许也很难胜任吧。</p>
<h2 id="4-2"><a href="#4-2" class="headerlink" title="4"></a>4</h2><p>长沙的软件公司或开发者技术不行么？这也是个悖论。文无第一，武无第二。工资不行不代表技术不行。 许多长沙的公司虽然公司效益远远比不上BAT大公司，一年净收入突破几千万就算是个不错的公司了，但这不能说明公司技术不行。恰好相反，一波一波回长沙的开发者，总会有人一点点把长沙的技术水平逐渐提高。</p>
<p>技术水平的高低没有评判标准，许多大佬技术牛逼，但脱离了公司的平台效应和团队战斗力，单兵作战能力可能并不强。</p>
<p>相比之下，许多长沙的开发者平时下班之后就是学习技术，交流技术，一天八小时撸码，还有四小时学习，这样的开发者技术还能差到哪里去。</p>
<p>例如前面提到的蜜獾信息，就形成了这样一群人。而且公司待遇不错，技术氛围也很不错，公司管理层也重视技术和企业文化氛围，早就把“不加班，不写过时的文档，每两周发布一个版本的敏捷发布”玩的挺顺利的，非常适合大家关注。</p>
<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>当然，限于体量原因，许多技术含量较高的场景，长沙还真没有。我一位朋友吐槽，长沙的运维人员，还停留在最多百台服务器运维的能力，几乎相当于他2015年的水平。现在在长沙，能够玩得起自动化测试的公司，都还算不错的公司，所以如果你是拥有自动化测试经验的测试工程师，其实也还是有很多机会。</p>
<p>但那些大公司才有的细分岗位，例如之前说的基站测试，还有咨询师，技术写作专家，配置管理工程师，甚至是python大数据分析师，长沙大概还几乎没有。长沙市场上python相关的职位还非常少，go语言的也并不多。。。</p>
<h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>长沙的公司为什么不愿意花高工资聘请大牛呢？其实这也是一些回长沙的求职者向我吐槽的。也许他们的言下之意是：为啥不聘请“像自己这样的大牛”呢？</p>
<p>好吧，其实长沙的IT圈也舍得花力气聘请大牛，像已经成为社区电商行业的领跑者的兴盛优选，公司本身已经有不少大牛，而且也愿意用月薪35到60以上的标准聘请阿里巴巴p7以上的开发者，考虑到长沙的物价水平，其实已经挺不错了。</p>
<p><em>如果你是真大牛。。我可以帮你推荐一番。</em></p>
<p>总之，长沙的IT公司并非不舍得花高工资聘请大佬，而是因为。。。还没遇到真正牛逼的大佬。</p>
<h1 id="五-高工资是怎么来的？"><a href="#五-高工资是怎么来的？" class="headerlink" title="五 高工资是怎么来的？"></a>五 高工资是怎么来的？</h1><h2 id="1-3"><a href="#1-3" class="headerlink" title="1"></a>1</h2><p>谈起高工资，我们得想想北上广深那么多百万年薪的程序员，他们的高工资是怎么来的？</p>
<p>在互联网飞速发展的今天，靠近资本的北上广深杭已经成为风口浪尖，许多与互联网概念相关的企业都跟着业绩腾飞，员工的薪资也跟着水涨船高，此处就不需要举例子了，毕竟BAT那么多家公司的优秀开发者们，用他们的身价证明，自己的一份努力，完全可以代表中国互联网开发者的顶尖收入水平。</p>
<p>但。。在这些行业巨头之外，还有许多开发者，其实依然处于温饱线的边缘，或稍微比温饱线好那么一点，财务自由？35岁退休？年入百万？大部分人别想了。是由于选择大于努力造成的？还是由于平时温水煮青蛙，不够努力造成的？其实基本上都不是的。事实上，许多开发者，例如一些外包或制造业外包的开发者，他们的条件远比BAT公司更艰苦，每周的工作时长更高，但拿的收入水平，却仅仅只是BAT开发者的零头，甚至不如。</p>
<p>这大概有点像拿非洲人民和美国资本家对比。用经济学术语来说。。就是“剪刀差”（我打算称为工资剪刀差）。</p>
<p><img src="https://uploader.shimo.im/f/3jlkvgUiFD89FM37.png!thumbnail" alt="图片"></p>
<p>互联网企业员工的高收入，其实来源于互联网企业本身对于资本的凝聚力和投资者对于未来的期望所带来的溢价。而有许多互联网公司其实本身已经不需要靠利润来发工资，仅仅依靠“市梦率”，就能维持公司的飞速发展，让员工获得足够的福利。</p>
<h2 id="2-3"><a href="#2-3" class="headerlink" title="2"></a>2</h2><p>而长沙的互联网公司并不多，大部分都是所谓“行业互联网”，虽然沾上了“互联网”的名，却没有互联网的命。</p>
<p>“行业互联网”企业由于发展较为缓慢、或者已经较为稳定，事实上已经不太可能从投资者市场获得更高，由于只能靠利润来给员工发工资。</p>
<p>所以，员工的工资包含了公司获得的投资，公司的利润，公司的品牌溢价、个人的品牌溢价和个人的核心竞争力，个人的机遇。如果你核心竞争力强，让那些优秀的公司能够更早的认识你，自然而然也很容易成为职场上的香饽饽。</p>
<h2 id="3-2"><a href="#3-2" class="headerlink" title="3"></a>3</h2><p>如果品牌竞争力一般，该如何寻找合适自己的工作呢？</p>
<p><img src="https://uploader.shimo.im/f/CNVf9Df1pBrsO07B.png!thumbnail" alt="图片"></p>
<p>认清形势，放弃幻想。回归现实，别妄图拿那么高的工资。找一个自己感兴趣的行业、公司，踏踏实实干下去，通过自己的努力，为公司创造更大的价值，自然而然，你就获得了更好的发展。</p>
<p>当你回到长沙，就别在幻想通过上班来获得“暴富”了。长沙这样的土壤，其实更像普通人凭借自己双手改变家庭命运的跳板。</p>
<p>例如，校管家，就是这样的公司，老板们勤勤恳恳、踏踏实实，靠自己的努力，创造了一家优秀的公司，并成功的获得了投资者们的不断关注。在长沙，这样的公司不下数十家。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>与其他城市相比，长沙的IT业态或许更趋于“务实”“勤勉”“实干”“坚持”。</p>
<p>长沙不是互联网人淘金的热土，也不是一夜暴富者的摇篮。</p>
<p>在沿海地区互联网的热闹喧嚣之外，长沙其实就是一个这样静静发展、一声不响就创造出不错佳绩的“小而美”的现代化城市。</p>
<p>在长沙，也许你见不到太多“英雄”，却充满了各种各样、努力付出、细心耕耘、用三年、五年或更长的时间来用心助力公司成长的“普通人”。</p>
<p>显然，这个世界，既要“冒险家”“野心家”“成功学”，同样也需要“普通人”。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/04/09/技术/try-to-find-high-cpu-usage-in-netcore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/04/09/技术/try-to-find-high-cpu-usage-in-netcore/" class="post-title-link" itemprop="url">在.NET应用程序中分析CPU使用率过高的问题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-04-09 21:24:00 / Modified: 21:38:26" itemprop="dateCreated datePublished" datetime="2020-04-09T21:24:00+08:00">2020-04-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>作者:胡安·帕勃罗·希达，JUAN PABLO SCIDA是一位软件架构师，在软件开发方面拥有10多年的经验。他是经过认证的.NET和Java开发人员。在过去的几年中，他还热衷于使用Node.js，MongoDB和Erlang。</p>
<p>原文来自：<a href="https://www.toptal.com/dot-net/hunting-high-cpu-usage-in-dot-net" target="_blank" rel="noopener">https://www.toptal.com/dot-net/hunting-high-cpu-usage-in-dot-net</a></p>
<p>软件开发可能是一个非常复杂的过程。作为开发人员，我们需要考虑很多不同的变量。有些不在我们的控制之下，有些在实际代码执行时对我们来说是未知的，有些则由我们直接控制。 <a href="https://www.toptal.com/dot-net" target="_blank" rel="noopener">.NET开发人员</a>也毫不例外。</p>
<p>考虑到这样的现实情况，当我们在受控环境中工作时，事情通常会按计划进行。假设就是我们的开发机器或我们可以完全访问的集成环境。我们可以使用工具来分析影响我们的代码和软件的不同变量。我们也不必处理服务器的繁重负载，也不必处理并发用户尝试同时执行相同操作的情况。</p>
<p>在可描述和安全的情况下，我们的代码通常可以正常工作，但是在生产环境下，如果处于过度负载或其他一些外部因素的影响，可能会发生意外问题。生产环境的软件性能很难分析。在大多数情况下，我们必须在理论上处理潜在的问题：我们知道可能会发生问题，但无法测试。这就是为什么我们需要以我们所用语言的最佳实践和文档为基础进行开发，并避免<a href="https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make" target="_blank" rel="noopener">常见错误</a>。</p>
<p>如前所述，当软件上线时，可能会出错，并且代码可能会以我们未计划的方式开始执行。当我们不得不处理问题而又无法调试或确定发生了什么情况时，我们可能会遇到这种情况。在这种情况下我们该怎么办？</p>
<p><img src="https://uploader.shimo.im/f/nLECb8q0ecw5UN4q.png!thumbnail" alt="图片"></p>
<p>如果某个进程长时间使用超过90％的CPU，则我们会遇到麻烦</p>
<p>在本文中，我们将分析基于Windows的服务器上. net web应用程序的高CPU使用率的实际案例场景、涉及到的识别问题的过程，以及更重要的问题，为什么会出现这个问题以及我们如何解决它。</p>
<p>CPU使用率和内存消耗是广泛讨论的主题。通常，很难确定某个特定进程应使用的资源（CPU，RAM，I / O）的正确数量以及持续的时间段。尽管可以肯定的是-如果某个进程长时间使用了超过90％的CPU，那么我们将特别麻烦，因为在这种情况下服务器将无法处理任何其他请求。</p>
<p>这是否意味着流程本身存在问题？不必要。该过程可能需要更多的处理能力，或者正在处理大量数据。首先，我们唯一能做的就是尝试确定发生这种情况的原因。</p>
<p>所有操作系统都有几种不同的工具来监视服务器中发生的事情。Windows服务器专门具有任务管理器<a href="https://technet.microsoft.com/en-us/library/cc749115.aspx" target="_blank" rel="noopener">Performance Monitor</a>，在本例中，我们使用了<a href="http://newrelic.com/server-monitoring" target="_blank" rel="noopener">New Relic Servers</a>，它是监视服务器的绝佳工具。</p>
<h2 id="最初症状和问题分析"><a href="#最初症状和问题分析" class="headerlink" title="最初症状和问题分析"></a>最初症状和问题分析</h2><p>部署应用程序后，在头两周的时间里，我们开始看到服务器的CPU使用率达到峰值，这使服务器无响应。为了使其再次可用，我们必须重新启动它，并且该事件在该时间段内发生了3次。如前所述，我们使用New Relic Servers作为服务器监视器，它表明w3wp.exe在服务器崩溃时，该进程占用了94％的CPU。</p>
<p>Internet信息服务（IIS）工作进程是Windows进程（w3wp.exe），它运行Web应用程序，并负责处理发送到特定应用程序池的Web服务器的请求。IIS服务器可能有多个应用程序池（和几个不同的w3wp.exe进程），这些池可能会产生问题。根据该进程具有的用户（这在New Relic报告中显示），我们确定问题出在我们的.NET C＃Web表单旧版应用程序。</p>
<p>.NET Framework与Windows调试工具紧密集成在一起，因此，我们要做的第一件事是查看事件查看器和应用程序日志文件，以查找有关正在发生的事情的有用信息。无论我们是否在事件查看器中记录了一些异常，它们都没有提供足够的数据来进行分析。这就是为什么我们决定更进一步并收集更多数据的原因，因此当事件再次发生时，我们将做好准备。</p>
<h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><p>收集用户模式进程转储的最简单方法是使用<a href="https://www.microsoft.com/en-us/download/details.aspx?id=49924" target="_blank" rel="noopener">Debug Diagnostic Tools v2.0</a>或仅使用DebugDiag。DebugDiag具有一组用于收集数据（DebugDiag集合）和分析数据（DebugDiag分析）的工具。</p>
<p>因此，让我们开始定义使用调试诊断工具收集数据的规则：</p>
<ol>
<li>打开DebugDiag集合，然后选择Performance。<img src="https://uploader.shimo.im/f/pUEaTdjUQ34gG4NI.png!thumbnail" alt="图片"></li>
<li>选择Performance Counters并单击Next。</li>
<li>点击Add Perf Triggers。</li>
<li>展开Processor（不是Process）对象，然后选择% Processor Time。请注意，如果您使用的是Windows Server 2008 R2，并且具有64个以上的处理器，请选择该Processor Information对象而不是该Processor对象。</li>
<li>在实例列表中，选择_Total。</li>
<li>单击Add，然后单击确定OK。</li>
<li>选择新添加的触发器，然后单击确定Edit Thresholds。<img src="https://uploader.shimo.im/f/YLVYmJ9IXEsw2vyW.png!thumbnail" alt="图片"></li>
<li>Above在下拉菜单中选择。</li>
<li>将阈值更改为80。</li>
<li>输入20秒数。您可以根据需要调整该值，但请注意不要指定小数秒，以防止错误触发。<img src="https://uploader.shimo.im/f/o4CEqvo7SO4tN36e.png!thumbnail" alt="图片"></li>
<li>点击OK。</li>
<li>点击Next。</li>
<li>点击Add Dump Target。</li>
<li>Web Application Pool从下拉菜单中选择。</li>
<li>从应用程序池列表中选择您的应用程序池。</li>
<li>点击OK。</li>
<li>点击Next。</li>
<li>Next再点击一次。</li>
<li>如果需要，请输入规则名称，并记下转储的保存位置。您可以根据需要更改此位置。</li>
<li>点击Next。</li>
<li>选择Activate the Rule Now并单击Finish。</li>
</ol>
<p>描述的规则将创建一组小型转储文件，这些文件的大小将非常小。最终转储将是具有完整内存的转储，并且该转储会更大。现在，我们只需要等待高CPU事件再次发生即可。</p>
<p>将转储文件保存在所选文件夹中后，我们将使用DebugDiag Analysis工具来分析收集的数据：</p>
<ol>
<li>选择性能分析器。<img src="https://uploader.shimo.im/f/TMJu2hTrqlgsk72i.png!thumbnail" alt="图片"></li>
<li>添加转储文件。<img src="https://uploader.shimo.im/f/FiLI9Fm8THwFbtHC.png!thumbnail" alt="图片"></li>
<li>开始分析。</li>
</ol>
<p>DebugDiag将花费几分钟（或数分钟）来解析转储并提供分析。完成分析后，您将看到一个网页，其中包含摘要以及有关线程的大量信息，类似于以下内容：</p>
<p><img src="https://uploader.shimo.im/f/g0Ju109AJTgK2mGc.png!thumbnail" alt="图片"></p>
<p>正如您在摘要中看到的那样，有一条警告说：“在一个或多个线程上检测到转储文件之间的CPU使用率过高。” 如果单击建议，我们将开始了解应用程序存在问题的地方。我们的示例报告如下所示：</p>
<p><img src="https://uploader.shimo.im/f/8yUwhsUG7wg9LalW.png!thumbnail" alt="图片"></p>
<p>正如我们在报告中看到的那样，有一个关于CPU使用率的模式。所有CPU使用率高的线程都与同一类相关。在跳到代码之前，让我们看一下第一个。</p>
<p><img src="https://uploader.shimo.im/f/UejsVGxAkYEiBRaH.png!thumbnail" alt="图片"></p>
<p>这是我们遇到的第一个线程的细节。对我们来说有趣的部分是：</p>
<p><img src="https://uploader.shimo.im/f/oBHnRyDQWvU0RxZP.png!thumbnail" alt="图片"></p>
<p>在这里，我们有一个代码调用，GameHub.OnDisconnected()该代码触发了有问题的操作，但是在此调用之前，我们有两个Dictionary调用，它们可以使您对发生的事情有所了解。让我们看一下.NET代码，看看该方法在做什么：</p>
<p>public override Task OnDisconnected() {</p>
<pre><code>try

{

    var userId = GetUserId();

    string connId;

    if (onlineSessions.TryGetValue(userId, out connId))

        onlineSessions.Remove(userId);

}

catch (Exception)

{

    // ignored

}

return base.OnDisconnected();

}</code></pre><p>我们显然在这里有问题。报告的调用堆栈说问题出在字典上，在这段代码中我们正在访问字典，特别是引起问题的那一行是：</p>
<p>if (onlineSessions.TryGetValue(userId, out connId))</p>
<p>这是字典声明：</p>
<p>static Dictionary&lt;int, string&gt; onlineSessions = new Dictionary&lt;int, string&gt;();</p>
<h2 id="NET代码有什么问题？"><a href="#NET代码有什么问题？" class="headerlink" title=".NET代码有什么问题？"></a>.NET代码有什么问题？</h2><p>具有面向对象编程经验的每个人都知道静态变量将由此类的所有实例共享。让我们更深入地了解.NET世界中静态的含义。</p>
<p>根据.NET C＃规范：</p>
<blockquote>
<p>使用<a href="https://msdn.microsoft.com/en-us/library/98f28cdx.aspx" target="_blank" rel="noopener">static</a>修饰符声明一个静态成员，该成员属于类型本身而不是特定对象。</p>
</blockquote>
<p>这就是.NET C＃语言规范关于<a href="https://msdn.microsoft.com/en-us/library/79b3xss3.aspx" target="_blank" rel="noopener">静态类和成员的说明</a>：</p>
<blockquote>
<p>与所有类类型一样，当加载引用该类的程序时，.NET Framework公共语言运行库（CLR）将加载静态类的类型信息。程序无法确切指定何时加载类。但是，可以保证在程序中首次引用该类之前，将其加载并初始化其字段并调用其静态构造函数。静态构造函数仅被调用一次，并且静态类在程序所在的应用程序域的生存期内保留在内存中。<br>非静态类可以包含静态方法，字段，属性或事件。即使没有创建该类的实例，该静态成员也可以在该类上调用。始终通过类名称而不是实例名称访问静态成员。无论创建多少个类实例，静态成员只有一个副本。静态方法和属性无法访问其包含类型的非静态字段和事件，并且除非在方法参数中显式传递了实例变量，否则它们无法访问任何对象的实例变量。</p>
</blockquote>
<p>这意味着静态成员属于类型本身，而不是对象。它们也由CLR加载到应用程序域中，因此静态成员属于承载应用程序的进程，而不是特定线程。</p>
<p>鉴于Web环境是多线程环境，因为每个请求都是由w3wp.exe进程产生的新线程；考虑到静态成员是该过程的一部分，我们可能会遇到以下情况：几个不同的线程尝试访问静态（由多个线程共享的）变量的数据，这最终可能会导致多线程问题。</p>
<p>线程安全性下的Dictionary <a href="https://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.100%29.aspx" target="_blank" rel="noopener">文档</a>声明以下内容：</p>
<blockquote>
<p>Dictionary&lt;TKey, TValue&gt;只要不修改集合，A 就可以同时支持多个阅读器。即使这样，通过集合进行枚举本质上也不是线程安全的过程。在极少的枚举与写访问竞争的情况下，必须在整个枚举期间锁定集合。要允许多个线程访问该集合进行读写，您必须实现自己的同步。</p>
</blockquote>
<p>此声明解释了为什么我们可能会遇到此问题。根据转储信息，问题出在字典的FindEntry方法上：</p>
<p><img src="https://uploader.shimo.im/f/RrbDyIKOrqQQ2qt0.png!thumbnail" alt="图片"></p>
<p>如果查看字典的FindEntry <a href="http://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,bcd13bb775d408f1" target="_blank" rel="noopener">实现，</a>我们可以看到该方法遍历内部结构（存储桶）以查找值。</p>
<p>因此，以下.NET代码枚举了集合，这不是线程安全的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public override Task OnDisconnected() &#123;</span><br><span class="line">    	try</span><br><span class="line">    	&#123;</span><br><span class="line">        	var userId = GetUserId();</span><br><span class="line">        	string connId;</span><br><span class="line">        	if (onlineSessions.TryGetValue(userId, out connId))</span><br><span class="line">            	onlineSessions.Remove(userId);</span><br><span class="line">    	&#125;</span><br><span class="line">    	catch (Exception)</span><br><span class="line">    	&#123;</span><br><span class="line">        	// ignored</span><br><span class="line">    	&#125;</span><br><span class="line">    	return base.OnDisconnected();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>正如我们在转储中看到的那样，有多个线程试图同时迭代和修改共享资源（静态字典），最终导致迭代进入无限循环，从而导致线程消耗超过90％的CPU。 。</p>
<p>有几种可能的解决方案。我们首先实现的方法是锁定和同步对字典的访问，但会损失性能。那时服务器每天都崩溃，因此我们需要尽快解决此问题。即使这不是最佳解决方案，它也解决了该问题。</p>
<p>解决这个问题的下一步是分析代码并找到最优解决方案。重构代码是一个选项:新的ConcurrentDictionary类可以解决这个问题，因为它只锁定在一个桶级别，这将提高整体性能。尽管这是一大步，还需要进一步的分析。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/04/06/技术/memory-manage-in-c#/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/04/06/技术/memory-manage-in-c#/" class="post-title-link" itemprop="url">.NET中的内存管理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-04-06 16:28:00" itemprop="dateCreated datePublished" datetime="2020-04-06T16:28:00+08:00">2020-04-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-04-22 23:01:08" itemprop="dateModified" datetime="2020-04-22T23:01:08+08:00">2020-04-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="NET中的内存管理"><a href="#NET中的内存管理" class="headerlink" title=".NET中的内存管理"></a>.NET中的内存管理</h1><p> *<em>资源分配<br>*</em><br>Microsoft .NET公共语言运行时要求从托管堆分配所有资源。当应用程序不再需要对象时，它们将自动释放。</p>
<p>初始化进程后，运行时将保留地址空间的连续区域，该区域最初没有为其分配存储空间。该地址空间区域是托管堆。堆还维护一个指针。该指针指示下一个对象将在堆中分配的位置。最初，将指针设置为保留地址空间区域的基地址。</p>
<p>应用程序使用new运算符创建一个对象。该运算符首先确保新对象所需的字节适合保留区域（必要时进行存储）。如果对象合适，则指针指向堆中的对象，调用该对象的构造函数，并且new运算符返回该对象的地址。</p>
<p><img src="https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory3.gif" alt="Memory3.gif"></p>
<p>上图显示了一个由三个对象组成的托管堆：A，B和C。要分配的下一个对象将放置在NextObjPtr指向的位置（紧随对象C之后）。</p>
<p>当应用程序调用new运算符创建对象时，该区域中可能没有足够的地址空间分配给该对象。堆通过将新对象的大小添加到NextObjPtr来检测到这一点。如果NextObjPtr超出地址空间区域的末尾，则堆已满，必须执行收集。</p>
<p>实际上，当第0代完全填满时发生收集。简而言之，生成是由垃圾收集器实现以提高性能的一种机制。这个想法是，新创建的对象是年轻一代的一部分，而在应用程序生命周期的早期创建的对象是老一代的对象。将对象分成几代可以使垃圾收集器收集特定的世代，而不是收集托管堆中的所有对象。</p>
<p><strong>垃圾收集算法</strong></p>
<p>垃圾收集器检查以查看堆中是否有不再由应用程序使用的对象。如果存在此类对象，则可以回收这些对象使用的内存。（如果没有更多的内存可用于堆，则new运算符将引发OutOfMemoryException。）</p>
<p>每个应用程序都有一组根。根标识存储位置，这些存储位置引用托管堆上的对象或设置为null的对象。例如，应用程序中的所有全局和静态对象指针都被视为应用程序根目录的一部分。另外，线程堆栈上的任何局部变量/参数对象指针都被视为应用程序根目录的一部分。最后，任何包含指向托管堆中对象的指针的CPU寄存器也被视为应用程序根目录的一部分。活动根的列表由即时（JIT）编译器和公共语言运行时维护，并且可以由垃圾收集器的算法访问。</p>
<p>当垃圾收集器开始运行时，它假定堆中的所有对象都是垃圾。换句话说，它假定应用程序的任何根都没有引用堆中的任何对象。现在，垃圾收集器开始遍历根目录，并为从根目录可访问的所有对象建立图形。例如，垃圾收集器可以定位一个指向堆中对象的全局变量。</p>
<p>下图显示了具有几个已分配对象的堆，其中应用程序的根直接引用对象A，C，D和F。所有这些对象都成为图形的一部分。在添加对象D时，收集器会注意到该对象引用了对象H，并且对象H也已添加到图中。收集器将继续递归遍历所有可到达的对象。</p>
<p>图的这一部分完成后，垃圾收集器将检查下一个根并再次遍历对象。当垃圾收集器从一个对象移动到另一个对象时，如果它试图将一个对象添加到先前添加的图形中，则垃圾收集器可以停止沿该路径移动。这有两个目的。首先，它不会多次遍历一组对象，因此可以显着提高性能。其次，如果您有任何循环链接的对象列表，它可以防止无限循环。</p>
<p>一旦检查完所有的根，垃圾收集器的图形就会包含从应用程序的根以某种方式可以访问的所有对象的集合。应用程序无法访问该图中未包含的任何对象，因此将其视为垃圾。</p>
<p>垃圾收集器现在线性地遍历堆，寻找垃圾对象的连续块（现在被认为是可用空间）。然后，垃圾收集器将非垃圾对象向下移动到内存中（使用标准的memcpy函数），从而消除了堆中的所有间隙。当然，在内存中移动对象会使指向该对象的所有指针无效。因此，垃圾收集器必须修改应用程序的根，以便指针指向对象的新位置。另外，如果任何对象包含指向另一个对象的指针，则垃圾回收器还负责更正这些指针。</p>
<p>下图显示了收集后的托管堆。</p>
<p><img src="https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory5.gif" alt="Memory5.gif"></p>
<p>在识别完所有垃圾之后，所有非垃圾都已压缩，所有非垃圾指针都已固定，NextObjPtr定位在最后一个非垃圾对象之后。此时，再次尝试新操作，并成功创建应用程序请求的资源。</p>
<p>GC会对性能产生重大影响，这是使用托管堆的主要缺点。但是，请记住，GC仅在堆已满时才发生，并且在此之前，托管堆要比C运行时堆快得多。运行时的垃圾收集器还使用Generations提供了一些优化，可以大大提高垃圾收集的性能。</p>
<p>您不再需要实现管理应用程序使用的任何资源的生存期的任何代码。现在，不可能泄漏资源，因为可以在某个时候收集从应用程序的根目录无法访问的任何资源。此外，也无法访问已释放的资源，因为如果可访问资源将不会被释放。如果无法访问，则您的应用程序无法访问它。</p>
<p>以下代码演示了如何分配和管理资源：</p>
<p> <code>class Application
{
public static int Main(String[] args)
{
// ArrayList object created in heap, myArray is now in root
ArrayList myArray = new ArrayList();
// Create 10000 objects in the heap
for (int x = 0; x &lt; 10000; x++)
{
myArray.Add(new Object()); // Object object created in heap
}
// Right now, myArray is a root (on the thread&#39;s stack). So,
// myArray is reachable and the 10000 objects it points to are also reachable.
Console.WriteLine(myArray.Count);
// After the last reference to myArray in the code, myArray is not a root.
// Note that the method doesn&#39;t have to return, the JIT compiler knows
// to make myArray not a root after the last reference to it in the code.
// Since myArray is not a root, all 10001 objects are not reachable
// and are considered garbage. However, the objects are not
// collected until a GC is performed.
}
}</code></p>
<p>如果GC非常出色，那么您可能想知道为什么它不在ANSI C ++中。原因是垃圾收集器必须能够标识应用程序的根，还必须能够找到所有对象指针。C ++的问题在于它允许将指针从一种类型转换为另一种类型，并且无法知道指针所指的是什么。在公共语言运行库中，托管堆始终知道对象的实际类型，并且元数据信息用于确定对象的哪些成员引用其他对象。</p>
<p><strong>世代</strong></p>
<p>纯粹为了提高性能而存在的垃圾收集器的一个功能称为“世代”。分代垃圾收集器（也称为临时垃圾收集器）进行以下假设：</p>
<ul>
<li>对象越新，其生存期就会越短。</li>
<li>对象越旧，其寿命将越长。</li>
<li>较新的对象往往彼此之间具有很强的关系，并且经常在同一时间访问。</li>
<li>压缩一部分堆比压缩整个堆要快。</li>
</ul>
<p>初始化后，托管堆不包含任何对象。如下图所示，添加到堆中的对象被称为第0代。简而言之，第0代中的对象是从未被垃圾收集器检查过的年轻对象。</p>
<p><img src="https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory6.gif" alt="Memory6.gif"></p>
<p>现在，如果将更多对象添加到堆中，则将填充堆，并且必须进行垃圾回收。垃圾收集器分析堆时，将构建垃圾（此处以绿色显示）和非垃圾对象的图形。可以将收集到的所有对象压缩到堆的最左侧。这些对象在收藏中幸存下来，并且更旧，现在被认为是第一代。</p>
<p><img src="https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory7.gif" alt="Memory7.gif"></p>
<p>随着更多对象添加到堆中，这些新的年轻对象将放置在第0代中。如果再次填充第0代，则会执行GC。这次，将第1代中幸存的所有对象压缩并视为第2代（请参见下图）。现在压缩了第0代中的所有幸存者，并认为它们是第1代。第0代当前不包含任何对象，但是所有新对象将进入第0代。</p>
<p><img src="https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory8.gif" alt="Memory8.gif"></p>
<p>当前，第二代是运行时的垃圾收集器支持的最高一代。当将来发生收集时，当前第2代中尚存的所有对象仅保留在第2代中。</p>
<p><strong>世代GC性能优化</strong></p>
<p>分代垃圾收集提高了性能。当堆填满并发生收集时，垃圾收集器可以选择仅检查第0代中的对象，而忽略任何更大的后代中的对象。毕竟，对象越新，则预期寿命越短。因此，收集和压缩第0代对象很可能会从堆中回收大量空间，并且比收集器检查所有代的对象要快。</p>
<p>分代收集器可以通过不遍历托管堆中的每个对象来提供更多优化。如果根或对象引用的是旧对象，则垃圾收集器可以忽略任何较旧对象的内部引用，从而减少了构建可访问对象图所需的时间。当然，旧对象可能是指新对象。为了检查这些对象，收集器可以利用系统的写监视支持（由Kernel32.dll中的Win32 GetWriteWatch函数提供）。此支持使收集器知道自上次收集以来已将哪些旧对象（如果有）写入了。可以检查这些特定的旧对象的引用，以查看它们是否引用了任何新对象。</p>
<p>如果收集第0代未提供必要的存储量，则收集器可以尝试收集第1代和第0代的对象。如果所有其他操作均失败，则收集器可以收集第2代，第1代和第9代的所有对象。 0。</p>
<p>前面提到的一种假设是，较新的对象之间往往具有很强的关系，并且经常在同一时间访问。由于新对象是在内存中连续分配的，因此您可以从引用的位置获得性能。更具体地说，很可能所有对象都可以驻留在CPU的缓存中。您的应用程序将以惊人的速度访问这些对象，因为CPU将能够执行其大多数操作，而不会导致强制RAM访问的高速缓存未命中。</p>
<p>微软的性能测试表明，托管堆分配比Win32 HeapAlloc函数执行的标准分配更快。这些测试还表明，在200 MHz Pentium上执行第0代完整GC所需的时间少于1毫秒。Microsoft的目标是使GC花费的时间不比普通页面错误多。</p>
<p><strong>Win32堆的缺点：</strong></p>
<ul>
<li>大多数堆（例如C运行时堆）在找到可用空间的任何地方分配对象。因此，如果我连续创建多个对象，则这些对象很有可能将被兆字节的地址空间分隔开。但是，在托管堆中，连续分配几个对象可确保对象在内存中是连续的。</li>
<li>从Win32堆分配内存时，必须检查该堆以找到可以满足请求的内存块。这在托管堆中不是必需的，因为此处对象在内存中是连续的。</li>
<li>在Win32堆中，必须维护堆维护的数据结构。另一方面，托管堆仅需要增加堆指针。</li>
</ul>
<p><strong>终接器</strong></p>
<p>垃圾收集器提供了您可能想利用的其他功能：终结处理。最终确定允许资源在被收集后对其进行适当的清理。通过使用终结处理，当垃圾回收器决定释放资源的内存时，代表文件或网络连接的资源便能够正确清理自身。</p>
<p>当垃圾收集器检测到对象是垃圾时，垃圾收集器将调用对象的Finalize方法（如果存在），然后回收该对象的内存。例如，假设您具有以下类型（在C＃中）：</p>
<p> <code>public class BaseObj</code><br><code>{</code><br><code>public BaseObj()</code><br><code>{</code><br><code>}</code><br><code>protected override void Finalize()</code><br><code>{</code><br><code>// Perform resource cleanup code here</code><br><code>// Example: Close file/Close network connection</code><br><code>Console.WriteLine(&quot;In Finalize.&quot;);</code><br><code>}</code><br><code>}</code></p>
<p>现在，您可以通过调用以下内容来创建该对象的实例：</p>
<p> <code>BaseObj bo = new BaseObj();</code> </p>
<p>将来的某个时候，垃圾收集器将确定该对象为垃圾。发生这种情况时，垃圾收集器将看到该类型具有Finalize方法，并将调用该方法，从而使“ In Finalize”出现在控制台窗口中并回收该对象使用的内存块。</p>
<p>许多习惯于使用C ++进行编程的开发人员都会在析构函数和Finalize方法之间建立直接的关联。但是，对象终结处理和析构函数具有非常不同的语义，在考虑终结处理时，最好忘记您对析构函数的了解。受管对象永远不会有析构函数。</p>
<p>设计类型时，最好避免使用Finalize方法。有几个原因：</p>
<ul>
<li>可终结对象被提升为较早的一代，这增加了内存压力，并在垃圾收集器确定对象为垃圾时阻止了对象的内存被收集。此外，该对象直接或间接引用的所有对象也将得到提升。</li>
</ul>
<ul>
<li>可终结对象需要更长的分配时间。</li>
</ul>
<ul>
<li>强制垃圾收集器执行Finalize方法会严重影响性能。请记住，每个对象都已完成。因此，如果我有10,000个对象的数组，则每个对象都必须调用其Finalize方法。</li>
</ul>
<ul>
<li>终结对象可以引用其他（不可终结）对象，从而不必要地延长其寿命。实际上，您可能需要考虑将类型分为两种不同的类型：一种轻型类型，其具有不引用任何其他对象的Finalize方法，一个单独的类型，其类型不具有引用其他对象的Finalize方法。</li>
</ul>
<ul>
<li>您无法控制Finalize方法何时执行。该对象可能会保留资源，直到下一次垃圾收集器运行为止。</li>
</ul>
<ul>
<li>当应用程序终止时，某些对象仍然可以访问，并且不会调用其Finalize方法。如果后台线程正在使用对象，或者在应用程序关闭或AppDomain卸载期间创建了对象，则会发生这种情况。此外，默认情况下，应用程序退出时，不可达对象不会调用Finalize方法，因此应用程序可能会迅速终止。当然，将回收所有操作系统资源，但是托管堆中的任何对象都无法正常清理。您可以通过调用System.GC类型的RequestFinalizeOnShutdown方法来更改此默认行为。但是，应谨慎使用此方法，因为调用它意味着您的类型正在控制整个应用程序的策略。</li>
</ul>
<ul>
<li>运行时无法保证Finalize方法的调用顺序。例如，假设有一个对象包含一个指向内部对象的指针。垃圾收集器检测到两个对象都是垃圾。此外，假设首先调用内部对象的Finalize方法。现在，允许外部对象的Finalize方法访问内部对象并对其调用方法，但是内部对象已完成，并且结果可能无法预测。因此，强烈建议Finalize方法不要访问任何内部成员对象。</li>
</ul>
<p>如果确定类型必须实现Finalize方法，则请确保代码尽快执行。避免所有会阻止Finalize方法的操作，包括任何线程同步操作。另外，如果您让任何异常转义了Finalize方法，则系统仅假定Finalize方法已返回，并继续调用其他对象的Finalize方法。</p>
<p>当编译器为构造函数生成代码时，编译器会自动插入对基本类型的构造函数的调用。同样，当C ++编译器为析构函数生成代码时，编译器会自动插入对基本类型的析构函数的调用。终结方法不同于析构函数。编译器对Finalize方法没有特殊知识，因此编译器不会自动生成代码以调用基本类型的Finalize方法。如果您想要这种行为，并且经常这样做，那么必须从类型的Finalize方法中显式调用基本类型的Finalize方法：</p>
<p><code>public class BaseObj
{
public BaseObj()
{
}
protected override void Finalize()
{
Console.WriteLine(&quot;In Finalize.&quot;);
base.Finalize(); // Call base type&#39;s Finalize
}
}</code></p>
<p>请注意，通常将基类型的Finalize方法称为派生类型的Finalize方法中的最后一条语句。这样可以使基础对象保持尽可能长的生命。由于调用基本类型的Finalize方法很常见，因此C＃的语法简化了您的工作。在C＃中，以下代码：</p>
<p> <code>class MyObject
{
MyObject()
{
}
}</code></p>
<p><strong>终结内部</strong></p>
<p>当应用程序创建新对象时，新运算符将从堆中分配内存。如果对象的类型包含Finalize方法，则将指向该对象的指针放在终结队列中。终结队列是由垃圾收集器控制的内部数据结构。队列中的每个条目都指向一个对象，在可以回收该对象的内存之前，应调用该对象的Finalize方法。</p>
<p>下图显示了包含多个对象的堆。从应用程序的根目录可以访问其中的某些对象，而某些则不能。创建对象C，E，F，I和J时，系统检测到这些对象具有Finalize方法，并将指向这些对象的指针添加到了终结队列中。</p>
<p><img src="https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory9.gif" alt="Memory9.gif"></p>
<p>发生GC时，对象B，E，G，H，I和J被确定为垃圾。垃圾收集器扫描完成队列，以查找指向这些对象的指针。当找到一个指针时，该指针将从终结队列中删除，并附加到易碎队列（发音为“ F-reachable”）。易碎队列是由垃圾收集器控制的另一个内部数据结构。易碎队列中的每个指针都标识一个对象，该对象已准备好调用其Finalize方法。</p>
<p>收集之后，托管堆如下图所示。在这里，您看到对象B，G和H占用的内存已被回收，因为这些对象没有需要调用的Finalize方法。但是，无法回收对象E，I和J占用的内存，因为尚未调用它们的Finalize方法。</p>
<p><img src="https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory10.gif" alt="Memory10.gif"></p>
<p>有一个专用的运行时线程专用于调用Finalize方法。当可访问队列为空时（通常是这种情况），该线程进入睡眠状态。但是，当出现条目时，该线程将唤醒，从队列中删除每个条目，并调用每个对象的Finalize方法。因此，您不应在Finalize方法中执行任何有关执行代码的线程的假设的代码。例如，避免在Finalize方法中访问线程本地存储。</p>
<p>终结队列与易碎队列的交互非常有趣。首先，让我告诉您易碎队列的名称。f很明显，代表定稿；易碎队列中的每个条目都应调用其Finalize方法。名称的“可到达”部分表示对象可到达。换句话说，易碎队列被视为根，就像全局变量和静态变量是根一样。因此，如果对象在易碎队列中，则该对象可访问且不是垃圾。</p>
<p>简而言之，当对象不可访问时，垃圾收集器将其视为对象垃圾。然后，当垃圾收集器将对象的条目从终结队列移到可访问队列时，该对象不再被视为垃圾，并且不回收其内存。至此，垃圾收集器已经完成了对垃圾的识别。某些标识为垃圾的对象已被重新分类为非垃圾。垃圾收集器压缩可回收内存，特殊的运行时线程清空易碎队列，执行每个对象的Finalize方法。</p>
<p><img src="https://www.c-sharpcorner.com/UploadFile/tkagarwal/MemoryManagementInNet11232005064832AM/Images/Memory11.gif" alt="Memory11.gif"></p>
<p>下次调用垃圾回收器时，它会看到最终对象是真正的垃圾，因为应用程序的根不指向该对象，并且易碎队列不再指向该对象。现在，只需回收该对象的内存即可。这里要了解的重要一点是，需要两个GC来回收需要终结处理的对象使用的内存。实际上，可能需要两个以上的集合，因为这些对象可以提升为较老的一代。上图显示了第二个GC之后托管堆的外观。</p>
<p><strong>处置方法</strong></p>
<p>使用此方法可以关闭或释放由实现此接口的类的实例持有的非托管资源，例如文件，流和句柄。按照惯例，此方法用于与释放对象拥有的资源或准备对象重用相关的所有任务。</p>
<p>在实现此方法时，对象必须设法通过在包含层次结构中传播调用来确保释放所有保留的资源。例如，如果对象A分配了对象B，而对象B分配了对象C，则A的Dispose实现必须调用B上的Dispose，后者又必须调用C上的Dispose。对象还必须调用其基类的Dispose方法。如果基类实现IDisposable。</p>
<p><code>如果多次调用对象的</code>Dispose方法，则该对象必须忽略第一个调用之后的所有调用。如果多次调用其Dispose方法，则该对象不得引发异常。如果由于已释放资源并且以前未调用过Dispose而发生错误，则Dispose可能引发异常。</p>
<p><code>因为必须显式调用</code>Dispose方法，所以实现IDisposable的对象还必须实现终结器，以在不调用Dispose时处理释放资源。默认情况下，垃圾回收器将在回收对象的内存之前自动调用其终结器。但是，一旦调用了Dispose方法，垃圾收集器通常就不需要调用已处理对象的终结器。为了防止自动完成，Dispose实现可以调用GC.SuppressFinalize方法。</p>
<p><strong>通过System.GC直接控制</strong></p>
<p>System.GC类型使您的应用程序可以直接控制垃圾收集器。您可以通过读取GC.MaxGeneration属性来查询托管堆支持的最大生成量。当前，GC.MaxGeneration属性始终返回2。</p>
<p>也可以通过调用此处显示的两个方法之一来强制垃圾收集器执行收集：</p>
<p><code>void GC.Collect(Int32 Generation)
void GC.Collect()</code></p>
<p>第一种方法允许您指定要收集的世代。您可以将0范围内的任何整数传递给GC.MaxGeneration（含）。传递0导致生成0被收集；传递1导致收集第1代和第0代；传递2会导致生成2、1、0和0。不带参数的Collect方法的版本强制所有世代的完整集合，等效于调用：</p>
<p><code>GC.Collect（GC.MaxGeneration）;</code></p>
<p>GC类型还提供了WaitForPendingFinalizers方法。此方法只是挂起调用线程，直到处理易碎队列的线程清空了队列，然后调用每个对象的Finalize方法。在大多数应用程序中，您不太可能需要调用此方法。</p>
<p>最后，垃圾收集器提供了两种方法，可让您确定对象当前处于哪个世代：</p>
<p><code>Int32 GetGeneration（Object obj）</code><br><code>Int32 GetGeneration（WeakReference wr）</code></p>
<p>GetGeneration的第一个版本将对象引用作为参数，而第二个版本将WeakReference引用作为参数。当然，返回的值将介于0到GC.MaxGeneration之间（含）。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/04/05/技术/understanding-garbage-collection-in-.net/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/04/05/技术/understanding-garbage-collection-in-.net/" class="post-title-link" itemprop="url">了解.NET中的垃圾回收</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-04-05 16:28:00" itemprop="dateCreated datePublished" datetime="2020-04-05T16:28:00+08:00">2020-04-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-04-22 23:00:35" itemprop="dateModified" datetime="2020-04-22T23:00:35+08:00">2020-04-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="了解-NET中的垃圾回收"><a href="#了解-NET中的垃圾回收" class="headerlink" title="了解.NET中的垃圾回收"></a>了解.NET中的垃圾回收</h1><blockquote>
<p> 一旦了解了.NET的垃圾收集器是如何工作的，那么可能会触及.NET应用程序的一些更为神秘的问题的原因就会变得更加清楚。NET可能已承诺要结束显式内存管理，但在开发.NET应用程序时，仍然有必要分析内存的使用情况，以便避免与内存相关的错误和某些性能问题。 </p>
</blockquote>
<p>.NET的垃圾收集器已在Windows应用程序中作为显式内存管理和内存泄漏的结束而出售给我们：这个想法是，在后台运行垃圾收集器的情况下，开发人员不再需要担心管理它们创建的对象的生命周期–应用程序完成处理后，垃圾收集器将对其进行处理。</p>
<p>但是，实际情况要复杂得多。垃圾收集器无疑解决了非托管程序中最常见的泄漏-由开发人员在完成使用后忘记释放内存而引起的泄漏。它还解决了内存释放过早的相关问题，但是当垃圾收集器对开发人员对对象是否仍然处于“活动状态”并且能够进行开发时有不同的看法时，解决该问题的方式可能导致内存泄漏。要使用的。解决这些问题之前，您需要对收集器的工作方式有所了解。</p>
<h1 id="垃圾收集器如何工作"><a href="#垃圾收集器如何工作" class="headerlink" title="垃圾收集器如何工作"></a>垃圾收集器如何工作</h1><p>那么，垃圾收集器如何实现其魔力？基本思想非常简单：它检查对象在内存中的布局方式，并通过遵循一系列引用来标识正在运行的程序可以“访问”的所有那些对象。</p>
<p>当垃圾回收开始时，它将查看一组称为“ GC根”的引用。这些是由于某种原因总是可以访问的内存位置，并且包含对程序创建的对象的引用。它将这些对象标记为“活动”，然后查看它们引用的所有对象。它也将这些标记为“实时”。它以这种方式继续，遍历它知道是“活动”的所有对象。它将它们引用的所有内容都标记为也被使用，直到找不到其他对象为止。</p>
<p>如果某个对象或其超类之一的字段包含另一个对象，则该对象由垃圾收集器标识为引用另一个对象。</p>
<p>一旦知道了所有这些活动对象，就可以丢弃所有剩余的对象，并将空间重新用于新对象。.NET压缩内存，以确保没有间隙（有效地压缩丢弃的对象不存在）–这意味着空闲内存始终位于堆的末尾，并可以非常快速地分配新对象。</p>
<p>GC根本身不是对象，而是对对象的引用。GC根引用的任何对象将自动在下一个垃圾回收中保留下来。.NET中有四种主要的根：</p>
<p>当前正在运行的方法中的局部变量被视为GC根。这些变量引用的对象始终可以通过声明它们的方法立即访问，因此必须保留它们。这些根的生命周期可以取决于程序的构建方式。在调试版本中，局部变量的持续时间与方法在堆栈上的时间一样长。在发行版本中，JIT能够查看程序结构以找出执行过程中该方法可以使用变量的最后一点，并在不再需要该变量时将其丢弃。这种策略并不总是使用，可以通过例如在调试器中运行程序来关闭。</p>
<p>静态变量也始终被视为GC根。声明它们的类可以随时访问它们引用的对象（如果是公共的，则可以访问程序的其余部分），因此.NET将始终保持它们不变。声明为“线程静态”的变量仅会在该线程运行时持续存在。</p>
<p>如果通过互操作将托管对象传递给非托管COM +库，则该对象也将成为具有引用计数的GC根。这是因为COM +不进行垃圾收集：它使用引用计数系统；通过将引用计数设置为0，一旦COM +库完成了该对象，它将不再是GC根目录，并且可以再次收集。</p>
<p>如果对象具有终结器，则在垃圾回收器确定该对象不再“处于活动状态”时，不会立即将其删除。相反，它成为一种特殊的根，直到.NET调用了finalizer方法。这意味着这些对象通常需要从内存中删除一个以上的垃圾回收，因为它们在第一次发现未使用时仍将生存。</p>
<h2 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h2><p>总体而言，.NET中的内存形成了一个复杂的，打结的引用和交叉引用图。这可能使得很难确定特定对象使用的内存量。例如，List <x>对象使用的内存非常小，因为List <x>类只有几个字段。但是，其中之一是列表中的对象数组：如果列表中有许多条目，则这可能会很大。这几乎总是由列表“独占”，因此关系非常简单：列表的总大小是小的初始对象和它引用的大数组的大小。但是，数组中的对象可能完全是另一回事：很可能存在通过内存的其他路径来访问它们。在这种情况下，</x></x></p>
<p>当循环引用开始起作用时，事情变得更加混乱。</p>
<p><img src="https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image001.jpg" alt="737-image001.jpg"></p>
<p>在开发代码时，通常将内存视为组织为更容易理解的结构：从各个根开始的树：</p>
<p><img src="https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image002.jpg" alt="737-image002.jpg"></p>
<p>确实，以这种方式进行思考确实使（更确实可能）思考对象在内存中的布局方式。这也是编写程序或使用调试器时表示数据的方式，但这很容易忘记一个对象可以附加到多个根。这通常是.NET中内存泄漏的来源：开发人员忘记或从未意识到，一个对象锚定到多个根。考虑一下此处所示的情况：将GC root 2设置为null实际上不会允许垃圾收集器删除任何对象，这可以从查看完整图形中看到，而不能从树中看到。</p>
<p>内存剖析器可以从另一个角度查看图形，就像树根植于单个对象并向后跟随引用以将GC根放在叶子上一样。对于根2引用的ClassC对象，我们可以向后跟随引用以获取下图：</p>
<p><img src="https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image003.jpg" alt="737-image003.jpg"></p>
<p>通过这种方式的思考表明，ClassC对象具有两个最终的“所有者”，在垃圾收集器将其删除之前，这两个对象都必须放弃它。一旦将GC根目录2设置为null，就可以断开GC根目录3与该对象之间的任何链接，以便将其删除。</p>
<p>在实际的.NET应用程序中，这种情况很容易出现。最常见的是，数据对象被用户界面中的元素引用，但在数据处理完毕后不会被删除。这种情况并不是很泄漏：当用新数据更新UI控件时，将回收内存，但是这可能意味着应用程序使用的内存比预期的要多得多。事件处理程序是另一个常见原因：很容易忘记一个对象的寿命至少与它从中接收事件的对象一样长，对于某些全局事件处理程序（如Application类中的事件），这种情况永远存在。</p>
<p>实际的应用程序，尤其是那些具有用户界面组件的应用程序，具有比这复杂得多的图形。甚至可以从大量不同的地方引用对话框中的标签之类的简单内容…</p>
<p><img src="https://www.red-gate.com/simple-talk/wp-content/uploads/imported/737-image004.jpg" alt="737-image004.jpg"></p>
<p>很容易看到偶然的物体如何在迷宫中丢失。</p>
<h1 id="垃圾收集器的局限性"><a href="#垃圾收集器的局限性" class="headerlink" title="垃圾收集器的局限性"></a>垃圾收集器的局限性</h1><h2 id="仍在引用的未使用对象"><a href="#仍在引用的未使用对象" class="headerlink" title="仍在引用的未使用对象"></a>仍在引用的未使用对象</h2><p>.NET中垃圾收集器的最大局限性是一个细微的限制：虽然它可以检测和删除未使用的对象，但实际上它会找到<em>未引用的</em>对象。这是一个重要的区别：程序可能永远不会再引用对象。但是，尽管有一些路径导致它可能仍被使用，但它永远不会从内存中释放出来。这导致内存泄漏；在.NET中，当将不再使用的对象保持引用状态时，会发生这些情况。</p>
<p>尽管内存使用率上升的症状很明显，但这些泄漏的来源可能很难发现。有必要确定哪些未使用的对象保留在内存中，然后跟踪引用以找出为什么不收集它们。内存分析器对于此任务至关重要：通过比较发生泄漏时的内存状态，可以找到麻烦的未使用对象，但是没有调试器可以向后跟踪对象引用。</p>
<p>垃圾收集器旨在处理大量资源，也就是说，释放对象的位置无关紧要。在现代系统上，内存属于这一类（何时回收内存无关紧要，只要及时完成以防止新分配失败）。仍然有一些资源不属于此类：例如，需要快速关闭文件句柄以避免引起应用程序之间的共享冲突。这些资源不能由垃圾收集器完全管理，因此.NET为管理这些资源的对象提供<code>Dispose</code>（）方法以及<code>using</code>（）构造。在这些情况下，对象的稀缺资源可通过实施<code>Dispose</code> 方法，但是紧要的内存要少得多，然后由垃圾回收器释放。</p>
<p><code>Dispose</code>意味着.NET没有什么特别的，因此仍必须取消引用已处置的对象。这使已处置但尚未回收的对象成为内存泄漏源的良好候选对象。</p>
<h2 id="堆的碎片"><a href="#堆的碎片" class="headerlink" title="堆的碎片"></a>堆的碎片</h2><p>.NET中一个鲜为人知的限制是大对象堆的限制。成为该堆一部分的对象不会在运行时移动，这可能导致程序过早地耗尽内存。当某些对象的寿命比其他对象长时，这将导致堆在对象过去所在的位置形成孔-这称为碎片。当程序要求一个大的内存块，但堆变得非常分散，以至于没有单个内存区域足以容纳它时，就会发生问题。内存分析器可以估计程序可以分配的最大对象：如果该对象正在下降，则很可能是原因。一个<code>OutOfMemoryException</code>当程序显然具有大量可用内存时，通常会发生由碎片引起的错误–在32位系统上，进程应至少能够使用1.5Gb，但是由于碎片导致的故障通常会在使用该碎片之前开始发生很多内存。</p>
<p>碎片化的另一个征兆是.NET通常必须保留分配给应用程序的空洞所使用的内存。这显然导致它使用比在任务管理器中查看所需的内存更多的内存。这种效果通常相对来说是无害的：Windows非常擅长于意识到未被占用的孔所占用的内存并将其分页，并且如果碎片没有恶化，则程序将不会耗尽内存。但是，对于用户而言，这看起来并不好，他们可能会认为该应用程序浪费且“ blo肿”。当探查器显示程序分配的对象仅使用少量内存，而任务管理器显示该进程占用大量空间时，通常会发生这种情况。</p>
<h1 id="垃圾收集器的性能"><a href="#垃圾收集器的性能" class="headerlink" title="垃圾收集器的性能"></a>垃圾收集器的性能</h1><p>在性能方面，垃圾收集系统的最重要特征是垃圾收集器可以随时开始执行。这使它们不适用于定时至关重要的情况，因为任何操作的定时都可能被收集器的操作所抛弃。</p>
<p>.NET收集器有两种主要的操作模式：并发和同步（有时称为工作站和服务器）。默认情况下，并发垃圾收集用于桌面应用程序，同步用于服务器应用程序（例如ASP.NET）。</p>
<p>在并发模式下，.NET将尝试避免在进行收集时停止正在运行的程序。这意味着在给定的时间内应用程序可以完成的总次数较少，但应用程序不会暂停。这对交互式应用程序很有用，在交互应用程序中，给用户留下印象，即应用程序应立即做出响应，这一点很重要。</p>
<p>在同步模式下，.NET将在垃圾收集器运行时挂起正在运行的应用程序。实际上，这总体上比并发模式更有效–垃圾回收花费相同的时间，但是不必与程序继续运行进行竞争–但是，这意味着必须执行完整的回收时会有明显的暂停。 。</p>
<p>如果默认设置不合适，则可以在应用程序的配置文件中设置垃圾收集器的类型。当更重要的是应用程序具有高吞吐量而不是显示响应时，选择同步收集器可能很有用。</p>
<p>在大型应用程序中，垃圾收集器需要处理的对象数量会变得非常大，这意味着访问和重新排列所有对象都将花费很长时间。为了解决这个问题，.NET使用了“分代”垃圾收集器，该垃圾收集器试图将优先级赋予较小的一组对象。这个想法是，最近创建的对象更有可能被快速释放，因此，当试图释放内存时，分代垃圾收集器会优先处理它们，因此.NET首先查看自上一次垃圾收集以来已分配的对象，并且只会开始如果无法通过这种方式释放足够的空间，请考虑使用较旧的对象。</p>
<p>如果.NET可以自行选择收集时间，则此系统效果最佳，并且如果<code>GC.Collect</code>调用（）会中断该系统，因为这通常会导致新对象过早地变旧，这增加了在不久的将来再次进行昂贵的完整收集的可能性。</p>
<p>具有终结器的类也会破坏垃圾收集器的平稳运行。这些类的对象不能立即删除：相反，它们进入终结器队列，并在运行终结器后从内存中删除。这意味着它们所引用的任何对象（以及那些对象所引用的任何对象，依此类推）至少也必须在此之前保留在内存中，并且在内存再次可用之前需要两次垃圾回收。如果该图包含带有终结器的许多对象，则这可能意味着垃圾收集器需要多次通过才能完全释放所有未引用的对象。</p>
<p>有一个避免此问题的简单方法：<code>IDisposable</code>在可终结类上实现，将完成对象所需的操作移到<code>Dispose()</code>方法中并<code>GC.SuppressFinalize()</code>在最后调用。然后可以修改终结器以调用该<code>Dispose()</code>方法。<code>GC.SuppressFinalize()</code>告诉垃圾回收器，该对象不再需要终结，可以立即被垃圾回收，这可以导致更快地回收内存。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>如果您花一些时间了解垃圾收集器的工作方式，则更容易理解应用程序中的内存和性能问题。它表明，尽管.NET减轻了内存管理的负担，但并不能完全消除跟踪和管理资源的需求。但是，使用内存分析器来诊断和修复.NET中的问题更加容易。考虑到.NET在开发中尽早管理内存的方式可以帮助减少问题，但是即使那样，由于框架或第三方库的复杂性，此类问题仍然可能出现。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/03/26/技术/the-typical-ten-problems-in-c-sharp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/03/26/技术/the-typical-ten-problems-in-c-sharp/" class="post-title-link" itemprop="url">C＃编程中最常见的10个错误</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-03-26 08:55:00 / Modified: 08:55:50" itemprop="dateCreated datePublished" datetime="2020-03-26T08:55:00+08:00">2020-03-26</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文来自：<a href="https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make" target="_blank" rel="noopener">https://www.toptal.com/c-sharp/top-10-mistakes-that-c-sharp-programmers-make</a></p>
<p>帕特里克·赖德（PATRICK RYDER）在Microsoft工作期间帮助创建了VB 1.0和更高版本的.NET平台。自2000年以来，他专注于全栈项目。</p>
<p>C＃是针对Microsoft 公共语言运行库（CLR）的几种语言之一。面向CLR的语言受益于多种功能，例如跨语言集成和异常处理，增强的安全性，简化的组件交互模型以及调试和性能分析服务。在当今的CLR语言中，C＃被广泛用于针对Windows台式机，移动或服务器环境的复杂，专业的开发项目中。(译者注，目前已支持各类跨平台的操作系统环境）</p>
<p>C＃是一种面向对象的强类型语言。在编译和运行时，C＃中严格的类型检查会导致尽早报告大多数典型的C＃编程错误，并准确定位其位置。这可以在C Sharp编程中节省大量时间，相比之下，在更自由地执行类型安全的语言中，跟踪令人困惑的错误的原因可能会在违规操作发生很久之后才发生。但是，许多C＃编码人员无意间（或不小心）放弃了这种检测的好处，这导致了本C＃教程中讨论的一些问题。</p>
<h2 id="关于本C-Sharp编程教程"><a href="#关于本C-Sharp编程教程" class="headerlink" title="关于本C Sharp编程教程"></a>关于本C Sharp编程教程</h2><p><strong>本教程描述了C＃程序员犯下的10种最常见的C＃编程错误或应避免的问题，并为他们提供了帮助。</strong></p>
<p>尽管本文中讨论的大多数错误都是C＃特定的，但有些错误也与其他以CLR为目标或使用框架类库（FCL）的语言有关。</p>
<h2 id="常见的C＃编程错误＃1：使用值类型与引用相等，或反过来"><a href="#常见的C＃编程错误＃1：使用值类型与引用相等，或反过来" class="headerlink" title="常见的C＃编程错误＃1：使用值类型与引用相等，或反过来"></a>常见的C＃编程错误＃1：使用值类型与引用相等，或反过来</h2><p>C ++和许多其他语言的程序员习惯于控制他们分配给变量的值是简单的值还是对现有对象的引用。但是，在C Sharp编程中，该决定由编写对象的程序员决定，而不是由实例化该对象并将其分配给变量的程序员做出。对于那些试图学习C＃编程的人来说，这是一个常见的“陷阱”。</p>
<p>如果您不知道所使用的对象是值类型还是引用类型，则可能会遇到一些意外。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Point point1 = new Point(20, 30);</span><br><span class="line">Point point2 = point1;</span><br><span class="line">point2.X = 50;</span><br><span class="line">Console.WriteLine(point1.X);       // 20 (does this surprise you?)</span><br><span class="line">Console.WriteLine(point2.X);       // 50</span><br><span class="line"></span><br><span class="line">Pen pen1 = new Pen(Color.Black);</span><br><span class="line">Pen pen2 = pen1;</span><br><span class="line">pen2.Color = Color.Blue;</span><br><span class="line">Console.WriteLine(pen1.Color);     // Blue (or does this surprise you?)</span><br><span class="line">Console.WriteLine(pen2.Color);     // Blue</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，都Point和Pen对象创建方式不尽相同，但值point1保持不变，当一个新的X坐标值被分配到point2，而价值pen1 <em>是</em>当一个新的颜色被分配到修改pen2。因此，我们可以<em>推断出<em>，point1并且point2每个Point对象都包含自己的对象副本，而pen1和pen2都包含对同一Pen对象的引用。</em>但是，如果不进行此实验，我们怎么知道呢？</em><br>答案是查看对象类型的定义（您可以在Visual Studio中通过将光标置于对象类型的名称上并按F12轻松地完成此操作）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public struct Point &#123; ... &#125;     // defines a “value” type</span><br><span class="line">public class Pen &#123; ... &#125;        // defines a “reference” type</span><br></pre></td></tr></table></figure>

<p>如上所示，在C＃编程中，struct关键字用于定义值类型，而class关键字用于定义引用类型。<em>对于那些具有C ++背景的人，由于C ++和C＃关键字之间的许多相似之处而陷入一种错误的安全感，这种行为可能会让人感到意外，您可能会从C＃教程中寻求帮助。</em><br>如果您要依赖值和引用类型之间不同的某些行为（例如，将对象作为方法参数传递并让该方法更改对象状态的能力），请确保您正在处理正确的对象类型，以避免C＃编程问题。</p>
<h2 id="常见的C＃编程错误＃2：误解了未初始化变量的默认值"><a href="#常见的C＃编程错误＃2：误解了未初始化变量的默认值" class="headerlink" title="常见的C＃编程错误＃2：误解了未初始化变量的默认值"></a>常见的C＃编程错误＃2：误解了未初始化变量的默认值</h2><p>在C＃中，值类型不能为null。根据定义，值类型具有值，甚至值类型的未初始化变量也必须具有值。这称为该类型的默认值。当检查变量是否未初始化时，这会导致以下结果，通常是意外的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static Point point1;</span><br><span class="line">    static Pen pen1;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Console.WriteLine(pen1 == null);      // True</span><br><span class="line">        Console.WriteLine(point1 == null);    // False (huh?)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么point1不为空？答案是Point是值类型，它的默认值为Point（0,0），而不是null。未能意识到这一点是在C＃中非常容易（也是常见）的错误。<br>许多（但不是全部）值类型都有一个IsEmpty属性，您可以检查该属性是否等于其默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(point1.IsEmpty);        // True</span><br></pre></td></tr></table></figure>

<p>当您检查变量是否已初始化时，请确保您知道该类型的未初始化变量在默认情况下将具有什么值，并且不要依赖于它为null。</p>
<h2 id="常见的C＃编程错误＃3：使用不正确或未指定的字符串比较方法"><a href="#常见的C＃编程错误＃3：使用不正确或未指定的字符串比较方法" class="headerlink" title="常见的C＃编程错误＃3：使用不正确或未指定的字符串比较方法"></a>常见的C＃编程错误＃3：使用不正确或未指定的字符串比较方法</h2><p>比较C＃中的字符串有很多不同的方法。</p>
<p>尽管许多程序员使用==运算符进行字符串比较，但这实际上是最不希望采用的方法之一，主要是因为它没有在代码中明确指定需要哪种类型的比较。</p>
<p>相反，在C＃编程中测试字符串相等性的首选方法是使用以下Equals方法：</p>
<pre><code>public bool Equals(string value);

public bool Equals(string value, StringComparison comparisonType);</code></pre><p>第一个方法签名（即不带comparisonType参数）实际上与使用==运算符相同，但是具有显式应用于字符串的好处。它执行字符串的序数比较，基本上是逐字节比较。在很多情况下，这正是您想要的比较类型，尤其是在比较以编程方式设置值的字符串（例如文件名，环境变量，属性等）时。在这些情况下，只要序数比较确实是正确的类型这种情况下的比较，使用Equals方法不带 comparisonType参数的唯一缺点是，阅读代码的人可能不知道您要进行哪种类型的比较。</p>
<p>但是，使用Equals每次比较字符串包含comparisonType的方法签名，不仅可以使代码更清晰，还可以使您明确考虑需要进行哪种类型的比较。这是一件值得做的事情，因为即使英语在序数比较和对文化敏感的比较之间不能提供很多差异，其他语言也可以提供很多好处，而忽略其他语言的可能性正在为您提供巨大的潜力错误的道路。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string s = &quot;strasse&quot;;</span><br><span class="line"></span><br><span class="line">// outputs False:</span><br><span class="line">Console.WriteLine(s == &quot;straße&quot;);</span><br><span class="line">Console.WriteLine(s.Equals(&quot;straße&quot;));</span><br><span class="line">Console.WriteLine(s.Equals(&quot;straße&quot;, StringComparison.Ordinal));</span><br><span class="line">Console.WriteLine(s.Equals(&quot;Straße&quot;, StringComparison.CurrentCulture));        </span><br><span class="line">Console.WriteLine(s.Equals(&quot;straße&quot;, StringComparison.OrdinalIgnoreCase));</span><br><span class="line"></span><br><span class="line">// outputs True:</span><br><span class="line">Console.WriteLine(s.Equals(&quot;straße&quot;, StringComparison.CurrentCulture));</span><br><span class="line">Console.WriteLine(s.Equals(&quot;Straße&quot;, StringComparison.CurrentCultureIgnoreCase));</span><br></pre></td></tr></table></figure>

<p>最安全的做法是始终为该Equals方法提供comparisonType参数。以下是一些基本准则：</p>
<ul>
<li>在比较用户输入的字符串或要显示给用户的字符串时，请使用区分区域性的比较（CurrentCulture或CurrentCultureIgnoreCase）。</li>
<li>比较程序字符串时，请使用序数比较（Ordinal或OrdinalIgnoreCase）。</li>
<li>InvariantCulture和InvariantCultureIgnoreCase一般不被除了在非常有限的情况下使用，因为顺序比较是更有效的。如果需要进行文化意识比较，则通常应针对当前文化或其他特定文化进行比较。</li>
</ul>
<p>除了Equals方法之外，字符串还提供了 Compare方法，该方法为您提供有关字符串相对顺序的信息，而不仅仅是进行相等性测试。此方法是优选的&lt;，&lt;=，&gt;和&gt;=运算符，对于上述的为讨论避免C＃的问题同样的原因。</p>
<h2 id="常见的C＃编程错误＃4：使用迭代（而不是声明性）语句来操作集合"><a href="#常见的C＃编程错误＃4：使用迭代（而不是声明性）语句来操作集合" class="headerlink" title="常见的C＃编程错误＃4：使用迭代（而不是声明性）语句来操作集合"></a>常见的C＃编程错误＃4：使用迭代（而不是声明性）语句来操作集合</h2><p>在C＃3.0中，向<a href="http://msdn.microsoft.com/en-us/library/bb308959.aspx" target="_blank" rel="noopener">语言</a>添加<a href="http://msdn.microsoft.com/en-us/library/bb308959.aspx" target="_blank" rel="noopener">语言集成查询</a>（LINQ）永远改变了查询和操作集合的方式。从那时起，如果您使用迭代语句来操作集合，那么您本来应该使用LINQ。</p>
<p>一些C＃程序员甚至不知道LINQ的存在，但是幸运的是，这个数目正在变得越来越小。但是，许多人仍然认为，由于LINQ关键字和SQL语句之间的相似性，它的唯一用途是在查询数据库的代码中。</p>
<p>尽管数据库查询是LINQ语句的一种非常普遍的用法，但它们实际上是在任何可枚举的集合（即，实现IEnumerable接口的任何对象）上工作的。因此，例如，如果您有一个Accounts数组，而不是为每个each编写一个C＃List：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      decimal total = 0;</span><br><span class="line">      foreach (Account account in myAccounts) &#123;</span><br><span class="line">        if (account.Status == &quot;active&quot;) &#123;</span><br><span class="line">          total += account.Balance;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">你可以这样写：</span><br><span class="line">      decimal total = (from account in myAccounts</span><br><span class="line">                       where account.Status == &quot;active&quot;</span><br><span class="line">                       select account.Balance).Sum();</span><br></pre></td></tr></table></figure>

<p>尽管这是一个非常简单的示例，说明如何避免这种常见的C＃编程问题，但在某些情况下，单个LINQ语句可以轻松替换代码中的迭代循环（或嵌套循环）中的数十个语句。更少的通用代码意味着更少的引入错误的机会。但是请记住，在性能方面可能会有所取舍。在对性能有严格要求的情况下，尤其是在迭代代码能够对LINQ无法进行的集合进行假设的情况下，请确保在这两种方法之间进行性能比较。</p>
<h2 id="常见的C＃编程错误＃5：无法考虑LINQ语句中的基础对象"><a href="#常见的C＃编程错误＃5：无法考虑LINQ语句中的基础对象" class="headerlink" title="常见的C＃编程错误＃5：无法考虑LINQ语句中的基础对象"></a>常见的C＃编程错误＃5：无法考虑LINQ语句中的基础对象</h2><p>LINQ非常适合抽象处理集合的任务，无论它们是内存中对象，数据库表还是XML文档。在理想环境中，您不需要知道底层对象是什么。但是这里的错误是假设我们生活在一个完美的世界中。实际上，如果相同的LINQ语句恰好采用不同的格式，则当它们对完全相同的数据执行时，它们可以返回不同的结果。</p>
<p>例如，考虑以下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">decimal total = (from account in myAccounts</span><br><span class="line">                 where account.Status == &quot;active&quot;</span><br><span class="line">                 select account.Balance).Sum();</span><br></pre></td></tr></table></figure>

<p>如果对象的其中一个account.Status等于“活动”（请注意大写字母A）会怎样？好吧，如果myAccounts是一个DbSet对象（使用默认的不区分大小写的默认配置设置），则where表达式仍会匹配该元素。但是，如果myAccounts位于内存阵列中，则它将不匹配，因此将产生总计不同的结果。<br>等一下 在前面讨论字符串比较时，我们看到==运算符对字符串进行了序数比较。那么，为什么在这种情况下==操作员执行不区分大小写的比较？</p>
<p><em>答案是，当LINQ语句中的基础对象是对SQL表数据的引用时（如本示例中的Entity Framework DbSet对象一样），该语句将转换为T-SQL语句。然后，操作员将遵循T-SQL编程规则，而不是C＃编程规则，因此，上述情况下的比较最终不区分大小写。</em></p>
<p>通常，即使LINQ是查询对象集合的有用且一致的方式，实际上，您仍然需要知道您的语句是否将转换为C＃以外的其他内容，以确保代码的行为能够在运行时达到预期。</p>
<h2 id="常见的C＃编程错误＃6：扩展方法使您感到困惑或冒充"><a href="#常见的C＃编程错误＃6：扩展方法使您感到困惑或冒充" class="headerlink" title="常见的C＃编程错误＃6：扩展方法使您感到困惑或冒充"></a>常见的C＃编程错误＃6：扩展方法使您感到困惑或冒充</h2><p>如前所述，LINQ语句可在实现IEnumerable的任何对象上工作。例如，以下简单功能将在任何帐户集合上累加余额：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public decimal SumAccounts(IEnumerable&lt;Account&gt; myAccounts) &#123;</span><br><span class="line">    return myAccounts.Sum(a =&gt; a.Balance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，myAccounts参数的类型声明为 IEnumerable<account>。由于myAccounts引用Sum方法（C＃使用熟悉的“点符号”来引用类或接口上的方法），因此我们希望看到Sum()在IEnumerable<t>接口定义上调用的方法。但是，定义 IEnumerable<t>未引用任何Sum方法，而只是这样：</t></t></account></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IEnumerable&lt;out T&gt; : IEnumerable &#123;</span><br><span class="line">    IEnumerator&lt;T&gt; GetEnumerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么该Sum()方法在哪里定义？C＃是强类型的，因此，如果对该Sum方法的引用无效，则C＃编译器肯定会将其标记为错误。因此，我们知道它必须存在，但是在哪里？此外，LINQ为查询或汇总这些集合提供的所有其他方法的定义在哪里？<br>答案是这Sum()不是IEnumerable接口上定义的方法 。相反，它是在System.Linq.Enumerable类上定义的静态方法（称为“扩展方法”）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">namespace System.Linq &#123;</span><br><span class="line">  public static class Enumerable &#123;</span><br><span class="line">    ...</span><br><span class="line">    // the reference here to “this IEnumerable&lt;TSource&gt; source” is</span><br><span class="line">    // the magic sauce that provides access to the extension method Sum</span><br><span class="line">    public static decimal Sum&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source,</span><br><span class="line">                                       Func&lt;TSource, decimal&gt; selector);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，什么使扩展方法与任何其他静态方法不同，又使我们能够在其他类中访问它呢？<br>扩展方法的显着特征是this其第一个参数上的 修饰符。这是“魔术”，可以将其标识为编译器的扩展方法。它修改的参数的类型（在本例中为IEnumerable<tsource>）表示将要实现此方法的类或接口。</tsource></p>
<p>（另一方面，IEnumerable接口名称和Enumerable定义扩展方法的类的名称 之间的相似性并没有什么神奇的。这种相似性只是一个任意的样式选择。）</p>
<p>有了这种理解，我们还可以看到sumAccounts上面介绍的功能可以改为如下实现：</p>
<pre><code>public decimal SumAccounts(IEnumerable&lt;Account&gt; myAccounts) {

    return Enumerable.Sum(myAccounts, a =&gt; a.Balance);

}</code></pre><p>我们本可以以这种方式实现它的事实反而引起了一个问题，为什么根本没有扩展方法？ <a href="http://msdn.microsoft.com/en-us/library/bb383977.aspx" target="_blank" rel="noopener">扩展方法</a>本质上是C＃编程语言的一种便利，它使您可以将方法“添加”到现有类型，而无需创建新的派生类型，重新编译或修改原始类型。</p>
<p>通过using [namespace];在文件顶部包含一条语句，可将扩展方法纳入范围。您需要知道哪个C＃名称空间包含要查找的扩展方法，但是一旦知道要查找的内容，就很容易确定。</p>
<p>当C＃编译器在对象的实例上遇到方法调用，但未找到在引用的对象类上定义的方法时，它将查看范围内的所有扩展方法，以尝试查找与所需方法匹配的扩展方法。签名和类。如果找到一个，它将实例引用作为该扩展方法的第一个参数传递，然后其余参数（如果有）将作为后续参数传递给扩展方法。（如果C＃编译器在范围内找不到任何相应的扩展方法，它将抛出错误。）</p>
<p>扩展方法是C＃编译器中“语法糖”的一个示例，它使我们能够编写（通常）更清晰，更可维护的代码。更清楚的是，如果您知道它们的用法。否则，可能会有些混乱，尤其是在开始时。</p>
<p>尽管使用扩展方法当然具有优势，但它们可能会引起问题，并且对于那些不了解它们或不正确理解它们的开发人员，C＃编程帮助会大声疾呼。当在线查看代码示例或任何其他预先编写的代码时，尤其如此。当此类代码产生编译器错误时（因为它调用的类显然没有定义方法），人们倾向于认为该代码适用于该库的不同版本，或完全适用于不同的库。可能会花费大量时间搜索不存在的新版本或幻影“缺少库”。</p>
<p>当对象上存在具有相同名称的方法时，即使熟悉扩展方法的开发人员仍然偶尔会被捕获，但是其方法签名与扩展方法的方法签名之间存在细微的差异。寻找错别字或错误可能会浪费很多时间。</p>
<p>在C＃库中使用扩展方法变得越来越普遍。除LINQ之外，<a href="http://msdn.microsoft.com/en-us/library/ff648512.aspx" target="_blank" rel="noopener">Unity Application Block</a>和<a href="http://msdn.microsoft.com/en-us/library/hh833994%28v=vs.108%29.aspx" target="_blank" rel="noopener">Web API框架</a>是Microsoft经常使用的两个现代库的示例，它们也使用扩展方法，并且还有许多其他方法。框架越现代，就越有可能包含扩展方法。</p>
<p>当然，您也可以编写自己的扩展方法。请意识到，尽管扩展方法看起来像常规实例方法一样被调用，但这实际上只是一种幻想。特别是，您的扩展方法不能引用它们正在扩展的类的私有成员或受保护成员，因此不能完全替代更传统的类继承。</p>
<h2 id="常见的C＃编程错误＃7：为当前任务使用错误的集合类型"><a href="#常见的C＃编程错误＃7：为当前任务使用错误的集合类型" class="headerlink" title="常见的C＃编程错误＃7：为当前任务使用错误的集合类型"></a>常见的C＃编程错误＃7：为当前任务使用错误的集合类型</h2><p>C＃提供了大量的各种对象集合，具有以下仅为部分清单：</p>
<p>Array，ArrayList，BitArray，BitVector32，Dictionary&lt;K,V&gt;，HashTable，HybridDictionary，List<t>，NameValueCollection，OrderedDictionary，Queue, Queue<t>，SortedList，Stack, Stack<t>，StringCollection，StringDictionary。</t></t></t></p>
<p>尽管在某些情况下，太多的选择和不足的选择一样糟糕，但对于集合对象却并非如此。可用的选项数量肯定可以使您受益。预先花一些时间进行研究，然后为您的目的选择最佳的收集类型。这可能会导致更好的性能和更少的错误空间。</p>
<p>如果有一种收集类型专门针对您拥有的元素类型（例如字符串或位），则倾向于首先使用该元素。当针对特定类型的元素时，实现通常会更高效。</p>
<p>为了利用C＃的类型安全性，通常应首选使用通用接口而不是非通用接口。泛型接口的元素是您在声明对象时指定的类型，而非泛型接口的元素则是object类型。使用非泛型接口时，C＃编译器无法对您的代码进行类型检查。同样，在处理原始值类型的集合时，使用非泛型集合将导致这些类型的重复 <a href="http://msdn.microsoft.com/en-us/library/yz2be5wk.aspx" target="_blank" rel="noopener">装箱/拆箱</a>，与适当类型的泛型集合相比，可能会对性能产生重大的负面影响。</p>
<p>另一个常见的C＃问题是编写您自己的集合对象。但这并不是说它永远不合适，但是通过提供.NET提供的广泛选择，您可以通过使用或扩展已经存在的扩展而不是重新发明轮子来节省大量时间。特别是，用于C＃和CLI的C5通用集合库“开箱即用”提供了各种各样的附加集合，例如持久树数据结构，基于堆的优先级队列，哈希索引数组列表，链接列表等等。</p>
<h2 id="常见的C＃编程错误＃8：忽略释放资源"><a href="#常见的C＃编程错误＃8：忽略释放资源" class="headerlink" title="常见的C＃编程错误＃8：忽略释放资源"></a>常见的C＃编程错误＃8：忽略释放资源</h2><p>CLR环境使用垃圾回收器，因此您无需显式释放为任何对象创建的内存。实际上，您不能。没有C ++ delete运算符或free()这样的函数。但这并不意味着您在使用完所有对象后就可以忘记所有对象。许多类型的对象封装了其他类型的系统资源（例如，磁盘文件，数据库连接，网络套接字等）。保持这些资源开放状态会迅速耗尽系统资源的总数，从而降低性能并最终导致程序错误。</p>
<p>尽管可以在任何C＃类上定义析构函数方法，但析构函数（在C＃中也称为终结器）存在的问题是，您不确定是否会调用它们。它们在将来的不确定时间内被垃圾收集器调用（在单独的线程上，这可能会导致其他问题）。尝试通过强制使用垃圾回收来克服这些限制 GC.Collect()不是<a href="https://orcharddojo.net/orchard-resources/Library/DevelopmentGuidelines/BestPractices/CSharp" target="_blank" rel="noopener">C＃最佳实践</a>，因为这将在线程收集所有符合收集条件的对象时在未知时间内阻塞线程。</p>
<p>这并不是说终结器没有很好的用途，但是以确定性方式释放资源并不是其中之一。相反，当您在文件，网络或数据库连接上进行操作时，您希望在完成使用后立即显式释放基础资源。</p>
<p>在几乎<a href="https://www.toptal.com/c-sharp/how-to-make-an-android-and-ios-app-in-c-on-a-mac" target="_blank" rel="noopener">所有环境中，</a>资源泄漏都是一个问题。但是，C＃提供了一种健壮且易于使用的机制，如果使用该机制，则使泄漏的情况更加罕见。.NET框架定义了IDisposable仅由Dispose()方法组成的接口 。任何实现的对象都IDisposable希望在对象的使用者完成对它的操作后才调用该方法。这导致显式，确定性的资源释放。</p>
<p>如果要在单个代码块的上下文中创建和处理对象，则忘记调用基本上是不可原谅的 Dispose()，因为C＃提供了一条using语句， Dispose()无论代码块如何退出（无论它是例外，return陈述式，或是干脆关闭区块）。是的，这与using前面提到的语句相同，该语句用于在文件顶部包含C＃名称空间。它有第二个完全不相关的目的，许多C＃开发人员都不知道。即，确保Dispose()在退出代码块时对对象进行调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using (FileStream myFile = File.OpenRead(&quot;foo.txt&quot;)) &#123;</span><br><span class="line">  myFile.Read(buffer, 0, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过using 在上面的示例中创建一个块，您可以确定 myFile.Dispose()在处理完文件后立即调用该块，无论是否Read()引发异常。</p>
<h2 id="常见的C＃编程错误＃9：回避异常"><a href="#常见的C＃编程错误＃9：回避异常" class="headerlink" title="常见的C＃编程错误＃9：回避异常"></a>常见的C＃编程错误＃9：回避异常</h2><p>C＃将其类型安全性强制实施到运行时。这使您能够比在C ++等语言中更快地查明C＃中的许多类型的错误，在C＃中错误的类型转换可能导致将任意值分配给对象的字段。但是，程序员再次可以浪费这一强大功能，从而导致C＃问题。之所以陷入这种陷阱，是因为C＃提供了两种不同的处理方式，一种可以引发异常，而另一种则不能。有些人会回避异常路由，认为不必编写try / catch块可以节省一些代码。</p>
<p>例如，以下两种方法可以在C＃中执行显式类型转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// METHOD 1:</span><br><span class="line">// Throws an exception if account can&apos;t be cast to SavingsAccount</span><br><span class="line">SavingsAccount savingsAccount = (SavingsAccount)account;</span><br><span class="line"></span><br><span class="line">// METHOD 2:</span><br><span class="line">// Does NOT throw an exception if account can&apos;t be cast to</span><br><span class="line">// SavingsAccount; will just set savingsAccount to null instead</span><br><span class="line">SavingsAccount savingsAccount = account as SavingsAccount;</span><br></pre></td></tr></table></figure>

<p>使用方法2可能发生的最明显的错误是无法检查返回值。这可能会导致最终的NullReferenceException，该异常可能会在更晚的时间浮出水面，从而更加难以找到问题的根源。相反，方法1会立即抛出一个 InvalidCastException问题，使问题的根源更加明显。<br>而且，即使您记得在方法2中检查过返回值，如果发现它为空，您将怎么办？您编写的方法是否适合报告错误？如果强制转换失败，您还可以尝试其他方法吗？如果不是，那么抛出异常是正确的事，因此您最好让它尽可能地靠近问题的根源。</p>
<p>这是其他两个常见方法对的两个示例，其中一个抛出异常而另一个不抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int.Parse();     // throws exception if argument can’t be parsed</span><br><span class="line">int.TryParse();  // returns a bool to denote whether parse succeeded</span><br><span class="line"></span><br><span class="line">IEnumerable.First();           // throws exception if sequence is empty</span><br><span class="line">IEnumerable.FirstOrDefault();  // returns null/default value if sequence is empty</span><br></pre></td></tr></table></figure>

<p>一些C＃开发人员是如此“异常不利”，以至于他们自动认为不抛出异常的方法是更好的。尽管在某些特定情况下这可能是正确的，但作为概括，它根本不正确。<br>作为一个特定的示例，如果您有替代的合法（例如，默认）操作要发生，那么将产生异常，那么非异常方法可能是一个合法的选择。在这种情况下，写这样的东西确实更好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (int.TryParse(myString, out myInt)) &#123;</span><br><span class="line">  // use myInt</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // use default value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代替：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  myInt = int.Parse(myString);</span><br><span class="line">  // use myInt</span><br><span class="line">&#125; catch (FormatException) &#123;</span><br><span class="line">  // use default value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，认为TryParse必然是“更好”的方法是不正确的。有时候是这种情况，有时候不是。这就是为什么有两种方法可以做到这一点。在您所处的环境中使用正确的方法，请记住，作为开发人员，异常肯定可以成为您的朋友。</p>
<h2 id="常见的C＃编程错误＃10：允许编译器警告累积"><a href="#常见的C＃编程错误＃10：允许编译器警告累积" class="headerlink" title="常见的C＃编程错误＃10：允许编译器警告累积"></a>常见的C＃编程错误＃10：允许编译器警告累积</h2><p>尽管此问题绝对不是C＃特有的，但由于放弃了C＃编译器提供的严格类型检查的优点，因此在C＃编程中尤为突出。</p>
<p>产生警告是有原因的。尽管所有C＃编译器错误都表明您的代码有缺陷，但许多警告也是如此。两者的区别在于，在出现警告的情况下，编译器在发出代码所表示的指令时没有问题。即使这样，它也会发现您的代码有些混乱，并且您的代码有可能无法准确反映您的意图。</p>
<p>就本C＃编程教程而言，一个常见的简单示例是，当您修改算法以消除对正在使用的变量的使用时，却忘记了删除变量声明。该程序将完美运行，但编译器将标记无用的变量声明。程序运行完美的事实导致程序员忽略了修复警告原因的方法。此外，编码人员还利用了Visual Studio功能，该功能使他们可以轻松地将警告隐藏在“错误列表”窗口中，从而使他们只能专注于错误。很快就出现了数十种警告，所有这些警告都被幸福地忽略了（或更糟的是隐藏了）。</p>
<p>但是，如果您迟早忽略这种类型的警告，则类似这样的内容很可能会在您的代码中找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Account &#123;</span><br><span class="line"></span><br><span class="line">    int myId;</span><br><span class="line">    int Id;   // compiler warned you about this, but you didn’t listen!</span><br><span class="line">  </span><br><span class="line">    // Constructor</span><br><span class="line">    Account(int id) &#123;</span><br><span class="line">        this.myId = Id;     // OOPS!</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且，以Intellisense允许我们编写代码的速度，此错误并不像看起来那样不可能。<br>现在，您的程序中出现了严重错误（尽管出于已经说明的原因，编译器仅将其标记为警告），并且根据程序的复杂程度，您可能会浪费大量时间来跟踪该程序。如果您首先注意了此警告，则只需五秒钟即可解决此问题。</p>
<p><strong>记住，如果您正在侦听，C Sharp编译器会为您提供有关代码健壮性的许多有用信息。不要忽略警告。</strong>通常，它们只需要花费几秒钟的时间进行修复，而在发生新问题时修复它们可以节省您的时间。训练自己，使Visual Studio“错误列表”窗口显示“ 0错误，0警告”，以便所有警告使您感到不舒服，无法立即解决它们。</p>
<p>当然，每个规则都有例外。因此，有时您的代码对编译器来说似乎有些混乱，即使这正是您的预期。在极少数情况下，请#pragma warning disable [warning id]仅在周围使用触发警告的代码，并仅使用其触发的警告ID。这将取消该警告，并且仅禁止该警告，因此您仍然可以保持警惕以防出现新的警告。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>C＃是一种功能强大且灵活的语言，具有许多可以极大地提高生产率的机制和范例。但是，就像使用任何软件工具或语言一样，对其功能的有限了解或欣赏有时可能更多的是障碍而不是收益，可能会导致生产环境代码的问题频发。为此，我们需要更多的了解C#语言中那些常见的错误，并不断的持续优化，确保每一行代码都处于可控的状态。</p>
<p>在你的日常开发过程中，你是否也曾经遇到过这些常见错误？赶紧跟你身边的伙伴一起分享吧~</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/03/26/技术/ten-problems-view/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/03/26/技术/ten-problems-view/" class="post-title-link" itemprop="url">15个基本的C＃面试问题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-03-26 08:54:00 / Modified: 08:56:02" itemprop="dateCreated datePublished" datetime="2020-03-26T08:54:00+08:00">2020-03-26</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1、给定一个int数组，编写方法以统计所有偶数的值。</p>
<p>有很多方法可以做到这一点，但是最直接的两种方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static long TotalAllEvenNumbers(int[] intArray) &#123;</span><br><span class="line">  return intArray.Where(i =&gt; i % 2 == 0).Sum(i =&gt; (long)i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static long TotalAllEvenNumbers(int[] intArray) &#123;</span><br><span class="line">  return (from i in intArray where i % 2 == 0 select (long)i).Sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，你还需要注意以下关键：</p>
<ol>
<li><p>你是否利用 C＃语言特性 一行就解决问题。（即，不是使用包含循环，条件语句和累加器的更长篇幅的解决方案）</p>
</li>
<li><p>你是否考虑过溢出的可能性。例如，诸如 </p>
<p>  return intArray.Where(i =&gt; i % 2 == 0).Sum()（与函数的返回类型无关）</p>
</li>
</ol>
<p>这可能一个很”明显”的单行，但这样溢出的可能性很高。虽然上面的答案中使用的转换为long的方法并没有消除这种可能性，但是它使得发生溢出异常的可能性非常小。但请注意，如果你写答案的时候询问数组的预期大小及其成员的大小，则显然你在做这道题目的时候在考虑此溢出问题，这很棒。</p>
<h1 id="2、下面的代码的输出是什么？解释你的答案。"><a href="#2、下面的代码的输出是什么？解释你的答案。" class="headerlink" title="2、下面的代码的输出是什么？解释你的答案。"></a>2、下面的代码的输出是什么？解释你的答案。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">  static String location;</span><br><span class="line">  static DateTime time;</span><br><span class="line"> </span><br><span class="line">  static void Main() &#123;</span><br><span class="line">    Console.WriteLine(location == null ? &quot;location is null&quot; : location);</span><br><span class="line">    Console.WriteLine(time == null ? &quot;time is null&quot; : time.ToString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出将是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location is null</span><br><span class="line">1/1/0001 12:00:00 AM</span><br></pre></td></tr></table></figure>

<p>下面的简短程序的输出是什么？解释你的答案。简短程序的输出是什么？解释你的答案。<br>尽管两个变量都未初始化，但是String是引用类型 、DateTime 是值类型。作为值类型，单位化DateTime变量设置为默认值  公元1年晚上12点，<em>而不是</em> null </p>
<h1 id="3、下面语句中-time-和null-的比较是有效还是无效的"><a href="#3、下面语句中-time-和null-的比较是有效还是无效的" class="headerlink" title="3、下面语句中 time 和null 的比较是有效还是无效的?"></a>3、下面语句中 time 和null 的比较是有效还是无效的?</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static DateTime time;</span><br><span class="line">/* ... */</span><br><span class="line">if (time == null)</span><br><span class="line">&#123;</span><br><span class="line">	/* do something */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有人可能会认为，由于变量永远不可能为null (它被自动初始化为1月1日的值)，所以编译器在比较某个变量时就会报错。具体来说，操作符将其操作数强制转换为不同的允许类型，以便在两边都得到一个通用类型，然后可以对其进行比较。这就是为什么像这样的东西会给你期望的结果(而不是失败或意外的行为，因为操作数是不同的类型):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double x = 5.0;</span><br><span class="line">int y = 5;</span><br><span class="line">Console.WriteLine(x == y);  // outputs true</span><br></pre></td></tr></table></figure>

<p>然而，这有时会导致意外的行为，例如DateTime变量和null的比较。在这种情况下，DateTime变量和null文字都可以转换为可空的。因此，比较这两个值是合法的，即使结果总是假的。</p>
<h1 id="4、给定circle以下类的实例："><a href="#4、给定circle以下类的实例：" class="headerlink" title="4、给定circle以下类的实例："></a>4、给定circle以下类的实例：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Circle &#123;</span><br><span class="line">  private double radius;</span><br><span class="line">  </span><br><span class="line">  public double Calculate(Func&lt;double, double&gt; op) &#123;</span><br><span class="line">    return op(radius);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 简编写代码以计算圆的周长，而无需修改Circle类本身。<br>首选的答案如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">circle.Calculate(r =&gt; 2 * Math.PI * r);</span><br></pre></td></tr></table></figure>

<p>由于我们不能访问对象的私有半径字段，所以我们通过内联传递计算函数，让对象本身计算周长。</p>
<p>许多c#程序员回避(或不理解)函数值参数。虽然在这种情况下，这个例子有点做作，但其目的是看看申请人是否了解如何制定一个调用来计算哪个与方法的定义相匹配。</p>
<p>另外，一个有效的(虽然不那么优雅的)解决方案是从对象中检索半径值本身，然后执行计算结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var radius = circle.Calculate(r =&gt; r);</span><br><span class="line">var circumference = 2 * Math.PI * radius;</span><br></pre></td></tr></table></figure>

<p>无论哪种方式。我们在这里主要寻找的是面试者是否熟悉并理解如何调用Calculate方法。</p>
<h1 id="5、下面程序的输出是什么-解释你的答案。"><a href="#5、下面程序的输出是什么-解释你的答案。" class="headerlink" title="5、下面程序的输出是什么?解释你的答案。"></a>5、下面程序的输出是什么?解释你的答案。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">  private static string result;</span><br><span class="line"> </span><br><span class="line">  static void Main() &#123;</span><br><span class="line">    SaySomething();</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  static async Task&lt;string&gt; SaySomething() &#123;</span><br><span class="line">    await Task.Delay(5);</span><br><span class="line">    result = &quot;Hello world!&quot;;</span><br><span class="line">    return “Something”;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>下面<br>此外，如果我们替换wait task，答案会改变吗? 比如 thread . sleep (5) ? 为什么?的简短</p>
<p>程序的输出是什么？解释你的答案。序的输出是什么？解释你的答案。</p>
<p>回答：</p>
<p>问题第一部分（即带有的代码版本await Task.Delay(5);）的答案是该程序将仅输出一个空行（而不是 “ Hello world！”）。这是因为调用result时仍将未初始化Console.WriteLine。</p>
<p>大多数程序和面向对象的程序员都希望函数return在返回调用函数之前从头到尾执行，或者从语句执行。C＃async函数不是这种情况。它们只执行到第一个await语句，然后返回到调用方。由await（在此例中为Task.Delay）调用的函数是异步执行的，并且该await语句之后的行直到Task.Delay完成（在5毫秒内）之前都不会发出信号。但是，在这段时间内，控制权已经返回给调用者，该调用者Console.WriteLine对尚未初始化的字符串执行该语句。</p>
<p>调用await Task.Delay(5) 可让当前线程继续其正在执行的操作，如果已完成（等待任何等待），则将其返回到线程池。这是异步/等待机制的主要好处。它允许CLR使用线程池中的更少线程来服务更多请求。</p>
<p>异步编程已经变得越来越普遍，因为执行许多活动的网络服务请求或数据库请求的设备越来越普遍。C＃具有一些出色的编程结构，可以极大地简化异步方法的编程任务，并且意识到它们的程序员将产生更好的程序。</p>
<p>关于问题的第二部分，如果将await Task.Delay(5);其替换为Thread.Sleep(5)，则程序将输出Hello world!。一种没有至少一个语句的async方法，其操作就像同步方法一样。也就是说，它将从头到尾执行，或者直到遇到一条语句为止。调用只是阻塞了当前正在运行的线程，因此调用仅将方法的执行时间增加了5毫秒。awaitreturnThread.Sleep()Thread.Sleep(5)SaySomething()</p>
<h1 id="6、下面的程序输出是什么？解释你的答案。"><a href="#6、下面的程序输出是什么？解释你的答案。" class="headerlink" title="6、下面的程序输出是什么？解释你的答案。"></a>6、下面的程序输出是什么？解释你的答案。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">delegate void Printer();</span><br><span class="line"></span><br><span class="line">static void Main()</span><br><span class="line">&#123;</span><br><span class="line">        List&lt;Printer&gt; printers = new List&lt;Printer&gt;();</span><br><span class="line">        int i=0;</span><br><span class="line">        for(; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            printers.Add(delegate &#123; Console.WriteLine(i); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        foreach (var printer in printers)</span><br><span class="line">        &#123;</span><br><span class="line">            printer();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序将把数字10输出十次。</p>
<p>原因如下: 委托被添加到 for循环中l了，而 “引用” (或者“指针”)被存储到i中，而不是值本身。因此，在我们退出循环之后，变量i被设置为10，所以到调用每个委托时，传递给它们的值都是10。</p>
<h1 id="7、是否可以将混合数据类型（例如int，string，float，char）全部存储在一个数组中？"><a href="#7、是否可以将混合数据类型（例如int，string，float，char）全部存储在一个数组中？" class="headerlink" title="7、是否可以将混合数据类型（例如int，string，float，char）全部存储在一个数组中？"></a>7、是否可以将混合数据类型（例如int，string，float，char）全部存储在一个数组中？</h1><p>是! 之所以可以这样做，是因为数组的类型object不仅可以存储任何数据类型，还可以存储类的对象，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">namespace ConsoleApplication8</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        class Customer</span><br><span class="line">        &#123;</span><br><span class="line">            public int ID &#123; get; set; &#125;</span><br><span class="line">            public string Name &#123; get; set; &#125;</span><br><span class="line">            public override string ToString()</span><br><span class="line">            &#123;</span><br><span class="line">                return this.Name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            object[] array = new object[3];</span><br><span class="line">            array[0] = 101;</span><br><span class="line">            array[1] = &quot;C#&quot;;</span><br><span class="line">            Customer c = new Customer();</span><br><span class="line">            c.ID = 55;</span><br><span class="line">            c.Name = &quot;Manish&quot;;</span><br><span class="line">            array[2] = c;</span><br><span class="line">            foreach (object obj in array)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8、比较C＃中的结构和类。他们有什么共同点？它们有何不同？"><a href="#8、比较C＃中的结构和类。他们有什么共同点？它们有何不同？" class="headerlink" title="8、比较C＃中的结构和类。他们有什么共同点？它们有何不同？"></a>8、比较C＃中的结构和类。他们有什么共同点？它们有何不同？</h1><p>C＃中的类和结构确实有一些共同点，即：</p>
<p>他们都是</p>
<p>是复合数据类型</p>
<p>可以包含方法和事件</p>
<p>可以支持接口</p>
<p>但是有许多差异。比较一下：</p>
<p><strong>类：</strong></p>
<p>支持继承</p>
<p>是引用（指针）类型</p>
<p>引用可以为空</p>
<p>每个新实例都有内存开销</p>
<p><strong>结构：</strong></p>
<p>不支持继承</p>
<p>是值类型</p>
<p>按值传递（如整数）</p>
<p>不能有空引用（除非使用了Nullable）</p>
<p>每个新实例没有内存开销（除非“装箱”）</p>
<h1 id="9、这里有一个包含一个或多个-符号的字串，例如"><a href="#9、这里有一个包含一个或多个-符号的字串，例如" class="headerlink" title="9、这里有一个包含一个或多个$符号的字串，例如:"></a>9、这里有一个包含一个或多个$符号的字串，例如:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;foo bar foo $ bar $ foo bar $ &quot;</span><br></pre></td></tr></table></figure>

<p>问题：如何$从给定的字符串中删除第二和第三次出现的？<br>答案：</p>
<p>使用如下正则表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s = &quot;like for example $  you don&apos;t have $  network $  access&quot;;       </span><br><span class="line">Regex rgx = new Regex(&quot;\\$\\s+&quot;);</span><br><span class="line">s = Regex.Replace(s, @&quot;(\$\s+.*?)\$\s+&quot;, &quot;$1$$&quot;);</span><br><span class="line">Console.WriteLine(&quot;string is: &#123;0&#125;&quot;,s);</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>($\s+.*?)-第1组，捕获一个文字$，一个或多个空格字符，然后捕获除换行符以外的任意数量的字符，并尽可能少地捕获到下一个最接近的匹配项</li>
<li>$\s+—单个$符号和一个或多个空格字符</li>
<li>$1引用组1的值，它只是将其插入被替换的字符串中，$$代表替换模式中的$符号。<h1 id="10、下面的程序输出是什么？"><a href="#10、下面的程序输出是什么？" class="headerlink" title="10、下面的程序输出是什么？"></a>10、下面的程序输出是什么？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class TestStatic</span><br><span class="line">    &#123;</span><br><span class="line">        public static int TestValue;</span><br><span class="line"></span><br><span class="line">        public TestStatic()</span><br><span class="line">        &#123;</span><br><span class="line">            if (TestValue == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                TestValue = 5;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        static TestStatic()</span><br><span class="line">        &#123;</span><br><span class="line">            if (TestValue == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                TestValue = 10;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Print()</span><br><span class="line">        &#123;</span><br><span class="line">            if (TestValue == 5)</span><br><span class="line">            &#123;</span><br><span class="line">                TestValue = 6;                </span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;TestValue : &quot; + TestValue);</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> public void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            TestStatic t = new TestStatic();</span><br><span class="line">            t.Print();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>TestValue : 10</p>
<p>在创建该类的任何实例之前，将调用该类的静态构造函数。此处调用的静态构造函数TestValue首先将变量初始化。</p>
<h1 id="11、有没有一种方法可以修改ClassA、以便您可以在调用Main方法时使用参数调用构造函数，而无需创建任何其他新实例ClassA？"><a href="#11、有没有一种方法可以修改ClassA、以便您可以在调用Main方法时使用参数调用构造函数，而无需创建任何其他新实例ClassA？" class="headerlink" title="11、有没有一种方法可以修改ClassA、以便您可以在调用Main方法时使用参数调用构造函数，而无需创建任何其他新实例ClassA？"></a>11、有没有一种方法可以修改ClassA、以便您可以在调用Main方法时使用参数调用构造函数，而无需创建任何其他新实例ClassA？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class ClassA</span><br><span class="line">&#123;</span><br><span class="line">  public ClassA() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  public ClassA(int pValue) &#123;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">  static void Main(string[] args)</span><br><span class="line">  &#123;</span><br><span class="line">    ClassA refA = new ClassA();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回答：</p>
<p>所述this关键字被用于调用其他构造，初始化该类对象。下面是实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ClassA</span><br><span class="line">&#123;</span><br><span class="line">  public ClassA() : this(10)</span><br><span class="line">  &#123; &#125;</span><br><span class="line"></span><br><span class="line">  public ClassA(int pValue)</span><br><span class="line">  &#123;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12、以下代码输出什么？"><a href="#12、以下代码输出什么？" class="headerlink" title="12、以下代码输出什么？"></a>12、以下代码输出什么？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">namespace main1</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;Hello&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (ArgumentNullException)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;A&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;B&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            finally</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;C&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<h1 id="13、描述依赖注入。"><a href="#13、描述依赖注入。" class="headerlink" title="13、描述依赖注入。"></a>13、描述依赖注入。</h1><p>依赖注入是一种使紧密链接的类分离的方式，从而减少了类之间的直接依赖。有多种方法可以实现依赖项注入：</p>
<ol>
<li>构造函数依赖</li>
<li>属性依赖</li>
<li>方法依赖<h1 id="14、编写一个C＃程序，该程序接受以千米为单位的距离，将其转换为米，然后显示结果。"><a href="#14、编写一个C＃程序，该程序接受以千米为单位的距离，将其转换为米，然后显示结果。" class="headerlink" title="14、编写一个C＃程序，该程序接受以千米为单位的距离，将其转换为米，然后显示结果。"></a>14、编写一个C＃程序，该程序接受以千米为单位的距离，将其转换为米，然后显示结果。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using system; </span><br><span class="line"></span><br><span class="line">class abc   </span><br><span class="line"></span><br><span class="line">&#123;   </span><br><span class="line">    public static Void Main()   </span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">            int ndistance, nresult;  </span><br><span class="line">            </span><br><span class="line">        Console.WriteLine(&quot;Enter the distance in kilometers&quot;);  </span><br><span class="line">        </span><br><span class="line">        ndistance = convert.ToInt32(Console.ReadLine());  </span><br><span class="line">        </span><br><span class="line">        nresult = ndistance * 1000;</span><br><span class="line">          </span><br><span class="line">        Console.WriteLine(&quot;Distance in meters: &quot; + nresult);  </span><br><span class="line">        </span><br><span class="line">        Console.ReadLine();  </span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="15、描述装箱和拆箱。并写一个例子。"><a href="#15、描述装箱和拆箱。并写一个例子。" class="headerlink" title="15、描述装箱和拆箱。并写一个例子。"></a>15、描述装箱和拆箱。并写一个例子。</h1><p>装箱是将值类型隐式转换为该类型object或该值类型实现的任何接口类型。将值类型装箱会创建一个包含该值的对象实例，并将其存储在堆中。</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int x = 101;</span><br><span class="line">object o = x;  // boxing value of x into object o</span><br><span class="line"></span><br><span class="line">o = 999;</span><br><span class="line">x = (int)o;    // unboxing value of o into integer x</span><br></pre></td></tr></table></figure>

<h1 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h1><p>面试不仅要基础扎实，更重要的是能解决棘手的技术问题，所以以上这些内容仅供参考。并非每个值得招聘的优秀候选人都能够回答所有问题，也不能确定能够全部回答，就能保证他是一个优秀候选人。归根结底，招聘仍然是一门艺术，一门科学以及许多工作。</p>
<p>如果你有招聘的要求，也欢迎和我们公众号联系，我们有12万的粉丝，相信能在其中找到适合您公司的 .net 候选人。</p>
<p>恭喜你！全部看完，看来您高手只有一步之遥，赶紧转发朋友圈吧！让其他.net 新手也来瞻仰瞻仰。 </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/03/12/技术/how-to-use-httpclient-in-netcore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/03/12/技术/how-to-use-httpclient-in-netcore/" class="post-title-link" itemprop="url">.NET Core的HttpClient连接池管理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-03-12 08:28:00 / Modified: 08:47:58" itemprop="dateCreated datePublished" datetime="2020-03-12T08:28:00+08:00">2020-03-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.stevejgordon.co.uk/httpclient-connection-pooling-in-dotnet-core" target="_blank" rel="noopener">本文来源</a><em>于史蒂夫·戈登（Steve Gordon）是Microsoft MVP，Pluralsight的作者，布莱顿（英国西南部城市）的高级开发人员和社区负责人。他的个人博客为：</em><a href="http://www.stevejgordon.co.uk" target="_blank" rel="noopener">www.stevejgordon.co.uk</a>。</p>
<p><strong><em>导读：</em></strong></p>
<p><em>.NET Core（从2.1开始）中的HttpClient执行连接池和这些连接的生命周期管理。这支持使用单个HttpClient实例，通过单例减少了套接字耗尽的机会，同时确保连接定期重新连接以反映DNS更改。</em></p>
<h2 id="回顾HttpClient的历史"><a href="#回顾HttpClient的历史" class="headerlink" title="回顾HttpClient的历史"></a>回顾HttpClient的历史</h2><p>HttpClient最初是作为NuGet包开始的，该包可以选择包含在.NET Framework 4.0项目中。在.NET Framework 4.5中，它作为BCL（基本类库）的一部分在框中提供。它建立在预先存在的HttpWebRequest实现之上。在.NET Framework中，ServicePoint API可用于控制和管理HTTP连接，包括通过为端点配置ConnectionLeaseTimeout来设置连接寿命。</p>
<p><img src="https://uploader.shimo.im/f/oKgF6qKs4QYLHxcE.png!thumbnail" alt="图片"></p>
<p>.NET Core 1.0最初于2016年6月发布。与.NET Framework中可用的版本相比，此第一个版本的API接口要小得多，主要用于构建ASP.NET Core Web应用程序。由于.NET Core 1.0是HttpClient，因此提供了API。但是，不包括用于HttpWebRequest和ServicePoint的API。.NET Core 1.0中的HttpClient直接建立在使用非托管代码的OS平台API之上，Windows API使用WinHTTP，Linux和Mac使用LibCurl。</p>
<p><img src="https://uploader.shimo.im/f/eQR5yORTYbAFS4Th.png!thumbnail" alt="图片"></p>
<p>到2016年8月，很快就注意到，重新使用HttpClient实例以防止套接字耗尽的建议有一个相当麻烦的副作用。Oren Novotny（译者注：.NET基金会执行董事，.NET团队的项目经理）揭开了一个长期存在的GitHub问题，题为“ <a href="https://github.com/dotnet/corefx/issues/11224" target="_blank" rel="noopener">Singleton HttpClient doesn’t respect DNS changes</a> ”(单例HttpClient不遵守DNS 更改）。在此问题中，人们认识到重新使用单个HttpClient实例将导致连接无限期保持打开状态，因此，DNS更改可能会导致请求失败或与过时的终结点通信。</p>
<p>在.NET Core 2.0中，添加了HttpWebRequest以支持.NET Standard 2.0。它位于HttpClient实现的顶层，这与.NET Framework 4.5+中的工作原理相反。还添加了ServicePoint，尽管它的许多API接口要么要么会抛出未实现的异常，要么根本就没有实现。</p>
<p><img src="https://uploader.shimo.im/f/phP4JDje5EI92hn3.png!thumbnail" alt="图片"></p>
<h2 id="自-NET-CORE-2-1以来的变化"><a href="#自-NET-CORE-2-1以来的变化" class="headerlink" title="自.NET CORE 2.1以来的变化"></a>自.NET CORE 2.1以来的变化</h2><p>这种有问题的行为导致团队不同团队进行了两项工作。ASP.NET团队开始研究<strong>Microsoft.Extensions.Http</strong>包，该包的主要功能是<strong>IHttpClientFactory</strong>。这个针对HttpClient实例自用的工厂还包括基础HttpMessageHandler链的生命周期管理。如果您想了解有关此功能的更多信息，可以查看我的<a href="https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore" target="_blank" rel="noopener">系列博客文章</a>，我将在此介绍。 </p>
<p>IHttpClientFactory功能是作为ASP.NET Core 2.1的一部分发布的，对于许多人来说，这是一个很好的折衷方案，它解决了连接重用以及生命周期管理的问题。</p>
<p>在同一时间范围内，.NET团队正在研究自己的解决方案。该团队也在.NET Core 2.1中发布，在HttpClient的处理程序链的核心引入了一个新的<strong>SocketsHttpHandler</strong>。该处理程序直接建立在Socket API之上，并在托管代码中实现HTTP。这项工作的一部分包括连接池系统以及为这些连接设置最大生存期的能力。此功能将是本文其余部分的重点。</p>
<p><img src="https://uploader.shimo.im/f/1Uacoirz6ok1CYur.png!thumbnail" alt="图片"></p>
<p>但是在开始之前，我想指出，虽然默认情况下从.NET Core 2.1启用了SocketsHttpHandler，但实现仅限于HTTP / 1.1通信。那些需要HTTP / 2的用户必须禁用该功能并使用较旧的处理程序链，该处理程序链像以前一样依赖非托管代码，并且不包括连接池。</p>
<p>幸运的是，.NET Core 3.0中已消除了此限制，并且现在提供了HTTP/2支持。这应该使用基于适合所有对象的SocketsHttpHandler链的HttpClient。</p>
<h2 id="什么是连接池？"><a href="#什么是连接池？" class="headerlink" title="什么是连接池？"></a>什么是连接池？</h2><p>SocketsHttpHandler为每个唯一端点建立连接池，您的应用程序通过HttpClient向该唯一端点发出出站HTTP请求。在对端点的第一个请求上，当不存在现有连接时，将建立一个新的HTTP连接并将其用于该请求。该请求完成后，连接将保持打开状态并返回到池中。</p>
<p>对同一端点的后续请求将尝试从池中找到可用的连接。如果没有可用的连接，并且尚未达到该端点的连接限制，则将建立新的连接。达到连接限制后，请求将保留在队列中，直到连接可以自由发送它们为止。</p>
<p>我一直在研究此实现的内部代码，并可能在以后的博客文章中对池的行为进行更深入的分析。</p>
<h2 id="如何控制连接池"><a href="#如何控制连接池" class="headerlink" title="如何控制连接池"></a>如何控制连接池</h2><p>有三个主要设置可用于控制连接池的行为。</p>
<p><strong>PooledConnectionLifetime</strong>，定义连接在池中保持活动状态的时间。此生存期到期后，将不再为将来的请求而合并或发出连接。</p>
<p><strong>PooledConnectionIdleTimeout</strong>，定义闲置连接在未使用时在池中保留的时间。一旦此生存期到期，空闲连接将被清除并从池中删除。</p>
<p><strong>MaxConnectionsPerServer</strong>，定义每个端点将建立的最大出站连接数。每个端点的连接分别池化。例如，如果最大连接数为2，则您的应用程序将请求发送到两个<a href="http://www.github.com/" target="_blank" rel="noopener">www.github.com</a>和<a href="http://www.google.com/" target="_blank" rel="noopener">www.google.com</a>，总共可能最多有4个打开的连接。</p>
<p>默认情况下，从.NET Core 2.1开始，更高级别的HttpClientHandler将SocketsHttpHandler用作内部处理程序。没有任何自定义配置，将应用连接池的默认设置。</p>
<p>该<strong>PooledConnectionLifetime</strong>默认是无限的，因此，虽然经常使用的请求，连接可能会无限期地保持打开状态。该<strong>PooledConnectionIdleTimeout</strong>默认为2分钟，如果在连接池中长时间未使用将被清理。<strong>MaxConnectionsPerServer</strong>默认为int.MaxValue，因此连接基本上不受限制。</p>
<p>如果希望控制这些值中的任何一个，则可以手动创建SocketsHttpHandler实例，并根据需要进行配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var socketsHandler = new SocketsHttpHandler</span><br><span class="line">	&#123;</span><br><span class="line">	    PooledConnectionLifetime = TimeSpan.FromMinutes(10),</span><br><span class="line">	    PooledConnectionIdleTimeout = TimeSpan.FromMinutes(5),</span><br><span class="line">	    MaxConnectionsPerServer = 10</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	var client = new HttpClient(socketsHandler);</span><br></pre></td></tr></table></figure>

<p>在前面的示例中，对SocketsHttpHandler进行了配置，以使连接将最多在10分钟后停止重新发出并关闭。如果闲置5分钟，则连接将在池的清理过程中被更早地删除。我们还将最大连接数（每个端点）限制为十个。如果我们需要并行发出更多出站请求，则某些请求可能会排队等待，直到10个池中的连接可用为止。<br>要应用处理程序，它将被传递到HttpClient的构造函数中。</p>
<h3 id="测试连接寿命"><a href="#测试连接寿命" class="headerlink" title="测试连接寿命"></a>测试连接寿命</h3><p>以这个示例程序为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">	using System.Net.Http;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace HttpConnectionPoolingSamples</span><br><span class="line">	&#123;</span><br><span class="line">	    class Program</span><br><span class="line">	    &#123;</span><br><span class="line">	        static async Task Main(string[] args)</span><br><span class="line">	        &#123;</span><br><span class="line">	            var ips = await Dns.GetHostAddressesAsync(&quot;www.google.com&quot;);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            foreach (var ipAddress in ips)</span><br><span class="line">	            &#123;</span><br><span class="line">	                Console.WriteLine(ipAddress.MapToIPv4().ToString());</span><br><span class="line">	            &#125;</span><br><span class="line">	            </span><br><span class="line">	            var socketsHandler = new SocketsHttpHandler</span><br><span class="line">	            &#123;</span><br><span class="line">	                PooledConnectionLifetime = TimeSpan.FromMinutes(10),</span><br><span class="line">	                PooledConnectionIdleTimeout = TimeSpan.FromMinutes(5),</span><br><span class="line">	                MaxConnectionsPerServer = 10</span><br><span class="line">	            &#125;;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            var client = new HttpClient(socketsHandler);</span><br><span class="line">	            </span><br><span class="line">	            for (var i = 0; i &lt; 5; i++)</span><br><span class="line">	            &#123;</span><br><span class="line">	                _ = await client.GetAsync(&quot;https://www.google.com&quot;);</span><br><span class="line">	                await Task.Delay(TimeSpan.FromSeconds(2));</span><br><span class="line">	            &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            Console.WriteLine(&quot;Press a key to exit...&quot;);</span><br><span class="line">	            Console.ReadKey();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>使用我们刚刚讨论的设置，此代码依次向同一端点发出5个请求。在每个请求之间，它会暂停两秒钟。该代码还输出从DNS检索到的Google服务器的IPv4地址。我们可以使用此IP地址来查看通过PowerShell中发出的netstat命令对其打开的连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr 216.58.211</span><br></pre></td></tr></table></figure>

<p>在我的例子中，此命令的输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP   192.168.1.139:53040   216.58.211.164:443   ESTABLISHED   20372</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在这种情况下，到远程端点的连接只有1个。在每个请求之后，该连接将返回到池中，因此在发出下一个请求时可以重新使用。<br>如果我们更改连接的生存期，以使它们在1秒后过期，那么我们可以测试这对行为的影响：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">	using System.Net;</span><br><span class="line">	using System.Net.Http;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace HttpConnectionPoolingSamples</span><br><span class="line">	&#123;</span><br><span class="line">	    class Program</span><br><span class="line">	    &#123;</span><br><span class="line">	        static async Task Main(string[] args)</span><br><span class="line">	        &#123;</span><br><span class="line">	            var ips = await Dns.GetHostAddressesAsync(&quot;www.google.com&quot;);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            foreach (var ipAddress in ips)</span><br><span class="line">	            &#123;</span><br><span class="line">	                Console.WriteLine(ipAddress.MapToIPv4().ToString());</span><br><span class="line">	            &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            var socketsHandler = new SocketsHttpHandler</span><br><span class="line">	            &#123;</span><br><span class="line">	                PooledConnectionLifetime = TimeSpan.FromSeconds(1),</span><br><span class="line">	                PooledConnectionIdleTimeout = TimeSpan.FromSeconds(1),</span><br><span class="line">	                MaxConnectionsPerServer = 10</span><br><span class="line">	            &#125;;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            var client = new HttpClient(socketsHandler);</span><br><span class="line">	            </span><br><span class="line">	            for (var i = 0; i &lt; 5; i++)</span><br><span class="line">	            &#123;</span><br><span class="line">	                _ = await client.GetAsync(&quot;https://www.google.com&quot;);</span><br><span class="line">	                await Task.Delay(TimeSpan.FromSeconds(2));</span><br><span class="line">	            &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            Console.WriteLine(&quot;Press a key to exit...&quot;);</span><br><span class="line">	            Console.ReadKey();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TCP   192.168.1.139:53115   216.58.211.164:443   TIME_WAIT     0</span><br><span class="line">TCP   192.168.1.139:53116   216.58.211.164:443   TIME_WAIT     0</span><br><span class="line">TCP   192.168.1.139:53118   216.58.211.164:443   TIME_WAIT     0</span><br><span class="line">TCP   192.168.1.139:53120   216.58.211.164:443   TIME_WAIT     0</span><br><span class="line">TCP   192.168.1.139:53121   216.58.211.164:443   ESTABLISHED   25948</span><br></pre></td></tr></table></figure>

<p>在这种情况下，我们可以看到使用了五个连接。其中的前四个在1秒后从池中删除，因此无法在下一个请求中重复使用。结果，每个请求都打开了一个新连接。现在，原始连接处于TIME_WAIT状态，并且操作系统无法将其重新用于新的出站连接。最终连接显示为ESTABLISHED，因为我在它过期之前就抓住了它。</p>
<h3 id="测试最大连接数"><a href="#测试最大连接数" class="headerlink" title="测试最大连接数"></a>测试最大连接数</h3><p>对于下一个测试用例，我们将使用以下程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">	using System.Diagnostics;</span><br><span class="line">	using System.Linq;</span><br><span class="line">	using System.Net;</span><br><span class="line">	using System.Net.Http;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace HttpConnectionPoolingSamples</span><br><span class="line">	&#123;</span><br><span class="line">	    class Program</span><br><span class="line">	    &#123;</span><br><span class="line">	        static async Task Main(string[] args)</span><br><span class="line">	        &#123;</span><br><span class="line">	            var ips = await Dns.GetHostAddressesAsync(&quot;www.google.com&quot;);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            foreach (var ipAddress in ips)</span><br><span class="line">	            &#123;</span><br><span class="line">	                Console.WriteLine(ipAddress.MapToIPv4().ToString());</span><br><span class="line">	            &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            var socketsHandler = new SocketsHttpHandler</span><br><span class="line">	            &#123;</span><br><span class="line">	                PooledConnectionLifetime = TimeSpan.FromSeconds(60),</span><br><span class="line">	                PooledConnectionIdleTimeout = TimeSpan.FromMinutes(20),</span><br><span class="line">	                MaxConnectionsPerServer = 2</span><br><span class="line">	            &#125;;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            var client = new HttpClient(socketsHandler);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            var sw = Stopwatch.StartNew();</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            var tasks = Enumerable.Range(0, 200).Select(i =&gt; client.GetAsync(&quot;https://www.google.com&quot;));</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            await Task.WhenAll(tasks);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            sw.Stop();</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            Console.WriteLine($&quot;&#123;sw.ElapsedMilliseconds&#125;ms taken for 200 requests&quot;);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            Console.WriteLine(&quot;Press a key to exit...&quot;);</span><br><span class="line">	            Console.ReadKey();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>该代码将MaxConnectionsPerServer限制为2。然后启动200个任务，每个任务都向同一端点发出HTTP请求。这些任务将同时运行。所有请求竞争所花费的时间将写入控制台。<br>在我的机器上运行此命令后，输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8013ms taken for 200 requests</span><br></pre></td></tr></table></figure>

<p>如果使用netstat查看连接，则根据定义的限制，我们可以看到两个已建立的连接。<br>已建立</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP   192.168.1.139:52780   216.58.204.36:443   ESTABLISHED   16076</span><br><span class="line">TCP   192.168.1.139:52780   216.58.204.36:443   ESTABLISHED   16076</span><br></pre></td></tr></table></figure>

<p>如果我们调整此代码以允许MaxConnectionsPerServer = 10，则可以重新运行该应用程序。这次所花费的时间减少了大约4倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2123ms taken for 200 requests</span><br></pre></td></tr></table></figure>

<p>当我们查看连接时，我们可以看到确实建立了十个连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TCP   192.168.1.139:52798   216.58.204.36:443   ESTABLISHED   30856</span><br><span class="line">TCP   192.168.1.139:52799   216.58.204.36:443   ESTABLISHED   30856</span><br><span class="line">TCP   192.168.1.139:52800   216.58.204.36:443   ESTABLISHED   30856</span><br><span class="line">TCP   192.168.1.139:52801   216.58.204.36:443   ESTABLISHED   30856</span><br><span class="line">TCP   192.168.1.139:52802   216.58.204.36:443   ESTABLISHED   30856</span><br><span class="line">TCP   192.168.1.139:52803   216.58.204.36:443   ESTABLISHED   30856</span><br><span class="line">TCP   192.168.1.139:52804   216.58.204.36:443   ESTABLISHED   30856</span><br><span class="line">TCP   192.168.1.139:52805   216.58.204.36:443   ESTABLISHED   30856</span><br><span class="line">TCP   192.168.1.139:52806   216.58.204.36:443   ESTABLISHED   30856</span><br><span class="line">TCP   192.168.1.139:52807   216.58.204.36:443   ESTABLISHED   30856</span><br></pre></td></tr></table></figure>

<p>结果，提高了吞吐量。我们允许更多的出站连接，因此可以更快地处理请求队列，并通过额外的连接并行发出更多请求。</p>
<h2 id="我还需要IHttpClientFactory吗？"><a href="#我还需要IHttpClientFactory吗？" class="headerlink" title="我还需要IHttpClientFactory吗？"></a>我还需要IHttpClientFactory吗？</h2><p>这是一个非常合乎逻辑的问题，可能是该帖子的结果。IHttpClientFactory的功能之一是HttpMessageHandler链的生命周期管理，因此也是基础连接的生命周期管理。有了HttpClient和SocketsHttpHandler可以达到相同效果的知识，我们是否需要使用IHttpClientFactory？</p>
<p>我的观点是，IHttpClientFactory除了帮助管理连接生存期外还有其他好处，并且在发出出站HTTP请求时仍然可以增加价值。它提供了一种很好的模式，可以使用<a href="https://www.stevejgordon.co.uk/httpclientfactory-named-typed-clients-aspnetcore" target="_blank" rel="noopener">命名或类型化的客户端方法</a>为HttpClient实例定义逻辑配置。后来有类型的客户是我个人的最爱。</p>
<p>这些逻辑客户端的流畅配置方法还使<a href="https://www.stevejgordon.co.uk/httpclientfactory-aspnetcore-outgoing-request-middleware-pipeline-delegatinghandlers" target="_blank" rel="noopener">定制的DelegatingHandlers</a>与客户端的使用非常简单明了。这包括ASP.NET团队对该方法的扩展，以便<a href="https://www.stevejgordon.co.uk/httpclientfactory-using-polly-for-transient-fault-handling" target="_blank" rel="noopener">与Polly集成，</a>以便轻松地对出站请求应用弹性和瞬时故障处理。</p>
<p>即使没有生命周期管理，我也希望在将来的一段时间内将工厂用于我的应用程序。根据我在网上看到的讨论，很有可能在将来的版本中，寿命管理功能将从IHttpClientFactory中弃用和/或删除，因为它解决的问题不再适用。</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在本文中，我们看到自从.NET Core 2.1发布以来，使用默认的SocketsHttpHandler实现时，将维护连接池。使用池的设置，我们可以控制连接的生存期并限制每个端点可能创建的出站连接的数量。</p>
<p>我们还讨论了IHttpClientFactory不仅具有连接生存期管理的优点和功能，因此仍然是一个有价值的工具。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/03/11/随笔/如何快速融入团队并成为团队核心（九）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/03/11/随笔/如何快速融入团队并成为团队核心（九）/" class="post-title-link" itemprop="url">如何快速融入团队并成为团队核心(九)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-03-11 21:22:00" itemprop="dateCreated datePublished" datetime="2020-03-11T21:22:00+08:00">2020-03-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-03-12 08:43:53" itemprop="dateModified" datetime="2020-03-12T08:43:53+08:00">2020-03-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随笔/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>不知从何时起，这个系列的文章已经偏离标题越来越远了~</p>
<p>大概，如果要融入团队，其实或许只需做好跟周围同事的关系，几乎已经能够很好的融入了，但是如果要成为团队精英呢？我们难免得多做一些额外的努力，例如，了解价值观、试图融入企业文化，试图提高自己的工作效率，合理的支配自己的时间，尤其还有一点，就是做好目标管理。</p>
<h1 id="一、画饼吃不下"><a href="#一、画饼吃不下" class="headerlink" title="一、画饼吃不下"></a>一、画饼吃不下</h1><p>某种意义上讲，决定我们能否成为高效开发者的核心关键是我们对于目标的管理能力，某种意义上讲，一个企业是否能够在群狼环伺的商界混得如鱼得水，中高层管理者是否能够理解和传达老板的意图和目标，基层能否理解老板的目标，并高效的执行，毋庸置疑都是至关重要的环节。</p>
<p>当然，大部分情况我们不用直接理解老板的目标，他们只需按照领导的指示，在自己的职责范围内把事情干好，就足够优秀了。但是事实上有时候我们会更加重视流程本身，往往忽略了对于目标的理解。甚至有时候公司老板喜欢站在更高的层面，画一个很大的饼，结果到具体执行时，给执行工作的人带来的巨大困扰。</p>
<p>“饼太大，吃不下”。一旦老板习惯于画饼，或许他自己也会陷入一个奇怪的状态，他会想，这件事情究竟是干呢，还是不干呢，嗯，我先吹出去，说不定有人会干，而且还能干出什么东西来着。但是作为中高层管理者显然更尴尬，我干了会不会犯错，犯错了会不会打板子，那我还是不干吧？一个长期画饼的老板，底下一定有一群听惯了“狼来了”谎话的中高层，他们已经习惯于对老板夸的海口无动于衷，最终导致了中高层管理者和老板之间的隔阂。</p>
<h1 id="二、信息的层层递减"><a href="#二、信息的层层递减" class="headerlink" title="二、信息的层层递减"></a>二、信息的层层递减</h1><p>当然，大部分情况下，中高层管理者都经历离时间和战火的历练，总是能够从老板的一言一行中理解领导的需求，但是即便如此，也容易产生返工的现象。</p>
<p>事实上，我们在工作过程中总是会遇到返工，这种情况发生的根源也同样来源于我们对于目标的误读，甚至曲解了领导对于工作的原意。返工不仅仅会浪费我们的时间，也同样会极大的打击我们对于工作的信心，甚至会让我们对于职场发展的前途产生迷茫。</p>
<p>造成目标识别错误的原因往往是沟通因素，如信息传递漏斗所描述的：</p>
<p><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/9-1.png" alt="图片"></p>
<p>在这个环节中，信息是层层递减的，我们能表达出我们想表达的内容的百分之八十，听众能听到我们想表达信息的百分之六十，而观众所能理解的，只有我们想表达信息的百分之四十。</p>
<p> 除此之外，假设我们的任务来源于其他人的二手信息，那么这种层层递减的边际效应或许也将更加明显。尤其是有时候领导喜欢说话只说一半，并指望下属能够从他的几句话中揣摩出他的全部心意，那这种效果或许自然而然就会更差了。</p>
<h1 id="三、目标识别和执行"><a href="#三、目标识别和执行" class="headerlink" title="三、目标识别和执行"></a>三、目标识别和执行</h1><p>所以我们显然不能把期望完全寄托在理解对方的沟通上，而是需要辅以其他手段使得我们能够更好的将领导的需求落实下来。</p>
<p>1、记录：我们需要记录从领导下达的指令的内容，确保在信息传输过程中尽可能的减少误误解。</p>
<p>2、适当的过滤和提取：从信息中，要提取与目标相关的内容，去掉与目标无关的噪声干扰，以便减轻对于目标识别的复杂程度。</p>
<p>3、重聚：从信息中按照任务的相关性，建立必要的链接，并使得目标得以形成体系。</p>
<p>4、反馈：尽早与领导反馈，以便确保自己的目标符合对方的意图，并根据领导的指示对目标进行修正，例如对时间节点进行细化，或者领导是不是已经有了下一步工作安排等等。</p>
<p>我们就识别到了可以执行的具体目标，这样在进行任务执行时，也便于我们对于目标的解读。</p>
<p>基于识别到的目标，我们可以辅以一些管理学的手段，例如运用计划、执行、检查、纠偏的PDCA工具，让我们在执行过程中不断的进行修正，以便使我们能够在任务的每个执行过程中都能建立起反馈的机制，同时有能让领导能够及时的参与其中，使得任务更加完整的符合领导的预期。</p>
<p><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/9-2.png" alt="图片"></p>
<h1 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h1><p>随着互联网企业开始实施基于OKR的管理方法，对大家来说或多或少造成了一些影响，不过显然，建立一个更加完整的目标管理机制，对我们确实会带来一些好处，最起码的少返工就已经是一个不错的进步了。</p>
<p><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/9-3.png" alt="图片"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/03/11/随笔/如何快速融入团队并成为团队核心（八）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/03/11/随笔/如何快速融入团队并成为团队核心（八）/" class="post-title-link" itemprop="url">如何快速融入团队并成为团队核心(八)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-03-11 21:22:00 / Modified: 21:30:51" itemprop="dateCreated datePublished" datetime="2020-03-11T21:22:00+08:00">2020-03-11</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随笔/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>感慨时间流逝，韶华易老似乎是我们与生俱来的焦虑，仿佛每当过年的时候总会感觉，呀，我这一年似乎什么都没干呀。</p>
<p>你看，连孔子都说：逝者如斯夫，不舍昼夜。所以他老人家是不是也很焦虑。。</p>
<p>然而我们的时间都去哪里了？</p>
<p><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/8-1.jpeg" alt="图片"></p>
<p>尤其是作为互联网开发者的我们，其实更加明显，有时候上午9点到公司，然后随便写几行代码，就到中午了，然后再下午又调几个昨天写的bug，于是，这一天就似乎这么结束了。</p>
<p>我也曾经列过一个清单，汇总了当天的工作分配情况，其中，修复bug占比和沟通所占的比重最多，大概表明作为开发者的我代码质量确实是个问题。</p>
<p><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/8-2.png" alt="图片">      </p>
<p>不过撇开代码质量这个因素不说，其实也反应了主观上在进行时间管控方面确实存在一些问题，这些问题也许平时看起来不明显，但是一旦我们开始进行记录，就会觉得比较明显。</p>
<p>例如，层出不穷的产品需求沟通、缺陷跟进、日常的会议和其他工作安排，这些看起来其实是非常常见的具体的事件，原本属于开发过程中正常的沟通，但是如果缺乏有效的节制，依然会造成效率的降低。毕竟我们的大脑进行任务的切换本身也是需要时间的，有时候如果正在进行某些需要消耗脑力的工作时，一旦被打断了，或许需要花更长的时间才能弥补过来。</p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>当然有时候我们可能会习惯于白天被人打断，而把工作拖到晚上再花时间来弥补，或许这也是程序员们不得不辛苦的选择996这种不太合理的作息制度的一个客观原因。</p>
<p>坦率而言，时间对每个人来说都是公平的，每天24个小时分配得其实已经够合理了，但是同样的时间，不同的人却能做出不同的成绩；例如，我最近在阅读《程序员的三门课》，就深深的感觉同样是在阿里巴巴集团工作的张洪亮，从2015年加入阿里巴巴，到目前短短五年时间，我们都可以看到他的博客，几年时间写了几百篇博客，显然这些博客都来源于他日常工作中的实际场景，这也说明他不仅仅能够把代码写得很完美，也同样能够把自己的业余时间安排得非常饱满、同样的选择职场奋斗，为何他能够把时间安排得如此妥当呢。</p>
<p>这确实是一个值得大家深思的问题。</p>
<p>我最近开始有意识的管理自己的时间，例如我发现我的iphone中显示了一组数据：</p>
<p>1、每天抬起手机61次。</p>
<p>2、使用微信一小时。</p>
<p>3、屏幕使用时长1个半小时。</p>
<p>我观察了我一周中，最少的屏幕使用时间差不多也是一小时多一点，多的一天大概是将近两小时，这实际上是在工作时间记录的时间，当然，撇开每天在地铁上上下班（约一个半小时）的日常的手机使用情况，依然每天有将近一个小时的时间看起来似乎是不合理的支配了。</p>
<p>我来粗略估算一下自己的时间粒度，大概是这样的：</p>
<p>1、休息时间，每天8个小时。这个时间包含晚上休息和中午休息的时间。</p>
<p>2、工作通勤路上的时间：1个半小时。</p>
<p>3、每天的用餐时间：30分钟。</p>
<p>4、每天的如厕时间，20分钟。</p>
<p>5、工作时间：8-9小时。</p>
<p>6、每天的阅读学习和其他时间：约两小时。</p>
<p>没错，以上数据之和不等于24小时，说明还有一些时间损耗看起来不明显，但累积起来也同样惊人。当然实际上工作时间看起来有8-9小时，实际上真的能实现满打满算的工作这么长的时间么，这大概是个自欺欺人的问题，很惭愧的说大概在这个工作时段，有那么一段时间，或者说不短于一个半小时，或许是在各种聊天工具间来回切换。</p>
<p><img src="https://raw.githubusercontent.com/farway000/image.techq.xyz/master/images/how-to-become-a-super-star/8-3.png" alt="图片"></p>
<p>（以上数据过于真实，请大家尽管批评吧。）</p>
<p>所以，我曾经看过，越是成功的人士，越善于合理的利用时间，例如，像王健林同志，据说已经把时间安排在15分钟这个粒度。而目前的我，大概离一个小时这个粒度都还有一点困难，所以离成功还差十万八千里也不是没有理由的。</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p>作为一位技术从业者，是否能够合理的支配自己的时间确实是非常重要的事情，从某种意义上来说，能够每天花10个小时，或者8个小时全付身心的投入到工作中，其实已经足够完成许多任务了。</p>
<p>个人认为，我们大概可以做以下这些工作来更好的实现自己对时间的支配：</p>
<p>1、对自己每天的实际时间支配情况进行总结，分析时间的主要分布情况，并以清单的形式列入，以便自己有目的性的进行改善。</p>
<p>2、难免需要一些断舍离，比如关闭某些app的推送通知，将非工作用的聊天工具，从windows桌面右下角的图标中隐藏，避免对工作造成的干扰，然后每天花一段特定的时间来处理非工作场景下的消息。</p>
<p>3、每天早上简单的概述自己今天需要完成的工作，并预估工作所需要的时间，适当的给自己一些相对较长的时间，在这个时间段内，尽量避免外界因素的干扰。每天早上和下午工作开始一小时后的是能够利用的长块时间，而且效率也比较高，尽量将重要性工作安排在这样的时间段进行，尽量避免在这样的时间段开会，以免降低工作效率。（例如，微软有一个go dark的机制，允许在某些特殊的情况下与外界因素隔离开，踏踏实实的沉浸到写代码中）。</p>
<p>4、合理的利用等待期。在同时需要处理多个任务时，有的任务往往由于各种条件或资源尚不具备，这会需要花不少时间来等待，如果我们将置于等待期的任务提前规划、也是一种不错的方法。</p>
<p>在《卓有成效的管理者》这本书中，将会管理自己的时间作为一个优秀管理者开始其管理工作的第一步，只有开始学会梳理自己的时间和管理自己的时间，才能成为合适的管理者，这一点我觉得非常有道理。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/02/23/技术/how-to-use-restfulapi-in-netcore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/23/技术/how-to-use-restfulapi-in-netcore/" class="post-title-link" itemprop="url">一步一步的构建整洁、可维护的RESTful APIs</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-02-23 22:24:00 / Modified: 22:24:23" itemprop="dateCreated datePublished" datetime="2020-02-23T22:24:00+08:00">2020-02-23</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>译者荐语：利用周末的时间，本人拜读了长沙.NET技术社区翻译的技术文章《<a href="http://techq.club/2019/08/02/%E6%8A%80%E6%9C%AF/Microsoft%20REST%20API%E6%8C%87%E5%8D%97/" target="_blank" rel="noopener">微软RESTFul API指南</a>》，打算按照步骤写一个完整的教程，后来无意中看到了这篇文章，与我要写的主题有不少相似之处，特意翻译下来。前方高能。</p>
<p><img src="https://uploader.shimo.im/f/U68C9NmcWwwWHATD.png!thumbnail" alt="图片">一步一步的构建整洁、可维护的RESTful APIs</p>
<p><a href="https://www.techq.xyz/2020/02/23/%E6%8A%80%E6%9C%AF/WPF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%A6%82%E8%BF%B0/" target="_blank" rel="noopener">查看原文</a></p>
<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>RESTful不是一个新名词。它是一种架构风格，这种架构风格使用Web服务从客户端应用程序接收数据和向客户端应用程序发送数据。其目标是集中不同客户端应用程序将使用的数据。</p>
<p>选择正确的工具来编写RESTful服务至关重要，因为我们需要关注可伸缩性，维护，文档以及所有其他相关方面。在<a href="https://docs.microsoft.com/en-us/aspnet/" target="_blank" rel="noopener">ASP.NET</a> Core为我们提供了一个功能强大、易于使用的API，使用这些API将很好的实现这个目标。</p>
<p>在本文中，我将向您展示如何使用ASP.NET Core框架为“几乎”现实世界的场景编写结构良好的RESTful API。我将详细介绍常见的模式和策略以简化开发过程。</p>
<p>我还将向您展示如何集成通用框架和库，例如<a href="https://docs.microsoft.com/en-us/ef/core/" target="_blank" rel="noopener">Entity Framework Core</a>和<a href="https://automapper.org/" target="_blank" rel="noopener">AutoMapper</a>，以提供必要的功能。</p>
<h1 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a><strong>先决条件</strong></h1><p>我希望您了解面向对象的编程概念。</p>
<p>即使我将介绍<a href="https://docs.microsoft.com/en-us/dotnet/csharp/" target="_blank" rel="noopener">C＃编程语言</a>的许多细节，我还是建议您具有该主题的基本知识。</p>
<p>我还假设您知道什么是REST，<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" target="_blank" rel="noopener">HTTP协议</a>如何工作，什么是API端点以及什么是<a href="https://www.json.org/" target="_blank" rel="noopener">JSON</a>。<a href="https://medium.freecodecamp.org/restful-services-part-i-http-in-a-nutshell-aab3bfedd131" target="_blank" rel="noopener">这是</a>关于此主题<a href="https://medium.freecodecamp.org/restful-services-part-i-http-in-a-nutshell-aab3bfedd131" target="_blank" rel="noopener">的出色的入门教程</a>。最后，您需要了解关系数据库的工作原理。</p>
<p>要与我一起编码，您将必须安装<a href="https://dotnet.microsoft.com/download" target="_blank" rel="noopener">.NET Core 2.2</a>以及<a href="https://www.getpostman.com/" target="_blank" rel="noopener">Postman</a>（我将用来测试API的工具）。我建议您使用诸如<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code之</a>类的代码编辑器来开发API。选择您喜欢的代码编辑器。如果选择Visual Studio Code作为您的代码编辑器，建议您安装<a href="https://code.visualstudio.com/docs/languages/csharp" target="_blank" rel="noopener">C＃扩展</a>以更好地突出显示代码。</p>
<p>您可以在本文末尾找到该API的Github的链接，以检查最终结果。</p>
<h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h1><p>让我们为一家超市编写一个虚构的Web API。假设我们必须实现以下范围：</p>
<ul>
<li><em>创建一个RESTful服务，该服务允许客户端应用程序管理超市的产品目录。它需要公开端点以创建，读取，编辑和删除产品类别，例如乳制品和化妆品，还需要管理这些类别的产品。</em></li>
<li><em>对于类别，我们需要存储其名称。对于产品，我们需要存储其名称，度量单位（例如，按重量测量的产品为KG），包装中的数量（例如，如果一包饼干是10，则为10）及其各自的类别。</em></li>
</ul>
<p>为了简化示例，我将不处理库存产品，产品运输，安全性和任何其他功能。这个范围足以向您展示ASP.NET Core的工作方式。</p>
<p>要开发此服务，我们基本上需要两个API 端点（译者注：指控制器）：一个用于管理类别，一个用于管理产品。在JSON通讯方面，我们可以认为响应如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">API endpoint: /api/categories</span><br><span class="line">JSON Response (for GET requests):</span><br><span class="line">&#123;</span><br><span class="line">  [</span><br><span class="line">    &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Fruits and Vegetables&quot; &#125;,</span><br><span class="line">    &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;Breads&quot; &#125;,</span><br><span class="line">    … // Other categories</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">API endpoint: /api/products</span><br><span class="line">JSON Response (for GET requests):</span><br><span class="line">&#123;</span><br><span class="line">  [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: 1,</span><br><span class="line">      &quot;name&quot;: &quot;Sugar&quot;,</span><br><span class="line">      &quot;quantityInPackage&quot;: 1,</span><br><span class="line">      &quot;unitOfMeasurement&quot;: &quot;KG&quot;</span><br><span class="line">      &quot;category&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: 3,</span><br><span class="line">        &quot;name&quot;: &quot;Sugar&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    … // Other products</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们开始编写应用程序。</p>
<h1 id="第1步-创建API"><a href="#第1步-创建API" class="headerlink" title="第1步-创建API"></a><strong>第1步-创建API</strong></h1><p>首先，我们必须为Web服务创建文件夹结构，然后我们必须使用<a href="https://docs.microsoft.com/en-us/dotnet/core/tools/?tabs=netcore2x" target="_blank" rel="noopener">.NET CLI工具</a>来构建基本的Web API。打开终端或命令提示符（取决于您使用的操作系统），并依次键入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir src/Supermarket.API</span><br><span class="line"></span><br><span class="line">cd src/Supermarket.API</span><br><span class="line"></span><br><span class="line">dotnet new webapi</span><br></pre></td></tr></table></figure>

<p>前两个命令只是为API创建一个新目录，然后将当前位置更改为新文件夹。最后一个遵循Web API模板生成一个新项目，这是我们正在开发的应用程序。您可以阅读有关这些命令和其他项目模板的更多信息，并可以通过<a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new?tabs=netcore21" target="_blank" rel="noopener">检查此链接</a>来生成其他项目模板。<br>现在，新目录将具有以下结构：</p>
<p><img src="https://uploader.shimo.im/f/LuICwkhqHDsD5RcN.png!thumbnail" alt="图片"></p>
<p>项目结构</p>
<h2 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h2><p>ASP.NET Core应用程序由在类中配置的一组<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-2.2" target="_blank" rel="noopener">中间件</a>（应用程序流水线中的小块应用程序，用于处理请求和响应）组成Startup。如果您以前已经使用过<a href="https://expressjs.com/" target="_blank" rel="noopener">Express.js</a>之类的框架，那么这个概念对您来说并不是什么新鲜事物。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Startup</span><br><span class="line">	&#123;</span><br><span class="line">	    public Startup(IConfiguration configuration)</span><br><span class="line">	    &#123;</span><br><span class="line">	        Configuration = configuration;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    public IConfiguration Configuration &#123; get; &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    // This method gets called by the runtime. Use this method to add services to the container.</span><br><span class="line">	    public void ConfigureServices(IServiceCollection services)</span><br><span class="line">	    &#123;</span><br><span class="line">	        services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span><br><span class="line">	    public void Configure(IApplicationBuilder app, IHostingEnvironment env)</span><br><span class="line">	    &#123;</span><br><span class="line">	        if (env.IsDevelopment())</span><br><span class="line">	        &#123;</span><br><span class="line">	            app.UseDeveloperExceptionPage();</span><br><span class="line">	        &#125;</span><br><span class="line">	        else</span><br><span class="line">	        &#123;</span><br><span class="line">	            // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.</span><br><span class="line">	            app.UseHsts();</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        app.UseHttpsRedirection();</span><br><span class="line">	        app.UseMvc();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>当应用程序启动时，将调用类中的Main** **方法Program。它使用启动配置创建默认的Web主机，通过HTTP通过特定端口（默认情况下，HTTP为5000，HTTPS为5001）公开应用程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">namespace Supermarket.API</span><br><span class="line">	&#123;</span><br><span class="line">	    public class Program</span><br><span class="line">	    &#123;</span><br><span class="line">	        public static void Main(string[] args)</span><br><span class="line">	        &#123;</span><br><span class="line">	            CreateWebHostBuilder(args).Build().Run();</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;</span><br><span class="line">	            WebHost.CreateDefaultBuilder(args)</span><br><span class="line">	                .UseStartup&lt;Startup&gt;();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>看一下文件夹中的ValuesController类Controllers。它公开了API通过路由接收请求时将调用的方法/api/values。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;api/[controller]&quot;)]</span><br><span class="line">	[ApiController]</span><br><span class="line">	public class ValuesController : ControllerBase</span><br><span class="line">	&#123;</span><br><span class="line">	    // GET api/values</span><br><span class="line">	    [HttpGet]</span><br><span class="line">	    public ActionResult&lt;IEnumerable&lt;string&gt;&gt; Get()</span><br><span class="line">	    &#123;</span><br><span class="line">	        return new string[] &#123; &quot;value1&quot;, &quot;value2&quot; &#125;;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    // GET api/values/5</span><br><span class="line">	    [HttpGet(&quot;&#123;id&#125;&quot;)]</span><br><span class="line">	    public ActionResult&lt;string&gt; Get(int id)</span><br><span class="line">	    &#123;</span><br><span class="line">	        return &quot;value&quot;;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    // POST api/values</span><br><span class="line">	    [HttpPost]</span><br><span class="line">	    public void Post([FromBody] string value)</span><br><span class="line">	    &#123; </span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    // PUT api/values/5</span><br><span class="line">	    [HttpPut(&quot;&#123;id&#125;&quot;)]</span><br><span class="line">	    public void Put(int id, [FromBody] string value)</span><br><span class="line">	    &#123;   </span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    // DELETE api/values/5</span><br><span class="line">	    [HttpDelete(&quot;&#123;id&#125;&quot;)]</span><br><span class="line">	    public void Delete(int id)</span><br><span class="line">	    &#123;  </span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>如果您不了解此代码的某些部分，请不要担心。在开发必要的API端点时，我将详细介绍每一个。现在，只需删除此类，因为我们不会使用它。</p>
<h1 id="第2步-创建领域模型"><a href="#第2步-创建领域模型" class="headerlink" title="第2步-创建领域模型"></a><strong>第2步-创建领域模型</strong></h1><p>我将应用一些设计概念，以使应用程序简单易维护。</p>
<p>编写可以由您自己理解和维护的代码并不难，但是您必须牢记您将成为团队的一部分。如果您不注意如何编写代码，那么结果将是一个庞然大物，这将使您和您的团队成员头痛不已。听起来很极端吧？但是相信我，这就是事实。</p>
<p><img src="https://uploader.shimo.im/f/vMGZaW8zLiA39wxb.png!thumbnail" alt="图片"></p>
<p>衡量好代码的标准是WTF的频率。原图来自<a href="https://www.flickr.com/photos/smitty/" target="_blank" rel="noopener">smitty42</a>，发表于<a href="https://www.flickr.com/photos/smitty/2245445147" target="_blank" rel="noopener">filckr</a>。该图遵循CC-BY-2.0。</p>
<p>在Supermarket.API目录中，创建一个名为的新文件夹Domain。在新的领域文件夹中，创建另一个名为的文件夹Models。我们必须添加到此文件夹的第一个模型是Category。最初，它将是一个简单的<a href="https://en.wikipedia.org/wiki/Plain_old_CLR_object" target="_blank" rel="noopener">Plain Old CLR Object（POCO）</a>类。这意味着该类将仅具有描述其基本信息的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Domain.Models</span><br><span class="line">	&#123;</span><br><span class="line">	    public class Category</span><br><span class="line">	    &#123;</span><br><span class="line">	        public int Id &#123; get; set; &#125;</span><br><span class="line">	        public string Name &#123; get; set; &#125;</span><br><span class="line">	        public IList&lt;Product&gt; Products &#123; get; set; &#125; = new List&lt;Product&gt;();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>该类具有一个Id** <strong>属性（用于标识类别）和一个Name属性。以及一个Products</strong> <strong>属性。最后一个属性将由</strong>Entity Framework Core使用**，大多数ASP.NET Core应用程序使用ORM将数据持久化到数据库中，以映射类别和产品之间的关系。由于类别具有许多相关产品，因此在面向对象的编程方面也具有合理的思维能力。<br>我们还必须创建产品模型。在同一文件夹中，添加一个新Product类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">namespace Supermarket.API.Domain.Models</span><br><span class="line">	&#123;</span><br><span class="line">	    public class Product</span><br><span class="line">	    &#123;</span><br><span class="line">	        public int Id &#123; get; set; &#125;</span><br><span class="line">	        public string Name &#123; get; set; &#125;</span><br><span class="line">	        public short QuantityInPackage &#123; get; set; &#125;</span><br><span class="line">	        public EUnitOfMeasurement UnitOfMeasurement &#123; get; set; &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public int CategoryId &#123; get; set; &#125;</span><br><span class="line">	        public Category Category &#123; get; set; &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>该产品还具有ID和名称的属性。属性QuantityInPackage，它告诉我们一包中有多少个产品单位（请记住应用范围的饼干示例）和一个UnitOfMeasurement** <strong>属性，这是表示一个<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum" target="_blank" rel="noopener">枚举类型</a>，它表示可能的度量单位的枚举。最后两个属性，CategoryId</strong> **和Category将由ORM用于映射的产品和类别之间的关系。它表明一种产品只有一个类别。</p>
<p>让我们定义领域模型的最后一部分，EUnitOfMeasurement** **枚举。</p>
<p>按照惯例，枚举不需要在名称前以<em>“ E”</em>开头，但是在某些库和框架中，您会发现此前缀是将枚举与接口和类区分开的一种方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">using System.ComponentModel;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Domain.Models</span><br><span class="line">	&#123;</span><br><span class="line">	    public enum EUnitOfMeasurement : byte</span><br><span class="line">	    &#123;</span><br><span class="line">	        [Description(&quot;UN&quot;)]</span><br><span class="line">	        Unity = 1,</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        [Description(&quot;MG&quot;)]</span><br><span class="line">	        Milligram = 2,</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        [Description(&quot;G&quot;)]</span><br><span class="line">	        Gram = 3,</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        [Description(&quot;KG&quot;)]</span><br><span class="line">	        Kilogram = 4,</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        [Description(&quot;L&quot;)]</span><br><span class="line">	        Liter = 5</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>该代码非常简单。在这里，我们仅定义了几种度量单位的可能性，但是，在实际的超市系统中，您可能具有许多其他度量单位，并且可能还有一个单独的模型。<br>注意，【Description】特性应用于所有枚举可能性。特性是一种在C＃语言的类，接口，属性和其他组件上定义元数据的方法。在这种情况下，我们将使用它来简化产品API端点的响应，但是您现在不必关心它。我们待会再回到这里。</p>
<p>我们的基本模型已准备就绪，可以使用。现在，我们可以开始编写将管理所有类别的API端点。</p>
<h1 id="第3步-类别API"><a href="#第3步-类别API" class="headerlink" title="第3步-类别API"></a><strong>第3步-类别API</strong></h1><p>在Controllers文件夹中，添加一个名为的新类CategoriesController。</p>
<p>按照惯例，该文件夹中所有后缀为<em>“ Controller”的类</em>都将成为我们应用程序的控制器。这意味着他们将处理请求和响应。您必须从<a href="https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/namespace" target="_blank" rel="noopener">命名空间</a>【Microsoft.AspNetCore.Mvc】继承Controller。</p>
<p>命名空间由一组相关的类，接口，枚举和结构组成。您可以将其视为类似于Java语言<a href="https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc" target="_blank" rel="noopener">模块</a>或Java <a href="https://docs.oracle.com/javase/tutorial/java/package/packages.html" target="_blank" rel="noopener">程序包</a>的东西。</p>
<p>新的控制器应通过路由/api/categories做出响应。我们通过Route** **在类名称上方添加属性，指定占位符来实现此目的，该占位符表示路由应按照惯例使用不带控制器后缀的类名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.AspNetCore.Mvc;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Controllers</span><br><span class="line">	&#123;</span><br><span class="line">	    [Route(&quot;/api/[controller]&quot;)]</span><br><span class="line">	    public class CategoriesController : Controller</span><br><span class="line">	    &#123;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>让我们开始处理GET请求。首先，当有人/api/categories通过GET动词请求数据时，API需要返回所有类别。为此，我们可以创建<strong>类别服务</strong>。<br>从概念上讲，服务基本上是定义用于处理某些业务逻辑的方法的类或接口。创建用于处理业务逻辑的服务是许多不同编程语言的一种常见做法，例如<a href="https://medium.com/@evandro.ggomes/json-web-token-authentication-with-asp-net-core-2-0-b074b0cfc870" target="_blank" rel="noopener">身份验证和授权</a>，付款，复杂的数据流，缓存和需要其他服务或模型之间进行某些交互的任务。</p>
<p>使用服务，我们可以将请求和响应处理与完成任务所需的真实逻辑隔离开来。</p>
<p>该服务，我们要创建将首先定义一个单独的行为<strong>，</strong>或<strong>方法</strong>：一个list方法。我们希望该方法返回数据库中所有现有的类别。</p>
<p>为简单起见，在这篇博客中，我们将不处理数据分页或过滤，（译者注：基于RESTFul规范，提供了一套完整的分页和过滤的规则）。将来，我将写一篇文章，展示如何轻松处理这些功能。</p>
<p>为了定义C＃（以及其他面向对象的语言，例如Java）中某事物的预期行为，我们定义一个<strong>interface</strong>。一个接口告诉某些事情应该如何工作，但是<strong>没有实现行为的真实逻辑</strong>。逻辑在实现接口的类中实现。如果您不清楚此概念，请不要担心。一段时间后您将了解它。</p>
<p>在Domain文件夹中，创建一个名为的新目录Services。在此添加一个名为ICategoryService的接口。按照惯例，所有接口都应以C＃中的大写字母<em>“ I”</em>开头。定义接口代码，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Domain.Services</span><br><span class="line">	&#123;</span><br><span class="line">	    public interface ICategoryService</span><br><span class="line">	    &#123;</span><br><span class="line">	         Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>该ListAsync方法的实现必须<strong>异步</strong>返回类别的可枚举对象。<br>Task封装返回的类表示异步。由于必须等待数据库完成操作才能返回数据，因此我们需要考虑执行此过程可能需要一段时间，因此我们需要使用异步方法。另请注意<em>“Async”</em>后缀。这是一个约定，告诉我们的方法应异步执行。</p>
<p>我们有很多约定，对吗？我个人喜欢它，因为它使应用程序易于阅读，即使你在一家使用.NET技术的公司是新人。</p>
<p><img src="https://uploader.shimo.im/f/vQLzU6MpZkoChf0Y.png!thumbnail" alt="图片"></p>
<p><em>“-好的，我们定义了此接口，但是它什么也没做。有什么用？”</em></p>
<p>如果您来自Javascript或其他非强类型语言，则此概念可能看起来很奇怪。</p>
<p>接口使我们能够从实际实现中抽象出所需的行为。使用称为<a href="https://medium.freecodecamp.org/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f" target="_blank" rel="noopener">依赖注入</a>的机制，我们可以实现这些接口并将它们与其他组件隔离。</p>
<p>基本上，当您使用依赖项注入时，您可以使用接口定义一些行为。然后，创建一个实现该接口的类。最后，将引用从接口绑定到您创建的类。</p>
<p><em>”-听起来确实令人困惑。我们不能简单地创建一个为我们做这些事情的类吗？”</em></p>
<p>让我们继续实现我们的API，您将了解为什么使用这种方法。</p>
<p>更改CategoriesController代码，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	using Microsoft.AspNetCore.Mvc;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	using Supermarket.API.Domain.Services;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Controllers</span><br><span class="line">	&#123;</span><br><span class="line">	    [Route(&quot;/api/[controller]&quot;)]</span><br><span class="line">	    public class CategoriesController : Controller</span><br><span class="line">	    &#123;</span><br><span class="line">	        private readonly ICategoryService _categoryService;</span><br><span class="line">	        </span><br><span class="line">	        public CategoriesController(ICategoryService categoryService)</span><br><span class="line">	        &#123;</span><br><span class="line">	            _categoryService = categoryService;   </span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        [HttpGet]</span><br><span class="line">	        public async Task&lt;IEnumerable&lt;Category&gt;&gt; GetAllAsync()</span><br><span class="line">	        &#123;</span><br><span class="line">	            var categories = await _categoryService.ListAsync();</span><br><span class="line">	            return categories;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我已经为控制器定义了一个构造函数（当创建一个类的新实例时会调用一个构造函数），并且它接收的实例ICategoryService。这意味着实例可以是任何实现服务接口的实例。我将此实例存储在一个私有的只读字段中_categoryService。我们将使用此字段访问类别服务实现的方法。<br>顺便说一下，下划线前缀是表示字段的另一个通用约定。特别地，<a href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions" target="_blank" rel="noopener">.NET</a>的<a href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions" target="_blank" rel="noopener">官方命名约定指南</a>不建议使用此<a href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions" target="_blank" rel="noopener">约定</a>，但是这是一种非常普遍的做法，可以避免使用<em>“ this”</em>关键字来区分类字段和局部变量。我个人认为阅读起来要干净得多，并且许多框架和库都使用此约定。</p>
<p>在构造函数下，我定义了用于处理请求的方法/api/categories。该HttpGet** **属性告诉ASP.NET Core管道使用该属性来处理GET请求（可以省略此属性，但是最好编写它以便于阅读）。</p>
<p>该方法使用我们的CategoryService实例列出所有类别，然后将类别返回给客户端。框架管道将数据序列化为JSON对象。IEnumerable类型告诉框架，我们想要返回一个类别的枚举，而Task类型(使用async关键字修饰)告诉管道，这个方法应该异步执行。最后，当我们定义一个异步方法时，我们必须使用await关键字来处理需要一些时间的任务。</p>
<p>好的，我们定义了API的初始结构。现在，有必要真正实现类别服务。</p>
<h1 id="步骤4-实现类别服务"><a href="#步骤4-实现类别服务" class="headerlink" title="步骤4-实现类别服务"></a><strong>步骤4-实现类别服务</strong></h1><p>在API的根文件夹（即Supermarket.API文件夹）中，创建一个名为的新文件夹Services。在这里，我们将放置所有服务实现。在新文件夹中，添加一个名为CategoryService的新类。更改代码，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	using Supermarket.API.Domain.Services;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Services</span><br><span class="line">	&#123;</span><br><span class="line">	    public class CategoryService : ICategoryService</span><br><span class="line">	    &#123;</span><br><span class="line">	        public async Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync()</span><br><span class="line">	        &#123;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>以上只是接口实现的基本代码，我们暂时仍不处理任何逻辑。让我们考虑一下列表方法应该如何实现。<br>我们需要访问数据库并返回所有类别，然后我们需要将此数据返回给客户端。</p>
<p>服务类不是应该处理数据访问的类。我们将使用一种称为“仓储模式”的设计模式，定义仓储类，用于管理数据库中的数据。</p>
<p>在使用仓储模式时，我们定义了repository 类，该类基本上封装了处理数据访问的所有逻辑。这些仓储类使方法可以列出，创建，编辑和删除给定模型的对象，与操作集合的方式相同。在内部，这些方法与数据库对话以执行CRUD操作，从而将数据库访问与应用程序的其余部分隔离开。</p>
<p>我们的服务需要调用类别仓储，以获取列表对象。</p>
<p>从概念上讲，服务可以与一个或多个仓储或其他服务“对话”以执行操作。</p>
<p>创建用于处理数据访问逻辑的新定义似乎是多余的，但是您将在一段时间内看到将这种逻辑与服务类隔离是非常有利的。</p>
<p>让我们创建一个仓储，该仓储负责与数据库通信，作为持久化保存类别的一种方式。</p>
<h1 id="步骤5-类别仓储和持久层"><a href="#步骤5-类别仓储和持久层" class="headerlink" title="步骤5-类别仓储和持久层"></a><strong>步骤5-类别仓储和持久层</strong></h1><p>在该Domain文件夹内，创建一个名为的新目录Repositories。然后，添加一个名为的新接口ICategoryRespository。定义接口如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	namespace Supermarket.API.Domain.Repositories</span><br><span class="line">	&#123;</span><br><span class="line">	    public interface ICategoryRepository</span><br><span class="line">	    &#123;</span><br><span class="line">	         Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>初始代码基本上与服务接口的代码相同。<br>定义了接口之后，我们可以返回服务类并使用的实例ICategoryRepository返回数据来完成实现list方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	using Supermarket.API.Domain.Repositories;</span><br><span class="line">	using Supermarket.API.Domain.Services;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Services</span><br><span class="line">	&#123;</span><br><span class="line">	    public class CategoryService : ICategoryService</span><br><span class="line">	    &#123;</span><br><span class="line">	        private readonly ICategoryRepository _categoryRepository;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public CategoryService(ICategoryRepository categoryRepository)</span><br><span class="line">	        &#123;</span><br><span class="line">	            this._categoryRepository = categoryRepository;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public async Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync()</span><br><span class="line">	        &#123; </span><br><span class="line">	            return await _categoryRepository.ListAsync();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们必须实现类别仓储的真实逻辑。在这样做之前，我们必须考虑如何访问数据库。<br><em>顺便说一句，我们仍然没有数据库！</em></p>
<p>我们将使用Entity Framework Core（为简单起见，我将其称为<strong><em>EF Core</em></strong>）作为我们的数据库ORM。该框架是ASP.NET Core的默认ORM，并公开了一个友好的API，该API使我们能够将应用程序的类映射到数据库表。</p>
<p>EF Core还允许我们先设计应用程序，然后根据我们在代码中定义的内容生成数据库。此技术称为<strong>Code First</strong>。我们将使用Code First方法来生成数据库（实际上，在此示例中，我将使用内存数据库，但是您可以轻松地将其更改为像SQL Server或MySQL服务器这样的实例数据库）。</p>
<p>在API的根文件夹中，创建一个名为的新目录Persistence。此目录将包含我们访问数据库所需的所有内容，例如仓储实现。</p>
<p>在新文件夹中，创建一个名为的新目录Contexts，然后添加一个名为的新类AppDbContext。此类必须继承DbContext，EF Core通过DBContext用来将您的模型映射到数据库表的类。通过以下方式更改代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.EntityFrameworkCore;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Domain.Persistence.Contexts</span><br><span class="line">	&#123;</span><br><span class="line">	    public class AppDbContext : DbContext</span><br><span class="line">	    &#123;</span><br><span class="line">	        public AppDbContext(DbContextOptions&lt;AppDbContext&gt; options) : base(options)</span><br><span class="line">	        &#123;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我们添加到此类的构造函数负责通过依赖注入将数据库配置传递给基类。稍后您将看到其工作原理。<br>现在，我们必须创建两个DbSet属性。这些属性是将模型映射到数据库表的集合（唯一对象的集合）。</p>
<p>另外，我们必须将模型的属性映射到相应的列，指定哪些属性是主键，哪些是外键，列类型等。我们可以使用称为<a href="http://www.entityframeworktutorial.net/efcore/fluent-api-in-entity-framework-core.aspx" target="_blank" rel="noopener">Fluent API</a>的功能来覆盖OnModelCreating方法，以指定数据库映射。更改AppDbContext类，如下所示：</p>
<p>该代码是如此直观。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.EntityFrameworkCore;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Persistence.Contexts</span><br><span class="line">	&#123;</span><br><span class="line">	    public class AppDbContext : DbContext</span><br><span class="line">	    &#123;</span><br><span class="line">	        public DbSet&lt;Category&gt; Categories &#123; get; set; &#125;</span><br><span class="line">	        public DbSet&lt;Product&gt; Products &#123; get; set; &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public AppDbContext(DbContextOptions&lt;AppDbContext&gt; options) : base(options) &#123; &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        protected override void OnModelCreating(ModelBuilder builder)</span><br><span class="line">	        &#123;</span><br><span class="line">	            base.OnModelCreating(builder);</span><br><span class="line">	            </span><br><span class="line">	            builder.Entity&lt;Category&gt;().ToTable(&quot;Categories&quot;);</span><br><span class="line">	            builder.Entity&lt;Category&gt;().HasKey(p =&gt; p.Id);</span><br><span class="line">	            builder.Entity&lt;Category&gt;().Property(p =&gt; p.Id).IsRequired().ValueGeneratedOnAdd();</span><br><span class="line">	            builder.Entity&lt;Category&gt;().Property(p =&gt; p.Name).IsRequired().HasMaxLength(30);</span><br><span class="line">	            builder.Entity&lt;Category&gt;().HasMany(p =&gt; p.Products).WithOne(p =&gt; p.Category).HasForeignKey(p =&gt; p.CategoryId);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            builder.Entity&lt;Category&gt;().HasData</span><br><span class="line">	            (</span><br><span class="line">	                new Category &#123; Id = 100, Name = &quot;Fruits and Vegetables&quot; &#125;, // Id set manually due to in-memory provider</span><br><span class="line">	                new Category &#123; Id = 101, Name = &quot;Dairy&quot; &#125;</span><br><span class="line">	            );</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            builder.Entity&lt;Product&gt;().ToTable(&quot;Products&quot;);</span><br><span class="line">	            builder.Entity&lt;Product&gt;().HasKey(p =&gt; p.Id);</span><br><span class="line">	            builder.Entity&lt;Product&gt;().Property(p =&gt; p.Id).IsRequired().ValueGeneratedOnAdd();</span><br><span class="line">	            builder.Entity&lt;Product&gt;().Property(p =&gt; p.Name).IsRequired().HasMaxLength(50);</span><br><span class="line">	            builder.Entity&lt;Product&gt;().Property(p =&gt; p.QuantityInPackage).IsRequired();</span><br><span class="line">	            builder.Entity&lt;Product&gt;().Property(p =&gt; p.UnitOfMeasurement).IsRequired();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我们指定我们的模型应映射到哪些表。此外，我们设置了主键，使用该方法HasKey，该表的列，使用Property方法，和一些限制，例如IsRequired，HasMaxLength<strong>，</strong>和ValueGeneratedOnAdd，这些都是使用FluentApi的方式基于Lamada 表达式语法实现的（链式语法）。<br>看一下下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.Entity&lt;Category&gt;()</span><br><span class="line">       .HasMany(p =&gt; p.Products)</span><br><span class="line">       .WithOne(p =&gt; p.Category)</span><br><span class="line">       .HasForeignKey(p =&gt; p.CategoryId);</span><br></pre></td></tr></table></figure>

<p>在这里，我们指定表之间的关系。我们说一个类别有很多产品，我们设置了将映射此关系的属性（Products，来自Category类，和Category，来自Product类）。我们还设置了外键（CategoryId）。<br>如果您想学习如何使用EF Core配置一对一和多对多关系，以及如何完整的使用它，请看一下<a href="https://www.learnentityframeworkcore.com/relationships" target="_blank" rel="noopener">本教程</a>。</p>
<p>还有一种用于通过HasData方法配置种子数据的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">builder.Entity&lt;Category&gt;().HasData</span><br><span class="line">(</span><br><span class="line">  new Category &#123; Id = 100, Name = &quot;Fruits and Vegetables&quot; &#125;,</span><br><span class="line">  new Category &#123; Id = 101, Name = &quot;Dairy&quot; &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>默认情况下，在这里我们仅添加两个示例类别。这对我们完成后进行API的测试来说是非常有必要的。</p>
<blockquote>
<p><strong>注意：</strong>我们在Id这里手动设置属性，因为内存提供程序的工作机制需要。我将标识符设置为大数字，以避免自动生成的标识符和种子数据之间发生冲突。</p>
<blockquote>
<p>真正的关系数据库提供程序中不存在此限制，因此，例如，如果要使用SQL Server等数据库，则不必指定这些标识符。如果您想了解此行为，请检查<a href="https://github.com/aspnet/EntityFrameworkCore/issues/6872" target="_blank" rel="noopener">此Github问题</a>。</p>
</blockquote>
</blockquote>
<p>在实现数据库上下文类之后，我们可以实现类别仓储。添加一个名为新的文件夹Repositories里面Persistence的文件夹，然后添加一个名为新类BaseRepository。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using Supermarket.API.Persistence.Contexts;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Persistence.Repositories</span><br><span class="line">	&#123;</span><br><span class="line">	    public abstract class BaseRepository</span><br><span class="line">	    &#123;</span><br><span class="line">	        protected readonly AppDbContext _context;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public BaseRepository(AppDbContext context)</span><br><span class="line">	        &#123;</span><br><span class="line">	            _context = context;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>此类只是我们所有仓储都将继承的<strong>抽象类</strong>。抽象类是没有直接实例的类。您必须创建直接类来创建实例。<br>在BaseRepository接受我们的实例，AppDbContext通过依赖注入暴露了一个受保护的属性称为（只能是由子类访问一个属性）_context，即可以访问我们需要处理数据库操作的所有方法。</p>
<p>在相同文件夹中添加一个新类CategoryRepository。现在，我们将真正实现仓储逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	using Microsoft.EntityFrameworkCore;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	using Supermarket.API.Domain.Repositories;</span><br><span class="line">	using Supermarket.API.Persistence.Contexts;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Persistence.Repositories</span><br><span class="line">	&#123;</span><br><span class="line">	    public class CategoryRepository : BaseRepository, ICategoryRepository</span><br><span class="line">	    &#123;</span><br><span class="line">	        public CategoryRepository(AppDbContext context) : base(context)</span><br><span class="line">	        &#123;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public async Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync()</span><br><span class="line">	        &#123;</span><br><span class="line">	            return await _context.Categories.ToListAsync();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>仓储继承BaseRepository和实现ICategoryRepository。<br>注意实现list方法是很简单的。我们使用Categories数据库集访问类别表，然后调用扩展方法ToListAsync，该方法负责将查询结果转换为类别的集合。</p>
<p>EF Core <a href="https://docs.microsoft.com/en-us/ef/core/querying/overview" target="_blank" rel="noopener">将我们的方法调用转换为SQL查询</a>，这是最有效的方法。这种方式仅当您调用将数据转换为集合的方法或使用方法获取特定数据时才执行查询。</p>
<p>现在，我们有了类别控制器，服务和仓储库的代码实现。</p>
<p>我们将关注点分离开来，创建了只执行应做的事情的类。</p>
<p>测试应用程序之前的最后一步是使用ASP.NET Core依赖项注入机制将我们的接口绑定到相应的类。</p>
<h1 id="第6步-配置依赖注入"><a href="#第6步-配置依赖注入" class="headerlink" title="第6步-配置依赖注入"></a><strong>第6步-配置依赖注入</strong></h1><p>现在是时候让您最终了解此概念的工作原理了。</p>
<p><img src="https://uploader.shimo.im/f/GYbYOJqzMqsxEBg3.png!thumbnail" alt="图片"></p>
<p>在应用程序的根文件夹中，打开Startup类。此类负责在应用程序启动时配置各种配置。</p>
<p>该ConfigureServices和Configure方法通过框架管道在运行时调用来配置应用程序应该如何工作，必须使用哪些组件。</p>
<p>打开ConfigureServices方法。在这里，我们只有一行配置应用程序以使用MVC管道，这基本上意味着该应用程序将使用控制器类来处理请求和响应（在这段代码背后发生了很多事情，但目前您仅需要知道这些）。</p>
<p>我们可以使用ConfigureServices访问services参数的方法来配置我们的依赖项绑定。清理类代码，删除所有注释并按如下所示更改代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.AspNetCore.Builder;</span><br><span class="line">	using Microsoft.AspNetCore.Hosting;</span><br><span class="line">	using Microsoft.AspNetCore.Mvc;</span><br><span class="line">	using Microsoft.EntityFrameworkCore;</span><br><span class="line">	using Microsoft.Extensions.Configuration;</span><br><span class="line">	using Microsoft.Extensions.DependencyInjection;</span><br><span class="line">	using Supermarket.API.Domain.Repositories;</span><br><span class="line">	using Supermarket.API.Domain.Services;</span><br><span class="line">	using Supermarket.API.Persistence.Contexts;</span><br><span class="line">	using Supermarket.API.Persistence.Repositories;</span><br><span class="line">	using Supermarket.API.Services;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API</span><br><span class="line">	&#123;</span><br><span class="line">	    public class Startup</span><br><span class="line">	    &#123;</span><br><span class="line">	        public IConfiguration Configuration &#123; get; &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public Startup(IConfiguration configuration)</span><br><span class="line">	        &#123;</span><br><span class="line">	            Configuration = configuration;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public void ConfigureServices(IServiceCollection services)</span><br><span class="line">	        &#123;</span><br><span class="line">	            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            services.AddDbContext&lt;AppDbContext&gt;(options =&gt; &#123;</span><br><span class="line">	                options.UseInMemoryDatabase(&quot;supermarket-api-in-memory&quot;);</span><br><span class="line">	            &#125;);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            services.AddScoped&lt;ICategoryRepository, CategoryRepository&gt;();</span><br><span class="line">	            services.AddScoped&lt;ICategoryService, CategoryService&gt;();</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public void Configure(IApplicationBuilder app, IHostingEnvironment env)</span><br><span class="line">	        &#123;</span><br><span class="line">	            if (env.IsDevelopment())</span><br><span class="line">	            &#123;</span><br><span class="line">	                app.UseDeveloperExceptionPage();</span><br><span class="line">	            &#125;</span><br><span class="line">	            else</span><br><span class="line">	            &#123;</span><br><span class="line">	                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.</span><br><span class="line">	                app.UseHsts();</span><br><span class="line">	            &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            app.UseHttpsRedirection();</span><br><span class="line">	            app.UseMvc();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>看一下这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services.AddDbContext&lt;AppDbContext&gt;(options =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  options.UseInMemoryDatabase(&quot;supermarket-api-in-memory&quot;);</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这里，我们配置数据库上下文。我们告诉ASP.NET Core将其AppDbContext与内存数据库实现一起使用，该实现由作为参数传递给我们方法的字符串标识。通常，在编写<a href="https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-2.2" target="_blank" rel="noopener">集成测试</a>时才会使用内存数据库，但是为了简单起见，我在这里使用了内存数据库。这样，我们无需连接到真实的数据库即可测试应用程序。<br>这些代码行在内部配置我们的数据库上下文，以便使用确定作用域的生存周期进行依赖注入。</p>
<p>scoped生存周期告诉ASP.NET Core管道，每当它需要解析接收AppDbContext作为构造函数参数的实例的类时，都应使用该类的相同实例。如果内存中没有实例，则管道将创建一个新实例，并在给定请求期间在需要它的所有类中重用它。这样，您无需在需要使用时手动创建类实例。</p>
<p>如果你想了解其他有关生命周期的知识，可以阅读<a href="https://docs.microsoft.com/pt-br/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.2" target="_blank" rel="noopener">官方文档</a>。</p>
<p>依赖注入技术为我们提供了许多优势，例如：</p>
<ul>
<li>代码可重用性；</li>
<li>更高的生产力，因为当我们不得不更改实现时，我们无需费心去更改您使用该功能的一百个地方；</li>
<li>您可以轻松地测试应用程序，因为我们可以使用mock（类的伪实现）隔离必须测试的内容，而我们必须将接口作为构造函数参数进行传递。</li>
<li>当一个类需要通过构造函数接收更多的依赖关系时，您不必手动更改正在创建实例的所有位置（<strong>太赞了！</strong>）。</li>
</ul>
<p>配置数据库上下文之后，我们还将我们的服务和仓储绑定到相应的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">services.AddScoped&lt;ICategoryRepository, CategoryRepository&gt;();</span><br><span class="line"></span><br><span class="line">services.AddScoped&lt;ICategoryService, CategoryService&gt;();</span><br></pre></td></tr></table></figure>

<p>在这里，我们还使用了scoped生存周期，因为这些类在内部必须使用数据库上下文类。在这种情况下，指定相同的范围是有意义的。<br>现在我们配置了依赖绑定，我们必须在Program类上进行一些小的更改，以便数据库正确地初始化种子数据。此步骤仅在使用内存数据库提供程序时才需要执行（请参阅<a href="https://github.com/aspnet/EntityFrameworkCore/issues/11666" target="_blank" rel="noopener">此Github问题</a>以了解原因）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">	using System.Collections.Generic;</span><br><span class="line">	using System.IO;</span><br><span class="line">	using System.Linq;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	using Microsoft.AspNetCore;</span><br><span class="line">	using Microsoft.AspNetCore.Hosting;</span><br><span class="line">	using Microsoft.Extensions.Configuration;</span><br><span class="line">	using Microsoft.Extensions.DependencyInjection;</span><br><span class="line">	using Microsoft.Extensions.Logging;</span><br><span class="line">	using Supermarket.API.Persistence.Contexts;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API</span><br><span class="line">	&#123;</span><br><span class="line">	    public class Program</span><br><span class="line">	    &#123;</span><br><span class="line">	        public static void Main(string[] args)</span><br><span class="line">	        &#123;</span><br><span class="line">	            var host = BuildWebHost(args);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            using(var scope = host.Services.CreateScope())</span><br><span class="line">	            using(var context = scope.ServiceProvider.GetService&lt;AppDbContext&gt;())</span><br><span class="line">	            &#123;</span><br><span class="line">	                context.Database.EnsureCreated();</span><br><span class="line">	            &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            host.Run();</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public static IWebHost BuildWebHost(string[] args) =&gt;</span><br><span class="line">	            WebHost.CreateDefaultBuilder(args)</span><br><span class="line">	            .UseStartup&lt;Startup&gt;()</span><br><span class="line">	            .Build();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们使用的是内存提供程序，因此有必要更改Main方法 添加“ context.Database.EnsureCreated();”代码以确保在应用程序启动时将“创建”数据库。没有此更改，将不会创建我们想要的初始化种子数据。<br>实现了所有基本功能后，就该测试我们的API端点了。</p>
<h1 id="第7步-测试类别"><a href="#第7步-测试类别" class="headerlink" title="第7步-测试类别"></a><strong>第7步-测试类别</strong></h1><p>在API根文件夹中打开终端或命令提示符，然后键入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet run</span><br></pre></td></tr></table></figure>

<p>上面的命令启动应用程序。控制台将显示类似于以下内容的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">info: Microsoft.EntityFrameworkCore.Infrastructure[10403]</span><br><span class="line"></span><br><span class="line">Entity Framework Core 2.2.0-rtm-35687 initialized ‘AppDbContext’ using provider ‘Microsoft.EntityFrameworkCore.InMemory’ with options: StoreName=supermarket-api-in-memory</span><br><span class="line"></span><br><span class="line">info: Microsoft.EntityFrameworkCore.Update[30100]</span><br><span class="line"></span><br><span class="line">Saved 2 entities to in-memory store.</span><br><span class="line"></span><br><span class="line">info: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[0]</span><br><span class="line"></span><br><span class="line">User profile is available. Using ‘C:\Users\evgomes\AppData\Local\ASP.NET\DataProtection-Keys’ as key repository and Windows DPAPI to encrypt keys at rest.</span><br><span class="line"></span><br><span class="line">Hosting environment: Development</span><br><span class="line"></span><br><span class="line">Content root path: C:\Users\evgomes\Desktop\Tutorials\src\Supermarket.API</span><br><span class="line"></span><br><span class="line">Now listening on: https://localhost:5001</span><br><span class="line"></span><br><span class="line">Now listening on: http://localhost:5000</span><br><span class="line"></span><br><span class="line">Application started. Press Ctrl+C to shut down.</span><br></pre></td></tr></table></figure>

<p>您可以看到调用了EF Core来初始化数据库。最后几行显示应用程序在哪个端口上运行。<br>打开浏览器，然后导航到 <a href="http://localhost:5000/api/categories" target="_blank" rel="noopener">http</a><a href="http://localhost:5000/api/categories" target="_blank" rel="noopener">:</a><a href="http://localhost:5000/api/categories" target="_blank" rel="noopener">//localhost</a><a href="http://localhost:5000/api/categories" target="_blank" rel="noopener">:</a><a href="http://localhost:5000/api/categories" target="_blank" rel="noopener">5000/api/categories</a> （或控制台输出上显示的URL）。如果您发现由于HTTPS导致的安全错误，则只需为应用程序添加一个例外。</p>
<p>浏览器将显示以下JSON数据作为输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">     &quot;id&quot;: 100,</span><br><span class="line">     &quot;name&quot;: &quot;Fruits and Vegetables&quot;,</span><br><span class="line">     &quot;products&quot;: []</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">     &quot;id&quot;: 101,</span><br><span class="line">     &quot;name&quot;: &quot;Dairy&quot;,</span><br><span class="line">     &quot;products&quot;: []</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在这里，我们看到配置数据库上下文时添加到数据库的数据。此输出确认我们的代码正在运行。<br>您使用很少的代码行创建了GET API端点，并且由于当前API项目的架构模式，您的代码结构确实很容易更改。</p>
<p>现在，该向您展示在由于业务需要而不得不对其进行更改时，更改此代码有多么容易。</p>
<h1 id="步骤8-创建类别资源"><a href="#步骤8-创建类别资源" class="headerlink" title="步骤8-创建类别资源"></a><strong>步骤8-创建类别资源</strong></h1><p>如果您还记得API端点的规范，您会注意到我们的实际JSON响应还有一个额外的属性：<strong>products数组</strong>。看一下所需响应的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  [</span><br><span class="line">    &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Fruits and Vegetables&quot; &#125;,</span><br><span class="line">    &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;Breads&quot; &#125;,</span><br><span class="line">    … // Other categories</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>产品数组出现在我们当前的JSON响应中，因为我们的Category模型具有Products，EF Core需要的属性，以正确映射给定类别的产品。<br>我们不希望在响应中使用此属性，但是不能更改模型类以排除此属性。当我们尝试管理类别数据时，这将导致EF Core引发错误，并且也将破坏我们的领域模型设计，因为没有产品的产品类别没有意义。</p>
<p>要返回仅包含超级市场类别的标识符和名称的JSON数据，我们必须创建一个<strong>资源类</strong>。</p>
<p><a href="https://restful-api-design.readthedocs.io/en/latest/resources.html" target="_blank" rel="noopener">资源类</a>是一种包含将客户端应用程序和API端点之间进行交换的类型，通常以JSON数据的形式出现，以表示一些特定信息的类。</p>
<p>来自API端点的所有响应都<strong>必须</strong>返回资源。</p>
<p>将真实模型表示形式作为响应返回是一种不好的做法，因为它可能包含客户端应用程序不需要或没有其权限的信息（例如，用户模型可以返回用户密码的信息） ，这将是一个很大的安全问题）。</p>
<p>我们需要一种资源来仅代表我们的类别，而没有产品。</p>
<p>现在您知道什么是资源，让我们实现它。首先，在命令行中按<strong>Ctrl + C</strong>停止正在运行的应用程序。在应用程序的根文件夹中，创建一个名为Resources的新文件夹。在其中添加一个名为的新类CategoryResource。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namespace Supermarket.API.Resources</span><br><span class="line">	&#123;</span><br><span class="line">	    public class CategoryResource</span><br><span class="line">	    &#123;</span><br><span class="line">	        public int Id &#123; get; set; &#125;</span><br><span class="line">	        public string Name &#123; get; set; &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我们必须将类别服务提供的类别模型集合映射到类别资源集合。<br>我们将使用一个名为<a href="https://automapper.org/" target="_blank" rel="noopener">AutoMapper</a>的库来处理对象之间的映射。AutoMapper是.NET世界中非常流行的库，并且在许多商业和开源项目中使用。</p>
<p>在命令行中输入以下命令，以将AutoMapper添加到我们的应用程序中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dotnet add package AutoMapper</span><br><span class="line"></span><br><span class="line">dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection</span><br></pre></td></tr></table></figure>

<p>要使用AutoMapper，我们必须做两件事：</p>
<ul>
<li>注册它以进行依赖注入；</li>
<li>创建一个类，该类将告诉AutoMapper如何处理类映射。</li>
</ul>
<p>首先，打开Startup课程。在该ConfigureServices方法的最后一行之后，添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddAutoMapper();</span><br></pre></td></tr></table></figure>

<p>此行处理AutoMapper的所有必需配置，例如注册它以进行依赖项注入以及在启动过程中扫描应用程序以配置映射配置文件。<br>现在，在根目录中，添加一个名为的新文件夹Mapping，然后添加一个名为的类ModelToResourceProfile。通过以下方式更改代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">using AutoMapper;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	using Supermarket.API.Resources;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Mapping</span><br><span class="line">	&#123;</span><br><span class="line">	    public class ModelToResourceProfile : Profile</span><br><span class="line">	    &#123;</span><br><span class="line">	        public ModelToResourceProfile()</span><br><span class="line">	        &#123;</span><br><span class="line">	            CreateMap&lt;Category, CategoryResource&gt;();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>该类继承Profile了AutoMapper用于检查我们的映射如何工作的类类型。在构造函数上，我们在Category模型类和CategoryResource类之间创建一个映射。由于类的属性具有相同的名称和类型，因此我们不必为其使用任何特殊的配置。<br>最后一步包括更改类别控制器以使用AutoMapper处理我们的对象映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	using AutoMapper;</span><br><span class="line">	using Microsoft.AspNetCore.Mvc;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	using Supermarket.API.Domain.Services;</span><br><span class="line">	using Supermarket.API.Resources;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Controllers</span><br><span class="line">	&#123;</span><br><span class="line">	    [Route(&quot;/api/[controller]&quot;)]</span><br><span class="line">	    public class CategoriesController : Controller</span><br><span class="line">	    &#123;</span><br><span class="line">	        private readonly ICategoryService _categoryService;</span><br><span class="line">	        private readonly IMapper _mapper;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public CategoriesController(ICategoryService categoryService, IMapper mapper)</span><br><span class="line">	        &#123;</span><br><span class="line">	            _categoryService = categoryService;</span><br><span class="line">	            _mapper = mapper;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        [HttpGet]</span><br><span class="line">	        public async Task&lt;IEnumerable&lt;CategoryResource&gt;&gt; GetAllAsync()</span><br><span class="line">	        &#123;</span><br><span class="line">	            var categories = await _categoryService.ListAsync();</span><br><span class="line">	            var resources = _mapper.Map&lt;IEnumerable&lt;Category&gt;, IEnumerable&lt;CategoryResource&gt;&gt;(categories);</span><br><span class="line">	            </span><br><span class="line">	            return resources;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我更改了构造函数以接收IMapper实现的实例。您可以使用这些接口方法来使用AutoMapper映射方法。<br>我还更改了GetAllAsync使用Map方法将类别枚举映射到资源枚举的方法。此方法接收我们要映射的类或集合的实例，并通过<a href="https://www.geeksforgeeks.org/c-generics-introduction/" target="_blank" rel="noopener">通用类型定义</a>定义必须映射到什么类型的类或集合。</p>
<p>注意，我们只需将新的依赖项（IMapper）注入构造函数，就可以轻松地更改实现，而不必修改服务类或仓储。</p>
<p>依赖注入使您的应用程序可维护且易于更改，因为您不必中断所有代码实现即可添加或删除功能。</p>
<p>您可能意识到，不仅控制器类，而且所有接收依赖项的类（包括依赖项本身）都会根据绑定配置自动解析为接收正确的类。</p>
<p>依赖注入如此的Amazing，不是吗？</p>
<p><img src="https://uploader.shimo.im/f/wGoOlHek0agFA3kQ.png!thumbnail" alt="图片"></p>
<p>现在，使用dotnet run命令再次启动API，然后转到<a href="http://localhost:5000/api/categories" target="_blank" rel="noopener">http</a><a href="http://localhost:5000/api/categories" target="_blank" rel="noopener">:</a><a href="http://localhost:5000/api/categories" target="_blank" rel="noopener">//localhost</a><a href="http://localhost:5000/api/categories" target="_blank" rel="noopener">:</a><a href="http://localhost:5000/api/categories" target="_blank" rel="noopener">5000/api/categories</a>以查看新的JSON响应。</p>
<p><img src="https://uploader.shimo.im/f/xb8S1G8qcWQW3MSN.png!thumbnail" alt="图片"></p>
<p>这是您应该看到的响应数据</p>
<p>我们已经有了GET端点。现在，让我们为POST（<strong>创建</strong>）类别创建一个新端点。</p>
<h1 id="第9步-创建新类别"><a href="#第9步-创建新类别" class="headerlink" title="第9步-创建新类别"></a><strong>第9步-创建新类别</strong></h1><p>在处理资源创建时，我们必须关心很多事情，例如：</p>
<ul>
<li>数据验证和数据完整性；</li>
<li>授权创建资源；</li>
<li>错误处理；</li>
<li>正在记录。</li>
</ul>
<p>在本教程中，我不会显示如何处理身份验证和授权，但是您可以阅读<a href="https://medium.com/@evandro.ggomes/json-web-token-authentication-with-asp-net-core-2-0-b074b0cfc870" target="_blank" rel="noopener">JSON Web令牌身份验证</a>教程，了解如何轻松实现这些功能。</p>
<p>另外，有一个非常流行的框架称为<strong>ASP.NET Identity</strong>，该框架提供了有关安全性和用户注册的内置解决方案，您可以在应用程序中使用它们。它包括与EF Core配合使用的提供程序，例如IdentityDbContext可以使用的内置程序。您可以<a href="https://docs.microsoft.com/en-us/aspnet/identity/overview/getting-started/introduction-to-aspnet-identity" target="_blank" rel="noopener">在此处了解更多信息</a>。</p>
<p>让我们编写一个HTTP POST端点，该端点将涵盖其他场景（日志记录除外，它可以根据不同的范围和工具进行更改）。</p>
<p>在创建新端点之前，我们需要一个新资源。此资源会将客户端应用程序发送到此端点的数据（在本例中为类别名称）映射到我们应用程序的类。</p>
<p>由于我们正在创建一个新类别，因此我们还没有ID，这意味着我们需要一种资源来表示仅包含其名称的类别。</p>
<p>在Resources文件夹中，添加一个新类SaveCategoryResource：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System.ComponentModel.DataAnnotations;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Resources</span><br><span class="line">	&#123;</span><br><span class="line">	    public class SaveCategoryResource</span><br><span class="line">	    &#123;</span><br><span class="line">	        [Required]</span><br><span class="line">	        [MaxLength(30)]</span><br><span class="line">	        public string Name &#123; get; set; &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>注意Name属性上的Required和MaxLength特性。这些属性称为<a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations?view=netframework-4.7.2" target="_blank" rel="noopener">数据注释</a>。ASP.NET Core管道使用此元数据来验证请求和响应。顾名思义，类别名称是必填项，最大长度为30个字符。<br>现在，让我们定义新API端点的形状。将以下代码添加到类别控制器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[HttpPost]</span><br><span class="line">	public async Task&lt;IActionResult&gt; PostAsync([FromBody] SaveCategoryResource resource)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用HttpPost特性告诉框架这是一个HTTP POST端点。<br>注意此方法的响应类型Task<iactionresult>。控制器类中存在的方法称为<strong>动作</strong>，它们具有此签名，因为在应用程序执行动作之后，我们可以返回一个以上的可能结果。</iactionresult></p>
<p>在这种情况下，如果类别名称无效或出现问题，我们必须返回<strong>400代码（错误请求）</strong>响应，该响应通常包含一条错误消息，客户端应用程序可以使用该错误消息来解决该问题，或者我们可以如果一切正常，则对数据进行<strong>200次响应（成功）</strong>。</p>
<p>可以将多种类型的操作类型用作响应，但是通常，我们可以使用此接口，并且ASP.NET Core将为此使用默认类。</p>
<p>该FromBody属性告诉ASP.NET Core将请求正文数据解析为我们的新资源类。这意味着当包含类别名称的JSON发送到我们的应用程序时，框架将自动将其解析为我们的新类。</p>
<p>现在，让我们实现路由逻辑。我们必须遵循一些步骤才能成功创建新类别：</p>
<ul>
<li>首先，我们必须验证传入的请求。如果请求无效，我们必须返回包含错误消息的错误请求响应；</li>
<li>然后，如果请求有效，则必须使用AutoMapper将新资源映射到类别模型类。</li>
<li>现在，我们需要调用我们的服务，告诉它保存我们的新类别。如果执行保存逻辑没有问题，它将返回一个包含我们新类别数据的响应。如果没有，它应该给我们一个指示，表明该过程失败了，并可能出现错误消息。</li>
<li>最后，如果有错误，我们将返回错误的请求。如果没有，我们将新的类别模型映射到类别资源，并向客户端返回包含新类别数据的成功响应。</li>
</ul>
<p>这似乎很复杂，但是使用为API构建的服务架构来实现此逻辑确实很容易。</p>
<p>让我们开始验证传入的请求。</p>
<h1 id="步骤10-使用模型状态验证请求主体"><a href="#步骤10-使用模型状态验证请求主体" class="headerlink" title="步骤10-使用模型状态验证请求主体"></a><strong>步骤10-使用模型状态验证请求主体</strong></h1><p>ASP.NET Core控制器具有名为ModelState的属性。在执行我们的操作<strong>之前，</strong>该属性在请求执行期间填充。它是ModelStateDictionary的实例，该类包含诸如请求是否有效以及潜在的验证错误消息之类的信息。</p>
<p>如下更改端点代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[HttpPost]</span><br><span class="line">	public async Task&lt;IActionResult&gt; PostAsync([FromBody] SaveCategoryResource resource)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!ModelState.IsValid)</span><br><span class="line">			return BadRequest(ModelState.GetErrorMessages());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码检查模型状态（在这种情况下为请求正文中发送的数据）是否无效，并检查我们的数据注释。如果不是，则API返回错误的请求（状态代码400），以及我们的注释元数据提供的默认错误消息。<br>该ModelState.GetErrorMessages()方法尚未实现。这是一种<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods" target="_blank" rel="noopener">扩展方法</a>（一种扩展现有类或接口功能的方法），我将实现该方法将验证错误转换为简单的字符串以返回给客户端。</p>
<p>Extensions在我们的API的根目录中添加一个新文件夹，然后添加一个新类ModelStateExtensions。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">	using System.Linq;</span><br><span class="line">	using Microsoft.AspNetCore.Mvc.ModelBinding;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Extensions</span><br><span class="line">	&#123;</span><br><span class="line">	    public static class ModelStateExtensions</span><br><span class="line">	    &#123;</span><br><span class="line">	        public static List&lt;string&gt; GetErrorMessages(this ModelStateDictionary dictionary)</span><br><span class="line">	        &#123;</span><br><span class="line">	            return dictionary.SelectMany(m =&gt; m.Value.Errors)</span><br><span class="line">	                             .Select(m =&gt; m.ErrorMessage)</span><br><span class="line">	                             .ToList();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>所有扩展方法以及声明它们的类都应该是<strong>静态的</strong>。** **这意味着它们不处理特定的实例数据，并且在应用程序启动时仅被加载一次。<br>this参数声明前面的关键字告诉C＃编译器将其视为扩展方法。结果是我们可以像此类的常规方法一样调用它，因为我们在要使用扩展的地方包含的特定的using代码。</p>
<p>该扩展使用<a href="https://www.tutorialsteacher.com/linq/what-is-linq" target="_blank" rel="noopener">LINQ查询</a>，这是.NET的非常有用的功能，它使我们能够使用链式语法来查询和转换数据。此处的表达式将验证错误方法转换为包含错误消息的字符串列表。</p>
<p>Supermarket.API.Extensions在进行下一步之前，将名称空间导入Categories控制器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using Supermarket.API.Extensions;</span><br></pre></td></tr></table></figure>

<p>让我们通过将新资源映射到类别模型类来继续实现端点逻辑。</p>
<h1 id="步骤11-映射新资源"><a href="#步骤11-映射新资源" class="headerlink" title="步骤11-映射新资源"></a><strong>步骤11-映射新资源</strong></h1><p>我们已经定义了映射配置文件，可以将模型转换为资源。现在，我们需要一个与之相反的新配置项。</p>
<p>ResourceToModelProfile在Mapping文件夹中添加一个新类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">using AutoMapper;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	using Supermarket.API.Resources;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Mapping</span><br><span class="line">	&#123;</span><br><span class="line">	    public class ResourceToModelProfile : Profile</span><br><span class="line">	    &#123;</span><br><span class="line">	        public ResourceToModelProfile()</span><br><span class="line">	        &#123;</span><br><span class="line">	            CreateMap&lt;SaveCategoryResource, Category&gt;();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有新内容。由于依赖注入的魔力，AutoMapper将在应用程序启动时自动注册此配置文件，而我们无需更改任何其他位置即可使用它。<br>现在，我们可以将新资源映射到相应的模型类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[HttpPost]</span><br><span class="line">	public async Task&lt;IActionResult&gt; PostAsync([FromBody] SaveCategoryResource resource)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!ModelState.IsValid)</span><br><span class="line">			return BadRequest(ModelState.GetErrorMessages());</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		var category = _mapper.Map&lt;SaveCategoryResource, Category&gt;(resource);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第12步-应用请求-响应模式来处理保存逻辑"><a href="#第12步-应用请求-响应模式来处理保存逻辑" class="headerlink" title="第12步-应用请求-响应模式来处理保存逻辑"></a><strong>第12步-应用请求-响应模式来处理保存逻辑</strong></h1><p>现在我们必须实现最有趣的逻辑：保存一个新类别。我们希望我们的服务能够做到。</p>
<p>由于连接到数据库时出现问题，或者由于任何内部业务规则使我们的数据无效，因此保存逻辑可能会失败。</p>
<p>如果出现问题，我们不能简单地抛出一个错误，因为它可能会停止API，并且客户端应用程序也不知道如何处理该问题。另外，我们可能会有某种日志记录机制来记录错误。</p>
<p>保存方法的约定（即方法的签名和响应类型）需要指示我们是否正确执行了该过程。如果处理正常，我们将接收类别数据。如果没有，我们至少必须收到一条错误消息，告诉您该过程失败的原因。</p>
<p>我们可以通过应用<strong>request-response模式</strong>来实现此功能。这种企业设计模式将我们的请求和响应参数封装到类中，以封装我们的服务将用于处理某些任务并将信息返回给正在使用该服务的类的信息。</p>
<p>这种模式为我们提供了一些优势，例如：</p>
<ul>
<li>如果我们需要更改服务以接收更多参数，则不必破坏其签名；</li>
<li>我们可以为我们的请求和/或响应定义标准合同；</li>
<li>我们可以在不停止应用程序流程的情况下处理业务逻辑和潜在的失败，并且我们不需要使用大量的try-catch块。</li>
</ul>
<p>让我们为处理数据更改的服务方法创建一个标准响应类型。对于这种类型的每个请求，我们都想知道该请求是否被正确执行。如果失败，我们要向客户端返回错误消息。</p>
<p>在Domain文件夹的内部Services，添加一个名为的新目录Communication。在此处添加一个名为的新类BaseResponse。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">namespace Supermarket.API.Domain.Services.Communication</span><br><span class="line">	&#123;</span><br><span class="line">	    public abstract class BaseResponse</span><br><span class="line">	    &#123;</span><br><span class="line">	        public bool Success &#123; get; protected set; &#125;</span><br><span class="line">	        public string Message &#123; get; protected set; &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public BaseResponse(bool success, string message)</span><br><span class="line">	        &#123;</span><br><span class="line">	            Success = success;</span><br><span class="line">	            Message = message;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>那是我们的响应类型将继承的抽象类。<br>抽象定义了一个Success属性和一个Message属性，该属性将告知请求是否已成功完成，如果失败，该属性将显示错误消息。</p>
<p>请注意，这些属性是必需的，只有继承的类才能设置此数据，因为子类必须通过构造函数传递此信息。</p>
<blockquote>
<p><strong>提示：</strong>为所有内容定义基类不是一个好习惯，因为<a href="https://en.wikipedia.org/wiki/Fragile_base_class" target="_blank" rel="noopener">基类会耦合您的代码</a>并阻止您轻松对其进行修改。优先使用<a href="https://medium.com/humans-create-software/composition-over-inheritance-cb6f88070205" target="_blank" rel="noopener">组合而不是继承</a>。</p>
<blockquote>
<p>在此API的范围内，使用基类并不是真正的问题，因为我们的服务不会增长太多。如果您意识到服务或应用程序会经常增长和更改，请避免使用基类。</p>
</blockquote>
</blockquote>
<p>现在，在同一文件夹中，添加一个名为的新类SaveCategoryResponse。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">using Supermarket.API.Domain.Models;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Domain.Services.Communication</span><br><span class="line">	&#123;</span><br><span class="line">	    public class SaveCategoryResponse : BaseResponse</span><br><span class="line">	    &#123;</span><br><span class="line">	        public Category Category &#123; get; private set; &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        private SaveCategoryResponse(bool success, string message, Category category) : base(success, message)</span><br><span class="line">	        &#123;</span><br><span class="line">	            Category = category;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        /// &lt;summary&gt;</span><br><span class="line">	        /// Creates a success response.</span><br><span class="line">	        /// &lt;/summary&gt;</span><br><span class="line">	        /// &lt;param name=&quot;category&quot;&gt;Saved category.&lt;/param&gt;</span><br><span class="line">	        /// &lt;returns&gt;Response.&lt;/returns&gt;</span><br><span class="line">	        public SaveCategoryResponse(Category category) : this(true, string.Empty, category)</span><br><span class="line">	        &#123; &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        /// &lt;summary&gt;</span><br><span class="line">	        /// Creates am error response.</span><br><span class="line">	        /// &lt;/summary&gt;</span><br><span class="line">	        /// &lt;param name=&quot;message&quot;&gt;Error message.&lt;/param&gt;</span><br><span class="line">	        /// &lt;returns&gt;Response.&lt;/returns&gt;</span><br><span class="line">	        public SaveCategoryResponse(string message) : this(false, message, null)</span><br><span class="line">	        &#123; &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>响应类型还设置了一个Category属性，如果请求成功完成，该属性将包含我们的类别数据。<br>请注意，我为此类定义了三种不同的构造函数：</p>
<ul>
<li>一个私有的，它将把成功和消息参数传递给基类，并设置Category属性。</li>
<li>仅接收类别作为参数的构造函数。这将创建一个成功的响应，调用私有构造函数来设置各自的属性；</li>
<li>第三个构造函数仅指定消息。这将用于创建故障响应。</li>
</ul>
<p>因为C＃支持多个构造函数，所以我们仅通过使用不同的构造函数就简化了响应的创建过程，而无需定义其他方法来处理此问题。</p>
<p>现在，我们可以更改服务界面以添加新的保存方法合同。</p>
<p>更改ICategoryService接口，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	using Supermarket.API.Domain.Services.Communication;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Domain.Services</span><br><span class="line">	&#123;</span><br><span class="line">	    public interface ICategoryService</span><br><span class="line">	    &#123;</span><br><span class="line">	         Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class="line">	         Task&lt;SaveCategoryResponse&gt; SaveAsync(Category category);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我们只需将类别传递给此方法，它将处理保存模型数据，编排仓储和其他必要服务所需的所有逻辑。<br>请注意，由于我们不需要任何其他参数来执行此任务，因此我不在此处创建特定的请求类。<a href="https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle" target="_blank" rel="noopener">计算机编程中</a>有一个名为<a href="https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle" target="_blank" rel="noopener">KISS</a>的<a href="https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle" target="_blank" rel="noopener">概念</a> —Keep It Simple，Stupid的简称。基本上，它说您应该使您的应用程序尽可能简单。</p>
<p>设计应用程序时请记住这一点：<strong>仅</strong>应用<strong>解决问题所需的内容</strong>。<strong>不要过度设计您的应用程序。</strong></p>
<p>现在我们可以完成端点逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[HttpPost]</span><br><span class="line">	public async Task&lt;IActionResult&gt; PostAsync([FromBody] SaveCategoryResource resource)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!ModelState.IsValid)</span><br><span class="line">			return BadRequest(ModelState.GetErrorMessages());</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		var category = _mapper.Map&lt;SaveCategoryResource, Category&gt;(resource);</span><br><span class="line">		var result = await _categoryService.SaveAsync(category);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		if (!result.Success)</span><br><span class="line">			return BadRequest(result.Message);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		var categoryResource = _mapper.Map&lt;Category, CategoryResource&gt;(result.Category);</span><br><span class="line">		return Ok(categoryResource);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在验证请求数据并将资源映射到我们的模型之后，我们将其传递给我们的服务以保留数据。<br>如果失败，则API返回错误的请求。如果没有，API会将新类别（现在包括诸如new的数据Id）映射到我们先前创建的类别CategoryResource，并将其发送给客户端。</p>
<p>现在，让我们为服务实现真正的逻辑。</p>
<p><strong>第13步—数据库逻辑和工作单元模式</strong></p>
<p>由于我们要将数据持久化到数据库中，因此我们需要在仓储中使用一种新方法。</p>
<p>向ICategoryRepository接口添加AddAsync新方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface ICategoryRepository</span><br><span class="line">	&#123;</span><br><span class="line">		 Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class="line">		 Task AddAsync(Category category);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们在真正的仓储类中实现此方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class CategoryRepository : BaseRepository, ICategoryRepository</span><br><span class="line">	&#123;</span><br><span class="line">		public CategoryRepository(AppDbContext context) : base(context)</span><br><span class="line">		&#123; &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		public async Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync()</span><br><span class="line">		&#123;</span><br><span class="line">			return await _context.Categories.ToListAsync();</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		public async Task AddAsync(Category category)</span><br><span class="line">		&#123;</span><br><span class="line">			await _context.Categories.AddAsync(category);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们只是在集合中添加一个新类别。<br>当我们向中添加类时DBSet&lt;&gt;，EF Core将开始跟踪模型发生的所有更改，并在当前状态下使用此数据生成将插入，更新或删除模型的查询。</p>
<p>当前的实现只是将模型添加到我们的集合中，但是<strong>我们的数据仍然不会保存</strong>。</p>
<p>在上下文类中提供了SaveChanges的方法，我们必须调用该方法才能真正将查询执行到数据库中。我之所以没有在这里调用它，是因为<a href="https://programmingwithmosh.com/entity-framework/common-mistakes-with-the-repository-pattern/" target="_blank" rel="noopener">仓储不应该持久化数据</a>，它只是一种内存集合对象。</p>
<p>即使在经验丰富的.NET开发人员之间，该主题也引起很大争议，但是让我向您解释为什么您不应该在仓储类中调用SaveChanges方法。</p>
<p>我们可以从概念上将仓储像.NET框架中存在的任何其他集合一样。在.NET（和许多其他编程语言，例如Javascript和Java）中处理集合时，通常可以：</p>
<ul>
<li>向其中添加新项（例如，当您将数据推送到列表，数组和字典时）；</li>
<li>查找或过滤项目；</li>
<li>从集合中删除一个项目；</li>
<li>替换给定的项目，或更新它。</li>
</ul>
<p>想一想现实世界中的清单。想象一下，您正在编写一份购物清单以在超市购买东西（<em>巧合，不是吗？</em>）。</p>
<p>在列表中，写下您需要购买的所有水果。您可以将水果添加到此列表中，如果放弃购买就删除水果，也可以替换水果的名称。但是您无法<strong>将</strong>水果<strong>保存</strong>到列表中。用简单的英语说这样的话是没有意义的。</p>
<blockquote>
<p><strong>提示：</strong>在使用面向对象的编程语言设计类和接口时，请尝试使用自然语言来检查您所做的工作是否正确。</p>
<blockquote>
<p>例如，说人实现了person的接口是有道理的，但是说一个人实现了一个帐户却没有道理。</p>
</blockquote>
</blockquote>
<p>如果您要“保存”水果清单（在这种情况下，要购买所有水果），请付款，然后超市会处理库存数据以检查他们是否必须从供应商处购买更多水果。</p>
<p>编程时可以应用相同的逻辑。仓储不应保存，更新或删除数据。相反，他们应该将其委托给其他类来处理此逻辑。</p>
<p>将数据直接保存到仓储中时，还有另一个问题：<strong>您不能使用transaction</strong>。</p>
<p>想象一下，我们的应用程序具有一种日志记录机制，该机制存储一些用户名，并且每次对API数据进行更改时都会执行操作。</p>
<p>现在想象一下，由于某种原因，您调用了一个更新用户名的服务（这是不常见的情况，但让我们考虑一下）。</p>
<p>您同意要更改虚拟用户表中的用户名，首先必须更新所有日志以正确告诉谁执行了该操作，对吗？</p>
<p>现在想象我们已经为用户和不同仓储中的日志实现了update方法，它们都调用了SaveChanges。如果这些方法之一在更新过程中失败，会发生什么？最终会导致数据不一致。</p>
<p>只有在一切完成之后，我们才应该将更改保存到数据库中。为此，我们必须使用<a href="https://en.wikipedia.org/wiki/Database_transaction" target="_blank" rel="noopener">transaction</a>，这基本上是大多数数据库实现的功能，只有在完成复杂的操作后才能保存数据。</p>
<p><em>“-好的，所以如果我们不能在这里保存东西，我们应该在哪里做？”</em></p>
<p>处理此问题的常见模式是<a href="https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application" target="_blank" rel="noopener">工作单元模式</a>。此模式包含一个类，该类将我们的AppDbContext实例作为依赖项接收，并公开用于开始，完成或中止事务的方法。</p>
<p>在这里，我们将使用工作单元的简单实现来解决我们的问题。</p>
<p>Repositories在Domain层的仓储文件夹Repositories内添加一个新接口IUnitOfWork：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">using System.Threading.Tasks;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Domain.Repositories</span><br><span class="line">	&#123;</span><br><span class="line">	    public interface IUnitOfWork</span><br><span class="line">	    &#123;</span><br><span class="line">	         Task CompleteAsync();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>如您所见，它仅公开一种将异步完成数据管理操作的方法。<br>现在让我们添加实际的实现。</p>
<p>在Persistence层RepositoriesRepositories文件夹中的添加一个名为的UnitOfWork的新类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using System.Threading.Tasks;</span><br><span class="line">	using Supermarket.API.Domain.Repositories;</span><br><span class="line">	using Supermarket.API.Persistence.Contexts;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Persistence.Repositories</span><br><span class="line">	&#123;</span><br><span class="line">	    public class UnitOfWork : IUnitOfWork</span><br><span class="line">	    &#123;</span><br><span class="line">	        private readonly AppDbContext _context;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public UnitOfWork(AppDbContext context)</span><br><span class="line">	        &#123;</span><br><span class="line">	            _context = context;     </span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public async Task CompleteAsync()</span><br><span class="line">	        &#123;</span><br><span class="line">	            await _context.SaveChangesAsync();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个简单，干净的实现，仅在使用仓储修改完所有更改后，才将所有更改保存到数据库中。<br>如果研究工作单元模式的实现，则会发现实现回滚操作的更复杂的模式。</p>
<p>由于<strong>EF Core已经在后台实现了仓储模式和工作单元</strong>，因此我们不必在意回滚方法。</p>
<p><em>“ - 什么？那么为什么我们必须创建所有这些接口和类？”</em></p>
<p>将持久性逻辑与业务规则分开在代码可重用性和维护方面具有许多优势。如果直接使用EF Core，我们最终将拥有更复杂的类，这些类将很难更改。</p>
<p>想象一下，将来您决定将ORM框架更改为其他框架，例如<a href="https://www.c-sharpcorner.com/article/crud-operation-in-asp-net-core-2-0-using-dapper-orm/" target="_blank" rel="noopener">Dapper</a>，或者由于性能而必须实施纯SQL查询。如果将查询逻辑与服务耦合在一起，将很难更改该逻辑，因为您必须在许多类中进行此操作。</p>
<p>使用仓储模式，您可以简单地实现一个新的仓储类并使用依赖注入将其绑定。</p>
<p>因此，基本上，如果您直接在服务中使用EF Core，并且必须进行一些更改，那么您将获得：</p>
<p>就像我说的那样，EF Core在后台实现了工作单元和仓储模式。我们可以将DbSet&lt;&gt;属性视为仓储。而且，SaveChanges仅在所有数据库操作成功的情况下才保留数据。</p>
<p>现在，您知道什么是工作单元以及为什么将其与仓储一起使用，让我们实现真实服务的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class CategoryService : ICategoryService</span><br><span class="line">	&#123;</span><br><span class="line">		private readonly ICategoryRepository _categoryRepository;</span><br><span class="line">		private readonly IUnitOfWork _unitOfWork;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		public CategoryService(ICategoryRepository categoryRepository, IUnitOfWork unitOfWork)</span><br><span class="line">		&#123;</span><br><span class="line">			_categoryRepository = categoryRepository;</span><br><span class="line">			_unitOfWork = unitOfWork;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		public async Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync()</span><br><span class="line">		&#123;</span><br><span class="line">			return await _categoryRepository.ListAsync();</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		public async Task&lt;SaveCategoryResponse&gt; SaveAsync(Category category)</span><br><span class="line">		&#123;</span><br><span class="line">			try</span><br><span class="line">			&#123;</span><br><span class="line">				await _categoryRepository.AddAsync(category);</span><br><span class="line">				await _unitOfWork.CompleteAsync();</span><br><span class="line">				</span><br><span class="line">				return new SaveCategoryResponse(category);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Exception ex)</span><br><span class="line">			&#123;</span><br><span class="line">				// Do some logging stuff</span><br><span class="line">				return new SaveCategoryResponse($&quot;An error occurred when saving the category: &#123;ex.Message&#125;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>多亏了我们的解耦架构，我们可以简单地将实例UnitOfWork作为此类的依赖传递。<br>我们的业务逻辑非常简单。</p>
<p>首先，我们尝试将新类别添加到数据库中，然后API尝试保存新类别，将所有内容包装在try-catch块中。</p>
<p>如果失败，则API会调用一些虚构的日志记录服务，并返回指示失败的响应。</p>
<p>如果该过程顺利完成，则应用程序将返回成功响应，并发送我们的类别数据。简单吧？</p>
<blockquote>
<p><strong>提示：</strong>在现实世界的应用程序中，您不应将所有内容包装在通用的try-catch块中，而应分别处理所有可能的错误。</p>
<blockquote>
<p>简单地添加一个try-catch块并不能解决大多数可能的失败情况。请确保正确实现错误处理。</p>
</blockquote>
</blockquote>
<p>测试我们的API之前的最后一步是将工作单元接口绑定到其各自的类。</p>
<p>将此新行添加到类的ConfigureServices方法中Startup：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddScoped&lt;IUnitOfWork, UnitOfWork&gt;();</span><br></pre></td></tr></table></figure>

<p>现在让我们测试一下！<br><strong>第14步-使用Postman测试我们的POST端点</strong></p>
<p>重新启动我们的应用程序dotnet run。</p>
<p>我们无法使用浏览器测试POST端点。让我们使用<strong>Postman</strong>测试我们的端点。这是测试RESTful API的非常有用的工具。</p>
<p>打开<strong>Postman</strong>，然后关闭介绍性消息。您会看到这样的屏幕：</p>
<p><img src="https://uploader.shimo.im/f/k9uqO0tzHP8sXyGu.png!thumbnail" alt="图片"></p>
<p>屏幕显示测试端点的选项</p>
<p>GET默认情况下，将所选内容更改为选择框POST。</p>
<p>在Enter request URL字段中输入API地址。</p>
<p>我们必须提供请求正文数据以发送到我们的API。单击Body菜单项，然后将其下方显示的选项更改为raw。</p>
<p>Postman将在右侧显示一个Text选项，将其更改为JSON (application/json)并粘贴以下JSON数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://uploader.shimo.im/f/aMktVnVAavwvF3Q3.png!thumbnail" alt="图片">发送请求前的屏幕</p>
<p>如您所见，我们将向我们的新端点发送一个空的名称字符串。</p>
<p>点击Send按钮。您将收到如下输出：</p>
<p><img src="https://uploader.shimo.im/f/5yuSjCfYKD0ELqiA.png!thumbnail" alt="图片"></p>
<p>如您所见，我们的验证逻辑有效！</p>
<p>您还记得我们为端点创建的验证逻辑吗？此输出是它起作用的证明！</p>
<p>还要注意右侧显示的400状态代码。该BadRequest结果自动将此状态码的响应。</p>
<p>现在，让我们将JSON数据更改为有效数据，以查看新的响应：</p>
<p><img src="https://uploader.shimo.im/f/zDpJNG3Yl8Q0XimL.png!thumbnail" alt="图片"></p>
<p>最后，我们期望得到的结果</p>
<p>API正确创建了我们的新资源。</p>
<p>到目前为止，我们的API可以列出和创建类别。您学到了很多有关C＃语言，ASP.NET Core框架以及构造API的通用设计方法的知识。</p>
<p>让我们继续我们的类别API，创建用于更新类别的端点。</p>
<p>从现在开始，由于我向您解释了大多数概念，因此我将加快解释速度，并专注于新主题，以免浪费您的时间。 Let’s go!</p>
<h1 id="第15步-更新类别"><a href="#第15步-更新类别" class="headerlink" title="第15步-更新类别"></a><strong>第15步-更新类别</strong></h1><p>要更新类别，我们需要一个HTTP PUT端点。</p>
<p>我们必须编写的逻辑与POST逻辑非常相似：</p>
<ul>
<li>首先，我们必须使用来验证传入的请求ModelState。</li>
<li>如果请求有效，则API应使用AutoMapper将传入资源映射到模型类。</li>
<li>然后，我们需要调用我们的服务，告诉它更新类别，提供相应的类别Id和更新的数据；</li>
<li>如果Id数据库中没有给定的类别，我们将返回错误的请求。我们可以使用NotFound结果来代替，但是对于这个范围而言，这并不重要，因为我们向客户端应用程序提供了错误消息。</li>
<li>如果正确执行了保存逻辑，则服务必须返回包含更新的类别数据的响应。如果不是，它应该给我们指示该过程失败，并显示一条消息指示原因；</li>
<li>最后，如果有错误，则API返回错误的请求。如果不是，它将更新的类别模型映射到类别资源，并将成功响应返回给客户端应用程序。</li>
</ul>
<p>让我们将新PutAsync方法添加到控制器类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[HttpPut(&quot;&#123;id&#125;&quot;)]</span><br><span class="line">	public async Task&lt;IActionResult&gt; PutAsync(int id, [FromBody] SaveCategoryResource resource)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!ModelState.IsValid)</span><br><span class="line">			return BadRequest(ModelState.GetErrorMessages());</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		var category = _mapper.Map&lt;SaveCategoryResource, Category&gt;(resource);</span><br><span class="line">		var result = await _categoryService.UpdateAsync(id, category);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		if (!result.Success)</span><br><span class="line">			return BadRequest(result.Message);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		var categoryResource = _mapper.Map&lt;Category, CategoryResource&gt;(result.Category);</span><br><span class="line">		return Ok(categoryResource);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>如果将其与POST逻辑进行比较，您会注意到这里只有一个区别：HttPut属性指定给定路由应接收的参数。<br>我们将调用此端点，将类别指定Id 为最后一个URL片段，例如/api/categories/1。ASP.NET Core管道将此片段解析为相同名称的参数。</p>
<p>现在我们必须UpdateAsync在ICategoryService接口中定义方法签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ICategoryService</span><br><span class="line">	&#123;</span><br><span class="line">		Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class="line">		Task&lt;SaveCategoryResponse&gt; SaveAsync(Category category);</span><br><span class="line">		Task&lt;SaveCategoryResponse&gt; UpdateAsync(int id, Category category);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们转向真正的逻辑。</p>
<h1 id="第16步-更新逻辑"><a href="#第16步-更新逻辑" class="headerlink" title="第16步-更新逻辑"></a><strong>第16步-更新逻辑</strong></h1><p>首先，要更新类别，我们需要从数据库中返回当前数据（如果存在）。我们还需要将其更新到我们的中DBSet&lt;&gt;。</p>
<p>让我们在ICategoryService界面中添加两个新的方法约定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface ICategoryRepository</span><br><span class="line">	&#123;</span><br><span class="line">		Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class="line">		Task AddAsync(Category category);</span><br><span class="line">		Task&lt;Category&gt; FindByIdAsync(int id);</span><br><span class="line">		void Update(Category category);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经定义了FindByIdAsync方法，该方法将从数据库中异步返回一个类别，以及该Update方法。请注意，该Update方法不是异步的，因为EF Core API不需要异步方法来更新模型。<br>现在，让我们在CategoryRepository类中实现真正的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public async Task&lt;Category&gt; FindByIdAsync(int id)</span><br><span class="line">	&#123;</span><br><span class="line">		return await _context.Categories.FindAsync(id);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	public void Update(Category category)</span><br><span class="line">	&#123;</span><br><span class="line">		_context.Categories.Update(category);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们可以对服务逻辑进行编码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public async Task&lt;SaveCategoryResponse&gt; UpdateAsync(int id, Category category)</span><br><span class="line">	&#123;</span><br><span class="line">		var existingCategory = await _categoryRepository.FindByIdAsync(id);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		if (existingCategory == null)</span><br><span class="line">			return new SaveCategoryResponse(&quot;Category not found.&quot;);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		existingCategory.Name = category.Name;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		try</span><br><span class="line">		&#123;</span><br><span class="line">			_categoryRepository.Update(existingCategory);</span><br><span class="line">			await _unitOfWork.CompleteAsync();</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">			return new SaveCategoryResponse(existingCategory);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception ex)</span><br><span class="line">		&#123;</span><br><span class="line">			// Do some logging stuff</span><br><span class="line">			return new SaveCategoryResponse($&quot;An error occurred when updating the category: &#123;ex.Message&#125;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>API尝试从数据库中获取类别。如果结果为null，我们将返回一个响应，告知该类别不存在。如果类别存在，我们需要设置其新名称。<br>然后，API会尝试保存更改，例如创建新类别时。如果该过程完成，则该服务将返回成功响应。如果不是，则执行日志记录逻辑，并且端点接收包含错误消息的响应。</p>
<p>现在让我们对其进行测试。首先，让我们添加一个新类别Id以使用有效类别。我们可以使用播种到数据库中的类别的标识符，但是我想通过这种方式向您展示我们的API将更新正确的资源。</p>
<p>再次运行该应用程序，然后使用Postman将新类别发布到数据库中：</p>
<p><img src="https://uploader.shimo.im/f/fxIzjvpz7Y0kf8XP.png!thumbnail" alt="图片"></p>
<p>添加新类别以供日后更新</p>
<p>使用一个可用的数据Id，将POST 选项更改PUT为选择框，然后在URL的末尾添加ID值。将name属性更改为其他名称，然后发送请求以检查结果：</p>
<p><img src="https://uploader.shimo.im/f/VMXmxLVsZNsqqXSK.png!thumbnail" alt="图片"></p>
<p>类别数据已成功更新</p>
<p>您可以将GET请求发送到API端点，以确保您正确编辑了类别名称：</p>
<p><img src="https://uploader.shimo.im/f/G5ipYxpQk5gJSVBI.png!thumbnail" alt="图片"></p>
<p>那是现在GET请求的结果</p>
<p>我们必须对类别执行的最后一项操作是排除类别。让我们创建一个HTTP Delete端点。</p>
<h1 id="第17步-删除类别"><a href="#第17步-删除类别" class="headerlink" title="第17步-删除类别"></a><strong>第17步-删除类别</strong></h1><p>删除类别的逻辑确实很容易实现，因为我们所需的大多数方法都是先前构建的。</p>
<p>这些是我们工作路线的必要步骤：</p>
<ul>
<li>API需要调用我们的服务，告诉它删除我们的类别，并提供相应的Id;</li>
<li>如果数据库中没有具有给定ID的类别，则该服务应返回一条消息指出该类别；</li>
<li>如果执行删除逻辑没有问题，则服务应返回包含我们已删除类别数据的响应。如果没有，它应该给我们一个指示，表明该过程失败了，并可能出现错误消息。</li>
<li>最后，如果有错误，则API返回错误的请求。如果不是，则API会将更新的类别映射到资源，并向客户端返回成功响应。</li>
</ul>
<p>让我们开始添加新的端点逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[HttpDelete(&quot;&#123;id&#125;&quot;)]</span><br><span class="line">	public async Task&lt;IActionResult&gt; DeleteAsync(int id)</span><br><span class="line">	&#123;</span><br><span class="line">		var result = await _categoryService.DeleteAsync(id);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		if (!result.Success)</span><br><span class="line">			return BadRequest(result.Message);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		var categoryResource = _mapper.Map&lt;Category, CategoryResource&gt;(result.Category);</span><br><span class="line">		return Ok(categoryResource);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>该HttpDelete属性还定义了一个id 模板。<br>在将DeleteAsync签名添加到我们的ICategoryService接口之前，我们需要做一些小的重构。</p>
<p>新的服务方法必须返回包含类别数据的响应，就像对PostAsyncand UpdateAsync方法所做的一样。我们可以SaveCategoryResponse为此目的重用，但在这种情况下我们不会保存数据。</p>
<p>为了避免创建具有相同形状的新类来满足此要求，我们可以将我们重命名SaveCategoryResponse为CategoryResponse。</p>
<p>如果您使用的是Visual Studio Code，则可以打开SaveCategoryResponse类，将鼠标光标放在类名上方，然后使用选项Change All Occurrences<strong>* *</strong>来重命名该类：</p>
<p><img src="https://uploader.shimo.im/f/9F3zYANcrMUdFlMe.png!thumbnail" alt="图片"></p>
<p>确保也重命名文件名。</p>
<p>让我们将DeleteAsync方法签名添加到ICategoryService 接口中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface ICategoryService</span><br><span class="line">	&#123;</span><br><span class="line">		Task&lt;IEnumerable&lt;Category&gt;&gt; ListAsync();</span><br><span class="line">		Task&lt;CategoryResponse&gt; SaveAsync(Category category);</span><br><span class="line">		Task&lt;CategoryResponse&gt; UpdateAsync(int id, Category category);</span><br><span class="line">		Task&lt;CategoryResponse&gt; DeleteAsync(int id);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在实施删除逻辑之前，我们需要在仓储中使用一种新方法。<br>将Remove方法签名添加到ICategoryRepository接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Remove(Category category);</span><br></pre></td></tr></table></figure>

<p>现在，在仓储类上添加真正的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void Remove(Category category)</span><br><span class="line">	&#123;</span><br><span class="line">		_context.Categories.Remove(category);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>EF Core要求将模型的实例传递给Remove方法，以正确了解我们要删除的模型，而不是简单地传递Id。<br>最后，让我们在CategoryService类上实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public async Task&lt;CategoryResponse&gt; DeleteAsync(int id)</span><br><span class="line">	&#123;</span><br><span class="line">		var existingCategory = await _categoryRepository.FindByIdAsync(id);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		if (existingCategory == null)</span><br><span class="line">			return new CategoryResponse(&quot;Category not found.&quot;);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		try</span><br><span class="line">		&#123;</span><br><span class="line">			_categoryRepository.Remove(existingCategory);</span><br><span class="line">			await _unitOfWork.CompleteAsync();</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">			return new CategoryResponse(existingCategory);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception ex)</span><br><span class="line">		&#123;</span><br><span class="line">			// Do some logging stuff</span><br><span class="line">			return new CategoryResponse($&quot;An error occurred when deleting the category: &#123;ex.Message&#125;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有新内容。该服务尝试通过ID查找类别，然后调用我们的仓储以删除类别。最后，工作单元完成将实际操作执行到数据库中的事务。<br><em>“-嘿，但是每个类别的产品呢？为避免出现错误，您是否不需要先创建仓储并删除产品？”</em></p>
<p>答案是<strong>否定的</strong>。借助<a href="https://docs.microsoft.com/en-us/ef/core/querying/tracking" target="_blank" rel="noopener">EF Core跟踪机制</a>，当我们从数据库中加载模型时，框架便知道了该模型具有哪些关系。如果我们删除它，EF Core知道它应该首先递归删除所有相关模型。</p>
<p>在将类映射到数据库表时，我们可以禁用此功能，但这在本教程的范围之外。如果您想了解此功能，<a href="https://entityframeworkcore.com/saving-data-cascade-delete" target="_blank" rel="noopener">请看这里</a>。</p>
<p>现在是时候测试我们的新端点了。再次运行该应用程序，并使用Postman发送DELETE请求，如下所示：</p>
<p><img src="https://uploader.shimo.im/f/VRCjsPelqx4qADIx.png!thumbnail" alt="图片"></p>
<p>如您所见，API毫无问题地删除了现有类别</p>
<p>我们可以通过发送GET请求来检查我们的API是否正常工作：</p>
<p><img src="https://uploader.shimo.im/f/iyiKvuB7e0IfSTQf.png!thumbnail" alt="图片">我们已经完成了类别API。现在是时候转向产品API。</p>
<h1 id="步骤18-产品API"><a href="#步骤18-产品API" class="headerlink" title="步骤18-产品API"></a><strong>步骤18-产品API</strong></h1><p>到目前为止，您已经学习了如何实现所有基本的HTTP动词来使用ASP.NET Core处理CRUD操作。让我们进入实现产品API的下一个层次。</p>
<p>我将不再详细介绍所有HTTP动词，因为这将是详尽无遗的。在本教程的最后一部分，我将仅介绍GET请求，以向您展示在从数据库查询数据时如何包括相关实体，以及如何使用Description我们为EUnitOfMeasurement 枚举值定义的属性。</p>
<p>将新控制器ProductsController添加到名为Controllers的文件夹中。</p>
<p>在这里编写任何代码之前，我们必须创建产品资源。</p>
<p>让我刷新您的记忆，再次显示我们的资源应如何：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> [</span><br><span class="line">  &#123;</span><br><span class="line">   &quot;id&quot;: 1,</span><br><span class="line">   &quot;name&quot;: &quot;Sugar&quot;,</span><br><span class="line">   &quot;quantityInPackage&quot;: 1,</span><br><span class="line">   &quot;unitOfMeasurement&quot;: &quot;KG&quot;</span><br><span class="line">   &quot;category&quot;: &#123;</span><br><span class="line">   &quot;id&quot;: 3,</span><br><span class="line">   &quot;name&quot;: &quot;Sugar&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  … // Other products</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想要一个包含数据库中所有产品的JSON数组。<br>JSON数据与产品模型有两点不同：</p>
<ul>
<li>测量单位以较短的方式显示，仅显示其缩写。</li>
<li>我们输出类别数据<strong>而不</strong>包括CategoryId属性。</li>
</ul>
<p>为了表示度量单位，我们可以使用简单的字符串属性代替枚举类型（顺便说一下，我们没有JSON数据的默认枚举类型，因此我们必须将其转换为其他类型）。</p>
<p>现在，我们现在要塑造新资源，让我们创建它。ProductResource在Resources文件夹中添加一个新类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">namespace Supermarket.API.Resources</span><br><span class="line">	&#123;</span><br><span class="line">	    public class ProductResource</span><br><span class="line">	    &#123;</span><br><span class="line">	        public int Id &#123; get; set; &#125;</span><br><span class="line">	        public string Name &#123; get; set; &#125;</span><br><span class="line">	        public int QuantityInPackage &#123; get; set; &#125;</span><br><span class="line">	        public string UnitOfMeasurement &#123; get; set; &#125;</span><br><span class="line">	        public CategoryResource Category &#123;get;set;&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们必须配置模型类和新资源类之间的映射。<br>映射配置将与用于其他映射的配置几乎相同，但是在这里，我们必须处理将EUnitOfMeasurement枚举转换为字符串的操作。</p>
<p>您还记得StringValue应用于枚举类型的属性吗？现在，我将向您展示如何使用.NET框架的强大功能：<a href="https://www.tutorialspoint.com/csharp/csharp_reflection.htm" target="_blank" rel="noopener">反射 API</a>提取此信息。</p>
<p>反射 API是一组强大的资源工具集，可让我们提取和操作元数据。许多框架和库（包括ASP.NET Core本身）都利用这些资源来处理许多后台工作。</p>
<p>现在让我们看看它在实践中是如何工作的。将新类添加到Extensions名为的文件夹中EnumExtensions。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">using System.ComponentModel;</span><br><span class="line">	using System.Reflection;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Extensions</span><br><span class="line">	&#123;</span><br><span class="line">	    public static class EnumExtensions</span><br><span class="line">	    &#123;</span><br><span class="line">	        public static string ToDescriptionString&lt;TEnum&gt;(this TEnum @enum)</span><br><span class="line">	        &#123;</span><br><span class="line">	            FieldInfo info = @enum.GetType().GetField(@enum.ToString());</span><br><span class="line">	            var attributes = (DescriptionAttribute[])info.GetCustomAttributes(typeof(DescriptionAttribute), false);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            return attributes?[0].Description ?? @enum.ToString();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>第一次看代码可能会让人感到恐惧，但这并不复杂。让我们分解代码定义以了解其工作原理。<br>首先，我们定义了一种<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/" target="_blank" rel="noopener">通用方法</a>（一种方法，该方法可以接收不止一种类型的参数，在这种情况下，该方法由TEnum声明表示），该方法接收给定的枚举作为参数。</p>
<p>由于enum是C＃中的保留关键字，因此我们在参数名称前面添加了@，以使其成为有效名称。</p>
<p>该方法的第一步是使用该方法获取参数的类型信息（类，接口，枚举或结构定义）GetType。</p>
<p>然后，该方法使用来获取特定的枚举值（例如Kilogram）GetField(@enum.ToString())。</p>
<p>下一行找到Description应用于枚举值的所有属性，并将其数据存储到数组中（在某些情况下，我们可以为同一属性指定多个属性）。</p>
<p>最后一行使用较短的语法来检查我们是否至少有一个枚举类型的描述属性。如果有，我们将返回Description此属性提供的值。如果不是，我们使用默认的强制类型转换将枚举作为字符串返回。</p>
<p>?.操作者（<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/conditional-operator" target="_blank" rel="noopener">零条件运算</a>）检查该值是否null访问其属性之前。</p>
<p>??运算符（<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator" target="_blank" rel="noopener">空合并运算符</a>）告诉应用程序在左边的返回值，如果它不为空，或者在正确的，否则价值。</p>
<p>现在我们有了扩展方法来提取描述，让我们配置模型和资源之间的映射。多亏了AutoMapper，我们只需要多一行就可以做到这一点。</p>
<p>打开ModelToResourceProfile类并通过以下方式更改代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using AutoMapper;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	using Supermarket.API.Extensions;</span><br><span class="line">	using Supermarket.API.Resources;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Mapping</span><br><span class="line">	&#123;</span><br><span class="line">	    public class ModelToResourceProfile : Profile</span><br><span class="line">	    &#123;</span><br><span class="line">	        public ModelToResourceProfile()</span><br><span class="line">	        &#123;</span><br><span class="line">	            CreateMap&lt;Category, CategoryResource&gt;();</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	            CreateMap&lt;Product, ProductResource&gt;()</span><br><span class="line">	                .ForMember(src =&gt; src.UnitOfMeasurement,</span><br><span class="line">	                           opt =&gt; opt.MapFrom(src =&gt; src.UnitOfMeasurement.ToDescriptionString()));</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>此语法告诉AutoMapper使用新的扩展方法将我们的EUnitOfMeasurement值转换为包含其描述的字符串。简单吧？您可以<a href="http://docs.automapper.org/en/stable/Inline-Mapping.html" target="_blank" rel="noopener">阅读官方文档</a>以了解完整语法。<br>注意，我们尚未为category属性定义任何映射配置。因为我们之前为类别配置了映射，并且由于产品模型具有相同类型和名称的category属性，所以AutoMapper隐式知道应该使用各自的配置来映射它。</p>
<p>现在，我们添加端点代码。更改ProductsController代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	using AutoMapper;</span><br><span class="line">	using Microsoft.AspNetCore.Mvc;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	using Supermarket.API.Domain.Services;</span><br><span class="line">	using Supermarket.API.Resources;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Controllers</span><br><span class="line">	&#123;</span><br><span class="line">	    [Route(&quot;/api/[controller]&quot;)]</span><br><span class="line">	    public class ProductsController : Controller</span><br><span class="line">	    &#123;</span><br><span class="line">	        private readonly IProductService _productService;</span><br><span class="line">	        private readonly IMapper _mapper;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public ProductsController(IProductService productService, IMapper mapper)</span><br><span class="line">	        &#123;</span><br><span class="line">	            _productService = productService;</span><br><span class="line">	            _mapper = mapper;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        [HttpGet]</span><br><span class="line">	        public async Task&lt;IEnumerable&lt;ProductResource&gt;&gt; ListAsync()</span><br><span class="line">	        &#123;</span><br><span class="line">	            var products = await _productService.ListAsync();</span><br><span class="line">	            var resources = _mapper.Map&lt;IEnumerable&lt;Product&gt;, IEnumerable&lt;ProductResource&gt;&gt;(products);</span><br><span class="line">	            return resources;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>基本上，为类别控制器定义的结构相同。<br>让我们进入服务部分。将一个新IProductService接口添加到Domain层中的Services文件夹中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Domain.Services</span><br><span class="line">	&#123;</span><br><span class="line">	    public interface IProductService</span><br><span class="line">	    &#123;</span><br><span class="line">	         Task&lt;IEnumerable&lt;Product&gt;&gt; ListAsync();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>您应该已经意识到，在真正实现新服务之前，我们需要一个仓储。<br>IProductRepository在相应的文件夹中添加一个名为的新接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Domain.Repositories</span><br><span class="line">	&#123;</span><br><span class="line">	    public interface IProductRepository</span><br><span class="line">	    &#123;</span><br><span class="line">	         Task&lt;IEnumerable&lt;Product&gt;&gt; ListAsync();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们实现仓储。除了必须在查询数据时返回每个产品的相应类别数据外，我们几乎必须像对类别仓储一样实现。<br>默认情况下，EF Core在查询数据时不包括与模型相关的实体，因为它可能非常慢（想象一个具有十个相关实体的模型，所有相关实体都有自己的关系）。</p>
<p>要包括类别数据，我们只需要多一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	using Microsoft.EntityFrameworkCore;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	using Supermarket.API.Domain.Repositories;</span><br><span class="line">	using Supermarket.API.Persistence.Contexts;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Persistence.Repositories</span><br><span class="line">	&#123;</span><br><span class="line">	    public class ProductRepository : BaseRepository, IProductRepository</span><br><span class="line">	    &#123;</span><br><span class="line">	        public ProductRepository(AppDbContext context) : base(context)</span><br><span class="line">	        &#123;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public async Task&lt;IEnumerable&lt;Product&gt;&gt; ListAsync()</span><br><span class="line">	        &#123;</span><br><span class="line">	            return await _context.Products.Include(p =&gt; p.Category)</span><br><span class="line">	                                          .ToListAsync();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>请注意对的调用Include(p =&gt; p.Category)。我们可以链接此语法，以在查询数据时包含尽可能多的实体。执行选择时，EF Core会将其转换为联接。<br>现在，我们可以ProductService像处理类别一样实现类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">	using System.Threading.Tasks;</span><br><span class="line">	using Supermarket.API.Domain.Models;</span><br><span class="line">	using Supermarket.API.Domain.Repositories;</span><br><span class="line">	using Supermarket.API.Domain.Services;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	namespace Supermarket.API.Services</span><br><span class="line">	&#123;</span><br><span class="line">	    public class ProductService : IProductService</span><br><span class="line">	    &#123;</span><br><span class="line">	        private readonly IProductRepository _productRepository;</span><br><span class="line">	    </span><br><span class="line">	        public ProductService(IProductRepository productRepository)</span><br><span class="line">	        &#123;</span><br><span class="line">	            _productRepository = productRepository;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	        public async Task&lt;IEnumerable&lt;Product&gt;&gt; ListAsync()</span><br><span class="line">	        &#123;</span><br><span class="line">	            return await _productRepository.ListAsync();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>让我们绑定更改Startup类的新依赖项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void ConfigureServices(IServiceCollection services)</span><br><span class="line">	&#123;</span><br><span class="line">	    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    services.AddDbContext&lt;AppDbContext&gt;(options =&gt;</span><br><span class="line">	    &#123;</span><br><span class="line">	        options.UseInMemoryDatabase(&quot;supermarket-api-in-memory&quot;);</span><br><span class="line">	    &#125;);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    services.AddScoped&lt;ICategoryRepository, CategoryRepository&gt;();</span><br><span class="line">	    services.AddScoped&lt;IProductRepository, ProductRepository&gt;();</span><br><span class="line">	    services.AddScoped&lt;IUnitOfWork, UnitOfWork&gt;();</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    services.AddScoped&lt;ICategoryService, CategoryService&gt;();</span><br><span class="line">	    services.AddScoped&lt;IProductService, ProductService&gt;();</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    services.AddAutoMapper();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在测试API之前，让我们AppDbContext在初始化应用程序时更改类以包括一些产品，以便我们看到结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">protected override void OnModelCreating(ModelBuilder builder)</span><br><span class="line">	&#123;</span><br><span class="line">	    base.OnModelCreating(builder);</span><br><span class="line">	    </span><br><span class="line">	    builder.Entity&lt;Category&gt;().ToTable(&quot;Categories&quot;);</span><br><span class="line">	    builder.Entity&lt;Category&gt;().HasKey(p =&gt; p.Id);</span><br><span class="line">	    builder.Entity&lt;Category&gt;().Property(p =&gt; p.Id).IsRequired().ValueGeneratedOnAdd().HasValueGenerator&lt;InMemoryIntegerValueGenerator&lt;int&gt;&gt;();</span><br><span class="line">	    builder.Entity&lt;Category&gt;().Property(p =&gt; p.Name).IsRequired().HasMaxLength(30);</span><br><span class="line">	    builder.Entity&lt;Category&gt;().HasMany(p =&gt; p.Products).WithOne(p =&gt; p.Category).HasForeignKey(p =&gt; p.CategoryId);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    builder.Entity&lt;Category&gt;().HasData</span><br><span class="line">	    (</span><br><span class="line">	        new Category &#123; Id = 100, Name = &quot;Fruits and Vegetables&quot; &#125;, // Id set manually due to in-memory provider</span><br><span class="line">	        new Category &#123; Id = 101, Name = &quot;Dairy&quot; &#125;</span><br><span class="line">	    );</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    builder.Entity&lt;Product&gt;().ToTable(&quot;Products&quot;);</span><br><span class="line">	    builder.Entity&lt;Product&gt;().HasKey(p =&gt; p.Id);</span><br><span class="line">	    builder.Entity&lt;Product&gt;().Property(p =&gt; p.Id).IsRequired().ValueGeneratedOnAdd();</span><br><span class="line">	    builder.Entity&lt;Product&gt;().Property(p =&gt; p.Name).IsRequired().HasMaxLength(50);</span><br><span class="line">	    builder.Entity&lt;Product&gt;().Property(p =&gt; p.QuantityInPackage).IsRequired();</span><br><span class="line">	    builder.Entity&lt;Product&gt;().Property(p =&gt; p.UnitOfMeasurement).IsRequired();</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	    builder.Entity&lt;Product&gt;().HasData</span><br><span class="line">	    (</span><br><span class="line">	        new Product</span><br><span class="line">	        &#123;</span><br><span class="line">	            Id = 100,</span><br><span class="line">	            Name = &quot;Apple&quot;,</span><br><span class="line">	            QuantityInPackage = 1,</span><br><span class="line">	            UnitOfMeasurement = EUnitOfMeasurement.Unity,</span><br><span class="line">	            CategoryId = 100</span><br><span class="line">	        &#125;,</span><br><span class="line">	        new Product</span><br><span class="line">	        &#123;</span><br><span class="line">	            Id = 101,</span><br><span class="line">	            Name = &quot;Milk&quot;,</span><br><span class="line">	            QuantityInPackage = 2,</span><br><span class="line">	            UnitOfMeasurement = EUnitOfMeasurement.Liter,</span><br><span class="line">	            CategoryId = 101,</span><br><span class="line">	        &#125;</span><br><span class="line">	    );</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我添加了两个虚构产品，将它们与初始化应用程序时我们播种的类别相关联。<br>该测试了！再次运行API并发送GET请求以/api/products使用Postman：</p>
<p><img src="https://uploader.shimo.im/f/h9cMeoAIZg4vyRgj.png!thumbnail" alt="图片"></p>
<p>就是这样！恭喜你！</p>
<p>现在，您将了解如何使用解耦的代码架构使用ASP.NET Core构建RESTful API。您了解了.NET Core框架的许多知识，如何使用C＃，EF Core和AutoMapper的基础知识以及在设计应用程序时要使用的许多有用的模式。</p>
<p>您可以检查API的完整实现，包括产品的其他HTTP动词，并检查Github仓储：</p>
<p><a href="https://github.com/evgomes/supermarket-api" target="_blank" rel="noopener">evgomes / supermarket-api</a></p>
<p><a href="https://github.com/evgomes/supermarket-api" target="_blank" rel="noopener">使用ASP.NET Core 2.2构建的简单RESTful API，展示了如何使用分离的，可维护的……创建RESTful服务</a><a href="https://github.com/evgomes/supermarket-api" target="_blank" rel="noopener">。github.com</a></p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h1><p>ASP.NET Core是创建Web应用程序时使用的出色框架。它带有许多有用的API，可用于构建干净，可维护的应用程序。创建专业应用程序时，可以将其视为一种选择。</p>
<p>本文并未涵盖专业API的所有方面，但您已学习了所有基础知识。您还学到了许多有用的模式，可以解决我们每天面临的模式。</p>
<p>希望您喜欢这篇文章，希望对您有所帮助。期待你的反馈，以便我能进一步提高。</p>
<p><strong>进一步学习的可用参考资料</strong></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/core/tutorials/" target="_blank" rel="noopener">.NET Core教程-Microsoft文档</a></p>
<p><a href="https://docs.microsoft.com/zh-cn/aspnet/#pivot=core&panel=core_tutorials" target="_blank" rel="noopener">ASP.NET Core文档-Microsoft文档</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">溪源</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">65</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">categories</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.cnblogs.com/xiyuanmore" title="博客园 &rarr; https://www.cnblogs.com/xiyuanmore" rel="noopener" target="_blank"><i class="fa fa-fw fa-博客园"></i>博客园</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/farway000" title="CSDN &rarr; https://blog.csdn.net/farway000" rel="noopener" target="_blank"><i class="fa fa-fw fa-CSDN"></i>CSDN</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">溪源</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.2</div>
#<div><a href="http://www.beian.miit.gov.cn/">ICP备案号:湘ICP备19001531号-2</a></div>



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
