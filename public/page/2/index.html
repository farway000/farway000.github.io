<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="xiyuan技术圈">
<meta property="og:url" content="http://techq.xyz/page/2/index.html">
<meta property="og:site_name" content="xiyuan技术圈">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xiyuan技术圈">





  
  
  <link rel="canonical" href="http://techq.xyz/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>xiyuan技术圈</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiyuan技术圈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">溪源的技术博客，技术的不断进取之路</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-技术">

    
    
    
      
    

    

    <a href="/categories/技术/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>技术</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-随笔">

    
    
    
      
    

    

    <a href="/categories/随笔/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>随笔</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-读书">

    
    
    
      
    

    

    <a href="/categories/读书/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>读书</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-管理">

    
    
    
      
    

    

    <a href="/categories/管理/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>管理</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-归档">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archives"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/05/08/技术/甲方爸爸，大概你要的是代码生成器吧？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/08/技术/甲方爸爸，大概你要的是代码生成器吧？/" class="post-title-link" itemprop="url">甲方爸爸，大概你要的是代码生成器吧？</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-05-08 19:49:00 / Modified: 19:47:04" itemprop="dateCreated datePublished" datetime="2020-05-08T19:49:00+08:00">2020-05-08</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="甲方爸爸，大概你要的是代码生成器吧？"><a href="#甲方爸爸，大概你要的是代码生成器吧？" class="headerlink" title="甲方爸爸，大概你要的是代码生成器吧？"></a>甲方爸爸，大概你要的是代码生成器吧？</h1><h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h3 id="1）"><a href="#1）" class="headerlink" title="1）"></a>1）</h3><p>有一天，我的朋友Y童鞋分享了他正在做的一个内部开源项目，这个开源项目从外表上看，跟目前市场上那些代码生成器本没有特别大的区别，所以我兴趣并不大。</p>
<p>在他给我介绍了一下具体需求之后，我才体会了他的意思，并提起了那么一丢丢兴趣。。</p>
<p>毕竟，听起来有点“鬼扯”，为啥？因为，他居然试图依靠这个项目来生成”单元测试“。。。。</p>
<p>他：定义好数据库表和结构，然后就生成逻辑方法和代码、以及界面，还同时把“单元测试”代码给生成了，免得程序员要花时间去思考代码逻辑之余，还要想怎么写出可测试代码。</p>
<p>我：这样生成的代码还有灵魂么。。</p>
<p>他：有啊，编写高可测试代码，不就是我辈中人，这些有追求的码农应该实现的目标么？</p>
<p>我：这种模式怎么越看越像埃里克埃文斯大佬说的“Smart UI”模式啊。。</p>
<p>他：你倒这么说，也有那么一点点像。</p>
<h3 id="2）"><a href="#2）" class="headerlink" title="2）"></a>2）</h3><p>我：当然，能够生成单元测试倒也可以。毕竟大部分单元测试看起来似乎是一模一样的。无外乎就是“ Arrange\Act\Assert”，AAA操作猛如虎，测试代码一把梭。</p>
<p>他：我这个东西，生成的代码，除了看起来提高了单元测试覆盖率之外，其实，并不能提高代码的质量。</p>
<p>我：是什么逼得你要花时间去开发这样的代码生成器呢？</p>
<p>他：还不是被这班菜鸡开发者们产出的劣质产品闹腾的。我不是想着省测试的钱，又能提高产品的质量么？就自然而然只能靠压榨“程序员”来实现了。但是让我来对这么多人的代码进行审查，还是太难了。这不，用单元测试来操作，不就可以了？</p>
<h3 id="3）"><a href="#3）" class="headerlink" title="3）"></a>3）</h3><p>我： 你们太难了。为啥这么赶啊？</p>
<p>他：这不是甲方爸爸要加需求，他说得倒是好：加需求也就几行代码，多简单。但是我们这边，就得忙翻天，太特么累了。</p>
<p>我：那能不能多招几个测试？</p>
<p>他：端到端测试，只是看起来将缺陷扼杀在摇篮而已，实际上。。隐藏在冰山下的缺陷呢。。客户就是小白鼠啊。再说，我们现在家业太小，测试有两个了，再招就请不起了。。功能是不能少的，bug是不能多的，我只能想想单元测试这种办法了。</p>
<p>我：好吧。。我们也一样。。</p>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><h3 id="1）-1"><a href="#1）-1" class="headerlink" title="1）"></a>1）</h3><p> 之前有个朋友老张介绍了一个故事，仿佛跟这个有点类似。他有幸参与了一个交通信息化的项目，这个项目的业主是国企单位，属于“体制内”的企业。</p>
<p>在过去一波有一波的信息化发展过程中，这些体制内的企业仿佛成为了许多IT企业竞相薅羊毛的对象。为啥，国企项目多、钱也不少，关键是国企对软件质量要求不高啊。</p>
<p> 许多企业借助国企项目，他们依托所谓“快速上线”的神器，将中华民族艰苦奋斗的精神发挥到了极致，公司能够在最短的时间内，将原本停留在脑海里的软件，快速的转化成为实现，并部署到甲方爸爸的现场环境中。</p>
<p>至于软件的质量、软件的工程化水平，对不起，不重要？用户体验？性能？功能可用性？重要么，不重要。先快速上线回款再说。于是，这些企业获得了业绩的腾飞，老板们赚得盆满簸赢，好不自在。</p>
<p>而且老板们还会吹：我们公司最大的优点，就是在逆境下生存的能力，能够在最短的时间消化需求，做出最符合客户需求的软件。</p>
<p>好吧，仿佛这也是软件工程的一种方向？快速开发。。。。</p>
<h3 id="2）-1"><a href="#2）-1" class="headerlink" title="2）"></a>2）</h3><p>然后，有那么几年，市场突然间就“做烂“了。一方面，国家将投资方向重点放在了房地产领域，对信息化的投入也逐渐收紧了许多；另外一方面，企业过去匆忙上线了太多的软件系统，不同软件系统之间的对接沟通困难，操作过程缺乏连贯性，使得基层员工开始抗拒这些”看似“能够带来效率提升，却容易出现各种质量问题导致自己过去几天工作量返工的所谓”信息化“系统；另外，大家也都很清楚，效率提升其实带来的是”裁员“，首先被裁的…</p>
<p>总之，有那么一段时间，国企对信息化是“弃若敝屣”的。</p>
<h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><h3 id="1）-2"><a href="#1）-2" class="headerlink" title="1）"></a>1）</h3><p>但，随着“互联网”和“共享出行”的兴起，又让这个概念重新热炒了起来。</p>
<p>老张他们公司也有幸接到了一个这样的项目，公司还是一家非常大的出租车公司，拥有二十多家子公司，员工超过2万人。这个项目的目的是打通出租车和旅客的关系，借助于手机实现快速出行，同时打通企业内部信息孤岛，让总公司领导能够第一时间看到各种数据的流转情况，为建立科学决策提供依据。</p>
<p>老张被选为这个项目的负责人。在项目启动会上，他意气风发，向业主和公司老板们保证，将带领公司团队与甲方团队一起，以饱满的姿态打响这场战役，为业主的业绩腾飞贡献自己的一份力量。</p>
<p>然而，但项目启动后，他才深刻的明白这究竟是一个怎样的坑。</p>
<h3 id="2）-2"><a href="#2）-2" class="headerlink" title="2）"></a>2）</h3><p>首先是业主关系，由于业主是一家涉及大几万员工和二十几家子公司的大型集团公司，需要梳理的业务表单非常复杂，业务流程和体系，远比甲方爸爸预想的要复杂得多。</p>
<p>其次是开发周期短，不知从何时起，国企对于软件系统的印象就是“简单、容易、很快就能实现”，仿佛一个需求只要说出来，这般不要命的程序员们就能很快的实现功能。当老张跟他们提到需求太多，根本做不完时，甲方爸爸甚至说：怎么可能有做不出来的软件系统，是不是你能力不行？</p>
<p>再次是外部系统多，由于不同的子公司往往采购了不同的系统，要统一对接到一个系统 。</p>
<p>还有就是涉及的技术点多，需要在许多领域进行专门的技术攻关，由于公司暂时缺乏相关资源，使得开发过程屡屡收到阻塞。</p>
<h3 id="2）-3"><a href="#2）-3" class="headerlink" title="2）"></a>2）</h3><p>经过长达几个月的需求调研，老张编写了一份超过一千页纸的需求规格说明书，并获得了业主的批准，但项目正式开始时，他却只获得了短短半年的开发周期。此时，他手上能够调动的开发者资源，才不过10余人。</p>
<p>为了干完这个项目，他和项目团队的成员不得不牺牲周末和假期，辛苦坚持了半年，才把项目功能都开发完，但在项目实施环节时，由于子公司与总公司的意见不统一，根本用不起来。</p>
<p>最终，项目崩盘，公司倒闭，甲方将近一年的投入近乎白费。老张和项目团队也白白辛苦了大半年，还得去劳动仲裁，找老板讨薪。</p>
<p>回顾这段时光时，老张说了一段话：</p>
<p>“企业信息服务化的项目，看起来合同工价很高，其实都是坑啊。有的业主，根本不懂什么叫“合适的软件”。</p>
<p>在互联网如此发展的今天，这些业主，要的还是“快速开发”。但凡想到什么就往里面加，程序员不猝死太难了。许多需求今天提，明天就要，但是用了一次呢这些功能就不用了，我根本不知道这些软件，干出来有什么意义。</p>
<p>千万别跟业主提敏捷，他们会在你的每个迭代中塞根本干不完的工作量；也不要提拥抱变化，他们变起脸来，自己都怕。”</p>
<h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>仔细想想，许多传统企业领导想转型到互联网，不就是这样么，恨不能一天就把项目干完，干完项目就“升官发财”，至于项目能不能用，谁知道呢。。</p>
<p>也许，他们要的并不是软件，而是一种“代码生成器”。嗯，输入“甲方爸爸的一万种需求”，输出“一个功能齐全、包容万物、自由变化的软件”。。</p>
<p>作为有追求的码农们，我们能像Robert大叔在《代码整洁之道-程序员的自我修养》一书中写的方法：选择“拒绝”么。</p>
<p>额。。生存要紧。。偶尔吐吐槽，饭还是得恰啊。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/05/03/技术/提升WebAPI性能的几个小建议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/03/技术/提升WebAPI性能的几个小建议/" class="post-title-link" itemprop="url">提升WebAPI性能的几个小建议</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-05-03 19:07:00" itemprop="dateCreated datePublished" datetime="2020-05-03T19:07:00+08:00">2020-05-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-06-25 22:03:27" itemprop="dateModified" datetime="2020-06-25T22:03:27+08:00">2020-06-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="typora-root-url-image-techq-xyz-images-improve-webapi"><a href="#typora-root-url-image-techq-xyz-images-improve-webapi" class="headerlink" title="typora-root-url: ........\image.techq.xyz\images\improve-webapi"></a>typora-root-url: ........\image.techq.xyz\images\improve-webapi</h2><h1 id="提升WebAPI性能的几个小建议"><a href="#提升WebAPI性能的几个小建议" class="headerlink" title="提升WebAPI性能的几个小建议"></a>提升WebAPI性能的几个小建议</h1><p>本文作者：德本德拉·达什（Debendra Dash）</p>
<p>原文来自： <a href="https://www.c-sharpcorner.com/article/Tips-And-Tricks-To-Improve-WEB-API-Performance/" target="_blank" rel="noopener">https://www.c-sharpcorner.com/article/Tips-And-Tricks-To-Improve-WEB-API-Performance/</a> </p>
<p>Web API是Microsoft作为.NET框架的一部分而开发的一项技术，它使用户能够与异构平台进行通信，包括网站，移动设备和桌面应用程序等。在编写Web API时，我们应该关注其性能和响应时间。在这里，我列出了在提高Web API性能时需要考虑的几点。</p>
<p> <img src="/1.png" alt="1"></p>
<h2 id="在Web-API中使用并行编程"><a href="#在Web-API中使用并行编程" class="headerlink" title="在Web API中使用并行编程"></a>在Web API中使用并行编程</h2><p>Web API逻辑主要处理2个重要功能-将数据发布到服务器以进行插入或更新，以及从服务器获取数据。当我们有成千上万的记录要从服务器获取时，响应时间非常高。这是因为有时我们将不得不遍历数据源，进行几次更改，然后将数据发送到客户端。而且，一个简单的foreach循环是一个单线程循环，该循环逐个顺序处理数据以给出结果集。</p>
<p> 因此，在这种情况下，建议在从服务器获取数据时使用并行foreach循环。由于并行的foreach循环在多线程环境中工作，因此执行速度将比foreach循环更快。 </p>
<h3 id="并行Foreach循环的执行过程"><a href="#并行Foreach循环的执行过程" class="headerlink" title="并行Foreach循环的执行过程"></a>并行Foreach循环的执行过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">```c#</span><br><span class="line">List&lt;Employee&gt; li = new List&lt;Employee&gt;();  </span><br><span class="line">li.Add(new Employee &#123; Id = 1001, Name = &quot;Sambid&quot;, Company = &quot;DELL&quot;, Location = &quot;Bangalore&quot; &#125;);  </span><br><span class="line">li.Add(new Employee &#123; Id = 1002, Name = &quot;Sumit&quot;, Company = &quot;DELL&quot;, Location = &quot;Bangalore&quot; &#125;);  </span><br><span class="line">li.Add(new Employee &#123; Id = 1003, Name = &quot;Koushal&quot;, Company = &quot;Infosys&quot;, Location = &quot;New Delhi&quot; &#125;);  </span><br><span class="line">li.Add(new Employee &#123; Id = 1004, Name = &quot;Kumar&quot;, Company = &quot;TCS&quot;, Location = &quot;Bangalore&quot; &#125;);  </span><br><span class="line">li.Add(new Employee &#123; Id = 1005, Name = &quot;Mohan&quot;, Company = &quot;Microsoft&quot;, Location = &quot;Hyderabad&quot; &#125;);  </span><br><span class="line">li.Add(new Employee &#123; Id = 1006, Name = &quot;Tushar&quot;, Company = &quot;Samsung&quot;, Location = &quot;Hyderabad&quot; &#125;);  </span><br><span class="line">li.Add(new Employee &#123; Id = 1007, Name = &quot;Jia&quot;, Company = &quot;TCS&quot;, Location = &quot;Pune&quot; &#125;);  </span><br><span class="line">li.Add(new Employee &#123; Id = 1008, Name = &quot;KIRAN&quot;, Company = &quot;CTS&quot;, Location = &quot;Bangalore&quot; &#125;);  </span><br><span class="line">li.Add(new Employee &#123; Id = 1009, Name = &quot;Rinku&quot;, Company = &quot;CGI&quot;, Location = &quot;Bangalore&quot; &#125;);  </span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p> 这是Employee类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Employee  </span><br><span class="line">&#123;  </span><br><span class="line">    public int Id &#123; get; set; &#125;  </span><br><span class="line">    public string Name &#123; get; set; &#125;  </span><br><span class="line">    public string Company &#123; get; set; &#125;  </span><br><span class="line">    public string Designation &#123; get; set; &#125;  </span><br><span class="line">    public string Location &#123; get; set; &#125;  </span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这就是我们可以使用Parallel Foreach循环的方式。 </p>
<p><img src="/parallel.png" alt></p>
<p>该循环将立即执行并给出结果。在Foreach循环的情况下，它一一给出结果。假设结果集中有1000条记录，则循环将执行一次1000次以得到结果。</p>
<p><strong>注意：</strong> 当您要获取的记录数量很少时，请不要使用Parallel foreach循环。</p>
<h2 id="使用异步编程来处理并发的HTTP请求"><a href="#使用异步编程来处理并发的HTTP请求" class="headerlink" title="使用异步编程来处理并发的HTTP请求"></a>使用异步编程来处理并发的HTTP请求</h2><p>同步编程中发生的事情是，每当有请求执行Web API时，就会将线程池中的线程分配给要执行的请求。该线程被阻塞，直到执行该过程并返回结果为止。</p>
<p><img src="/as1.png" alt></p>
<p>在这里，T2 线程一直处于阻塞状态，直到它处理请求并返回结果为止；如果遇到长的执行循环，则它将花费大量时间并一直等待到结束。</p>
<p>假设我们只有3个线程，并且所有线程都已分配给队列中正在等待的三个请求。在这种情况下，如果第四个请求在我们同步实现时出现，它将发出错误，因为现在它没有任何线程可以处理该请求。</p>
<p>因此，要处理更多数量的并发HTTP请求，我们必须使用异步编程。</p>
<p>异步请求处理程序的操作有所不同。当请求到达Web API控制器时，它将获取其线程池线程之一，并将其分配给该请求。</p>
<p>在进程开始执行的同时，线程将返回到线程池。执行完成后，为该请求分配了另一个线程来带来该请求，因此，该线程将不会等到进程执行完成后才返回到线程池以处理另一个请求。</p>
<p><img src="/final.png" alt></p>
<p> 因此，在这里我给出了一个小的注册示例，以及如何在Web API中使用异步编程。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[AllowAnonymous]  </span><br><span class="line">[Route(&quot;Register&quot;)]  </span><br><span class="line">public async Task&lt;IHttpActionResult&gt; Register(RegisterBindingModel model)  </span><br><span class="line">&#123;  </span><br><span class="line">    Dictionary&lt;object, object&gt; dict = new Dictionary&lt;object, object&gt;();  </span><br><span class="line">    if (!ModelState.IsValid)  </span><br><span class="line">    &#123;  </span><br><span class="line">        return BadRequest(ModelState);  </span><br><span class="line">    &#125;  </span><br><span class="line">    var user = new ApplicationUser() &#123; UserName = model.Email, Email = model.Email &#125;;  </span><br><span class="line">    IdentityResult result = await UserManager.CreateAsync(user, model.Password);  </span><br><span class="line">    if (result.Succeeded)  </span><br><span class="line">    &#123;  </span><br><span class="line">        tbl_Users obj = new tbl_Users();  </span><br><span class="line">        obj.Active = false;  </span><br><span class="line">        obj.FirstName = model.FirstName;  </span><br><span class="line">        obj.LastName = model.LastName;  </span><br><span class="line">        obj.Email = model.Email;  </span><br><span class="line">        obj.UserId = user.Id;  </span><br><span class="line">        DefEntity.tbl_Users.Add(obj);  </span><br><span class="line">        if (DefEntity.SaveChanges() == 1)  </span><br><span class="line">        &#123;  </span><br><span class="line">            dict.Add(&quot;Success&quot;, &quot;Data Saved Successfully.&quot;);  </span><br><span class="line">            return Ok(dict);  </span><br><span class="line">        &#125;  </span><br><span class="line">        else  </span><br><span class="line">        &#123;  </span><br><span class="line">            return Content(HttpStatusCode.BadRequest, &quot;User Details not Saved.&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    else  </span><br><span class="line">    &#123;  </span><br><span class="line">        return GetErrorResult(result);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="压缩Web-API的结果"><a href="#压缩Web-API的结果" class="headerlink" title="压缩Web API的结果"></a>压缩Web API的结果</h2><p>Web API压缩对于提高ASP.NET Web API性能非常重要。在Web中，数据以包（数据包）的形式通过网络传输，从而增加了数据包的大小，这将增加大小并增加Web API的响应时间。因此，减小数据包大小可提高Web API的加载性能。</p>
<p>通过压缩API响应，我们具有以下两个优点。</p>
<ul>
<li><p>数据大小将减小</p>
</li>
<li><p>响应时间将增加（增加客户端和服务器之间的通信速度。）</p>
<p>我们可以通过编码和IIS中的某些设置来压缩Web API。我已经在以下链接中介绍了使用编码对Web API进行压缩的方法。</p>
</li>
</ul>
<ol>
<li><ul>
<li><a href="http://www.c-sharpcorner.com/article/compressing-web-api-response-to-using-dotnetzip/" target="_blank" rel="noopener">使用DotNetZip压缩Web API响应</a></li>
<li><a href="http://www.c-sharpcorner.com/article/compressing-web-api-response-part-two/" target="_blank" rel="noopener">压缩Web API响应</a></li>
</ul>
</li>
</ol>
<ul>
<li><p>同样，我们可以通过检查动态内容压缩模块来启用IIS压缩 。</p>
<p><img src="/iis1.png" alt></p>
</li>
<li><p>因此，通过这种方式，我们可以压缩Web API响应以实现性能。</p>
</li>
</ul>
<h2 id="使用缓存提高性能"><a href="#使用缓存提高性能" class="headerlink" title="使用缓存提高性能"></a>使用缓存提高性能</h2><p>缓存是一种在一定时间段内将常用数据或信息存储在本地存储器中的技术。因此，下一次，当客户端请求相同的信息时，它将从本地内存中提供信息，而不是从数据库中检索信息。缓存的主要优点是它通过减少处理负担来提高性能。我们有几种方法可以在Web api中实现缓存。在下面的链接中，我描述了一种实现缓存的方法。</p>
<ul>
<li><p><a href="http://www.c-sharpcorner.com/article/implementing-caching-in-web-api/" target="_blank" rel="noopener">在Web API中实现缓存</a></p>
<p>因此，在这里您将找到我们如何在Web API中实现缓存以及它将如何帮助提高性能。</p>
</li>
</ul>
<h2 id="使用高速JSON序列化器"><a href="#使用高速JSON序列化器" class="headerlink" title="使用高速JSON序列化器"></a>使用高速JSON序列化器</h2><p>我们经常使用JSON而不是XML来在服务提供者和服务客户端之间交换数据。首先，我们使用它是因为JSON是轻量级的。</p>
<p>在.NET中，有很多序列化器。最受欢迎的是Json.NET，Microsoft选择它作为Web API的默认JSON序列化器。Json.NET之所以出色，是因为它快速，健壮且可配置。</p>
<p>有几种序列化器比Json.Net更快。下面提到其中一些。</p>
<p><img src="/ser.png" alt></p>
<p>我们可以看到Protobuf-Net和JIL是非常快速的序列化程序，因此，如果可以代替Json.net来实现它们，则显然可以提高性能。协议缓冲区或Protobuf是Google的官方序列化程序。要在.Net中使用JIL序列化程序，我已经写了一篇文章，您可以在下面的链接中进行检查。</p>
<ul>
<li><a href="http://www.c-sharpcorner.com/article/working-with-jil-serializer-and-deserializer-library-in-c-sharp/" target="_blank" rel="noopener">在C＃中使用Jil序列化器和反序列化器库</a></li>
</ul>
<h2 id="创建适当的数据库结构"><a href="#创建适当的数据库结构" class="headerlink" title="创建适当的数据库结构"></a>创建适当的数据库结构</h2><p>为了提高任何应用程序的性能，我们应该将重点放在数据库结构上。我可以说数据库结构在提高性能方面起着重要作用。这些是我们在处理数据库时应检查的一些注意事项。</p>
<ul>
<li><p>尝试使规范化表结构。</p>
</li>
<li><p>为所有表提供适当的索引，以便从表中轻松搜索结果。</p>
</li>
<li><p>将所有相互关联的表与外键和主键相关联。</p>
<p>我认为在创建数据库结构以提高性能时，我们必须至少遵循这三个规则。</p>
</li>
</ul>
<p><strong>尝试从客户端验证某些属性</strong></p>
<p>从客户端而不是服务器端验证某些模型属性非常好。一旦我们在未经客户端验证的情况下放置了无效数据，则它将进入服务器并检查其是否为有效数据。如果它是无效的数据，它将从服务器给出错误。因此，在这里我们可以使用客户端验证检查往返行程。因此，如果我们可以通过客户端（移动设备，网站等）进行任何可能的验证，那将是很好的。</p>
<p><img src="/valida.jpg" alt></p>
<p> 因此，我认为，如果我们专注于以上讨论的要点，则可以以某种方式提高Web API的性能。 </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/04/30/技术/TDD学习笔记（二）单元测试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/04/30/技术/TDD学习笔记（二）单元测试/" class="post-title-link" itemprop="url">.TDD学习笔记（二）单元测试</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-04-30 19:07:00" itemprop="dateCreated datePublished" datetime="2020-04-30T19:07:00+08:00">2020-04-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-26 19:08:09" itemprop="dateModified" datetime="2020-05-26T19:08:09+08:00">2020-05-26</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单元测试最早来源于Kent Beck，他在开发SmallTalk中引入了这个概念，随着软件工程学的不断发展，使得单元测试已经成为软件编程中一项非常有用的实践。</p>
<p>在维基百科中，“单元测试”是这样定义的：</p>
<blockquote>
<p>一个单元测试是一段代码（通常是一个方法），这段代码调用另一段代码，然后检验某些假设的正确性。如果这些假设是错误的，单元测试就失败了。一个单元可以是一个方法或一个函数。</p>
</blockquote>
<p>  而《单元测试的艺术》作者Roy Osherove则认为，一个单元不仅仅是一个方法，也有可能是包括实现某个功能的多个类和函数。</p>
<h2 id="什么是好的单元测试"><a href="#什么是好的单元测试" class="headerlink" title="什么是好的单元测试"></a>什么是好的单元测试</h2><p>Roy Osherove同时也认为，一个单元测试应该具备以下特征：</p>
<ol>
<li>它应该是自动化的，可重复执行。</li>
<li>它应该很容易实现；</li>
<li>它应该第二天还有意义；</li>
<li>任何人都应该能一键运行它；</li>
<li>它应该运行很快；</li>
<li>它的结果应该是稳定的（如果运行之间没有进行修改的话，多次运行一个测试应该总是能够返回同样的结果）</li>
<li>它应该能完全控制被测试的单元；</li>
<li>它应该是完全隔离的（独立于其他测试的运行）；</li>
<li>如果它失败了，我们应该很容易发现什么是期待的结果，进而定位问题所在。<h1 id="几种概念"><a href="#几种概念" class="headerlink" title="几种概念"></a>几种概念</h1>在<a href="https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da" target="_blank" rel="noopener">这篇博客</a>中，作者对Fake、Mock、Stub进行了对比。</li>
</ol>
<h2 id="Fakes（伪造）"><a href="#Fakes（伪造）" class="headerlink" title="Fakes（伪造）"></a>Fakes（伪造）</h2><p><img src="https://uploader.shimo.im/f/9bhjo93eYX4y1Mbt.png!thumbnail" alt="图片"></p>
<p>Fake创建的对象，看似跟原对象一致，但是简化了原来对象的某些行为，使得我们在进行代码过程中，无需通过启动数据库或其他外部组件，即可对服务进行集成测试。</p>
<h2 id="Mock（模拟）"><a href="#Mock（模拟）" class="headerlink" title="Mock（模拟）"></a>Mock（模拟）</h2><p><img src="https://uploader.shimo.im/f/OLf5e8HV6yUrw7uC.png!thumbnail" alt="图片"></p>
<p>mock是在调用方法中，注入“模拟”的完整的被调用者对象，并在Test方法中，通过注入的这个模拟对象来执行对应的操作。</p>
<h2 id="Stub（打桩）"><a href="#Stub（打桩）" class="headerlink" title="Stub（打桩）"></a>Stub（打桩）</h2><p><img src="https://uploader.shimo.im/f/X7xnMFmBKoQQXb7C.png!thumbnail" alt="图片"></p>
<p>存根是预先定义一个方法的返回值，以便我们在调用该方法时，返回存根对象，这样使我们的代码不会以不改变原方法、或对原方法产生副作用的情况下，实现某方法。</p>
<h2 id="横切关注点"><a href="#横切关注点" class="headerlink" title="横切关注点"></a>横切关注点</h2><blockquote>
<p>部分关注点「横切」程序代码中的数个模块，即在多个模块中都有出现，它们即被称作「横切关注点（Cross-cutting concerns, Horizontal concerns）」。</p>
</blockquote>
<p>横切关注点也是面向对象编程中的概念，我们通俗意义上理解的AOP框架，可以理解为解决横切关注点问题的一种框架。</p>
<p>日志、异常处理、服务调用、方法调用链路都是大家会遇到的一类关注点问题，而而在《单元测试的艺术》这本书中，作者也指出“时间”（DateTime）也同样是一种问题。例如，如果我们在代码中普遍使用了系统默认的DateTime.Now，那么假设我们要测试代码在元旦和非元旦日期中的不同行为时，是不是手动把系统时间修改为指定的时间？这显然是的代码不利于维护，也不利于代码的可测试性。</p>
<p>通过定义了一个SystemTime 对象来解决这个问题，确实是一种非常不错的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> [TestFixture]</span><br><span class="line">    public class TimeLoggerTests</span><br><span class="line">    &#123;</span><br><span class="line">        [Test]</span><br><span class="line">        public void SettingingSystemTime_Always_ChangesTime()</span><br><span class="line">        &#123;</span><br><span class="line">            SystemTime.Set(new DateTime(2000, 1, 1));</span><br><span class="line">            string output = TimeLogger.CreateMessage(&quot;a&quot;);</span><br><span class="line">            StringAssert.Contains(&quot;01.01.2000&quot;, output);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> public class SystemTime</span><br><span class="line">    &#123;</span><br><span class="line">        private static DateTime _dateTime;</span><br><span class="line">        public static void Set(DateTime custom)</span><br><span class="line">        &#123;</span><br><span class="line">            _dateTime = custom;</span><br><span class="line">        &#125;</span><br><span class="line">        public static void Reset()</span><br><span class="line">        &#123;</span><br><span class="line">            _dateTime = DateTime.MinValue;</span><br><span class="line">        &#125;</span><br><span class="line">        public static DateTime Now</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                if (_dateTime != DateTime.MinValue)</span><br><span class="line">                &#123;</span><br><span class="line">                    return _dateTime;</span><br><span class="line">                &#125;</span><br><span class="line">                return DateTime.Now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h1><p>测试框架是用来辅助开发者进行单元测试的代码库。在.NET开发环境下，我们常见的的测试框架可以分成以下两种类型：</p>
<h2 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h2><p>单元测试框架框架是帮助开发者进行单元测试的代码库和模块，它也可以作为自动编译过程的一个步骤运行测试。单元测试的框架<a href="https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks" target="_blank" rel="noopener">如此之多</a>，而在.NET中，常见的主要包括这几种：</p>
<p>1、MSTest:这是Visual Studio中最常见的测试框架，在除Visual Studio2019以前的版本中，创建的单元测试项目自带的就是这种测试框架。</p>
<p>2、XUnit:XUnit是一个大家族，在Java、.NET、等多种技术语言下都有XUnit的身影。</p>
<p>3、NUnit:在许多介绍单元测试的书籍中，都会采用NUnit作为示例，在本文中，也主要介绍这种框架。</p>
<h2 id="隔离（模拟）框架"><a href="#隔离（模拟）框架" class="headerlink" title="隔离（模拟）框架"></a>隔离（模拟）框架</h2><p>隔离（模拟）是一种可编程的API，使用这种API可以使得创建为对象比手工编写简便、快速和容易。常见的隔离（模拟）框架包括以下几种：</p>
<p>1、Moq：在.NET中常见的Mock框架。</p>
<p>2、NSubstitute：在《单元测试的艺术》一书中，作者Roy Osherove着重介绍过这种测试隔离框架，也经常和Moq框架一起进行<a href="https://itenium.be/blog/dotnet/nsubstitute-vs-moq/" target="_blank" rel="noopener">比较</a>。</p>
<p>3、Microsoft Fakes:也是一种模拟框架，经常被用于和上述模拟框架<a href="https://saucelabs.com/blog/mock-frameworks-vs-microsoft-fakes" target="_blank" rel="noopener">对比</a>。</p>
<p>4、FakeItEasy、EasyMoq、JustMock框架：其他模拟框架。 </p>
<h1 id="编写良好测试代码中常见的问题"><a href="#编写良好测试代码中常见的问题" class="headerlink" title="编写良好测试代码中常见的问题"></a>编写良好测试代码中常见的问题</h1><h2 id="如何给测试方法命名"><a href="#如何给测试方法命名" class="headerlink" title="如何给测试方法命名"></a>如何给测试方法命名</h2><p>方法的命名一直是困扰开发者的难题，尤其是单元测试方法。我们该如何给单元测试方法命名呢？目前我了解到两种不同的命名方法：</p>
<p>假设，现有一个新增方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public int Add(int x,int y)</span><br></pre></td></tr></table></figure>

<p>一种是Should开头的单元测试命名方法，可以命名为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Should_Returns_Sum_When_Add_Numbers();</span><br></pre></td></tr></table></figure>

<p>另外一种是在《单元测试的艺术》这本书中作者用到的命名方法，作者将单元测试命名为三个部分，分别为：被测试方法名，测试场景，预期行为，将三个部分用下划线“_”分开，例如MethodUnderTest_Scenario_Behavior()。按照这个命名方法，上述方法可以被命名为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add_Nums_Returns_ResultsOfInteger();</span><br></pre></td></tr></table></figure>

<h2 id="静态类或单例如何进行单元测试"><a href="#静态类或单例如何进行单元测试" class="headerlink" title="静态类或单例如何进行单元测试"></a>静态类或单例如何进行单元测试</h2><h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><p>在.NET Framework中经常互相静态类和静态对象，这无形中给我们的单元测试过程带来了不少困扰。我们可以采取以下方式对这些静态类进行测试。</p>
<p>1、静态类应该只限于静态的方法，例如像StringExtension这样的扩展方法，这种方式是可以直接进行测试的。</p>
<p>2、对于历史代码中为包含不少静态成员的“静态”对象，应该将其改成有IoC框架注入的单例对象，这样就能使用mock的方式进行单元测试。</p>
<p>3、对于无法修改的静态对象，我们可以考虑将其隔离。</p>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>而对于单例代码，则可以采用将单例逻辑和单例持有者分开的方式，让代码更易于测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MySingleton</span><br><span class="line">&#123;</span><br><span class="line">       private static MySingleton _instance;</span><br><span class="line">       public static MySingleton Instance</span><br><span class="line">       &#123;</span><br><span class="line">           get</span><br><span class="line">           &#123;</span><br><span class="line">               if (_instance == null)</span><br><span class="line">               &#123;</span><br><span class="line">                   _instance = new MySingleton();</span><br><span class="line">               &#125;</span><br><span class="line">               return _instance;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public void Foo()</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> public class MySingletonLogic</span><br><span class="line">    &#123; </span><br><span class="line">        public void Foo()</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class MySingletonHolder</span><br><span class="line">    &#123;</span><br><span class="line">        private static MySingletonLogic _instance;</span><br><span class="line">        public static MySingletonLogic Instance</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                if (_instance == null)</span><br><span class="line">                &#123;</span><br><span class="line">                    _instance = new MySingletonLogic();</span><br><span class="line">                &#125;</span><br><span class="line">                return _instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式的改造，使得我们能够非常方便的对Foo方法进行测试了。</p>
<h3 id="何时开始进行单元测试？"><a href="#何时开始进行单元测试？" class="headerlink" title="何时开始进行单元测试？"></a>何时开始进行单元测试？</h3><p>最好的时机就是当下，当你需要键入一行逻辑代码时，先写一个测试方法，按照TDD的流程进行开发，将有利于你的代码开发过程处于“自信满满”的状态，而且还能减少代码调试的时间，进而提高代码开发的效率。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/04/30/技术/什么是TDD（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/04/30/技术/什么是TDD（一）/" class="post-title-link" itemprop="url">.TDD学习笔记（一）单元测试</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-04-30 19:07:00" itemprop="dateCreated datePublished" datetime="2020-04-30T19:07:00+08:00">2020-04-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-26 19:08:52" itemprop="dateModified" datetime="2020-05-26T19:08:52+08:00">2020-05-26</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>虽然我很早以前就听说单元测试，也曾经多次在项目中引入单元测试框架和单元测试的实践为代码质量的提升带来了一丝助力。</p>
<p>但这种方式更多的是从软件调试的角度出发，即将单元测试作为一种测试方法可用性的入口，而非从TDD、极限编程、或从”Fail Fast,Fix Fast”这种获得快速反馈的方式来使用单元测试，使得实际过程中单元测试的效果并不明显。</p>
<p>直到去年8月下旬开始参加极客学院的<a href="https://www.jiker.com/plus/2?_comefrom=jikexueyuan&_code_slot=6&_creative=190" target="_blank" rel="noopener">TDD实战课</a>才进一步深入了解基于TDD的单元测试的流程、方法和实践的全过程，当时也间歇性的练习了一点Args等Kata项目，才逐步体会到TDD的妙处。</p>
<p>虽然到目前为止对于TDD的了解依然很浅，但在开发过程中，总是有意无意的“站在调用者的角度思考业务逻辑”，并尽可能的思考如何“编写可测试的代码”，总归是一种进步。</p>
<h2 id="我的教训"><a href="#我的教训" class="headerlink" title="我的教训"></a>我的教训</h2><p>总结自己学习TDD的一些经验教训：</p>
<ol>
<li>需求的识别，总是按惯性一次性把整个需求全部提取了。</li>
<li>总是习惯于拿着代码一把梭，没有按照“Arange,Assert,Art”的步骤来规划任务。</li>
<li>步子迈得太大，方法拆得不够细，过程式代码的味道很浓，例如，在练习String Calculate过程中，就有非常明显的问题。当然，这也是许多初学TDD开发者的通病。</li>
</ol>
<p><img src="https://uploader.shimo.im/f/idWlhCM560UviNjE.png!thumbnail" alt="图片"></p>
<p><img src="https://uploader.shimo.im/f/k1eYNKHvgyQAHJL8.png!thumbnail" alt="图片"></p>
<ol start="4">
<li>没有深刻理解“重构”的意义，只是把通过单元测试当做一个目的。</li>
<li>Kata的练习频率依然不高，一周只有两到三次，每次不到一个小时。 </li>
<li>单元测试和方法的命名不太规范，无法让人产生直接的理解。</li>
<li>方法的代码行较多，不符合优质代码的标准。</li>
<li>方法间适当的空行（分段）很重要。<h1 id="什么是TDD"><a href="#什么是TDD" class="headerlink" title="什么是TDD"></a>什么是TDD</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2>TDD的全称是“测试驱动开发”，也是一种旨在提升代码质量的开发实践。这种开发实践的主要步骤是在编写产品代码之前，先编写单元测试代码，然后再由测试代码来决定写什么产品代码，其目的是取得快速反馈，并使用“illustrate the main line”方法来构建程序。</li>
</ol>
<p>测试驱动开发是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。</p>
<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>在上述经验教训过程中，有些步骤其实与TDD的三原则相违背，让我们来回顾一下这三个原则：</p>
<ul>
<li><p>不允许编写任何产品代码，除非允许失败的测试通过。</p>
</li>
<li><p>不允许编写多余一个的失败测试，编译成功也是失败。</p>
</li>
<li><p>不允许编写多于恰好让测试通过的产品代码。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>TDD其实也有一系列完整的操作流程，包括如下五个步骤：</p>
</li>
<li><p>添加一个小的测试</p>
</li>
<li><p>运行所有测试并且失败</p>
</li>
<li><p>做一点修改</p>
</li>
<li><p>运行所有测试并且成功</p>
</li>
<li><p>重构以消除重复</p>
</li>
</ul>
<p><img src="https://uploader.shimo.im/f/dRjAx1w2z20tzyt1.png!thumbnail" alt="图片"></p>
<p><a href="https://xp123.com/articles/tdd-tcr-commits/" target="_blank" rel="noopener">图1（红绿重构）</a></p>
<h2 id="可行性之争"><a href="#可行性之争" class="headerlink" title="可行性之争"></a>可行性之争</h2><p>TDD也是一种充满争议的开发实践，许多人都吐槽，这种方式在原本开发代码之余，还得额外花三分之一的时间来编写测试代码。不过，我还是推荐《<a href="https://item.jd.com/11977659.html" target="_blank" rel="noopener">代码整洁之道-程序员的自我修养</a>》这本书中，Robert Bob大叔在第5.1小节说的几句话：</p>
<blockquote>
<p>1、此事已有定论！<br>2、争论已经结束！<br>3、GOTO是有害的！<br>4、TDD确实可行。</p>
</blockquote>
<p>他明确指出：</p>
<blockquote>
<p>过去人们对TDD充满争议，就此发表了不少博客和文章，如今争议依旧来袭。所不同的是，以前人们是认真尝试着去批判和理解TDD，而现在只有夸夸奇谈而已。结论很清楚，TDD的确切实可行，而且每个开发人员都要适应和掌握TDD。</p>
</blockquote>
<h2 id="TCR"><a href="#TCR" class="headerlink" title="TCR"></a>TCR</h2><p>在《极限中国社区》曾经介绍了一种测试驱动开发过程中的实践模式，这种实践被称为“<a href="https://xp123.com/articles/tdd-tcr-commits/" target="_blank" rel="noopener">TCR</a>”。</p>
<p>在实践过程中，开发者始终保持着测试，成功则提交，失败则回滚到上次的代码这样的循环。在并使用了插件来进行自动化回滚，确保每个方法的开发时间被控制在非常小的时间粒度上。这样保证了开发者能够以非常小的步子，非常快的频率，实现代码的开发过程。</p>
<p><img src="https://uploader.shimo.im/f/BKMKzoRcX7MbRVwk.png!thumbnail" alt="图片"></p>
<p><a href="https://xp123.com/articles/tdd-tcr-commits/" target="_blank" rel="noopener">TCR</a></p>
<h1 id="Kata"><a href="#Kata" class="headerlink" title="Kata"></a>Kata</h1><p>优秀的代码从来不是天生的，而是通过后天不断的练习培养出来的，尤其是要想写出符合面向对象设计的的好代码，更是需要“刻意练习”。</p>
<p>Kata被人称为是唯一的一种<a href="http://www.peterprovost.org/blog/2012/05/02/kata-the-only-way-to-learn-tdd/" target="_blank" rel="noopener">练习TDD</a>的形式。</p>
<p>“Kata”是一种来自日语词汇“形式”的翻译，它描述了武术练习中，通过一种精心编排的动作模式，用来训练自己达到肌肉记忆的水平。</p>
<p>Kata的练习例子是<a href="http://codingdojo.org/kata/" target="_blank" rel="noopener">如此之多</a>，只要你有心，总是能在海量的示例代码中找到最适合自己的一个例子。</p>
<p>例如，我所使用的Roy Osherove设计的例子“String Calculate”就是一个非常不错的示例。（当然，我给出的是一段反例代码。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、An empty string returns zero</span><br><span class="line">2、A single number returns the value</span><br><span class="line">3、Two numbers, comma delimited, returns the sum</span><br><span class="line">4、Two numbers, newline delimited, returns the sum</span><br><span class="line">5、Three numbers, delimited either way, returns the sum</span><br><span class="line">6、Negative numbers throw an exception</span><br><span class="line">7、Numbers greater than 1000 are ignored</span><br><span class="line">8、A single char delimiter can be defined on the first line (e.g. //# for a ‘#’ as the delimiter)</span><br><span class="line">9、A multi char delimiter can be defined on the first line (e.g. //[###] for ‘###’ as the delimiter)</span><br><span class="line">10、Many single or multi-char delimiters can be defined (each wrapped in square brackets)</span><br></pre></td></tr></table></figure>

<p>当然，<a href="http://codingkata.net/Katas/Beginner/FizzBuzz" target="_blank" rel="noopener">FizzBuzz</a>或<a href="http://www.butunclebob.com/ArticleS.UncleBob.ThePrimeFactorsKata" target="_blank" rel="noopener">The Prime Factors Kata</a>，Args也是一个非常不错的示例。重要的并非例子本身，而是通过持续不断的练习，形成自己的肌肉记忆。<br>在<a href="http://www.peterprovost.org/blog/2012/05/02/kata-the-only-way-to-learn-tdd/" target="_blank" rel="noopener">引文</a>中，作者Peter Provost认为，最好的办法：</p>
<blockquote>
<p>我对人们的建议是连续两周每天早上做一个30分钟的练习。然后再选一个，每天做一次，坚持两周<br>我不建议大家在工作中练习Kata，除非他们已经准备好了。你应该通过练习一周或六次，直到你已经决定对TDD的循环非常适应为止。否则，就像参加了一场没有技术水平的比赛。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/04/30/技术/使用自定义DelegatingHandler编写更清洁的Typed HttpClient/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/04/30/技术/使用自定义DelegatingHandler编写更清洁的Typed HttpClient/" class="post-title-link" itemprop="url">使用自定义DelegatingHandler编写更整洁的Typed HttpClient</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-04-30 19:07:00" itemprop="dateCreated datePublished" datetime="2020-04-30T19:07:00+08:00">2020-04-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-06-25 22:03:08" itemprop="dateModified" datetime="2020-06-25T22:03:08+08:00">2020-06-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用自定义DelegatingHandler编写更整洁的Typed-HttpClient"><a href="#使用自定义DelegatingHandler编写更整洁的Typed-HttpClient" class="headerlink" title="使用自定义DelegatingHandler编写更整洁的Typed HttpClient"></a>使用自定义DelegatingHandler编写更整洁的Typed HttpClient</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介﻿"></a><strong>简介</strong>﻿</h2><p>我写了很多<a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0" target="_blank" rel="noopener">HttpClient</a>，包括类型化的客户端。自从我发现<a href="https://github.com/reactiveui/refit" target="_blank" rel="noopener">Refit</a>以来，我只使用了那一个，所以我只编写了很少的代码！但是我想到了你！你们中的某些人不一定会使用<a href="https://github.com/reactiveui/refit" target="_blank" rel="noopener">Refit，</a>因此，我将为您提供一些技巧，以使用<a href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/httpclient-message-handlers" target="_blank" rel="noopener">HttpClient消息处理程序</a>（尤其是<a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8" target="_blank" rel="noopener">DelegatingHandlers）</a>编写具有最大可重用性的<a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests" target="_blank" rel="noopener">类型化HttpClient</a>。</p>
<h2 id="编写类型化的HttpClient来转发JWT并记录错误"><a href="#编写类型化的HttpClient来转发JWT并记录错误" class="headerlink" title="编写类型化的HttpClient来转发JWT并记录错误"></a><strong>编写类型化的HttpClient来转发JWT并记录错误</strong></h2><p>这是要清理的<a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests" target="_blank" rel="noopener">键入的HttpClient</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">using DemoRefit.Models;</span><br><span class="line">using DemoRefit.Repositories;</span><br><span class="line">using Microsoft.AspNetCore.Authentication;</span><br><span class="line">using Microsoft.AspNetCore.Http;</span><br><span class="line">using Microsoft.Extensions.Logging;</span><br><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Net.Http;</span><br><span class="line">using System.Net.Http.Headers;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace DemoRefit.HttpClients</span><br><span class="line">&#123;</span><br><span class="line">    public class CountryRepositoryClient : ICountryRepositoryClient</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly HttpClient _client;</span><br><span class="line">        private readonly IHttpContextAccessor _httpContextAccessor;</span><br><span class="line">        private readonly ILogger&lt;CountryRepositoryClient&gt; _logger;</span><br><span class="line"></span><br><span class="line">        public CountryRepositoryClient(HttpClient client, ILogger&lt;CountryRepositoryClient&gt; logger, IHttpContextAccessor httpContextAccessor)</span><br><span class="line">        &#123;</span><br><span class="line">            _client = client;</span><br><span class="line">            _logger = logger;</span><br><span class="line">            _httpContextAccessor = httpContextAccessor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public async Task&lt;IEnumerable&lt;Country&gt;&gt; GetAsync()</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                string accessToken = await _httpContextAccessor.HttpContext.GetTokenAsync(&quot;access_token&quot;);</span><br><span class="line">                if (string.IsNullOrEmpty(accessToken))</span><br><span class="line">                &#123;</span><br><span class="line">                    throw new Exception(&quot;Access token is missing&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(&quot;bearer&quot;, accessToken);</span><br><span class="line"></span><br><span class="line">                var headers = _httpContextAccessor.HttpContext.Request.Headers;</span><br><span class="line">                if (headers.ContainsKey(&quot;X-Correlation-ID&quot;) &amp;&amp; !string.IsNullOrEmpty(headers[&quot;X-Correlation-ID&quot;]))</span><br><span class="line">                &#123;</span><br><span class="line">                    _client.DefaultRequestHeaders.Add(&quot;X-Correlation-ID&quot;, headers[&quot;X-Correlation-ID&quot;].ToString());</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                using (HttpResponseMessage response = await _client.GetAsync(&quot;/api/democrud&quot;))</span><br><span class="line">                &#123;</span><br><span class="line">                    response.EnsureSuccessStatusCode();</span><br><span class="line">                    return await response.Content.ReadAsAsync&lt;IEnumerable&lt;Country&gt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                _logger.LogError(e, &quot;Failed to run http query&quot;);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有许多事情需要清理，因为它们在您将在同一应用程序中编写的每个客户端中可能都是多余的：</p>
<ul>
<li>从<strong>HttpContext</strong>读取访问令牌</li>
<li>令牌为空时，管理访问令牌</li>
<li>将访问令牌附加到<a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0" target="_blank" rel="noopener">HttpClient</a>进行委派</li>
<li>从<strong>HttpContext</strong>读取CorrelationId</li>
<li>将CorrelationId附加到<a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0" target="_blank" rel="noopener">HttpClient</a>进行委托</li>
<li>使用<em>EnsureSuccessStatusCode（）</em>验证Http查询是否成功</li>
</ul>
<h2 id="编写自定义的DelegatingHandler来处理冗余代码"><a href="#编写自定义的DelegatingHandler来处理冗余代码" class="headerlink" title="编写自定义的DelegatingHandler来处理冗余代码"></a><strong>编写自定义的DelegatingHandler来处理冗余代码</strong></h2><p>这是<a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8" target="_blank" rel="noopener">DelegatingHandler</a>：          </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.AspNetCore.Authentication;</span><br><span class="line">using Microsoft.AspNetCore.Http;</span><br><span class="line">using Microsoft.Extensions.Logging;</span><br><span class="line">using System;</span><br><span class="line">using System.Net.Http;</span><br><span class="line">using System.Net.Http.Headers;</span><br><span class="line">using System.Threading;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace DemoRefit.Handlers</span><br><span class="line">&#123;</span><br><span class="line">    public class MyDelegatingHandler : DelegatingHandler</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly IHttpContextAccessor _httpContextAccessor;</span><br><span class="line">        private readonly ILogger&lt;MyDelegatingHandler&gt; _logger;</span><br><span class="line"></span><br><span class="line">        public MyDelegatingHandler(IHttpContextAccessor httpContextAccessor, ILogger&lt;MyDelegatingHandler&gt; logger)</span><br><span class="line">        &#123;</span><br><span class="line">            _httpContextAccessor = httpContextAccessor;</span><br><span class="line">            _logger = logger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected override async Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)</span><br><span class="line">        &#123;</span><br><span class="line">            HttpResponseMessage httpResponseMessage;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                string accessToken = await _httpContextAccessor.HttpContext.GetTokenAsync(&quot;access_token&quot;);</span><br><span class="line">                if (string.IsNullOrEmpty(accessToken))</span><br><span class="line">                &#123;</span><br><span class="line">                    throw new Exception($&quot;Access token is missing for the request &#123;request.RequestUri&#125;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                request.Headers.Authorization = new AuthenticationHeaderValue(&quot;bearer&quot;, accessToken);</span><br><span class="line"></span><br><span class="line">                var headers = _httpContextAccessor.HttpContext.Request.Headers;</span><br><span class="line">                if (headers.ContainsKey(&quot;X-Correlation-ID&quot;) &amp;&amp; !string.IsNullOrEmpty(headers[&quot;X-Correlation-ID&quot;]))</span><br><span class="line">                &#123;</span><br><span class="line">                    request.Headers.Add(&quot;X-Correlation-ID&quot;, headers[&quot;X-Correlation-ID&quot;].ToString());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                httpResponseMessage = await base.SendAsync(request, cancellationToken);</span><br><span class="line">                httpResponseMessage.EnsureSuccessStatusCode();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                _logger.LogError(ex, &quot;Failed to run http query &#123;RequestUri&#125;&quot;, request.RequestUri);</span><br><span class="line">                throw;</span><br><span class="line">            &#125;</span><br><span class="line">            return httpResponseMessage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如您所见，现在它封装了用于同一应用程序中每个<a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0" target="_blank" rel="noopener">HttpClient</a>的冗余逻辑 。</p>
<p>现在，清理后的<a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0" target="_blank" rel="noopener">HttpClient</a>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">using DemoRefit.Models;</span><br><span class="line">using DemoRefit.Repositories;</span><br><span class="line">using Microsoft.Extensions.Logging;</span><br><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Net.Http;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace DemoRefit.HttpClients</span><br><span class="line">&#123;</span><br><span class="line">    public class CountryRepositoryClientV2 : ICountryRepositoryClient</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly HttpClient _client;</span><br><span class="line">        private readonly ILogger&lt;CountryRepositoryClient&gt; _logger;</span><br><span class="line"></span><br><span class="line">        public CountryRepositoryClientV2(HttpClient client, ILogger&lt;CountryRepositoryClient&gt; logger)</span><br><span class="line">        &#123;</span><br><span class="line">            _client = client;</span><br><span class="line">            _logger = logger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public async Task&lt;IEnumerable&lt;Country&gt;&gt; GetAsync()</span><br><span class="line">        &#123;</span><br><span class="line">            using (HttpResponseMessage response = await _client.GetAsync(&quot;/api/democrud&quot;))</span><br><span class="line">            &#123;</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    return await response.Content.ReadAsAsync&lt;IEnumerable&lt;Country&gt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    _logger.LogError(e, &quot;Failed to read content&quot;);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好多了不是吗？🙂</p>
<p>最后，让我们将<a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8" target="_blank" rel="noopener">DelegatingHandler</a>附加到Startup.cs中的<a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=netcore-3.0" target="_blank" rel="noopener">HttpClient</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">using DemoRefit.Handlers;</span><br><span class="line">using DemoRefit.HttpClients;</span><br><span class="line">using DemoRefit.Repositories;</span><br><span class="line">using Microsoft.AspNetCore.Builder;</span><br><span class="line">using Microsoft.AspNetCore.Hosting;</span><br><span class="line">using Microsoft.Extensions.Configuration;</span><br><span class="line">using Microsoft.Extensions.DependencyInjection;</span><br><span class="line">using Microsoft.Extensions.Hosting;</span><br><span class="line">using Refit;</span><br><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace DemoRefit</span><br><span class="line">&#123;</span><br><span class="line">    public class Startup</span><br><span class="line">    &#123;</span><br><span class="line">        public Startup(IConfiguration configuration)</span><br><span class="line">        &#123;</span><br><span class="line">            Configuration = configuration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public IConfiguration Configuration &#123; get; &#125;</span><br><span class="line"></span><br><span class="line">        // This method gets called by the runtime. Use this method to add services to the container.</span><br><span class="line">        public void ConfigureServices(IServiceCollection services)</span><br><span class="line">        &#123;</span><br><span class="line">            services.AddHttpContextAccessor();</span><br><span class="line"></span><br><span class="line">            services.AddControllers();</span><br><span class="line"></span><br><span class="line">            services.AddHttpClient&lt;ICountryRepositoryClient, CountryRepositoryClientV2&gt;()</span><br><span class="line">                    .ConfigureHttpClient(c =&gt; c.BaseAddress = new Uri(Configuration.GetSection(&quot;Apis:CountryApi:Url&quot;).Value))</span><br><span class="line">                    .AddHttpMessageHandler&lt;MyDelegatingHandler&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span><br><span class="line">        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)</span><br><span class="line">        &#123;</span><br><span class="line">            if (env.IsDevelopment())</span><br><span class="line">            &#123;</span><br><span class="line">                app.UseDeveloperExceptionPage();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            app.UseHttpsRedirection();</span><br><span class="line"></span><br><span class="line">            app.UseRouting();</span><br><span class="line"></span><br><span class="line">            app.UseAuthorization();</span><br><span class="line"></span><br><span class="line">            app.UseEndpoints(endpoints =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                endpoints.MapControllers();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Refit"><a href="#使用Refit" class="headerlink" title="使用Refit"></a><strong>使用Refit</strong></h2><p>如果您正在使用<a href="https://github.com/reactiveui/refit" target="_blank" rel="noopener">Refit</a>，则绝对可以重用该<a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8" target="_blank" rel="noopener">DelegatingHandler</a>！</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">using DemoRefit.Handlers;</span><br><span class="line">using DemoRefit.HttpClients;</span><br><span class="line">using DemoRefit.Repositories;</span><br><span class="line">using Microsoft.AspNetCore.Builder;</span><br><span class="line">using Microsoft.AspNetCore.Hosting;</span><br><span class="line">using Microsoft.Extensions.Configuration;</span><br><span class="line">using Microsoft.Extensions.DependencyInjection;</span><br><span class="line">using Microsoft.Extensions.Hosting;</span><br><span class="line">using Refit;</span><br><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace DemoRefit</span><br><span class="line">&#123;</span><br><span class="line">    public class Startup</span><br><span class="line">    &#123;</span><br><span class="line">        public Startup(IConfiguration configuration)</span><br><span class="line">        &#123;</span><br><span class="line">            Configuration = configuration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public IConfiguration Configuration &#123; get; &#125;</span><br><span class="line"></span><br><span class="line">        // This method gets called by the runtime. Use this method to add services to the container.</span><br><span class="line">        public void ConfigureServices(IServiceCollection services)</span><br><span class="line">        &#123;</span><br><span class="line">            services.AddHttpContextAccessor();</span><br><span class="line"></span><br><span class="line">            services.AddControllers();</span><br><span class="line"></span><br><span class="line">            services.AddRefitClient&lt;ICountryRepositoryClient&gt;()</span><br><span class="line">                    .ConfigureHttpClient(c =&gt; c.BaseAddress = new Uri(Configuration.GetSection(&quot;Apis:CountryApi:Url&quot;).Value));</span><br><span class="line">                    .AddHttpMessageHandler&lt;MyDelegatingHandler&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span><br><span class="line">        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)</span><br><span class="line">        &#123;</span><br><span class="line">            if (env.IsDevelopment())</span><br><span class="line">            &#123;</span><br><span class="line">                app.UseDeveloperExceptionPage();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            app.UseHttpsRedirection();</span><br><span class="line"></span><br><span class="line">            app.UseRouting();</span><br><span class="line"></span><br><span class="line">            app.UseAuthorization();</span><br><span class="line"></span><br><span class="line">            app.UseEndpoints(endpoints =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                endpoints.MapControllers();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="轮子介绍："><a href="#轮子介绍：" class="headerlink" title="轮子介绍："></a>轮子介绍：</h5><p>Refit是一个深受Square的 Retrofit 库启发的库,目前在github上共有star 4000枚，通过这个框架，可以把你的REST API变成了一个活的接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IGitHubApi</span><br><span class="line">&#123;</span><br><span class="line">    [Get(&quot;/users/&#123;user&#125;&quot;)]</span><br><span class="line">    Task&lt;User&gt; GetUser(string user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RestService类生成一个IGitHubApi的实现，它使用HttpClient进行调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var gitHubApi = RestService.For&lt;IGitHubApi&gt;(&quot;https://api.github.com&quot;);</span><br><span class="line"></span><br><span class="line">var octocat = await gitHubApi.GetUser(&quot;octocat&quot;);</span><br></pre></td></tr></table></figure>

<p>查看更多： <a href="https://reactiveui.github.io/refit/" target="_blank" rel="noopener">https://reactiveui.github.io/refit/</a> </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/04/28/技术/在C＃中使用RESTful API的几种好方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/04/28/技术/在C＃中使用RESTful API的几种好方法/" class="post-title-link" itemprop="url">在C＃中使用RESTful API的几种好方法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-04-28 23:28:00" itemprop="dateCreated datePublished" datetime="2020-04-28T23:28:00+08:00">2020-04-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-26 19:10:12" itemprop="dateModified" datetime="2020-05-26T19:10:12+08:00">2020-05-26</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在C＃中使用RESTful-API的几种好方法"><a href="#在C＃中使用RESTful-API的几种好方法" class="headerlink" title="在C＃中使用RESTful API的几种好方法"></a>在C＃中使用RESTful API的几种好方法</h1><p> <a href="https://code-maze.com/author/codemaze_blog/" target="_blank" rel="noopener">Vladimir Pecanac</a> </p>
<p>通过Web开发的路径，您发现自己迟早需要处理外部API（应用程序编程接口）。在本文中，我的目标是列出在C＃项目中使用RESTful API的方法的最全面列表，并通过一些简单示例向您展示如何做到这一点。</p>
<p>阅读该文章后，您将更深入地了解可以使用哪些选项，以及下次需要使用<a href="https://code-maze.com/ultimate-aspnet-core-3-web-api/" target="_blank" rel="noopener">RESTful API</a>时如何选择正确的选项。</p>
<h2 id="什么是RESTful-API？"><a href="#什么是RESTful-API？" class="headerlink" title="什么是RESTful API？"></a>什么是RESTful API？</h2><p>因此，在开始之前，您可能想知道<a href="https://code-maze.com/ultimate-aspnet-core-3-web-api/" target="_blank" rel="noopener">API</a>代表什么，以及RESTful的全部含义是什么？</p>
<p>简而言之，API是软件应用程序之间的层。您可以将请求发送到<a href="https://code-maze.com/ultimate-aspnet-core-3-web-api/" target="_blank" rel="noopener">API</a>，并从中获得响应。API隐藏了软件应用程序具体实现的所有细节，并公开了您用于与该应用程序通信的接口。</p>
<p>整个互联网是由API组成的大型蜘蛛网。我们使用API在应用程序之间通信和关联信息。我们有一个<a href="https://code-maze.com/ultimate-aspnet-core-3-web-api/" target="_blank" rel="noopener">API</a>，可以处理几乎所有内容。您每天使用的大多数服务都有自己的API（GoogleMaps，Facebook，Twitter，Instagram，天气门户…）</p>
<p>RESTful部分意味着API是根据REST（表示状态传输）的原理和规则来实现的，REST是网络的基础架构原理。RESTful API在大多数情况下会返回纯文本，JSON或XML响应。更详细地解释REST不在本文的讨论范围之内，但是您可以在我们的文章<a href="https://code-maze.com/top-rest-api-best-practices/" target="_blank" rel="noopener">REST API最佳实践中</a>阅读有关REST的更多信息。</p>
<h2 id="如何使用RESTful-API"><a href="#如何使用RESTful-API" class="headerlink" title="如何使用RESTful API"></a>如何使用RESTful API</h2><p>好吧，让我们进入整个故事中最重要的部分。</p>
<p>有几种方法可以在C＃中使用RESTful API：</p>
<ul>
<li><a href="https://code-maze.com/different-ways-consume-restful-api-csharp/#HttpWebRequest" target="_blank" rel="noopener"><strong>HttpWebRequest/Response Class</strong></a></li>
<li><a href="https://code-maze.com/different-ways-consume-restful-api-csharp/#webclient" target="_blank" rel="noopener"><strong>WebClient Class</strong></a></li>
<li><a href="https://code-maze.com/different-ways-consume-restful-api-csharp/#HttpClient" target="_blank" rel="noopener"><strong>HttpClient Class</strong></a></li>
<li><a href="https://code-maze.com/different-ways-consume-restful-api-csharp/#RestSharp" target="_blank" rel="noopener"><strong>RestSharp NuGet Package</strong></a></li>
<li><a href="https://code-maze.com/different-ways-consume-restful-api-csharp/#ServiceStack" target="_blank" rel="noopener"><strong>ServiceStack Http Utils</strong></a></li>
<li><strong><a href="https://code-maze.com/different-ways-consume-restful-api-csharp/#flurl" target="_blank" rel="noopener">Flurl</a></strong></li>
<li><strong><a href="https://code-maze.com/different-ways-consume-restful-api-csharp/#dalsoft" target="_blank" rel="noopener">DalSoft.RestClient</a></strong></li>
</ul>
<p>这些中的每一个都有优点和缺点，因此让我们仔细研究它们，看看它们提供了什么。</p>
<p>例如，我们将通过GitHub API收集有关RestSharp回购版本及其发布日期的信息。此信息是公开可用的，您可以在此处查看原始JSON响应的外观： <a href="https://api.github.com/repos/restsharp/restsharp/releases" target="_blank" rel="noopener">RestSharp版本</a></p>
<p>我们将利用Json.NET库的帮助来反序列化获得的响应。同样，对于某些示例，我们将使用库的内置反序列化机制。选择哪种方式取决于您，因为没有正确的方法。（您可以在<a href="https://github.com/CodeMazeBlog/ConsumeRestfulApisExamples" target="_blank" rel="noopener">源代码中</a>看到这两种机制的实现）。</p>
<p>我期望通过接下来的几个示例得到一个反序列化<code>JArray</code>（为简单起见），其中包含RestSharp发布信息。之后，我们可以遍历它以获得以下结果。</p>
<p> <img src="https://code-maze.com/wp-content/uploads/2017/06/RestSharp-releases.png" alt="img"> </p>
<h2 id="HttpWebRequest-Response类"><a href="#HttpWebRequest-Response类" class="headerlink" title="HttpWebRequest / Response类"></a>HttpWebRequest / Response类</h2><p>这是<code>WebRequest</code> 类的特定于HTTP的实现，该实现最初用于处理HTTP请求，但已过时并由<code>WebClient</code>该类代替 。</p>
<p>该<code>HttpWebRequest</code> 提供细粒度控制的要求制定过程的每一个环节。您可以想象，这可能是一把双刃剑，您很容易浪费大量时间来微调您的请求。另一方面，这可能正是您针对特定案例所需要的。</p>
<p><code>HttpWebRequest</code> 类不会阻止用户界面，也就是说，我相信您会同意这一点，这一点非常重要。</p>
<p><code>HttpWebResponse</code> 类为传入的响应提供了一个容器。</p>
<p>这是有关如何使用这些类使用API的简单示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class HttpWebRequestHandler : IRequestHandler</span><br><span class="line">&#123;</span><br><span class="line">    public string GetReleases(string url)</span><br><span class="line">    &#123;</span><br><span class="line">        var request = (HttpWebRequest)WebRequest.Create(url);</span><br><span class="line"></span><br><span class="line">        request.Method = &quot;GET&quot;;</span><br><span class="line">        request.UserAgent = RequestConstants.UserAgentValue;</span><br><span class="line">        request.AutomaticDecompression = DecompressionMethods.Deflate | DecompressionMethods.GZip;</span><br><span class="line"></span><br><span class="line">        var content = string.Empty;</span><br><span class="line"></span><br><span class="line">        using (var response = (HttpWebResponse)request.GetResponse())</span><br><span class="line">        &#123;</span><br><span class="line">            using (var stream = response.GetResponseStream())</span><br><span class="line">            &#123;</span><br><span class="line">                using (var sr = new StreamReader(stream))</span><br><span class="line">                &#123;</span><br><span class="line">                    content = sr.ReadToEnd();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 尽管是一个简单的示例，但是当您需要处理更复杂的方案（例如，发布表单信息，授权等）时，它会变得更加复杂。 </p>
<h2 id="WebClient类别"><a href="#WebClient类别" class="headerlink" title="WebClient类别"></a>WebClient类别</h2><p>这个类对<code>HttpWebRequest</code>的包装。它通过<code>HttpWebRequest</code>从开发人员中提取的细节来简化流程。该代码更容易编写，并且您通过这种方式犯错误的可能性较小。如果您想编写更少的代码，而不用担心所有细节，并且执行速度是不重要的，请考虑使用<code>WebClient</code>class。</p>
<p>这个示例应该使您大致了解<code>WebClient</code>与<code>HttpWebRequest</code>/ <code>HttpWebResponse</code>方法相比使用起来要容易得多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public string GetReleases(string url)</span><br><span class="line">&#123;</span><br><span class="line">    var client = new WebClient();</span><br><span class="line">    client.Headers.Add(RequestConstants.UserAgent, RequestConstants.UserAgentValue);</span><br><span class="line"></span><br><span class="line">    var response = client.DownloadString(url);</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容易得多，对吗？</p>
<p>除了其他<code>DownloadString</code>方法，<code>WebClient</code>类还提供了许多其他有用的方法，使我们的生活更轻松。我们可以轻松地使用它来操作字符串，文件或字节数组，并且价格比<code>HttpWebRequest</code>/ <code>HttpWebResponse</code>方法要慢几毫秒。</p>
<p>无论是<code>HttpWebRequest</code>/ <code>HttpWebResponse</code>和<code>WebClient</code>类在旧版本的.NET可供选择。如果您对其他产品感兴趣，请务必查看<a href="https://msdn.microsoft.com/en-us/library/system.net.webclient(v=vs.110).aspx" target="_blank" rel="noopener">MSDN</a><code>WebClient</code>。</p>
<h2 id="HttpClient类"><a href="#HttpClient类" class="headerlink" title="HttpClient类"></a>HttpClient类</h2><p><code>HttpClient</code> 是“新人”，它提供了旧库所缺乏的一些现代.NET功能。例如，您可以使用的单个实例发送多个请求<code>HttpClient</code>，它不绑定到特定的HTTP服务器或主机，而是使用async / await机制。</p>
<p>您可以<a href="https://channel9.msdn.com/Events/Build/2013/4-092" target="_blank" rel="noopener">在此视频中</a>找到<a href="https://channel9.msdn.com/Events/Build/2013/4-092" target="_blank" rel="noopener">使用HttpClient</a>的<a href="https://channel9.msdn.com/Events/Build/2013/4-092" target="_blank" rel="noopener">五个很好的理由</a>：</p>
<ul>
<li>强类型标题。</li>
<li>共享缓存，cookie和凭据</li>
<li>访问cookie和共享cookie</li>
<li>控制缓存和共享缓存。</li>
<li>将您的代码模块注入ASP.NET管道。清洁和模块化的代码。</li>
</ul>
<p><code>HttpClient</code>在我们的示例中，这是实际的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public string GetReleases(string url)</span><br><span class="line">&#123;</span><br><span class="line">    using (var httpClient = new HttpClient())</span><br><span class="line">    &#123;</span><br><span class="line">        httpClient.DefaultRequestHeaders.Add(RequestConstants.UserAgent, RequestConstants.UserAgentValue);</span><br><span class="line"></span><br><span class="line">        var response = httpClient.GetStringAsync(new Uri(url)).Result;</span><br><span class="line"></span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了简单起见，我同步实现了它。每个<code>HttpClient</code>方法都应异步使用，应该以这种方式使用。</p>
<p>另外，我还要提到一件事。<strong>是否<code>HttpClient</code>应该包装在using块中还是在应用程序级别上进行静态讨论。尽管它实现了<code>IDisposable</code>，但似乎通过将它包装在using块中，<a href="https://aspnetmonsters.com/2016/08/2016-08-27-httpclientwrong/" target="_blank" rel="noopener">会使应用程序出现故障并获得SocketException</a>。</strong>而在ANKIT博客中，提供了基于<a href="https://ankitvijay.net/2016/09/25/dispose-httpclient-or-have-a-static-instance/" target="_blank" rel="noopener">很多有利于静态初始化的</a>的<code>HttpClient</code>性能测试结果是。<strong>请务必阅读这些博客文章，</strong>因为它们可以帮助您更了解该<code>HttpClient</code> 库的正确用法。（原文编写时间比较旧，在新版的.NET Core3.1中，相关问题已经解决）</p>
<p>并且不要忘记，由于是新的，<code>HttpClient</code>是.NET 4.5以上版本才有，因此在某些旧项目中使用它可能会遇到麻烦。</p>
<h2 id="RestSharp"><a href="#RestSharp" class="headerlink" title="RestSharp"></a>RestSharp</h2><p>RestSharp是标准.NET库的OpenSource替代品，也是目前最酷的.NET库之一。它以NuGet软件包的形式提供，出于某些原因，您应该考虑尝试一下。</p>
<p>就像<code>HttpClient</code>RestSharp 一样，它是一个现代而全面的库，易于使用且令人愉悦，同时仍支持旧版本的.NET Framework。它具有内置的<a href="https://github.com/restsharp/RestSharp/wiki/Authenticators" target="_blank" rel="noopener">身份验证</a>和<a href="https://github.com/restsharp/RestSharp/wiki/Deserialization" target="_blank" rel="noopener">序列化/反序列化机制，</a>但允许您使用自定义<a href="https://github.com/restsharp/RestSharp/wiki/Deserialization" target="_blank" rel="noopener">机制</a>覆盖它们。它<a href="https://github.com/restsharp/RestSharp/wiki/Cross-Platform-Support" target="_blank" rel="noopener">可跨平台使用，</a>并支持OAuth1，OAuth2，基本，NTLM和基于参数的身份验证。您可以选择同步或异步工作。该库还有很多其他功能，而这些只是它提供的众多好处中的一部分。有关RestSharp的用法和功能的详细信息，您可以访问<a href="https://github.com/restsharp/RestSharp/wiki/Getting-Started" target="_blank" rel="noopener">GitHub上</a>的RestSharp <a href="https://github.com/restsharp/RestSharp/wiki/Getting-Started" target="_blank" rel="noopener">页面</a>。</p>
<p>现在，让我们尝试使用RestSharp get获取RestSharp版本的列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public string GetReleases(string url)</span><br><span class="line">&#123;</span><br><span class="line">    var client = new RestClient(url);</span><br><span class="line"></span><br><span class="line">    var response = client.Execute(new RestRequest());</span><br><span class="line"></span><br><span class="line">    return response.Content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单。RestSharp非常灵活，拥有使用RESTful API时几乎可以实现所有功能所需的所有工具。</p>
<p>在此示例中要注意的一件事是，由于示例的一致性，我没有使用RestSharp的反序列化机制，这有点浪费，但是我鼓励您使用它，因为它确实非常容易和方便。因此，您可以轻松地制作一个这样的容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class GitHubRelease</span><br><span class="line">&#123;</span><br><span class="line">    [JsonProperty(PropertyName = &quot;name&quot;)]</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    [JsonProperty(PropertyName = &quot;published_at&quot;)]</span><br><span class="line">    public string PublishedAt &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 然后使用该<code>Execute</code>方法直接反序列化对该容器的响应。您可以仅添加所需的属性，并使用属性<code>JsonProperty</code>将它们映射到C＃属性（很好的触摸）。由于我们在响应中获得了发布列表，因此我们将<code>List</code> 用作包含类型。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;GitHubRelease&gt; GetDeserializedReleases(string url)</span><br><span class="line">&#123;</span><br><span class="line">    var client = new RestClient(url);</span><br><span class="line"></span><br><span class="line">    var response = client.Execute&lt;List&lt;GitHubRelease&gt;&gt;(new RestRequest());</span><br><span class="line"></span><br><span class="line">    return response.Data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种非常直接而优雅的方式来获取我们的数据。</p>
<p>RestSharp不仅具有发送<code>GET</code>请求的功能，还可以自己探索并观察它的酷炫之处。</p>
<p>在RestSharp案例中要补充的最后一点是，其存储库需要维护者。如果您想了解更多有关这个很棒的库的信息，我敦促您前往<a href="https://github.com/restsharp/RestSharp" target="_blank" rel="noopener">RestSharp存储库</a>，帮助该项目继续发展并变得更好。</p>
<h2 id="ServiceStack-Http实用程序"><a href="#ServiceStack-Http实用程序" class="headerlink" title="ServiceStack Http实用程序"></a>ServiceStack Http实用程序</h2><p>另一个库，但与RestSharp不同，ServiceStack似乎得到了适当维护，并与现代<a href="https://code-maze.com/ultimate-aspnet-core-3-web-api/" target="_blank" rel="noopener">API</a>趋势保持同步。ServiceStack功能列表令人印象深刻，并且肯定具有各种应用程序。</p>
<p>在这里对我们最有用的是演示如何使用外部RESTful API。ServiceStack具有一种专门的方式来处理称为<a href="http://docs.servicestack.net/http-utils" target="_blank" rel="noopener">Http Utils的</a>第三方HTTP API 。</p>
<p>让我们看看如何首先使用Json.NET解析器来获取RestSharp版本是如何使用ServiceStack Http Utils。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public string GetReleases(string url)</span><br><span class="line">&#123;</span><br><span class="line">    var response = url.GetJsonFromUrl(webReq =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        webReq.UserAgent = RequestConstants.UserAgentValue;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 您还可以选择将其留给ServiceStack解析器。我们可以重用本文前面定义的<code>Release</code>类 。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;GitHubRelease&gt; GetDeserializedReleases(string url)</span><br><span class="line">&#123;</span><br><span class="line">    var releases = url.GetJsonFromUrl(webReq =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        webReq.UserAgent = RequestConstants.UserAgentValue;</span><br><span class="line">    &#125;).FromJson&lt;List&lt;GitHubRelease&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    return releases;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如您所见，无论哪种方式都可以正常工作，并且您可以选择是获取字符串响应还是立即反序列化它。</p>
<p>尽管ServiceStack是我们偶然发现的最后一个库，但令我感到惊讶的是，它使用起来如此容易，而且我认为它将来可能成为我处理API和服务的首选工具。</p>
<h2 id="Flurl"><a href="#Flurl" class="headerlink" title="Flurl"></a>Flurl</h2><p>评论库中许多人要求的图书馆之一，并在Internet上受到许多人的喜爱，但仍吸引着人们。</p>
<p>Flurl代表Fluent Url Builder，这是库构建其查询的方式。对于不熟悉flurl的做事方式的人来说，flurl只是意味着库的构建方式是将方法链接在一起以实现更高的可读性，类似于人类语言。</p>
<p>为了使事情更容易理解，让我们举一些例子（这个例子来自官方文档）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Flurl will use 1 HttpClient instance per host</span><br><span class="line">var person = await &quot;https://api.com&quot;</span><br><span class="line">    .AppendPathSegment(&quot;person&quot;)</span><br><span class="line">    .SetQueryParams(new &#123; a = 1, b = 2 &#125;)</span><br><span class="line">    .WithOAuthBearerToken(&quot;my_oauth_token&quot;)</span><br><span class="line">    .PostJsonAsync(new</span><br><span class="line">    &#123;</span><br><span class="line">        first_name = &quot;Claire&quot;,</span><br><span class="line">        last_name = &quot;Underwood&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">    .ReceiveJson&lt;Person&gt;();</span><br></pre></td></tr></table></figure>

<p>您可以看到方法如何链接在一起以完成“句子”。</p>
<p>在后台，Flurl使用HttpClient或通过自己的语法糖增强HttpClient库。因此，这意味着Flurl是一个异步库，因此请牢记这一点。</p>
<p>与其他高级库一样，我们可以通过两种不同的方式来做到这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public string GetReleases(string url)</span><br><span class="line">&#123;</span><br><span class="line">    var result = url</span><br><span class="line">        .WithHeader(RequestConstants.UserAgent, RequestConstants.UserAgentValue)</span><br><span class="line">        .GetJsonAsync&lt;List&lt;GitHubRelease&gt;&gt;()</span><br><span class="line">        .Result;</span><br><span class="line"></span><br><span class="line">    return JsonConvert.SerializeObject(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式相当糟糕，因为我们只是序列化结果，以便稍后对其进行反序列化。如果您使用的是Flurl之类的库，则不应以这种方式进行操作。</p>
<p>更好的做事方式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;GitHubRelease&gt; GetDeserializedReleases(string url)</span><br><span class="line">&#123;</span><br><span class="line">    var result = url</span><br><span class="line">        .WithHeader(RequestConstants.UserAgent, RequestConstants.UserAgentValue)</span><br><span class="line">        .GetJsonAsync&lt;List&lt;GitHubRelease&gt;&gt;()</span><br><span class="line">        .Result;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 随着<code>.Result</code>我们强迫代码的同步行为。使用Flurl的实际和预期方式如下所示： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public async Task&lt;List&lt;GitHubRelease&gt;&gt; GetDeserializedReleases(string url)</span><br><span class="line">&#123;</span><br><span class="line">    var result = await url</span><br><span class="line">        .WithHeader(RequestConstants.UserAgent, RequestConstants.UserAgentValue)</span><br><span class="line">        .GetJsonAsync&lt;List&lt;GitHubRelease&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这展示了Flurl库的全部潜力。</p>
<p>如果您想了解更多有关如何在不同的现实生活场景使用Flurl，看看我们的 <a href="https://code-maze.com/consuming-github-api-rest-with-flurl/" target="_blank" rel="noopener">消费GitHub的API（REST）随着</a><a href="https://code-maze.com/wp-admin/post.php?post=4822&action=edit" target="_blank" rel="noopener">Flurl</a> 文章</p>
<p>总而言之，它就像广告一样：易于使用，现代，可读性和可测试性。您对这个库还有什么期望？要开源？<a href="https://github.com/tmenier/Flurl" target="_blank" rel="noopener">签</a>出： <a href="https://github.com/tmenier/Flurl" target="_blank" rel="noopener">Flurl存储库</a>，如果您愿意，可以贡献自己的力量！</p>
<h2 id="DalSoft-RestClient"><a href="#DalSoft-RestClient" class="headerlink" title="DalSoft.RestClient"></a>DalSoft.RestClient</h2><p>现在，此列表与该列表中的任何内容都有些不同。但这一点有所不同。</p>
<p>让我们看看如何使用DalSoft.RestClient来使用GitHub API，然后谈论我们已完成的工作。</p>
<p>首先，您可以通过输入以下内容，通过NuGet软件包管理器下载DalSoft.RestClient： <code>Install-Package DalSoft.RestClient</code></p>
<p>或通过.NET Core CLI： <code>dotnet add package DalSoft.RestClient</code></p>
<p>两种方法都可以。</p>
<p>拥有图书馆后，我们可以执行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public string GetReleases(string url)</span><br><span class="line">&#123;</span><br><span class="line">    dynamic client = new RestClient(RequestConstants.BaseUrl,</span><br><span class="line">        new Headers &#123; &#123; RequestConstants.UserAgent, RequestConstants.UserAgentValue &#125; &#125;);</span><br><span class="line"></span><br><span class="line">    var response = client.repos.restsharp.restsharp.releases.Get().Result.ToString();</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 或最好使用DalSoft.RestClient在充分利用其功能的同时立即反序列化响应： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public async Task&lt;List&lt;GitHubRelease&gt;&gt; GetDeserializedReleases(string url)</span><br><span class="line">&#123;</span><br><span class="line">    dynamic client = new RestClient(RequestConstants.BaseUrl,</span><br><span class="line">        new Headers &#123; &#123; RequestConstants.UserAgent, RequestConstants.UserAgentValue &#125; &#125;);</span><br><span class="line"></span><br><span class="line">    var response = await client.repos.restsharp.restsharp.releases.Get();</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，让我们稍微讨论一下这些例子。</p>
<p>乍一看，它似乎并不比我们使用的其他一些现代库简单得多。</p>
<p>但这归结为形成请求的方式，那就是利用RestClient的动态特性。例如，我们的BaseUrl是<code>https://api.github.com</code> ，我们需要进入<code>https://api.github.com/repos/restsharp/restsharp/releases</code>。我们可以通过动态创建客户端，然后通过链接Url的“部分”来形成Url来做到这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await client.repos.restsharp.restsharp.releases.Get();</span><br></pre></td></tr></table></figure>

<p>形成请求的一种非常独特的方法。还有一个非常灵活的！</p>
<p>因此，一旦我们设置了基本的网址，就可以轻松地使用不同的端点。</p>
<p>还值得一提的是，我们得到的JSON响应会自动进行类型转换。如您在第二个示例中看到的那样，我们方法的返回值是<code>Task&gt;.</code> So，该库足够聪明，可以将响应转换为我们的类型（依赖于Json.NET）。这使我们的生活更加轻松。</p>
<p>除了易于理解和使用之外，DalSoft.RestClient还具有现代库应具备的所有功能。它是可<strong>配置的，异步的，可扩展的，可测试的，并且支持多个平台</strong>。</p>
<p>我们仅演示了DalSoft.RestClient功能的一小部分。如果您对使用DalSoft.RestClient感兴趣，请转至<a href="https://code-maze.com/dalsoft-restclient-consume-any-rest-api/" target="_blank" rel="noopener">我们的文章，</a>以学习如何在不同情况下使用它，或参阅 <a href="https://github.com/DalSoft/DalSoft.RestClient" target="_blank" rel="noopener">GitHub官方仓库</a>和<a href="https://restclient.dalsoft.io/" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="其他选择"><a href="#其他选择" class="headerlink" title="其他选择"></a>其他选择</h2><p>对于您的特定问题，还有许多其他选项可用。您可以使用任何这些库来使用特定的RESTful API。例如，<a href="https://github.com/octokit/octokit.net" target="_blank" rel="noopener">octokit.net专门 </a>用于GitHub API，<a href="https://github.com/facebook-csharp-sdk/facebook-csharp-sdk" target="_blank" rel="noopener">Facebook SDK</a> 用于使用Facebook API，并且还有许多其他功能可用于任何用途。</p>
<p>虽然这些库是专门为这些API而设计的，并且可能擅长于它们的用途，但它们的用途是有限的，因为您经常需要在应用程序中连接多个<a href="https://code-maze.com/ultimate-aspnet-core-3-web-api/" target="_blank" rel="noopener">API</a>。这可能会导致每个实现都有不同的实现方式，以及更多的依赖关系，这可能导致重复并且容易出错。库越具体，其灵活性就越差。</p>
<h2 id="GitHub上的源代码"><a href="#GitHub上的源代码" class="headerlink" title="GitHub上的源代码"></a>GitHub上的源代码</h2><p><a href="https://github.com/CodeMazeBlog/ConsumeRestfulApisExamples" target="_blank" rel="noopener">GitHub上的源代码</a></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>因此，总而言之，我们已经讨论了可用于使用RESTful API的不同工具。我们已经提到了一些.NET库，可以这样做<code>HttpWebRequest</code>，<code>WebClient</code>和<code>HttpClient</code>，以及一些惊人的第三方工具，如RestSharp和ServiceStack。您还对这些工具进行了简短的介绍，并给出了一些非常简单的示例来向您展示如何开始使用它们。</p>
<p>我认为您现在至少有95％准备使用一些REST。继续展开翅膀，探索并找到更多有趣且有趣的方式来使用和连接不同的API。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/04/22/技术/您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/04/22/技术/您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术/" class="post-title-link" itemprop="url">您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-04-22 22:58:00 / Modified: 22:56:56" itemprop="dateCreated datePublished" datetime="2020-04-22T22:58:00+08:00">2020-04-22</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="您应该知道的5种避免C＃-NET中事件造成的内存泄漏的技术"><a href="#您应该知道的5种避免C＃-NET中事件造成的内存泄漏的技术" class="headerlink" title="您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术"></a>您应该知道的5种避免C＃.NET中事件造成的内存泄漏的技术</h1><p>C＃（通常是.NET）中的事件注册是内存泄漏的最常见原因。至少从我的经验来看。实际上，我从事件中看到了太多的内存泄漏，因此 在代码中看到 <strong>+ =</strong>将立即使我感到怀疑。</p>
<p>尽管事件很常见，但它们也很危险。如果您不知道要查找的内容，则事件很容易导致内存泄漏。在本文中，我将解释此问题的根本原因，并提供几种最佳实践技术来解决该问题。最后，我将向您展示一个简单的技巧，以找出您是否确实存在内存泄漏。</p>
<h2 id="了解内存泄漏"><a href="#了解内存泄漏" class="headerlink" title="了解内存泄漏"></a>了解内存泄漏</h2><p>在垃圾收集环境中，术语“内存泄漏”有点反直觉。当有一个垃圾收集器负责收集所有内容时，我的内存如何泄漏？</p>
<p>答案是，在存在垃圾收集器（<strong>GC</strong>）的情况下，内存泄漏表示有些对象仍在引用中，但实际上未被使用。由于已引用它们，因此GC将不会收集它们，并且它们将永久保存，占用内存。</p>
<p>让我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class WiFiManager</span><br><span class="line">&#123;</span><br><span class="line">    public event EventHandler &lt;WifiEventArgs&gt; WiFiSignalChanged;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass</span><br><span class="line">&#123;</span><br><span class="line">    public MyClass(WiFiManager wiFiManager)</span><br><span class="line">    &#123;</span><br><span class="line">        wiFiManager.WiFiSignalChanged += OnWiFiChanged;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void OnWiFiChanged(object sender, WifiEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void SomeOperation(WiFiManager wiFiManager)</span><br><span class="line">&#123;</span><br><span class="line">    var myClass = new MyClass(wiFiManager);</span><br><span class="line">    myClass.DoSomething();</span><br><span class="line">    </span><br><span class="line">    //... myClass is not used again</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，我们假设<strong>WiFiManager</strong> 在程序的整个生命周期中都处于活动状态。执行<strong>SomeOperation之后</strong>，将创建<strong>MyClass</strong>的实例，并且不再使用它。程序员可能会认为GC将收集它，但事实并非如此。所述<strong>WiFiManager</strong>保持在其事件MyClass的参考 <strong>WiFiSignalChanged</strong>和它引起了内存泄漏。GC将永远不会收集<strong>MyClass</strong>。</p>
<h2 id="1-确保退订"><a href="#1-确保退订" class="headerlink" title="1.确保退订"></a>1.确保退订</h2><p>显而易见的解决方案（尽管并非总是最简单的）是记住从事件中注销事件处理程序。一种方法是实现IDisposable：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass : IDisposable</span><br><span class="line">&#123;</span><br><span class="line">    private readonly WiFiManager _wiFiManager;</span><br><span class="line"> </span><br><span class="line">    public MyClass(WiFiManager wiFiManager)</span><br><span class="line">    &#123;</span><br><span class="line">        _wiFiManager = wiFiManager;</span><br><span class="line">        _wiFiManager.WiFiSignalChanged += OnWiFiChanged;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void Dispose()</span><br><span class="line">    &#123;</span><br><span class="line">        _wiFiManager.WiFiSignalChanged -= OnWiFiChanged;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void OnWiFiChanged(object sender, WifiEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当然，您必须确保调用<strong>Dispose</strong>。如果您有WPF控件，一个简单的解决方案是退订<strong>Unloaded</strong>事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public partial class MyUserControl : UserControl</span><br><span class="line">&#123;</span><br><span class="line">    public MyUserControl(WiFiManager wiFiManager)</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">        this.Loaded += (sender, args) =&gt; wiFiManager.WiFiSignalChanged += OnWiFiChanged;</span><br><span class="line">        this.Unloaded += (sender, args) =&gt; wiFiManager.WiFiSignalChanged -= OnWiFiChanged;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void OnWiFiChanged(object sender, WifiEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点**：简单易读的代码。</p>
<p><strong>缺点：</strong>您很容易忘记取消订阅，或者在所有情况下都不会取消订阅，这将导致内存泄漏。</p>
<h6 id="注意：并非所有事件注册都会导致内存泄漏。注册到将要过期的事件时，不会发生内存泄漏。例如，在WPF-UserControl中，您可以注册到Button的Click事件。这很好，并且不需要注销，因为用户控件是唯一引用该Button的控件。如果没有一个人引用用户控件，那么也将没有一个人引用按钮，并且GC将同时收集两者。"><a href="#注意：并非所有事件注册都会导致内存泄漏。注册到将要过期的事件时，不会发生内存泄漏。例如，在WPF-UserControl中，您可以注册到Button的Click事件。这很好，并且不需要注销，因为用户控件是唯一引用该Button的控件。如果没有一个人引用用户控件，那么也将没有一个人引用按钮，并且GC将同时收集两者。" class="headerlink" title="注意：并非所有事件注册都会导致内存泄漏。注册到将要过期的事件时，不会发生内存泄漏。例如，在WPF UserControl中，您可以注册到Button的Click事件。这很好，并且不需要注销，因为用户控件是唯一引用该Button的控件。如果没有一个人引用用户控件，那么也将没有一个人引用按钮，并且GC将同时收集两者。"></a>注意：并非所有事件注册都会导致内存泄漏。注册到将要<strong>过期</strong>的事件时，不会发生内存泄漏。例如，在WPF <strong>UserControl中，</strong>您可以注册到Button的<strong>Click</strong>事件。这很好，并且不需要注销，因为用户控件是唯一引用该Button的控件。如果没有一个人引用用户控件，那么也将没有一个人引用按钮，并且<strong>GC</strong>将同时收集两者。</h6><h2 id="2-让处理程序退订"><a href="#2-让处理程序退订" class="headerlink" title="2.让处理程序退订"></a>2.让处理程序退订</h2><p>在某些情况下，您可能希望事件处理程序仅发生一次。在这种情况下，您将希望代码自己退订。当事件处理程序是命名方法时，它很容易：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass</span><br><span class="line">&#123;</span><br><span class="line">    private readonly WiFiManager _wiFiManager;</span><br><span class="line"> </span><br><span class="line">    public MyClass(WiFiManager wiFiManager)</span><br><span class="line">    &#123;</span><br><span class="line">        _wiFiManager = wiFiManager;</span><br><span class="line">        _wiFiManager.WiFiSignalChanged += OnWiFiChanged;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void OnWiFiChanged(object sender, WifiEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        // do something</span><br><span class="line">        _wiFiManager.WiFiSignalChanged -= OnWiFiChanged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，有时您希望事件处理程序是lambda表达式。在这种情况下，以下是一种使自己退订的有用技术：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MyClass</span><br><span class="line">&#123;</span><br><span class="line">    public MyClass(WiFiManager wiFiManager)</span><br><span class="line">    &#123;</span><br><span class="line">        var someObject = GetSomeObject();</span><br><span class="line">        EventHandler&lt;WifiEventArgs&gt; handler = null;</span><br><span class="line">        handler = (sender, args) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(someObject);</span><br><span class="line">            wiFiManager.WiFiSignalChanged -= handler;</span><br><span class="line">        &#125;;</span><br><span class="line">        wiFiManager.WiFiSignalChanged += handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，lambda表达式非常有用，因为您可以捕获局部变量<strong>someObject</strong>，而使用处理程序方法则无法做到这一点。</p>
<p><strong>优点：</strong>简单，易读，只要您确定事件至少会触发一次，就不会发生内存泄漏。</p>
<p><strong>缺点：</strong>仅在需要处理一次事件的特殊情况下可用。</p>
<h2 id="3-将弱事件与事件聚合器一起使用"><a href="#3-将弱事件与事件聚合器一起使用" class="headerlink" title="3.将弱事件与事件聚合器一起使用"></a>3.将弱事件与事件聚合器一起使用</h2><p>在.NET中引用对象时，您基本上会告诉GC该对象正在使用中，因此请不要收集它。有一种引用对象的方法，而无需实际说“我正在使用它”。这种参考称为 <em>弱参考</em>。您是说“我不需要它，但是如果它仍然存在，那么我会使用它”。在其他换句话说，如果某个对象仅被弱引用引用，则<strong>GC</strong>会收集该对象并释放该内存。这是使用.NET的<strong>WeakReference</strong> 类实现的。</p>
<p>我们可以通过多种方式使用它来防止内存泄漏。一种流行的设计模式是使用<a href="https://www.codeproject.com/Articles/812461/Event-Aggregator-Pattern" target="_blank" rel="noopener">事件聚合器</a>。这个概念是，任何人都可以<strong>订阅</strong> T类型的事件，任何人都可以<strong>发布</strong> T类型的事件。因此，当一个类发布事件时，将调用所有订阅的事件处理程序。事件聚合器使用WeakReference引用所有内容。所以即使有物体提斯 订阅事件，仍然可以对其进行垃圾回收。</p>
<p>这是一个使用<strong>Prism</strong> 流行的事件聚合器（通过NuGet <a href="https://www.nuget.org/packages/Prism.Core/" target="_blank" rel="noopener">Prism.Core提供</a>）的<a href="https://www.nuget.org/packages/Prism.Core/" target="_blank" rel="noopener">示例</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class WiFiManager</span><br><span class="line">&#123;</span><br><span class="line">    private readonly IEventAggregator _eventAggregator;</span><br><span class="line"> </span><br><span class="line">    public WiFiManager(IEventAggregator eventAggregator)</span><br><span class="line">    &#123;</span><br><span class="line">        _eventAggregator = eventAggregator;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void PublishEvent()</span><br><span class="line">    &#123;</span><br><span class="line">        _eventAggregator.GetEvent&lt;WiFiEvent&gt;().Publish(new WifiEventArgs());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass</span><br><span class="line">&#123;</span><br><span class="line">    public MyClass(IEventAggregator eventAggregator)</span><br><span class="line">    &#123;</span><br><span class="line">        eventAggregator.GetEvent&lt;WiFiEvent&gt;().Subscribe(OnWiFiChanged);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void OnWiFiChanged(WifiEventArgs args)</span><br><span class="line">    &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class WiFiEvent : PubSubEvent&lt;WifiEventArgs&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> 防止内存泄漏，相对易于使用。</p>
<p><strong>缺点：</strong></p>
<p> 充当所有事件的全局容器。任何人都可以订阅任何人。这使得系统在过度使用时难以理解。没有分离的关注点。</p>
<h2 id="4-对常规事件使用弱事件处理程序"><a href="#4-对常规事件使用弱事件处理程序" class="headerlink" title="4.对常规事件使用弱事件处理程序"></a>4.对常规事件使用弱事件处理程序</h2><p>借助一些代码技巧，可以将弱引用与常规事件一起使用。这可以通过几种不同的方式来实现。这是使用Paul Stovell的<a href="http://paulstovell.com/blog/weakevents" target="_blank" rel="noopener">WeakEventHandler</a>的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass</span><br><span class="line">&#123;</span><br><span class="line">    public MyClass(WiFiManager wiFiManager)</span><br><span class="line">    &#123;</span><br><span class="line">        wiFiManager.WiFiSignalChanged += new WeakEventHandler&lt;WifiEventArgs&gt;(OnWiFiChanged).Handler;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void OnWiFiChanged(object sender, WifiEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class WiFiManager</span><br><span class="line">&#123;</span><br><span class="line">    public event EventHandler&lt;WifiEventArgs&gt; WiFiSignalChanged;</span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void SomeOperation(WiFiManager wiFiManager)</span><br><span class="line">&#123;</span><br><span class="line">    var myClass = new MyClass(wiFiManager);</span><br><span class="line">    myClass.DoSomething();</span><br><span class="line">    </span><br><span class="line">    //... myClass is not used again</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我真的很喜欢这种方法，因为在我们的案例中，发布者<strong>WiFiManager</strong>保留了标准的C＃事件。这只是这种模式的一种实现，但是实际上有很多方法可以解决。<strong>Daniel Grunwald</strong>写了<a href="https://www.codeproject.com/Articles/29922/Weak-Events-in-C" target="_blank" rel="noopener">一篇</a>有关不同实现及其差异的文章。</p>
<p><strong>优点：</strong>利用标准事件。简单。没有内存泄漏。关注点分离（与事件聚合器不同）。</p>
<p><strong>缺点：</strong>此模式的不同实现有一些细微之处和不同问题。该示例中的实现实际上创建了一个 注册的<strong>包装</strong>对象，该 <strong>包装</strong>对象从未被GC收集。其他实现可以解决此问题，但还有其他问题，例如其他样板代码。在Daniel的<a href="https://www.codeproject.com/Articles/29922/Weak-Events-in-C" target="_blank" rel="noopener">文章中</a>了解有关此内容的更多信息 。</p>
<h2 id="WeakReference解决方案存在的问题"><a href="#WeakReference解决方案存在的问题" class="headerlink" title="WeakReference解决方案存在的问题"></a>WeakReference解决方案存在的问题</h2><p>使用<strong>WeakReference</strong>意味着<strong>GC</strong>将能够在可能的情况下收集订阅类。但是，GC不会立即收集未引用的对象。就开发商而言，它是随机的。因此，对于弱事件，您可能会在当时不应该存在的对象中调用事件处理程序。</p>
<p>事件处理程序可能会执行无害的操作，例如更新内部状态。或者，它可能会更改程序状态，直到GC决定随机收集某个时间为止。这种行为确实很危险。在<a href="https://ladimolnar.com/2015/09/14/the-weak-event-pattern-is-dangerous/" target="_blank" rel="noopener">“弱事件模式是危险的”中</a>对此进行附加阅读 。</p>
<h2 id="5-在没有内存探查器的情况下检测内存泄漏"><a href="#5-在没有内存探查器的情况下检测内存泄漏" class="headerlink" title="5.在没有内存探查器的情况下检测内存泄漏"></a>5.在没有内存探查器的情况下检测内存泄漏</h2><p>此技术是为了测试现有的内存泄漏，而不是编码模式以首先避免它们。</p>
<p>假设您怀疑某个类存在内存泄漏。如果您有创建一个实例然后希望<strong>GC</strong>收集它的情况，则可以轻松地确定是否将收集您的实例或是否存在内存泄漏。按着这些次序：</p>
<p>1.将<strong>终结器添加</strong>到您的可疑类中，并在其中放置一个断点：</p>
<p><img src="https://i2.wp.com/michaelscodingspot.com/wp-content/uploads/2018/12/breakpoint-in-finalizer.jpg?w=1080&ssl=1" alt="img"></p>
<ol start="2">
<li>在场景<strong>开始</strong>时添加以下要调用的魔术3行：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GC.Collect();</span><br><span class="line">GC.WaitForPendingFinalizers();</span><br><span class="line">GC.Collect();</span><br></pre></td></tr></table></figure>

<p>这将迫使GC到目前为止收集所有未引用的实例（不在生产环境中使用），因此它们不会干扰我们的调试。</p>
<p>3.添加相同的3条魔术代码行，以 <strong>在</strong>方案<strong>之后</strong>运行。请记住，该方案是创建并收集可疑对象的方案。</p>
<p>4.运行有问题的方案。</p>
<p>在第1步中，我告诉您在类的终结器中放置一个断点。<strong>在</strong>第一个垃圾回收完成<strong>之后</strong>，您实际上应该注意该断点。否则，您可能会被废弃旧实例感到困惑。需要注意的重要时刻是 您的方案<strong>之后</strong>调试器是否在Finalizer中停止 。 </p>
<p>它还有助于在类的构造函数中放置一个断点。这样，您可以计算创建次数和完成次数。如果触发了终结器中的断点，则GC会收集您的实例，一切正常。如果没有，则可能发生内存泄漏。</p>
<p>这是我调试的一种方案，该方案使用了上一种技术中的WeakEventHandler，并且没有内存泄漏：</p>
<p><video controls src="https://michaelscodingspot.com/wp-content/uploads/2018/12/my-class-is-finalized-with-weakEventHandler.mp4" style="box-sizing: border-box; max-width: 100%; margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;"></video></p>
<p>这是我使用常规事件注册的另一种情况，它确实存在内存泄漏：</p>
<p><video controls src="https://michaelscodingspot.com/wp-content/uploads/2018/12/my-class-is-not-finalized-with-regular-event.mp4" style="box-sizing: border-box; max-width: 100%; margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;"></video></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>总是让我感到惊讶的是，C＃看起来像是一种易于学习的语言，并且提供了一个提供训练平台的环境。但实际上，还远远没有做到。诸如使用事件之类的简单事情，可以由未经培训的手轻松地将您的应用程序变成一堆内存泄漏。</p>
<p>至于在代码中使用的正确模式，我认为本文的结论应该是，在所有情况下都没有正确答案。提供的所有技术，以及他们， 视情况而定是可行的解决方案。 </p>
<p>原来这是一个相对较大的职位，但在此问题上，我仍然处于较高水平。这恰恰证明了在这些问题上存在多少深度，以及软件开发如何永无止境。</p>
<p>有关内存泄漏的更多信息，请查看我的文章<a href="https://michaelscodingspot.com/2019/01/03/find-fix-and-avoid-memory-leaks-in-c-net-8-best-practices/" target="_blank" rel="noopener">查找，修复和避免C＃.NET：8最佳实践中的内存泄漏</a>。从我自己的经验和其他高级.NET开发人员那里获得的大量信息都为我提供了建议。它包括有关内存分析器，非托管代码的内存泄漏，监控内存等信息。</p>
<p>我希望您在评论部分中留下一些反馈。并确保<a href="https://michaelscodingspot.com/subscribe/" target="_blank" rel="noopener">订阅</a>博客并收到新帖子通知。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/04/22/技术/分析EFCore中的内存泄漏/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/04/22/技术/分析EFCore中的内存泄漏/" class="post-title-link" itemprop="url">分析EFCore中的内存泄漏</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-04-22 22:28:00 / Modified: 22:57:45" itemprop="dateCreated datePublished" datetime="2020-04-22T22:28:00+08:00">2020-04-22</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分析EFCore中的内存泄漏"><a href="#分析EFCore中的内存泄漏" class="headerlink" title="分析EFCore中的内存泄漏"></a>分析EFCore中的内存泄漏</h1><p> <img src="https://dzone.com/storage/temp/12517247-pic-fire-house-leaking-water-into-puddle.jpg" alt="消防漏水入水坑"> </p>
<p>术语“内存泄漏”和“ .NET应用程序”不是经常一起使用。但是，我们最近在一个.NET Core Web应用程序中出现了一系列内存不足异常。事实证明，此问题是由Entity Framework Core中的行为更改引起的，尽管最终的解决方案非常简单，但实现该目标的过程既充满挑战又有趣。</p>
<p>该系统本身托管在Azure中，由Angular SPA前端和后端的.NET Core API组成，使用Entity Framework Core与Azure SQL数据库进行通信。作为专门从事.NET开发的软件咨询公司，我们之前已经编写了许多类似的应用程序。因此<a href="https://dzone.com/articles/what-causes-outofmemoryerror" target="_blank" rel="noopener">，内存不足崩溃</a>是无法预料的，因此我们立即知道这是需要认真对待的事情。使用Azure门户中的指标，我们可以看到内存使用率稳步上升，然后突然下降：此下降是应用程序崩溃。</p>
<p><img src="https://dzone.com/storage/temp/12481545-before.png" alt="修复之前"></p>
<p><em>修复之前</em></p>
<p>因此，我们花了一些时间进行调查并逐步进行更改，以解决看似经典的内存泄漏问题。.NET泄漏的常见原因是未正确处理某些问题，在我们的案例中很可能是EF Core数据库上下文。因此，我们遍历了源代码，以寻找可能无法处理上下文的潜在原因。这变成了空白。</p>
<p>我们将Entity Framework Core升级到了最新版本，因为最近的更新包括各种内存泄漏的修复程序和总体效率的提高。</p>
<p>我们还在使用的Application Insights版本中发现了可能的内存泄漏（请参阅<a href="https://github.com/microsoft/ApplicationInsights-dotnet/issues/594），因此我们也对该软件包进行了升级。" target="_blank" rel="noopener">https://github.com/microsoft/ApplicationInsights-dotnet/issues/594），因此我们也对该软件包进行了升级。</a></p>
<p>这些都不能解决问题，因此我们解剖了从Azure应用服务中获取的内存转储（请参阅<a href="https://blogs.msdn.microsoft.com/jpsanders/2017/02/02/how-to-get-a-full-memory-dump-in-azure-app-services/）。" target="_blank" rel="noopener">https://blogs.msdn.microsoft.com/jpsanders/2017/02/02/how-to-get-a-full-memory-dump-in-azure-app-services/）。</a></p>
<p>我们注意到，绝大多数托管内存最终都由MemoryCache类使用。进一步深入研究表明，大多数缓存数据都是原始SQL查询的形式。我们看到大量的根本上是同一查询的事件被多次缓存，并且参数本身被硬编码在查询中而不是被参数化。</p>
<p>例如，与其像这样缓存查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP (<span class="number">1</span>) UserId, FirstName, LastName, EmailAddress</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">Users</span></span><br><span class="line"><span class="keyword">WHERE</span> UserId = @param_1</span><br></pre></td></tr></table></figure>

<p>我们发现这样的多个查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT TOP (1) UserId, FirstName, LastName, EmailAddress</span><br><span class="line">FROM Users</span><br><span class="line">WHERE UserId = 5</span><br></pre></td></tr></table></figure>

<p>因此，我们进行了一些搜索，寻找可能与之相关的EF核心问题，并遇到了这个问题：<a href="https://github.com/aspnet/EntityFrameworkCore/issues/10535" target="_blank" rel="noopener">https</a> : <a href="https://github.com/aspnet/EntityFrameworkCore/issues/10535" target="_blank" rel="noopener">//github.com/aspnet/EntityFrameworkCore/issues/10535</a>。</p>
<p>关于这个问题的主题指出了这个问题：我们正在建立一个动态表达式树，并使用它  <code>Expressions.Expression.Constant</code> 来为where子句提供参数。使用常量表达式意味着Entity Framework Core不会参数化SQL查询，并且是Entity Framework 6的行为更改。</p>
<p>我们到处都使用这个表达式树，通过它的ID来获取某些东西，这就是为什么它是一个很大的问题。</p>
<p>因此，这就是我们所做的更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Before</span><br><span class="line">var param = Expressions.Expression.Parameter(typeof(T));</span><br><span class="line">Expression = Expressions.Expression.Lambda&lt;Func&lt;T, bool&gt;&gt;(</span><br><span class="line">  Expressions.Expression.Call(</span><br><span class="line">    Expressions.Expression.Constant(valuesToFilter),</span><br><span class="line">    &quot;Contains&quot;,</span><br><span class="line">    Type.EmptyTypes,</span><br><span class="line">    Expressions.Expression.Property(param, propertyName)),</span><br><span class="line">  param);</span><br><span class="line">// After</span><br><span class="line">var param = Expressions.Expression.Parameter(typeof(T));</span><br><span class="line">// This is what we added</span><br><span class="line">Expression&lt;Func&lt;List&lt;int&gt;&gt;&gt; valuesToFilterLambda = () =&gt; valuesToFilter;</span><br><span class="line">Expression = Expressions.Expression.Lambda&lt;Func&lt;T, bool&gt;&gt;(</span><br><span class="line">  Expressions.Expression.Call(</span><br><span class="line">    valuesToFilterLambda.Body,</span><br><span class="line">    &quot;Contains&quot;,</span><br><span class="line">    Type.EmptyTypes,</span><br><span class="line">    Expressions.Expression.Property(param, propertyName)),</span><br><span class="line">  param);</span><br></pre></td></tr></table></figure>

<p>使用lambda表达式获取表达式主体会使<a href="https://dzone.com/articles/entity-framework-core-30-and-sql-server-2019-perfo" target="_blank" rel="noopener">Entity Framework Core</a>对SQL查询进行参数化，因此仅缓存它的一个实例。</p>
<p>这是包括修订版本在内的一段时间内的内存使用情况。该版本以红色标记，您可以看到差异很大。稳定的内存使用量从未超过200MB，而不断攀升至超过1GB，然后发生崩溃。</p>
<p><img src="https://dzone.com/storage/temp/12481549-release.png" alt="修复后"></p>
<p><em>修复后</em></p>
<p>最初进行调查时，真正的解决方案不是我们要注意的事情，而是通过检查内存转储并遵循证据我们最终到达那里。</p>
<p>从此调查中可以汲取的教训是：</p>
<ul>
<li>内存转储不会说谎-如果内存泄漏，请先查看证据。</li>
<li>微软已经开放了EF Core的源代码，所有问题在那里所有人都可以看到，对有需求的开发者来说非常方便。</li>
<li>简单的代码更改（在这种情况下为一行）可能会产生巨大的影响。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/04/17/随笔/那个程序员，为什么选择改行_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/04/17/随笔/那个程序员，为什么选择改行_/" class="post-title-link" itemprop="url">那个程序员，为什么选择改行_</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-04-17 22:28:00" itemprop="dateCreated datePublished" datetime="2020-04-17T22:28:00+08:00">2020-04-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-26 19:35:09" itemprop="dateModified" datetime="2020-05-26T19:35:09+08:00">2020-05-26</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随笔/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>有一天，一位同事跟我说：老w已经改行做美缝去了，你怎么看？</p>
<p>我想了想，说：他大概终于做出了眼下最符合他的选择。</p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>老w是我曾经一位同事。</p>
<p>还记得2014年面试的时候第一次遇到他，当时的他精力旺盛，充满干劲。大概是因为他上一段职场中获得了他认为非常充足的收获，所以找工作的时候，心态也非常积极乐观，这也让面试的过程很轻松愉悦，技术问题一问一个准。</p>
<p>这应该是一个能够为公司创造价值的优秀开发者吧！当时，我这样想，于是毫不犹豫的告知领导，让领导把老w留下来。</p>
<p>被公司招进来之后，他也表现出他的足够专业，使得他能够在这段工作中平滑发展，获得让大家满意的评价。</p>
<p>如果没有其他意外，大概他将从这里起步，在星城长沙好好发展，直到有一天不再适合IT为止。（而那一天，也许得42岁之后吧）。</p>
<p>后来，我从这家公司离开若干年后，与他在一家初创公司相聚。</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p>老w来到这里有不少原因。首先原公司项目回款陷入僵持状态，管理层和董事会出现了重大分歧，董事会已经无意于维持公司的进一步发展，进而导致了严重的经济问题，那几个月员工的工资和公积金已经无法按时间缴纳。而老w本身也自我感觉技术到了瓶颈，打算换一个岗位来提升自己，但是原公司的发展困境显然无法给他创造适当的机会。</p>
<p>于是当有人挖他时，他顺势就把工作辞了，来到了这家新成立的公司。</p>
<p>老板很慷慨，看到他是一位经验丰富的开发者，并没有给他安排试用期，而是入职就直接成为正式员工。加入公司的前几个月有点像蜜月期，他和部门经理之间经常对技术进行探讨。由于部门经理主要从事嵌入式系统开发，对互联网技术几乎不懂，老w则也算是从业老兵，虽然基础不扎实，但还能勉强应付部门经理的问题，所以双方的沟通比较融洽。</p>
<p>他们部门的产品也主要是偏物联网的智慧监测管理平台，需要运用嵌入式技术开发设备上的组件，并通过Web平台来展示数据的状态信息。而老W之前并不了解物联网相关领域，但在Web开发领域还是有一点点积累，能够勉强把自己手头上的任务完成妥当。</p>
<p>然而，在初创公司做产品并非只是干好那一亩三分地就够了。他和大部分拥有一定经验的所谓高级开发者一样，总是觉得干好技术就是自己的本份，对业务知识不太在乎。而物联网行业需要太多的行业基础，如果不能深入行业，几乎很难做出成熟的产品。</p>
<p>随着项目的逐渐深入，也完美暴露出老w的技术短板。他已经工作了六七年，但是平时主要负责增删改查，对前端页面和框架底层几乎很少涉及，他本身缺乏主动学习的积极性和创造性，对新技术和前端技术缺乏兴趣和敏感度，甚至连搜索查找问题的能力也很欠缺，这使得他得花许多精力来学习框架知识，并间接导致项目速度进展缓慢。</p>
<p>原本计划三个月做一个小产品，但由于种种原因，以及后来的迭代，硬生生五六个月才完成。在产品终于做完开始正式运行之后，由于后台代码存在的缺陷比较多，部门经理对他大为失望。于是被调到其他部门当研发工程师，但在新的工作岗位上，他很快就暴露出自己无法胜任相关岗位的能力，又回到了原部门。</p>
<p>原部门已经没有他的工作安排了，从此他陷入了长达一个多月的清闲期。这段时间，他也没去找工作，每天朝九晚五，上上网，看看电影，由于他本身就对技术兴趣不足，自然而然也不会踏踏实实补足短板，于是安安稳稳的在公司混了好几个月。</p>
<p>2018年过完年，就从公司离开。之后听说他前前后后找了好几轮工作，但都没能好好的干下去。听说他曾经一度打算选择成为独立开发者，却接不到什么好项目，有的项目完全是费力不讨好，付出了许多努力，却交货时被客户打回。</p>
<p>所以最终选择改行也是万般无奈。</p>
<h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><p>老w的职业发展历程总是令我扼腕叹息。虽然程序员转行很正常，但他年轻时也算是精力充沛，对技术充满激情，却为何刚过而立之年就不得不离开行业？要想维持职场长久的生命力，究竟该做哪些努力？这个问题想必已经深深的困扰着许多人。</p>
<p>在我们的身边，有许多这样或那样的人选择IT行业，选择成为程序员。也许大家选择成为程序员的理由不尽相同，但是大家的学习曲线或许却大体类似。这种学习曲线，大概有点像“达克效应”曲线一般魔幻真实。</p>
<p><img src="https://uploader.shimo.im/f/WXL0JugXKFISHNSP.png!thumbnail" alt="图片"></p>
<p>（达克效应）</p>
<p>用来描述一种认知偏差。它表明，能力差的人总是有一种虚幻的自我优越感，他们总是错误的以为自己比真实的自己更优越。</p>
<p>在这个效应中，将一个人求知的阶段划分为四个阶段：</p>
<p>1、不知道自己不知道。</p>
<p>这一阶段是我们刚刚加入职场的时候，由于眼界和见识的限制，我们将在较短的时间内获得完成短期工作所需的部分知识。这些知识使得我们在短期内自我膨胀，然后心态发生改变，渐渐的成为“愚昧山峰”上的一块顽固之石。过早的登上愚昧之山，对每个开发者来说都不是一件好事情，这意味着你或者你们公司所在行业的天花板太低、或者你的见识太低，使得你过于轻易的就掌握了驾驭当前应用场景的知识，如果不做出改变，将为未来埋下祸根。</p>
<p>2、知道自己不知道。</p>
<p>新技术的发展是如此的突飞猛进，当你还在睡安稳觉时，或许一不小心就被淘汰了。许多“顽固之石”对于新技术的出现，总是抱有成见，甚至会习惯于用自己的固有思想来思考问题。于是在市场面前，一旦遇到一波有一波的挫折，并陷入绝望之谷。</p>
<p>3、知道自己知道</p>
<p>绝望之谷，或使人逃离，或使人成长。</p>
<p>前面故事提到的老w，就是逃离的典型。由于其固有习惯和见识，让他遇到新技术、新应用场景带来的挑战时，总是选择像海龟一样，把自己深藏在一个“壳”中，并且甚至逃避问题，最终只能在一波有一波的挫折面前，选择离开行业。</p>
<p>还有一些人，他们会以过去的挫折为跳板，然后不断的学习，进入“开悟之谷”。这个阶段才是智慧形成的阶段，这意味着你过去的从业经验和知识将成为你成长的宝贵财富。</p>
<p>4、不知道自己知道。</p>
<p>如果始终保持积极乐观和空杯的心态，你掌握的知识也将越来越多，你所散发出的知识的馥郁，也将促使你能够成为身边人学习的榜样，并将促使你成为真正的“大师”。</p>
<h1 id="五"><a href="#五" class="headerlink" title="五"></a>五</h1><p>在我们的身边，被类似“达克效应”困扰的现象其实无处不在。拿笔者为例，曾经有一段时间，我经常写博客，还以为自己的博客写得挺有文采的。后来读了许多书，发现自己简直就是可以称为“无知”，于是花了更多的时间来提高自己。</p>
<p>作为开发者也许都将如此，你所知道的越多，其实意味着不知道的越多。每一次你以为大彻大悟，以为道理不过如此，但是往往随着你学习的进一步深入，只会使你更加清楚自己的愚昧。</p>
<p>一次又一次探索中，不断的发现自己的无知，看似在浪费时间，其实是在不断的扎根。人生的每一次成长，从不是一蹴而就，而是像攀登高峰一般，一步一步脚印，每一步都得踏踏实实。</p>
<p>你今天的积累，既是你过去的沉淀，更是适应未来变化的踏脚石。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://techq.xyz/2020/04/17/随笔/那位五十多岁的创业者给我的启示/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="溪源">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiyuan技术圈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/04/17/随笔/那位五十多岁的创业者给我的启示/" class="post-title-link" itemprop="url">那个年过半百的奋斗者~</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-04-17 22:28:00 / Modified: 22:26:46" itemprop="dateCreated datePublished" datetime="2020-04-17T22:28:00+08:00">2020-04-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随笔/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>我曾经提到过最终改行从事美缝行业的老w，他靠自己的“不够努力”，最终离开了行业。</p>
<p>但是，这个世界其实有点讽刺。</p>
<p>在沉迷于安逸小日子的老w每天朝九晚五，只想拿钱，不想干活的那段日子，隔壁的总经理办公室却经常通宵达旦、灯火通明，那位五十五岁的老板Y总，正在为了自己的梦想努力奋斗着。</p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>在加入公司之前，我曾经见过一次Y总，那是在一个茶室，跟Y总有过一番简单的沟通后，我打算去公司看看，以便了解公司实际的产品情况。</p>
<p>于是受到技术团队负责人的邀请，我选择了一个阳光明媚的下午，坐上了被当地人称为“最长公交线路”的127路公交车，在那条的弯弯曲曲的公交线路上，折腾了大概一个多小时，终于才来到了目的地，位于当地东北角的某商务写字楼。并再次见到了Y总。</p>
<p>虽然是第二次见到Y总，但是第一次其实只是简单的沟通，并没有仔细打量这位领导。这一次，算是对Y总有了更加深刻的印象。</p>
<p>那是一位两鬓开始逐渐开始冒出白发的中年男子，身体精瘦、精神饱满、看起来充满了力量，他操着一口相对于当地人来说非常纯粹的普通话，给我留下了非常深刻的印象。当听他提起他自己已经55岁时，我的内心泛起了波澜。</p>
<p>这是一位和我的父亲一般年龄的中年人啊~在这个年龄，他居然选择了创业，着实让我大吃一惊。</p>
<p>当然，他显然非常的专业，在简单概要的介绍了公司的创业方向、拥有的背景和资源之后，让我深刻的体会到，他一定是想干一番大事业。</p>
<p>于是，我毫不犹豫的加入了公司，并期待在这里开启职场的新征程。</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p>创业公司的发展，总是跌宕起伏，看似波澜不惊，其实暗藏杀机。尤其是选择合适的人才，更是难点中的难点。谁都想选择最优秀的人才，但是在优秀的专业人才和优秀的跨职能型人才间，其实非常难以选择。</p>
<p>还好，本人算是一个勉强称职的跨职能型开发者，在我们部门的经理离职之后，毅然扛起了部门的重担，为公司勉强完成了一个非常不错的项目，使得公司能够获得短暂的喘息之机。</p>
<p>但是老w所在的项目，却面临了巨大的问题。</p>
<p>首先是优秀人才的缺失，毕竟能够深刻领悟如何基于物联网技术构建平台的应用开发者，在当时非常的稀缺，更何况公司所能付出的资源（要钱没钱，要股份没股份）其实非常有限，也显然很难招到合适的人才，而这仅仅只是我所看到的web开发方面，还有更严重的方面是物联网基础技术方面。</p>
<p>说来也搞笑，没有物联网基础技术，又如何做物联网产品呢？其实倒也不完全没有积累，这位老板和物联网部门的负责人曾经参与创办了另外一家非常优秀的物联网公司H公司，他们花了十年时间让这家公司从无到有，到做到国际一流。后来H公司业绩到了瓶颈，他们想为公司开辟新的业务方向，才创建了这家新的物联网公司。但是虽然同是物联网创业方向，但选择的技术路线和实现模式却不尽相同，而在新的技术路线上公司的积累非常浅。而在最关键的时候，拥有核心开发能力的一位嵌入式系统开发者，居然只打了个招呼，连交接和培训新人都没有认真开展就离开了公司，使得公司技术层面面临巨大的断层。</p>
<p>为了完成这个项目，Y总只好自己迎难而上。那段时间他不得不捡起曾经荒废多年的嵌入式系统开发技术，天天加班到深夜。每天早上又最早来到公司，恨不能尽早完成目标。</p>
<p>他就不怕猝死么？显然，他是怕的。但为了公司的生存，其实他别无选择。</p>
<h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><p>我曾经冒昧的问过他选择创业的原因，他只是轻轻一笑，还不是为了实现自己创业的梦想？</p>
<p>显然他不愿意过多的描述。但是联想到Y总的职业生涯，我大概能猜到一部分原因。</p>
<p>Y总虽然是北方人，但是在这片热土已经呆了三十几年。八十年代在第一大学就读的Y总，年轻时学习成绩特别好，不仅保送本校研究生，还直博，方向是某个热门的领域。当博士毕业后，也许他也曾想去沿海地区发展，但是他最终留下来主导该校的某领域的学术研究。</p>
<p>又过了几年，市场经济放开的九十年代，他也有许多选择的机会。在该领域浸淫十几年的他，一定收到了许多沿海企业或外资企业的聘书，但是他并没有做出这样的选择。</p>
<p>又过了十年，四十岁，他已经决定放开手脚出去干一场时，又是家庭压力最大的时候。也许去沿海城市会让他家庭和事业难以兼顾，他最终还是没有迈出哪一步。</p>
<p>一晃五十岁，他从学校退休。子女也出过留学，得到了顶级互联网公司的offer，基本上算是没什么压力了。</p>
<p>也许，从二十几岁到五十几岁，他错过了太多的机会。</p>
<p>他也曾经偶尔提到那些跟他一起读书的同学，或者研究所的同事，在离开象牙塔后，有的加入了互联网公司花了十年时间获得了财富自由，有的甚至创办了挺不错的公司。</p>
<p>Y总虽然也曾参与了一家公司的创办过程，却并没有从零开始创办一家属于自己的公司，而且他自认为这家公司虽然业务还算稳定，但在技术上，不能算卓越，只能算优秀。由于没有赶上风口，所以做得非常费力；而且行业领域非常狭小，很难获得更大的发展。</p>
<p>他显然想挑战自己。</p>
<h1 id="五"><a href="#五" class="headerlink" title="五"></a>五</h1><p>然而，创业难，难于上青天。</p>
<p>我也最终选择了离开这家公司。依稀记得Y总说过的话：“人生短短80年，其中从二十几岁毕业到六十多岁退休，期间有四十年时间。如果抱着把行业当做一辈子的心态，就该前二十年学经验，后二十年才能有经验可以用。”</p>
<p>当然，没有任何一个人敢说自己的技能能够通吃一辈子，也不可能每个人都会在一个公司、一份工作上干一辈子，变化才是人生的常态。适应变化和主动学习，正是人的基本能力。尤其是程序员，有许多程序员能够花十年赚到二十年才能赚到的钱，但是之后呢？年纪轻轻三十岁就养老吗？</p>
<p>学习这条路，其实根本没有终点。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">溪源</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">65</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">categories</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.cnblogs.com/xiyuanmore" title="博客园 &rarr; https://www.cnblogs.com/xiyuanmore" rel="noopener" target="_blank"><i class="fa fa-fw fa-博客园"></i>博客园</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/farway000" title="CSDN &rarr; https://blog.csdn.net/farway000" rel="noopener" target="_blank"><i class="fa fa-fw fa-CSDN"></i>CSDN</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">溪源</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.2</div>
#<div><a href="http://www.beian.miit.gov.cn/">ICP备案号:湘ICP备19001531号-2</a></div>



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
